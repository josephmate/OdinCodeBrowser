<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.rmi.rmic.newrmic.jrmp;

import com.sun.javadoc.ClassDoc;
import com.sun.javadoc.MethodDoc;
import com.sun.javadoc.Type;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import sun.rmi.rmic.newrmic.BatchEnvironment;
import sun.rmi.rmic.newrmic.IndentingWriter;

import static sun.rmi.rmic.newrmic.Constants.*;
import static sun.rmi.rmic.newrmic.jrmp.Constants.*;

/**
 * Writes the source code for the stub class and (optionally) skeleton
 * class for a particular remote implementation class.
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 *
 * @author Peter Jones
 **/
class StubSkeletonWriter {

    /** rmic environment for this object */
    private final BatchEnvironment env;

    /** the remote implementation class to generate code for */
    private final RemoteClass remoteClass;

    /** version of the JRMP stub protocol to generate code for */
    private final StubVersion version;

    /*
     * binary names of the stub and skeleton classes to generate for
     * the remote class
     */
    private final String stubClassName;
    private final String skeletonClassName;

    /* package name and simple names of the stub and skeleton classes */
    private final String packageName;
    private final String stubClassSimpleName;
    private final String skeletonClassSimpleName;

    /** remote methods of class, indexed by operation number */
    private final RemoteClass.Method[] remoteMethods;

    /**
     * Names to use for the java.lang.reflect.Method static fields in
     * the generated stub class corresponding to each remote method.
     **/
    private final String[] methodFieldNames;

    /**
     * Creates a StubSkeletonWriter instance for the specified remote
     * implementation class.  The generated code will implement the
     * specified JRMP stub protocol version.
     **/
    StubSkeletonWriter(BatchEnvironment env,
                       RemoteClass remoteClass,
                       StubVersion version)
    {
        this.env = env;
        this.remoteClass = remoteClass;
        this.version = version;

        stubClassName = Util.binaryNameOf(remoteClass.classDoc()) + &quot;_Stub&quot;;
        skeletonClassName =
            Util.binaryNameOf(remoteClass.classDoc()) + &quot;_Skel&quot;;

        int i = stubClassName.lastIndexOf('.');
        packageName = (i != -1 ? stubClassName.substring(0, i) : &quot;&quot;);
        stubClassSimpleName = stubClassName.substring(i + 1);
        skeletonClassSimpleName = skeletonClassName.substring(i + 1);

        remoteMethods = remoteClass.remoteMethods();
        methodFieldNames = nameMethodFields(remoteMethods);
    }

    /**
     * Returns the binary name of the stub class to generate for the
     * remote implementation class.
     **/
    String stubClassName() {
        return stubClassName;
    }

    /**
     * Returns the binary name of the skeleton class to generate for
     * the remote implementation class.
     **/
    String skeletonClassName() {
        return skeletonClassName;
    }

    /**
     * Writes the stub class for the remote class to a stream.
     **/
    void writeStub(IndentingWriter p) throws IOException {

        /*
         * Write boiler plate comment.
         */
        p.pln(&quot;// Stub class generated by rmic, do not edit.&quot;);
        p.pln(&quot;// Contents subject to change without notice.&quot;);
        p.pln();

        /*
         * If remote implementation class was in a particular package,
         * declare the stub class to be in the same package.
         */
        if (!packageName.equals(&quot;&quot;)) {
            p.pln(&quot;package &quot; + packageName + &quot;;&quot;);
            p.pln();
        }

        /*
         * Declare the stub class; implement all remote interfaces.
         */
        p.plnI(&quot;public final class &quot; + stubClassSimpleName);
        p.pln(&quot;extends &quot; + REMOTE_STUB);
        ClassDoc[] remoteInterfaces = remoteClass.remoteInterfaces();
        if (remoteInterfaces.length &gt; 0) {
            p.p(&quot;implements &quot;);
            for (int i = 0; i &lt; remoteInterfaces.length; i++) {
                if (i &gt; 0) {
                    p.p(&quot;, &quot;);
                }
                p.p(remoteInterfaces[i].qualifiedName());
            }
            p.pln();
        }
        p.pOlnI(&quot;{&quot;);

        if (version == StubVersion.V1_1 ||
            version == StubVersion.VCOMPAT)
        {
            writeOperationsArray(p);
            p.pln();
            writeInterfaceHash(p);
            p.pln();
        }

        if (version == StubVersion.VCOMPAT ||
            version == StubVersion.V1_2)
        {
            p.pln(&quot;private static final long serialVersionUID = &quot; +
                STUB_SERIAL_VERSION_UID + &quot;;&quot;);
            p.pln();

            /*
             * We only need to declare and initialize the static fields of
             * Method objects for each remote method if there are any remote
             * methods; otherwise, skip this code entirely, to avoid generating
             * a try/catch block for a checked exception that cannot occur
             * (see bugid 4125181).
             */
            if (methodFieldNames.length &gt; 0) {
                if (version == StubVersion.VCOMPAT) {
                    p.pln(&quot;private static boolean useNewInvoke;&quot;);
                }
                writeMethodFieldDeclarations(p);
                p.pln();

                /*
                 * Initialize java.lang.reflect.Method fields for each remote
                 * method in a static initializer.
                 */
                p.plnI(&quot;static {&quot;);
                p.plnI(&quot;try {&quot;);
                if (version == StubVersion.VCOMPAT) {
                    /*
                     * Fat stubs must determine whether the API required for
                     * the JDK 1.2 stub protocol is supported in the current
                     * runtime, so that it can use it if supported.  This is
                     * determined by using the Reflection API to test if the
                     * new invoke method on RemoteRef exists, and setting the
                     * static boolean &quot;useNewInvoke&quot; to true if it does, or
                     * to false if a NoSuchMethodException is thrown.
                     */
                    p.plnI(REMOTE_REF + &quot;.class.getMethod(\&quot;invoke\&quot;,&quot;);
                    p.plnI(&quot;new java.lang.Class[] {&quot;);
                    p.pln(REMOTE + &quot;.class,&quot;);
                    p.pln(&quot;java.lang.reflect.Method.class,&quot;);
                    p.pln(&quot;java.lang.Object[].class,&quot;);
                    p.pln(&quot;long.class&quot;);
                    p.pOln(&quot;});&quot;);
                    p.pO();
                    p.pln(&quot;useNewInvoke = true;&quot;);
                }
                writeMethodFieldInitializers(p);
                p.pOlnI(&quot;} catch (java.lang.NoSuchMethodException e) {&quot;);
                if (version == StubVersion.VCOMPAT) {
                    p.pln(&quot;useNewInvoke = false;&quot;);
                } else {
                    p.plnI(&quot;throw new java.lang.NoSuchMethodError(&quot;);
                    p.pln(&quot;\&quot;stub class initialization failed\&quot;);&quot;);
                    p.pO();
                }
                p.pOln(&quot;}&quot;);            // end try/catch block
                p.pOln(&quot;}&quot;);            // end static initializer
                p.pln();
            }
        }

        writeStubConstructors(p);
        p.pln();

        /*
         * Write each stub method.
         */
        if (remoteMethods.length &gt; 0) {
            p.pln(&quot;// methods from remote interfaces&quot;);
            for (int i = 0; i &lt; remoteMethods.length; ++i) {
                p.pln();
                writeStubMethod(p, i);
            }
        }

        p.pOln(&quot;}&quot;);                    // end stub class
    }

    /**
     * Writes the constructors for the stub class.
     **/
    private void writeStubConstructors(IndentingWriter p)
        throws IOException
    {
        p.pln(&quot;// constructors&quot;);

        /*
         * Only stubs compatible with the JDK 1.1 stub protocol need
         * a no-arg constructor; later versions use reflection to find
         * the constructor that directly takes a RemoteRef argument.
         */
        if (version == StubVersion.V1_1 ||
            version == StubVersion.VCOMPAT)
        {
            p.plnI(&quot;public &quot; + stubClassSimpleName + &quot;() {&quot;);
            p.pln(&quot;super();&quot;);
            p.pOln(&quot;}&quot;);
        }

        p.plnI(&quot;public &quot; + stubClassSimpleName + &quot;(&quot; + REMOTE_REF + &quot; ref) {&quot;);
        p.pln(&quot;super(ref);&quot;);
        p.pOln(&quot;}&quot;);
    }

    /**
     * Writes the stub method for the remote method with the given
     * operation number.
     **/
    private void writeStubMethod(IndentingWriter p, int opnum)
        throws IOException
    {
        RemoteClass.Method method = remoteMethods[opnum];
        MethodDoc methodDoc = method.methodDoc();
        String methodName = methodDoc.name();
        Type[] paramTypes = method.parameterTypes();
        String paramNames[] = nameParameters(paramTypes);
        Type returnType = methodDoc.returnType();
        ClassDoc[] exceptions = method.exceptionTypes();

        /*
         * Declare stub method; throw exceptions declared in remote
         * interface(s).
         */
        p.pln(&quot;// implementation of &quot; +
              Util.getFriendlyUnqualifiedSignature(methodDoc));
        p.p(&quot;public &quot; + returnType.toString() + &quot; &quot; + methodName + &quot;(&quot;);
        for (int i = 0; i &lt; paramTypes.length; i++) {
            if (i &gt; 0) {
                p.p(&quot;, &quot;);
            }
            p.p(paramTypes[i].toString() + &quot; &quot; + paramNames[i]);
        }
        p.plnI(&quot;)&quot;);
        if (exceptions.length &gt; 0) {
            p.p(&quot;throws &quot;);
            for (int i = 0; i &lt; exceptions.length; i++) {
                if (i &gt; 0) {
                    p.p(&quot;, &quot;);
                }
                p.p(exceptions[i].qualifiedName());
            }
            p.pln();
        }
        p.pOlnI(&quot;{&quot;);

        /*
         * The RemoteRef.invoke methods throw Exception, but unless
         * this stub method throws Exception as well, we must catch
         * Exceptions thrown from the invocation.  So we must catch
         * Exception and rethrow something we can throw:
         * UnexpectedException, which is a subclass of
         * RemoteException.  But for any subclasses of Exception that
         * we can throw, like RemoteException, RuntimeException, and
         * any of the exceptions declared by this stub method, we want
         * them to pass through unmodified, so first we must catch any
         * such exceptions and rethrow them directly.
         *
         * We have to be careful generating the rethrowing catch
         * blocks here, because javac will flag an error if there are
         * any unreachable catch blocks, i.e. if the catch of an
         * exception class follows a previous catch of it or of one of
         * its superclasses.  The following method invocation takes
         * care of these details.
         */
        List&lt;ClassDoc&gt; catchList = computeUniqueCatchList(exceptions);

        /*
         * If we need to catch any particular exceptions (i.e. this method
         * does not declare java.lang.Exception), put the entire stub
         * method in a try block.
         */
        if (catchList.size() &gt; 0) {
            p.plnI(&quot;try {&quot;);
        }

        if (version == StubVersion.VCOMPAT) {
            p.plnI(&quot;if (useNewInvoke) {&quot;);
        }
        if (version == StubVersion.VCOMPAT ||
            version == StubVersion.V1_2)
        {
            if (!Util.isVoid(returnType)) {
                p.p(&quot;Object $result = &quot;);               // REMIND: why $?
            }
            p.p(&quot;ref.invoke(this, &quot; + methodFieldNames[opnum] + &quot;, &quot;);
            if (paramTypes.length &gt; 0) {
                p.p(&quot;new java.lang.Object[] {&quot;);
                for (int i = 0; i &lt; paramTypes.length; i++) {
                    if (i &gt; 0)
                        p.p(&quot;, &quot;);
                    p.p(wrapArgumentCode(paramTypes[i], paramNames[i]));
                }
                p.p(&quot;}&quot;);
            } else {
                p.p(&quot;null&quot;);
            }
            p.pln(&quot;, &quot; + method.methodHash() + &quot;L);&quot;);
            if (!Util.isVoid(returnType)) {
                p.pln(&quot;return &quot; +
                    unwrapArgumentCode(returnType, &quot;$result&quot;) + &quot;;&quot;);
            }
        }
        if (version == StubVersion.VCOMPAT) {
            p.pOlnI(&quot;} else {&quot;);
        }
        if (version == StubVersion.V1_1 ||
            version == StubVersion.VCOMPAT)
        {
            p.pln(REMOTE_CALL + &quot; call = ref.newCall((&quot; + REMOTE_OBJECT +
                &quot;) this, operations, &quot; + opnum + &quot;, interfaceHash);&quot;);

            if (paramTypes.length &gt; 0) {
                p.plnI(&quot;try {&quot;);
                p.pln(&quot;java.io.ObjectOutput out = call.getOutputStream();&quot;);
                writeMarshalArguments(p, &quot;out&quot;, paramTypes, paramNames);
                p.pOlnI(&quot;} catch (java.io.IOException e) {&quot;);
                p.pln(&quot;throw new &quot; + MARSHAL_EXCEPTION +
                    &quot;(\&quot;error marshalling arguments\&quot;, e);&quot;);
                p.pOln(&quot;}&quot;);
            }

            p.pln(&quot;ref.invoke(call);&quot;);

            if (Util.isVoid(returnType)) {
                p.pln(&quot;ref.done(call);&quot;);
            } else {
                p.pln(returnType.toString() + &quot; $result;&quot;);
                                                        // REMIND: why $?
                p.plnI(&quot;try {&quot;);
                p.pln(&quot;java.io.ObjectInput in = call.getInputStream();&quot;);
                boolean objectRead =
                    writeUnmarshalArgument(p, &quot;in&quot;, returnType, &quot;$result&quot;);
                p.pln(&quot;;&quot;);
                p.pOlnI(&quot;} catch (java.io.IOException e) {&quot;);
                p.pln(&quot;throw new &quot; + UNMARSHAL_EXCEPTION +
                    &quot;(\&quot;error unmarshalling return\&quot;, e);&quot;);
                /*
                 * If any only if readObject has been invoked, we must catch
                 * ClassNotFoundException as well as IOException.
                 */
                if (objectRead) {
                    p.pOlnI(&quot;} catch (java.lang.ClassNotFoundException e) {&quot;);
                    p.pln(&quot;throw new &quot; + UNMARSHAL_EXCEPTION +
                        &quot;(\&quot;error unmarshalling return\&quot;, e);&quot;);
                }
                p.pOlnI(&quot;} finally {&quot;);
                p.pln(&quot;ref.done(call);&quot;);
                p.pOln(&quot;}&quot;);
                p.pln(&quot;return $result;&quot;);
            }
        }
        if (version == StubVersion.VCOMPAT) {
            p.pOln(&quot;}&quot;);                // end if/else (useNewInvoke) block
        }

        /*
         * If we need to catch any particular exceptions, finally write
         * the catch blocks for them, rethrow any other Exceptions with an
         * UnexpectedException, and end the try block.
         */
        if (catchList.size() &gt; 0) {
            for (ClassDoc catchClass : catchList) {
                p.pOlnI(&quot;} catch (&quot; + catchClass.qualifiedName() + &quot; e) {&quot;);
                p.pln(&quot;throw e;&quot;);
            }
            p.pOlnI(&quot;} catch (java.lang.Exception e) {&quot;);
            p.pln(&quot;throw new &quot; + UNEXPECTED_EXCEPTION +
                &quot;(\&quot;undeclared checked exception\&quot;, e);&quot;);
            p.pOln(&quot;}&quot;);                // end try/catch block
        }

        p.pOln(&quot;}&quot;);                    // end stub method
    }

    /**
     * Computes the exceptions that need to be caught and rethrown in
     * a stub method before wrapping Exceptions in
     * UnexpectedExceptions, given the exceptions declared in the
     * throws clause of the method.  Returns a list containing the
     * exception to catch.  Each exception is guaranteed to be unique,
     * i.e. not a subclass of any of the other exceptions in the list,
     * so the catch blocks for these exceptions may be generated in
     * any order relative to each other.
     *
     * RemoteException and RuntimeException are each automatically
     * placed in the returned list (unless any of their superclasses
     * are already present), since those exceptions should always be
     * directly rethrown by a stub method.
     *
     * The returned list will be empty if java.lang.Exception or one
     * of its superclasses is in the throws clause of the method,
     * indicating that no exceptions need to be caught.
     **/
    private List&lt;ClassDoc&gt; computeUniqueCatchList(ClassDoc[] exceptions) {
        List&lt;ClassDoc&gt; uniqueList = new ArrayList&lt;ClassDoc&gt;();

        uniqueList.add(env.docRuntimeException());
        uniqueList.add(env.docRemoteException()); // always catch/rethrow these

        /* For each exception declared by the stub method's throws clause: */
    nextException:
        for (ClassDoc ex : exceptions) {
            if (env.docException().subclassOf(ex)) {
                /*
                 * If java.lang.Exception (or a superclass) was declared
                 * in the throws clause of this stub method, then we don't
                 * have to bother catching anything; clear the list and
                 * return.
                 */
                uniqueList.clear();
                break;
            } else if (!ex.subclassOf(env.docException())) {
                /*
                 * Ignore other Throwables that do not extend Exception,
                 * because they cannot be thrown by the invoke methods.
                 */
                continue;
            }
            /*
             * Compare this exception against the current list of
             * exceptions that need to be caught:
             */
            for (Iterator&lt;ClassDoc&gt; i = uniqueList.iterator(); i.hasNext();) {
                ClassDoc ex2 = i.next();
                if (ex.subclassOf(ex2)) {
                    /*
                     * If a superclass of this exception is already on
                     * the list to catch, then ignore this one and continue;
                     */
                    continue nextException;
                } else if (ex2.subclassOf(ex)) {
                    /*
                     * If a subclass of this exception is on the list
                     * to catch, then remove it;
                     */
                    i.remove();
                }
            }
            /* This exception is unique: add it to the list to catch. */
            uniqueList.add(ex);
        }
        return uniqueList;
    }

    /**
     * Writes the skeleton for the remote class to a stream.
     **/
    void writeSkeleton(IndentingWriter p) throws IOException {
        if (version == StubVersion.V1_2) {
            throw new AssertionError(
                &quot;should not generate skeleton for version &quot; + version);
        }

        /*
         * Write boiler plate comment.
         */
        p.pln(&quot;// Skeleton class generated by rmic, do not edit.&quot;);
        p.pln(&quot;// Contents subject to change without notice.&quot;);
        p.pln();

        /*
         * If remote implementation class was in a particular package,
         * declare the skeleton class to be in the same package.
         */
        if (!packageName.equals(&quot;&quot;)) {
            p.pln(&quot;package &quot; + packageName + &quot;;&quot;);
            p.pln();
        }

        /*
         * Declare the skeleton class.
         */
        p.plnI(&quot;public final class &quot; + skeletonClassSimpleName);
        p.pln(&quot;implements &quot; + SKELETON);
        p.pOlnI(&quot;{&quot;);

        writeOperationsArray(p);
        p.pln();

        writeInterfaceHash(p);
        p.pln();

        /*
         * Define the getOperations() method.
         */
        p.plnI(&quot;public &quot; + OPERATION + &quot;[] getOperations() {&quot;);
        p.pln(&quot;return (&quot; + OPERATION + &quot;[]) operations.clone();&quot;);
        p.pOln(&quot;}&quot;);
        p.pln();

        /*
         * Define the dispatch() method.
         */
        p.plnI(&quot;public void dispatch(&quot; + REMOTE + &quot; obj, &quot; +
            REMOTE_CALL + &quot; call, int opnum, long hash)&quot;);
        p.pln(&quot;throws java.lang.Exception&quot;);
        p.pOlnI(&quot;{&quot;);

        if (version == StubVersion.VCOMPAT) {
            p.plnI(&quot;if (opnum &lt; 0) {&quot;);
            if (remoteMethods.length &gt; 0) {
                for (int opnum = 0; opnum &lt; remoteMethods.length; opnum++) {
                    if (opnum &gt; 0)
                        p.pO(&quot;} else &quot;);
                    p.plnI(&quot;if (hash == &quot; +
                        remoteMethods[opnum].methodHash() + &quot;L) {&quot;);
                    p.pln(&quot;opnum = &quot; + opnum + &quot;;&quot;);
                }
                p.pOlnI(&quot;} else {&quot;);
            }
            /*
             * Skeleton throws UnmarshalException if it does not recognize
             * the method hash; this is what UnicastServerRef.dispatch()
             * would do.
             */
            p.pln(&quot;throw new &quot; +
                UNMARSHAL_EXCEPTION + &quot;(\&quot;invalid method hash\&quot;);&quot;);
            if (remoteMethods.length &gt; 0) {
                p.pOln(&quot;}&quot;);
            }
            /*
             * Ignore the validation of the interface hash if the
             * operation number was negative, since it is really a
             * method hash instead.
             */
            p.pOlnI(&quot;} else {&quot;);
        }

        p.plnI(&quot;if (hash != interfaceHash)&quot;);
        p.pln(&quot;throw new &quot; +
            SKELETON_MISMATCH_EXCEPTION + &quot;(\&quot;interface hash mismatch\&quot;);&quot;);
        p.pO();

        if (version == StubVersion.VCOMPAT) {
            p.pOln(&quot;}&quot;);                // end if/else (opnum &lt; 0) block
        }
        p.pln();

        /*
         * Cast remote object reference to the remote implementation
         * class, if it's not private.  We don't use the binary name
         * of the class like previous implementations did because that
         * would not compile with javac (since 1.4.1).  If the remote
         * implementation class is private, then we can't cast to it
         * like previous implementations did because that also would
         * not compile with javac-- so instead, we'll have to try to
         * cast to the remote interface for each remote method.
         */
        if (!remoteClass.classDoc().isPrivate()) {
            p.pln(remoteClass.classDoc().qualifiedName() + &quot; server = (&quot; +
                  remoteClass.classDoc().qualifiedName() + &quot;) obj;&quot;);
        }

        /*
         * Process call according to the operation number.
         */
        p.plnI(&quot;switch (opnum) {&quot;);
        for (int opnum = 0; opnum &lt; remoteMethods.length; opnum++) {
            writeSkeletonDispatchCase(p, opnum);
        }
        p.pOlnI(&quot;default:&quot;);
        /*
         * Skeleton throws UnmarshalException if it does not recognize
         * the operation number; this is consistent with the case of an
         * unrecognized method hash.
         */
        p.pln(&quot;throw new &quot; + UNMARSHAL_EXCEPTION +
            &quot;(\&quot;invalid method number\&quot;);&quot;);
        p.pOln(&quot;}&quot;);                    // end switch statement

        p.pOln(&quot;}&quot;);                    // end dispatch() method

        p.pOln(&quot;}&quot;);                    // end skeleton class
    }

    /**
     * Writes the case block for the skeleton's dispatch method for
     * the remote method with the given &quot;opnum&quot;.
     **/
    private void writeSkeletonDispatchCase(IndentingWriter p, int opnum)
        throws IOException
    {
        RemoteClass.Method method = remoteMethods[opnum];
        MethodDoc methodDoc = method.methodDoc();
        String methodName = methodDoc.name();
        Type paramTypes[] = method.parameterTypes();
        String paramNames[] = nameParameters(paramTypes);
        Type returnType = methodDoc.returnType();

        p.pOlnI(&quot;case &quot; + opnum + &quot;: // &quot; +
            Util.getFriendlyUnqualifiedSignature(methodDoc));
        /*
         * Use nested block statement inside case to provide an independent
         * namespace for local variables used to unmarshal parameters for
         * this remote method.
         */
        p.pOlnI(&quot;{&quot;);

        if (paramTypes.length &gt; 0) {
            /*
             * Declare local variables to hold arguments.
             */
            for (int i = 0; i &lt; paramTypes.length; i++) {
                p.pln(paramTypes[i].toString() + &quot; &quot; + paramNames[i] + &quot;;&quot;);
            }

            /*
             * Unmarshal arguments from call stream.
             */
            p.plnI(&quot;try {&quot;);
            p.pln(&quot;java.io.ObjectInput in = call.getInputStream();&quot;);
            boolean objectsRead = writeUnmarshalArguments(p, &quot;in&quot;,
                paramTypes, paramNames);
            p.pOlnI(&quot;} catch (java.io.IOException e) {&quot;);
            p.pln(&quot;throw new &quot; + UNMARSHAL_EXCEPTION +
                &quot;(\&quot;error unmarshalling arguments\&quot;, e);&quot;);
            /*
             * If any only if readObject has been invoked, we must catch
             * ClassNotFoundException as well as IOException.
             */
            if (objectsRead) {
                p.pOlnI(&quot;} catch (java.lang.ClassNotFoundException e) {&quot;);
                p.pln(&quot;throw new &quot; + UNMARSHAL_EXCEPTION +
                    &quot;(\&quot;error unmarshalling arguments\&quot;, e);&quot;);
            }
            p.pOlnI(&quot;} finally {&quot;);
            p.pln(&quot;call.releaseInputStream();&quot;);
            p.pOln(&quot;}&quot;);
        } else {
            p.pln(&quot;call.releaseInputStream();&quot;);
        }

        if (!Util.isVoid(returnType)) {
            /*
             * Declare variable to hold return type, if not void.
             */
            p.p(returnType.toString() + &quot; $result = &quot;);
                                                        // REMIND: why $?
        }

        /*
         * Invoke the method on the server object.  If the remote
         * implementation class is private, then we don't have a
         * reference cast to it, and so we try to cast to the remote
         * object reference to the method's declaring interface here.
         */
        String target = remoteClass.classDoc().isPrivate() ?
            &quot;((&quot; + methodDoc.containingClass().qualifiedName() + &quot;) obj)&quot; :
            &quot;server&quot;;
        p.p(target + &quot;.&quot; + methodName + &quot;(&quot;);
        for (int i = 0; i &lt; paramNames.length; i++) {
            if (i &gt; 0)
                p.p(&quot;, &quot;);
            p.p(paramNames[i]);
        }
        p.pln(&quot;);&quot;);

        /*
         * Always invoke getResultStream(true) on the call object to send
         * the indication of a successful invocation to the caller.  If
         * the return type is not void, keep the result stream and marshal
         * the return value.
         */
        p.plnI(&quot;try {&quot;);
        if (!Util.isVoid(returnType)) {
            p.p(&quot;java.io.ObjectOutput out = &quot;);
        }
        p.pln(&quot;call.getResultStream(true);&quot;);
        if (!Util.isVoid(returnType)) {
            writeMarshalArgument(p, &quot;out&quot;, returnType, &quot;$result&quot;);
            p.pln(&quot;;&quot;);
        }
        p.pOlnI(&quot;} catch (java.io.IOException e) {&quot;);
        p.pln(&quot;throw new &quot; +
            MARSHAL_EXCEPTION + &quot;(\&quot;error marshalling return\&quot;, e);&quot;);
        p.pOln(&quot;}&quot;);

        p.pln(&quot;break;&quot;);                // break from switch statement

        p.pOlnI(&quot;}&quot;);                   // end nested block statement
        p.pln();
    }

    /**
     * Writes declaration and initializer for &quot;operations&quot; static array.
     **/
    private void writeOperationsArray(IndentingWriter p)
        throws IOException
    {
        p.plnI(&quot;private static final &quot; + OPERATION + &quot;[] operations = {&quot;);
        for (int i = 0; i &lt; remoteMethods.length; i++) {
            if (i &gt; 0)
                p.pln(&quot;,&quot;);
            p.p(&quot;new &quot; + OPERATION + &quot;(\&quot;&quot; +
                remoteMethods[i].operationString() + &quot;\&quot;)&quot;);
        }
        p.pln();
        p.pOln(&quot;};&quot;);
    }

    /**
     * Writes declaration and initializer for &quot;interfaceHash&quot; static field.
     **/
    private void writeInterfaceHash(IndentingWriter p)
        throws IOException
    {
        p.pln(&quot;private static final long interfaceHash = &quot; +
            remoteClass.interfaceHash() + &quot;L;&quot;);
    }

    /**
     * Writes declaration for java.lang.reflect.Method static fields
     * corresponding to each remote method in a stub.
     **/
    private void writeMethodFieldDeclarations(IndentingWriter p)
        throws IOException
    {
        for (String name : methodFieldNames) {
            p.pln(&quot;private static java.lang.reflect.Method &quot; + name + &quot;;&quot;);
        }
    }

    /**
     * Writes code to initialize the static fields for each method
     * using the Java Reflection API.
     **/
    private void writeMethodFieldInitializers(IndentingWriter p)
        throws IOException
    {
        for (int i = 0; i &lt; methodFieldNames.length; i++) {
            p.p(methodFieldNames[i] + &quot; = &quot;);
            /*
             * Look up the Method object in the somewhat arbitrary
             * interface that we find in the Method object.
             */
            RemoteClass.Method method = remoteMethods[i];
            MethodDoc methodDoc = method.methodDoc();
            String methodName = methodDoc.name();
            Type paramTypes[] = method.parameterTypes();

            p.p(methodDoc.containingClass().qualifiedName() + &quot;.class.getMethod(\&quot;&quot; +
                methodName + &quot;\&quot;, new java.lang.Class[] {&quot;);
            for (int j = 0; j &lt; paramTypes.length; j++) {
                if (j &gt; 0)
                    p.p(&quot;, &quot;);
                p.p(paramTypes[j].toString() + &quot;.class&quot;);
            }
            p.pln(&quot;});&quot;);
        }
    }


    /*
     * Following are a series of static utility methods useful during
     * the code generation process:
     */

    /**
     * Generates an array of names for fields correspondins to the
     * given array of remote methods.  Each name in the returned array
     * is guaranteed to be unique.
     *
     * The name of a method is included in its corresponding field
     * name to enhance readability of the generated code.
     **/
    private static String[] nameMethodFields(RemoteClass.Method[] methods) {
        String[] names = new String[methods.length];
        for (int i = 0; i &lt; names.length; i++) {
            names[i] = &quot;$method_&quot; + methods[i].methodDoc().name() + &quot;_&quot; + i;
        }
        return names;
    }

    /**
     * Generates an array of names for parameters corresponding to the
     * given array of types for the parameters.  Each name in the
     * returned array is guaranteed to be unique.
     *
     * A representation of the type of a parameter is included in its
     * corresponding parameter name to enhance the readability of the
     * generated code.
     **/
    private static String[] nameParameters(Type[] types) {
        String[] names = new String[types.length];
        for (int i = 0; i &lt; names.length; i++) {
            names[i] = &quot;$param_&quot; +
                generateNameFromType(types[i]) + &quot;_&quot; + (i + 1);
        }
        return names;
    }

    /**
     * Generates a readable string representing the given type
     * suitable for embedding within a Java identifier.
     **/
    private static String generateNameFromType(Type type) {
        String name = type.typeName().replace('.', '$');
        int dimensions = type.dimension().length() / 2;
        for (int i = 0; i &lt; dimensions; i++) {
            name = &quot;arrayOf_&quot; + name;
        }
        return name;
    }

    /**
     * Writes a snippet of Java code to marshal a value named &quot;name&quot;
     * of type &quot;type&quot; to the java.io.ObjectOutput stream named
     * &quot;stream&quot;.
     *
     * Primitive types are marshalled with their corresponding methods
     * in the java.io.DataOutput interface, and objects (including
     * arrays) are marshalled using the writeObject method.
     **/
    private static void writeMarshalArgument(IndentingWriter p,
                                             String streamName,
                                             Type type, String name)
        throws IOException
    {
        if (type.dimension().length() &gt; 0 || type.asClassDoc() != null) {
            p.p(streamName + &quot;.writeObject(&quot; + name + &quot;)&quot;);
        } else if (type.typeName().equals(&quot;boolean&quot;)) {
            p.p(streamName + &quot;.writeBoolean(&quot; + name + &quot;)&quot;);
        } else if (type.typeName().equals(&quot;byte&quot;)) {
            p.p(streamName + &quot;.writeByte(&quot; + name + &quot;)&quot;);
        } else if (type.typeName().equals(&quot;char&quot;)) {
            p.p(streamName + &quot;.writeChar(&quot; + name + &quot;)&quot;);
        } else if (type.typeName().equals(&quot;short&quot;)) {
            p.p(streamName + &quot;.writeShort(&quot; + name + &quot;)&quot;);
        } else if (type.typeName().equals(&quot;int&quot;)) {
            p.p(streamName + &quot;.writeInt(&quot; + name + &quot;)&quot;);
        } else if (type.typeName().equals(&quot;long&quot;)) {
            p.p(streamName + &quot;.writeLong(&quot; + name + &quot;)&quot;);
        } else if (type.typeName().equals(&quot;float&quot;)) {
            p.p(streamName + &quot;.writeFloat(&quot; + name + &quot;)&quot;);
        } else if (type.typeName().equals(&quot;double&quot;)) {
            p.p(streamName + &quot;.writeDouble(&quot; + name + &quot;)&quot;);
        } else {
            throw new AssertionError(type);
        }
    }

    /**
     * Writes Java statements to marshal a series of values in order
     * as named in the &quot;names&quot; array, with types as specified in the
     * &quot;types&quot; array, to the java.io.ObjectOutput stream named
     * &quot;stream&quot;.
     **/
    private static void writeMarshalArguments(IndentingWriter p,
                                              String streamName,
                                              Type[] types, String[] names)
        throws IOException
    {
        assert types.length == names.length;

        for (int i = 0; i &lt; types.length; i++) {
            writeMarshalArgument(p, streamName, types[i], names[i]);
            p.pln(&quot;;&quot;);
        }
    }

    /**
     * Writes a snippet of Java code to unmarshal a value of type
     * &quot;type&quot; from the java.io.ObjectInput stream named &quot;stream&quot; into
     * a variable named &quot;name&quot; (if &quot;name&quot; is null, the value is
     * unmarshalled and discarded).
     *
     * Primitive types are unmarshalled with their corresponding
     * methods in the java.io.DataInput interface, and objects
     * (including arrays) are unmarshalled using the readObject
     * method.
     *
     * Returns true if code to invoke readObject was written, and
     * false otherwise.
     **/
    private static boolean writeUnmarshalArgument(IndentingWriter p,
                                                  String streamName,
                                                  Type type, String name)
        throws IOException
    {
        boolean readObject = false;

        if (name != null) {
            p.p(name + &quot; = &quot;);
        }

        if (type.dimension().length() &gt; 0 || type.asClassDoc() != null) {
            p.p(&quot;(&quot; + type.toString() + &quot;) &quot; + streamName + &quot;.readObject()&quot;);
            readObject = true;
        } else if (type.typeName().equals(&quot;boolean&quot;)) {
            p.p(streamName + &quot;.readBoolean()&quot;);
        } else if (type.typeName().equals(&quot;byte&quot;)) {
            p.p(streamName + &quot;.readByte()&quot;);
        } else if (type.typeName().equals(&quot;char&quot;)) {
            p.p(streamName + &quot;.readChar()&quot;);
        } else if (type.typeName().equals(&quot;short&quot;)) {
            p.p(streamName + &quot;.readShort()&quot;);
        } else if (type.typeName().equals(&quot;int&quot;)) {
            p.p(streamName + &quot;.readInt()&quot;);
        } else if (type.typeName().equals(&quot;long&quot;)) {
            p.p(streamName + &quot;.readLong()&quot;);
        } else if (type.typeName().equals(&quot;float&quot;)) {
            p.p(streamName + &quot;.readFloat()&quot;);
        } else if (type.typeName().equals(&quot;double&quot;)) {
            p.p(streamName + &quot;.readDouble()&quot;);
        } else {
            throw new AssertionError(type);
        }

        return readObject;
    }

    /**
     * Writes Java statements to unmarshal a series of values in order
     * of types as in the &quot;types&quot; array from the java.io.ObjectInput
     * stream named &quot;stream&quot; into variables as named in &quot;names&quot; (for
     * any element of &quot;names&quot; that is null, the corresponding value is
     * unmarshalled and discarded).
     **/
    private static boolean writeUnmarshalArguments(IndentingWriter p,
                                                   String streamName,
                                                   Type[] types,
                                                   String[] names)
        throws IOException
    {
        assert types.length == names.length;

        boolean readObject = false;
        for (int i = 0; i &lt; types.length; i++) {
            if (writeUnmarshalArgument(p, streamName, types[i], names[i])) {
                readObject = true;
            }
            p.pln(&quot;;&quot;);
        }
        return readObject;
    }

    /**
     * Returns a snippet of Java code to wrap a value named &quot;name&quot; of
     * type &quot;type&quot; into an object as appropriate for use by the Java
     * Reflection API.
     *
     * For primitive types, an appropriate wrapper class is
     * instantiated with the primitive value.  For object types
     * (including arrays), no wrapping is necessary, so the value is
     * named directly.
     **/
    private static String wrapArgumentCode(Type type, String name) {
        if (type.dimension().length() &gt; 0 || type.asClassDoc() != null) {
            return name;
        } else if (type.typeName().equals(&quot;boolean&quot;)) {
            return (&quot;(&quot; + name +
                    &quot; ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE)&quot;);
        } else if (type.typeName().equals(&quot;byte&quot;)) {
            return &quot;new java.lang.Byte(&quot; + name + &quot;)&quot;;
        } else if (type.typeName().equals(&quot;char&quot;)) {
            return &quot;new java.lang.Character(&quot; + name + &quot;)&quot;;
        } else if (type.typeName().equals(&quot;short&quot;)) {
            return &quot;new java.lang.Short(&quot; + name + &quot;)&quot;;
        } else if (type.typeName().equals(&quot;int&quot;)) {
            return &quot;new java.lang.Integer(&quot; + name + &quot;)&quot;;
        } else if (type.typeName().equals(&quot;long&quot;)) {
            return &quot;new java.lang.Long(&quot; + name + &quot;)&quot;;
        } else if (type.typeName().equals(&quot;float&quot;)) {
            return &quot;new java.lang.Float(&quot; + name + &quot;)&quot;;
        } else if (type.typeName().equals(&quot;double&quot;)) {
            return &quot;new java.lang.Double(&quot; + name + &quot;)&quot;;
        } else {
            throw new AssertionError(type);
        }
    }

    /**
     * Returns a snippet of Java code to unwrap a value named &quot;name&quot;
     * into a value of type &quot;type&quot;, as appropriate for the Java
     * Reflection API.
     *
     * For primitive types, the value is assumed to be of the
     * corresponding wrapper class, and a method is called on the
     * wrapper to retrieve the primitive value.  For object types
     * (include arrays), no unwrapping is necessary; the value is
     * simply cast to the expected real object type.
     **/
    private static String unwrapArgumentCode(Type type, String name) {
        if (type.dimension().length() &gt; 0 || type.asClassDoc() != null) {
            return &quot;((&quot; + type.toString() + &quot;) &quot; + name + &quot;)&quot;;
        } else if (type.typeName().equals(&quot;boolean&quot;)) {
            return &quot;((java.lang.Boolean) &quot; + name + &quot;).booleanValue()&quot;;
        } else if (type.typeName().equals(&quot;byte&quot;)) {
            return &quot;((java.lang.Byte) &quot; + name + &quot;).byteValue()&quot;;
        } else if (type.typeName().equals(&quot;char&quot;)) {
            return &quot;((java.lang.Character) &quot; + name + &quot;).charValue()&quot;;
        } else if (type.typeName().equals(&quot;short&quot;)) {
            return &quot;((java.lang.Short) &quot; + name + &quot;).shortValue()&quot;;
        } else if (type.typeName().equals(&quot;int&quot;)) {
            return &quot;((java.lang.Integer) &quot; + name + &quot;).intValue()&quot;;
        } else if (type.typeName().equals(&quot;long&quot;)) {
            return &quot;((java.lang.Long) &quot; + name + &quot;).longValue()&quot;;
        } else if (type.typeName().equals(&quot;float&quot;)) {
            return &quot;((java.lang.Float) &quot; + name + &quot;).floatValue()&quot;;
        } else if (type.typeName().equals(&quot;double&quot;)) {
            return &quot;((java.lang.Double) &quot; + name + &quot;).doubleValue()&quot;;
        } else {
            throw new AssertionError(type);
        }
    }
}
</pre>
</body>
</html>
