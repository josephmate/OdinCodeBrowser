<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.jstat;

import java.io.*;
import java.net.*;
import java.util.*;
import java.util.regex.*;
import sun.jvmstat.monitor.Monitor;
import sun.jvmstat.monitor.VmIdentifier;

/**
 * Class for processing command line arguments and providing method
 * level access to arguments.
 *
 * @author Brian Doherty
 * @since 1.5
 */
public class Arguments {

    private static final boolean debug = Boolean.getBoolean(&quot;jstat.debug&quot;);
    private static final boolean showUnsupported =
            Boolean.getBoolean(&quot;jstat.showUnsupported&quot;);

    private static final String JVMSTAT_USERDIR = &quot;.jvmstat&quot;;
    private static final String OPTIONS_FILENAME = &quot;jstat_options&quot;;
    private static final String UNSUPPORTED_OPTIONS_FILENAME = &quot;jstat_unsupported_options&quot;;
    private static final String ALL_NAMES = &quot;\\w*&quot;;

    private Comparator&lt;Monitor&gt; comparator;
    private int headerRate;
    private boolean help;
    private boolean list;
    private boolean options;
    private boolean constants;
    private boolean constantsOnly;
    private boolean strings;
    private boolean timestamp;
    private boolean snap;
    private boolean verbose;
    private String specialOption;
    private String names;

    private OptionFormat optionFormat;

    private int count = -1;
    private int interval = -1;
    private String vmIdString;

    private VmIdentifier vmId;

    public static void printUsage(PrintStream ps) {
        ps.println(&quot;Usage: jstat -help|-options&quot;);
        ps.println(&quot;       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]&quot;);
        ps.println();
        ps.println(&quot;Definitions:&quot;);
        ps.println(&quot;  &lt;option&gt;      An option reported by the -options option&quot;);
        ps.println(&quot;  &lt;vmid&gt;        Virtual Machine Identifier. A vmid takes the following form:&quot;);
        ps.println(&quot;                     &lt;lvmid&gt;[@&lt;hostname&gt;[:&lt;port&gt;]]&quot;);
        ps.println(&quot;                Where &lt;lvmid&gt; is the local vm identifier for the target&quot;);
        ps.println(&quot;                Java virtual machine, typically a process id; &lt;hostname&gt; is&quot;);
        ps.println(&quot;                the name of the host running the target Java virtual machine;&quot;);
        ps.println(&quot;                and &lt;port&gt; is the port number for the rmiregistry on the&quot;);
        ps.println(&quot;                target host. See the jvmstat documentation for a more complete&quot;);
        ps.println(&quot;                description of the Virtual Machine Identifier.&quot;);
        ps.println(&quot;  &lt;lines&gt;       Number of samples between header lines.&quot;);
        ps.println(&quot;  &lt;interval&gt;    Sampling interval. The following forms are allowed:&quot;);
        ps.println(&quot;                    &lt;n&gt;[\&quot;ms\&quot;|\&quot;s\&quot;]&quot;);
        ps.println(&quot;                Where &lt;n&gt; is an integer and the suffix specifies the units as &quot;);
        ps.println(&quot;                milliseconds(\&quot;ms\&quot;) or seconds(\&quot;s\&quot;). The default units are \&quot;ms\&quot;.&quot;);
        ps.println(&quot;  &lt;count&gt;       Number of samples to take before terminating.&quot;);
        ps.println(&quot;  -J&lt;flag&gt;      Pass &lt;flag&gt; directly to the runtime system.&quot;);

        // undocumented options:
        //   -list [&lt;vmid&gt;]  - list counter names
        //   -snap &lt;vmid&gt;    - snapshot counter values as name=value pairs
        //   -name &lt;pattern&gt; - output counters matching given pattern
        //   -a              - sort in ascending order (default)
        //   -d              - sort in descending order
        //   -v              - verbose output  (-snap)
        //   -constants      - output constants with -name output
        //   -strings        - output strings with -name output
    }

    private static int toMillis(String s) throws IllegalArgumentException {

        String[] unitStrings = { &quot;ms&quot;, &quot;s&quot; }; // ordered from most specific to
                                              // least specific
        String unitString = null;
        String valueString = s;

        for (int i = 0; i &lt; unitStrings.length; i++) {
            int index = s.indexOf(unitStrings[i]);
            if (index &gt; 0) {
                unitString = s.substring(index);
                valueString = s.substring(0, index);
                break;
            }
        }

        try {
            int value = Integer.parseInt(valueString);

            if (unitString == null || unitString.compareTo(&quot;ms&quot;) == 0) {
                return value;
            } else if (unitString.compareTo(&quot;s&quot;) == 0) {
                return value * 1000;
            } else {
                throw new IllegalArgumentException(
                        &quot;Unknow time unit: &quot; + unitString);
            }
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException(
                    &quot;Could not convert interval: &quot; + s);
        }
    }

    public Arguments(String[] args) throws IllegalArgumentException {
        int argc = 0;

        if (args.length &lt; 1) {
            throw new IllegalArgumentException(&quot;invalid argument count&quot;);
        }

        if ((args[0].compareTo(&quot;-?&quot;) == 0)
                || (args[0].compareTo(&quot;-help&quot;) == 0)) {
            help = true;
            return;
        } else if (args[0].compareTo(&quot;-options&quot;) == 0) {
            options = true;
            return;
        } else if (args[0].compareTo(&quot;-list&quot;) == 0) {
            list = true;
            if (args.length &gt; 2) {
              throw new IllegalArgumentException(&quot;invalid argument count&quot;);
            }
            // list can take one arg - a vmid - fall through for arg processing
            argc++;
        }

        for ( ; (argc &lt; args.length) &amp;&amp; (args[argc].startsWith(&quot;-&quot;)); argc++) {
            String arg = args[argc];

            if (arg.compareTo(&quot;-a&quot;) == 0) {
                comparator = new AscendingMonitorComparator();
            } else if (arg.compareTo(&quot;-d&quot;) == 0) {
                comparator =  new DescendingMonitorComparator();
            } else if (arg.compareTo(&quot;-t&quot;) == 0) {
                timestamp = true;
            } else if (arg.compareTo(&quot;-v&quot;) == 0) {
                verbose = true;
            } else if ((arg.compareTo(&quot;-constants&quot;) == 0)
                       || (arg.compareTo(&quot;-c&quot;) == 0)) {
                constants = true;
            } else if ((arg.compareTo(&quot;-strings&quot;) == 0)
                       || (arg.compareTo(&quot;-s&quot;) == 0)) {
                strings = true;
            } else if (arg.startsWith(&quot;-h&quot;)) {
                String value;
                if (arg.compareTo(&quot;-h&quot;) != 0) {
                    value = arg.substring(2);
                } else {
                    argc++;
                    if (argc &gt;= args.length) {
                        throw new IllegalArgumentException(
                                &quot;-h requires an integer argument&quot;);
                    }
                    value = args[argc];
                }
                try {
                    headerRate = Integer.parseInt(value);
                } catch (NumberFormatException e) {
                    headerRate = -1;
                }
                if (headerRate &lt; 0) {
                    throw new IllegalArgumentException(
                            &quot;illegal -h argument: &quot; + value);
                }
            } else if (arg.startsWith(&quot;-name&quot;)) {
                if (arg.startsWith(&quot;-name=&quot;)) {
                    names = arg.substring(7);
                } else {
                    argc++;
                    if (argc &gt;= args.length) {
                        throw new IllegalArgumentException(
                                &quot;option argument expected&quot;);
                    }
                    names = args[argc];
                }
            } else {
                /*
                 * there are scenarios here: special jstat_options file option
                 * or the rare case of a negative lvmid. The negative lvmid
                 * can occur in some operating environments (such as Windows
                 * 95/98/ME), so we provide for this case here by checking if
                 * the argument has any numerical characters. This assumes that
                 * there are no special jstat_options that contain numerical
                 * characters in their name.
                 */

                // extract the lvmid part of possible lvmid@host.domain:port
                String lvmidStr = null;
                int at_index = args[argc].indexOf('@');
                if (at_index &lt; 0) {
                    lvmidStr = args[argc];
                } else {
                    lvmidStr = args[argc].substring(0, at_index);
                }

                // try to parse the lvmid part as an integer
                try {
                    int vmid = Integer.parseInt(lvmidStr);
                    // it parsed, assume a negative lvmid and continue
                    break;
                } catch (NumberFormatException nfe) {
                    // it didn't parse. check for the -snap or jstat_options
                    // file options.
                    if ((argc == 0) &amp;&amp; (args[argc].compareTo(&quot;-snap&quot;) == 0)) {
                        snap = true;
                    } else if (argc == 0) {
                        specialOption = args[argc].substring(1);
                    } else {
                        throw new IllegalArgumentException(
                                &quot;illegal argument: &quot; + args[argc]);
                    }
                }
            }
        }

        // prevent 'jstat &lt;pid&gt;' from being accepted as a valid argument
        if (!(specialOption != null || list || snap || names != null)) {
            throw new IllegalArgumentException(&quot;-&lt;option&gt; required&quot;);
        }

        switch (args.length - argc) {
        case 3:
            if (snap) {
                throw new IllegalArgumentException(&quot;invalid argument count&quot;);
            }
            try {
                count = Integer.parseInt(args[args.length-1]);
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException(&quot;illegal count value: &quot;
                                                   + args[args.length-1]);
            }
            interval = toMillis(args[args.length-2]);
            vmIdString = args[args.length-3];
            break;
        case 2:
            if (snap) {
                throw new IllegalArgumentException(&quot;invalid argument count&quot;);
            }
            interval = toMillis(args[args.length-1]);
            vmIdString = args[args.length-2];
            break;
        case 1:
            vmIdString = args[args.length-1];
            break;
        case 0:
            if (!list) {
                throw new IllegalArgumentException(&quot;invalid argument count&quot;);
            }
            break;
        default:
            throw new IllegalArgumentException(&quot;invalid argument count&quot;);
        }

        // set count and interval to their default values if not set above.
        if (count == -1 &amp;&amp; interval == -1) {
            // default is for a single sample
            count = 1;
            interval = 0;
        }

        // validate arguments
        if (comparator == null) {
            comparator = new AscendingMonitorComparator();
        }

        // allow ',' characters to separate names, convert to '|' chars
        names = (names == null) ? ALL_NAMES : names.replace(',', '|');

        // verify that the given pattern parses without errors
        try {
            Pattern pattern = Pattern.compile(names);
        } catch (PatternSyntaxException e) {
            throw new IllegalArgumentException(&quot;Bad name pattern: &quot;
                                               + e.getMessage());
        }

        // verify that the special option is valid and get it's formatter
        if (specialOption != null) {
            OptionFinder finder = new OptionFinder(optionsSources());
            optionFormat = finder.getOptionFormat(specialOption, timestamp);
            if (optionFormat == null) {
                throw new IllegalArgumentException(&quot;Unknown option: -&quot;
                                                   + specialOption);
            }
        }

        // verify that the vm identifier is valied
        try {
            vmId = new VmIdentifier(vmIdString);
        } catch (URISyntaxException e) {
            IllegalArgumentException iae = new IllegalArgumentException(
                    &quot;Malformed VM Identifier: &quot; + vmIdString);
            iae.initCause(e);
            throw iae;
        }
    }

    public Comparator&lt;Monitor&gt; comparator() {
        return comparator;
    }

    public boolean isHelp() {
        return help;
    }

    public boolean isList() {
        return list;
    }

    public boolean isSnap() {
        return snap;
    }

    public boolean isOptions() {
        return options;
    }

    public boolean isVerbose() {
        return verbose;
    }

    public boolean printConstants() {
        return constants;
    }

    public boolean isConstantsOnly() {
        return constantsOnly;
    }

    public boolean printStrings() {
        return strings;
    }

    public boolean showUnsupported() {
        return showUnsupported;
    }

    public int headerRate() {
        return headerRate;
    }

    public String counterNames() {
        return names;
    }

    public VmIdentifier vmId() {
        return vmId;
    }

    public String vmIdString() {
        return vmIdString;
    }

    public int sampleInterval() {
        return interval;
    }

    public int sampleCount() {
        return count;
    }

    public boolean isTimestamp() {
        return timestamp;
    }

    public boolean isSpecialOption() {
        return specialOption != null;
    }

    public String specialOption() {
        return specialOption;
    }

    public OptionFormat optionFormat() {
        return optionFormat;
    }

    public List&lt;URL&gt; optionsSources() {
        List&lt;URL&gt; sources = new ArrayList&lt;URL&gt;();
        int i = 0;

        String filename = OPTIONS_FILENAME;

        try {
            String userHome = System.getProperty(&quot;user.home&quot;);
            String userDir = userHome + &quot;/&quot; + JVMSTAT_USERDIR;
            File home = new File(userDir + &quot;/&quot; + filename);
            sources.add(home.toURI().toURL());
        } catch (Exception e) {
            if (debug) {
                System.err.println(e.getMessage());
                e.printStackTrace();
            }
            throw new IllegalArgumentException(&quot;Internal Error: Bad URL: &quot;
                                               + e.getMessage());
        }
        URL u = this.getClass().getResource(&quot;resources/&quot; + filename);
        assert u != null;
        sources.add(u);

        if (showUnsupported) {
            u = this.getClass().getResource(&quot;resources/&quot; +  UNSUPPORTED_OPTIONS_FILENAME);
            assert u != null;
            sources.add(u);
        }
        return sources;
    }
}
</pre>
</body>
</html>
