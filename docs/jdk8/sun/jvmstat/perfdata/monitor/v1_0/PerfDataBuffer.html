<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.jvmstat.perfdata.monitor.v1_0;

import sun.jvmstat.monitor.*;
import sun.jvmstat.perfdata.monitor.*;
import java.util.*;
import java.util.regex.*;
import java.nio.*;

/**
 * The concrete implementation of version 1.0 of the HotSpot PerfData
 * Instrumentation buffer. This class is responsible for parsing the
 * instrumentation memory and constructing the necessary objects to
 * represent and access the instrumentation objects contained in the
 * memory buffer.
 *
 * @author Brian Doherty
 * @since 1.5
 * @see AbstractPerfDataBuffer
 */
public class PerfDataBuffer extends PerfDataBufferImpl {

    private static final boolean DEBUG = false;
    private static final int syncWaitMs =
            Integer.getInteger(&quot;sun.jvmstat.perdata.syncWaitMs&quot;, 5000);
    private static final ArrayList EMPTY_LIST = new ArrayList(0);

    /*
     * the following constants must be kept in sync with struct
     * PerfDataEntry in perfMemory.hpp
     */
    private final static int PERFDATA_ENTRYLENGTH_OFFSET=0;
    private final static int PERFDATA_ENTRYLENGTH_SIZE=4;   // sizeof(int)
    private final static int PERFDATA_NAMELENGTH_OFFSET=4;
    private final static int PERFDATA_NAMELENGTH_SIZE=4;    // sizeof(int)
    private final static int PERFDATA_VECTORLENGTH_OFFSET=8;
    private final static int PERFDATA_VECTORLENGTH_SIZE=4;  // sizeof(int)
    private final static int PERFDATA_DATATYPE_OFFSET=12;
    private final static int PERFDATA_DATATYPE_SIZE=1;      // sizeof(byte)
    private final static int PERFDATA_FLAGS_OFFSET=13;
    private final static int PERFDATA_FLAGS_SIZE=1;        // sizeof(byte)
    private final static int PERFDATA_DATAUNITS_OFFSET=14;
    private final static int PERFDATA_DATAUNITS_SIZE=1;     // sizeof(byte)
    private final static int PERFDATA_DATAATTR_OFFSET=15;
    private final static int PERFDATA_DATAATTR_SIZE=1;      // sizeof(byte)
    private final static int PERFDATA_NAME_OFFSET=16;

    PerfDataBufferPrologue prologue;
    int nextEntry;
    int pollForEntry;
    int perfDataItem;
    long lastModificationTime;
    int lastUsed;
    IntegerMonitor overflow;
    ArrayList&lt;Monitor&gt; insertedMonitors;

    /**
     * Construct a PerfDataBufferImpl instance.
     * &lt;p&gt;
     * This class is dynamically loaded by
     * {@link AbstractPerfDataBuffer#createPerfDataBuffer}, and this
     * constructor is called to instantiate the instance.
     *
     * @param buffer the buffer containing the instrumentation data
     * @param lvmid the Local Java Virtual Machine Identifier for this
     *              instrumentation buffer.
     */
    public PerfDataBuffer(ByteBuffer buffer, int lvmid)
           throws MonitorException {
        super(buffer, lvmid);
        prologue = new PerfDataBufferPrologue(buffer);
        this.buffer.order(prologue.getByteOrder());
    }

    /**
     * {@inheritDoc}
     */
    protected void buildMonitorMap(Map&lt;String, Monitor&gt; map) throws MonitorException {
        assert Thread.holdsLock(this);

        // start at the beginning of the buffer
        buffer.rewind();

        // create pseudo monitors
        buildPseudoMonitors(map);

        // position buffer to start of the data section
        buffer.position(prologue.getSize());
        nextEntry = buffer.position();
        perfDataItem = 0;

        int used = prologue.getUsed();
        long modificationTime = prologue.getModificationTimeStamp();

        Monitor m = getNextMonitorEntry();
        while (m != null) {
            map.put(m.getName(), m);
            m = getNextMonitorEntry();
        }

        /*
         * set the last modification data. These are set to the values
         * recorded before parsing the data structure. This allows the
         * the data structure to be modified while the Map is being built.
         * The Map may contain more entries than indicated based on the
         * time stamp, but this is handled by ignoring duplicate entries
         * when the Map is updated in getNewMonitors().
         */
        lastUsed = used;
        lastModificationTime = modificationTime;

        // synchronize with the target jvm
        synchWithTarget(map);

        // work around 1.4.2 counter inititization bugs
        kludge(map);

        insertedMonitors = new ArrayList&lt;Monitor&gt;(map.values());
    }

    /**
     * {@inheritDoc}
     */
    protected void getNewMonitors(Map&lt;String, Monitor&gt; map) throws MonitorException {
        assert Thread.holdsLock(this);

        int used = prologue.getUsed();
        long modificationTime = prologue.getModificationTimeStamp();

        if ((used &gt; lastUsed) || (lastModificationTime &gt; modificationTime)) {

            lastUsed = used;
            lastModificationTime = modificationTime;

            Monitor monitor = getNextMonitorEntry();
            while (monitor != null) {
                String name = monitor.getName();

                // guard against duplicate entries
                if (!map.containsKey(name)) {
                    map.put(name, monitor);

                    /*
                     * insertedMonitors is null when called from pollFor()
                     * via buildMonitorMap(). Since we update insertedMonitors
                     * at the end of buildMonitorMap(), it's ok to skip the
                     * add here.
                     */
                    if (insertedMonitors != null) {
                        insertedMonitors.add(monitor);
                    }
                }
                monitor = getNextMonitorEntry();
            }
        }
    }

    /**
     * {@inheritDoc}
     */
    protected MonitorStatus getMonitorStatus(Map&lt;String, Monitor&gt; map) throws MonitorException {
        assert Thread.holdsLock(this);
        assert insertedMonitors != null;

        // load any new monitors
        getNewMonitors(map);

        // current implementation doesn't support deletion or reuse of entries
        ArrayList removed = EMPTY_LIST;
        ArrayList inserted = insertedMonitors;

        insertedMonitors = new ArrayList&lt;Monitor&gt;();
        return new MonitorStatus(inserted, removed);
    }

    /**
     * Build the pseudo monitors used to map the prolog data into counters.
     */
    protected void buildPseudoMonitors(Map&lt;String, Monitor&gt; map) {
        Monitor monitor = null;
        String name = null;
        IntBuffer ib = null;

        name = PerfDataBufferPrologue.PERFDATA_MAJOR_NAME;
        ib = prologue.majorVersionBuffer();
        monitor = new PerfIntegerMonitor(name, Units.NONE,
                                         Variability.CONSTANT, false, ib);
        map.put(name, monitor);

        name = PerfDataBufferPrologue.PERFDATA_MINOR_NAME;
        ib = prologue.minorVersionBuffer();
        monitor = new PerfIntegerMonitor(name, Units.NONE,
                                         Variability.CONSTANT, false, ib);
        map.put(name, monitor);

        name = PerfDataBufferPrologue.PERFDATA_BUFFER_SIZE_NAME;
        ib = prologue.sizeBuffer();
        monitor = new PerfIntegerMonitor(name, Units.BYTES,
                                         Variability.MONOTONIC, false, ib);
        map.put(name, monitor);

        name = PerfDataBufferPrologue.PERFDATA_BUFFER_USED_NAME;
        ib = prologue.usedBuffer();
        monitor = new PerfIntegerMonitor(name, Units.BYTES,
                                         Variability.MONOTONIC, false, ib);
        map.put(name, monitor);

        name = PerfDataBufferPrologue.PERFDATA_OVERFLOW_NAME;
        ib = prologue.overflowBuffer();
        monitor = new PerfIntegerMonitor(name, Units.BYTES,
                                         Variability.MONOTONIC, false, ib);
        map.put(name, monitor);
        this.overflow = (IntegerMonitor)monitor;

        name = PerfDataBufferPrologue.PERFDATA_MODTIMESTAMP_NAME;
        LongBuffer lb = prologue.modificationTimeStampBuffer();
        monitor = new PerfLongMonitor(name, Units.TICKS,
                                      Variability.MONOTONIC, false, lb);
        map.put(name, monitor);
    }

    /**
     * Method to provide a gross level of synchronization with the
     * target monitored jvm.
     *
     * gross synchronization works by polling for the hotspot.rt.hrt.ticks
     * counter, which is the last counter created by the StatSampler
     * initialization code. The counter is updated when the watcher thread
     * starts scheduling tasks, which is the last thing done in vm
     * initialization.
     */
    protected void synchWithTarget(Map&lt;String, Monitor&gt; map) throws MonitorException {
        /*
         * synch must happen with syncWaitMs from now. Default is 5 seconds,
         * which is reasonabally generous and should provide for extreme
         * situations like startup delays due to allocation of large ISM heaps.
         */
        long timeLimit = System.currentTimeMillis() + syncWaitMs;

        String name = &quot;hotspot.rt.hrt.ticks&quot;;
        LongMonitor ticks = (LongMonitor)pollFor(map, name, timeLimit);

        /*
         * loop waiting for the ticks counter to be non zero. This is
         * an indication that the jvm is initialized.
         */
        log(&quot;synchWithTarget: &quot; + lvmid + &quot; &quot;);
        while (ticks.longValue() == 0) {
            log(&quot;.&quot;);

            try { Thread.sleep(20); } catch (InterruptedException e) { }

            if (System.currentTimeMillis() &gt; timeLimit) {
                lognl(&quot;failed: &quot; + lvmid);
                throw new MonitorException(&quot;Could Not Synchronize with target&quot;);
            }
        }
        lognl(&quot;success: &quot; + lvmid);
    }

    /**
     * Method to poll the instrumentation memory for a counter with
     * the given name. The polling period is bounded by the timeLimit
     * argument.
     */
    protected Monitor pollFor(Map&lt;String, Monitor&gt; map, String name, long timeLimit)
                      throws MonitorException {
        Monitor monitor = null;

        log(&quot;polling for: &quot; + lvmid + &quot;,&quot; + name + &quot; &quot;);

        pollForEntry = nextEntry;
        while ((monitor = map.get(name)) == null) {
            log(&quot;.&quot;);

            try { Thread.sleep(20); } catch (InterruptedException e) { }

            long t = System.currentTimeMillis();
            if ((t &gt; timeLimit) || (overflow.intValue() &gt; 0)) {
                lognl(&quot;failed: &quot; + lvmid + &quot;,&quot; + name);
                dumpAll(map, lvmid);
                throw new MonitorException(&quot;Could not find expected counter&quot;);
            }

            getNewMonitors(map);
        }
        lognl(&quot;success: &quot; + lvmid + &quot;,&quot; + name);
        return monitor;
    }

    /**
     * method to make adjustments for known counter problems. This
     * method depends on the availability of certain counters, which
     * is generally guaranteed by the synchWithTarget() method.
     */
    protected void kludge(Map&lt;String, Monitor&gt; map) {
        if (Boolean.getBoolean(&quot;sun.jvmstat.perfdata.disableKludge&quot;)) {
            // bypass all kludges
            return;
        }

        String name = &quot;java.vm.version&quot;;
        StringMonitor jvm_version = (StringMonitor)map.get(name);
        if (jvm_version == null) {
            jvm_version = (StringMonitor)findByAlias(name);
        }

        name = &quot;java.vm.name&quot;;
        StringMonitor jvm_name = (StringMonitor)map.get(name);
        if (jvm_name == null) {
            jvm_name = (StringMonitor)findByAlias(name);
        }

        name = &quot;hotspot.vm.args&quot;;
        StringMonitor args = (StringMonitor)map.get(name);
        if (args == null) {
            args = (StringMonitor)findByAlias(name);
        }

        assert ((jvm_name != null) &amp;&amp; (jvm_version != null) &amp;&amp; (args != null));

        if (jvm_name.stringValue().indexOf(&quot;HotSpot&quot;) &gt;= 0) {
            if (jvm_version.stringValue().startsWith(&quot;1.4.2&quot;)) {
                kludgeMantis(map, args);
            }
        }
    }

    /**
     * method to repair the 1.4.2 parallel scavenge counters that are
     * incorrectly initialized by the JVM when UseAdaptiveSizePolicy
     * is set. This bug couldn't be fixed for 1.4.2 FCS due to putback
     * restrictions.
     */
    private void kludgeMantis(Map&lt;String, Monitor&gt; map, StringMonitor args) {
        /*
         * the HotSpot 1.4.2 JVM with the +UseParallelGC option along
         * with its default +UseAdaptiveSizePolicy option has a bug with
         * the initialization of the sizes of the eden and survivor spaces.
         * See bugid 4890736.
         *
         * note - use explicit 1.4.2 counter names here - don't update
         * to latest counter names or attempt to find aliases.
         */

        String cname = &quot;hotspot.gc.collector.0.name&quot;;
        StringMonitor collector = (StringMonitor)map.get(cname);

        if (collector.stringValue().compareTo(&quot;PSScavenge&quot;) == 0) {
            boolean adaptiveSizePolicy = true;

            /*
             * HotSpot processes the -XX:Flags/.hotspotrc arguments prior to
             * processing the command line arguments. This allows the command
             * line arguments to override any defaults set in .hotspotrc
             */
            cname = &quot;hotspot.vm.flags&quot;;
            StringMonitor flags = (StringMonitor)map.get(cname);
            String allArgs = flags.stringValue() + &quot; &quot; + args.stringValue();

            /*
             * ignore the -XX: prefix as it only applies to the arguments
             * passed from the command line (i.e. the invocation api).
             * arguments passed through .hotspotrc omit the -XX: prefix.
             */
            int ahi = allArgs.lastIndexOf(&quot;+AggressiveHeap&quot;);
            int aspi = allArgs.lastIndexOf(&quot;-UseAdaptiveSizePolicy&quot;);

            if (ahi != -1) {
                /*
                 * +AggressiveHeap was set, check if -UseAdaptiveSizePolicy
                 * is set after +AggressiveHeap.
                 */
                //
                if ((aspi != -1) &amp;&amp; (aspi &gt; ahi)) {
                    adaptiveSizePolicy = false;
                }
            } else {
                /*
                 * +AggressiveHeap not set, must be +UseParallelGC. The
                 * relative position of -UseAdaptiveSizePolicy is not
                 * important in this case, as it will override the
                 * UseParallelGC default (+UseAdaptiveSizePolicy) if it
                 * appears anywhere in the JVM arguments.
                 */
                if (aspi != -1) {
                    adaptiveSizePolicy = false;
                }
            }

            if (adaptiveSizePolicy) {
                // adjust the buggy AdaptiveSizePolicy size counters.

                // first remove the real counters.
                String eden_size = &quot;hotspot.gc.generation.0.space.0.size&quot;;
                String s0_size = &quot;hotspot.gc.generation.0.space.1.size&quot;;
                String s1_size = &quot;hotspot.gc.generation.0.space.2.size&quot;;
                map.remove(eden_size);
                map.remove(s0_size);
                map.remove(s1_size);

                // get the maximum new generation size
                String new_max_name = &quot;hotspot.gc.generation.0.capacity.max&quot;;
                LongMonitor new_max = (LongMonitor)map.get(new_max_name);

                /*
                 * replace the real counters with pseudo counters that are
                 * initialized to to the correct values. The maximum size of
                 * the eden and survivor spaces are supposed to be:
                 *    max_eden_size = new_size - (2*alignment).
                 *    max_survivor_size = new_size - (2*alignment).
                 * since we don't know the alignment value used, and because
                 * of other parallel scavenge bugs that result in oversized
                 * spaces, we just set the maximum size of each space to the
                 * full new gen size.
                 */
                Monitor monitor = null;

                LongBuffer lb = LongBuffer.allocate(1);
                lb.put(new_max.longValue());
                monitor = new PerfLongMonitor(eden_size, Units.BYTES,
                                              Variability.CONSTANT, false, lb);
                map.put(eden_size, monitor);

                monitor = new PerfLongMonitor(s0_size, Units.BYTES,
                                              Variability.CONSTANT, false, lb);
                map.put(s0_size, monitor);

                monitor = new PerfLongMonitor(s1_size, Units.BYTES,
                                              Variability.CONSTANT, false, lb);
                map.put(s1_size, monitor);
            }
        }
    }

    /**
     * method to extract the next monitor entry from the instrumentation memory.
     * assumes that nextEntry is the offset into the byte array
     * at which to start the search for the next entry. method leaves
     * next entry pointing to the next entry or to the end of data.
     */
    protected Monitor getNextMonitorEntry() throws MonitorException {
        Monitor monitor = null;

        // entries are always 4 byte aligned.
        if ((nextEntry % 4) != 0) {
            throw new MonitorStructureException(
                   &quot;Entry index not properly aligned: &quot; + nextEntry);
        }

        // protect against a corrupted shared memory region.
        if ((nextEntry &lt; 0) || (nextEntry &gt; buffer.limit())) {
            throw new MonitorStructureException(
                   &quot;Entry index out of bounds: nextEntry = &quot; + nextEntry
                   + &quot;, limit = &quot; + buffer.limit());
        }

        // check for the end of the buffer
        if (nextEntry == buffer.limit()) {
            lognl(&quot;getNextMonitorEntry():&quot;
                  + &quot; nextEntry == buffer.limit(): returning&quot;);
            return null;
        }

        buffer.position(nextEntry);

        int entryStart = buffer.position();
        int entryLength = buffer.getInt();

        // check for valid entry length
        if ((entryLength &lt; 0) || (entryLength &gt; buffer.limit())) {
            throw new MonitorStructureException(
                   &quot;Invalid entry length: entryLength = &quot; + entryLength);
        }

        // check if last entry occurs before the eof.
        if ((entryStart + entryLength) &gt; buffer.limit()) {
            throw new MonitorStructureException(
                   &quot;Entry extends beyond end of buffer: &quot;
                   + &quot; entryStart = &quot; + entryStart
                   + &quot; entryLength = &quot; + entryLength
                   + &quot; buffer limit = &quot; + buffer.limit());
        }

        if (entryLength == 0) {
            // end of data
            return null;
        }

        int nameLength = buffer.getInt();
        int vectorLength = buffer.getInt();
        byte dataType = buffer.get();
        byte flags = buffer.get();
        Units u = Units.toUnits(buffer.get());
        Variability v = Variability.toVariability(buffer.get());
        boolean supported = (flags &amp; 0x01) != 0;

        // defend against corrupt entries
        if ((nameLength &lt;= 0) || (nameLength &gt; entryLength)) {
            throw new MonitorStructureException(
                   &quot;Invalid Monitor name length: &quot; + nameLength);
        }

        if ((vectorLength &lt; 0) || (vectorLength &gt; entryLength)) {
            throw new MonitorStructureException(
                   &quot;Invalid Monitor vector length: &quot; + vectorLength);
        }

        // read in the perfData item name, casting bytes to chars. skip the
        // null terminator
        //
        byte[] nameBytes = new byte[nameLength-1];
        for (int i = 0; i &lt; nameLength-1; i++) {
            nameBytes[i] = buffer.get();
        }

        // convert name into a String
        String name = new String(nameBytes, 0, nameLength-1);

        if (v == Variability.INVALID) {
            throw new MonitorDataException(&quot;Invalid variability attribute:&quot;
                                           + &quot; entry index = &quot; + perfDataItem
                                           + &quot; name = &quot; + name);
        }
        if (u == Units.INVALID) {
            throw new MonitorDataException(&quot;Invalid units attribute: &quot;
                                           + &quot; entry index = &quot; + perfDataItem
                                           + &quot; name = &quot; + name);
        }

        int offset;
        if (vectorLength == 0) {
            // scalar Types
            if (dataType == BasicType.LONG.intValue()) {
                offset = entryStart + entryLength - 8;  /* 8 = sizeof(long) */
                buffer.position(offset);
                LongBuffer lb = buffer.asLongBuffer();
                lb.limit(1);
                monitor = new PerfLongMonitor(name, u, v, supported, lb);
                perfDataItem++;
            } else {
                // bad data types.
                throw new MonitorTypeException(&quot;Invalid Monitor type:&quot;
                                    + &quot; entry index = &quot; + perfDataItem
                                    + &quot; name = &quot; + name
                                    + &quot; type = &quot; + dataType);
            }
        } else {
            // vector types
            if (dataType == BasicType.BYTE.intValue()) {
                if (u != Units.STRING) {
                    // only byte arrays of type STRING are currently supported
                    throw new MonitorTypeException(&quot;Invalid Monitor type:&quot;
                                      + &quot; entry index = &quot; + perfDataItem
                                      + &quot; name = &quot; + name
                                      + &quot; type = &quot; + dataType);
                }

                offset = entryStart + PERFDATA_NAME_OFFSET + nameLength;
                buffer.position(offset);
                ByteBuffer bb = buffer.slice();
                bb.limit(vectorLength);
                bb.position(0);

                if (v == Variability.CONSTANT) {
                    monitor = new PerfStringConstantMonitor(name, supported,
                                                            bb);
                } else if (v == Variability.VARIABLE) {
                    monitor = new PerfStringVariableMonitor(name, supported,
                                                            bb, vectorLength-1);
                } else {
                    // Monotonically increasing byte arrays are not supported
                    throw new MonitorDataException(
                            &quot;Invalid variability attribute:&quot;
                            + &quot; entry index = &quot; + perfDataItem
                            + &quot; name = &quot; + name
                            + &quot; variability = &quot; + v);
                }
                perfDataItem++;
            } else {
                // bad data types.
                throw new MonitorTypeException(
                        &quot;Invalid Monitor type:&quot; + &quot; entry index = &quot;
                        + perfDataItem + &quot; name = &quot; + name
                        + &quot; type = &quot; + dataType);
            }
        }

        // setup index to next entry for next iteration of the loop.
        nextEntry = entryStart + entryLength;
        return monitor;
    }

    /**
     * Method to dump debugging information
     */
    private void dumpAll(Map map, int lvmid) {
        if (DEBUG) {
            Set keys = map.keySet();

            System.err.println(&quot;Dump for &quot; + lvmid);
            int j = 0;
            for (Iterator i = keys.iterator(); i.hasNext(); j++) {
                Monitor monitor = (Monitor)map.get(i.next());
                System.err.println(j + &quot;\t&quot; + monitor.getName()
                                   + &quot;=&quot; + monitor.getValue());
            }
            System.err.println(&quot;nextEntry = &quot; + nextEntry
                               + &quot; pollForEntry = &quot; + pollForEntry);
            System.err.println(&quot;Buffer info:&quot;);
            System.err.println(&quot;buffer = &quot; + buffer);
        }
    }

    private void lognl(String s) {
        if (DEBUG) {
            System.err.println(s);
        }
    }

    private void log(String s) {
        if (DEBUG) {
            System.err.print(s);
        }
    }
}
</pre>
</body>
</html>
