<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.jvmstat.monitor;

import java.net.*;

/**
 * An abstraction that identifies a target Java Virtual Machine.
 * The VmIdentifier, or vmid, provides a convenient string representation
 * of the information needed to locate and communicate with a target
 * Java Virtual Machine. The string, based on a {@link URI}, may specify
 * the communications protocol, host name, local vm identifier, and protocol
 * specific information for a target Java Virtual Machine. The format for
 * a VmIdentifier string is:
 * &lt;pre&gt;
 *      [&lt;I&gt;protocol&lt;/I&gt;:][&lt;I&gt;//&lt;/I&gt;]&lt;I&gt;&lt;B&gt;lvmid&lt;/B&gt;&lt;/I&gt;[&lt;I&gt;@hostname&lt;/I&gt;][&lt;I&gt;:port&lt;/I&gt;][&lt;I&gt;/servername&lt;/I&gt;]
 * &lt;/pre&gt;
 * The only required component of this string is the Local Virtual Machine
 * Identifier, or &lt;tt&gt;lvmid&lt;/tt&gt;, which uniquely identifies the target
 * Java Virtual Machine on a host. The optional components of the VmIdentifier
 * include:
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;p&gt;&lt;tt&gt;protocol&lt;/tt&gt; - The communications protocol. A VmIdentifier
 *          omitting the protocol must be resolved against a HostIdentifier
 *          using {@link HostIdentifier#resolve}.
 *       &lt;/p&gt;&lt;/li&gt;
 *   &lt;li&gt;&lt;p&gt;&lt;tt&gt;hostname&lt;/tt&gt; - A hostname or IP address indicating the target
 *          host. A VmIdentifier omitting the protocol must be resolved
 *          against a HostIdentifier using {@link HostIdentifier#resolve}.
 *       &lt;/p&gt;&lt;/li&gt;
 *   &lt;li&gt;&lt;p&gt;&lt;tt&gt;port&lt;/tt&gt; - The port for the communications protocol.
 *          Treatment of the &lt;tt&gt;port&lt;/tt&gt; parameter is implementation
 *          (protocol) specific. A VmIdentifier omitting the protocol should
 *          be resolved against a HostIdentifier using
 *          {@link HostIdentifier#resolve}.
 *       &lt;/p&gt;&lt;/li&gt;
 *   &lt;li&gt;&lt;p&gt;&lt;tt&gt;servername&lt;/tt&gt; - The treatment of the Path, Query, and
 *          Fragment components of the VmIdentifier are implementation
 *          (protocol) dependent. A VmIdentifier omitting the protocol should
 *          be resolved against a HostIdentifier using
 *          {@link HostIdentifier#resolve}.
 *       &lt;/p&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * All VmIdentifier instances are constructed as absolute, hierarchical URIs.
 * The constructors will accept relative (and even some malformed,
 * though convenient) URI strings. Such strings are transformed into
 * legitimate, absolute URI strings.
 * &lt;/p&gt;
 * &lt;p&gt;
 * With the exception of &lt;em&gt;file:&lt;/em&gt; based VmIdentifier strings, all
 * VmIdentifier strings must include a &lt;tt&gt;lvmid&lt;/tt&gt;. Attempting to construct
 * a non-file based VmIdentifier that doesn't include a &lt;tt&gt;lvmid&lt;/tt&gt;
 * component will result in a &lt;tt&gt;MonitorException&lt;/tt&gt;.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Here are some examples of VmIdentifier strings.
 * &lt;ul&gt;
 *    &lt;li&gt;&lt;p&gt;Relative URIs&lt;/p&gt;&lt;/li&gt;
 *      &lt;ul&gt;
 *         &lt;li&gt;&lt;p&gt;&lt;em&gt;1234&lt;/em&gt; - Specifies the Java Virtual Machine
 *                identified by lvmid &lt;em&gt;1234&lt;/em&gt; on an unnamed host.
 *                This string is transformed into the absolute form
 *                &lt;em&gt;//1234&lt;/em&gt;, which must be resolved against a
 *                HostIdentifier.
 *         &lt;/p&gt;&lt;/li&gt;
 *         &lt;li&gt;&lt;p&gt;&lt;em&gt;1234@hostname&lt;/em&gt; - Specifies the Java Virtual
 *                Machine identified by lvmid &lt;em&gt;1234&lt;/em&gt; on host
 *                &lt;em&gt;hostname&lt;/em&gt; with an unnamed protocol.
 *                This string is transformed into the absolute form
 *                &lt;em&gt;//1234@hostname&lt;/em&gt;, which must be resolved against
 *                a HostIdentifier.
 *         &lt;/p&gt;&lt;/li&gt;
 *         &lt;li&gt;&lt;p&gt;&lt;em&gt;1234@hostname:2099&lt;/em&gt; - Specifies the Java Virtual
 *                Machine identified by lvmid &lt;em&gt;1234&lt;/em&gt; on host
 *                &lt;em&gt;hostname&lt;/em&gt; with an unnamed protocol, but with
 *                port &lt;em&gt;2099&lt;/em&gt;. This string is transformed into
 *                the absolute form &lt;em&gt;//1234@hostname:2099&lt;/em&gt;, which
 *                must be resolved against a HostIdentifier.
 *         &lt;/p&gt;&lt;/li&gt;
 *      &lt;/ul&gt;
 *    &lt;li&gt;&lt;p&gt;Absolute URIs&lt;/p&gt;&lt;/li&gt;
 *      &lt;ul&gt;
 *         &lt;li&gt;&lt;p&gt;&lt;em&gt;rmi://1234@hostname:2099/remoteobjectname&lt;/em&gt; -
 *                Specifies the Java Virtual Machine identified by lvmid
 *                &lt;em&gt;1234&lt;/em&gt; on host &lt;em&gt;hostname&lt;/em&gt; accessed
 *                using the &lt;em&gt;rmi:&lt;/em&gt; protocol through the rmi remote
 *                object named &lt;em&gt;remoteobjectname&lt;/em&gt; as registered with
 *                the &lt;em&gt;rmiserver&lt;/em&gt; on port &lt;em&gt;2099&lt;/em&gt; on host
 *                &lt;em&gt;hostname&lt;/em&gt;.
 *         &lt;/p&gt;&lt;/li&gt;
 *         &lt;li&gt;&lt;p&gt;&lt;em&gt;file:/path/file&lt;/em&gt; - Identifies a Java Virtual Machine
 *                through accessing a special file based protocol to use as
 *                the communications mechanism.
 *         &lt;/p&gt;&lt;/li&gt;
 *      &lt;/ul&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;
 *
 * @see URI
 * @see HostIdentifier
 * @author Brian Doherty
 * @since 1.5
 */
public class VmIdentifier {
    private URI uri;

    /**
     * creates a canonical representation of the uriString. This method
     * performs certain translations depending on the type of URI generated
     * by the string.
     */
    private URI canonicalize(String uriString) throws URISyntaxException {
        if (uriString == null) {
            uriString = &quot;local://0@localhost&quot;;
            return new URI(uriString);
        }

        URI u = new URI(uriString);

        if (u.isAbsolute()) {
            if (u.isOpaque()) {
                /*
                 * rmi:1234@hostname/path#fragment converted to
                 * rmi://1234@hostname/path#fragment
                 */
                u = new URI(u.getScheme(), &quot;//&quot; + u.getSchemeSpecificPart(),
                            u.getFragment());
            }
        } else {
            /*
             * make the uri absolute, if possible. A relative URI doesn't
             * specify the scheme part, so it's safe to prepend a &quot;//&quot; and
             * try again.
             */
            if (!uriString.startsWith(&quot;//&quot;)) {
                if (u.getFragment() == null) {
                    u = new URI(&quot;//&quot; + u.getSchemeSpecificPart());
                } else {
                    u = new URI(&quot;//&quot; + u.getSchemeSpecificPart() + &quot;#&quot;
                                + u.getFragment());
                }
            }
        }
        return u;
    }

    /**
     * check that the VmIdentifier includes a unique numerical identifier
     * for the target JVM.
     */
    private void validate() throws URISyntaxException {
        // file:// uri, which is a special case where the lvmid is not required.
        String s = getScheme();
        if ((s != null) &amp;&amp; (s.compareTo(&quot;file&quot;) == 0)) {
            return;
        }
        if (getLocalVmId() == -1) {
            throw new URISyntaxException(uri.toString(), &quot;Local vmid required&quot;);
        }
    }

    /**
     * Create a VmIdentifier instance from a string value.
     *
     * @param uriString a string representing a target Java Virtual Machine.
     *                  The syntax of the string must conforms to the rules
     *                  specified in the class documentation.
     * @throws URISyntaxException Thrown when the uriString or its canonical
     *                            form is poorly formed.
     */
    public VmIdentifier(String uriString) throws URISyntaxException {
        URI u;
        try {
            u = canonicalize(uriString);
        } catch (URISyntaxException e) {
            /*
             * a vmid of the form 1234@hostname:1098 causes an exception,
             * so try again with a leading &quot;//&quot;
             */
            if (uriString.startsWith(&quot;//&quot;)) {
                throw e;
            }
            u = canonicalize(&quot;//&quot;+uriString);
        }

        uri = u;

        // verify that we have a valid lvmid
        validate();
    }

    /**
     * Create a VmIdentifier instance from a URI object.
     *
     * @param uri a well formed, absolute URI indicating the
     *            target Java Virtual Machine.
     * @throws URISyntaxException Thrown if the URI is missing some
     *                            required component.
     */
    public VmIdentifier(URI uri) throws URISyntaxException {
        this.uri = uri;
        validate();
    }

    /**
     * Return the corresponding HostIdentifier for this VmIdentifier.
     * &lt;p&gt;
     * This method constructs a HostIdentifier object from the VmIdentifier.
     * If the VmIdentifier is not specific about the protocol or other
     * components of the URI, then the resulting HostIdentifier will
     * be constructed based on this missing information. Typically, the
     * missing components will have result in the HostIdentifier assigning
     * assumed defaults that allow the VmIdentifier to be resolved according
     * to those defaults.
     * &lt;/p&gt;
     * &lt;p&gt;
     * For example, a VmIdentifier that specifies only a &lt;tt&gt;lvmid&lt;/tt&gt;
     * will result in a HostIdentifier for &lt;em&gt;localhost&lt;/em&gt; utilizing
     * the default local protocol, &lt;em&gt;local:&lt;/em&gt;. A VmIdentifier that
     * specifies both a &lt;tt&gt;vmid&lt;/tt&gt; and a &lt;tt&gt;hostname&lt;/tt&gt; will result
     * in a HostIdentifier for the specified host with the default remote
     * protocol, &lt;em&gt;rmi:&lt;/em&gt;, using the protocol defaults for the
     * &lt;tt&gt;port&lt;/tt&gt; and &lt;tt&gt;servername&lt;/tt&gt; components.
     * &lt;/p&gt;
     *
     * @return HostIdentifier - the host identifier for the host containing
     *                          the Java Virtual Machine represented by this
     *                          VmIdentifier.
     * @throws URISyntaxException Thrown if a bad host URI is constructed.
     *                            This exception may get encapsulated into
     *                            a MonitorException in a future version.
     */
    public HostIdentifier getHostIdentifier() throws URISyntaxException {
        StringBuffer sb = new StringBuffer();
        if (getScheme() != null) {
            sb.append(getScheme()).append(&quot;:&quot;);
        }
        sb.append(&quot;//&quot;).append(getHost());
        if (getPort() != -1) {
            sb.append(&quot;:&quot;).append(getPort());
        }
        if (getPath() != null) {
            sb.append(getPath());
        }
        return new HostIdentifier(sb.toString());
    }

    /**
     * Return the Scheme, or protocol, portion of this VmIdentifier.
     *
     * @return String - the scheme for this VmIdentifier.
     * @see URI#getScheme()
     */
    public String getScheme() {
        return uri.getScheme();
    }

    /**
     * Return the Scheme Specific Part of this VmIdentifier.
     *
     * @return String - the Scheme Specific Part for this VmIdentifier.
     * @see URI#getSchemeSpecificPart()
     */
    public String getSchemeSpecificPart() {
        return uri.getSchemeSpecificPart();
    }

    /**
     * Return the UserInfo part of this VmIdentifier.
     *
     * @return String - the UserInfo part for this VmIdentifier.
     * @see URI#getUserInfo()
     */
    public String getUserInfo() {
        return uri.getUserInfo();
    }

    /**
     * Return the Host part of this VmIdentifier.
     *
     * @return String - the Host part for this VmIdentifier.
     * @see URI#getHost()
     */
    public String getHost() {
        return uri.getHost();
    }

    /**
     * Return the Port part of this VmIdentifier.
     *
     * @return int - the Port part for this VmIdentifier.
     * @see URI#getPort()
     */
    public int getPort() {
        return uri.getPort();
    }

    /**
     * Return the Authority part of this VmIdentifier.
     *
     * @return String - the Authority part for this VmIdentifier.
     * @see URI#getAuthority()
     */
    public String getAuthority() {
        return uri.getAuthority();
    }

    /**
     * Return the Path part of this VmIdentifier.
     *
     * @return String - the Path part for this VmIdentifier.
     * @see URI#getPath()
     */
    public String getPath() {
        return uri.getPath();
    }

    /**
     * Return the Query part of this VmIdentifier.
     *
     * @return String - the Query part for this VmIdentifier.
     * @see URI#getQuery()
     */
    public String getQuery() {
        return uri.getQuery();
    }

    /**
     * Return the Fragment part of this VmIdentifier.
     *
     * @return String - the Fragment part for this VmIdentifier.
     * @see URI#getFragment()
     */
    public String getFragment() {
        return uri.getFragment();
    }

    /**
     * Return the Local Virtual Machine Identifier for this VmIdentifier.
     * The Local Virtual Machine Identifier is also known as the
     * &lt;em&gt;lvmid&lt;/em&gt;.
     *
     * @return int - the lvmid for this VmIdentifier.
     */
    public int getLocalVmId() {
        int result = -1;
        try {
            if (uri.getUserInfo() == null) {
                result = Integer.parseInt(uri.getAuthority());
            } else {
                result = Integer.parseInt(uri.getUserInfo());
            }
        } catch (NumberFormatException e) { }
        return result;
    }

    /**
     * Return the mode indicated in this VmIdentifier.
     *
     * @return String - the mode string. If no mode is specified, then &quot;r&quot;
     *                  is returned. otherwise, the specified mode is returned.
     */
    public String getMode() {
        String query = getQuery();
        if (query != null) {
            String[] queryArgs = query.split(&quot;\\+&quot;);
            for (int i = 0; i &lt; queryArgs.length; i++) {
                if (queryArgs[i].startsWith(&quot;mode=&quot;)) {
                    int index = queryArgs[i].indexOf('=');
                    return queryArgs[i].substring(index+1);
                }
            }
        }
        return &quot;r&quot;;
    }

    /**
     * Return the URI associated with the VmIdentifier.
     *
     * @return URI - the URI.
     * @see URI
     */
    public URI getURI() {
        return uri;
    }

    /**
     * Return the hash code for this VmIdentifier. The hash code is
     * identical to the hash code for the contained URI.
     *
     * @return int - the hashcode.
     * @see URI#hashCode()
     */
    public int hashCode() {
        return uri.hashCode();
    }

    /**
     * Test for quality with other objects.
     *
     * @param object the object to be test for equality.
     * @return boolean - returns true if the given object is of type
     *                   VmIdentifier and its URI field is equal to
     *                   this object's URI field. Otherwise, return false.
     *
     * @see URI#equals(Object)
     */
    public boolean equals(Object object) {
        if (object == this) {
            return true;
        }
        if (!(object instanceof VmIdentifier)) {
            return false;
        }
        return uri.equals(((VmIdentifier)object).uri);
    }

    /**
     * Convert to a string representation. Conversion is identical to
     * calling getURI().toString(). This may change in a future release.
     *
     * @return String - a String representation of the VmIdentifier.
     *
     * @see URI#toString()
     */
    public String toString() {
        return uri.toString();
    }
}
</pre>
</body>
</html>
