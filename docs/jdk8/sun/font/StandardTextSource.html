<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
/*
 *
 * (C) Copyright IBM Corp. 1998-2003 - All Rights Reserved
 */

package sun.font;

import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.font.LineMetrics;

public class StandardTextSource extends TextSource {
  char[] chars;
  int start;
  int len;
  int cstart;
  int clen;
  int level; // assumed all uniform
  int flags; // see GlyphVector.java
  Font font;
  FontRenderContext frc;
  CoreMetrics cm;

  /**
   * Create a simple implementation of a TextSource.
   *
   * Chars is an array containing clen chars in the context, in
   * logical order, contiguously starting at cstart.  Start and len
   * represent that portion of the context representing the true
   * source; start, like cstart, is relative to the start of the
   * character array.
   *
   * Level is the bidi level (0-63 for the entire context. Flags is
   * the layout flags. Font is the font, frc is the render context,
   * and lm is the line metrics for the entire source text, but not
   * necessarily the context.
   */
  public StandardTextSource(char[] chars,
                            int start,
                            int len,
                            int cstart,
                            int clen,
                            int level,
                            int flags,
                            Font font,
                            FontRenderContext frc,
                            CoreMetrics cm) {
    if (chars == null) {
      throw new IllegalArgumentException(&quot;bad chars: null&quot;);
    }
    if (cstart &lt; 0) {
      throw new IllegalArgumentException(&quot;bad cstart: &quot; + cstart);
    }
    if (start &lt; cstart) {
      throw new IllegalArgumentException(&quot;bad start: &quot; + start + &quot; for cstart: &quot; + cstart);
    }
    if (clen &lt; 0) {
      throw new IllegalArgumentException(&quot;bad clen: &quot; + clen);
    }
    if (cstart + clen &gt; chars.length) {
      throw new IllegalArgumentException(&quot;bad clen: &quot; + clen + &quot; cstart: &quot; + cstart + &quot; for array len: &quot; + chars.length);
    }
    if (len &lt; 0) {
      throw new IllegalArgumentException(&quot;bad len: &quot; + len);
    }
    if ((start + len) &gt; (cstart + clen)) {
      throw new IllegalArgumentException(&quot;bad len: &quot; + len + &quot; start: &quot; + start + &quot; for cstart: &quot; + cstart + &quot; clen: &quot; + clen);
    }
    if (font == null) {
      throw new IllegalArgumentException(&quot;bad font: null&quot;);
    }
    if (frc == null) {
      throw new IllegalArgumentException(&quot;bad frc: null&quot;);
    }

    this.chars = chars.clone();
    this.start = start;
    this.len = len;
    this.cstart = cstart;
    this.clen = clen;
    this.level = level;
    this.flags = flags;
    this.font = font;
    this.frc = frc;

    if (cm != null) {
        this.cm = cm;
    } else {
        LineMetrics metrics = font.getLineMetrics(chars, cstart, clen, frc);
        this.cm = ((FontLineMetrics)metrics).cm;
    }
  }

  /** Create a StandardTextSource whose context is coextensive with the source. */
  public StandardTextSource(char[] chars,
                            int start,
                            int len,
                            int level,
                            int flags,
                            Font font,
                            FontRenderContext frc,
                            CoreMetrics cm) {
    this(chars, start, len, start, len, level, flags, font, frc, cm);
  }

  /** Create a StandardTextSource whose context and source are coextensive with the entire char array. */
  public StandardTextSource(char[] chars,
                            int level,
                            int flags,
                            Font font,
                            FontRenderContext frc) {
    this(chars, 0, chars.length, 0, chars.length, level, flags, font, frc, null);
  }

  /** Create a StandardTextSource whose context and source are all the text in the String. */
  public StandardTextSource(String str,
                            int level,
                            int flags,
                            Font font,
                            FontRenderContext frc) {
    this(str.toCharArray(), 0, str.length(), 0, str.length(), level, flags, font, frc, null);
  }

  // TextSource API

  public char[] getChars() {
    return chars.clone();
  }

  public int getStart() {
    return start;
  }

  public int getLength() {
    return len;
  }

  public int getContextStart() {
    return cstart;
  }

  public int getContextLength() {
    return clen;
  }

  public int getLayoutFlags() {
    return flags;
  }

  public int getBidiLevel() {
    return level;
  }

  public Font getFont() {
    return font;
  }

  public FontRenderContext getFRC() {
    return frc;
  }

  public CoreMetrics getCoreMetrics() {
    return cm;
  }

  public TextSource getSubSource(int start, int length, int dir) {
    if (start &lt; 0 || length &lt; 0 || (start + length) &gt; len) {
      throw new IllegalArgumentException(&quot;bad start (&quot; + start + &quot;) or length (&quot; + length + &quot;)&quot;);
    }

    int level = this.level;
    if (dir != TextLineComponent.UNCHANGED) {
        boolean ltr = (flags &amp; 0x8) == 0;
        if (!(dir == TextLineComponent.LEFT_TO_RIGHT &amp;&amp; ltr) &amp;&amp;
                !(dir == TextLineComponent.RIGHT_TO_LEFT &amp;&amp; !ltr)) {
            throw new IllegalArgumentException(&quot;direction flag is invalid&quot;);
        }
        level = ltr? 0 : 1;
    }

    return new StandardTextSource(chars, this.start + start, length, cstart, clen, level, flags, font, frc, cm);
  }

  public String toString() {
    return toString(WITH_CONTEXT);
  }

  public String toString(boolean withContext) {
    StringBuffer buf = new StringBuffer(super.toString());
    buf.append(&quot;[start:&quot;);
    buf.append(start);
    buf.append(&quot;, len:&quot; );
    buf.append(len);
    buf.append(&quot;, cstart:&quot;);
    buf.append(cstart);
    buf.append(&quot;, clen:&quot; );
    buf.append(clen);
    buf.append(&quot;, chars:\&quot;&quot;);
    int chStart, chLimit;
    if (withContext == WITH_CONTEXT) {
        chStart = cstart;
        chLimit = cstart + clen;
    }
    else {
        chStart = start;
        chLimit = start + len;
    }
    for (int i = chStart; i &lt; chLimit; ++i) {
      if (i &gt; chStart) {
        buf.append(&quot; &quot;);
      }
      buf.append(Integer.toHexString(chars[i]));
    }
    buf.append(&quot;\&quot;&quot;);
    buf.append(&quot;, level:&quot;);
    buf.append(level);
    buf.append(&quot;, flags:&quot;);
    buf.append(flags);
    buf.append(&quot;, font:&quot;);
    buf.append(font);
    buf.append(&quot;, frc:&quot;);
    buf.append(frc);
    buf.append(&quot;, cm:&quot;);
    buf.append(cm);
    buf.append(&quot;]&quot;);

    return buf.toString();
  }
}
</pre>
</body>
</html>
