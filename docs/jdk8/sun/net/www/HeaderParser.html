<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.net.www;

import java.util.Iterator;

/* This is useful for the nightmare of parsing multi-part HTTP/RFC822 headers
 * sensibly:
 * From a String like: 'timeout=15, max=5'
 * create an array of Strings:
 * { {&quot;timeout&quot;, &quot;15&quot;},
 *   {&quot;max&quot;, &quot;5&quot;}
 * }
 * From one like: 'Basic Realm=&quot;FuzzFace&quot; Foo=&quot;Biz Bar Baz&quot;'
 * create one like (no quotes in literal):
 * { {&quot;basic&quot;, null},
 *   {&quot;realm&quot;, &quot;FuzzFace&quot;}
 *   {&quot;foo&quot;, &quot;Biz Bar Baz&quot;}
 * }
 * keys are converted to lower case, vals are left as is....
 *
 * @author Dave Brown
 */


public class HeaderParser {

    /* table of key/val pairs */
    String raw;
    String[][] tab;
    int nkeys;
    int asize = 10; // initial size of array is 10

    public HeaderParser(String raw) {
        this.raw = raw;
        tab = new String[asize][2];
        parse();
    }

    private HeaderParser () {
    }

    /**
     * create a new HeaderParser from this, whose keys (and corresponding values)
     * range from &quot;start&quot; to &quot;end-1&quot;
     */
    public HeaderParser subsequence (int start, int end) {
        if (start == 0 &amp;&amp; end == nkeys) {
            return this;
        }
        if (start &lt; 0 || start &gt;= end || end &gt; nkeys)
            throw new IllegalArgumentException (&quot;invalid start or end&quot;);
        HeaderParser n = new HeaderParser ();
        n.tab = new String [asize][2];
        n.asize = asize;
        System.arraycopy (tab, start, n.tab, 0, (end-start));
        n.nkeys= (end-start);
        return n;
    }

    private void parse() {

        if (raw != null) {
            raw = raw.trim();
            char[] ca = raw.toCharArray();
            int beg = 0, end = 0, i = 0;
            boolean inKey = true;
            boolean inQuote = false;
            int len = ca.length;
            while (end &lt; len) {
                char c = ca[end];
                if ((c == '=') &amp;&amp; !inQuote) { // end of a key
                    tab[i][0] = new String(ca, beg, end-beg).toLowerCase();
                    inKey = false;
                    end++;
                    beg = end;
                } else if (c == '\&quot;') {
                    if (inQuote) {
                        tab[i++][1]= new String(ca, beg, end-beg);
                        inQuote=false;
                        do {
                            end++;
                        } while (end &lt; len &amp;&amp; (ca[end] == ' ' || ca[end] == ','));
                        inKey=true;
                        beg=end;
                    } else {
                        inQuote=true;
                        end++;
                        beg=end;
                    }
                } else if (c == ' ' || c == ',') { // end key/val, of whatever we're in
                    if (inQuote) {
                        end++;
                        continue;
                    } else if (inKey) {
                        tab[i++][0] = (new String(ca, beg, end-beg)).toLowerCase();
                    } else {
                        tab[i++][1] = (new String(ca, beg, end-beg));
                    }
                    while (end &lt; len &amp;&amp; (ca[end] == ' ' || ca[end] == ',')) {
                        end++;
                    }
                    inKey = true;
                    beg = end;
                } else {
                    end++;
                }
                if (i == asize) {
                    asize = asize * 2;
                    String[][] ntab = new String[asize][2];
                    System.arraycopy (tab, 0, ntab, 0, tab.length);
                    tab = ntab;
                }
            }
            // get last key/val, if any
            if (--end &gt; beg) {
                if (!inKey) {
                    if (ca[end] == '\&quot;') {
                        tab[i++][1] = (new String(ca, beg, end-beg));
                    } else {
                        tab[i++][1] = (new String(ca, beg, end-beg+1));
                    }
                } else {
                    tab[i++][0] = (new String(ca, beg, end-beg+1)).toLowerCase();
                }
            } else if (end == beg) {
                if (!inKey) {
                    if (ca[end] == '\&quot;') {
                        tab[i++][1] = String.valueOf(ca[end-1]);
                    } else {
                        tab[i++][1] = String.valueOf(ca[end]);
                    }
                } else {
                    tab[i++][0] = String.valueOf(ca[end]).toLowerCase();
                }
            }
            nkeys=i;
        }

    }

    public String findKey(int i) {
        if (i &lt; 0 || i &gt; asize)
            return null;
        return tab[i][0];
    }

    public String findValue(int i) {
        if (i &lt; 0 || i &gt; asize)
            return null;
        return tab[i][1];
    }

    public String findValue(String key) {
        return findValue(key, null);
    }

    public String findValue(String k, String Default) {
        if (k == null)
            return Default;
        k = k.toLowerCase();
        for (int i = 0; i &lt; asize; ++i) {
            if (tab[i][0] == null) {
                return Default;
            } else if (k.equals(tab[i][0])) {
                return tab[i][1];
            }
        }
        return Default;
    }

    class ParserIterator implements Iterator&lt;String&gt; {
        int index;
        boolean returnsValue; // or key

        ParserIterator (boolean returnValue) {
            returnsValue = returnValue;
        }
        public boolean hasNext () {
            return index&lt;nkeys;
        }
        public String next () {
            return tab[index++][returnsValue?1:0];
        }
        public void remove () {
            throw new UnsupportedOperationException (&quot;remove not supported&quot;);
        }
    }

    public Iterator&lt;String&gt; keys () {
        return new ParserIterator (false);
    }

    public Iterator&lt;String&gt; values () {
        return new ParserIterator (true);
    }

    public String toString () {
        Iterator&lt;String&gt; k = keys();
        StringBuffer sbuf = new StringBuffer();
        sbuf.append (&quot;{size=&quot;+asize+&quot; nkeys=&quot;+nkeys+&quot; &quot;);
        for (int i=0; k.hasNext(); i++) {
            String key = k.next();
            String val = findValue (i);
            if (val != null &amp;&amp; &quot;&quot;.equals (val)) {
                val = null;
            }
            sbuf.append (&quot; {&quot;+key+(val==null?&quot;&quot;:&quot;,&quot;+val)+&quot;}&quot;);
            if (k.hasNext()) {
                sbuf.append (&quot;,&quot;);
            }
        }
        sbuf.append (&quot; }&quot;);
        return new String (sbuf);
    }

    public int findInt(String k, int Default) {
        try {
            return Integer.parseInt(findValue(k, String.valueOf(Default)));
        } catch (Throwable t) {
            return Default;
        }
    }
    /*
    public static void main(String[] a) throws Exception {
        System.out.print(&quot;enter line to parse&gt; &quot;);
        System.out.flush();
        DataInputStream dis = new DataInputStream(System.in);
        String line = dis.readLine();
        HeaderParser p = new HeaderParser(line);
        for (int i = 0; i &lt; asize; ++i) {
            if (p.findKey(i) == null) break;
            String v = p.findValue(i);
            System.out.println(i + &quot;) &quot; +p.findKey(i) + &quot;=&quot;+v);
        }
        System.out.println(&quot;Done!&quot;);

    }
    */
}
</pre>
</body>
</html>
