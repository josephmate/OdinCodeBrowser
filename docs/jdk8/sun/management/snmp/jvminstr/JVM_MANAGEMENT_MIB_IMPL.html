<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package sun.management.snmp.jvminstr;

// java imports
//
import java.util.Hashtable;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.lang.ref.WeakReference;

// jmx imports
//
import javax.management.MBeanServer;
import javax.management.ObjectName;
import javax.management.InstanceAlreadyExistsException;
import javax.management.NotificationEmitter;
import javax.management.NotificationListener;
import javax.management.Notification;
import javax.management.ListenerNotFoundException;
import javax.management.openmbean.CompositeData;

// jdmk imports
//
import com.sun.jmx.snmp.agent.SnmpMib;
import com.sun.jmx.snmp.daemon.SnmpAdaptorServer;
import com.sun.jmx.snmp.SnmpPeer;
import com.sun.jmx.snmp.SnmpParameters;

import com.sun.jmx.snmp.SnmpOidTable;
import com.sun.jmx.snmp.SnmpOid;
import com.sun.jmx.snmp.SnmpVarBindList;
import com.sun.jmx.snmp.SnmpVarBind;
import com.sun.jmx.snmp.SnmpCounter;
import com.sun.jmx.snmp.SnmpCounter64;
import com.sun.jmx.snmp.SnmpString;
import com.sun.jmx.snmp.SnmpInt;
import com.sun.jmx.snmp.Enumerated;
import com.sun.jmx.snmp.agent.SnmpMibTable;

import sun.management.snmp.jvmmib.JVM_MANAGEMENT_MIBOidTable;
import sun.management.snmp.jvmmib.JVM_MANAGEMENT_MIB;
import sun.management.snmp.jvmmib.JvmMemoryMeta;
import sun.management.snmp.jvmmib.JvmThreadingMeta;
import sun.management.snmp.jvmmib.JvmRuntimeMeta;
import sun.management.snmp.jvmmib.JvmClassLoadingMeta;
import sun.management.snmp.jvmmib.JvmCompilationMeta;
import sun.management.snmp.util.MibLogger;
import sun.management.snmp.util.SnmpCachedData;
import sun.management.snmp.util.SnmpTableHandler;

//java management imports
import java.lang.management.ManagementFactory;
import java.lang.management.MemoryPoolMXBean;
import java.lang.management.MemoryNotificationInfo;
import java.lang.management.MemoryType;

public class JVM_MANAGEMENT_MIB_IMPL extends JVM_MANAGEMENT_MIB {
    private static final long serialVersionUID = -8104825586888859831L;

    private static final MibLogger log =
        new MibLogger(JVM_MANAGEMENT_MIB_IMPL.class);

    private static WeakReference&lt;SnmpOidTable&gt; tableRef;

    public static SnmpOidTable getOidTable() {
        SnmpOidTable table = null;
        if(tableRef == null) {
            table =  new JVM_MANAGEMENT_MIBOidTable();
            tableRef = new WeakReference&lt;&gt;(table);
            return table;
        }

        table = tableRef.get();
        if(table == null) {
            table = new JVM_MANAGEMENT_MIBOidTable();
            tableRef = new WeakReference&lt;&gt;(table);
        }

        return table;
    }

    /**
     * Handler waiting for memory &lt;CODE&gt;Notification&lt;/CODE&gt;.
     * Translate each JMX notification in SNMP trap.
     */
    private class NotificationHandler implements NotificationListener {
        public void handleNotification(Notification notification,
                                       Object handback) {
            log.debug(&quot;handleNotification&quot;, &quot;Received notification [ &quot; +
                      notification.getType() + &quot;]&quot;);

            String type = notification.getType();
            if (type.equals(MemoryNotificationInfo.MEMORY_THRESHOLD_EXCEEDED) ||
                type.equals(MemoryNotificationInfo.
                    MEMORY_COLLECTION_THRESHOLD_EXCEEDED)) {
                MemoryNotificationInfo minfo = MemoryNotificationInfo.
                    from((CompositeData) notification.getUserData());
                SnmpCounter64 count = new SnmpCounter64(minfo.getCount());
                SnmpCounter64 used =
                    new SnmpCounter64(minfo.getUsage().getUsed());
                SnmpString poolName = new SnmpString(minfo.getPoolName());
                SnmpOid entryIndex =
                    getJvmMemPoolEntryIndex(minfo.getPoolName());

                if (entryIndex == null) {
                    log.error(&quot;handleNotification&quot;,
                              &quot;Error: Can't find entry index for Memory Pool: &quot;
                              + minfo.getPoolName() +&quot;: &quot; +
                              &quot;No trap emitted for &quot; + type);
                    return;
                }

                SnmpOid trap = null;

                final SnmpOidTable mibTable = getOidTable();
                try {
                    SnmpOid usedOid  = null;
                    SnmpOid countOid = null;

                    if (type.equals(MemoryNotificationInfo.
                                   MEMORY_THRESHOLD_EXCEEDED)) {
                        trap = new SnmpOid(mibTable.
                        resolveVarName(&quot;jvmLowMemoryPoolUsageNotif&quot;).getOid());
                        usedOid =
                            new SnmpOid(mibTable.
                            resolveVarName(&quot;jvmMemPoolUsed&quot;).getOid() +
                                    &quot;.&quot; + entryIndex);
                        countOid =
                            new SnmpOid(mibTable.
                            resolveVarName(&quot;jvmMemPoolThreshdCount&quot;).getOid()
                                    + &quot;.&quot; + entryIndex);
                    } else if  (type.equals(MemoryNotificationInfo.
                                   MEMORY_COLLECTION_THRESHOLD_EXCEEDED)) {
                        trap = new SnmpOid(mibTable.
                        resolveVarName(&quot;jvmLowMemoryPoolCollectNotif&quot;).
                                           getOid());
                        usedOid =
                            new SnmpOid(mibTable.
                            resolveVarName(&quot;jvmMemPoolCollectUsed&quot;).getOid() +
                                        &quot;.&quot; + entryIndex);
                        countOid =
                            new SnmpOid(mibTable.
                            resolveVarName(&quot;jvmMemPoolCollectThreshdCount&quot;).
                                        getOid() +
                                        &quot;.&quot; + entryIndex);
                    }

                    //Datas
                    SnmpVarBindList list = new SnmpVarBindList();
                    SnmpOid poolNameOid =
                        new SnmpOid(mibTable.
                                    resolveVarName(&quot;jvmMemPoolName&quot;).getOid() +
                                    &quot;.&quot; + entryIndex);

                    SnmpVarBind varCount = new SnmpVarBind(countOid, count);
                    SnmpVarBind varUsed = new SnmpVarBind(usedOid, used);
                    SnmpVarBind varPoolName = new SnmpVarBind(poolNameOid,
                                              poolName);

                    list.add(varPoolName);
                    list.add(varCount);
                    list.add(varUsed);

                    sendTrap(trap, list);
                }catch(Exception e) {
                    log.error(&quot;handleNotification&quot;,
                              &quot;Exception occurred : &quot; + e);
                }
            }
        }
    }

    /**
     * List of notification targets.
     */
    private ArrayList&lt;NotificationTarget&gt; notificationTargets =
            new ArrayList&lt;&gt;();
    private final NotificationEmitter emitter;
    private final NotificationHandler handler;


    /**
     * Instantiate a JVM MIB intrusmentation.
     * A &lt;CODE&gt;NotificationListener&lt;/CODE&gt; is added to the &lt;CODE&gt;MemoryMXBean&lt;/CODE&gt;
     * &lt;CODE&gt;NotificationEmitter&lt;/CODE&gt;
     */
    public JVM_MANAGEMENT_MIB_IMPL() {
        handler = new NotificationHandler();
        emitter = (NotificationEmitter) ManagementFactory.getMemoryMXBean();
        emitter.addNotificationListener(handler, null, null);
    }

    private synchronized void sendTrap(SnmpOid trap, SnmpVarBindList list) {
        final Iterator&lt;NotificationTarget&gt; iterator = notificationTargets.iterator();
        final SnmpAdaptorServer adaptor =
            (SnmpAdaptorServer) getSnmpAdaptor();

        if (adaptor == null) {
            log.error(&quot;sendTrap&quot;, &quot;Cannot send trap: adaptor is null.&quot;);
            return;
        }

        if (!adaptor.isActive()) {
            log.config(&quot;sendTrap&quot;, &quot;Adaptor is not active: trap not sent.&quot;);
            return;
        }

        while(iterator.hasNext()) {
            NotificationTarget target = null;
            try {
                target = iterator.next();
                SnmpPeer peer =
                    new SnmpPeer(target.getAddress(), target.getPort());
                SnmpParameters p = new SnmpParameters();
                p.setRdCommunity(target.getCommunity());
                peer.setParams(p);
                log.debug(&quot;handleNotification&quot;, &quot;Sending trap to &quot; +
                          target.getAddress() + &quot;:&quot; + target.getPort());
                adaptor.snmpV2Trap(peer, trap, list, null);
            }catch(Exception e) {
                log.error(&quot;sendTrap&quot;,
                          &quot;Exception occurred while sending trap to [&quot; +
                          target + &quot;]. Exception : &quot; + e);
                log.debug(&quot;sendTrap&quot;,e);
            }
        }
    }

    /**
     * Add a notification target.
     * @param target The target to add
     * @throws IllegalArgumentException If target parameter is null.
     */
    public synchronized void addTarget(NotificationTarget target)
        throws IllegalArgumentException {
        if(target == null)
            throw new IllegalArgumentException(&quot;Target is null&quot;);

        notificationTargets.add(target);
    }

    /**
     * Remove notification listener.
     */
    public void terminate() {
        try {
            emitter.removeNotificationListener(handler);
        }catch(ListenerNotFoundException e) {
            log.error(&quot;terminate&quot;, &quot;Listener Not found : &quot; + e);
        }
    }

    /**
     * Add notification targets.
     * @param targets A list of
     * &lt;CODE&gt;sun.management.snmp.jvminstr.NotificationTarget&lt;/CODE&gt;
     * @throws IllegalArgumentException If targets parameter is null.
     */
    public synchronized void addTargets(List&lt;NotificationTarget&gt; targets)
        throws IllegalArgumentException {
        if(targets == null)
            throw new IllegalArgumentException(&quot;Target list is null&quot;);

        notificationTargets.addAll(targets);
    }

    /**
     * Factory method for &quot;JvmMemory&quot; group MBean.
     *
     * You can redefine this method if you need to replace the default
     * generated MBean class with your own customized class.
     *
     * @param groupName Name of the group (&quot;JvmMemory&quot;)
     * @param groupOid  OID of this group
     * @param groupObjname ObjectName for this group (may be null)
     * @param server    MBeanServer for this group (may be null)
     *
     * @return An instance of the MBean class generated for the
     *         &quot;JvmMemory&quot; group (JvmMemory)
     *
     * Note that when using standard metadata,
     * the returned object must implement the &quot;JvmMemoryMBean&quot;
     * interface.
     **/
    protected Object createJvmMemoryMBean(String groupName,
                String groupOid,  ObjectName groupObjname,
                                          MBeanServer server)  {

        // Note that when using standard metadata,
        // the returned object must implement the &quot;JvmMemoryMBean&quot;
        // interface.
        //
        if (server != null)
            return new JvmMemoryImpl(this,server);
        else
            return new JvmMemoryImpl(this);
    }

    /**
     * Factory method for &quot;JvmMemory&quot; group metadata class.
     *
     * You can redefine this method if you need to replace the default
     * generated metadata class with your own customized class.
     *
     * @param groupName Name of the group (&quot;JvmMemory&quot;)
     * @param groupOid  OID of this group
     * @param groupObjname ObjectName for this group (may be null)
     * @param server    MBeanServer for this group (may be null)
     *
     * @return An instance of the metadata class generated for the
     *         &quot;JvmMemory&quot; group (JvmMemoryMeta)
     *
     **/
    protected JvmMemoryMeta createJvmMemoryMetaNode(String groupName,
                                                    String groupOid,
                                                    ObjectName groupObjname,
                                                    MBeanServer server) {
        return new JvmMemoryMetaImpl(this, objectserver);
    }

    /**
     * Factory method for &quot;JvmThreading&quot; group metadata class.
     *
     * You can redefine this method if you need to replace the default
     * generated metadata class with your own customized class.
     *
     * @param groupName Name of the group (&quot;JvmThreading&quot;)
     * @param groupOid  OID of this group
     * @param groupObjname ObjectName for this group (may be null)
     * @param server    MBeanServer for this group (may be null)
     *
     * @return An instance of the metadata class generated for the
     *         &quot;JvmThreading&quot; group (JvmThreadingMeta)
     *
     **/
    protected JvmThreadingMeta createJvmThreadingMetaNode(String groupName,
                                                          String groupOid,
                                                          ObjectName groupObjname,
                                                          MBeanServer server)  {
        return new JvmThreadingMetaImpl(this, objectserver);
    }

    /**
     * Factory method for &quot;JvmThreading&quot; group MBean.
     *
     * You can redefine this method if you need to replace the default
     * generated MBean class with your own customized class.
     *
     * @param groupName Name of the group (&quot;JvmThreading&quot;)
     * @param groupOid  OID of this group
     * @param groupObjname ObjectName for this group (may be null)
     * @param server    MBeanServer for this group (may be null)
     *
     * @return An instance of the MBean class generated for the
     *         &quot;JvmThreading&quot; group (JvmThreading)
     *
     * Note that when using standard metadata,
     * the returned object must implement the &quot;JvmThreadingMBean&quot;
     * interface.
     **/
    protected Object createJvmThreadingMBean(String groupName,
                                             String groupOid,
                                             ObjectName groupObjname,
                                             MBeanServer server)  {

        // Note that when using standard metadata,
        // the returned object must implement the &quot;JvmThreadingMBean&quot;
        // interface.
        //
        if (server != null)
            return new JvmThreadingImpl(this,server);
        else
            return new JvmThreadingImpl(this);
    }

    /**
     * Factory method for &quot;JvmRuntime&quot; group metadata class.
     *
     * You can redefine this method if you need to replace the default
     * generated metadata class with your own customized class.
     *
     * @param groupName Name of the group (&quot;JvmRuntime&quot;)
     * @param groupOid  OID of this group
     * @param groupObjname ObjectName for this group (may be null)
     * @param server    MBeanServer for this group (may be null)
     *
     * @return An instance of the metadata class generated for the
     *         &quot;JvmRuntime&quot; group (JvmRuntimeMeta)
     *
     **/
    protected JvmRuntimeMeta createJvmRuntimeMetaNode(String groupName,
                                                      String groupOid,
                                                      ObjectName groupObjname,
                                                      MBeanServer server)  {
        return new JvmRuntimeMetaImpl(this, objectserver);
    }

    /**
     * Factory method for &quot;JvmRuntime&quot; group MBean.
     *
     * You can redefine this method if you need to replace the default
     * generated MBean class with your own customized class.
     *
     * @param groupName Name of the group (&quot;JvmRuntime&quot;)
     * @param groupOid  OID of this group
     * @param groupObjname ObjectName for this group (may be null)
     * @param server    MBeanServer for this group (may be null)
     *
     * @return An instance of the MBean class generated for the
     *         &quot;JvmRuntime&quot; group (JvmRuntime)
     *
     * Note that when using standard metadata,
     * the returned object must implement the &quot;JvmRuntimeMBean&quot;
     * interface.
     **/
    protected Object createJvmRuntimeMBean(String groupName,
                                           String groupOid,
                                           ObjectName groupObjname,
                                           MBeanServer server)  {

        // Note that when using standard metadata,
        // the returned object must implement the &quot;JvmRuntimeMBean&quot;
        // interface.
        //
        if (server != null)
            return new JvmRuntimeImpl(this,server);
        else
            return new JvmRuntimeImpl(this);
    }

    /**
     * Factory method for &quot;JvmCompilation&quot; group metadata class.
     *
     * You can redefine this method if you need to replace the default
     * generated metadata class with your own customized class.
     *
     * @param groupName Name of the group (&quot;JvmCompilation&quot;)
     * @param groupOid  OID of this group
     * @param groupObjname ObjectName for this group (may be null)
     * @param server    MBeanServer for this group (may be null)
     *
     * @return An instance of the metadata class generated for the
     *         &quot;JvmCompilation&quot; group (JvmCompilationMeta)
     *
     **/
    protected JvmCompilationMeta
        createJvmCompilationMetaNode(String groupName,
                                     String groupOid,
                                     ObjectName groupObjname,
                                     MBeanServer server)  {
        // If there is no compilation system, the jvmCompilation  will not
        // be instantiated.
        //
        if (ManagementFactory.getCompilationMXBean() == null) return null;
        return super.createJvmCompilationMetaNode(groupName,groupOid,
                                                  groupObjname,server);
    }

    /**
     * Factory method for &quot;JvmCompilation&quot; group MBean.
     *
     * You can redefine this method if you need to replace the default
     * generated MBean class with your own customized class.
     *
     * @param groupName Name of the group (&quot;JvmCompilation&quot;)
     * @param groupOid  OID of this group
     * @param groupObjname ObjectName for this group (may be null)
     * @param server    MBeanServer for this group (may be null)
     *
     * @return An instance of the MBean class generated for the
     *         &quot;JvmCompilation&quot; group (JvmCompilation)
     *
     * Note that when using standard metadata,
     * the returned object must implement the &quot;JvmCompilationMBean&quot;
     * interface.
     **/
    protected Object createJvmCompilationMBean(String groupName,
                String groupOid,  ObjectName groupObjname, MBeanServer server)  {

        // Note that when using standard metadata,
        // the returned object must implement the &quot;JvmCompilationMBean&quot;
        // interface.
        //
        if (server != null)
            return new JvmCompilationImpl(this,server);
        else
            return new JvmCompilationImpl(this);
    }

    /**
     * Factory method for &quot;JvmOS&quot; group MBean.
     *
     * You can redefine this method if you need to replace the default
     * generated MBean class with your own customized class.
     *
     * @param groupName Name of the group (&quot;JvmOS&quot;)
     * @param groupOid  OID of this group
     * @param groupObjname ObjectName for this group (may be null)
     * @param server    MBeanServer for this group (may be null)
     *
     * @return An instance of the MBean class generated for the
     *         &quot;JvmOS&quot; group (JvmOS)
     *
     * Note that when using standard metadata,
     * the returned object must implement the &quot;JvmOSMBean&quot;
     * interface.
     **/
    protected Object createJvmOSMBean(String groupName,
                String groupOid,  ObjectName groupObjname, MBeanServer server)  {

        // Note that when using standard metadata,
        // the returned object must implement the &quot;JvmOSMBean&quot;
        // interface.
        //
        if (server != null)
            return new JvmOSImpl(this,server);
        else
            return new JvmOSImpl(this);
    }


    /**
     * Factory method for &quot;JvmClassLoading&quot; group MBean.
     *
     * You can redefine this method if you need to replace the default
     * generated MBean class with your own customized class.
     *
     * @param groupName Name of the group (&quot;JvmClassLoading&quot;)
     * @param groupOid  OID of this group
     * @param groupObjname ObjectName for this group (may be null)
     * @param server    MBeanServer for this group (may be null)
     *
     * @return An instance of the MBean class generated for the
     *         &quot;JvmClassLoading&quot; group (JvmClassLoading)
     *
     * Note that when using standard metadata,
     * the returned object must implement the &quot;JvmClassLoadingMBean&quot;
     * interface.
     **/
    protected Object createJvmClassLoadingMBean(String groupName,
                                                String groupOid,
                                                ObjectName groupObjname,
                                                MBeanServer server)  {

        // Note that when using standard metadata,
        // the returned object must implement the &quot;JvmClassLoadingMBean&quot;
        // interface.
        //
        if (server != null)
            return new JvmClassLoadingImpl(this,server);
        else
            return new JvmClassLoadingImpl(this);
    }

    static String validDisplayStringTC(String str) {

        if(str == null) return &quot;&quot;;

        if(str.length() &gt; DISPLAY_STRING_MAX_LENGTH) {
            return str.substring(0, DISPLAY_STRING_MAX_LENGTH);
        }
        else
            return str;
    }

    static String validJavaObjectNameTC(String str) {

        if(str == null) return &quot;&quot;;

        if(str.length() &gt; JAVA_OBJECT_NAME_MAX_LENGTH) {
            return str.substring(0, JAVA_OBJECT_NAME_MAX_LENGTH);
        }
        else
            return str;
    }

    static String validPathElementTC(String str) {

        if(str == null) return &quot;&quot;;

        if(str.length() &gt; PATH_ELEMENT_MAX_LENGTH) {
            return str.substring(0, PATH_ELEMENT_MAX_LENGTH);
        }
        else
            return str;
    }
    static String validArgValueTC(String str) {

        if(str == null) return &quot;&quot;;

        if(str.length() &gt; ARG_VALUE_MAX_LENGTH) {
            return str.substring(0, ARG_VALUE_MAX_LENGTH);
        }
        else
            return str;
    }

    /**
     * WARNING: This should probably be moved to JvmMemPoolTableMetaImpl
     **/
    private SnmpTableHandler getJvmMemPoolTableHandler(Object userData) {
        final SnmpMibTable meta =
            getRegisteredTableMeta(&quot;JvmMemPoolTable&quot;);
        if (! (meta instanceof JvmMemPoolTableMetaImpl)) {
            final String err = ((meta==null)?&quot;No metadata for JvmMemPoolTable&quot;:
                                &quot;Bad metadata class for JvmMemPoolTable: &quot; +
                                meta.getClass().getName());
            log.error(&quot;getJvmMemPoolTableHandler&quot;, err);
            return null;
        }
        final JvmMemPoolTableMetaImpl memPoolTable =
            (JvmMemPoolTableMetaImpl) meta;
        return memPoolTable.getHandler(userData);
    }

    /**
     * WARNING: This should probably be moved to JvmMemPoolTableMetaImpl
     **/
    private int findInCache(SnmpTableHandler handler,
                            String poolName) {

        if (!(handler instanceof SnmpCachedData)) {
            if (handler != null) {
                final String err = &quot;Bad class for JvmMemPoolTable datas: &quot; +
                    handler.getClass().getName();
                log.error(&quot;getJvmMemPoolEntry&quot;, err);
            }
            return -1;
        }

        final SnmpCachedData data = (SnmpCachedData)handler;
        final int len = data.datas.length;
        for (int i=0; i &lt; data.datas.length ; i++) {
            final MemoryPoolMXBean pool = (MemoryPoolMXBean) data.datas[i];
            if (poolName.equals(pool.getName())) return i;
        }
        return -1;
    }

    /**
     * WARNING: This should probably be moved to JvmMemPoolTableMetaImpl
     **/
    private SnmpOid getJvmMemPoolEntryIndex(SnmpTableHandler handler,
                                            String poolName) {
        final int index = findInCache(handler,poolName);
        if (index &lt; 0) return null;
        return ((SnmpCachedData)handler).indexes[index];
    }

    private SnmpOid getJvmMemPoolEntryIndex(String poolName) {
        return getJvmMemPoolEntryIndex(getJvmMemPoolTableHandler(null),
                                       poolName);
    }

    // cache validity
    //
    // Should we define a property for this? Should we have different
    // cache validity periods depending on which table we cache?
    //
    public long validity() {
        return DEFAULT_CACHE_VALIDITY_PERIOD;
    }

    // Defined in RFC 2579
    private final static int DISPLAY_STRING_MAX_LENGTH=255;
    private final static int JAVA_OBJECT_NAME_MAX_LENGTH=1023;
    private final static int PATH_ELEMENT_MAX_LENGTH=1023;
    private final static int ARG_VALUE_MAX_LENGTH=1023;
    private final static int DEFAULT_CACHE_VALIDITY_PERIOD=1000;
}
</pre>
</body>
</html>
