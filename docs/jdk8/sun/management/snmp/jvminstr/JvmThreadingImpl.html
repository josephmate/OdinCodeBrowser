<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package sun.management.snmp.jvminstr;

// java imports
//
import java.io.Serializable;

import java.lang.management.ThreadMXBean;
import java.lang.management.ManagementFactory;

// jmx imports
//
import javax.management.MBeanServer;
import com.sun.jmx.snmp.SnmpString;
import com.sun.jmx.snmp.SnmpStatusException;

// jdmk imports
//
import com.sun.jmx.snmp.agent.SnmpMib;
import com.sun.jmx.snmp.SnmpDefinitions;

import sun.management.snmp.jvmmib.JvmThreadingMBean;
import sun.management.snmp.jvmmib.EnumJvmThreadCpuTimeMonitoring;
import sun.management.snmp.jvmmib.EnumJvmThreadContentionMonitoring;
import sun.management.snmp.util.MibLogger;

/**
 * The class is used for implementing the &quot;JvmThreading&quot; group.
 */
public class JvmThreadingImpl implements JvmThreadingMBean {

    /**
     * Variable for storing the value of &quot;JvmThreadCpuTimeMonitoring&quot;.
     *
     * &quot;The state of the Thread CPU Time Monitoring feature.
     * This feature can be:
     *
     * unsupported: The JVM does not support Thread CPU Time Monitoring.
     * enabled    : The JVM supports Thread CPU Time Monitoring, and it
     * is enabled.
     * disabled   : The JVM supports Thread CPU Time Monitoring, and it
     * is disabled.
     *
     * Only enabled(3) and disabled(4) may be supplied as values to a
     * SET request. unsupported(1) can only be set internally by the
     * agent.
     *
     * See java.lang.management.ThreadMXBean.isThreadCpuTimeSupported(),
     * java.lang.management.ThreadMXBean.isThreadCpuTimeEnabled(),
     * java.lang.management.ThreadMXBean.setThreadCpuTimeEnabled()
     * &quot;
     *
     */
    final static EnumJvmThreadCpuTimeMonitoring
        JvmThreadCpuTimeMonitoringUnsupported =
        new EnumJvmThreadCpuTimeMonitoring(&quot;unsupported&quot;);
    final static EnumJvmThreadCpuTimeMonitoring
        JvmThreadCpuTimeMonitoringEnabled =
        new EnumJvmThreadCpuTimeMonitoring(&quot;enabled&quot;);
    final static EnumJvmThreadCpuTimeMonitoring
        JvmThreadCpuTimeMonitoringDisabled =
        new EnumJvmThreadCpuTimeMonitoring(&quot;disabled&quot;);


    /**
     * Variable for storing the value of &quot;JvmThreadContentionMonitoring&quot;.
     *
     * &quot;The state of the Thread Contention Monitoring feature.
     * This feature can be:
     *
     * unsupported: The JVM does not support Thread Contention Monitoring.
     * enabled    : The JVM supports Thread Contention Monitoring, and it
     * is enabled.
     * disabled   : The JVM supports Thread Contention Monitoring, and it
     * is disabled.
     *
     * Only enabled(3) and disabled(4) may be supplied as values to a
     * SET request. unsupported(1) can only be set internally by the
     * agent.
     *
     * See java.lang.management.ThreadMXBean.isThreadContentionMonitoringSupported(),
     * java.lang.management.ThreadMXBean.isThreadContentionMonitoringEnabled(),
     * java.lang.management.ThreadMXBean.setThreadContentionMonitoringEnabled()
     * &quot;
     *
     */
    static final EnumJvmThreadContentionMonitoring
        JvmThreadContentionMonitoringUnsupported =
        new EnumJvmThreadContentionMonitoring(&quot;unsupported&quot;);
    static final EnumJvmThreadContentionMonitoring
        JvmThreadContentionMonitoringEnabled =
        new EnumJvmThreadContentionMonitoring(&quot;enabled&quot;);
    static final EnumJvmThreadContentionMonitoring
        JvmThreadContentionMonitoringDisabled =
        new EnumJvmThreadContentionMonitoring(&quot;disabled&quot;);

    /**
     * Constructor for the &quot;JvmThreading&quot; group.
     * If the group contains a table, the entries created through an SNMP SET
     * will not be registered in Java DMK.
     */
    public JvmThreadingImpl(SnmpMib myMib) {
        log.debug(&quot;JvmThreadingImpl&quot;,&quot;Constructor&quot;);
    }


    /**
     * Constructor for the &quot;JvmThreading&quot; group.
     * If the group contains a table, the entries created through an SNMP SET
     * will be AUTOMATICALLY REGISTERED in Java DMK.
     */
    public JvmThreadingImpl(SnmpMib myMib, MBeanServer server) {
        log.debug(&quot;JvmThreadingImpl&quot;,&quot;Constructor with server&quot;);
    }

    /**
     * ThreadMXBean accessor. It is acquired from the
     * java.lang.management.ManagementFactory
     * @return The local ThreadMXBean.
     */
    static ThreadMXBean getThreadMXBean() {
        return ManagementFactory.getThreadMXBean();
    }

    /**
     * Getter for the &quot;JvmThreadCpuTimeMonitoring&quot; variable.
     */
    public EnumJvmThreadCpuTimeMonitoring getJvmThreadCpuTimeMonitoring()
        throws SnmpStatusException {

        ThreadMXBean mbean = getThreadMXBean();

        if(!mbean.isThreadCpuTimeSupported()) {
            log.debug(&quot;getJvmThreadCpuTimeMonitoring&quot;,
                      &quot;Unsupported ThreadCpuTimeMonitoring&quot;);
            return JvmThreadCpuTimeMonitoringUnsupported;
        }

        try {
            if(mbean.isThreadCpuTimeEnabled()) {
                log.debug(&quot;getJvmThreadCpuTimeMonitoring&quot;,
                      &quot;Enabled ThreadCpuTimeMonitoring&quot;);
                return JvmThreadCpuTimeMonitoringEnabled;
            } else {
                log.debug(&quot;getJvmThreadCpuTimeMonitoring&quot;,
                          &quot;Disabled ThreadCpuTimeMonitoring&quot;);
                return JvmThreadCpuTimeMonitoringDisabled;
            }
        }catch(UnsupportedOperationException e) {
            log.debug(&quot;getJvmThreadCpuTimeMonitoring&quot;,
                      &quot;Newly unsupported ThreadCpuTimeMonitoring&quot;);

            return JvmThreadCpuTimeMonitoringUnsupported;
        }
    }

    /**
     * Setter for the &quot;JvmThreadCpuTimeMonitoring&quot; variable.
     */
    public void setJvmThreadCpuTimeMonitoring(EnumJvmThreadCpuTimeMonitoring x)
        throws SnmpStatusException {

        ThreadMXBean mbean = getThreadMXBean();

        // We can trust the received value, it has been checked in
        // checkJvmThreadCpuTimeMonitoring
        if(JvmThreadCpuTimeMonitoringEnabled.intValue() == x.intValue())
            mbean.setThreadCpuTimeEnabled(true);
        else
            mbean.setThreadCpuTimeEnabled(false);
    }

    /**
     * Checker for the &quot;JvmThreadCpuTimeMonitoring&quot; variable.
     */
    public void checkJvmThreadCpuTimeMonitoring(EnumJvmThreadCpuTimeMonitoring
                                                x)
        throws SnmpStatusException {

        //Can't be set externaly to unsupported state.
        if(JvmThreadCpuTimeMonitoringUnsupported.intValue() == x.intValue()) {
             log.debug(&quot;checkJvmThreadCpuTimeMonitoring&quot;,
                      &quot;Try to set to illegal unsupported value&quot;);
            throw new SnmpStatusException(SnmpDefinitions.snmpRspWrongValue);
        }

        if ((JvmThreadCpuTimeMonitoringEnabled.intValue() == x.intValue()) ||
            (JvmThreadCpuTimeMonitoringDisabled.intValue() == x.intValue())) {

            // The value is a valid value. But is the feature supported?
            ThreadMXBean mbean = getThreadMXBean();
            if(mbean.isThreadCpuTimeSupported()) return;

            // Not supported.
            log.debug(&quot;checkJvmThreadCpuTimeMonitoring&quot;,
                      &quot;Unsupported operation, can't set state&quot;);
            throw new
                SnmpStatusException(SnmpDefinitions.snmpRspInconsistentValue);
        }

        // Unknown value.
        log.debug(&quot;checkJvmThreadCpuTimeMonitoring&quot;,
                  &quot;unknown enum value &quot;);
        throw new SnmpStatusException(SnmpDefinitions.snmpRspWrongValue);
    }

    /**
     * Getter for the &quot;JvmThreadContentionMonitoring&quot; variable.
     */
    public EnumJvmThreadContentionMonitoring getJvmThreadContentionMonitoring()
        throws SnmpStatusException {

        ThreadMXBean mbean = getThreadMXBean();

        if(!mbean.isThreadContentionMonitoringSupported()) {
            log.debug(&quot;getJvmThreadContentionMonitoring&quot;,
                      &quot;Unsupported ThreadContentionMonitoring&quot;);
            return JvmThreadContentionMonitoringUnsupported;
        }

        if(mbean.isThreadContentionMonitoringEnabled()) {
            log.debug(&quot;getJvmThreadContentionMonitoring&quot;,
                      &quot;Enabled ThreadContentionMonitoring&quot;);
            return JvmThreadContentionMonitoringEnabled;
        } else {
            log.debug(&quot;getJvmThreadContentionMonitoring&quot;,
                      &quot;Disabled ThreadContentionMonitoring&quot;);
            return JvmThreadContentionMonitoringDisabled;
        }
    }

    /**
     * Setter for the &quot;JvmThreadContentionMonitoring&quot; variable.
     */
    public void setJvmThreadContentionMonitoring(
                            EnumJvmThreadContentionMonitoring x)
        throws SnmpStatusException {
        ThreadMXBean mbean = getThreadMXBean();

        // We can trust the received value, it has been checked in
        // checkJvmThreadContentionMonitoring
        if(JvmThreadContentionMonitoringEnabled.intValue() == x.intValue())
            mbean.setThreadContentionMonitoringEnabled(true);
        else
            mbean.setThreadContentionMonitoringEnabled(false);
    }

    /**
     * Checker for the &quot;JvmThreadContentionMonitoring&quot; variable.
     */
    public void checkJvmThreadContentionMonitoring(
                              EnumJvmThreadContentionMonitoring x)
        throws SnmpStatusException {
        //Can't be set externaly to unsupported state.
        if(JvmThreadContentionMonitoringUnsupported.intValue()==x.intValue()) {
            log.debug(&quot;checkJvmThreadContentionMonitoring&quot;,
                      &quot;Try to set to illegal unsupported value&quot;);
            throw new SnmpStatusException(SnmpDefinitions.snmpRspWrongValue);
        }

        if ((JvmThreadContentionMonitoringEnabled.intValue()==x.intValue()) ||
            (JvmThreadContentionMonitoringDisabled.intValue()==x.intValue())) {

            // The value is valid, but is the feature supported ?
            ThreadMXBean mbean = getThreadMXBean();
            if(mbean.isThreadContentionMonitoringSupported()) return;

            log.debug(&quot;checkJvmThreadContentionMonitoring&quot;,
                      &quot;Unsupported operation, can't set state&quot;);
            throw new
                SnmpStatusException(SnmpDefinitions.snmpRspInconsistentValue);
        }

        log.debug(&quot;checkJvmThreadContentionMonitoring&quot;,
                  &quot;Try to set to unknown value&quot;);
        throw new SnmpStatusException(SnmpDefinitions.snmpRspWrongValue);
    }

    /**
     * Getter for the &quot;JvmThreadTotalStartedCount&quot; variable.
     */
    public Long getJvmThreadTotalStartedCount() throws SnmpStatusException {
        return new Long(getThreadMXBean().getTotalStartedThreadCount());
    }

    /**
     * Getter for the &quot;JvmThreadPeakCount&quot; variable.
     */
    public Long getJvmThreadPeakCount() throws SnmpStatusException {
        return  new Long(getThreadMXBean().getPeakThreadCount());
    }

    /**
     * Getter for the &quot;JvmThreadDaemonCount&quot; variable.
     */
    public Long getJvmThreadDaemonCount() throws SnmpStatusException {
        return new Long(getThreadMXBean().getDaemonThreadCount());
    }

    /**
     * Getter for the &quot;JvmThreadCount&quot; variable.
     */
    public Long getJvmThreadCount() throws SnmpStatusException {
        return new Long(getThreadMXBean().getThreadCount());
    }

   /**
     * Getter for the &quot;JvmThreadPeakCountReset&quot; variable.
     */
    public synchronized Long getJvmThreadPeakCountReset()
        throws SnmpStatusException {
        return new Long(jvmThreadPeakCountReset);
    }

    /**
     * Setter for the &quot;JvmThreadPeakCountReset&quot; variable.
     */
    public synchronized void setJvmThreadPeakCountReset(Long x)
        throws SnmpStatusException {
        final long l = x.longValue();
        if (l &gt; jvmThreadPeakCountReset) {
            final long stamp = System.currentTimeMillis();
            getThreadMXBean().resetPeakThreadCount();
            jvmThreadPeakCountReset = stamp;
            log.debug(&quot;setJvmThreadPeakCountReset&quot;,
                      &quot;jvmThreadPeakCountReset=&quot;+stamp);
        }
    }

    /**
     * Checker for the &quot;JvmThreadPeakCountReset&quot; variable.
     */
    public void checkJvmThreadPeakCountReset(Long x)
        throws SnmpStatusException {
    }

    /* Last time thread peak count was reset */
    private long jvmThreadPeakCountReset=0;

    static final MibLogger log = new MibLogger(JvmThreadingImpl.class);
}
</pre>
</body>
</html>
