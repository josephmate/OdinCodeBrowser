<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package sun.management.snmp.jvminstr;

// java imports
//
import java.util.Map;

// jmx imports
//
import com.sun.jmx.snmp.SnmpStatusException;
import com.sun.jmx.snmp.SnmpDefinitions;

// jdmk imports
//

import java.lang.management.MemoryUsage;
import java.lang.management.MemoryType;
import java.lang.management.MemoryPoolMXBean;

import sun.management.snmp.jvmmib.JvmMemPoolEntryMBean;
import sun.management.snmp.jvmmib.EnumJvmMemPoolState;
import sun.management.snmp.jvmmib.EnumJvmMemPoolType;
import sun.management.snmp.jvmmib.EnumJvmMemPoolThreshdSupport;
import sun.management.snmp.jvmmib.EnumJvmMemPoolCollectThreshdSupport;
import sun.management.snmp.util.MibLogger;
import sun.management.snmp.util.JvmContextFactory;

/**
 * The class is used for implementing the &quot;JvmMemPoolEntry&quot; group.
 */
public class JvmMemPoolEntryImpl implements JvmMemPoolEntryMBean {

    /**
     * Variable for storing the value of &quot;JvmMemPoolIndex&quot;.
     *
     * &quot;An index value opaquely computed by the agent which uniquely
     * identifies a row in the jvmMemPoolTable.
     * &quot;
     *
     */
    final protected int jvmMemPoolIndex;


    final static String memoryTag = &quot;jvmMemPoolEntry.getUsage&quot;;
    final static String peakMemoryTag = &quot;jvmMemPoolEntry.getPeakUsage&quot;;
    final static String collectMemoryTag =
        &quot;jvmMemPoolEntry.getCollectionUsage&quot;;
    final static MemoryUsage ZEROS = new MemoryUsage(0,0,0,0);

    final String entryMemoryTag;
    final String entryPeakMemoryTag;
    final String entryCollectMemoryTag;

    MemoryUsage getMemoryUsage() {
        try {
            final Map&lt;Object, Object&gt; m = JvmContextFactory.getUserData();

            if (m != null) {
                final MemoryUsage cached = (MemoryUsage)
                    m.get(entryMemoryTag);
                if (cached != null) {
                    log.debug(&quot;getMemoryUsage&quot;,entryMemoryTag+
                          &quot; found in cache.&quot;);
                    return cached;
                }

                MemoryUsage u = pool.getUsage();
                if (u == null) u = ZEROS;

                m.put(entryMemoryTag,u);
                return u;
            }
            // Should never come here.
            // Log error!
            log.trace(&quot;getMemoryUsage&quot;, &quot;ERROR: should never come here!&quot;);
            return pool.getUsage();
        } catch (RuntimeException x) {
            log.trace(&quot;getMemoryUsage&quot;,
                  &quot;Failed to get MemoryUsage: &quot; + x);
            log.debug(&quot;getMemoryUsage&quot;,x);
            throw x;
        }

    }

    MemoryUsage getPeakMemoryUsage() {
        try {
            final Map&lt;Object, Object&gt; m = JvmContextFactory.getUserData();

            if (m != null) {
                final MemoryUsage cached = (MemoryUsage)
                    m.get(entryPeakMemoryTag);
                if (cached != null) {
                    if (log.isDebugOn())
                        log.debug(&quot;getPeakMemoryUsage&quot;,
                              entryPeakMemoryTag + &quot; found in cache.&quot;);
                    return cached;
                }

                MemoryUsage u = pool.getPeakUsage();
                if (u == null) u = ZEROS;

                m.put(entryPeakMemoryTag,u);
                return u;
            }
            // Should never come here.
            // Log error!
            log.trace(&quot;getPeakMemoryUsage&quot;, &quot;ERROR: should never come here!&quot;);
            return ZEROS;
        } catch (RuntimeException x) {
            log.trace(&quot;getPeakMemoryUsage&quot;,
                  &quot;Failed to get MemoryUsage: &quot; + x);
            log.debug(&quot;getPeakMemoryUsage&quot;,x);
            throw x;
        }

    }

    MemoryUsage getCollectMemoryUsage() {
        try {
            final Map&lt;Object, Object&gt; m = JvmContextFactory.getUserData();

            if (m != null) {
                final MemoryUsage cached = (MemoryUsage)
                    m.get(entryCollectMemoryTag);
                if (cached != null) {
                    if (log.isDebugOn())
                        log.debug(&quot;getCollectMemoryUsage&quot;,
                                  entryCollectMemoryTag + &quot; found in cache.&quot;);
                    return cached;
                }

                MemoryUsage u = pool.getCollectionUsage();
                if (u == null) u = ZEROS;

                m.put(entryCollectMemoryTag,u);
                return u;
            }
            // Should never come here.
            // Log error!
            log.trace(&quot;getCollectMemoryUsage&quot;,
                      &quot;ERROR: should never come here!&quot;);
            return ZEROS;
        } catch (RuntimeException x) {
            log.trace(&quot;getPeakMemoryUsage&quot;,
                  &quot;Failed to get MemoryUsage: &quot; + x);
            log.debug(&quot;getPeakMemoryUsage&quot;,x);
            throw x;
        }

    }

    final MemoryPoolMXBean pool;

    /**
     * Constructor for the &quot;JvmMemPoolEntry&quot; group.
     */
    public JvmMemPoolEntryImpl(MemoryPoolMXBean mp, final int index) {
        this.pool=mp;
        this.jvmMemPoolIndex = index;
        this.entryMemoryTag = memoryTag + &quot;.&quot; + index;
        this.entryPeakMemoryTag = peakMemoryTag + &quot;.&quot; + index;
        this.entryCollectMemoryTag = collectMemoryTag + &quot;.&quot; + index;
    }

    /**
     * Getter for the &quot;JvmMemPoolMaxSize&quot; variable.
     */
    public Long getJvmMemPoolMaxSize() throws SnmpStatusException {
        final long val = getMemoryUsage().getMax();
        if (val &gt; -1) return  new Long(val);
        else return JvmMemoryImpl.Long0;
    }

    /**
     * Getter for the &quot;JvmMemPoolUsed&quot; variable.
     */
    public Long getJvmMemPoolUsed() throws SnmpStatusException {
        final long val = getMemoryUsage().getUsed();
        if (val &gt; -1) return  new Long(val);
        else return JvmMemoryImpl.Long0;
    }

    /**
     * Getter for the &quot;JvmMemPoolInitSize&quot; variable.
     */
    public Long getJvmMemPoolInitSize() throws SnmpStatusException {
        final long val = getMemoryUsage().getInit();
        if (val &gt; -1) return  new Long(val);
        else return JvmMemoryImpl.Long0;
    }

    /**
     * Getter for the &quot;JvmMemPoolCommitted&quot; variable.
     */
    public Long getJvmMemPoolCommitted() throws SnmpStatusException {
        final long val = getMemoryUsage().getCommitted();
        if (val &gt; -1) return  new Long(val);
        else return JvmMemoryImpl.Long0;
    }

    /**
     * Getter for the &quot;JvmMemPoolPeakMaxSize&quot; variable.
     */
    public Long getJvmMemPoolPeakMaxSize() throws SnmpStatusException {
        final long val = getPeakMemoryUsage().getMax();
        if (val &gt; -1) return  new Long(val);
        else return JvmMemoryImpl.Long0;
    }

    /**
     * Getter for the &quot;JvmMemPoolPeakUsed&quot; variable.
     */
    public Long getJvmMemPoolPeakUsed() throws SnmpStatusException {
        final long val = getPeakMemoryUsage().getUsed();
        if (val &gt; -1) return  new Long(val);
        else return JvmMemoryImpl.Long0;
    }

    /**
     * Getter for the &quot;JvmMemPoolPeakCommitted&quot; variable.
     */
    public Long getJvmMemPoolPeakCommitted() throws SnmpStatusException {
        final long val = getPeakMemoryUsage().getCommitted();
        if (val &gt; -1) return  new Long(val);
        else return JvmMemoryImpl.Long0;
    }

    /**
     * Getter for the &quot;JvmMemPoolCollectMaxSize&quot; variable.
     */
    public Long getJvmMemPoolCollectMaxSize() throws SnmpStatusException {
        final long val = getCollectMemoryUsage().getMax();
        if (val &gt; -1) return  new Long(val);
        else return JvmMemoryImpl.Long0;
    }

    /**
     * Getter for the &quot;JvmMemPoolCollectUsed&quot; variable.
     */
    public Long getJvmMemPoolCollectUsed() throws SnmpStatusException {
        final long val = getCollectMemoryUsage().getUsed();
        if (val &gt; -1) return  new Long(val);
        else return JvmMemoryImpl.Long0;
    }

    /**
     * Getter for the &quot;JvmMemPoolCollectCommitted&quot; variable.
     */
    public Long getJvmMemPoolCollectCommitted() throws SnmpStatusException {
        final long val = getCollectMemoryUsage().getCommitted();
        if (val &gt; -1) return  new Long(val);
        else return JvmMemoryImpl.Long0;
    }

    /**
     * Getter for the &quot;JvmMemPoolThreshold&quot; variable.
     */
    public Long getJvmMemPoolThreshold() throws SnmpStatusException {
        if (!pool.isUsageThresholdSupported())
            return JvmMemoryImpl.Long0;
        final long val = pool.getUsageThreshold();
        if (val &gt; -1) return  new Long(val);
        else return JvmMemoryImpl.Long0;
    }

    /**
     * Setter for the &quot;JvmMemPoolThreshold&quot; variable.
     */
    public void setJvmMemPoolThreshold(Long x) throws SnmpStatusException {
        final long val = x.longValue();
        if (val &lt; 0 )
            throw new SnmpStatusException(SnmpDefinitions.snmpRspWrongValue);
        // This should never throw an exception has the checks have
        // already been performed in checkJvmMemPoolThreshold().
        //
        pool.setUsageThreshold(val);
    }

    /**
     * Checker for the &quot;JvmMemPoolThreshold&quot; variable.
     */
    public void checkJvmMemPoolThreshold(Long x) throws SnmpStatusException {
        // if threshold is -1, it means that low memory detection is not
        // supported.

        if (!pool.isUsageThresholdSupported())
            throw new
                SnmpStatusException(SnmpDefinitions.snmpRspInconsistentValue);
        final long val = x.longValue();
        if (val &lt; 0 )
            throw new SnmpStatusException(SnmpDefinitions.snmpRspWrongValue);
    }

    /**
     * Getter for the &quot;JvmMemPoolThreshdSupport&quot; variable.
     */
    public EnumJvmMemPoolThreshdSupport getJvmMemPoolThreshdSupport()
        throws SnmpStatusException {
        if (pool.isUsageThresholdSupported())
            return EnumJvmMemPoolThreshdSupported;
        else
            return EnumJvmMemPoolThreshdUnsupported;
    }

    /**
     * Getter for the &quot;JvmMemPoolThreshdCount&quot; variable.
     */
    public Long getJvmMemPoolThreshdCount()
        throws SnmpStatusException {
        if (!pool.isUsageThresholdSupported())
            return JvmMemoryImpl.Long0;
        final long val = pool.getUsageThresholdCount();
        if (val &gt; -1) return  new Long(val);
        else return JvmMemoryImpl.Long0;
    }

    /**
     * Getter for the &quot;JvmMemPoolCollectThreshold&quot; variable.
     */
    public Long getJvmMemPoolCollectThreshold() throws SnmpStatusException {
        if (!pool.isCollectionUsageThresholdSupported())
            return JvmMemoryImpl.Long0;
        final long val = pool.getCollectionUsageThreshold();
        if (val &gt; -1) return  new Long(val);
        else return JvmMemoryImpl.Long0;
    }

    /**
     * Setter for the &quot;JvmMemPoolCollectThreshold&quot; variable.
     */
    public void setJvmMemPoolCollectThreshold(Long x)
        throws SnmpStatusException {
        final long val = x.longValue();
        if (val &lt; 0 )
            throw new SnmpStatusException(SnmpDefinitions.snmpRspWrongValue);
        // This should never throw an exception has the checks have
        // already been performed in checkJvmMemPoolCollectThreshold().
        //
        pool.setCollectionUsageThreshold(val);
    }

    /**
     * Checker for the &quot;JvmMemPoolCollectThreshold&quot; variable.
     */
    public void checkJvmMemPoolCollectThreshold(Long x)
        throws SnmpStatusException {
        // if threshold is -1, it means that low memory detection is not
        // supported.

        if (!pool.isCollectionUsageThresholdSupported())
            throw new
                SnmpStatusException(SnmpDefinitions.snmpRspInconsistentValue);
        final long val = x.longValue();
        if (val &lt; 0 )
            throw new SnmpStatusException(SnmpDefinitions.snmpRspWrongValue);
    }

    /**
     * Getter for the &quot;JvmMemPoolThreshdSupport&quot; variable.
     */
    public EnumJvmMemPoolCollectThreshdSupport
        getJvmMemPoolCollectThreshdSupport()
        throws SnmpStatusException {
        if (pool.isCollectionUsageThresholdSupported())
            return EnumJvmMemPoolCollectThreshdSupported;
        else
            return EnumJvmMemPoolCollectThreshdUnsupported;
    }

    /**
     * Getter for the &quot;JvmMemPoolCollectThreshdCount&quot; variable.
     */
    public Long getJvmMemPoolCollectThreshdCount()
        throws SnmpStatusException {
        if (!pool.isCollectionUsageThresholdSupported())
            return JvmMemoryImpl.Long0;
        final long val = pool.getCollectionUsageThresholdCount();
        if (val &gt; -1) return  new Long(val);
        else return JvmMemoryImpl.Long0;
    }

    public static EnumJvmMemPoolType jvmMemPoolType(MemoryType type)
        throws SnmpStatusException {
        if (type.equals(MemoryType.HEAP))
            return  EnumJvmMemPoolTypeHeap;
        else if (type.equals(MemoryType.NON_HEAP))
            return EnumJvmMemPoolTypeNonHeap;
        throw new SnmpStatusException(SnmpStatusException.snmpRspWrongValue);
    }

    /**
     * Getter for the &quot;JvmMemPoolType&quot; variable.
     */
    public EnumJvmMemPoolType getJvmMemPoolType() throws SnmpStatusException {
        return jvmMemPoolType(pool.getType());
    }

    /**
     * Getter for the &quot;JvmMemPoolName&quot; variable.
     */
    public String getJvmMemPoolName() throws SnmpStatusException {
        return JVM_MANAGEMENT_MIB_IMPL.validJavaObjectNameTC(pool.getName());
    }

    /**
     * Getter for the &quot;JvmMemPoolIndex&quot; variable.
     */
    public Integer getJvmMemPoolIndex() throws SnmpStatusException {
        return new Integer(jvmMemPoolIndex);
    }


    /**
     * Getter for the &quot;JvmMemPoolState&quot; variable.
     */
    public EnumJvmMemPoolState getJvmMemPoolState()
        throws SnmpStatusException {
        if (pool.isValid())
            return JvmMemPoolStateValid;
        else
            return JvmMemPoolStateInvalid;
    }

    /**
     * Getter for the &quot;JvmMemPoolPeakReset&quot; variable.
     */
    public synchronized Long getJvmMemPoolPeakReset()
        throws SnmpStatusException {
        return new Long(jvmMemPoolPeakReset);
    }

    /**
     * Setter for the &quot;JvmMemPoolPeakReset&quot; variable.
     */
    public synchronized void setJvmMemPoolPeakReset(Long x)
        throws SnmpStatusException {
        final long l = x.longValue();
        if (l &gt; jvmMemPoolPeakReset) {
            final long stamp = System.currentTimeMillis();
            pool.resetPeakUsage();
            jvmMemPoolPeakReset = stamp;
            log.debug(&quot;setJvmMemPoolPeakReset&quot;,
                      &quot;jvmMemPoolPeakReset=&quot;+stamp);
        }
    }

    /**
     * Checker for the &quot;JvmMemPoolPeakReset&quot; variable.
     */
    public void checkJvmMemPoolPeakReset(Long x) throws SnmpStatusException {
    }

    /* Last time peak usage was reset */
    private long jvmMemPoolPeakReset = 0;

    private final static EnumJvmMemPoolState JvmMemPoolStateValid =
        new EnumJvmMemPoolState(&quot;valid&quot;);
    private final static EnumJvmMemPoolState JvmMemPoolStateInvalid =
        new EnumJvmMemPoolState(&quot;invalid&quot;);

    private static final EnumJvmMemPoolType EnumJvmMemPoolTypeHeap =
        new EnumJvmMemPoolType(&quot;heap&quot;);
    private static final EnumJvmMemPoolType EnumJvmMemPoolTypeNonHeap =
        new EnumJvmMemPoolType(&quot;nonheap&quot;);

    private static final EnumJvmMemPoolThreshdSupport
        EnumJvmMemPoolThreshdSupported =
        new EnumJvmMemPoolThreshdSupport(&quot;supported&quot;);
    private static final EnumJvmMemPoolThreshdSupport
        EnumJvmMemPoolThreshdUnsupported =
        new EnumJvmMemPoolThreshdSupport(&quot;unsupported&quot;);

    private static final EnumJvmMemPoolCollectThreshdSupport
        EnumJvmMemPoolCollectThreshdSupported =
        new EnumJvmMemPoolCollectThreshdSupport(&quot;supported&quot;);
    private static final EnumJvmMemPoolCollectThreshdSupport
        EnumJvmMemPoolCollectThreshdUnsupported=
        new EnumJvmMemPoolCollectThreshdSupport(&quot;unsupported&quot;);


    static final MibLogger log = new MibLogger(JvmMemPoolEntryImpl.class);
}
</pre>
</body>
</html>
