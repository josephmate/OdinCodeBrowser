<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.management;

import com.sun.management.DiagnosticCommandMBean;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.security.Permission;
import java.util.*;
import javax.management.*;

/**
 * Implementation class for the diagnostic commands subsystem.
 *
 * @since 8
 */
class DiagnosticCommandImpl extends NotificationEmitterSupport
    implements DiagnosticCommandMBean {

    private final VMManagement jvm;
    private volatile Map&lt;String, Wrapper&gt; wrappers = null;
    private static final String strClassName = &quot;&quot;.getClass().getName();
    private static final String strArrayClassName = String[].class.getName();
    private final boolean isSupported;

    @Override
    public Object getAttribute(String attribute) throws AttributeNotFoundException,
        MBeanException, ReflectionException {
        throw new AttributeNotFoundException(attribute);
    }

    @Override
    public void setAttribute(Attribute attribute) throws AttributeNotFoundException,
        InvalidAttributeValueException, MBeanException, ReflectionException {
        throw new AttributeNotFoundException(attribute.getName());
    }

    @Override
    public AttributeList getAttributes(String[] attributes) {
        return new AttributeList();
    }

    @Override
    public AttributeList setAttributes(AttributeList attributes) {
        return new AttributeList();
    }

    private class Wrapper {

        String name;
        String cmd;
        DiagnosticCommandInfo info;
        Permission permission;

        Wrapper(String name, String cmd, DiagnosticCommandInfo info)
                throws InstantiationException {
            this.name = name;
            this.cmd = cmd;
            this.info = info;
            this.permission = null;
            Exception cause = null;
            if (info.getPermissionClass() != null) {
                try {
                    Class c = Class.forName(info.getPermissionClass());
                    if (info.getPermissionAction() == null) {
                        try {
                            Constructor constructor = c.getConstructor(String.class);
                            permission = (Permission) constructor.newInstance(info.getPermissionName());

                        } catch (InstantiationException | IllegalAccessException
                                | IllegalArgumentException | InvocationTargetException
                                | NoSuchMethodException | SecurityException ex) {
                            cause = ex;
                        }
                    }
                    if (permission == null) {
                        try {
                            Constructor constructor = c.getConstructor(String.class, String.class);
                            permission = (Permission) constructor.newInstance(
                                    info.getPermissionName(),
                                    info.getPermissionAction());
                        } catch (InstantiationException | IllegalAccessException
                                | IllegalArgumentException | InvocationTargetException
                                | NoSuchMethodException | SecurityException ex) {
                            cause = ex;
                        }
                    }
                } catch (ClassNotFoundException ex) { }
                if (permission == null) {
                    InstantiationException iex =
                            new InstantiationException(&quot;Unable to instantiate required permission&quot;);
                    iex.initCause(cause);
                }
            }
        }

        public String execute(String[] args) {
            if (permission != null) {
                SecurityManager sm = System.getSecurityManager();
                if (sm != null) {
                    sm.checkPermission(permission);
                }
            }
            if(args == null) {
                return executeDiagnosticCommand(cmd);
            } else {
                StringBuilder sb = new StringBuilder();
                sb.append(cmd);
                for(int i=0; i&lt;args.length; i++) {
                    if(args[i] == null) {
                        throw new IllegalArgumentException(&quot;Invalid null argument&quot;);
                    }
                    sb.append(&quot; &quot;);
                    sb.append(args[i]);
                }
                return executeDiagnosticCommand(sb.toString());
            }
        }
    }

    DiagnosticCommandImpl(VMManagement jvm) {
        this.jvm = jvm;
        isSupported = jvm.isRemoteDiagnosticCommandsSupported();
    }

    private static class OperationInfoComparator implements Comparator&lt;MBeanOperationInfo&gt; {
        @Override
        public int compare(MBeanOperationInfo o1, MBeanOperationInfo o2) {
            return o1.getName().compareTo(o2.getName());
        }
    }

    @Override
    public MBeanInfo getMBeanInfo() {
        SortedSet&lt;MBeanOperationInfo&gt; operations = new TreeSet&lt;&gt;(new OperationInfoComparator());
        Map&lt;String, Wrapper&gt; wrappersmap;
        if (!isSupported) {
            wrappersmap = (Map&lt;String, Wrapper&gt;) Collections.EMPTY_MAP;
        } else {
            try {
                String[] command = getDiagnosticCommands();
                DiagnosticCommandInfo[] info = getDiagnosticCommandInfo(command);
                MBeanParameterInfo stringArgInfo[] = new MBeanParameterInfo[]{
                    new MBeanParameterInfo(&quot;arguments&quot;, strArrayClassName,
                    &quot;Array of Diagnostic Commands Arguments and Options&quot;)
                };
                wrappersmap = new HashMap&lt;&gt;();
                for (int i = 0; i &lt; command.length; i++) {
                    String name = transform(command[i]);
                    try {
                        Wrapper w = new Wrapper(name, command[i], info[i]);
                        wrappersmap.put(name, w);
                        operations.add(new MBeanOperationInfo(
                                w.name,
                                w.info.getDescription(),
                                (w.info.getArgumentsInfo() == null
                                    || w.info.getArgumentsInfo().isEmpty())
                                    ? null : stringArgInfo,
                                strClassName,
                                MBeanOperationInfo.ACTION_INFO,
                                commandDescriptor(w)));
                    } catch (InstantiationException ex) {
                        // If for some reasons the creation of a diagnostic command
                        // wrappers fails, the diagnostic command is just ignored
                        // and won't appear in the DynamicMBean
                    }
                }
            } catch (IllegalArgumentException | UnsupportedOperationException e) {
                wrappersmap = (Map&lt;String, Wrapper&gt;) Collections.EMPTY_MAP;
            }
        }
        wrappers =  Collections.unmodifiableMap(wrappersmap);
        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;immutableInfo&quot;, &quot;false&quot;);
        map.put(&quot;interfaceClassName&quot;,&quot;com.sun.management.DiagnosticCommandMBean&quot;);
        map.put(&quot;mxbean&quot;, &quot;false&quot;);
        Descriptor desc = new ImmutableDescriptor(map);
        return new MBeanInfo(
                this.getClass().getName(),
                &quot;Diagnostic Commands&quot;,
                null, // attributes
                null, // constructors
                operations.toArray(new MBeanOperationInfo[operations.size()]), // operations
                getNotificationInfo(), // notifications
                desc);
    }

    @Override
    public Object invoke(String actionName, Object[] params, String[] signature)
            throws MBeanException, ReflectionException {
        if (!isSupported) {
            throw new UnsupportedOperationException();
        }
        if (wrappers == null) {
            getMBeanInfo();
        }
        Wrapper w = wrappers.get(actionName);
        if (w != null) {
            if (w.info.getArgumentsInfo().isEmpty()
                    &amp;&amp; (params == null || params.length == 0)
                    &amp;&amp; (signature == null || signature.length == 0)) {
                return w.execute(null);
            } else if((params != null &amp;&amp; params.length == 1)
                    &amp;&amp; (signature != null &amp;&amp; signature.length == 1
                    &amp;&amp; signature[0] != null
                    &amp;&amp; signature[0].compareTo(strArrayClassName) == 0)) {
                return w.execute((String[]) params[0]);
            }
        }
        throw new ReflectionException(new NoSuchMethodException(actionName));
    }

    private static String transform(String name) {
        StringBuilder sb = new StringBuilder();
        boolean toLower = true;
        boolean toUpper = false;
        for (int i = 0; i &lt; name.length(); i++) {
            char c = name.charAt(i);
            if (c == '.' || c == '_') {
                toLower = false;
                toUpper = true;
            } else {
                if (toUpper) {
                    toUpper = false;
                    sb.append(Character.toUpperCase(c));
                } else if(toLower) {
                    sb.append(Character.toLowerCase(c));
                } else {
                    sb.append(c);
                }
            }
        }
        return sb.toString();
    }

    private Descriptor commandDescriptor(Wrapper w) throws IllegalArgumentException {
        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;dcmd.name&quot;, w.info.getName());
        map.put(&quot;dcmd.description&quot;, w.info.getDescription());
        map.put(&quot;dcmd.vmImpact&quot;, w.info.getImpact());
        map.put(&quot;dcmd.permissionClass&quot;, w.info.getPermissionClass());
        map.put(&quot;dcmd.permissionName&quot;, w.info.getPermissionName());
        map.put(&quot;dcmd.permissionAction&quot;, w.info.getPermissionAction());
        map.put(&quot;dcmd.enabled&quot;, w.info.isEnabled());
        StringBuilder sb = new StringBuilder();
        sb.append(&quot;help &quot;);
        sb.append(w.info.getName());
        map.put(&quot;dcmd.help&quot;, executeDiagnosticCommand(sb.toString()));
        if (w.info.getArgumentsInfo() != null &amp;&amp; !w.info.getArgumentsInfo().isEmpty()) {
            HashMap&lt;String, Object&gt; allargmap = new HashMap&lt;&gt;();
            for (DiagnosticCommandArgumentInfo arginfo : w.info.getArgumentsInfo()) {
                HashMap&lt;String, Object&gt; argmap = new HashMap&lt;&gt;();
                argmap.put(&quot;dcmd.arg.name&quot;, arginfo.getName());
                argmap.put(&quot;dcmd.arg.type&quot;, arginfo.getType());
                argmap.put(&quot;dcmd.arg.description&quot;, arginfo.getDescription());
                argmap.put(&quot;dcmd.arg.isMandatory&quot;, arginfo.isMandatory());
                argmap.put(&quot;dcmd.arg.isMultiple&quot;, arginfo.isMultiple());
                boolean isOption = arginfo.isOption();
                argmap.put(&quot;dcmd.arg.isOption&quot;, isOption);
                if(!isOption) {
                    argmap.put(&quot;dcmd.arg.position&quot;, arginfo.getPosition());
                } else {
                    argmap.put(&quot;dcmd.arg.position&quot;, -1);
                }
                allargmap.put(arginfo.getName(), new ImmutableDescriptor(argmap));
            }
            map.put(&quot;dcmd.arguments&quot;, new ImmutableDescriptor(allargmap));
        }
        return new ImmutableDescriptor(map);
    }

    private final static String notifName =
        &quot;javax.management.Notification&quot;;

    private final static String[] diagFramNotifTypes = {
        &quot;jmx.mbean.info.changed&quot;
    };

    private MBeanNotificationInfo[] notifInfo = null;

    @Override
    public MBeanNotificationInfo[] getNotificationInfo() {
        synchronized (this) {
            if (notifInfo == null) {
                 notifInfo = new MBeanNotificationInfo[1];
                 notifInfo[0] =
                         new MBeanNotificationInfo(diagFramNotifTypes,
                                                   notifName,
                                                   &quot;Diagnostic Framework Notification&quot;);
            }
        }
        return notifInfo;
    }

    private static long seqNumber = 0;
    private static long getNextSeqNumber() {
        return ++seqNumber;
    }

    private void createDiagnosticFrameworkNotification() {

        if (!hasListeners()) {
            return;
        }
        ObjectName on = null;
        try {
            on = ObjectName.getInstance(ManagementFactoryHelper.HOTSPOT_DIAGNOSTIC_COMMAND_MBEAN_NAME);
        } catch (MalformedObjectNameException e) { }
        Notification notif = new Notification(&quot;jmx.mbean.info.changed&quot;,
                                              on,
                                              getNextSeqNumber());
        notif.setUserData(getMBeanInfo());
        sendNotification(notif);
    }

    @Override
    public synchronized void addNotificationListener(NotificationListener listener,
            NotificationFilter filter,
            Object handback) {
        boolean before = hasListeners();
        super.addNotificationListener(listener, filter, handback);
        boolean after = hasListeners();
        if (!before &amp;&amp; after) {
            setNotificationEnabled(true);
        }
    }

    @Override
    public synchronized void removeNotificationListener(NotificationListener listener)
            throws ListenerNotFoundException {
        boolean before = hasListeners();
        super.removeNotificationListener(listener);
        boolean after = hasListeners();
        if (before &amp;&amp; !after) {
            setNotificationEnabled(false);
        }
    }

    @Override
    public synchronized void removeNotificationListener(NotificationListener listener,
            NotificationFilter filter,
            Object handback)
            throws ListenerNotFoundException {
        boolean before = hasListeners();
        super.removeNotificationListener(listener, filter, handback);
        boolean after = hasListeners();
        if (before &amp;&amp; !after) {
            setNotificationEnabled(false);
        }
    }

    private native void setNotificationEnabled(boolean enabled);
    private native String[] getDiagnosticCommands();
    private native DiagnosticCommandInfo[] getDiagnosticCommandInfo(String[] commands);
    private native String executeDiagnosticCommand(String command);

}
</pre>
</body>
</html>
