<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/OdinCodeBrowser/css/styles.css"/>
    </head>
<body>
<table>
<tr>
<td><a class="linenum-cell" data-linenum="1" href="#"></a></td>
<td><pre>/*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2" href="#"></a></td>
<td><pre> * Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3" href="#"></a></td>
<td><pre> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5" href="#"></a></td>
<td><pre> * This code is free software; you can redistribute it and/or modify it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="6" href="#"></a></td>
<td><pre> * under the terms of the GNU General Public License version 2 only, as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="7" href="#"></a></td>
<td><pre> * published by the Free Software Foundation.  Oracle designates this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="8" href="#"></a></td>
<td><pre> * particular file as subject to the &quot;Classpath&quot; exception as provided</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="9" href="#"></a></td>
<td><pre> * by Oracle in the LICENSE file that accompanied this code.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="10" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="11" href="#"></a></td>
<td><pre> * This code is distributed in the hope that it will be useful, but WITHOUT</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="12" href="#"></a></td>
<td><pre> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="13" href="#"></a></td>
<td><pre> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="14" href="#"></a></td>
<td><pre> * version 2 for more details (a copy is included in the LICENSE file that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="15" href="#"></a></td>
<td><pre> * accompanied this code).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="16" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="17" href="#"></a></td>
<td><pre> * You should have received a copy of the GNU General Public License version</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="18" href="#"></a></td>
<td><pre> * 2 along with this work; if not, write to the Free Software Foundation,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="19" href="#"></a></td>
<td><pre> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="20" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="21" href="#"></a></td>
<td><pre> * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="22" href="#"></a></td>
<td><pre> * or visit www.oracle.com if you need additional information or have any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="23" href="#"></a></td>
<td><pre> * questions.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="24" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="25" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="26" href="#"></a></td>
<td><pre>package sun.java2d.pisces;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="27" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="28" href="#"></a></td>
<td><pre>import java.util.Arrays;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="29" href="#"></a></td>
<td><pre>import java.util.Iterator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="30" href="#"></a></td>
<td><pre>import static java.lang.Math.ulp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="31" href="#"></a></td>
<td><pre>import static java.lang.Math.sqrt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="32" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="33" href="#"></a></td>
<td><pre>import sun.awt.geom.PathConsumer2D;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="34" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="35" href="#"></a></td>
<td><pre>// TODO: some of the arithmetic here is too verbose and prone to hard to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="36" href="#"></a></td>
<td><pre>// debug typos. We should consider making a small Point/Vector class that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="37" href="#"></a></td>
<td><pre>// has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="38" href="#"></a></td>
<td><pre>final class Stroker implements PathConsumer2D {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="39" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="40" href="#"></a></td>
<td><pre>    private static final int MOVE_TO = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="41" href="#"></a></td>
<td><pre>    private static final int DRAWING_OP_TO = 1; // ie. curve, line, or quad</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="42" href="#"></a></td>
<td><pre>    private static final int CLOSE = 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="43" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="44" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="45" href="#"></a></td>
<td><pre>     * Constant value for join style.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="46" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="47" href="#"></a></td>
<td><pre>    public static final int JOIN_MITER = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="48" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="49" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="50" href="#"></a></td>
<td><pre>     * Constant value for join style.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="51" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="52" href="#"></a></td>
<td><pre>    public static final int JOIN_ROUND = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="53" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="54" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="55" href="#"></a></td>
<td><pre>     * Constant value for join style.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="56" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="57" href="#"></a></td>
<td><pre>    public static final int JOIN_BEVEL = 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="58" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="59" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="60" href="#"></a></td>
<td><pre>     * Constant value for end cap style.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="61" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="62" href="#"></a></td>
<td><pre>    public static final int CAP_BUTT = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="63" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="64" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="65" href="#"></a></td>
<td><pre>     * Constant value for end cap style.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="66" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="67" href="#"></a></td>
<td><pre>    public static final int CAP_ROUND = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="68" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="69" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="70" href="#"></a></td>
<td><pre>     * Constant value for end cap style.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="71" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="72" href="#"></a></td>
<td><pre>    public static final int CAP_SQUARE = 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="73" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="74" href="#"></a></td>
<td><pre>    private final PathConsumer2D out;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="75" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="76" href="#"></a></td>
<td><pre>    private final int capStyle;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="77" href="#"></a></td>
<td><pre>    private final int joinStyle;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="78" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="79" href="#"></a></td>
<td><pre>    private final float lineWidth2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="80" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="81" href="#"></a></td>
<td><pre>    private final float[][] offset = new float[3][2];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="82" href="#"></a></td>
<td><pre>    private final float[] miter = new float[2];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="83" href="#"></a></td>
<td><pre>    private final float miterLimitSq;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="84" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="85" href="#"></a></td>
<td><pre>    private int prev;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="86" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="87" href="#"></a></td>
<td><pre>    // The starting point of the path, and the slope there.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="88" href="#"></a></td>
<td><pre>    private float sx0, sy0, sdx, sdy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="89" href="#"></a></td>
<td><pre>    // the current point and the slope there.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="90" href="#"></a></td>
<td><pre>    private float cx0, cy0, cdx, cdy; // c stands for current</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="91" href="#"></a></td>
<td><pre>    // vectors that when added to (sx0,sy0) and (cx0,cy0) respectively yield the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="92" href="#"></a></td>
<td><pre>    // first and last points on the left parallel path. Since this path is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="93" href="#"></a></td>
<td><pre>    // parallel, it's slope at any point is parallel to the slope of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="94" href="#"></a></td>
<td><pre>    // original path (thought they may have different directions), so these</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="95" href="#"></a></td>
<td><pre>    // could be computed from sdx,sdy and cdx,cdy (and vice versa), but that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="96" href="#"></a></td>
<td><pre>    // would be error prone and hard to read, so we keep these anyway.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="97" href="#"></a></td>
<td><pre>    private float smx, smy, cmx, cmy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="98" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="99" href="#"></a></td>
<td><pre>    private final PolyStack reverse = new PolyStack();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="100" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="101" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="102" href="#"></a></td>
<td><pre>     * Constructs a &lt;code&gt;Stroker&lt;/code&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="103" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="104" href="#"></a></td>
<td><pre>     * @param pc2d an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="105" href="#"></a></td>
<td><pre>     * @param lineWidth the desired line width in pixels</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="106" href="#"></a></td>
<td><pre>     * @param capStyle the desired end cap style, one of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="107" href="#"></a></td>
<td><pre>     * &lt;code&gt;CAP_BUTT&lt;/code&gt;, &lt;code&gt;CAP_ROUND&lt;/code&gt; or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="108" href="#"></a></td>
<td><pre>     * &lt;code&gt;CAP_SQUARE&lt;/code&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="109" href="#"></a></td>
<td><pre>     * @param joinStyle the desired line join style, one of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="110" href="#"></a></td>
<td><pre>     * &lt;code&gt;JOIN_MITER&lt;/code&gt;, &lt;code&gt;JOIN_ROUND&lt;/code&gt; or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="111" href="#"></a></td>
<td><pre>     * &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="112" href="#"></a></td>
<td><pre>     * @param miterLimit the desired miter limit</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="113" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="114" href="#"></a></td>
<td><pre>    public Stroker(PathConsumer2D pc2d,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="115" href="#"></a></td>
<td><pre>                   float lineWidth,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="116" href="#"></a></td>
<td><pre>                   int capStyle,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="117" href="#"></a></td>
<td><pre>                   int joinStyle,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="118" href="#"></a></td>
<td><pre>                   float miterLimit)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="119" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="120" href="#"></a></td>
<td><pre>        this.out = pc2d;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="121" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="122" href="#"></a></td>
<td><pre>        this.lineWidth2 = lineWidth / 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="123" href="#"></a></td>
<td><pre>        this.capStyle = capStyle;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="124" href="#"></a></td>
<td><pre>        this.joinStyle = joinStyle;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="125" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="126" href="#"></a></td>
<td><pre>        float limit = miterLimit * lineWidth2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="127" href="#"></a></td>
<td><pre>        this.miterLimitSq = limit*limit;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="128" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="129" href="#"></a></td>
<td><pre>        this.prev = CLOSE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="130" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="131" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="132" href="#"></a></td>
<td><pre>    private static void computeOffset(final float lx, final float ly,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="133" href="#"></a></td>
<td><pre>                                      final float w, final float[] m)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="134" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="135" href="#"></a></td>
<td><pre>        final float len = (float) sqrt(lx*lx + ly*ly);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="136" href="#"></a></td>
<td><pre>        if (len == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="137" href="#"></a></td>
<td><pre>            m[0] = m[1] = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="138" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="139" href="#"></a></td>
<td><pre>            m[0] = (ly * w)/len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="140" href="#"></a></td>
<td><pre>            m[1] = -(lx * w)/len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="141" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="142" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="143" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="144" href="#"></a></td>
<td><pre>    // Returns true if the vectors (dx1, dy1) and (dx2, dy2) are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="145" href="#"></a></td>
<td><pre>    // clockwise (if dx1,dy1 needs to be rotated clockwise to close</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="146" href="#"></a></td>
<td><pre>    // the smallest angle between it and dx2,dy2).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="147" href="#"></a></td>
<td><pre>    // This is equivalent to detecting whether a point q is on the right side</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="148" href="#"></a></td>
<td><pre>    // of a line passing through points p1, p2 where p2 = p1+(dx1,dy1) and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="149" href="#"></a></td>
<td><pre>    // q = p2+(dx2,dy2), which is the same as saying p1, p2, q are in a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="150" href="#"></a></td>
<td><pre>    // clockwise order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="151" href="#"></a></td>
<td><pre>    // NOTE: &quot;clockwise&quot; here assumes coordinates with 0,0 at the bottom left.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="152" href="#"></a></td>
<td><pre>    private static boolean isCW(final float dx1, final float dy1,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="153" href="#"></a></td>
<td><pre>                                final float dx2, final float dy2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="154" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="155" href="#"></a></td>
<td><pre>        return dx1 * dy2 &lt;= dy1 * dx2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="156" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="157" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="158" href="#"></a></td>
<td><pre>    // pisces used to use fixed point arithmetic with 16 decimal digits. I</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="159" href="#"></a></td>
<td><pre>    // didn't want to change the values of the constant below when I converted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="160" href="#"></a></td>
<td><pre>    // it to floating point, so that's why the divisions by 2^16 are there.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="161" href="#"></a></td>
<td><pre>    private static final float ROUND_JOIN_THRESHOLD = 1000/65536f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="162" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="163" href="#"></a></td>
<td><pre>    private void drawRoundJoin(float x, float y,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="164" href="#"></a></td>
<td><pre>                               float omx, float omy, float mx, float my,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="165" href="#"></a></td>
<td><pre>                               boolean rev,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="166" href="#"></a></td>
<td><pre>                               float threshold)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="167" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="168" href="#"></a></td>
<td><pre>        if ((omx == 0 &amp;&amp; omy == 0) || (mx == 0 &amp;&amp; my == 0)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="169" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="170" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="171" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="172" href="#"></a></td>
<td><pre>        float domx = omx - mx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="173" href="#"></a></td>
<td><pre>        float domy = omy - my;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="174" href="#"></a></td>
<td><pre>        float len = domx*domx + domy*domy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="175" href="#"></a></td>
<td><pre>        if (len &lt; threshold) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="176" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="177" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="178" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="179" href="#"></a></td>
<td><pre>        if (rev) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="180" href="#"></a></td>
<td><pre>            omx = -omx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="181" href="#"></a></td>
<td><pre>            omy = -omy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="182" href="#"></a></td>
<td><pre>            mx = -mx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="183" href="#"></a></td>
<td><pre>            my = -my;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="184" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="185" href="#"></a></td>
<td><pre>        drawRoundJoin(x, y, omx, omy, mx, my, rev);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="186" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="187" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="188" href="#"></a></td>
<td><pre>    private void drawRoundJoin(float cx, float cy,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="189" href="#"></a></td>
<td><pre>                               float omx, float omy,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="190" href="#"></a></td>
<td><pre>                               float mx, float my,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="191" href="#"></a></td>
<td><pre>                               boolean rev)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="192" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="193" href="#"></a></td>
<td><pre>        // The sign of the dot product of mx,my and omx,omy is equal to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="194" href="#"></a></td>
<td><pre>        // the sign of the cosine of ext</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="195" href="#"></a></td>
<td><pre>        // (ext is the angle between omx,omy and mx,my).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="196" href="#"></a></td>
<td><pre>        double cosext = omx * mx + omy * my;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="197" href="#"></a></td>
<td><pre>        // If it is &gt;=0, we know that abs(ext) is &lt;= 90 degrees, so we only</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="198" href="#"></a></td>
<td><pre>        // need 1 curve to approximate the circle section that joins omx,omy</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="199" href="#"></a></td>
<td><pre>        // and mx,my.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="200" href="#"></a></td>
<td><pre>        final int numCurves = cosext &gt;= 0 ? 1 : 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="201" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="202" href="#"></a></td>
<td><pre>        switch (numCurves) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="203" href="#"></a></td>
<td><pre>        case 1:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="204" href="#"></a></td>
<td><pre>            drawBezApproxForArc(cx, cy, omx, omy, mx, my, rev);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="205" href="#"></a></td>
<td><pre>            break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="206" href="#"></a></td>
<td><pre>        case 2:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="207" href="#"></a></td>
<td><pre>            // we need to split the arc into 2 arcs spanning the same angle.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="208" href="#"></a></td>
<td><pre>            // The point we want will be one of the 2 intersections of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="209" href="#"></a></td>
<td><pre>            // perpendicular bisector of the chord (omx,omy)-&gt;(mx,my) and the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="210" href="#"></a></td>
<td><pre>            // circle. We could find this by scaling the vector</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="211" href="#"></a></td>
<td><pre>            // (omx+mx, omy+my)/2 so that it has length=lineWidth2 (and thus lies</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="212" href="#"></a></td>
<td><pre>            // on the circle), but that can have numerical problems when the angle</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="213" href="#"></a></td>
<td><pre>            // between omx,omy and mx,my is close to 180 degrees. So we compute a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="214" href="#"></a></td>
<td><pre>            // normal of (omx,omy)-(mx,my). This will be the direction of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="215" href="#"></a></td>
<td><pre>            // perpendicular bisector. To get one of the intersections, we just scale</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="216" href="#"></a></td>
<td><pre>            // this vector that its length is lineWidth2 (this works because the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="217" href="#"></a></td>
<td><pre>            // perpendicular bisector goes through the origin). This scaling doesn't</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="218" href="#"></a></td>
<td><pre>            // have numerical problems because we know that lineWidth2 divided by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="219" href="#"></a></td>
<td><pre>            // this normal's length is at least 0.5 and at most sqrt(2)/2 (because</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="220" href="#"></a></td>
<td><pre>            // we know the angle of the arc is &gt; 90 degrees).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="221" href="#"></a></td>
<td><pre>            float nx = my - omy, ny = omx - mx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="222" href="#"></a></td>
<td><pre>            float nlen = (float) sqrt(nx*nx + ny*ny);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="223" href="#"></a></td>
<td><pre>            float scale = lineWidth2/nlen;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="224" href="#"></a></td>
<td><pre>            float mmx = nx * scale, mmy = ny * scale;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="225" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="226" href="#"></a></td>
<td><pre>            // if (isCW(omx, omy, mx, my) != isCW(mmx, mmy, mx, my)) then we've</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="227" href="#"></a></td>
<td><pre>            // computed the wrong intersection so we get the other one.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="228" href="#"></a></td>
<td><pre>            // The test above is equivalent to if (rev).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="229" href="#"></a></td>
<td><pre>            if (rev) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="230" href="#"></a></td>
<td><pre>                mmx = -mmx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="231" href="#"></a></td>
<td><pre>                mmy = -mmy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="232" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="233" href="#"></a></td>
<td><pre>            drawBezApproxForArc(cx, cy, omx, omy, mmx, mmy, rev);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="234" href="#"></a></td>
<td><pre>            drawBezApproxForArc(cx, cy, mmx, mmy, mx, my, rev);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="235" href="#"></a></td>
<td><pre>            break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="236" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="237" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="238" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="239" href="#"></a></td>
<td><pre>    // the input arc defined by omx,omy and mx,my must span &lt;= 90 degrees.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="240" href="#"></a></td>
<td><pre>    private void drawBezApproxForArc(final float cx, final float cy,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="241" href="#"></a></td>
<td><pre>                                     final float omx, final float omy,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="242" href="#"></a></td>
<td><pre>                                     final float mx, final float my,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="243" href="#"></a></td>
<td><pre>                                     boolean rev)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="244" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="245" href="#"></a></td>
<td><pre>        float cosext2 = (omx * mx + omy * my) / (2 * lineWidth2 * lineWidth2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="246" href="#"></a></td>
<td><pre>        // cv is the length of P1-P0 and P2-P3 divided by the radius of the arc</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="247" href="#"></a></td>
<td><pre>        // (so, cv assumes the arc has radius 1). P0, P1, P2, P3 are the points that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="248" href="#"></a></td>
<td><pre>        // define the bezier curve we're computing.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="249" href="#"></a></td>
<td><pre>        // It is computed using the constraints that P1-P0 and P3-P2 are parallel</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="250" href="#"></a></td>
<td><pre>        // to the arc tangents at the endpoints, and that |P1-P0|=|P3-P2|.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="251" href="#"></a></td>
<td><pre>        float cv = (float) ((4.0 / 3.0) * sqrt(0.5-cosext2) /</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="252" href="#"></a></td>
<td><pre>                            (1.0 + sqrt(cosext2+0.5)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="253" href="#"></a></td>
<td><pre>        // if clockwise, we need to negate cv.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="254" href="#"></a></td>
<td><pre>        if (rev) { // rev is equivalent to isCW(omx, omy, mx, my)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="255" href="#"></a></td>
<td><pre>            cv = -cv;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="256" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="257" href="#"></a></td>
<td><pre>        final float x1 = cx + omx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="258" href="#"></a></td>
<td><pre>        final float y1 = cy + omy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="259" href="#"></a></td>
<td><pre>        final float x2 = x1 - cv * omy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="260" href="#"></a></td>
<td><pre>        final float y2 = y1 + cv * omx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="261" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="262" href="#"></a></td>
<td><pre>        final float x4 = cx + mx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="263" href="#"></a></td>
<td><pre>        final float y4 = cy + my;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="264" href="#"></a></td>
<td><pre>        final float x3 = x4 + cv * my;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="265" href="#"></a></td>
<td><pre>        final float y3 = y4 - cv * mx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="266" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="267" href="#"></a></td>
<td><pre>        emitCurveTo(x1, y1, x2, y2, x3, y3, x4, y4, rev);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="268" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="269" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="270" href="#"></a></td>
<td><pre>    private void drawRoundCap(float cx, float cy, float mx, float my) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="271" href="#"></a></td>
<td><pre>        final float C = 0.5522847498307933f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="272" href="#"></a></td>
<td><pre>        // the first and second arguments of the following two calls</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="273" href="#"></a></td>
<td><pre>        // are really will be ignored by emitCurveTo (because of the false),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="274" href="#"></a></td>
<td><pre>        // but we put them in anyway, as opposed to just giving it 4 zeroes,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="275" href="#"></a></td>
<td><pre>        // because it's just 4 additions and it's not good to rely on this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="276" href="#"></a></td>
<td><pre>        // sort of assumption (right now it's true, but that may change).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="277" href="#"></a></td>
<td><pre>        emitCurveTo(cx+mx,      cy+my,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="278" href="#"></a></td>
<td><pre>                    cx+mx-C*my, cy+my+C*mx,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="279" href="#"></a></td>
<td><pre>                    cx-my+C*mx, cy+mx+C*my,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="280" href="#"></a></td>
<td><pre>                    cx-my,      cy+mx,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="281" href="#"></a></td>
<td><pre>                    false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="282" href="#"></a></td>
<td><pre>        emitCurveTo(cx-my,      cy+mx,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="283" href="#"></a></td>
<td><pre>                    cx-my-C*mx, cy+mx-C*my,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="284" href="#"></a></td>
<td><pre>                    cx-mx-C*my, cy-my+C*mx,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="285" href="#"></a></td>
<td><pre>                    cx-mx,      cy-my,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="286" href="#"></a></td>
<td><pre>                    false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="287" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="288" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="289" href="#"></a></td>
<td><pre>    // Put the intersection point of the lines (x0, y0) -&gt; (x1, y1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="290" href="#"></a></td>
<td><pre>    // and (x0p, y0p) -&gt; (x1p, y1p) in m[off] and m[off+1].</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="291" href="#"></a></td>
<td><pre>    // If the lines are parallel, it will put a non finite number in m.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="292" href="#"></a></td>
<td><pre>    private void computeIntersection(final float x0, final float y0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="293" href="#"></a></td>
<td><pre>                                     final float x1, final float y1,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="294" href="#"></a></td>
<td><pre>                                     final float x0p, final float y0p,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="295" href="#"></a></td>
<td><pre>                                     final float x1p, final float y1p,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="296" href="#"></a></td>
<td><pre>                                     final float[] m, int off)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="297" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="298" href="#"></a></td>
<td><pre>        float x10 = x1 - x0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="299" href="#"></a></td>
<td><pre>        float y10 = y1 - y0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="300" href="#"></a></td>
<td><pre>        float x10p = x1p - x0p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="301" href="#"></a></td>
<td><pre>        float y10p = y1p - y0p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="302" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="303" href="#"></a></td>
<td><pre>        float den = x10*y10p - x10p*y10;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="304" href="#"></a></td>
<td><pre>        float t = x10p*(y0-y0p) - y10p*(x0-x0p);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="305" href="#"></a></td>
<td><pre>        t /= den;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="306" href="#"></a></td>
<td><pre>        m[off++] = x0 + t*x10;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="307" href="#"></a></td>
<td><pre>        m[off] = y0 + t*y10;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="308" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="309" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="310" href="#"></a></td>
<td><pre>    private void drawMiter(final float pdx, final float pdy,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="311" href="#"></a></td>
<td><pre>                           final float x0, final float y0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="312" href="#"></a></td>
<td><pre>                           final float dx, final float dy,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="313" href="#"></a></td>
<td><pre>                           float omx, float omy, float mx, float my,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="314" href="#"></a></td>
<td><pre>                           boolean rev)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="315" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="316" href="#"></a></td>
<td><pre>        if ((mx == omx &amp;&amp; my == omy) ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="317" href="#"></a></td>
<td><pre>            (pdx == 0 &amp;&amp; pdy == 0) ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="318" href="#"></a></td>
<td><pre>            (dx == 0 &amp;&amp; dy == 0))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="319" href="#"></a></td>
<td><pre>        {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="320" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="321" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="322" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="323" href="#"></a></td>
<td><pre>        if (rev) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="324" href="#"></a></td>
<td><pre>            omx = -omx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="325" href="#"></a></td>
<td><pre>            omy = -omy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="326" href="#"></a></td>
<td><pre>            mx = -mx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="327" href="#"></a></td>
<td><pre>            my = -my;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="328" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="329" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="330" href="#"></a></td>
<td><pre>        computeIntersection((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="331" href="#"></a></td>
<td><pre>                            (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="332" href="#"></a></td>
<td><pre>                            miter, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="333" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="334" href="#"></a></td>
<td><pre>        float lenSq = (miter[0]-x0)*(miter[0]-x0) + (miter[1]-y0)*(miter[1]-y0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="335" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="336" href="#"></a></td>
<td><pre>        // If the lines are parallel, lenSq will be either NaN or +inf</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="337" href="#"></a></td>
<td><pre>        // (actually, I'm not sure if the latter is possible. The important</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="338" href="#"></a></td>
<td><pre>        // thing is that -inf is not possible, because lenSq is a square).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="339" href="#"></a></td>
<td><pre>        // For both of those values, the comparison below will fail and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="340" href="#"></a></td>
<td><pre>        // no miter will be drawn, which is correct.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="341" href="#"></a></td>
<td><pre>        if (lenSq &lt; miterLimitSq) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="342" href="#"></a></td>
<td><pre>            emitLineTo(miter[0], miter[1], rev);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="343" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="344" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="345" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="346" href="#"></a></td>
<td><pre>    public void moveTo(float x0, float y0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="347" href="#"></a></td>
<td><pre>        if (prev == DRAWING_OP_TO) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="348" href="#"></a></td>
<td><pre>            finish();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="349" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="350" href="#"></a></td>
<td><pre>        this.sx0 = this.cx0 = x0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="351" href="#"></a></td>
<td><pre>        this.sy0 = this.cy0 = y0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="352" href="#"></a></td>
<td><pre>        this.cdx = this.sdx = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="353" href="#"></a></td>
<td><pre>        this.cdy = this.sdy = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="354" href="#"></a></td>
<td><pre>        this.prev = MOVE_TO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="355" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="356" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="357" href="#"></a></td>
<td><pre>    public void lineTo(float x1, float y1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="358" href="#"></a></td>
<td><pre>        float dx = x1 - cx0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="359" href="#"></a></td>
<td><pre>        float dy = y1 - cy0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="360" href="#"></a></td>
<td><pre>        if (dx == 0f &amp;&amp; dy == 0f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="361" href="#"></a></td>
<td><pre>            dx = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="362" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="363" href="#"></a></td>
<td><pre>        computeOffset(dx, dy, lineWidth2, offset[0]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="364" href="#"></a></td>
<td><pre>        float mx = offset[0][0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="365" href="#"></a></td>
<td><pre>        float my = offset[0][1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="366" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="367" href="#"></a></td>
<td><pre>        drawJoin(cdx, cdy, cx0, cy0, dx, dy, cmx, cmy, mx, my);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="368" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="369" href="#"></a></td>
<td><pre>        emitLineTo(cx0 + mx, cy0 + my);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="370" href="#"></a></td>
<td><pre>        emitLineTo(x1 + mx, y1 + my);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="371" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="372" href="#"></a></td>
<td><pre>        emitLineTo(cx0 - mx, cy0 - my, true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="373" href="#"></a></td>
<td><pre>        emitLineTo(x1 - mx, y1 - my, true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="374" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="375" href="#"></a></td>
<td><pre>        this.cmx = mx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="376" href="#"></a></td>
<td><pre>        this.cmy = my;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="377" href="#"></a></td>
<td><pre>        this.cdx = dx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="378" href="#"></a></td>
<td><pre>        this.cdy = dy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="379" href="#"></a></td>
<td><pre>        this.cx0 = x1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="380" href="#"></a></td>
<td><pre>        this.cy0 = y1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="381" href="#"></a></td>
<td><pre>        this.prev = DRAWING_OP_TO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="382" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="383" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="384" href="#"></a></td>
<td><pre>    public void closePath() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="385" href="#"></a></td>
<td><pre>        if (prev != DRAWING_OP_TO) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="386" href="#"></a></td>
<td><pre>            if (prev == CLOSE) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="387" href="#"></a></td>
<td><pre>                return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="388" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="389" href="#"></a></td>
<td><pre>            emitMoveTo(cx0, cy0 - lineWidth2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="390" href="#"></a></td>
<td><pre>            this.cmx = this.smx = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="391" href="#"></a></td>
<td><pre>            this.cmy = this.smy = -lineWidth2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="392" href="#"></a></td>
<td><pre>            this.cdx = this.sdx = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="393" href="#"></a></td>
<td><pre>            this.cdy = this.sdy = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="394" href="#"></a></td>
<td><pre>            finish();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="395" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="396" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="397" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="398" href="#"></a></td>
<td><pre>        if (cx0 != sx0 || cy0 != sy0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="399" href="#"></a></td>
<td><pre>            lineTo(sx0, sy0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="400" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="401" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="402" href="#"></a></td>
<td><pre>        drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="403" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="404" href="#"></a></td>
<td><pre>        emitLineTo(sx0 + smx, sy0 + smy);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="405" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="406" href="#"></a></td>
<td><pre>        emitMoveTo(sx0 - smx, sy0 - smy);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="407" href="#"></a></td>
<td><pre>        emitReverse();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="408" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="409" href="#"></a></td>
<td><pre>        this.prev = CLOSE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="410" href="#"></a></td>
<td><pre>        emitClose();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="411" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="412" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="413" href="#"></a></td>
<td><pre>    private void emitReverse() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="414" href="#"></a></td>
<td><pre>        while(!reverse.isEmpty()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="415" href="#"></a></td>
<td><pre>            reverse.pop(out);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="416" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="417" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="418" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="419" href="#"></a></td>
<td><pre>    public void pathDone() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="420" href="#"></a></td>
<td><pre>        if (prev == DRAWING_OP_TO) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="421" href="#"></a></td>
<td><pre>            finish();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="422" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="423" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="424" href="#"></a></td>
<td><pre>        out.pathDone();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="425" href="#"></a></td>
<td><pre>        // this shouldn't matter since this object won't be used</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="426" href="#"></a></td>
<td><pre>        // after the call to this method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="427" href="#"></a></td>
<td><pre>        this.prev = CLOSE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="428" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="429" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="430" href="#"></a></td>
<td><pre>    private void finish() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="431" href="#"></a></td>
<td><pre>        if (capStyle == CAP_ROUND) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="432" href="#"></a></td>
<td><pre>            drawRoundCap(cx0, cy0, cmx, cmy);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="433" href="#"></a></td>
<td><pre>        } else if (capStyle == CAP_SQUARE) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="434" href="#"></a></td>
<td><pre>            emitLineTo(cx0 - cmy + cmx, cy0 + cmx + cmy);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="435" href="#"></a></td>
<td><pre>            emitLineTo(cx0 - cmy - cmx, cy0 + cmx - cmy);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="436" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="437" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="438" href="#"></a></td>
<td><pre>        emitReverse();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="439" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="440" href="#"></a></td>
<td><pre>        if (capStyle == CAP_ROUND) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="441" href="#"></a></td>
<td><pre>            drawRoundCap(sx0, sy0, -smx, -smy);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="442" href="#"></a></td>
<td><pre>        } else if (capStyle == CAP_SQUARE) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="443" href="#"></a></td>
<td><pre>            emitLineTo(sx0 + smy - smx, sy0 - smx - smy);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="444" href="#"></a></td>
<td><pre>            emitLineTo(sx0 + smy + smx, sy0 - smx + smy);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="445" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="446" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="447" href="#"></a></td>
<td><pre>        emitClose();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="448" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="449" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="450" href="#"></a></td>
<td><pre>    private void emitMoveTo(final float x0, final float y0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="451" href="#"></a></td>
<td><pre>        out.moveTo(x0, y0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="452" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="453" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="454" href="#"></a></td>
<td><pre>    private void emitLineTo(final float x1, final float y1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="455" href="#"></a></td>
<td><pre>        out.lineTo(x1, y1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="456" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="457" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="458" href="#"></a></td>
<td><pre>    private void emitLineTo(final float x1, final float y1,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="459" href="#"></a></td>
<td><pre>                            final boolean rev)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="460" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="461" href="#"></a></td>
<td><pre>        if (rev) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="462" href="#"></a></td>
<td><pre>            reverse.pushLine(x1, y1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="463" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="464" href="#"></a></td>
<td><pre>            emitLineTo(x1, y1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="465" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="466" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="467" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="468" href="#"></a></td>
<td><pre>    private void emitQuadTo(final float x0, final float y0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="469" href="#"></a></td>
<td><pre>                            final float x1, final float y1,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="470" href="#"></a></td>
<td><pre>                            final float x2, final float y2, final boolean rev)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="471" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="472" href="#"></a></td>
<td><pre>        if (rev) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="473" href="#"></a></td>
<td><pre>            reverse.pushQuad(x0, y0, x1, y1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="474" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="475" href="#"></a></td>
<td><pre>            out.quadTo(x1, y1, x2, y2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="476" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="477" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="478" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="479" href="#"></a></td>
<td><pre>    private void emitCurveTo(final float x0, final float y0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="480" href="#"></a></td>
<td><pre>                             final float x1, final float y1,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="481" href="#"></a></td>
<td><pre>                             final float x2, final float y2,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="482" href="#"></a></td>
<td><pre>                             final float x3, final float y3, final boolean rev)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="483" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="484" href="#"></a></td>
<td><pre>        if (rev) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="485" href="#"></a></td>
<td><pre>            reverse.pushCubic(x0, y0, x1, y1, x2, y2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="486" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="487" href="#"></a></td>
<td><pre>            out.curveTo(x1, y1, x2, y2, x3, y3);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="488" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="489" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="490" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="491" href="#"></a></td>
<td><pre>    private void emitClose() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="492" href="#"></a></td>
<td><pre>        out.closePath();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="493" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="494" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="495" href="#"></a></td>
<td><pre>    private void drawJoin(float pdx, float pdy,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="496" href="#"></a></td>
<td><pre>                          float x0, float y0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="497" href="#"></a></td>
<td><pre>                          float dx, float dy,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="498" href="#"></a></td>
<td><pre>                          float omx, float omy,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="499" href="#"></a></td>
<td><pre>                          float mx, float my)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="500" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="501" href="#"></a></td>
<td><pre>        if (prev != DRAWING_OP_TO) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="502" href="#"></a></td>
<td><pre>            emitMoveTo(x0 + mx, y0 + my);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="503" href="#"></a></td>
<td><pre>            this.sdx = dx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="504" href="#"></a></td>
<td><pre>            this.sdy = dy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="505" href="#"></a></td>
<td><pre>            this.smx = mx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="506" href="#"></a></td>
<td><pre>            this.smy = my;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="507" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="508" href="#"></a></td>
<td><pre>            boolean cw = isCW(pdx, pdy, dx, dy);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="509" href="#"></a></td>
<td><pre>            if (joinStyle == JOIN_MITER) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="510" href="#"></a></td>
<td><pre>                drawMiter(pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="511" href="#"></a></td>
<td><pre>            } else if (joinStyle == JOIN_ROUND) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="512" href="#"></a></td>
<td><pre>                drawRoundJoin(x0, y0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="513" href="#"></a></td>
<td><pre>                              omx, omy,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="514" href="#"></a></td>
<td><pre>                              mx, my, cw,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="515" href="#"></a></td>
<td><pre>                              ROUND_JOIN_THRESHOLD);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="516" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="517" href="#"></a></td>
<td><pre>            emitLineTo(x0, y0, !cw);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="518" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="519" href="#"></a></td>
<td><pre>        prev = DRAWING_OP_TO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="520" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="521" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="522" href="#"></a></td>
<td><pre>    private static boolean within(final float x1, final float y1,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="523" href="#"></a></td>
<td><pre>                                  final float x2, final float y2,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="524" href="#"></a></td>
<td><pre>                                  final float ERR)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="525" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="526" href="#"></a></td>
<td><pre>        assert ERR &gt; 0 : &quot;&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="527" href="#"></a></td>
<td><pre>        // compare taxicab distance. ERR will always be small, so using</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="528" href="#"></a></td>
<td><pre>        // true distance won't give much benefit</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="529" href="#"></a></td>
<td><pre>        return (Helpers.within(x1, x2, ERR) &amp;&amp;  // we want to avoid calling Math.abs</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="530" href="#"></a></td>
<td><pre>                Helpers.within(y1, y2, ERR)); // this is just as good.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="531" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="532" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="533" href="#"></a></td>
<td><pre>    private void getLineOffsets(float x1, float y1,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="534" href="#"></a></td>
<td><pre>                                float x2, float y2,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="535" href="#"></a></td>
<td><pre>                                float[] left, float[] right) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="536" href="#"></a></td>
<td><pre>        computeOffset(x2 - x1, y2 - y1, lineWidth2, offset[0]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="537" href="#"></a></td>
<td><pre>        left[0] = x1 + offset[0][0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="538" href="#"></a></td>
<td><pre>        left[1] = y1 + offset[0][1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="539" href="#"></a></td>
<td><pre>        left[2] = x2 + offset[0][0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="540" href="#"></a></td>
<td><pre>        left[3] = y2 + offset[0][1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="541" href="#"></a></td>
<td><pre>        right[0] = x1 - offset[0][0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="542" href="#"></a></td>
<td><pre>        right[1] = y1 - offset[0][1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="543" href="#"></a></td>
<td><pre>        right[2] = x2 - offset[0][0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="544" href="#"></a></td>
<td><pre>        right[3] = y2 - offset[0][1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="545" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="546" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="547" href="#"></a></td>
<td><pre>    private int computeOffsetCubic(float[] pts, final int off,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="548" href="#"></a></td>
<td><pre>                                   float[] leftOff, float[] rightOff)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="549" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="550" href="#"></a></td>
<td><pre>        // if p1=p2 or p3=p4 it means that the derivative at the endpoint</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="551" href="#"></a></td>
<td><pre>        // vanishes, which creates problems with computeOffset. Usually</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="552" href="#"></a></td>
<td><pre>        // this happens when this stroker object is trying to winden</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="553" href="#"></a></td>
<td><pre>        // a curve with a cusp. What happens is that curveTo splits</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="554" href="#"></a></td>
<td><pre>        // the input curve at the cusp, and passes it to this function.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="555" href="#"></a></td>
<td><pre>        // because of inaccuracies in the splitting, we consider points</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="556" href="#"></a></td>
<td><pre>        // equal if they're very close to each other.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="557" href="#"></a></td>
<td><pre>        final float x1 = pts[off + 0], y1 = pts[off + 1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="558" href="#"></a></td>
<td><pre>        final float x2 = pts[off + 2], y2 = pts[off + 3];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="559" href="#"></a></td>
<td><pre>        final float x3 = pts[off + 4], y3 = pts[off + 5];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="560" href="#"></a></td>
<td><pre>        final float x4 = pts[off + 6], y4 = pts[off + 7];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="561" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="562" href="#"></a></td>
<td><pre>        float dx4 = x4 - x3;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="563" href="#"></a></td>
<td><pre>        float dy4 = y4 - y3;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="564" href="#"></a></td>
<td><pre>        float dx1 = x2 - x1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="565" href="#"></a></td>
<td><pre>        float dy1 = y2 - y1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="566" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="567" href="#"></a></td>
<td><pre>        // if p1 == p2 &amp;&amp; p3 == p4: draw line from p1-&gt;p4, unless p1 == p4,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="568" href="#"></a></td>
<td><pre>        // in which case ignore if p1 == p2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="569" href="#"></a></td>
<td><pre>        final boolean p1eqp2 = within(x1,y1,x2,y2, 6 * ulp(y2));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="570" href="#"></a></td>
<td><pre>        final boolean p3eqp4 = within(x3,y3,x4,y4, 6 * ulp(y4));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="571" href="#"></a></td>
<td><pre>        if (p1eqp2 &amp;&amp; p3eqp4) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="572" href="#"></a></td>
<td><pre>            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="573" href="#"></a></td>
<td><pre>            return 4;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="574" href="#"></a></td>
<td><pre>        } else if (p1eqp2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="575" href="#"></a></td>
<td><pre>            dx1 = x3 - x1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="576" href="#"></a></td>
<td><pre>            dy1 = y3 - y1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="577" href="#"></a></td>
<td><pre>        } else if (p3eqp4) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="578" href="#"></a></td>
<td><pre>            dx4 = x4 - x2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="579" href="#"></a></td>
<td><pre>            dy4 = y4 - y2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="580" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="581" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="582" href="#"></a></td>
<td><pre>        // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="583" href="#"></a></td>
<td><pre>        float dotsq = (dx1 * dx4 + dy1 * dy4);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="584" href="#"></a></td>
<td><pre>        dotsq = dotsq * dotsq;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="585" href="#"></a></td>
<td><pre>        float l1sq = dx1 * dx1 + dy1 * dy1, l4sq = dx4 * dx4 + dy4 * dy4;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="586" href="#"></a></td>
<td><pre>        if (Helpers.within(dotsq, l1sq * l4sq, 4 * ulp(dotsq))) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="587" href="#"></a></td>
<td><pre>            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="588" href="#"></a></td>
<td><pre>            return 4;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="589" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="590" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="591" href="#"></a></td>
<td><pre>//      What we're trying to do in this function is to approximate an ideal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="592" href="#"></a></td>
<td><pre>//      offset curve (call it I) of the input curve B using a bezier curve Bp.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="593" href="#"></a></td>
<td><pre>//      The constraints I use to get the equations are:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="594" href="#"></a></td>
<td><pre>//</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="595" href="#"></a></td>
<td><pre>//      1. The computed curve Bp should go through I(0) and I(1). These are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="596" href="#"></a></td>
<td><pre>//      x1p, y1p, x4p, y4p, which are p1p and p4p. We still need to find</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="597" href="#"></a></td>
<td><pre>//      4 variables: the x and y components of p2p and p3p (i.e. x2p, y2p, x3p, y3p).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="598" href="#"></a></td>
<td><pre>//</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="599" href="#"></a></td>
<td><pre>//      2. Bp should have slope equal in absolute value to I at the endpoints. So,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="600" href="#"></a></td>
<td><pre>//      (by the way, the operator || in the comments below means &quot;aligned with&quot;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="601" href="#"></a></td>
<td><pre>//      It is defined on vectors, so when we say I'(0) || Bp'(0) we mean that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="602" href="#"></a></td>
<td><pre>//      vectors I'(0) and Bp'(0) are aligned, which is the same as saying</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="603" href="#"></a></td>
<td><pre>//      that the tangent lines of I and Bp at 0 are parallel. Mathematically</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="604" href="#"></a></td>
<td><pre>//      this means (I'(t) || Bp'(t)) &lt;==&gt; (I'(t) = c * Bp'(t)) where c is some</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="605" href="#"></a></td>
<td><pre>//      nonzero constant.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="606" href="#"></a></td>
<td><pre>//      I'(0) || Bp'(0) and I'(1) || Bp'(1). Obviously, I'(0) || B'(0) and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="607" href="#"></a></td>
<td><pre>//      I'(1) || B'(1); therefore, Bp'(0) || B'(0) and Bp'(1) || B'(1).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="608" href="#"></a></td>
<td><pre>//      We know that Bp'(0) || (p2p-p1p) and Bp'(1) || (p4p-p3p) and the same</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="609" href="#"></a></td>
<td><pre>//      is true for any bezier curve; therefore, we get the equations</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="610" href="#"></a></td>
<td><pre>//          (1) p2p = c1 * (p2-p1) + p1p</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="611" href="#"></a></td>
<td><pre>//          (2) p3p = c2 * (p4-p3) + p4p</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="612" href="#"></a></td>
<td><pre>//      We know p1p, p4p, p2, p1, p3, and p4; therefore, this reduces the number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="613" href="#"></a></td>
<td><pre>//      of unknowns from 4 to 2 (i.e. just c1 and c2).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="614" href="#"></a></td>
<td><pre>//      To eliminate these 2 unknowns we use the following constraint:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="615" href="#"></a></td>
<td><pre>//</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="616" href="#"></a></td>
<td><pre>//      3. Bp(0.5) == I(0.5). Bp(0.5)=(x,y) and I(0.5)=(xi,yi), and I should note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="617" href="#"></a></td>
<td><pre>//      that I(0.5) is *the only* reason for computing dxm,dym. This gives us</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="618" href="#"></a></td>
<td><pre>//          (3) Bp(0.5) = (p1p + 3 * (p2p + p3p) + p4p)/8, which is equivalent to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="619" href="#"></a></td>
<td><pre>//          (4) p2p + p3p = (Bp(0.5)*8 - p1p - p4p) / 3</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="620" href="#"></a></td>
<td><pre>//      We can substitute (1) and (2) from above into (4) and we get:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="621" href="#"></a></td>
<td><pre>//          (5) c1*(p2-p1) + c2*(p4-p3) = (Bp(0.5)*8 - p1p - p4p)/3 - p1p - p4p</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="622" href="#"></a></td>
<td><pre>//      which is equivalent to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="623" href="#"></a></td>
<td><pre>//          (6) c1*(p2-p1) + c2*(p4-p3) = (4/3) * (Bp(0.5) * 2 - p1p - p4p)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="624" href="#"></a></td>
<td><pre>//</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="625" href="#"></a></td>
<td><pre>//      The right side of this is a 2D vector, and we know I(0.5), which gives us</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="626" href="#"></a></td>
<td><pre>//      Bp(0.5), which gives us the value of the right side.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="627" href="#"></a></td>
<td><pre>//      The left side is just a matrix vector multiplication in disguise. It is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="628" href="#"></a></td>
<td><pre>//</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="629" href="#"></a></td>
<td><pre>//      [x2-x1, x4-x3][c1]</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="630" href="#"></a></td>
<td><pre>//      [y2-y1, y4-y3][c2]</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="631" href="#"></a></td>
<td><pre>//      which, is equal to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="632" href="#"></a></td>
<td><pre>//      [dx1, dx4][c1]</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="633" href="#"></a></td>
<td><pre>//      [dy1, dy4][c2]</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="634" href="#"></a></td>
<td><pre>//      At this point we are left with a simple linear system and we solve it by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="635" href="#"></a></td>
<td><pre>//      getting the inverse of the matrix above. Then we use [c1,c2] to compute</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="636" href="#"></a></td>
<td><pre>//      p2p and p3p.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="637" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="638" href="#"></a></td>
<td><pre>        float x = 0.125f * (x1 + 3 * (x2 + x3) + x4);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="639" href="#"></a></td>
<td><pre>        float y = 0.125f * (y1 + 3 * (y2 + y3) + y4);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="640" href="#"></a></td>
<td><pre>        // (dxm,dym) is some tangent of B at t=0.5. This means it's equal to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="641" href="#"></a></td>
<td><pre>        // c*B'(0.5) for some constant c.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="642" href="#"></a></td>
<td><pre>        float dxm = x3 + x4 - x1 - x2, dym = y3 + y4 - y1 - y2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="643" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="644" href="#"></a></td>
<td><pre>        // this computes the offsets at t=0, 0.5, 1, using the property that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="645" href="#"></a></td>
<td><pre>        // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="646" href="#"></a></td>
<td><pre>        // the (dx/dt, dy/dt) vectors at the endpoints.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="647" href="#"></a></td>
<td><pre>        computeOffset(dx1, dy1, lineWidth2, offset[0]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="648" href="#"></a></td>
<td><pre>        computeOffset(dxm, dym, lineWidth2, offset[1]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="649" href="#"></a></td>
<td><pre>        computeOffset(dx4, dy4, lineWidth2, offset[2]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="650" href="#"></a></td>
<td><pre>        float x1p = x1 + offset[0][0]; // start</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="651" href="#"></a></td>
<td><pre>        float y1p = y1 + offset[0][1]; // point</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="652" href="#"></a></td>
<td><pre>        float xi  = x + offset[1][0]; // interpolation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="653" href="#"></a></td>
<td><pre>        float yi  = y + offset[1][1]; // point</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="654" href="#"></a></td>
<td><pre>        float x4p = x4 + offset[2][0]; // end</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="655" href="#"></a></td>
<td><pre>        float y4p = y4 + offset[2][1]; // point</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="656" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="657" href="#"></a></td>
<td><pre>        float invdet43 = 4f / (3f * (dx1 * dy4 - dy1 * dx4));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="658" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="659" href="#"></a></td>
<td><pre>        float two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="660" href="#"></a></td>
<td><pre>        float two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="661" href="#"></a></td>
<td><pre>        float c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="662" href="#"></a></td>
<td><pre>        float c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="663" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="664" href="#"></a></td>
<td><pre>        float x2p, y2p, x3p, y3p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="665" href="#"></a></td>
<td><pre>        x2p = x1p + c1*dx1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="666" href="#"></a></td>
<td><pre>        y2p = y1p + c1*dy1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="667" href="#"></a></td>
<td><pre>        x3p = x4p + c2*dx4;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="668" href="#"></a></td>
<td><pre>        y3p = y4p + c2*dy4;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="669" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="670" href="#"></a></td>
<td><pre>        leftOff[0] = x1p; leftOff[1] = y1p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="671" href="#"></a></td>
<td><pre>        leftOff[2] = x2p; leftOff[3] = y2p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="672" href="#"></a></td>
<td><pre>        leftOff[4] = x3p; leftOff[5] = y3p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="673" href="#"></a></td>
<td><pre>        leftOff[6] = x4p; leftOff[7] = y4p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="674" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="675" href="#"></a></td>
<td><pre>        x1p = x1 - offset[0][0]; y1p = y1 - offset[0][1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="676" href="#"></a></td>
<td><pre>        xi = xi - 2 * offset[1][0]; yi = yi - 2 * offset[1][1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="677" href="#"></a></td>
<td><pre>        x4p = x4 - offset[2][0]; y4p = y4 - offset[2][1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="678" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="679" href="#"></a></td>
<td><pre>        two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="680" href="#"></a></td>
<td><pre>        two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="681" href="#"></a></td>
<td><pre>        c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="682" href="#"></a></td>
<td><pre>        c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="683" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="684" href="#"></a></td>
<td><pre>        x2p = x1p + c1*dx1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="685" href="#"></a></td>
<td><pre>        y2p = y1p + c1*dy1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="686" href="#"></a></td>
<td><pre>        x3p = x4p + c2*dx4;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="687" href="#"></a></td>
<td><pre>        y3p = y4p + c2*dy4;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="688" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="689" href="#"></a></td>
<td><pre>        rightOff[0] = x1p; rightOff[1] = y1p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="690" href="#"></a></td>
<td><pre>        rightOff[2] = x2p; rightOff[3] = y2p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="691" href="#"></a></td>
<td><pre>        rightOff[4] = x3p; rightOff[5] = y3p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="692" href="#"></a></td>
<td><pre>        rightOff[6] = x4p; rightOff[7] = y4p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="693" href="#"></a></td>
<td><pre>        return 8;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="694" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="695" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="696" href="#"></a></td>
<td><pre>    // return the kind of curve in the right and left arrays.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="697" href="#"></a></td>
<td><pre>    private int computeOffsetQuad(float[] pts, final int off,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="698" href="#"></a></td>
<td><pre>                                  float[] leftOff, float[] rightOff)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="699" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="700" href="#"></a></td>
<td><pre>        final float x1 = pts[off + 0], y1 = pts[off + 1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="701" href="#"></a></td>
<td><pre>        final float x2 = pts[off + 2], y2 = pts[off + 3];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="702" href="#"></a></td>
<td><pre>        final float x3 = pts[off + 4], y3 = pts[off + 5];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="703" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="704" href="#"></a></td>
<td><pre>        final float dx3 = x3 - x2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="705" href="#"></a></td>
<td><pre>        final float dy3 = y3 - y2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="706" href="#"></a></td>
<td><pre>        final float dx1 = x2 - x1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="707" href="#"></a></td>
<td><pre>        final float dy1 = y2 - y1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="708" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="709" href="#"></a></td>
<td><pre>        // this computes the offsets at t = 0, 1</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="710" href="#"></a></td>
<td><pre>        computeOffset(dx1, dy1, lineWidth2, offset[0]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="711" href="#"></a></td>
<td><pre>        computeOffset(dx3, dy3, lineWidth2, offset[1]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="712" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="713" href="#"></a></td>
<td><pre>        leftOff[0]  = x1 + offset[0][0];  leftOff[1] = y1 + offset[0][1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="714" href="#"></a></td>
<td><pre>        leftOff[4]  = x3 + offset[1][0];  leftOff[5] = y3 + offset[1][1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="715" href="#"></a></td>
<td><pre>        rightOff[0] = x1 - offset[0][0]; rightOff[1] = y1 - offset[0][1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="716" href="#"></a></td>
<td><pre>        rightOff[4] = x3 - offset[1][0]; rightOff[5] = y3 - offset[1][1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="717" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="718" href="#"></a></td>
<td><pre>        float x1p = leftOff[0]; // start</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="719" href="#"></a></td>
<td><pre>        float y1p = leftOff[1]; // point</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="720" href="#"></a></td>
<td><pre>        float x3p = leftOff[4]; // end</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="721" href="#"></a></td>
<td><pre>        float y3p = leftOff[5]; // point</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="722" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="723" href="#"></a></td>
<td><pre>        // Corner cases:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="724" href="#"></a></td>
<td><pre>        // 1. If the two control vectors are parallel, we'll end up with NaN's</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="725" href="#"></a></td>
<td><pre>        //    in leftOff (and rightOff in the body of the if below), so we'll</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="726" href="#"></a></td>
<td><pre>        //    do getLineOffsets, which is right.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="727" href="#"></a></td>
<td><pre>        // 2. If the first or second two points are equal, then (dx1,dy1)==(0,0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="728" href="#"></a></td>
<td><pre>        //    or (dx3,dy3)==(0,0), so (x1p, y1p)==(x1p+dx1, y1p+dy1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="729" href="#"></a></td>
<td><pre>        //    or (x3p, y3p)==(x3p-dx3, y3p-dy3), which means that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="730" href="#"></a></td>
<td><pre>        //    computeIntersection will put NaN's in leftOff and right off, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="731" href="#"></a></td>
<td><pre>        //    we will do getLineOffsets, which is right.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="732" href="#"></a></td>
<td><pre>        computeIntersection(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, leftOff, 2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="733" href="#"></a></td>
<td><pre>        float cx = leftOff[2];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="734" href="#"></a></td>
<td><pre>        float cy = leftOff[3];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="735" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="736" href="#"></a></td>
<td><pre>        if (!(isFinite(cx) &amp;&amp; isFinite(cy))) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="737" href="#"></a></td>
<td><pre>            // maybe the right path is not degenerate.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="738" href="#"></a></td>
<td><pre>            x1p = rightOff[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="739" href="#"></a></td>
<td><pre>            y1p = rightOff[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="740" href="#"></a></td>
<td><pre>            x3p = rightOff[4];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="741" href="#"></a></td>
<td><pre>            y3p = rightOff[5];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="742" href="#"></a></td>
<td><pre>            computeIntersection(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, rightOff, 2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="743" href="#"></a></td>
<td><pre>            cx = rightOff[2];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="744" href="#"></a></td>
<td><pre>            cy = rightOff[3];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="745" href="#"></a></td>
<td><pre>            if (!(isFinite(cx) &amp;&amp; isFinite(cy))) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="746" href="#"></a></td>
<td><pre>                // both are degenerate. This curve is a line.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="747" href="#"></a></td>
<td><pre>                getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="748" href="#"></a></td>
<td><pre>                return 4;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="749" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="750" href="#"></a></td>
<td><pre>            // {left,right}Off[0,1,4,5] are already set to the correct values.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="751" href="#"></a></td>
<td><pre>            leftOff[2] = 2*x2 - cx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="752" href="#"></a></td>
<td><pre>            leftOff[3] = 2*y2 - cy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="753" href="#"></a></td>
<td><pre>            return 6;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="754" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="755" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="756" href="#"></a></td>
<td><pre>        // rightOff[2,3] = (x2,y2) - ((left_x2, left_y2) - (x2, y2))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="757" href="#"></a></td>
<td><pre>        // == 2*(x2, y2) - (left_x2, left_y2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="758" href="#"></a></td>
<td><pre>        rightOff[2] = 2*x2 - cx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="759" href="#"></a></td>
<td><pre>        rightOff[3] = 2*y2 - cy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="760" href="#"></a></td>
<td><pre>        return 6;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="761" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="762" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="763" href="#"></a></td>
<td><pre>    private static boolean isFinite(float x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="764" href="#"></a></td>
<td><pre>        return (Float.NEGATIVE_INFINITY &lt; x &amp;&amp; x &lt; Float.POSITIVE_INFINITY);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="765" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="766" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="767" href="#"></a></td>
<td><pre>    // This is where the curve to be processed is put. We give it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="768" href="#"></a></td>
<td><pre>    // enough room to store 2 curves: one for the current subdivision, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="769" href="#"></a></td>
<td><pre>    // other for the rest of the curve.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="770" href="#"></a></td>
<td><pre>    private float[] middle = new float[2*8];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="771" href="#"></a></td>
<td><pre>    private float[] lp = new float[8];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="772" href="#"></a></td>
<td><pre>    private float[] rp = new float[8];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="773" href="#"></a></td>
<td><pre>    private static final int MAX_N_CURVES = 11;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="774" href="#"></a></td>
<td><pre>    private float[] subdivTs = new float[MAX_N_CURVES - 1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="775" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="776" href="#"></a></td>
<td><pre>    // If this class is compiled with ecj, then Hotspot crashes when OSR</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="777" href="#"></a></td>
<td><pre>    // compiling this function. See bugs 7004570 and 6675699</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="778" href="#"></a></td>
<td><pre>    // TODO: until those are fixed, we should work around that by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="779" href="#"></a></td>
<td><pre>    // manually inlining this into curveTo and quadTo.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="780" href="#"></a></td>
<td><pre>/******************************* WORKAROUND **********************************</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="781" href="#"></a></td>
<td><pre>    private void somethingTo(final int type) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="782" href="#"></a></td>
<td><pre>        // need these so we can update the state at the end of this method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="783" href="#"></a></td>
<td><pre>        final float xf = middle[type-2], yf = middle[type-1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="784" href="#"></a></td>
<td><pre>        float dxs = middle[2] - middle[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="785" href="#"></a></td>
<td><pre>        float dys = middle[3] - middle[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="786" href="#"></a></td>
<td><pre>        float dxf = middle[type - 2] - middle[type - 4];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="787" href="#"></a></td>
<td><pre>        float dyf = middle[type - 1] - middle[type - 3];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="788" href="#"></a></td>
<td><pre>        switch(type) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="789" href="#"></a></td>
<td><pre>        case 6:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="790" href="#"></a></td>
<td><pre>            if ((dxs == 0f &amp;&amp; dys == 0f) ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="791" href="#"></a></td>
<td><pre>                (dxf == 0f &amp;&amp; dyf == 0f)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="792" href="#"></a></td>
<td><pre>               dxs = dxf = middle[4] - middle[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="793" href="#"></a></td>
<td><pre>               dys = dyf = middle[5] - middle[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="794" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="795" href="#"></a></td>
<td><pre>            break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="796" href="#"></a></td>
<td><pre>        case 8:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="797" href="#"></a></td>
<td><pre>            boolean p1eqp2 = (dxs == 0f &amp;&amp; dys == 0f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="798" href="#"></a></td>
<td><pre>            boolean p3eqp4 = (dxf == 0f &amp;&amp; dyf == 0f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="799" href="#"></a></td>
<td><pre>            if (p1eqp2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="800" href="#"></a></td>
<td><pre>                dxs = middle[4] - middle[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="801" href="#"></a></td>
<td><pre>                dys = middle[5] - middle[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="802" href="#"></a></td>
<td><pre>                if (dxs == 0f &amp;&amp; dys == 0f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="803" href="#"></a></td>
<td><pre>                    dxs = middle[6] - middle[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="804" href="#"></a></td>
<td><pre>                    dys = middle[7] - middle[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="805" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="806" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="807" href="#"></a></td>
<td><pre>            if (p3eqp4) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="808" href="#"></a></td>
<td><pre>                dxf = middle[6] - middle[2];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="809" href="#"></a></td>
<td><pre>                dyf = middle[7] - middle[3];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="810" href="#"></a></td>
<td><pre>                if (dxf == 0f &amp;&amp; dyf == 0f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="811" href="#"></a></td>
<td><pre>                    dxf = middle[6] - middle[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="812" href="#"></a></td>
<td><pre>                    dyf = middle[7] - middle[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="813" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="814" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="815" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="816" href="#"></a></td>
<td><pre>        if (dxs == 0f &amp;&amp; dys == 0f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="817" href="#"></a></td>
<td><pre>            // this happens iff the &quot;curve&quot; is just a point</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="818" href="#"></a></td>
<td><pre>            lineTo(middle[0], middle[1]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="819" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="820" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="821" href="#"></a></td>
<td><pre>        // if these vectors are too small, normalize them, to avoid future</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="822" href="#"></a></td>
<td><pre>        // precision problems.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="823" href="#"></a></td>
<td><pre>        if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="824" href="#"></a></td>
<td><pre>            float len = (float) sqrt(dxs*dxs + dys*dys);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="825" href="#"></a></td>
<td><pre>            dxs /= len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="826" href="#"></a></td>
<td><pre>            dys /= len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="827" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="828" href="#"></a></td>
<td><pre>        if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="829" href="#"></a></td>
<td><pre>            float len = (float) sqrt(dxf*dxf + dyf*dyf);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="830" href="#"></a></td>
<td><pre>            dxf /= len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="831" href="#"></a></td>
<td><pre>            dyf /= len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="832" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="833" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="834" href="#"></a></td>
<td><pre>        computeOffset(dxs, dys, lineWidth2, offset[0]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="835" href="#"></a></td>
<td><pre>        final float mx = offset[0][0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="836" href="#"></a></td>
<td><pre>        final float my = offset[0][1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="837" href="#"></a></td>
<td><pre>        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="838" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="839" href="#"></a></td>
<td><pre>        int nSplits = findSubdivPoints(middle, subdivTs, type, lineWidth2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="840" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="841" href="#"></a></td>
<td><pre>        int kind = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="842" href="#"></a></td>
<td><pre>        Iterator&lt;Integer&gt; it = Curve.breakPtsAtTs(middle, type, subdivTs, nSplits);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="843" href="#"></a></td>
<td><pre>        while(it.hasNext()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="844" href="#"></a></td>
<td><pre>            int curCurveOff = it.next();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="845" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="846" href="#"></a></td>
<td><pre>            switch (type) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="847" href="#"></a></td>
<td><pre>            case 8:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="848" href="#"></a></td>
<td><pre>                kind = computeOffsetCubic(middle, curCurveOff, lp, rp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="849" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="850" href="#"></a></td>
<td><pre>            case 6:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="851" href="#"></a></td>
<td><pre>                kind = computeOffsetQuad(middle, curCurveOff, lp, rp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="852" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="853" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="854" href="#"></a></td>
<td><pre>            emitLineTo(lp[0], lp[1]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="855" href="#"></a></td>
<td><pre>            switch(kind) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="856" href="#"></a></td>
<td><pre>            case 8:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="857" href="#"></a></td>
<td><pre>                emitCurveTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="858" href="#"></a></td>
<td><pre>                emitCurveTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="859" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="860" href="#"></a></td>
<td><pre>            case 6:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="861" href="#"></a></td>
<td><pre>                emitQuadTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="862" href="#"></a></td>
<td><pre>                emitQuadTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="863" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="864" href="#"></a></td>
<td><pre>            case 4:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="865" href="#"></a></td>
<td><pre>                emitLineTo(lp[2], lp[3]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="866" href="#"></a></td>
<td><pre>                emitLineTo(rp[0], rp[1], true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="867" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="868" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="869" href="#"></a></td>
<td><pre>            emitLineTo(rp[kind - 2], rp[kind - 1], true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="870" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="871" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="872" href="#"></a></td>
<td><pre>        this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="873" href="#"></a></td>
<td><pre>        this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="874" href="#"></a></td>
<td><pre>        this.cdx = dxf;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="875" href="#"></a></td>
<td><pre>        this.cdy = dyf;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="876" href="#"></a></td>
<td><pre>        this.cx0 = xf;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="877" href="#"></a></td>
<td><pre>        this.cy0 = yf;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="878" href="#"></a></td>
<td><pre>        this.prev = DRAWING_OP_TO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="879" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="880" href="#"></a></td>
<td><pre>****************************** END WORKAROUND *******************************/</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="881" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="882" href="#"></a></td>
<td><pre>    // finds values of t where the curve in pts should be subdivided in order</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="883" href="#"></a></td>
<td><pre>    // to get good offset curves a distance of w away from the middle curve.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="884" href="#"></a></td>
<td><pre>    // Stores the points in ts, and returns how many of them there were.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="885" href="#"></a></td>
<td><pre>    private static Curve c = new Curve();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="886" href="#"></a></td>
<td><pre>    private static int findSubdivPoints(float[] pts, float[] ts, final int type, final float w)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="887" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="888" href="#"></a></td>
<td><pre>        final float x12 = pts[2] - pts[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="889" href="#"></a></td>
<td><pre>        final float y12 = pts[3] - pts[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="890" href="#"></a></td>
<td><pre>        // if the curve is already parallel to either axis we gain nothing</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="891" href="#"></a></td>
<td><pre>        // from rotating it.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="892" href="#"></a></td>
<td><pre>        if (y12 != 0f &amp;&amp; x12 != 0f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="893" href="#"></a></td>
<td><pre>            // we rotate it so that the first vector in the control polygon is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="894" href="#"></a></td>
<td><pre>            // parallel to the x-axis. This will ensure that rotated quarter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="895" href="#"></a></td>
<td><pre>            // circles won't be subdivided.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="896" href="#"></a></td>
<td><pre>            final float hypot = (float) sqrt(x12 * x12 + y12 * y12);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="897" href="#"></a></td>
<td><pre>            final float cos = x12 / hypot;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="898" href="#"></a></td>
<td><pre>            final float sin = y12 / hypot;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="899" href="#"></a></td>
<td><pre>            final float x1 = cos * pts[0] + sin * pts[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="900" href="#"></a></td>
<td><pre>            final float y1 = cos * pts[1] - sin * pts[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="901" href="#"></a></td>
<td><pre>            final float x2 = cos * pts[2] + sin * pts[3];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="902" href="#"></a></td>
<td><pre>            final float y2 = cos * pts[3] - sin * pts[2];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="903" href="#"></a></td>
<td><pre>            final float x3 = cos * pts[4] + sin * pts[5];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="904" href="#"></a></td>
<td><pre>            final float y3 = cos * pts[5] - sin * pts[4];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="905" href="#"></a></td>
<td><pre>            switch(type) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="906" href="#"></a></td>
<td><pre>            case 8:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="907" href="#"></a></td>
<td><pre>                final float x4 = cos * pts[6] + sin * pts[7];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="908" href="#"></a></td>
<td><pre>                final float y4 = cos * pts[7] - sin * pts[6];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="909" href="#"></a></td>
<td><pre>                c.set(x1, y1, x2, y2, x3, y3, x4, y4);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="910" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="911" href="#"></a></td>
<td><pre>            case 6:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="912" href="#"></a></td>
<td><pre>                c.set(x1, y1, x2, y2, x3, y3);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="913" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="914" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="915" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="916" href="#"></a></td>
<td><pre>            c.set(pts, type);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="917" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="918" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="919" href="#"></a></td>
<td><pre>        int ret = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="920" href="#"></a></td>
<td><pre>        // we subdivide at values of t such that the remaining rotated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="921" href="#"></a></td>
<td><pre>        // curves are monotonic in x and y.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="922" href="#"></a></td>
<td><pre>        ret += c.dxRoots(ts, ret);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="923" href="#"></a></td>
<td><pre>        ret += c.dyRoots(ts, ret);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="924" href="#"></a></td>
<td><pre>        // subdivide at inflection points.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="925" href="#"></a></td>
<td><pre>        if (type == 8) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="926" href="#"></a></td>
<td><pre>            // quadratic curves can't have inflection points</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="927" href="#"></a></td>
<td><pre>            ret += c.infPoints(ts, ret);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="928" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="929" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="930" href="#"></a></td>
<td><pre>        // now we must subdivide at points where one of the offset curves will have</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="931" href="#"></a></td>
<td><pre>        // a cusp. This happens at ts where the radius of curvature is equal to w.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="932" href="#"></a></td>
<td><pre>        ret += c.rootsOfROCMinusW(ts, ret, w, 0.0001f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="933" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="934" href="#"></a></td>
<td><pre>        ret = Helpers.filterOutNotInAB(ts, 0, ret, 0.0001f, 0.9999f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="935" href="#"></a></td>
<td><pre>        Helpers.isort(ts, 0, ret);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="936" href="#"></a></td>
<td><pre>        return ret;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="937" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="938" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="939" href="#"></a></td>
<td><pre>    @Override public void curveTo(float x1, float y1,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="940" href="#"></a></td>
<td><pre>                                  float x2, float y2,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="941" href="#"></a></td>
<td><pre>                                  float x3, float y3)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="942" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="943" href="#"></a></td>
<td><pre>        middle[0] = cx0; middle[1] = cy0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="944" href="#"></a></td>
<td><pre>        middle[2] = x1;  middle[3] = y1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="945" href="#"></a></td>
<td><pre>        middle[4] = x2;  middle[5] = y2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="946" href="#"></a></td>
<td><pre>        middle[6] = x3;  middle[7] = y3;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="947" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="948" href="#"></a></td>
<td><pre>        // inlined version of somethingTo(8);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="949" href="#"></a></td>
<td><pre>        // See the TODO on somethingTo</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="950" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="951" href="#"></a></td>
<td><pre>        // need these so we can update the state at the end of this method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="952" href="#"></a></td>
<td><pre>        final float xf = middle[6], yf = middle[7];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="953" href="#"></a></td>
<td><pre>        float dxs = middle[2] - middle[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="954" href="#"></a></td>
<td><pre>        float dys = middle[3] - middle[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="955" href="#"></a></td>
<td><pre>        float dxf = middle[6] - middle[4];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="956" href="#"></a></td>
<td><pre>        float dyf = middle[7] - middle[5];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="957" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="958" href="#"></a></td>
<td><pre>        boolean p1eqp2 = (dxs == 0f &amp;&amp; dys == 0f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="959" href="#"></a></td>
<td><pre>        boolean p3eqp4 = (dxf == 0f &amp;&amp; dyf == 0f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="960" href="#"></a></td>
<td><pre>        if (p1eqp2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="961" href="#"></a></td>
<td><pre>            dxs = middle[4] - middle[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="962" href="#"></a></td>
<td><pre>            dys = middle[5] - middle[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="963" href="#"></a></td>
<td><pre>            if (dxs == 0f &amp;&amp; dys == 0f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="964" href="#"></a></td>
<td><pre>                dxs = middle[6] - middle[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="965" href="#"></a></td>
<td><pre>                dys = middle[7] - middle[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="966" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="967" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="968" href="#"></a></td>
<td><pre>        if (p3eqp4) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="969" href="#"></a></td>
<td><pre>            dxf = middle[6] - middle[2];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="970" href="#"></a></td>
<td><pre>            dyf = middle[7] - middle[3];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="971" href="#"></a></td>
<td><pre>            if (dxf == 0f &amp;&amp; dyf == 0f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="972" href="#"></a></td>
<td><pre>                dxf = middle[6] - middle[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="973" href="#"></a></td>
<td><pre>                dyf = middle[7] - middle[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="974" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="975" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="976" href="#"></a></td>
<td><pre>        if (dxs == 0f &amp;&amp; dys == 0f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="977" href="#"></a></td>
<td><pre>            // this happens iff the &quot;curve&quot; is just a point</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="978" href="#"></a></td>
<td><pre>            lineTo(middle[0], middle[1]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="979" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="980" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="981" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="982" href="#"></a></td>
<td><pre>        // if these vectors are too small, normalize them, to avoid future</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="983" href="#"></a></td>
<td><pre>        // precision problems.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="984" href="#"></a></td>
<td><pre>        if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="985" href="#"></a></td>
<td><pre>            float len = (float) sqrt(dxs*dxs + dys*dys);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="986" href="#"></a></td>
<td><pre>            dxs /= len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="987" href="#"></a></td>
<td><pre>            dys /= len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="988" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="989" href="#"></a></td>
<td><pre>        if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="990" href="#"></a></td>
<td><pre>            float len = (float) sqrt(dxf*dxf + dyf*dyf);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="991" href="#"></a></td>
<td><pre>            dxf /= len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="992" href="#"></a></td>
<td><pre>            dyf /= len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="993" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="994" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="995" href="#"></a></td>
<td><pre>        computeOffset(dxs, dys, lineWidth2, offset[0]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="996" href="#"></a></td>
<td><pre>        final float mx = offset[0][0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="997" href="#"></a></td>
<td><pre>        final float my = offset[0][1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="998" href="#"></a></td>
<td><pre>        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="999" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1000" href="#"></a></td>
<td><pre>        int nSplits = findSubdivPoints(middle, subdivTs, 8, lineWidth2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1001" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1002" href="#"></a></td>
<td><pre>        int kind = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1003" href="#"></a></td>
<td><pre>        Iterator&lt;Integer&gt; it = Curve.breakPtsAtTs(middle, 8, subdivTs, nSplits);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1004" href="#"></a></td>
<td><pre>        while(it.hasNext()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1005" href="#"></a></td>
<td><pre>            int curCurveOff = it.next();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1006" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1007" href="#"></a></td>
<td><pre>            kind = computeOffsetCubic(middle, curCurveOff, lp, rp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1008" href="#"></a></td>
<td><pre>            emitLineTo(lp[0], lp[1]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1009" href="#"></a></td>
<td><pre>            switch(kind) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1010" href="#"></a></td>
<td><pre>            case 8:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1011" href="#"></a></td>
<td><pre>                emitCurveTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1012" href="#"></a></td>
<td><pre>                emitCurveTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1013" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1014" href="#"></a></td>
<td><pre>            case 4:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1015" href="#"></a></td>
<td><pre>                emitLineTo(lp[2], lp[3]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1016" href="#"></a></td>
<td><pre>                emitLineTo(rp[0], rp[1], true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1017" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1018" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1019" href="#"></a></td>
<td><pre>            emitLineTo(rp[kind - 2], rp[kind - 1], true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1020" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1021" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1022" href="#"></a></td>
<td><pre>        this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1023" href="#"></a></td>
<td><pre>        this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1024" href="#"></a></td>
<td><pre>        this.cdx = dxf;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1025" href="#"></a></td>
<td><pre>        this.cdy = dyf;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1026" href="#"></a></td>
<td><pre>        this.cx0 = xf;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1027" href="#"></a></td>
<td><pre>        this.cy0 = yf;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1028" href="#"></a></td>
<td><pre>        this.prev = DRAWING_OP_TO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1029" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1030" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1031" href="#"></a></td>
<td><pre>    @Override public void quadTo(float x1, float y1, float x2, float y2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1032" href="#"></a></td>
<td><pre>        middle[0] = cx0; middle[1] = cy0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1033" href="#"></a></td>
<td><pre>        middle[2] = x1;  middle[3] = y1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1034" href="#"></a></td>
<td><pre>        middle[4] = x2;  middle[5] = y2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1035" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1036" href="#"></a></td>
<td><pre>        // inlined version of somethingTo(8);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1037" href="#"></a></td>
<td><pre>        // See the TODO on somethingTo</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1038" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1039" href="#"></a></td>
<td><pre>        // need these so we can update the state at the end of this method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1040" href="#"></a></td>
<td><pre>        final float xf = middle[4], yf = middle[5];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1041" href="#"></a></td>
<td><pre>        float dxs = middle[2] - middle[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1042" href="#"></a></td>
<td><pre>        float dys = middle[3] - middle[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1043" href="#"></a></td>
<td><pre>        float dxf = middle[4] - middle[2];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1044" href="#"></a></td>
<td><pre>        float dyf = middle[5] - middle[3];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1045" href="#"></a></td>
<td><pre>        if ((dxs == 0f &amp;&amp; dys == 0f) || (dxf == 0f &amp;&amp; dyf == 0f)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1046" href="#"></a></td>
<td><pre>            dxs = dxf = middle[4] - middle[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1047" href="#"></a></td>
<td><pre>            dys = dyf = middle[5] - middle[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1048" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1049" href="#"></a></td>
<td><pre>        if (dxs == 0f &amp;&amp; dys == 0f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1050" href="#"></a></td>
<td><pre>            // this happens iff the &quot;curve&quot; is just a point</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1051" href="#"></a></td>
<td><pre>            lineTo(middle[0], middle[1]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1052" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1053" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1054" href="#"></a></td>
<td><pre>        // if these vectors are too small, normalize them, to avoid future</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1055" href="#"></a></td>
<td><pre>        // precision problems.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1056" href="#"></a></td>
<td><pre>        if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1057" href="#"></a></td>
<td><pre>            float len = (float) sqrt(dxs*dxs + dys*dys);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1058" href="#"></a></td>
<td><pre>            dxs /= len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1059" href="#"></a></td>
<td><pre>            dys /= len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1060" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1061" href="#"></a></td>
<td><pre>        if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1062" href="#"></a></td>
<td><pre>            float len = (float) sqrt(dxf*dxf + dyf*dyf);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1063" href="#"></a></td>
<td><pre>            dxf /= len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1064" href="#"></a></td>
<td><pre>            dyf /= len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1065" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1066" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1067" href="#"></a></td>
<td><pre>        computeOffset(dxs, dys, lineWidth2, offset[0]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1068" href="#"></a></td>
<td><pre>        final float mx = offset[0][0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1069" href="#"></a></td>
<td><pre>        final float my = offset[0][1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1070" href="#"></a></td>
<td><pre>        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1071" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1072" href="#"></a></td>
<td><pre>        int nSplits = findSubdivPoints(middle, subdivTs, 6, lineWidth2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1073" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1074" href="#"></a></td>
<td><pre>        int kind = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1075" href="#"></a></td>
<td><pre>        Iterator&lt;Integer&gt; it = Curve.breakPtsAtTs(middle, 6, subdivTs, nSplits);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1076" href="#"></a></td>
<td><pre>        while(it.hasNext()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1077" href="#"></a></td>
<td><pre>            int curCurveOff = it.next();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1078" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1079" href="#"></a></td>
<td><pre>            kind = computeOffsetQuad(middle, curCurveOff, lp, rp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1080" href="#"></a></td>
<td><pre>            emitLineTo(lp[0], lp[1]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1081" href="#"></a></td>
<td><pre>            switch(kind) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1082" href="#"></a></td>
<td><pre>            case 6:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1083" href="#"></a></td>
<td><pre>                emitQuadTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1084" href="#"></a></td>
<td><pre>                emitQuadTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1085" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1086" href="#"></a></td>
<td><pre>            case 4:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1087" href="#"></a></td>
<td><pre>                emitLineTo(lp[2], lp[3]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1088" href="#"></a></td>
<td><pre>                emitLineTo(rp[0], rp[1], true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1089" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1090" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1091" href="#"></a></td>
<td><pre>            emitLineTo(rp[kind - 2], rp[kind - 1], true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1092" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1093" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1094" href="#"></a></td>
<td><pre>        this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1095" href="#"></a></td>
<td><pre>        this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1096" href="#"></a></td>
<td><pre>        this.cdx = dxf;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1097" href="#"></a></td>
<td><pre>        this.cdy = dyf;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1098" href="#"></a></td>
<td><pre>        this.cx0 = xf;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1099" href="#"></a></td>
<td><pre>        this.cy0 = yf;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1100" href="#"></a></td>
<td><pre>        this.prev = DRAWING_OP_TO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1101" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1102" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1103" href="#"></a></td>
<td><pre>    @Override public long getNativeConsumer() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1104" href="#"></a></td>
<td><pre>        throw new InternalError(&quot;Stroker doesn't use a native consumer&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1105" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1106" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1107" href="#"></a></td>
<td><pre>    // a stack of polynomial curves where each curve shares endpoints with</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1108" href="#"></a></td>
<td><pre>    // adjacent ones.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1109" href="#"></a></td>
<td><pre>    private static final class PolyStack {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1110" href="#"></a></td>
<td><pre>        float[] curves;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1111" href="#"></a></td>
<td><pre>        int end;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1112" href="#"></a></td>
<td><pre>        int[] curveTypes;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1113" href="#"></a></td>
<td><pre>        int numCurves;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1114" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1115" href="#"></a></td>
<td><pre>        private static final int INIT_SIZE = 50;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1116" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1117" href="#"></a></td>
<td><pre>        PolyStack() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1118" href="#"></a></td>
<td><pre>            curves = new float[8 * INIT_SIZE];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1119" href="#"></a></td>
<td><pre>            curveTypes = new int[INIT_SIZE];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1120" href="#"></a></td>
<td><pre>            end = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1121" href="#"></a></td>
<td><pre>            numCurves = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1122" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1123" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1124" href="#"></a></td>
<td><pre>        public boolean isEmpty() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1125" href="#"></a></td>
<td><pre>            return numCurves == 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1126" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1127" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1128" href="#"></a></td>
<td><pre>        private void ensureSpace(int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1129" href="#"></a></td>
<td><pre>            if (end + n &gt;= curves.length) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1130" href="#"></a></td>
<td><pre>                int newSize = (end + n) * 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1131" href="#"></a></td>
<td><pre>                curves = Arrays.copyOf(curves, newSize);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1132" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1133" href="#"></a></td>
<td><pre>            if (numCurves &gt;= curveTypes.length) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1134" href="#"></a></td>
<td><pre>                int newSize = numCurves * 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1135" href="#"></a></td>
<td><pre>                curveTypes = Arrays.copyOf(curveTypes, newSize);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1136" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1137" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1138" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1139" href="#"></a></td>
<td><pre>        public void pushCubic(float x0, float y0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1140" href="#"></a></td>
<td><pre>                              float x1, float y1,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1141" href="#"></a></td>
<td><pre>                              float x2, float y2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1142" href="#"></a></td>
<td><pre>        {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1143" href="#"></a></td>
<td><pre>            ensureSpace(6);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1144" href="#"></a></td>
<td><pre>            curveTypes[numCurves++] = 8;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1145" href="#"></a></td>
<td><pre>            // assert(x0 == lastX &amp;&amp; y0 == lastY)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1146" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1147" href="#"></a></td>
<td><pre>            // we reverse the coordinate order to make popping easier</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1148" href="#"></a></td>
<td><pre>            curves[end++] = x2;    curves[end++] = y2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1149" href="#"></a></td>
<td><pre>            curves[end++] = x1;    curves[end++] = y1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1150" href="#"></a></td>
<td><pre>            curves[end++] = x0;    curves[end++] = y0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1151" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1152" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1153" href="#"></a></td>
<td><pre>        public void pushQuad(float x0, float y0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1154" href="#"></a></td>
<td><pre>                             float x1, float y1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1155" href="#"></a></td>
<td><pre>        {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1156" href="#"></a></td>
<td><pre>            ensureSpace(4);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1157" href="#"></a></td>
<td><pre>            curveTypes[numCurves++] = 6;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1158" href="#"></a></td>
<td><pre>            // assert(x0 == lastX &amp;&amp; y0 == lastY)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1159" href="#"></a></td>
<td><pre>            curves[end++] = x1;    curves[end++] = y1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1160" href="#"></a></td>
<td><pre>            curves[end++] = x0;    curves[end++] = y0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1161" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1162" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1163" href="#"></a></td>
<td><pre>        public void pushLine(float x, float y) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1164" href="#"></a></td>
<td><pre>            ensureSpace(2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1165" href="#"></a></td>
<td><pre>            curveTypes[numCurves++] = 4;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1166" href="#"></a></td>
<td><pre>            // assert(x0 == lastX &amp;&amp; y0 == lastY)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1167" href="#"></a></td>
<td><pre>            curves[end++] = x;    curves[end++] = y;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1168" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1169" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1170" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;unused&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1171" href="#"></a></td>
<td><pre>        public int pop(float[] pts) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1172" href="#"></a></td>
<td><pre>            int ret = curveTypes[numCurves - 1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1173" href="#"></a></td>
<td><pre>            numCurves--;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1174" href="#"></a></td>
<td><pre>            end -= (ret - 2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1175" href="#"></a></td>
<td><pre>            System.arraycopy(curves, end, pts, 0, ret - 2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1176" href="#"></a></td>
<td><pre>            return ret;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1177" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1178" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1179" href="#"></a></td>
<td><pre>        public void pop(PathConsumer2D io) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1180" href="#"></a></td>
<td><pre>            numCurves--;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1181" href="#"></a></td>
<td><pre>            int type = curveTypes[numCurves];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1182" href="#"></a></td>
<td><pre>            end -= (type - 2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1183" href="#"></a></td>
<td><pre>            switch(type) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1184" href="#"></a></td>
<td><pre>            case 8:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1185" href="#"></a></td>
<td><pre>                io.curveTo(curves[end+0], curves[end+1],</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1186" href="#"></a></td>
<td><pre>                           curves[end+2], curves[end+3],</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1187" href="#"></a></td>
<td><pre>                           curves[end+4], curves[end+5]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1188" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1189" href="#"></a></td>
<td><pre>            case 6:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1190" href="#"></a></td>
<td><pre>                io.quadTo(curves[end+0], curves[end+1],</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1191" href="#"></a></td>
<td><pre>                           curves[end+2], curves[end+3]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1192" href="#"></a></td>
<td><pre>                 break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1193" href="#"></a></td>
<td><pre>            case 4:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1194" href="#"></a></td>
<td><pre>                io.lineTo(curves[end], curves[end+1]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1195" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1196" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1197" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1198" href="#"></a></td>
<td><pre>        @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1199" href="#"></a></td>
<td><pre>        public String toString() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1200" href="#"></a></td>
<td><pre>            String ret = &quot;&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1201" href="#"></a></td>
<td><pre>            int nc = numCurves;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1202" href="#"></a></td>
<td><pre>            int end = this.end;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1203" href="#"></a></td>
<td><pre>            while (nc &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1204" href="#"></a></td>
<td><pre>                nc--;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1205" href="#"></a></td>
<td><pre>                int type = curveTypes[numCurves];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1206" href="#"></a></td>
<td><pre>                end -= (type - 2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1207" href="#"></a></td>
<td><pre>                switch(type) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1208" href="#"></a></td>
<td><pre>                case 8:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1209" href="#"></a></td>
<td><pre>                    ret += &quot;cubic: &quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1210" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1211" href="#"></a></td>
<td><pre>                case 6:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1212" href="#"></a></td>
<td><pre>                    ret += &quot;quad: &quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1213" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1214" href="#"></a></td>
<td><pre>                case 4:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1215" href="#"></a></td>
<td><pre>                    ret += &quot;line: &quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1216" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1217" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1218" href="#"></a></td>
<td><pre>                ret += Arrays.toString(Arrays.copyOfRange(curves, end, end+type-2)) + &quot;\n&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1219" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1220" href="#"></a></td>
<td><pre>            return ret;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1221" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1222" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1223" href="#"></a></td>
<td><pre>}</pre></td>
</tr>
</table>
</body>
</html>
