<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.applet;

import java.util.*;
import java.io.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.print.*;
import javax.print.attribute.*;
import java.applet.*;
import java.net.URL;
import java.net.MalformedURLException;
import java.net.SocketPermission;
import sun.misc.Ref;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import sun.awt.SunToolkit;
import sun.awt.AppContext;
import java.lang.ref.WeakReference;

/**
 * A frame to show the applet tag in.
 */
class TextFrame extends Frame {

    /**
     * Create the tag frame.
     */
    TextFrame(int x, int y, String title, String text) {
        setTitle(title);
        TextArea txt = new TextArea(20, 60);
        txt.setText(text);
        txt.setEditable(false);

        add(&quot;Center&quot;, txt);

        Panel p = new Panel();
        add(&quot;South&quot;, p);
        Button b = new Button(amh.getMessage(&quot;button.dismiss&quot;, &quot;Dismiss&quot;));
        p.add(b);

        class ActionEventListener implements ActionListener {
            public void actionPerformed(ActionEvent evt) {
                dispose();
            }
        }
        b.addActionListener(new ActionEventListener());

        pack();
        move(x, y);
        setVisible(true);

        WindowListener windowEventListener = new WindowAdapter() {

            public void windowClosing(WindowEvent evt) {
                dispose();
            }
        };

        addWindowListener(windowEventListener);
    }
    private static AppletMessageHandler amh = new AppletMessageHandler(&quot;textframe&quot;);

}

/**
 * Lets us construct one using unix-style one shot behaviors
 */

class StdAppletViewerFactory implements AppletViewerFactory
{
    public AppletViewer createAppletViewer(int x, int y,
                                           URL doc, Hashtable atts) {
        return new AppletViewer(x, y, doc, atts, System.out, this);
    }

    public MenuBar getBaseMenuBar() {
        return new MenuBar();
    }

    public boolean isStandalone() {
        return true;
    }
}

/**
 * The applet viewer makes it possible to run a Java applet without using a browser.
 * For details on the syntax that &lt;B&gt;appletviewer&lt;/B&gt; supports, see
 * &lt;a href=&quot;../../../docs/tooldocs/appletviewertags.html&quot;&gt;AppletViewer Tags&lt;/a&gt;.
 * (The document named appletviewertags.html in the JDK's docs/tooldocs directory,
 *  once the JDK docs have been installed.)
 */
public class AppletViewer extends Frame implements AppletContext,
                                                   Printable {

    /**
     * Some constants...
     */
    private static String defaultSaveFile = &quot;Applet.ser&quot;;

    /**
     * The panel in which the applet is being displayed.
     */
    AppletViewerPanel panel;

    /**
     * The status line.
     */
    Label label;

    /**
     * output status messages to this stream
     */

    PrintStream statusMsgStream;

    /**
     * For cloning
     */
    AppletViewerFactory factory;


    private final class UserActionListener implements ActionListener {
        public void actionPerformed(ActionEvent evt) {
            processUserAction(evt);
        }
    }

    /**
     * Create the applet viewer
     */
    public AppletViewer(int x, int y, URL doc, Hashtable atts,
                        PrintStream statusMsgStream, AppletViewerFactory factory) {
        this.factory = factory;
        this.statusMsgStream = statusMsgStream;
        setTitle(amh.getMessage(&quot;tool.title&quot;, atts.get(&quot;code&quot;)));

        MenuBar mb = factory.getBaseMenuBar();

        Menu m = new Menu(amh.getMessage(&quot;menu.applet&quot;));

        addMenuItem(m, &quot;menuitem.restart&quot;);
        addMenuItem(m, &quot;menuitem.reload&quot;);
        addMenuItem(m, &quot;menuitem.stop&quot;);
        addMenuItem(m, &quot;menuitem.save&quot;);
        addMenuItem(m, &quot;menuitem.start&quot;);
        addMenuItem(m, &quot;menuitem.clone&quot;);
        m.add(new MenuItem(&quot;-&quot;));
        addMenuItem(m, &quot;menuitem.tag&quot;);
        addMenuItem(m, &quot;menuitem.info&quot;);
        addMenuItem(m, &quot;menuitem.edit&quot;).disable();
        addMenuItem(m, &quot;menuitem.encoding&quot;);
        m.add(new MenuItem(&quot;-&quot;));
        addMenuItem(m, &quot;menuitem.print&quot;);
        m.add(new MenuItem(&quot;-&quot;));
        addMenuItem(m, &quot;menuitem.props&quot;);
        m.add(new MenuItem(&quot;-&quot;));
        addMenuItem(m, &quot;menuitem.close&quot;);
        if (factory.isStandalone()) {
            addMenuItem(m, &quot;menuitem.quit&quot;);
        }

        mb.add(m);

        setMenuBar(mb);

        add(&quot;Center&quot;, panel = new AppletViewerPanel(doc, atts));
        add(&quot;South&quot;, label = new Label(amh.getMessage(&quot;label.hello&quot;)));
        panel.init();
        appletPanels.addElement(panel);

        pack();
        move(x, y);
        setVisible(true);

        WindowListener windowEventListener = new WindowAdapter() {

            public void windowClosing(WindowEvent evt) {
                appletClose();
            }

            public void windowIconified(WindowEvent evt) {
                appletStop();
            }

            public void windowDeiconified(WindowEvent evt) {
                appletStart();
            }
        };

        class AppletEventListener implements AppletListener
        {
            final Frame frame;

            public AppletEventListener(Frame frame)
            {
                this.frame = frame;
            }

            public void appletStateChanged(AppletEvent evt)
            {
                AppletPanel src = (AppletPanel)evt.getSource();

                switch (evt.getID()) {
                    case AppletPanel.APPLET_RESIZE: {
                        if(src != null) {
                            resize(preferredSize());
                            validate();
                        }
                        break;
                    }
                    case AppletPanel.APPLET_LOADING_COMPLETED: {
                        Applet a = src.getApplet(); // sun.applet.AppletPanel

                        // Fixed #4754451: Applet can have methods running on main
                        // thread event queue.
                        //
                        // The cause of this bug is that the frame of the applet
                        // is created in main thread group. Thus, when certain
                        // AWT/Swing events are generated, the events will be
                        // dispatched through the wrong event dispatch thread.
                        //
                        // To fix this, we rearrange the AppContext with the frame,
                        // so the proper event queue will be looked up.
                        //
                        // Swing also maintains a Frame list for the AppContext,
                        // so we will have to rearrange it as well.
                        //
                        if (a != null)
                            AppletPanel.changeFrameAppContext(frame, SunToolkit.targetToAppContext(a));
                        else
                            AppletPanel.changeFrameAppContext(frame, AppContext.getAppContext());

                        break;
                    }
                }
            }
        };

        addWindowListener(windowEventListener);
        panel.addAppletListener(new AppletEventListener(this));

        // Start the applet
        showStatus(amh.getMessage(&quot;status.start&quot;));
        initEventQueue();
    }

    // XXX 99/9/10 probably should be &quot;private&quot;
    public MenuItem addMenuItem(Menu m, String s) {
        MenuItem mItem = new MenuItem(amh.getMessage(s));
        mItem.addActionListener(new UserActionListener());
        return m.add(mItem);
    }

    /**
     * Send the initial set of events to the appletviewer event queue.
     * On start-up the current behaviour is to load the applet and call
     * Applet.init() and Applet.start().
     */
    private void initEventQueue() {
        // appletviewer.send.event is an undocumented and unsupported system
        // property which is used exclusively for testing purposes.
        String eventList = System.getProperty(&quot;appletviewer.send.event&quot;);

        if (eventList == null) {
            // Add the standard events onto the event queue.
            panel.sendEvent(AppletPanel.APPLET_LOAD);
            panel.sendEvent(AppletPanel.APPLET_INIT);
            panel.sendEvent(AppletPanel.APPLET_START);
        } else {
            // We're testing AppletViewer.  Force the specified set of events
            // onto the event queue, wait for the events to be processed, and
            // exit.

            // The list of events that will be executed is provided as a
            // &quot;,&quot;-separated list.  No error-checking will be done on the list.
            String [] events = splitSeparator(&quot;,&quot;, eventList);

            for (int i = 0; i &lt; events.length; i++) {
                System.out.println(&quot;Adding event to queue: &quot; + events[i]);
                if (events[i].equals(&quot;dispose&quot;))
                    panel.sendEvent(AppletPanel.APPLET_DISPOSE);
                else if (events[i].equals(&quot;load&quot;))
                    panel.sendEvent(AppletPanel.APPLET_LOAD);
                else if (events[i].equals(&quot;init&quot;))
                    panel.sendEvent(AppletPanel.APPLET_INIT);
                else if (events[i].equals(&quot;start&quot;))
                    panel.sendEvent(AppletPanel.APPLET_START);
                else if (events[i].equals(&quot;stop&quot;))
                    panel.sendEvent(AppletPanel.APPLET_STOP);
                else if (events[i].equals(&quot;destroy&quot;))
                    panel.sendEvent(AppletPanel.APPLET_DESTROY);
                else if (events[i].equals(&quot;quit&quot;))
                    panel.sendEvent(AppletPanel.APPLET_QUIT);
                else if (events[i].equals(&quot;error&quot;))
                    panel.sendEvent(AppletPanel.APPLET_ERROR);
                else
                    // non-fatal error if we get an unrecognized event
                    System.out.println(&quot;Unrecognized event name: &quot; + events[i]);
            }

            while (!panel.emptyEventQueue()) ;
            appletSystemExit();
        }
    }

    /**
     * Split a string based on the presence of a specified separator.  Returns
     * an array of arbitrary length.  The end of each element in the array is
     * indicated by the separator of the end of the string.  If there is a
     * separator immediately before the end of the string, the final element
     * will be empty.  None of the strings will contain the separator.  Useful
     * when separating strings such as &quot;foo/bar/bas&quot; using separator &quot;/&quot;.
     *
     * @param sep  The separator.
     * @param s    The string to split.
     * @return     An array of strings.  Each string in the array is determined
     *             by the location of the provided sep in the original string,
     *             s.  Whitespace not stripped.
     */
    private String [] splitSeparator(String sep, String s) {
        Vector v = new Vector();
        int tokenStart = 0;
        int tokenEnd   = 0;

        while ((tokenEnd = s.indexOf(sep, tokenStart)) != -1) {
            v.addElement(s.substring(tokenStart, tokenEnd));
            tokenStart = tokenEnd+1;
        }
        // Add the final element.
        v.addElement(s.substring(tokenStart));

        String [] retVal = new String[v.size()];
        v.copyInto(retVal);
        return retVal;
    }

    /*
     * Methods for java.applet.AppletContext
     */

    private static Map audioClips = new HashMap();

    /**
     * Get an audio clip.
     */
    public AudioClip getAudioClip(URL url) {
        checkConnect(url);
        synchronized (audioClips) {
            AudioClip clip = (AudioClip)audioClips.get(url);
            if (clip == null) {
                audioClips.put(url, clip = new AppletAudioClip(url));
            }
            return clip;
        }
    }

    private static Map imageRefs = new HashMap();

    /**
     * Get an image.
     */
    public Image getImage(URL url) {
        return getCachedImage(url);
    }

    static Image getCachedImage(URL url) {
        // System.getSecurityManager().checkConnection(url.getHost(), url.getPort());
        return (Image)getCachedImageRef(url).get();
    }

    /**
     * Get an image ref.
     */
    static Ref getCachedImageRef(URL url) {
        synchronized (imageRefs) {
            AppletImageRef ref = (AppletImageRef)imageRefs.get(url);
            if (ref == null) {
                ref = new AppletImageRef(url);
                imageRefs.put(url, ref);
            }
            return ref;
        }
    }

    /**
     * Flush the image cache.
     */
    static void flushImageCache() {
        imageRefs.clear();
    }

    static Vector appletPanels = new Vector();

    /**
     * Get an applet by name.
     */
    public Applet getApplet(String name) {
        AppletSecurity security = (AppletSecurity)System.getSecurityManager();
        name = name.toLowerCase();
        SocketPermission panelSp =
            new SocketPermission(panel.getCodeBase().getHost(), &quot;connect&quot;);
        for (Enumeration e = appletPanels.elements() ; e.hasMoreElements() ;) {
            AppletPanel p = (AppletPanel)e.nextElement();
            String param = p.getParameter(&quot;name&quot;);
            if (param != null) {
                param = param.toLowerCase();
            }
            if (name.equals(param) &amp;&amp;
                p.getDocumentBase().equals(panel.getDocumentBase())) {

                SocketPermission sp =
                    new SocketPermission(p.getCodeBase().getHost(), &quot;connect&quot;);

                if (panelSp.implies(sp)) {
                    return p.applet;
                }
            }
        }
        return null;
    }

    /**
     * Return an enumeration of all the accessible
     * applets on this page.
     */
    public Enumeration getApplets() {
        AppletSecurity security = (AppletSecurity)System.getSecurityManager();
        Vector v = new Vector();
        SocketPermission panelSp =
            new SocketPermission(panel.getCodeBase().getHost(), &quot;connect&quot;);

        for (Enumeration e = appletPanels.elements() ; e.hasMoreElements() ;) {
            AppletPanel p = (AppletPanel)e.nextElement();
            if (p.getDocumentBase().equals(panel.getDocumentBase())) {

                SocketPermission sp =
                    new SocketPermission(p.getCodeBase().getHost(), &quot;connect&quot;);
                if (panelSp.implies(sp)) {
                    v.addElement(p.applet);
                }
            }
        }
        return v.elements();
    }

    /**
     * Ignore.
     */
    public void showDocument(URL url) {
    }

    /**
     * Ignore.
     */
    public void showDocument(URL url, String target) {
    }

    /**
     * Show status.
     */
    public void showStatus(String status) {
        label.setText(status);
    }

    public void setStream(String key, InputStream stream)throws IOException{
        // We do nothing.
    }

    public InputStream getStream(String key){
        // We do nothing.
        return null;
    }

    public Iterator getStreamKeys(){
        // We do nothing.
        return null;
    }

    /**
     * System parameters.
     */
    static Hashtable systemParam = new Hashtable();

    static {
        systemParam.put(&quot;codebase&quot;, &quot;codebase&quot;);
        systemParam.put(&quot;code&quot;, &quot;code&quot;);
        systemParam.put(&quot;alt&quot;, &quot;alt&quot;);
        systemParam.put(&quot;width&quot;, &quot;width&quot;);
        systemParam.put(&quot;height&quot;, &quot;height&quot;);
        systemParam.put(&quot;align&quot;, &quot;align&quot;);
        systemParam.put(&quot;vspace&quot;, &quot;vspace&quot;);
        systemParam.put(&quot;hspace&quot;, &quot;hspace&quot;);
    }

    /**
     * Print the HTML tag.
     */
    public static void printTag(PrintStream out, Hashtable atts) {
        out.print(&quot;&lt;applet&quot;);

        String v = (String)atts.get(&quot;codebase&quot;);
        if (v != null) {
            out.print(&quot; codebase=\&quot;&quot; + v + &quot;\&quot;&quot;);
        }

        v = (String)atts.get(&quot;code&quot;);
        if (v == null) {
            v = &quot;applet.class&quot;;
        }
        out.print(&quot; code=\&quot;&quot; + v + &quot;\&quot;&quot;);
        v = (String)atts.get(&quot;width&quot;);
        if (v == null) {
            v = &quot;150&quot;;
        }
        out.print(&quot; width=&quot; + v);

        v = (String)atts.get(&quot;height&quot;);
        if (v == null) {
            v = &quot;100&quot;;
        }
        out.print(&quot; height=&quot; + v);

        v = (String)atts.get(&quot;name&quot;);
        if (v != null) {
            out.print(&quot; name=\&quot;&quot; + v + &quot;\&quot;&quot;);
        }
        out.println(&quot;&gt;&quot;);

        // A very slow sorting algorithm
        int len = atts.size();
        String params[] = new String[len];
        len = 0;
        for (Enumeration e = atts.keys() ; e.hasMoreElements() ;) {
            String param = (String)e.nextElement();
            int i = 0;
            for (; i &lt; len ; i++) {
                if (params[i].compareTo(param) &gt;= 0) {
                    break;
                }
            }
            System.arraycopy(params, i, params, i + 1, len - i);
            params[i] = param;
            len++;
        }

        for (int i = 0 ; i &lt; len ; i++) {
            String param = params[i];
            if (systemParam.get(param) == null) {
                out.println(&quot;&lt;param name=&quot; + param +
                            &quot; value=\&quot;&quot; + atts.get(param) + &quot;\&quot;&gt;&quot;);
            }
        }
        out.println(&quot;&lt;/applet&gt;&quot;);
    }

    /**
     * Make sure the atrributes are uptodate.
     */
    public void updateAtts() {
        Dimension d = panel.size();
        Insets in = panel.insets();
        panel.atts.put(&quot;width&quot;,
                       Integer.toString(d.width - (in.left + in.right)));
        panel.atts.put(&quot;height&quot;,
                       Integer.toString(d.height - (in.top + in.bottom)));
    }

    /**
     * Restart the applet.
     */
    void appletRestart() {
        panel.sendEvent(AppletPanel.APPLET_STOP);
        panel.sendEvent(AppletPanel.APPLET_DESTROY);
        panel.sendEvent(AppletPanel.APPLET_INIT);
        panel.sendEvent(AppletPanel.APPLET_START);
    }

    /**
     * Reload the applet.
     */
    void appletReload() {
        panel.sendEvent(AppletPanel.APPLET_STOP);
        panel.sendEvent(AppletPanel.APPLET_DESTROY);
        panel.sendEvent(AppletPanel.APPLET_DISPOSE);

        /**
         * Fixed #4501142: Classlaoder sharing policy doesn't
         * take &quot;archive&quot; into account. This will be overridden
         * by Java Plug-in.                     [stanleyh]
         */
        AppletPanel.flushClassLoader(panel.getClassLoaderCacheKey());

        /*
         * Make sure we don't have two threads running through the event queue
         * at the same time.
         */
        try {
            panel.joinAppletThread();
            panel.release();
        } catch (InterruptedException e) {
            return;   // abort the reload
        }

        panel.createAppletThread();
        panel.sendEvent(AppletPanel.APPLET_LOAD);
        panel.sendEvent(AppletPanel.APPLET_INIT);
        panel.sendEvent(AppletPanel.APPLET_START);
    }

    /**
     * Save the applet to a well known file (for now) as a serialized object
     */
    void appletSave() {
        AccessController.doPrivileged(new PrivilegedAction() {

            public Object run() {
                // XXX: this privileged block should be made smaller
                // by initializing a private static variable with &quot;user.dir&quot;

                // Applet needs to be stopped for serialization to succeed.
                // Since panel.sendEvent only queues the event, there is a
                // chance that the event will not be processed before
                // serialization begins.  However, by sending the event before
                // FileDialog is created, enough time is given such that this
                // situation is unlikely to ever occur.

                panel.sendEvent(AppletPanel.APPLET_STOP);
                FileDialog fd = new FileDialog(AppletViewer.this,
                                               amh.getMessage(&quot;appletsave.filedialogtitle&quot;),
                                               FileDialog.SAVE);
                // needed for a bug under Solaris...
                fd.setDirectory(System.getProperty(&quot;user.dir&quot;));
                fd.setFile(defaultSaveFile);
                fd.show();
                String fname = fd.getFile();
                if (fname == null) {
                    // Restart applet if Save is cancelled.
                    panel.sendEvent(AppletPanel.APPLET_START);
                    return null;                // cancelled
                }
                String dname = fd.getDirectory();
                File file = new File(dname, fname);

                try (FileOutputStream fos = new FileOutputStream(file);
                     BufferedOutputStream bos = new BufferedOutputStream(fos);
                     ObjectOutputStream os = new ObjectOutputStream(bos)) {

                    showStatus(amh.getMessage(&quot;appletsave.err1&quot;, panel.applet.toString(), file.toString()));
                    os.writeObject(panel.applet);
                } catch (IOException ex) {
                    System.err.println(amh.getMessage(&quot;appletsave.err2&quot;, ex));
                } finally {
                    panel.sendEvent(AppletPanel.APPLET_START);
                }
                return null;
            }
        });
    }

    /**
     * Clone the viewer and the applet.
     */
    void appletClone() {
        Point p = location();
        updateAtts();
        factory.createAppletViewer(p.x + XDELTA, p.y + YDELTA,
                                   panel.documentURL, (Hashtable)panel.atts.clone());
    }

    /**
     * Show the applet tag.
     */
    void appletTag() {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        updateAtts();
        printTag(new PrintStream(out), panel.atts);
        showStatus(amh.getMessage(&quot;applettag&quot;));

        Point p = location();
        new TextFrame(p.x + XDELTA, p.y + YDELTA, amh.getMessage(&quot;applettag.textframe&quot;), out.toString());
    }

    /**
     * Show the applet info.
     */
    void appletInfo() {
        String str = panel.applet.getAppletInfo();
        if (str == null) {
            str = amh.getMessage(&quot;appletinfo.applet&quot;);
        }
        str += &quot;\n\n&quot;;

        String atts[][] = panel.applet.getParameterInfo();
        if (atts != null) {
            for (int i = 0 ; i &lt; atts.length ; i++) {
                str += atts[i][0] + &quot; -- &quot; + atts[i][1] + &quot; -- &quot; + atts[i][2] + &quot;\n&quot;;
            }
        } else {
            str += amh.getMessage(&quot;appletinfo.param&quot;);
        }

        Point p = location();
        new TextFrame(p.x + XDELTA, p.y + YDELTA, amh.getMessage(&quot;appletinfo.textframe&quot;), str);

    }

    /**
     * Show character encoding type
     */
    void appletCharacterEncoding() {
        showStatus(amh.getMessage(&quot;appletencoding&quot;, encoding));
    }

    /**
     * Edit the applet.
     */
    void appletEdit() {
    }

    /**
     * Print the applet.
     */
    void appletPrint() {
        PrinterJob pj = PrinterJob.getPrinterJob();

        if (pj != null) {
            PrintRequestAttributeSet aset = new HashPrintRequestAttributeSet();
            if (pj.printDialog(aset)) {
                pj.setPrintable(this);
                try {
                    pj.print(aset);
                    statusMsgStream.println(amh.getMessage(&quot;appletprint.finish&quot;));
                } catch (PrinterException e) {
                   statusMsgStream.println(amh.getMessage(&quot;appletprint.fail&quot;));
                }
            } else {
                statusMsgStream.println(amh.getMessage(&quot;appletprint.cancel&quot;));
            }
        } else {
            statusMsgStream.println(amh.getMessage(&quot;appletprint.fail&quot;));
        }
    }

    public int print(Graphics graphics, PageFormat pf, int pageIndex) {
        if (pageIndex &gt; 0) {
            return Printable.NO_SUCH_PAGE;
        } else {
            Graphics2D g2d = (Graphics2D)graphics;
            g2d.translate(pf.getImageableX(), pf.getImageableY());
            panel.applet.printAll(graphics);
            return Printable.PAGE_EXISTS;
        }
    }

    /**
     * Properties.
     */
    static AppletProps props;
    public static synchronized void networkProperties() {
        if (props == null) {
            props = new AppletProps();
        }
        props.addNotify();
        props.setVisible(true);
    }

    /**
     * Start the applet.
     */
    void appletStart() {
        panel.sendEvent(AppletPanel.APPLET_START);
    }

    /**
     * Stop the applet.
     */
    void appletStop() {
        panel.sendEvent(AppletPanel.APPLET_STOP);
    }

    /**
     * Shutdown a viewer.
     * Stop, Destroy, Dispose and Quit a viewer
     */
    private void appletShutdown(AppletPanel p) {
        p.sendEvent(AppletPanel.APPLET_STOP);
        p.sendEvent(AppletPanel.APPLET_DESTROY);
        p.sendEvent(AppletPanel.APPLET_DISPOSE);
        p.sendEvent(AppletPanel.APPLET_QUIT);
    }

    /**
     * Close this viewer.
     * Stop, Destroy, Dispose and Quit an AppletView, then
     * reclaim resources and exit the program if this is
     * the last applet.
     */
    void appletClose() {

        // The caller thread is event dispatch thread, so
        // spawn a new thread to avoid blocking the event queue
        // when calling appletShutdown.
        //
        final AppletPanel p = panel;

        new Thread(new Runnable()
        {
            public void run()
            {
                appletShutdown(p);
                appletPanels.removeElement(p);
                dispose();

                if (countApplets() == 0) {
                    appletSystemExit();
                }
            }
        }).start();
    }

    /**
     * Exit the program.
     * Exit from the program (if not stand alone) - do no clean-up
     */
    private void appletSystemExit() {
        if (factory.isStandalone())
            System.exit(0);
    }

    /**
     * Quit all viewers.
     * Shutdown all viewers properly then
     * exit from the program (if not stand alone)
     */
    protected void appletQuit()
    {
        // The caller thread is event dispatch thread, so
        // spawn a new thread to avoid blocking the event queue
        // when calling appletShutdown.
        //
        new Thread(new Runnable()
        {
            public void run()
            {
                for (Enumeration e = appletPanels.elements() ; e.hasMoreElements() ;) {
                    AppletPanel p = (AppletPanel)e.nextElement();
                    appletShutdown(p);
                }
                appletSystemExit();
            }
        }).start();
    }

    /**
     * Handle events.
     */
    public void processUserAction(ActionEvent evt) {

        String label = ((MenuItem)evt.getSource()).getLabel();

        if (amh.getMessage(&quot;menuitem.restart&quot;).equals(label)) {
            appletRestart();
            return;
        }

        if (amh.getMessage(&quot;menuitem.reload&quot;).equals(label)) {
            appletReload();
            return;
        }

        if (amh.getMessage(&quot;menuitem.clone&quot;).equals(label)) {
            appletClone();
            return;
        }

        if (amh.getMessage(&quot;menuitem.stop&quot;).equals(label)) {
            appletStop();
            return;
        }

        if (amh.getMessage(&quot;menuitem.save&quot;).equals(label)) {
            appletSave();
            return;
        }

        if (amh.getMessage(&quot;menuitem.start&quot;).equals(label)) {
            appletStart();
            return;
        }

        if (amh.getMessage(&quot;menuitem.tag&quot;).equals(label)) {
            appletTag();
            return;
        }

        if (amh.getMessage(&quot;menuitem.info&quot;).equals(label)) {
            appletInfo();
            return;
        }

        if (amh.getMessage(&quot;menuitem.encoding&quot;).equals(label)) {
            appletCharacterEncoding();
            return;
        }

        if (amh.getMessage(&quot;menuitem.edit&quot;).equals(label)) {
            appletEdit();
            return;
        }

        if (amh.getMessage(&quot;menuitem.print&quot;).equals(label)) {
            appletPrint();
            return;
        }

        if (amh.getMessage(&quot;menuitem.props&quot;).equals(label)) {
            networkProperties();
            return;
        }

        if (amh.getMessage(&quot;menuitem.close&quot;).equals(label)) {
            appletClose();
            return;
        }

        if (factory.isStandalone() &amp;&amp; amh.getMessage(&quot;menuitem.quit&quot;).equals(label)) {
            appletQuit();
            return;
        }
        //statusMsgStream.println(&quot;evt = &quot; + evt);
    }

    /**
     * How many applets are running?
     */

    public static int countApplets() {
        return appletPanels.size();
    }


    /**
     * The current character.
     */
    static int c;

    /**
     * Scan spaces.
     */
    public static void skipSpace(Reader in) throws IOException {
        while ((c &gt;= 0) &amp;&amp;
               ((c == ' ') || (c == '\t') || (c == '\n') || (c == '\r'))) {
            c = in.read();
        }
    }

    /**
     * Scan identifier
     */
    public static String scanIdentifier(Reader in) throws IOException {
        StringBuffer buf = new StringBuffer();
        while (true) {
            if (((c &gt;= 'a') &amp;&amp; (c &lt;= 'z')) ||
                ((c &gt;= 'A') &amp;&amp; (c &lt;= 'Z')) ||
                ((c &gt;= '0') &amp;&amp; (c &lt;= '9')) || (c == '_')) {
                buf.append((char)c);
                c = in.read();
            } else {
                return buf.toString();
            }
        }
    }

    /**
     * Scan tag
     */
    public static Hashtable scanTag(Reader in) throws IOException {
        Hashtable atts = new Hashtable();
        skipSpace(in);
        while (c &gt;= 0 &amp;&amp; c != '&gt;') {
            String att = scanIdentifier(in);
            String val = &quot;&quot;;
            skipSpace(in);
            if (c == '=') {
                int quote = -1;
                c = in.read();
                skipSpace(in);
                if ((c == '\'') || (c == '\&quot;')) {
                    quote = c;
                    c = in.read();
                }
                StringBuffer buf = new StringBuffer();
                while ((c &gt; 0) &amp;&amp;
                       (((quote &lt; 0) &amp;&amp; (c != ' ') &amp;&amp; (c != '\t') &amp;&amp;
                         (c != '\n') &amp;&amp; (c != '\r') &amp;&amp; (c != '&gt;'))
                        || ((quote &gt;= 0) &amp;&amp; (c != quote)))) {
                    buf.append((char)c);
                    c = in.read();
                }
                if (c == quote) {
                    c = in.read();
                }
                skipSpace(in);
                val = buf.toString();
            }
            //statusMsgStream.println(&quot;PUT &quot; + att + &quot; = '&quot; + val + &quot;'&quot;);
            if (! val.equals(&quot;&quot;)) {
                atts.put(att.toLowerCase(java.util.Locale.ENGLISH), val);
            }
            while (true) {
                if ((c == '&gt;') || (c &lt; 0) ||
                    ((c &gt;= 'a') &amp;&amp; (c &lt;= 'z')) ||
                    ((c &gt;= 'A') &amp;&amp; (c &lt;= 'Z')) ||
                    ((c &gt;= '0') &amp;&amp; (c &lt;= '9')) || (c == '_'))
                    break;
                c = in.read();
            }
            //skipSpace(in);
        }
        return atts;
    }

    /* values used for placement of AppletViewer's frames */
    private static int x = 0;
    private static int y = 0;
    private static final int XDELTA = 30;
    private static final int YDELTA = XDELTA;

    static String encoding = null;

    static private Reader makeReader(InputStream is) {
        if (encoding != null) {
            try {
                return new BufferedReader(new InputStreamReader(is, encoding));
            } catch (IOException x) { }
        }
        InputStreamReader r = new InputStreamReader(is);
        encoding = r.getEncoding();
        return new BufferedReader(r);
    }

    /**
     * Scan an html file for &lt;applet&gt; tags
     */
    public static void parse(URL url, String enc) throws IOException {
        encoding = enc;
        parse(url, System.out, new StdAppletViewerFactory());
    }

    public static void parse(URL url) throws IOException {
        parse(url, System.out, new StdAppletViewerFactory());
    }

    public static void parse(URL url, PrintStream statusMsgStream,
                             AppletViewerFactory factory) throws IOException {
        // &lt;OBJECT&gt; &lt;EMBED&gt; tag flags
        boolean isAppletTag = false;
        boolean isObjectTag = false;
        boolean isEmbedTag = false;

        // warning messages
        String requiresNameWarning = amh.getMessage(&quot;parse.warning.requiresname&quot;);
        String paramOutsideWarning = amh.getMessage(&quot;parse.warning.paramoutside&quot;);
        String appletRequiresCodeWarning = amh.getMessage(&quot;parse.warning.applet.requirescode&quot;);
        String appletRequiresHeightWarning = amh.getMessage(&quot;parse.warning.applet.requiresheight&quot;);
        String appletRequiresWidthWarning = amh.getMessage(&quot;parse.warning.applet.requireswidth&quot;);
        String objectRequiresCodeWarning = amh.getMessage(&quot;parse.warning.object.requirescode&quot;);
        String objectRequiresHeightWarning = amh.getMessage(&quot;parse.warning.object.requiresheight&quot;);
        String objectRequiresWidthWarning = amh.getMessage(&quot;parse.warning.object.requireswidth&quot;);
        String embedRequiresCodeWarning = amh.getMessage(&quot;parse.warning.embed.requirescode&quot;);
        String embedRequiresHeightWarning = amh.getMessage(&quot;parse.warning.embed.requiresheight&quot;);
        String embedRequiresWidthWarning = amh.getMessage(&quot;parse.warning.embed.requireswidth&quot;);
        String appNotLongerSupportedWarning = amh.getMessage(&quot;parse.warning.appnotLongersupported&quot;);

        java.net.URLConnection conn = url.openConnection();
        Reader in = makeReader(conn.getInputStream());
        /* The original URL may have been redirected - this
         * sets it to whatever URL/codebase we ended up getting
         */
        url = conn.getURL();

        int ydisp = 1;
        Hashtable atts = null;

        while(true) {
            c = in.read();
            if (c == -1)
                break;

            if (c == '&lt;') {
                c = in.read();
                if (c == '/') {
                    c = in.read();
                    String nm = scanIdentifier(in);
                    if (nm.equalsIgnoreCase(&quot;applet&quot;) ||
                        nm.equalsIgnoreCase(&quot;object&quot;) ||
                        nm.equalsIgnoreCase(&quot;embed&quot;)) {

                        // We can't test for a code tag until &lt;/OBJECT&gt;
                        // because it is a parameter, not an attribute.
                        if(isObjectTag) {
                            if (atts.get(&quot;code&quot;) == null &amp;&amp; atts.get(&quot;object&quot;) == null) {
                                statusMsgStream.println(objectRequiresCodeWarning);
                                atts = null;
                            }
                        }

                        if (atts != null) {
                            // XXX 5/18 In general this code just simply
                            // shouldn't be part of parsing.  It's presence
                            // causes things to be a little too much of a
                            // hack.
                            factory.createAppletViewer(x, y, url, atts);
                            x += XDELTA;
                            y += YDELTA;
                            // make sure we don't go too far!
                            Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
                            if ((x &gt; d.width - 300) || (y &gt; d.height - 300)) {
                                x = 0;
                                y = 2 * ydisp * YDELTA;
                                ydisp++;
                            }
                        }
                        atts = null;
                        isAppletTag = false;
                        isObjectTag = false;
                        isEmbedTag = false;
                    }
                }
                else {
                    String nm = scanIdentifier(in);
                    if (nm.equalsIgnoreCase(&quot;param&quot;)) {
                        Hashtable t = scanTag(in);
                        String att = (String)t.get(&quot;name&quot;);
                        if (att == null) {
                            statusMsgStream.println(requiresNameWarning);
                        } else {
                            String val = (String)t.get(&quot;value&quot;);
                            if (val == null) {
                                statusMsgStream.println(requiresNameWarning);
                            } else if (atts != null) {
                                atts.put(att.toLowerCase(), val);
                            } else {
                                statusMsgStream.println(paramOutsideWarning);
                            }
                        }
                    }
                    else if (nm.equalsIgnoreCase(&quot;applet&quot;)) {
                        isAppletTag = true;
                        atts = scanTag(in);
                        if (atts.get(&quot;code&quot;) == null &amp;&amp; atts.get(&quot;object&quot;) == null) {
                            statusMsgStream.println(appletRequiresCodeWarning);
                            atts = null;
                        } else if (atts.get(&quot;width&quot;) == null) {
                            statusMsgStream.println(appletRequiresWidthWarning);
                            atts = null;
                        } else if (atts.get(&quot;height&quot;) == null) {
                            statusMsgStream.println(appletRequiresHeightWarning);
                            atts = null;
                        }
                    }
                    else if (nm.equalsIgnoreCase(&quot;object&quot;)) {
                        isObjectTag = true;
                        atts = scanTag(in);
                        // The &lt;OBJECT&gt; attribute codebase isn't what
                        // we want. If its defined, remove it.
                        if(atts.get(&quot;codebase&quot;) != null) {
                            atts.remove(&quot;codebase&quot;);
                        }

                        if (atts.get(&quot;width&quot;) == null) {
                            statusMsgStream.println(objectRequiresWidthWarning);
                            atts = null;
                        } else if (atts.get(&quot;height&quot;) == null) {
                            statusMsgStream.println(objectRequiresHeightWarning);
                            atts = null;
                        }
                    }
                    else if (nm.equalsIgnoreCase(&quot;embed&quot;)) {
                        isEmbedTag = true;
                        atts = scanTag(in);

                        if (atts.get(&quot;code&quot;) == null &amp;&amp; atts.get(&quot;object&quot;) == null) {
                            statusMsgStream.println(embedRequiresCodeWarning);
                            atts = null;
                        } else if (atts.get(&quot;width&quot;) == null) {
                            statusMsgStream.println(embedRequiresWidthWarning);
                            atts = null;
                        } else if (atts.get(&quot;height&quot;) == null) {
                            statusMsgStream.println(embedRequiresHeightWarning);
                            atts = null;
                        }
                    }
                    else if (nm.equalsIgnoreCase(&quot;app&quot;)) {
                        statusMsgStream.println(appNotLongerSupportedWarning);
                        Hashtable atts2 = scanTag(in);
                        nm = (String)atts2.get(&quot;class&quot;);
                        if (nm != null) {
                            atts2.remove(&quot;class&quot;);
                            atts2.put(&quot;code&quot;, nm + &quot;.class&quot;);
                        }
                        nm = (String)atts2.get(&quot;src&quot;);
                        if (nm != null) {
                            atts2.remove(&quot;src&quot;);
                            atts2.put(&quot;codebase&quot;, nm);
                        }
                        if (atts2.get(&quot;width&quot;) == null) {
                            atts2.put(&quot;width&quot;, &quot;100&quot;);
                        }
                        if (atts2.get(&quot;height&quot;) == null) {
                            atts2.put(&quot;height&quot;, &quot;100&quot;);
                        }
                        printTag(statusMsgStream, atts2);
                        statusMsgStream.println();
                    }
                }
            }
        }
        in.close();
    }

    /**
     * Old main entry point.
     *
     * @deprecated
     */
    @Deprecated
    public static void main(String argv[]) {
        // re-route everything to the new main entry point
        Main.main(argv);
    }

    private static AppletMessageHandler amh = new AppletMessageHandler(&quot;appletviewer&quot;);

    private static void checkConnect(URL url)
    {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            try {
                java.security.Permission perm =
                    url.openConnection().getPermission();
                if (perm != null)
                    security.checkPermission(perm);
                else
                    security.checkConnect(url.getHost(), url.getPort());
            } catch (java.io.IOException ioe) {
                    security.checkConnect(url.getHost(), url.getPort());
            }
        }
    }
}
</pre>
</body>
</html>
