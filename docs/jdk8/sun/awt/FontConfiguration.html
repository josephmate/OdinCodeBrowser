<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt;

import java.awt.Font;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Locale;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.Vector;
import sun.font.CompositeFontDescriptor;
import sun.font.SunFontManager;
import sun.font.FontManagerFactory;
import sun.font.FontUtilities;
import sun.util.logging.PlatformLogger;

/**
 * Provides the definitions of the five logical fonts: Serif, SansSerif,
 * Monospaced, Dialog, and DialogInput. The necessary information
 * is obtained from fontconfig files.
 */
public abstract class FontConfiguration {

    //static global runtime env
    protected static String osVersion;
    protected static String osName;
    protected static String encoding; // canonical name of default nio charset
    protected static Locale startupLocale = null;
    protected static Hashtable localeMap = null;
    private static FontConfiguration fontConfig;
    private static PlatformLogger logger;
    protected static boolean isProperties = true;

    protected SunFontManager fontManager;
    protected boolean preferLocaleFonts;
    protected boolean preferPropFonts;

    private File fontConfigFile;
    private boolean foundOsSpecificFile;
    private boolean inited;
    private String javaLib;

    /* A default FontConfiguration must be created before an alternate
     * one to ensure proper static initialisation takes place.
     */
    public FontConfiguration(SunFontManager fm) {
        if (FontUtilities.debugFonts()) {
            FontUtilities.getLogger()
                .info(&quot;Creating standard Font Configuration&quot;);
        }
        if (FontUtilities.debugFonts() &amp;&amp; logger == null) {
            logger = PlatformLogger.getLogger(&quot;sun.awt.FontConfiguration&quot;);
        }
        fontManager = fm;
        setOsNameAndVersion();  /* static initialization */
        setEncoding();          /* static initialization */
        /* Separating out the file location from the rest of the
         * initialisation, so the caller has the option of doing
         * something else if a suitable file isn't found.
         */
        findFontConfigFile();
    }

    public synchronized boolean init() {
        if (!inited) {
            this.preferLocaleFonts = false;
            this.preferPropFonts = false;
            setFontConfiguration();
            readFontConfigFile(fontConfigFile);
            initFontConfig();
            inited = true;
        }
        return true;
    }

    public FontConfiguration(SunFontManager fm,
                             boolean preferLocaleFonts,
                             boolean preferPropFonts) {
        fontManager = fm;
        if (FontUtilities.debugFonts()) {
            FontUtilities.getLogger()
                .info(&quot;Creating alternate Font Configuration&quot;);
        }
        this.preferLocaleFonts = preferLocaleFonts;
        this.preferPropFonts = preferPropFonts;
        /* fontConfig should be initialised by default constructor, and
         * its data tables can be shared, since readFontConfigFile doesn't
         * update any other state. Also avoid a doPrivileged block.
         */
        initFontConfig();
    }

    /**
     * Fills in this instance's osVersion and osName members. By
     * default uses the system properties os.name and os.version;
     * subclasses may override.
     */
    protected void setOsNameAndVersion() {
        osName = System.getProperty(&quot;os.name&quot;);
        osVersion = System.getProperty(&quot;os.version&quot;);
    }

    private void setEncoding() {
        encoding = Charset.defaultCharset().name();
        startupLocale = SunToolkit.getStartupLocale();
    }

    /////////////////////////////////////////////////////////////////////
    // methods for loading the FontConfig file                         //
    /////////////////////////////////////////////////////////////////////

    public boolean foundOsSpecificFile() {
        return foundOsSpecificFile;
    }

    /* Smoke test to see if we can trust this configuration by testing if
     * the first slot of a composite font maps to an installed file.
     */
    public boolean fontFilesArePresent() {
        init();
        short fontNameID = compFontNameIDs[0][0][0];
        short fileNameID = getComponentFileID(fontNameID);
        final String fileName = mapFileName(getComponentFileName(fileNameID));
        Boolean exists = (Boolean)java.security.AccessController.doPrivileged(
            new java.security.PrivilegedAction() {
                 public Object run() {
                     try {
                         File f = new File(fileName);
                         return Boolean.valueOf(f.exists());
                     }
                     catch (Exception e) {
                         return false;
                     }
                 }
                });
        return exists.booleanValue();
    }

    private void findFontConfigFile() {

        foundOsSpecificFile = true; // default assumption.
        String javaHome = System.getProperty(&quot;java.home&quot;);
        if (javaHome == null) {
            throw new Error(&quot;java.home property not set&quot;);
        }
        javaLib = javaHome + File.separator + &quot;lib&quot;;
        String userConfigFile = System.getProperty(&quot;sun.awt.fontconfig&quot;);
        if (userConfigFile != null) {
            fontConfigFile = new File(userConfigFile);
        } else {
            fontConfigFile = findFontConfigFile(javaLib);
        }
    }

    private void readFontConfigFile(File f) {
        /* This is invoked here as readFontConfigFile is only invoked
         * once per VM, and always in a privileged context, thus the
         * directory containing installed fall back fonts is accessed
         * from this context
         */
        getInstalledFallbackFonts(javaLib);

        if (f != null) {
            try {
                FileInputStream in = new FileInputStream(f.getPath());
                if (isProperties) {
                    loadProperties(in);
                } else {
                    loadBinary(in);
                }
                in.close();
                if (FontUtilities.debugFonts()) {
                    logger.config(&quot;Read logical font configuration from &quot; + f);
                }
            } catch (IOException e) {
                if (FontUtilities.debugFonts()) {
                    logger.config(&quot;Failed to read logical font configuration from &quot; + f);
                }
            }
        }
        String version = getVersion();
        if (!&quot;1&quot;.equals(version) &amp;&amp; FontUtilities.debugFonts()) {
            logger.config(&quot;Unsupported fontconfig version: &quot; + version);
        }
    }

    protected void getInstalledFallbackFonts(String javaLib) {
        String fallbackDirName = javaLib + File.separator +
            &quot;fonts&quot; + File.separator + &quot;fallback&quot;;

        File fallbackDir = new File(fallbackDirName);
        if (fallbackDir.exists() &amp;&amp; fallbackDir.isDirectory()) {
            String[] ttfs = fallbackDir.list(fontManager.getTrueTypeFilter());
            String[] t1s = fallbackDir.list(fontManager.getType1Filter());
            int numTTFs = (ttfs == null) ? 0 : ttfs.length;
            int numT1s = (t1s == null) ? 0 : t1s.length;
            int len = numTTFs + numT1s;
            if (numTTFs + numT1s == 0) {
                return;
            }
            installedFallbackFontFiles = new String[len];
            for (int i=0; i&lt;numTTFs; i++) {
                installedFallbackFontFiles[i] =
                    fallbackDir + File.separator + ttfs[i];
            }
            for (int i=0; i&lt;numT1s; i++) {
                installedFallbackFontFiles[i+numTTFs] =
                    fallbackDir + File.separator + t1s[i];
            }
            fontManager.registerFontsInDir(fallbackDirName);
        }
    }

    private File findImpl(String fname) {
        File f = new File(fname + &quot;.properties&quot;);
        if (f.canRead()) {
            isProperties = true;
            return f;
        }
        f = new File(fname + &quot;.bfc&quot;);
        if (f.canRead()) {
            isProperties = false;
            return f;
        }
        return null;
    }

    private File findFontConfigFile(String javaLib) {
        String baseName = javaLib + File.separator + &quot;fontconfig&quot;;
        File configFile;
        String osMajorVersion = null;
        if (osVersion != null &amp;&amp; osName != null) {
            configFile = findImpl(baseName + &quot;.&quot; + osName + &quot;.&quot; + osVersion);
            if (configFile != null) {
                return configFile;
            }
            int decimalPointIndex = osVersion.indexOf(&quot;.&quot;);
            if (decimalPointIndex != -1) {
                osMajorVersion = osVersion.substring(0, osVersion.indexOf(&quot;.&quot;));
                configFile = findImpl(baseName + &quot;.&quot; + osName + &quot;.&quot; + osMajorVersion);
                if (configFile != null) {
                    return configFile;
                }
            }
        }
        if (osName != null) {
            configFile = findImpl(baseName + &quot;.&quot; + osName);
            if (configFile != null) {
                return configFile;
            }
        }
        if (osVersion != null) {
            configFile = findImpl(baseName + &quot;.&quot; + osVersion);
            if (configFile != null) {
                return configFile;
            }
            if (osMajorVersion != null) {
                configFile = findImpl(baseName + &quot;.&quot; + osMajorVersion);
                if (configFile != null) {
                    return configFile;
                }
            }
        }
        foundOsSpecificFile = false;

        configFile = findImpl(baseName);
        if (configFile != null) {
            return configFile;
        }
        return null;
    }

    /* Initialize the internal data tables from binary format font
     * configuration file.
     */
    public static void loadBinary(InputStream inStream) throws IOException {
        DataInputStream in = new DataInputStream(inStream);
        head = readShortTable(in, HEAD_LENGTH);
        int[] tableSizes = new int[INDEX_TABLEEND];
        for (int i = 0; i &lt; INDEX_TABLEEND; i++) {
            tableSizes[i] = head[i + 1] - head[i];
        }
        table_scriptIDs       = readShortTable(in, tableSizes[INDEX_scriptIDs]);
        table_scriptFonts     = readShortTable(in, tableSizes[INDEX_scriptFonts]);
        table_elcIDs          = readShortTable(in, tableSizes[INDEX_elcIDs]);
        table_sequences        = readShortTable(in, tableSizes[INDEX_sequences]);
        table_fontfileNameIDs = readShortTable(in, tableSizes[INDEX_fontfileNameIDs]);
        table_componentFontNameIDs = readShortTable(in, tableSizes[INDEX_componentFontNameIDs]);
        table_filenames       = readShortTable(in, tableSizes[INDEX_filenames]);
        table_awtfontpaths    = readShortTable(in, tableSizes[INDEX_awtfontpaths]);
        table_exclusions      = readShortTable(in, tableSizes[INDEX_exclusions]);
        table_proportionals   = readShortTable(in, tableSizes[INDEX_proportionals]);
        table_scriptFontsMotif   = readShortTable(in, tableSizes[INDEX_scriptFontsMotif]);
        table_alphabeticSuffix   = readShortTable(in, tableSizes[INDEX_alphabeticSuffix]);
        table_stringIDs       = readShortTable(in, tableSizes[INDEX_stringIDs]);

        //StringTable cache
        stringCache = new String[table_stringIDs.length + 1];

        int len = tableSizes[INDEX_stringTable];
        byte[] bb = new byte[len * 2];
        table_stringTable = new char[len];
        in.read(bb);
        int i = 0, j = 0;
        while (i &lt; len) {
           table_stringTable[i++] = (char)(bb[j++] &lt;&lt; 8 | (bb[j++] &amp; 0xff));
        }
        if (verbose) {
            dump();
        }
    }

    /* Generate a binary format font configuration from internal data
     * tables.
     */
    public static void saveBinary(OutputStream out) throws IOException {
        sanityCheck();

        DataOutputStream dataOut = new DataOutputStream(out);
        writeShortTable(dataOut, head);
        writeShortTable(dataOut, table_scriptIDs);
        writeShortTable(dataOut, table_scriptFonts);
        writeShortTable(dataOut, table_elcIDs);
        writeShortTable(dataOut, table_sequences);
        writeShortTable(dataOut, table_fontfileNameIDs);
        writeShortTable(dataOut, table_componentFontNameIDs);
        writeShortTable(dataOut, table_filenames);
        writeShortTable(dataOut, table_awtfontpaths);
        writeShortTable(dataOut, table_exclusions);
        writeShortTable(dataOut, table_proportionals);
        writeShortTable(dataOut, table_scriptFontsMotif);
        writeShortTable(dataOut, table_alphabeticSuffix);
        writeShortTable(dataOut, table_stringIDs);
        //stringTable
        dataOut.writeChars(new String(table_stringTable));
        out.close();
        if (verbose) {
            dump();
        }
    }

    //private static boolean loadingProperties;
    private static short stringIDNum;
    private static short[] stringIDs;
    private static StringBuilder stringTable;

    public static void loadProperties(InputStream in) throws IOException {
        //loadingProperties = true;
        //StringID starts from &quot;1&quot;, &quot;0&quot; is reserved for &quot;not defined&quot;
        stringIDNum = 1;
        stringIDs = new short[1000];
        stringTable = new StringBuilder(4096);

        if (verbose &amp;&amp; logger == null) {
            logger = PlatformLogger.getLogger(&quot;sun.awt.FontConfiguration&quot;);
        }
        new PropertiesHandler().load(in);

        //loadingProperties = false;
        stringIDs = null;
        stringTable = null;
    }


    /////////////////////////////////////////////////////////////////////
    // methods for initializing the FontConfig                         //
    /////////////////////////////////////////////////////////////////////

    /**
     *  set initLocale, initEncoding and initELC for this FontConfig object
     *  currently we just simply use the startup locale and encoding
     */
    private void initFontConfig() {
        initLocale = startupLocale;
        initEncoding = encoding;
        if (preferLocaleFonts &amp;&amp; !willReorderForStartupLocale()) {
            preferLocaleFonts = false;
        }
        initELC = getInitELC();
        initAllComponentFonts();
    }

    //&quot;ELC&quot; stands for &quot;Encoding.Language.Country&quot;. This method returns
    //the ID of the matched elc setting of &quot;initLocale&quot; in elcIDs table.
    //If no match is found, it returns the default ID, which is
    //&quot;NULL.NULL.NULL&quot; in elcIDs table.
    private short getInitELC() {
        if (initELC != -1) {
            return initELC;
        }
        HashMap &lt;String, Integer&gt; elcIDs = new HashMap&lt;String, Integer&gt;();
        for (int i = 0; i &lt; table_elcIDs.length; i++) {
            elcIDs.put(getString(table_elcIDs[i]), i);
        }
        String language = initLocale.getLanguage();
        String country = initLocale.getCountry();
        String elc;
        if (elcIDs.containsKey(elc=initEncoding + &quot;.&quot; + language + &quot;.&quot; + country)
            || elcIDs.containsKey(elc=initEncoding + &quot;.&quot; + language)
            || elcIDs.containsKey(elc=initEncoding)) {
            initELC = elcIDs.get(elc).shortValue();
        } else {
            initELC = elcIDs.get(&quot;NULL.NULL.NULL&quot;).shortValue();
        }
        int i = 0;
        while (i &lt; table_alphabeticSuffix.length) {
            if (initELC == table_alphabeticSuffix[i]) {
                alphabeticSuffix = getString(table_alphabeticSuffix[i + 1]);
                return initELC;
            }
            i += 2;
        }
        return initELC;
    }

    public static boolean verbose;
    private short    initELC = -1;
    private Locale   initLocale;
    private String   initEncoding;
    private String   alphabeticSuffix;

    private short[][][] compFontNameIDs = new short[NUM_FONTS][NUM_STYLES][];
    private int[][][] compExclusions = new int[NUM_FONTS][][];
    private int[] compCoreNum = new int[NUM_FONTS];

    private Set&lt;Short&gt; coreFontNameIDs = new HashSet&lt;Short&gt;();
    private Set&lt;Short&gt; fallbackFontNameIDs = new HashSet&lt;Short&gt;();

    private void initAllComponentFonts() {
        short[] fallbackScripts = getFallbackScripts();
        for (int fontIndex = 0; fontIndex &lt; NUM_FONTS; fontIndex++) {
            short[] coreScripts = getCoreScripts(fontIndex);
            compCoreNum[fontIndex] = coreScripts.length;
            /*
            System.out.println(&quot;coreScriptID=&quot; + table_sequences[initELC * 5 + fontIndex]);
            for (int i = 0; i &lt; coreScripts.length; i++) {
            System.out.println(&quot;  &quot; + i + &quot; :&quot; + getString(table_scriptIDs[coreScripts[i]]));
            }
            */
            //init exclusionRanges
            int[][] exclusions = new int[coreScripts.length][];
            for (int i = 0; i &lt; coreScripts.length; i++) {
                exclusions[i] = getExclusionRanges(coreScripts[i]);
            }
            compExclusions[fontIndex] = exclusions;
            //init componentFontNames
            for (int styleIndex = 0; styleIndex &lt; NUM_STYLES; styleIndex++) {
                int index;
                short[] nameIDs = new short[coreScripts.length + fallbackScripts.length];
                //core
                for (index = 0; index &lt; coreScripts.length; index++) {
                    nameIDs[index] = getComponentFontID(coreScripts[index],
                                               fontIndex, styleIndex);
                    if (preferLocaleFonts &amp;&amp; localeMap != null &amp;&amp;
                            fontManager.usingAlternateFontforJALocales()) {
                        nameIDs[index] = remapLocaleMap(fontIndex, styleIndex,
                                                        coreScripts[index], nameIDs[index]);
                    }
                    if (preferPropFonts) {
                        nameIDs[index] = remapProportional(fontIndex, nameIDs[index]);
                    }
                    //System.out.println(&quot;nameid=&quot; + nameIDs[index]);
                    coreFontNameIDs.add(nameIDs[index]);
                }
                //fallback
                for (int i = 0; i &lt; fallbackScripts.length; i++) {
                    short id = getComponentFontID(fallbackScripts[i],
                                               fontIndex, styleIndex);
                    if (preferLocaleFonts &amp;&amp; localeMap != null &amp;&amp;
                            fontManager.usingAlternateFontforJALocales()) {
                        id = remapLocaleMap(fontIndex, styleIndex, fallbackScripts[i], id);
                    }
                    if (preferPropFonts) {
                        id = remapProportional(fontIndex, id);
                    }
                    if (contains(nameIDs, id, index)) {
                        continue;
                    }
                    /*
                      System.out.println(&quot;fontIndex=&quot; + fontIndex + &quot;, styleIndex=&quot; + styleIndex
                           + &quot;, fbIndex=&quot; + i + &quot;,fbS=&quot; + fallbackScripts[i] + &quot;, id=&quot; + id);
                    */
                    fallbackFontNameIDs.add(id);
                    nameIDs[index++] = id;
                }
                if (index &lt; nameIDs.length) {
                    short[] newNameIDs = new short[index];
                    System.arraycopy(nameIDs, 0, newNameIDs, 0, index);
                    nameIDs = newNameIDs;
                }
                compFontNameIDs[fontIndex][styleIndex] = nameIDs;
            }
        }
   }

   private short remapLocaleMap(int fontIndex, int styleIndex, short scriptID, short fontID) {
        String scriptName = getString(table_scriptIDs[scriptID]);

        String value = (String)localeMap.get(scriptName);
        if (value == null) {
            String fontName = fontNames[fontIndex];
            String styleName = styleNames[styleIndex];
            value = (String)localeMap.get(fontName + &quot;.&quot; + styleName + &quot;.&quot; + scriptName);
        }
        if (value == null) {
            return fontID;
        }

        for (int i = 0; i &lt; table_componentFontNameIDs.length; i++) {
            String name = getString(table_componentFontNameIDs[i]);
            if (value.equalsIgnoreCase(name)) {
                fontID = (short)i;
                break;
            }
        }
        return fontID;
    }

    public static boolean hasMonoToPropMap() {
        return table_proportionals != null &amp;&amp; table_proportionals.length != 0;
    }

    private short remapProportional(int fontIndex, short id) {
    if (preferPropFonts &amp;&amp;
        table_proportionals.length != 0 &amp;&amp;
        fontIndex != 2 &amp;&amp;         //&quot;monospaced&quot;
        fontIndex != 4) {         //&quot;dialoginput&quot;
            int i = 0;
            while (i &lt; table_proportionals.length) {
                if (table_proportionals[i] == id) {
                    return table_proportionals[i + 1];
                }
                i += 2;
            }
        }
        return id;
    }

    /////////////////////////////////////////////////////////////////////
    // Methods for handling font and style names                       //
    /////////////////////////////////////////////////////////////////////
    protected static final int NUM_FONTS = 5;
    protected static final int NUM_STYLES = 4;
    protected static final String[] fontNames
            = {&quot;serif&quot;, &quot;sansserif&quot;, &quot;monospaced&quot;, &quot;dialog&quot;, &quot;dialoginput&quot;};
    protected static final String[] publicFontNames
            = {Font.SERIF, Font.SANS_SERIF, Font.MONOSPACED, Font.DIALOG,
               Font.DIALOG_INPUT};
    protected static final String[] styleNames
            = {&quot;plain&quot;, &quot;bold&quot;, &quot;italic&quot;, &quot;bolditalic&quot;};

    /**
     * Checks whether the given font family name is a valid logical font name.
     * The check is case insensitive.
     */
    public static boolean isLogicalFontFamilyName(String fontName) {
        return isLogicalFontFamilyNameLC(fontName.toLowerCase(Locale.ENGLISH));
    }

    /**
     * Checks whether the given font family name is a valid logical font name.
     * The check is case sensitive.
     */
    public static boolean isLogicalFontFamilyNameLC(String fontName) {
        for (int i = 0; i &lt; fontNames.length; i++) {
            if (fontName.equals(fontNames[i])) {
                return true;
            }
        }
        return false;
    }

    /**
     * Checks whether the given style name is a valid logical font style name.
     */
    private static boolean isLogicalFontStyleName(String styleName) {
        for (int i = 0; i &lt; styleNames.length; i++) {
            if (styleName.equals(styleNames[i])) {
                return true;
            }
        }
        return false;
    }

    /**
     * Checks whether the given font face name is a valid logical font name.
     * The check is case insensitive.
     */
    public static boolean isLogicalFontFaceName(String fontName) {
        return isLogicalFontFaceNameLC(fontName.toLowerCase(Locale.ENGLISH));
    }

   /**
    * Checks whether the given font face name is a valid logical font name.
    * The check is case sensitive.
    */
    public static boolean isLogicalFontFaceNameLC(String fontName) {
        int period = fontName.indexOf('.');
        if (period &gt;= 0) {
            String familyName = fontName.substring(0, period);
            String styleName = fontName.substring(period + 1);
            return isLogicalFontFamilyName(familyName) &amp;&amp;
                    isLogicalFontStyleName(styleName);
        } else {
            return isLogicalFontFamilyName(fontName);
        }
    }

    protected static int getFontIndex(String fontName) {
        return getArrayIndex(fontNames, fontName);
    }

    protected static int getStyleIndex(String styleName) {
        return getArrayIndex(styleNames, styleName);
    }

    private static int getArrayIndex(String[] names, String name) {
        for (int i = 0; i &lt; names.length; i++) {
            if (name.equals(names[i])) {
                return i;
            }
        }
        assert false;
        return 0;
    }

    protected static int getStyleIndex(int style) {
        switch (style) {
            case Font.PLAIN:
                return 0;
            case Font.BOLD:
                return 1;
            case Font.ITALIC:
                return 2;
            case Font.BOLD | Font.ITALIC:
                return 3;
            default:
                return 0;
        }
    }

    protected static String getFontName(int fontIndex) {
        return fontNames[fontIndex];
    }

    protected static String getStyleName(int styleIndex) {
        return styleNames[styleIndex];
    }

    /**
     * Returns the font face name for the given logical font
     * family name and style.
     * The style argument is interpreted as in java.awt.Font.Font.
     */
    public static String getLogicalFontFaceName(String familyName, int style) {
        assert isLogicalFontFamilyName(familyName);
        return familyName.toLowerCase(Locale.ENGLISH) + &quot;.&quot; + getStyleString(style);
    }

    /**
     * Returns the string typically used in properties files
     * for the given style.
     * The style argument is interpreted as in java.awt.Font.Font.
     */
    public static String getStyleString(int style) {
        return getStyleName(getStyleIndex(style));
    }

    /**
     * Returns a fallback name for the given font name. For a few known
     * font names, matching logical font names are returned. For all
     * other font names, defaultFallback is returned.
     * defaultFallback differs between AWT and 2D.
     */
    public abstract String getFallbackFamilyName(String fontName, String defaultFallback);

    /**
     * Returns the 1.1 equivalent for some old 1.0 font family names for
     * which we need to maintain compatibility in some configurations.
     * Returns null for other font names.
     */
    protected String getCompatibilityFamilyName(String fontName) {
        fontName = fontName.toLowerCase(Locale.ENGLISH);
        if (fontName.equals(&quot;timesroman&quot;)) {
            return &quot;serif&quot;;
        } else if (fontName.equals(&quot;helvetica&quot;)) {
            return &quot;sansserif&quot;;
        } else if (fontName.equals(&quot;courier&quot;)) {
            return &quot;monospaced&quot;;
        }
        return null;
    }

    protected static String[] installedFallbackFontFiles = null;

    /**
     * Maps a file name given in the font configuration file
     * to a format appropriate for the platform.
     */
    protected String mapFileName(String fileName) {
        return fileName;
    }

    //////////////////////////////////////////////////////////////////////
    //  reordering                                                      //
    //////////////////////////////////////////////////////////////////////

    /* Mappings from file encoding to font config name for font supporting
     * the corresponding language. This is filled in by initReorderMap()
     */
    protected HashMap reorderMap = null;

    /* Platform-specific mappings */
    protected abstract void initReorderMap();

    /* Move item at index &quot;src&quot; to &quot;dst&quot;, shuffling all values in
     * between down
     */
    private void shuffle(String[] seq, int src, int dst) {
        if (dst &gt;= src) {
            return;
        }
        String tmp = seq[src];
        for (int i=src; i&gt;dst; i--) {
            seq[i] = seq[i-1];
        }
        seq[dst] = tmp;
    }

    /* Called to determine if there's a re-order sequence for this locale/
     * encoding. If there's none then the caller can &quot;bail&quot; and avoid
     * unnecessary work
     */
    public static boolean willReorderForStartupLocale() {
        return getReorderSequence() != null;
    }

    private static Object getReorderSequence() {
        if (fontConfig.reorderMap == null) {
             fontConfig.initReorderMap();
        }
        HashMap reorderMap = fontConfig.reorderMap;

        /* Find the most specific mapping */
        String language = startupLocale.getLanguage();
        String country = startupLocale.getCountry();
        Object val = reorderMap.get(encoding + &quot;.&quot; + language + &quot;.&quot; + country);
        if (val == null) {
            val = reorderMap.get(encoding + &quot;.&quot; + language);
        }
        if (val == null) {
            val = reorderMap.get(encoding);
        }
        return val;
    }

    /* This method reorders the sequence such that the matches for the
     * file encoding are moved ahead of other elements.
     * If an encoding uses more than one font, they are all moved up.
     */
     private void reorderSequenceForLocale(String[] seq) {
        Object val =  getReorderSequence();
        if (val instanceof String) {
            for (int i=0; i&lt; seq.length; i++) {
                if (seq[i].equals(val)) {
                    shuffle(seq, i, 0);
                    return;
                }
            }
        } else if (val instanceof String[]) {
            String[] fontLangs = (String[])val;
            for (int l=0; l&lt;fontLangs.length;l++) {
                for (int i=0; i&lt;seq.length;i++) {
                    if (seq[i].equals(fontLangs[l])) {
                        shuffle(seq, i, l);
                    }
                }
            }
        }
    }

    private static Vector splitSequence(String sequence) {
        //String.split would be more convenient, but incurs big performance penalty
        Vector parts = new Vector();
        int start = 0;
        int end;
        while ((end = sequence.indexOf(',', start)) &gt;= 0) {
            parts.add(sequence.substring(start, end));
            start = end + 1;
        }
        if (sequence.length() &gt; start) {
            parts.add(sequence.substring(start, sequence.length()));
        }
        return parts;
    }

    protected String[] split(String sequence) {
        Vector v = splitSequence(sequence);
        return (String[])v.toArray(new String[0]);
    }

    ////////////////////////////////////////////////////////////////////////
    // Methods for extracting information from the fontconfig data for AWT//
    ////////////////////////////////////////////////////////////////////////
    private Hashtable charsetRegistry = new Hashtable(5);

    /**
     * Returns FontDescriptors describing the physical fonts used for the
     * given logical font name and style. The font name is interpreted
     * in a case insensitive way.
     * The style argument is interpreted as in java.awt.Font.Font.
     */
    public FontDescriptor[] getFontDescriptors(String fontName, int style) {
        assert isLogicalFontFamilyName(fontName);
        fontName = fontName.toLowerCase(Locale.ENGLISH);
        int fontIndex = getFontIndex(fontName);
        int styleIndex = getStyleIndex(style);
        return getFontDescriptors(fontIndex, styleIndex);
    }
    private FontDescriptor[][][] fontDescriptors =
        new FontDescriptor[NUM_FONTS][NUM_STYLES][];

    private FontDescriptor[] getFontDescriptors(int fontIndex, int styleIndex) {
        FontDescriptor[] descriptors = fontDescriptors[fontIndex][styleIndex];
        if (descriptors == null) {
            descriptors = buildFontDescriptors(fontIndex, styleIndex);
            fontDescriptors[fontIndex][styleIndex] = descriptors;
        }
        return descriptors;
    }

    private FontDescriptor[] buildFontDescriptors(int fontIndex, int styleIndex) {
        String fontName = fontNames[fontIndex];
        String styleName = styleNames[styleIndex];

        short[] scriptIDs = getCoreScripts(fontIndex);
        short[] nameIDs = compFontNameIDs[fontIndex][styleIndex];
        String[] sequence = new String[scriptIDs.length];
        String[] names = new String[scriptIDs.length];
        for (int i = 0; i &lt; sequence.length; i++) {
            names[i] = getComponentFontName(nameIDs[i]);
            sequence[i] = getScriptName(scriptIDs[i]);
            if (alphabeticSuffix != null &amp;&amp; &quot;alphabetic&quot;.equals(sequence[i])) {
                sequence[i] = sequence[i] + &quot;/&quot; + alphabeticSuffix;
            }
        }
        int[][] fontExclusionRanges = compExclusions[fontIndex];

        FontDescriptor[] descriptors = new FontDescriptor[names.length];

        for (int i = 0; i &lt; names.length; i++) {
            String awtFontName;
            String encoding;

            awtFontName = makeAWTFontName(names[i], sequence[i]);

            // look up character encoding
            encoding = getEncoding(names[i], sequence[i]);
            if (encoding == null) {
                encoding = &quot;default&quot;;
            }
            CharsetEncoder enc
                    = getFontCharsetEncoder(encoding.trim(), awtFontName);

            // we already have the exclusion ranges
            int[] exclusionRanges = fontExclusionRanges[i];

            // create descriptor
            descriptors[i] = new FontDescriptor(awtFontName, enc, exclusionRanges);
        }
        return descriptors;
    }

    /**
     * Returns the AWT font name for the given platform font name and
     * character subset.
     */
    protected String makeAWTFontName(String platformFontName,
            String characterSubsetName) {
        return platformFontName;
    }

    /**
     * Returns the java.io name of the platform character encoding for the
     * given AWT font name and character subset. May return &quot;default&quot;
     * to indicate that getDefaultFontCharset should be called to obtain
     * a charset encoder.
     */
    protected abstract String getEncoding(String awtFontName,
            String characterSubsetName);

    private CharsetEncoder getFontCharsetEncoder(final String charsetName,
            String fontName) {

        Charset fc = null;
        if (charsetName.equals(&quot;default&quot;)) {
            fc = (Charset) charsetRegistry.get(fontName);
        } else {
            fc = (Charset) charsetRegistry.get(charsetName);
        }
        if (fc != null) {
            return fc.newEncoder();
        }

        if (!charsetName.startsWith(&quot;sun.awt.&quot;) &amp;&amp; !charsetName.equals(&quot;default&quot;)) {
            fc = Charset.forName(charsetName);
        } else {
            Class fcc = (Class) AccessController.doPrivileged(new PrivilegedAction() {
                    public Object run() {
                        try {
                            return Class.forName(charsetName, true,
                                                 ClassLoader.getSystemClassLoader());
                        } catch (ClassNotFoundException e) {
                        }
                        return null;
                    }
                });

            if (fcc != null) {
                try {
                    fc = (Charset) fcc.newInstance();
                } catch (Exception e) {
                }
            }
        }
        if (fc == null) {
            fc = getDefaultFontCharset(fontName);
        }

        if (charsetName.equals(&quot;default&quot;)){
            charsetRegistry.put(fontName, fc);
        } else {
            charsetRegistry.put(charsetName, fc);
        }
        return fc.newEncoder();
    }

    protected abstract Charset getDefaultFontCharset(
            String fontName);

    /* This retrieves the platform font directories (path) calculated
     * by setAWTFontPathSequence(String[]). The default implementation
     * returns null, its expected that X11 platforms may return
     * non-null.
     */
    public HashSet&lt;String&gt; getAWTFontPathSet() {
        return null;
    }

    ////////////////////////////////////////////////////////////////////////
    // methods for extracting information from the fontconfig data for 2D //
    ////////////////////////////////////////////////////////////////////////

    /**
     * Returns an array of composite font descriptors for all logical font
     * faces.
     * If the font configuration file doesn't specify Lucida Sans Regular
     * or the given fallback font as component fonts, they are added here.
     */
    public CompositeFontDescriptor[] get2DCompositeFontInfo() {
        CompositeFontDescriptor[] result =
                new CompositeFontDescriptor[NUM_FONTS * NUM_STYLES];
        String defaultFontFile = fontManager.getDefaultFontFile();
        String defaultFontFaceName = fontManager.getDefaultFontFaceName();

        for (int fontIndex = 0; fontIndex &lt; NUM_FONTS; fontIndex++) {
            String fontName = publicFontNames[fontIndex];

            // determine exclusion ranges for font
            // AWT uses separate exclusion range array per component font.
            // 2D packs all range boundaries into one array.
            // Both use separate entries for lower and upper boundary.
            int[][] exclusions = compExclusions[fontIndex];
            int numExclusionRanges = 0;
            for (int i = 0; i &lt; exclusions.length; i++) {
                numExclusionRanges += exclusions[i].length;
            }
            int[] exclusionRanges = new int[numExclusionRanges];
            int[] exclusionRangeLimits = new int[exclusions.length];
            int exclusionRangeIndex = 0;
            int exclusionRangeLimitIndex = 0;
            for (int i = 0; i &lt; exclusions.length; i++) {
                int[] componentRanges = exclusions[i];
                for (int j = 0; j &lt; componentRanges.length; ) {
                    int value = componentRanges[j];
                    exclusionRanges[exclusionRangeIndex++] = componentRanges[j++];
                    exclusionRanges[exclusionRangeIndex++] = componentRanges[j++];
                }
                exclusionRangeLimits[i] = exclusionRangeIndex;
            }
            // other info is per style
            for (int styleIndex = 0; styleIndex &lt; NUM_STYLES; styleIndex++) {
                int maxComponentFontCount = compFontNameIDs[fontIndex][styleIndex].length;
                boolean sawDefaultFontFile = false;
                // fall back fonts listed in the lib/fonts/fallback directory
                if (installedFallbackFontFiles != null) {
                    maxComponentFontCount += installedFallbackFontFiles.length;
                }
                String faceName = fontName + &quot;.&quot; + styleNames[styleIndex];

                // determine face names and file names of component fonts
                String[] componentFaceNames = new String[maxComponentFontCount];
                String[] componentFileNames = new String[maxComponentFontCount];

                int index;
                for (index = 0; index &lt; compFontNameIDs[fontIndex][styleIndex].length; index++) {
                    short fontNameID = compFontNameIDs[fontIndex][styleIndex][index];
                    short fileNameID = getComponentFileID(fontNameID);
                    componentFaceNames[index] = getFaceNameFromComponentFontName(getComponentFontName(fontNameID));
                    componentFileNames[index] = mapFileName(getComponentFileName(fileNameID));
                    if (componentFileNames[index] == null ||
                        needToSearchForFile(componentFileNames[index])) {
                        componentFileNames[index] = getFileNameFromComponentFontName(getComponentFontName(fontNameID));
                    }
                    if (!sawDefaultFontFile &amp;&amp;
                        defaultFontFile.equals(componentFileNames[index])) {
                        sawDefaultFontFile = true;
                    }
                    /*
                    System.out.println(publicFontNames[fontIndex] + &quot;.&quot; + styleNames[styleIndex] + &quot;.&quot;
                        + getString(table_scriptIDs[coreScripts[index]]) + &quot;=&quot; + componentFileNames[index]);
                    */
                }

                //&quot;Lucida Sans Regular&quot; is not in the list, we add it here
                if (!sawDefaultFontFile) {
                    int len = 0;
                    if (installedFallbackFontFiles != null) {
                        len = installedFallbackFontFiles.length;
                    }
                    if (index + len == maxComponentFontCount) {
                        String[] newComponentFaceNames = new String[maxComponentFontCount + 1];
                        System.arraycopy(componentFaceNames, 0, newComponentFaceNames, 0, index);
                        componentFaceNames = newComponentFaceNames;
                        String[] newComponentFileNames = new String[maxComponentFontCount + 1];
                        System.arraycopy(componentFileNames, 0, newComponentFileNames, 0, index);
                        componentFileNames = newComponentFileNames;
                    }
                    componentFaceNames[index] = defaultFontFaceName;
                    componentFileNames[index] = defaultFontFile;
                    index++;
                }

                if (installedFallbackFontFiles != null) {
                    for (int ifb=0; ifb&lt;installedFallbackFontFiles.length; ifb++) {
                        componentFaceNames[index] = null;
                        componentFileNames[index] = installedFallbackFontFiles[ifb];
                        index++;
                    }
                }

                if (index &lt; maxComponentFontCount) {
                    String[] newComponentFaceNames = new String[index];
                    System.arraycopy(componentFaceNames, 0, newComponentFaceNames, 0, index);
                    componentFaceNames = newComponentFaceNames;
                    String[] newComponentFileNames = new String[index];
                    System.arraycopy(componentFileNames, 0, newComponentFileNames, 0, index);
                    componentFileNames = newComponentFileNames;
                }
                // exclusion range limit array length must match component face name
                // array length - native code relies on this

                int[] clippedExclusionRangeLimits = exclusionRangeLimits;
                if (index != clippedExclusionRangeLimits.length) {
                    int len = exclusionRangeLimits.length;
                    clippedExclusionRangeLimits = new int[index];
                    System.arraycopy(exclusionRangeLimits, 0, clippedExclusionRangeLimits, 0, len);
                    //padding for various fallback fonts
                    for (int i = len; i &lt; index; i++) {
                        clippedExclusionRangeLimits[i] = exclusionRanges.length;
                    }
                }
                /*
                System.out.println(faceName + &quot;:&quot;);
                for (int i = 0; i &lt; componentFileNames.length; i++) {
                    System.out.println(&quot;    &quot; + componentFaceNames[i]
                         + &quot;  -&gt; &quot; + componentFileNames[i]);
                }
                */
                result[fontIndex * NUM_STYLES + styleIndex]
                        = new CompositeFontDescriptor(
                            faceName,
                            compCoreNum[fontIndex],
                            componentFaceNames,
                            componentFileNames,
                            exclusionRanges,
                            clippedExclusionRangeLimits);
            }
        }
        return result;
    }

    protected abstract String getFaceNameFromComponentFontName(String componentFontName);
    protected abstract String getFileNameFromComponentFontName(String componentFontName);

    /*
    public class 2dFont {
        public String platformName;
        public String fontfileName;
    }
    private 2dFont [] componentFonts = null;
    */

    /* Used on Linux to test if a file referenced in a font configuration
     * file exists in the location that is expected. If it does, no need
     * to search for it. If it doesn't then unless its a fallback font,
     * return that expensive code should be invoked to search for the font.
     */
    HashMap&lt;String, Boolean&gt; existsMap;
    public boolean needToSearchForFile(String fileName) {
        if (!FontUtilities.isLinux) {
            return false;
        } else if (existsMap == null) {
           existsMap = new HashMap&lt;String, Boolean&gt;();
        }
        Boolean exists = existsMap.get(fileName);
        if (exists == null) {
            /* call getNumberCoreFonts() to ensure these are initialised, and
             * if this file isn't for a core component, ie, is a for a fallback
             * font which very typically isn't available, then can't afford
             * to take the start-up penalty to search for it.
             */
            getNumberCoreFonts();
            if (!coreFontFileNames.contains(fileName)) {
                exists = Boolean.TRUE;
            } else {
                exists = Boolean.valueOf((new File(fileName)).exists());
                existsMap.put(fileName, exists);
                if (FontUtilities.debugFonts() &amp;&amp;
                    exists == Boolean.FALSE) {
                    logger.warning(&quot;Couldn't locate font file &quot; + fileName);
                }
            }
        }
        return exists == Boolean.FALSE;
    }

    private int numCoreFonts = -1;
    private String[] componentFonts = null;
    HashMap &lt;String, String&gt; filenamesMap = new HashMap&lt;String, String&gt;();
    HashSet &lt;String&gt; coreFontFileNames = new HashSet&lt;String&gt;();

    /* Return the number of core fonts. Note this isn't thread safe but
     * a calling thread can call this and getPlatformFontNames() in either
     * order.
     */
    public int getNumberCoreFonts() {
        if (numCoreFonts == -1) {
            numCoreFonts = coreFontNameIDs.size();
            Short[] emptyShortArray = new Short[0];
            Short[] core = coreFontNameIDs.toArray(emptyShortArray);
            Short[] fallback = fallbackFontNameIDs.toArray(emptyShortArray);

            int numFallbackFonts = 0;
            int i;
            for (i = 0; i &lt; fallback.length; i++) {
                if (coreFontNameIDs.contains(fallback[i])) {
                    fallback[i] = null;
                    continue;
                }
                numFallbackFonts++;
            }
            componentFonts = new String[numCoreFonts + numFallbackFonts];
            String filename = null;
            for (i = 0; i &lt; core.length; i++) {
                short fontid = core[i];
                short fileid = getComponentFileID(fontid);
                componentFonts[i] = getComponentFontName(fontid);
                String compFileName = getComponentFileName(fileid);
                if (compFileName != null) {
                    coreFontFileNames.add(compFileName);
                }
                filenamesMap.put(componentFonts[i], mapFileName(compFileName));
            }
            for (int j = 0; j &lt; fallback.length; j++) {
                if (fallback[j] != null) {
                    short fontid = fallback[j];
                    short fileid = getComponentFileID(fontid);
                    componentFonts[i] = getComponentFontName(fontid);
                    filenamesMap.put(componentFonts[i],
                                     mapFileName(getComponentFileName(fileid)));
                    i++;
                }
            }
        }
        return numCoreFonts;
    }

    /* Return all platform font names used by this font configuration.
     * The first getNumberCoreFonts() entries are guaranteed to be the
     * core fonts - ie no fall back only fonts.
     */
    public String[] getPlatformFontNames() {
        if (numCoreFonts == -1) {
            getNumberCoreFonts();
        }
        return componentFonts;
    }

    /**
     * Returns a file name for the physical font represented by this platform font name,
     * if the font configuration has such information available, or null if the
     * information is unavailable. The file name returned is just a hint; a null return
     * value doesn't necessarily mean that the font is unavailable, nor does a non-null
     * return value guarantee that the file exists and contains the physical font.
     * The file name can be an absolute or a relative path name.
     */
    public String getFileNameFromPlatformName(String platformName) {
        // get2DCompositeFontInfo
        //     -&gt;  getFileNameFromComponentfontName()  (W/M)
        //       -&gt;   getFileNameFromPlatformName()
        // it's a waste of time on Win32, but I have to give X11 a chance to
        // call getFileNameFromXLFD()
        return filenamesMap.get(platformName);
    }

    /**
     * Returns a configuration specific path to be appended to the font
     * search path.
     */
    public String getExtraFontPath() {
        return getString(head[INDEX_appendedfontpath]);
    }

    public String getVersion() {
        return getString(head[INDEX_version]);
    }

    /* subclass support */
    protected static FontConfiguration getFontConfiguration() {
        return fontConfig;
    }

    protected void setFontConfiguration() {
        fontConfig = this;      /* static initialization */
    }

    //////////////////////////////////////////////////////////////////////
    // FontConfig data tables and the index constants in binary file    //
    //////////////////////////////////////////////////////////////////////
    /* The binary font configuration file begins with a short[] &quot;head&quot;, which
     * contains the offsets to the starts of the individual data table which
     * immediately follow. The current implementation includes the tables shown
     * below.
     *
     * (00) table_scriptIDs    :stringIDs of all defined CharacterSubsetNames
     * (01) table_scriptFonts  :scriptID x fontIndex x styleIndex-&gt;
     *                          PlatformFontNameID mapping. Each scriptID might
     *                          have 1 or 20 entries depends on if it is defined
     *                          via a &quot;allfonts.CharacterSubsetname&quot; or a list of
     *                          &quot;LogicalFontName.StyleName.CharacterSubsetName&quot;
     *                          entries, positive entry means it's a &quot;allfonts&quot;
     *                          entry, a negative value means this is a offset to
     *                          a NUM_FONTS x NUM_STYLES subtable.
     * (02) table_elcIDs       :stringIDs of all defined ELC names, string
     *                          &quot;NULL.NULL.NULL&quot; is used for &quot;default&quot;
     * (03) table_sequences    :elcID x logicalFont -&gt; scriptIDs table defined
     *                          by &quot;sequence.allfonts/LogicalFontName.ELC&quot; in
     *                          font configuration file, each &quot;elcID&quot; has
     *                          NUM_FONTS (5) entries in this table.
     * (04) table_fontfileNameIDs
     *                         :stringIDs of all defined font file names
     * (05) table_componentFontNameIDs
     *                         :stringIDs of all defined PlatformFontNames
     * (06) table_filenames    :platformFontNamesID-&gt;fontfileNameID mapping
     *                          table, the index is the platformFontNamesID.
     * (07) table_awtfontpaths :CharacterSubsetNames-&gt;awtfontpaths mapping table,
     *                          the index is the CharacterSubsetName's stringID
     *                          and content is the stringID of awtfontpath.
     * (08) table_exclusions   :scriptID -&gt; exclusionRanges mapping table,
     *                          the index is the scriptID and the content is
                                a id of an exclusionRanges int[].
     * (09) table_proportionals:list of pairs of PlatformFontNameIDs, stores
     *                          the replacement info defined by &quot;proportional&quot;
     *                          keyword.
     * (10) table_scriptFontsMotif
     *                         :same as (01) except this table stores the
     *                          info defined with &quot;.motif&quot; keyword
     * (11) table_alphabeticSuffix
     *                         :elcID -&gt; stringID of alphabetic/XXXX entries
     * (12) table_stringIDs    :The index of this table is the string ID, the
     *                          content is the &quot;start index&quot; of this string in
     *                          stringTable, use the start index of next entry
     *                          as the &quot;end index&quot;.
     * (13) table_stringTable  :The real storage of all character strings defined
     *                          /used this font configuration, need a pair of
     *                          &quot;start&quot; and &quot;end&quot; indices to access.
     * (14) reserved
     * (15) table_fallbackScripts
     *                         :stringIDs of fallback CharacterSubsetnames, stored
     *                          in the order of they are defined in sequence.fallback.
     * (16) table_appendedfontpath
     *                         :stringtID of the &quot;appendedfontpath&quot; defined.
     * (17) table_version   :stringID of the version number of this fontconfig file.
     */
    private static final int HEAD_LENGTH = 20;
    private static final int INDEX_scriptIDs = 0;
    private static final int INDEX_scriptFonts = 1;
    private static final int INDEX_elcIDs = 2;
    private static final int INDEX_sequences = 3;
    private static final int INDEX_fontfileNameIDs = 4;
    private static final int INDEX_componentFontNameIDs = 5;
    private static final int INDEX_filenames = 6;
    private static final int INDEX_awtfontpaths = 7;
    private static final int INDEX_exclusions = 8;
    private static final int INDEX_proportionals = 9;
    private static final int INDEX_scriptFontsMotif = 10;
    private static final int INDEX_alphabeticSuffix = 11;
    private static final int INDEX_stringIDs = 12;
    private static final int INDEX_stringTable = 13;
    private static final int INDEX_TABLEEND = 14;
    private static final int INDEX_fallbackScripts = 15;
    private static final int INDEX_appendedfontpath = 16;
    private static final int INDEX_version = 17;

    private static short[] head;
    private static short[] table_scriptIDs;
    private static short[] table_scriptFonts;
    private static short[] table_elcIDs;
    private static short[] table_sequences;
    private static short[] table_fontfileNameIDs;
    private static short[] table_componentFontNameIDs;
    private static short[] table_filenames;
    protected static short[] table_awtfontpaths;
    private static short[] table_exclusions;
    private static short[] table_proportionals;
    private static short[] table_scriptFontsMotif;
    private static short[] table_alphabeticSuffix;
    private static short[] table_stringIDs;
    private static char[]  table_stringTable;

    /**
     * Checks consistencies of complied fontconfig data. This method
     * is called only at the build-time from
     * build.tools.compilefontconfig.CompileFontConfig.
     */
    private static void sanityCheck() {
        int errors = 0;

        //This method will only be called during build time, do we
        //need do PrivilegedAction?
        String osName = (String)java.security.AccessController.doPrivileged(
                            new java.security.PrivilegedAction() {
            public Object run() {
                return System.getProperty(&quot;os.name&quot;);
            }
        });

        //componentFontNameID starts from &quot;1&quot;
        for (int ii = 1; ii &lt; table_filenames.length; ii++) {
            if (table_filenames[ii] == -1) {
                // The corresponding finename entry for a component
                // font name is mandatory on Windows, but it's
                // optional on Solaris and Linux.
                if (osName.contains(&quot;Windows&quot;)) {
                    System.err.println(&quot;\n Error: &lt;filename.&quot;
                                       + getString(table_componentFontNameIDs[ii])
                                       + &quot;&gt; entry is missing!!!&quot;);
                    errors++;
                } else {
                    if (verbose &amp;&amp; !isEmpty(table_filenames)) {
                        System.err.println(&quot;\n Note: 'filename' entry is undefined for \&quot;&quot;
                                           + getString(table_componentFontNameIDs[ii])
                                           + &quot;\&quot;&quot;);
                    }
                }
            }
        }
        for (int ii = 0; ii &lt; table_scriptIDs.length; ii++) {
            short fid = table_scriptFonts[ii];
            if (fid == 0) {
                System.out.println(&quot;\n Error: &lt;allfonts.&quot;
                                   + getString(table_scriptIDs[ii])
                                   + &quot;&gt; entry is missing!!!&quot;);
                errors++;
                continue;
            } else if (fid &lt; 0) {
                fid = (short)-fid;
                for (int iii = 0; iii &lt; NUM_FONTS; iii++) {
                    for (int iij = 0; iij &lt; NUM_STYLES; iij++) {
                        int jj = iii * NUM_STYLES + iij;
                        short ffid = table_scriptFonts[fid + jj];
                        if (ffid == 0) {
                            System.err.println(&quot;\n Error: &lt;&quot;
                                           + getFontName(iii) + &quot;.&quot;
                                           + getStyleName(iij) + &quot;.&quot;
                                           + getString(table_scriptIDs[ii])
                                           + &quot;&gt; entry is missing!!!&quot;);
                            errors++;
                        }
                    }
                }
            }
        }
        if (&quot;SunOS&quot;.equals(osName)) {
            for (int ii = 0; ii &lt; table_awtfontpaths.length; ii++) {
                if (table_awtfontpaths[ii] == 0) {
                    String script = getString(table_scriptIDs[ii]);
                    if (script.contains(&quot;lucida&quot;) ||
                        script.contains(&quot;dingbats&quot;) ||
                        script.contains(&quot;symbol&quot;)) {
                        continue;
                    }
                    System.err.println(&quot;\nError: &quot;
                                       + &quot;&lt;awtfontpath.&quot;
                                       + script
                                       + &quot;&gt; entry is missing!!!&quot;);
                    errors++;
                }
            }
        }
        if (errors != 0) {
            System.err.println(&quot;!!THERE ARE &quot; + errors + &quot; ERROR(S) IN &quot;
                               + &quot;THE FONTCONFIG FILE, PLEASE CHECK ITS CONTENT!!\n&quot;);
            System.exit(1);
        }
    }

    private static boolean isEmpty(short[] a) {
        for (short s : a) {
            if (s != -1) {
                return false;
            }
        }
        return true;
    }

    //dump the fontconfig data tables
    private static void dump() {
        System.out.println(&quot;\n----Head Table------------&quot;);
        for (int ii = 0; ii &lt; HEAD_LENGTH; ii++) {
            System.out.println(&quot;  &quot; + ii + &quot; : &quot; + head[ii]);
        }
        System.out.println(&quot;\n----scriptIDs-------------&quot;);
        printTable(table_scriptIDs, 0);
        System.out.println(&quot;\n----scriptFonts----------------&quot;);
        for (int ii = 0; ii &lt; table_scriptIDs.length; ii++) {
            short fid = table_scriptFonts[ii];
            if (fid &gt;= 0) {
                System.out.println(&quot;  allfonts.&quot;
                                   + getString(table_scriptIDs[ii])
                                   + &quot;=&quot;
                                   + getString(table_componentFontNameIDs[fid]));
            }
        }
        for (int ii = 0; ii &lt; table_scriptIDs.length; ii++) {
            short fid = table_scriptFonts[ii];
            if (fid &lt; 0) {
                fid = (short)-fid;
                for (int iii = 0; iii &lt; NUM_FONTS; iii++) {
                    for (int iij = 0; iij &lt; NUM_STYLES; iij++) {
                        int jj = iii * NUM_STYLES + iij;
                        short ffid = table_scriptFonts[fid + jj];
                        System.out.println(&quot;  &quot;
                                           + getFontName(iii) + &quot;.&quot;
                                           + getStyleName(iij) + &quot;.&quot;
                                           + getString(table_scriptIDs[ii])
                                           + &quot;=&quot;
                                           + getString(table_componentFontNameIDs[ffid]));
                    }
                }

            }
        }
        System.out.println(&quot;\n----elcIDs----------------&quot;);
        printTable(table_elcIDs, 0);
        System.out.println(&quot;\n----sequences-------------&quot;);
        for (int ii = 0; ii&lt; table_elcIDs.length; ii++) {
            System.out.println(&quot;  &quot; + ii + &quot;/&quot; + getString((short)table_elcIDs[ii]));
            short[] ss = getShortArray(table_sequences[ii * NUM_FONTS + 0]);
            for (int jj = 0; jj &lt; ss.length; jj++) {
                System.out.println(&quot;     &quot; + getString((short)table_scriptIDs[ss[jj]]));
            }
        }
        System.out.println(&quot;\n----fontfileNameIDs-------&quot;);
        printTable(table_fontfileNameIDs, 0);

        System.out.println(&quot;\n----componentFontNameIDs--&quot;);
        printTable(table_componentFontNameIDs, 1);
        System.out.println(&quot;\n----filenames-------------&quot;);
        for (int ii = 0; ii &lt; table_filenames.length; ii++) {
            if (table_filenames[ii] == -1) {
                System.out.println(&quot;  &quot; + ii + &quot; : null&quot;);
            } else {
                System.out.println(&quot;  &quot; + ii + &quot; : &quot;
                   + getString(table_fontfileNameIDs[table_filenames[ii]]));
            }
        }
        System.out.println(&quot;\n----awtfontpaths---------&quot;);
        for (int ii = 0; ii &lt; table_awtfontpaths.length; ii++) {
            System.out.println(&quot;  &quot; + getString(table_scriptIDs[ii])
                               + &quot; : &quot;
                               + getString(table_awtfontpaths[ii]));
        }
        System.out.println(&quot;\n----proportionals--------&quot;);
        for (int ii = 0; ii &lt; table_proportionals.length; ii++) {
            System.out.println(&quot;  &quot;
                   + getString((short)table_componentFontNameIDs[table_proportionals[ii++]])
                   + &quot; -&gt; &quot;
                   + getString((short)table_componentFontNameIDs[table_proportionals[ii]]));
        }
        int i = 0;
        System.out.println(&quot;\n----alphabeticSuffix----&quot;);
        while (i &lt; table_alphabeticSuffix.length) {
          System.out.println(&quot;    &quot; + getString(table_elcIDs[table_alphabeticSuffix[i++]])
                             + &quot; -&gt; &quot; + getString(table_alphabeticSuffix[i++]));
        }
        System.out.println(&quot;\n----String Table---------&quot;);
        System.out.println(&quot;    stringID:    Num =&quot; + table_stringIDs.length);
        System.out.println(&quot;    stringTable: Size=&quot; + table_stringTable.length * 2);

        System.out.println(&quot;\n----fallbackScriptIDs---&quot;);
        short[] fbsIDs = getShortArray(head[INDEX_fallbackScripts]);
        for (int ii = 0; ii &lt; fbsIDs.length; ii++) {
          System.out.println(&quot;  &quot; + getString(table_scriptIDs[fbsIDs[ii]]));
        }
        System.out.println(&quot;\n----appendedfontpath-----&quot;);
        System.out.println(&quot;  &quot; + getString(head[INDEX_appendedfontpath]));
        System.out.println(&quot;\n----Version--------------&quot;);
        System.out.println(&quot;  &quot; + getString(head[INDEX_version]));
    }


    //////////////////////////////////////////////////////////////////////
    // Data table access methods                                        //
    //////////////////////////////////////////////////////////////////////

    /* Return the fontID of the platformFontName defined in this font config
     * by &quot;LogicalFontName.StyleName.CharacterSubsetName&quot; entry or
     * &quot;allfonts.CharacterSubsetName&quot; entry in properties format fc file.
     */
    protected static short getComponentFontID(short scriptID, int fontIndex, int styleIndex) {
        short fid = table_scriptFonts[scriptID];
        //System.out.println(&quot;fid=&quot; + fid + &quot;/ scriptID=&quot; + scriptID + &quot;, fi=&quot; + fontIndex + &quot;, si=&quot; + styleIndex);
        if (fid &gt;= 0) {
            //&quot;allfonts&quot;
            return fid;
        } else {
            return table_scriptFonts[-fid + fontIndex * NUM_STYLES + styleIndex];
        }
    }

    /* Same as getCompoentFontID() except this method returns the fontID define by
     * &quot;xxxx.motif&quot; entry.
     */
    protected static short getComponentFontIDMotif(short scriptID, int fontIndex, int styleIndex) {
        if (table_scriptFontsMotif.length == 0) {
            return 0;
        }
        short fid = table_scriptFontsMotif[scriptID];
        if (fid &gt;= 0) {
            //&quot;allfonts&quot; &gt; 0 or &quot;not defined&quot; == 0
            return fid;
        } else {
            return table_scriptFontsMotif[-fid + fontIndex * NUM_STYLES + styleIndex];
        }
    }

    private static int[] getExclusionRanges(short scriptID) {
        short exID = table_exclusions[scriptID];
        if (exID == 0) {
            return EMPTY_INT_ARRAY;
        } else {
            char[] exChar = getString(exID).toCharArray();
            int[] exInt = new int[exChar.length / 2];
            int i = 0;
            for (int j = 0; j &lt; exInt.length; j++) {
                exInt[j] = (exChar[i++] &lt;&lt; 16) + (exChar[i++] &amp; 0xffff);
            }
            return exInt;
        }
    }

    private static boolean contains(short IDs[], short id, int limit) {
        for (int i = 0; i &lt; limit; i++) {
            if (IDs[i] == id) {
                return true;
            }
        }
        return false;
    }

    /* Return the PlatformFontName from its fontID*/
    protected static String getComponentFontName(short id) {
        if (id &lt; 0) {
            return null;
        }
        return getString(table_componentFontNameIDs[id]);
    }

    private static String getComponentFileName(short id) {
        if (id &lt; 0) {
            return null;
        }
        return getString(table_fontfileNameIDs[id]);
    }

    //componentFontID -&gt; componentFileID
    private static short getComponentFileID(short nameID) {
        return table_filenames[nameID];
    }

    private static String getScriptName(short scriptID) {
        return getString(table_scriptIDs[scriptID]);
    }

   private HashMap&lt;String, Short&gt; reorderScripts;
   protected short[] getCoreScripts(int fontIndex) {
        short elc = getInitELC();
        /*
          System.out.println(&quot;getCoreScripts: elc=&quot; + elc + &quot;, fontIndex=&quot; + fontIndex);
          short[] ss = getShortArray(table_sequences[elc * NUM_FONTS + fontIndex]);
          for (int i = 0; i &lt; ss.length; i++) {
              System.out.println(&quot;     &quot; + getString((short)table_scriptIDs[ss[i]]));
          }
          */
        short[] scripts = getShortArray(table_sequences[elc * NUM_FONTS + fontIndex]);
        if (preferLocaleFonts) {
            if (reorderScripts == null) {
                reorderScripts = new HashMap&lt;String, Short&gt;();
            }
            String[] ss = new String[scripts.length];
            for (int i = 0; i &lt; ss.length; i++) {
                ss[i] = getScriptName(scripts[i]);
                reorderScripts.put(ss[i], scripts[i]);
            }
            reorderSequenceForLocale(ss);
            for (int i = 0; i &lt; ss.length; i++) {
                scripts[i] = reorderScripts.get(ss[i]);
            }
        }
         return scripts;
    }

    private static short[] getFallbackScripts() {
        return getShortArray(head[INDEX_fallbackScripts]);
    }

    private static void printTable(short[] list, int start) {
        for (int i = start; i &lt; list.length; i++) {
            System.out.println(&quot;  &quot; + i + &quot; : &quot; + getString(list[i]));
        }
    }

    private static short[] readShortTable(DataInputStream in, int len )
        throws IOException {
        if (len == 0) {
            return EMPTY_SHORT_ARRAY;
        }
        short[] data = new short[len];
        byte[] bb = new byte[len * 2];
        in.read(bb);
        int i = 0,j = 0;
        while (i &lt; len) {
            data[i++] = (short)(bb[j++] &lt;&lt; 8 | (bb[j++] &amp; 0xff));
        }
        return data;
    }

    private static void writeShortTable(DataOutputStream out, short[] data)
        throws IOException {
        for (short val : data) {
            out.writeShort(val);
        }
    }

    private static short[] toList(HashMap&lt;String, Short&gt; map) {
        short[] list = new short[map.size()];
        Arrays.fill(list, (short) -1);
        for (Entry&lt;String, Short&gt; entry : map.entrySet()) {
            list[entry.getValue()] = getStringID(entry.getKey());
        }
        return list;
    }

    //runtime cache
    private static String[] stringCache;
    protected static String getString(short stringID) {
        if (stringID == 0)
            return null;
        /*
        if (loadingProperties) {
            return stringTable.substring(stringIDs[stringID],
                                         stringIDs[stringID+1]);
        }
        */
        //sync if we want it to be MT-enabled
        if (stringCache[stringID] == null){
            stringCache[stringID] =
              new String (table_stringTable,
                          table_stringIDs[stringID],
                          table_stringIDs[stringID+1] - table_stringIDs[stringID]);
        }
        return stringCache[stringID];
    }

    private static short[] getShortArray(short shortArrayID) {
        String s = getString(shortArrayID);
        char[] cc = s.toCharArray();
        short[] ss = new short[cc.length];
        for (int i = 0; i &lt; cc.length; i++) {
            ss[i] = (short)(cc[i] &amp; 0xffff);
        }
        return ss;
    }

    private static short getStringID(String s) {
        if (s == null) {
            return (short)0;
        }
        short pos0 = (short)stringTable.length();
        stringTable.append(s);
        short pos1 = (short)stringTable.length();

        stringIDs[stringIDNum] = pos0;
        stringIDs[stringIDNum + 1] = pos1;
        stringIDNum++;
        if (stringIDNum + 1 &gt;= stringIDs.length) {
            short[] tmp = new short[stringIDNum + 1000];
            System.arraycopy(stringIDs, 0, tmp, 0, stringIDNum);
            stringIDs = tmp;
        }
        return (short)(stringIDNum - 1);
    }

    private static short getShortArrayID(short sa[]) {
        char[] cc = new char[sa.length];
        for (int i = 0; i &lt; sa.length; i ++) {
            cc[i] = (char)sa[i];
        }
        String s = new String(cc);
        return getStringID(s);
    }

    //utility &quot;empty&quot; objects
    private static final int[] EMPTY_INT_ARRAY = new int[0];
    private static final String[] EMPTY_STRING_ARRAY = new String[0];
    private static final short[] EMPTY_SHORT_ARRAY = new short[0];
    private static final String UNDEFINED_COMPONENT_FONT = &quot;unknown&quot;;

    //////////////////////////////////////////////////////////////////////////
    //Convert the FontConfig data in Properties file to binary data tables  //
    //////////////////////////////////////////////////////////////////////////
    static class PropertiesHandler {
        public void load(InputStream in) throws IOException {
            initLogicalNameStyle();
            initHashMaps();
            FontProperties fp = new FontProperties();
            fp.load(in);
            initBinaryTable();
        }

        private void initBinaryTable() {
            //(0)
            head = new short[HEAD_LENGTH];
            head[INDEX_scriptIDs] = (short)HEAD_LENGTH;

            table_scriptIDs = toList(scriptIDs);
            //(1)a: scriptAllfonts scriptID/allfonts -&gt; componentFontNameID
            //   b: scriptFonts    scriptID -&gt; componentFontNameID[20]
            //if we have a &quot;allfonts.script&quot; def, then we just put
            //the &quot;-platformFontID&quot; value in the slot, otherwise the slot
            //value is &quot;offset&quot; which &quot;offset&quot; is where 20 entries located
            //in the table attached.
            head[INDEX_scriptFonts] = (short)(head[INDEX_scriptIDs]  + table_scriptIDs.length);
            int len = table_scriptIDs.length + scriptFonts.size() * 20;
            table_scriptFonts = new short[len];

            for (Entry&lt;Short, Short&gt; entry : scriptAllfonts.entrySet()) {
                table_scriptFonts[entry.getKey().intValue()] = entry.getValue();
            }
            int off = table_scriptIDs.length;
            for (Entry&lt;Short, Short[]&gt; entry : scriptFonts.entrySet()) {
                table_scriptFonts[entry.getKey().intValue()] = (short)-off;
                Short[] v = entry.getValue();
                for (int i = 0; i &lt; 20; i++) {
                    if (v[i] != null) {
                        table_scriptFonts[off++] = v[i];
                    } else {
                        table_scriptFonts[off++] = 0;
                    }
                }
            }

            //(2)
            head[INDEX_elcIDs] = (short)(head[INDEX_scriptFonts]  + table_scriptFonts.length);
            table_elcIDs = toList(elcIDs);

            //(3) sequences  elcID -&gt; XXXX[1|5] -&gt; scriptID[]
            head[INDEX_sequences] = (short)(head[INDEX_elcIDs]  + table_elcIDs.length);
            table_sequences = new short[elcIDs.size() * NUM_FONTS];
            for (Entry&lt;Short, short[]&gt; entry : sequences.entrySet()) {
                //table_sequences[entry.getKey().intValue()] = (short)-off;
                int k = entry.getKey().intValue();
                short[] v = entry.getValue();
                /*
                  System.out.println(&quot;elc=&quot; + k + &quot;/&quot; + getString((short)table_elcIDs[k]));
                  short[] ss = getShortArray(v[0]);
                  for (int i = 0; i &lt; ss.length; i++) {
                  System.out.println(&quot;     &quot; + getString((short)table_scriptIDs[ss[i]]));
                  }
                  */
                if (v.length == 1) {
                    //the &quot;allfonts&quot; entries
                    for (int i = 0; i &lt; NUM_FONTS; i++) {
                        table_sequences[k * NUM_FONTS + i] = v[0];
                    }
                } else {
                    for (int i = 0; i &lt; NUM_FONTS; i++) {
                        table_sequences[k * NUM_FONTS + i] = v[i];
                    }
                }
            }
            //(4)
            head[INDEX_fontfileNameIDs] = (short)(head[INDEX_sequences]  + table_sequences.length);
            table_fontfileNameIDs = toList(fontfileNameIDs);

            //(5)
            head[INDEX_componentFontNameIDs] = (short)(head[INDEX_fontfileNameIDs]  + table_fontfileNameIDs.length);
            table_componentFontNameIDs = toList(componentFontNameIDs);

            //(6)componentFontNameID -&gt; filenameID
            head[INDEX_filenames] = (short)(head[INDEX_componentFontNameIDs]  + table_componentFontNameIDs.length);
            table_filenames = new short[table_componentFontNameIDs.length];
            Arrays.fill(table_filenames, (short) -1);

            for (Entry&lt;Short, Short&gt; entry : filenames.entrySet()) {
                table_filenames[entry.getKey()] = entry.getValue();
            }

            //(7)scriptID-&gt; awtfontpath
            //the paths are stored as scriptID -&gt; stringID in awtfontpahts
            head[INDEX_awtfontpaths] = (short)(head[INDEX_filenames]  + table_filenames.length);
            table_awtfontpaths = new short[table_scriptIDs.length];
            for (Entry&lt;Short, Short&gt; entry : awtfontpaths.entrySet()) {
                table_awtfontpaths[entry.getKey()] = entry.getValue();
            }

            //(8)exclusions
            head[INDEX_exclusions] = (short)(head[INDEX_awtfontpaths]  + table_awtfontpaths.length);
            table_exclusions = new short[scriptIDs.size()];
            for (Entry&lt;Short, int[]&gt; entry : exclusions.entrySet()) {
                int[] exI = entry.getValue();
                char[] exC = new char[exI.length * 2];
                int j = 0;
                for (int i = 0; i &lt; exI.length; i++) {
                    exC[j++] = (char) (exI[i] &gt;&gt; 16);
                    exC[j++] = (char) (exI[i] &amp; 0xffff);
                }
                table_exclusions[entry.getKey()] = getStringID(new String (exC));
            }
            //(9)proportionals
            head[INDEX_proportionals] = (short)(head[INDEX_exclusions]  + table_exclusions.length);
            table_proportionals = new short[proportionals.size() * 2];
            int j = 0;
            for (Entry&lt;Short, Short&gt; entry : proportionals.entrySet()) {
                table_proportionals[j++] = entry.getKey();
                table_proportionals[j++] = entry.getValue();
            }

            //(10) see (1) for info, the only difference is &quot;xxx.motif&quot;
            head[INDEX_scriptFontsMotif] = (short)(head[INDEX_proportionals] + table_proportionals.length);
            if (scriptAllfontsMotif.size() != 0 || scriptFontsMotif.size() != 0) {
                len = table_scriptIDs.length + scriptFontsMotif.size() * 20;
                table_scriptFontsMotif = new short[len];

                for (Entry&lt;Short, Short&gt; entry : scriptAllfontsMotif.entrySet()) {
                    table_scriptFontsMotif[entry.getKey().intValue()] =
                      (short)entry.getValue();
                }
                off = table_scriptIDs.length;
                for (Entry&lt;Short, Short[]&gt; entry : scriptFontsMotif.entrySet()) {
                    table_scriptFontsMotif[entry.getKey().intValue()] = (short)-off;
                    Short[] v = entry.getValue();
                    int i = 0;
                    while (i &lt; 20) {
                        if (v[i] != null) {
                            table_scriptFontsMotif[off++] = v[i];
                        } else {
                            table_scriptFontsMotif[off++] = 0;
                        }
                        i++;
                    }
                }
            } else {
                table_scriptFontsMotif = EMPTY_SHORT_ARRAY;
            }

            //(11)short[] alphabeticSuffix
            head[INDEX_alphabeticSuffix] = (short)(head[INDEX_scriptFontsMotif] + table_scriptFontsMotif.length);
            table_alphabeticSuffix = new short[alphabeticSuffix.size() * 2];
            j = 0;
            for (Entry&lt;Short, Short&gt; entry : alphabeticSuffix.entrySet()) {
                table_alphabeticSuffix[j++] = entry.getKey();
                table_alphabeticSuffix[j++] = entry.getValue();
            }

            //(15)short[] fallbackScriptIDs; just put the ID in head
            head[INDEX_fallbackScripts] = getShortArrayID(fallbackScriptIDs);

            //(16)appendedfontpath
            head[INDEX_appendedfontpath] = getStringID(appendedfontpath);

            //(17)version
            head[INDEX_version] = getStringID(version);

            //(12)short[] StringIDs
            head[INDEX_stringIDs] = (short)(head[INDEX_alphabeticSuffix] + table_alphabeticSuffix.length);
            table_stringIDs = new short[stringIDNum + 1];
            System.arraycopy(stringIDs, 0, table_stringIDs, 0, stringIDNum + 1);

            //(13)StringTable
            head[INDEX_stringTable] = (short)(head[INDEX_stringIDs] + stringIDNum + 1);
            table_stringTable = stringTable.toString().toCharArray();
            //(14)
            head[INDEX_TABLEEND] = (short)(head[INDEX_stringTable] + stringTable.length());

            //StringTable cache
            stringCache = new String[table_stringIDs.length];
        }

        //////////////////////////////////////////////
        private HashMap&lt;String, Short&gt; scriptIDs;
        //elc -&gt; Encoding.Language.Country
        private HashMap&lt;String, Short&gt; elcIDs;
        //componentFontNameID starts from &quot;1&quot;, &quot;0&quot; reserves for &quot;undefined&quot;
        private HashMap&lt;String, Short&gt; componentFontNameIDs;
        private HashMap&lt;String, Short&gt; fontfileNameIDs;
        private HashMap&lt;String, Integer&gt; logicalFontIDs;
        private HashMap&lt;String, Integer&gt; fontStyleIDs;

        //componentFontNameID -&gt; fontfileNameID
        private HashMap&lt;Short, Short&gt;  filenames;

        //elcID -&gt; allfonts/logicalFont -&gt; scriptID list
        //(1)if we have a &quot;allfonts&quot;, then the length of the
        //   value array is &quot;1&quot;, otherwise it's 5, each font
        //   must have their own individual entry.
        //scriptID list &quot;short[]&quot; is stored as an ID
        private HashMap&lt;Short, short[]&gt; sequences;

        //scriptID -&gt;logicFontID/fontStyleID-&gt;componentFontNameID,
        //a 20-entry array (5-name x 4-style) for each script
        private HashMap&lt;Short, Short[]&gt; scriptFonts;

        //scriptID -&gt; componentFontNameID
        private HashMap&lt;Short, Short&gt; scriptAllfonts;

        //scriptID -&gt; exclusionRanges[]
        private HashMap&lt;Short, int[]&gt; exclusions;

        //scriptID -&gt; fontpath
        private HashMap&lt;Short, Short&gt; awtfontpaths;

        //fontID -&gt; fontID
        private HashMap&lt;Short, Short&gt; proportionals;

        //scriptID -&gt; componentFontNameID
        private HashMap&lt;Short, Short&gt; scriptAllfontsMotif;

        //scriptID -&gt;logicFontID/fontStyleID-&gt;componentFontNameID,
        private HashMap&lt;Short, Short[]&gt; scriptFontsMotif;

        //elcID -&gt; stringID of alphabetic/XXXX
        private HashMap&lt;Short, Short&gt; alphabeticSuffix;

        private short[] fallbackScriptIDs;
        private String version;
        private String appendedfontpath;

        private void initLogicalNameStyle() {
            logicalFontIDs = new HashMap&lt;String, Integer&gt;();
            fontStyleIDs = new HashMap&lt;String, Integer&gt;();
            logicalFontIDs.put(&quot;serif&quot;,      0);
            logicalFontIDs.put(&quot;sansserif&quot;,  1);
            logicalFontIDs.put(&quot;monospaced&quot;, 2);
            logicalFontIDs.put(&quot;dialog&quot;,     3);
            logicalFontIDs.put(&quot;dialoginput&quot;,4);
            fontStyleIDs.put(&quot;plain&quot;,      0);
            fontStyleIDs.put(&quot;bold&quot;,       1);
            fontStyleIDs.put(&quot;italic&quot;,     2);
            fontStyleIDs.put(&quot;bolditalic&quot;, 3);
        }

        private void initHashMaps() {
            scriptIDs = new HashMap&lt;String, Short&gt;();
            elcIDs = new HashMap&lt;String, Short&gt;();
            componentFontNameIDs = new HashMap&lt;String, Short&gt;();
            /*Init these tables to allow componentFontNameID, fontfileNameIDs
              to start from &quot;1&quot;.
            */
            componentFontNameIDs.put(&quot;&quot;, Short.valueOf((short)0));

            fontfileNameIDs = new HashMap&lt;String, Short&gt;();
            filenames = new HashMap&lt;Short, Short&gt;();
            sequences = new HashMap&lt;Short, short[]&gt;();
            scriptFonts = new HashMap&lt;Short, Short[]&gt;();
            scriptAllfonts = new HashMap&lt;Short, Short&gt;();
            exclusions = new HashMap&lt;Short, int[]&gt;();
            awtfontpaths = new HashMap&lt;Short, Short&gt;();
            proportionals = new HashMap&lt;Short, Short&gt;();
            scriptFontsMotif = new HashMap&lt;Short, Short[]&gt;();
            scriptAllfontsMotif = new HashMap&lt;Short, Short&gt;();
            alphabeticSuffix = new HashMap&lt;Short, Short&gt;();
            fallbackScriptIDs = EMPTY_SHORT_ARRAY;
            /*
              version
              appendedfontpath
            */
        }

        private int[] parseExclusions(String key, String exclusions) {
            if (exclusions == null) {
                return EMPTY_INT_ARRAY;
            }
            // range format is xxxx-XXXX,yyyyyy-YYYYYY,.....
            int numExclusions = 1;
            int pos = 0;
            while ((pos = exclusions.indexOf(',', pos)) != -1) {
                numExclusions++;
                pos++;
            }
            int[] exclusionRanges = new int[numExclusions * 2];
            pos = 0;
            int newPos = 0;
            for (int j = 0; j &lt; numExclusions * 2; ) {
                String lower, upper;
                int lo = 0, up = 0;
                try {
                    newPos = exclusions.indexOf('-', pos);
                    lower = exclusions.substring(pos, newPos);
                    pos = newPos + 1;
                    newPos = exclusions.indexOf(',', pos);
                    if (newPos == -1) {
                        newPos = exclusions.length();
                    }
                    upper = exclusions.substring(pos, newPos);
                    pos = newPos + 1;
                    int lowerLength = lower.length();
                    int upperLength = upper.length();
                    if (lowerLength != 4 &amp;&amp; lowerLength != 6
                        || upperLength != 4 &amp;&amp; upperLength != 6) {
                        throw new Exception();
                    }
                    lo = Integer.parseInt(lower, 16);
                    up = Integer.parseInt(upper, 16);
                    if (lo &gt; up) {
                        throw new Exception();
                    }
                } catch (Exception e) {
                    if (FontUtilities.debugFonts() &amp;&amp;
                        logger != null) {
                        logger.config(&quot;Failed parsing &quot; + key +
                                  &quot; property of font configuration.&quot;);

                    }
                    return EMPTY_INT_ARRAY;
                }
                exclusionRanges[j++] = lo;
                exclusionRanges[j++] = up;
            }
            return exclusionRanges;
        }

        private Short getID(HashMap&lt;String, Short&gt; map, String key) {
            Short ret = map.get(key);
            if ( ret == null) {
                map.put(key, (short)map.size());
                return map.get(key);
            }
            return ret;
        }

        class FontProperties extends Properties {
            public synchronized Object put(Object k, Object v) {
                parseProperty((String)k, (String)v);
                return null;
            }
        }

        private void parseProperty(String key, String value) {
            if (key.startsWith(&quot;filename.&quot;)) {
                //the only special case is &quot;MingLiu_HKSCS&quot; which has &quot;_&quot; in its
                //facename, we don't want to replace the &quot;_&quot; with &quot; &quot;
                key = key.substring(9);
                if (!&quot;MingLiU_HKSCS&quot;.equals(key)) {
                    key = key.replace('_', ' ');
                }
                Short faceID = getID(componentFontNameIDs, key);
                Short fileID = getID(fontfileNameIDs, value);
                //System.out.println(&quot;faceID=&quot; + faceID + &quot;/&quot; + key + &quot; -&gt; &quot;
                //    + &quot;fileID=&quot; + fileID + &quot;/&quot; + value);
                filenames.put(faceID, fileID);
            } else if (key.startsWith(&quot;exclusion.&quot;)) {
                key = key.substring(10);
                exclusions.put(getID(scriptIDs,key), parseExclusions(key,value));
            } else if (key.startsWith(&quot;sequence.&quot;)) {
                key = key.substring(9);
                boolean hasDefault = false;
                boolean has1252 = false;

                //get the scriptID list
                String[] ss = (String[])splitSequence(value).toArray(EMPTY_STRING_ARRAY);
                short [] sa = new short[ss.length];
                for (int i = 0; i &lt; ss.length; i++) {
                    if (&quot;alphabetic/default&quot;.equals(ss[i])) {
                        //System.out.println(key + &quot; -&gt; &quot; + ss[i]);
                        ss[i] = &quot;alphabetic&quot;;
                        hasDefault = true;
                    } else if (&quot;alphabetic/1252&quot;.equals(ss[i])) {
                        //System.out.println(key + &quot; -&gt; &quot; + ss[i]);
                        ss[i] = &quot;alphabetic&quot;;
                        has1252 = true;
                    }
                    sa[i] = getID(scriptIDs, ss[i]).shortValue();
                    //System.out.println(&quot;scriptID=&quot; + si[i] + &quot;/&quot; + ss[i]);
                }
                //convert the &quot;short[] -&gt; string -&gt; stringID&quot;
                short scriptArrayID = getShortArrayID(sa);
                Short elcID = null;
                int dot = key.indexOf('.');
                if (dot == -1) {
                    if (&quot;fallback&quot;.equals(key)) {
                        fallbackScriptIDs = sa;
                        return;
                    }
                    if (&quot;allfonts&quot;.equals(key)) {
                        elcID = getID(elcIDs, &quot;NULL.NULL.NULL&quot;);
                    } else {
                        if (logger != null) {
                            logger.config(&quot;Error sequence def: &lt;sequence.&quot; + key + &quot;&gt;&quot;);
                        }
                        return;
                    }
                } else {
                    elcID = getID(elcIDs, key.substring(dot + 1));
                    //System.out.println(&quot;elcID=&quot; + elcID + &quot;/&quot; + key.substring(dot + 1));
                    key = key.substring(0, dot);
                }
                short[] scriptArrayIDs = null;
                if (&quot;allfonts&quot;.equals(key)) {
                    scriptArrayIDs = new short[1];
                    scriptArrayIDs[0] = scriptArrayID;
                } else {
                    scriptArrayIDs = sequences.get(elcID);
                    if (scriptArrayIDs == null) {
                       scriptArrayIDs = new short[5];
                    }
                    Integer fid = logicalFontIDs.get(key);
                    if (fid == null) {
                        if (logger != null) {
                            logger.config(&quot;Unrecognizable logicfont name &quot; + key);
                        }
                        return;
                    }
                    //System.out.println(&quot;sequence.&quot; + key + &quot;/&quot; + id);
                    scriptArrayIDs[fid.intValue()] = scriptArrayID;
                }
                sequences.put(elcID, scriptArrayIDs);
                if (hasDefault) {
                    alphabeticSuffix.put(elcID, getStringID(&quot;default&quot;));
                } else
                if (has1252) {
                    alphabeticSuffix.put(elcID, getStringID(&quot;1252&quot;));
                }
            } else if (key.startsWith(&quot;allfonts.&quot;)) {
                key = key.substring(9);
                if (key.endsWith(&quot;.motif&quot;)) {
                    key = key.substring(0, key.length() - 6);
                    //System.out.println(&quot;motif: all.&quot; + key + &quot;=&quot; + value);
                    scriptAllfontsMotif.put(getID(scriptIDs,key), getID(componentFontNameIDs,value));
                } else {
                    scriptAllfonts.put(getID(scriptIDs,key), getID(componentFontNameIDs,value));
                }
            } else if (key.startsWith(&quot;awtfontpath.&quot;)) {
                key = key.substring(12);
                //System.out.println(&quot;scriptID=&quot; + getID(scriptIDs, key) + &quot;/&quot; + key);
                awtfontpaths.put(getID(scriptIDs, key), getStringID(value));
            } else if (&quot;version&quot;.equals(key)) {
                version = value;
            } else if (&quot;appendedfontpath&quot;.equals(key)) {
                appendedfontpath = value;
            } else if (key.startsWith(&quot;proportional.&quot;)) {
                key = key.substring(13).replace('_', ' ');
                //System.out.println(key + &quot;=&quot; + value);
                proportionals.put(getID(componentFontNameIDs, key),
                                  getID(componentFontNameIDs, value));
            } else {
                //&quot;name.style.script(.motif)&quot;, we don't care anything else
                int dot1, dot2;
                boolean isMotif = false;

                dot1 = key.indexOf('.');
                if (dot1 == -1) {
                    if (logger != null) {
                        logger.config(&quot;Failed parsing &quot; + key +
                                  &quot; property of font configuration.&quot;);

                    }
                    return;
                }
                dot2 = key.indexOf('.', dot1 + 1);
                if (dot2 == -1) {
                    if (logger != null) {
                        logger.config(&quot;Failed parsing &quot; + key +
                                  &quot; property of font configuration.&quot;);

                    }
                    return;
                }
                if (key.endsWith(&quot;.motif&quot;)) {
                    key = key.substring(0, key.length() - 6);
                    isMotif = true;
                    //System.out.println(&quot;motif: &quot; + key + &quot;=&quot; + value);
                }
                Integer nameID = logicalFontIDs.get(key.substring(0, dot1));
                Integer styleID = fontStyleIDs.get(key.substring(dot1+1, dot2));
                Short scriptID = getID(scriptIDs, key.substring(dot2 + 1));
                if (nameID == null || styleID == null) {
                    if (logger != null) {
                        logger.config(&quot;unrecognizable logicfont name/style at &quot; + key);
                    }
                    return;
                }
                Short[] pnids;
                if (isMotif) {
                    pnids = scriptFontsMotif.get(scriptID);
                } else {
                    pnids = scriptFonts.get(scriptID);
                }
                if (pnids == null) {
                    pnids =  new Short[20];
                }
                pnids[nameID.intValue() * NUM_STYLES + styleID.intValue()]
                  = getID(componentFontNameIDs, value);
                /*
                System.out.println(&quot;key=&quot; + key + &quot;/&lt;&quot; + nameID + &quot;&gt;&lt;&quot; + styleID
                                     + &quot;&gt;&lt;&quot; + scriptID + &quot;&gt;=&quot; + value
                                     + &quot;/&quot; + getID(componentFontNameIDs, value));
                */
                if (isMotif) {
                    scriptFontsMotif.put(scriptID, pnids);
                } else {
                    scriptFonts.put(scriptID, pnids);
                }
            }
        }
    }
}
</pre>
</body>
</html>
