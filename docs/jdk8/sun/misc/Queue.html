<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.misc;

import java.util.Enumeration;
import java.util.NoSuchElementException;

/**
 * Queue: implements a simple queue mechanism.  Allows for enumeration of the
 * elements.
 *
 * @author Herb Jellinek
 */

public class Queue&lt;T&gt; {

    int length = 0;

    QueueElement&lt;T&gt; head = null;
    QueueElement&lt;T&gt; tail = null;

    public Queue() {
    }

    /**
     * Enqueue an object.
     */
    public synchronized void enqueue(T obj) {

        QueueElement&lt;T&gt; newElt = new QueueElement&lt;&gt;(obj);

        if (head == null) {
            head = newElt;
            tail = newElt;
            length = 1;
        } else {
            newElt.next = head;
            head.prev = newElt;
            head = newElt;
            length++;
        }
        notify();
    }

    /**
     * Dequeue the oldest object on the queue.  Will wait indefinitely.
     *
     * @return    the oldest object on the queue.
     * @exception java.lang.InterruptedException if any thread has
     *              interrupted this thread.
     */
    public T dequeue() throws InterruptedException {
        return dequeue(0L);
    }

    /**
     * Dequeue the oldest object on the queue.
     * @param timeOut the number of milliseconds to wait for something
     * to arrive.
     *
     * @return    the oldest object on the queue.
     * @exception java.lang.InterruptedException if any thread has
     *              interrupted this thread.
     */
    public synchronized T dequeue(long timeOut)
        throws InterruptedException {

        while (tail == null) {
            wait(timeOut);
        }
        QueueElement&lt;T&gt; elt = tail;
        tail = elt.prev;
        if (tail == null) {
            head = null;
        } else {
            tail.next = null;
        }
        length--;
        return elt.obj;
    }

    /**
     * Is the queue empty?
     * @return true if the queue is empty.
     */
    public synchronized boolean isEmpty() {
        return (tail == null);
    }

    /**
     * Returns an enumeration of the elements in Last-In, First-Out
     * order. Use the Enumeration methods on the returned object to
     * fetch the elements sequentially.
     */
    public final synchronized Enumeration&lt;T&gt; elements() {
        return new LIFOQueueEnumerator&lt;&gt;(this);
    }

    /**
     * Returns an enumeration of the elements in First-In, First-Out
     * order. Use the Enumeration methods on the returned object to
     * fetch the elements sequentially.
     */
    public final synchronized Enumeration&lt;T&gt; reverseElements() {
        return new FIFOQueueEnumerator&lt;&gt;(this);
    }

    public synchronized void dump(String msg) {
        System.err.println(&quot;&gt;&gt; &quot;+msg);
        System.err.println(&quot;[&quot;+length+&quot; elt(s); head = &quot;+
                           (head == null ? &quot;null&quot; : (head.obj)+&quot;&quot;)+
                           &quot; tail = &quot;+(tail == null ? &quot;null&quot; : (tail.obj)+&quot;&quot;));
        QueueElement&lt;T&gt; cursor = head;
        QueueElement&lt;T&gt; last = null;
        while (cursor != null) {
            System.err.println(&quot;  &quot;+cursor);
            last = cursor;
            cursor = cursor.next;
        }
        if (last != tail) {
            System.err.println(&quot;  tail != last: &quot;+tail+&quot;, &quot;+last);
        }
        System.err.println(&quot;]&quot;);
    }
}

final class FIFOQueueEnumerator&lt;T&gt; implements Enumeration&lt;T&gt; {
    Queue&lt;T&gt; queue;
    QueueElement&lt;T&gt; cursor;

    FIFOQueueEnumerator(Queue&lt;T&gt; q) {
        queue = q;
        cursor = q.tail;
    }

    public boolean hasMoreElements() {
        return (cursor != null);
    }

    public T nextElement() {
        synchronized (queue) {
            if (cursor != null) {
                QueueElement&lt;T&gt; result = cursor;
                cursor = cursor.prev;
                return result.obj;
            }
        }
        throw new NoSuchElementException(&quot;FIFOQueueEnumerator&quot;);
    }
}

final class LIFOQueueEnumerator&lt;T&gt; implements Enumeration&lt;T&gt; {
    Queue&lt;T&gt; queue;
    QueueElement&lt;T&gt; cursor;

    LIFOQueueEnumerator(Queue&lt;T&gt; q) {
        queue = q;
        cursor = q.head;
    }

    public boolean hasMoreElements() {
        return (cursor != null);
    }

    public T nextElement() {
        synchronized (queue) {
            if (cursor != null) {
                QueueElement&lt;T&gt; result = cursor;
                cursor = cursor.next;
                return result.obj;
            }
        }
        throw new NoSuchElementException(&quot;LIFOQueueEnumerator&quot;);
    }
}

class QueueElement&lt;T&gt; {
    QueueElement&lt;T&gt; next = null;
    QueueElement&lt;T&gt; prev = null;

    T obj = null;

    QueueElement(T obj) {
        this.obj = obj;
    }

    public String toString() {
        return &quot;QueueElement[obj=&quot;+obj+(prev == null ? &quot; null&quot; : &quot; prev&quot;)+
            (next == null ? &quot; null&quot; : &quot; next&quot;)+&quot;]&quot;;
    }
}
</pre>
</body>
</html>
