<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2002, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package sun.misc;

import java.nio.ByteBuffer;
import java.security.Permission;
import java.security.PrivilegedAction;
import java.io.IOException;
import java.io.UnsupportedEncodingException;

/**
 * The Perf class provides the ability to attach to an instrumentation
 * buffer maintained by a Java virtual machine. The instrumentation
 * buffer may be for the Java virtual machine running the methods of
 * this class or it may be for another Java virtual machine on the
 * same system.
 * &lt;p&gt;
 * In addition, this class provides methods to create instrumentation
 * objects in the instrumentation buffer for the Java virtual machine
 * that is running these methods. It also contains methods for acquiring
 * the value of a platform specific high resolution clock for time
 * stamp and interval measurement purposes.
 *
 * @author   Brian Doherty
 * @since    1.4.2
 * @see      #getPerf
 * @see      sun.misc.Perf$GetPerfAction
 * @see      java.nio.ByteBuffer
 */
public final class Perf {

    private static Perf instance;

    private static final int PERF_MODE_RO = 0;
    private static final int PERF_MODE_RW = 1;

    private Perf() { }    // prevent instantiation

    /**
     * The GetPerfAction class is a convenience class for acquiring access
     * to the singleton Perf instance using the
     * &lt;code&gt;AccessController.doPrivileged()&lt;/code&gt; method.
     * &lt;p&gt;
     * An instance of this class can be used as the argument to
     * &lt;code&gt;AccessController.doPrivileged(PrivilegedAction)&lt;/code&gt;.
     * &lt;p&gt; Here is a suggested idiom for use of this class:
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     * class MyTrustedClass {
     *   private static final Perf perf =
     *       AccessController.doPrivileged(new Perf.GetPerfAction&lt;Perf&gt;());
     *   ...
     * }
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * In the presence of a security manager, the &lt;code&gt;MyTrustedClass&lt;/code&gt;
     * class in the above example will need to be granted the
     * &lt;em&gt;&quot;sun.misc.Perf.getPerf&quot;&lt;/em&gt; &lt;code&gt;RuntimePermission&lt;/code&gt;
     * permission in order to successfully acquire the singleton Perf instance.
     * &lt;p&gt;
     * Please note that the &lt;em&gt;&quot;sun.misc.Perf.getPerf&quot;&lt;/em&gt; permission
     * is not a JDK specified permission.
     *
     * @see  java.security.AccessController#doPrivileged(PrivilegedAction)
     * @see  java.lang.RuntimePermission
     */
    public static class GetPerfAction implements PrivilegedAction&lt;Perf&gt;
    {
        /**
         * Run the &lt;code&gt;Perf.getPerf()&lt;/code&gt; method in a privileged context.
         *
         * @see #getPerf
         */
        public Perf run() {
            return getPerf();
        }
    }

    /**
     * Return a reference to the singleton Perf instance.
     * &lt;p&gt;
     * The getPerf() method returns the singleton instance of the Perf
     * class. The returned object provides the caller with the capability
     * for accessing the instrumentation buffer for this or another local
     * Java virtual machine.
     * &lt;p&gt;
     * If a security manager is installed, its &lt;code&gt;checkPermission&lt;/code&gt;
     * method is called with a &lt;code&gt;RuntimePermission&lt;/code&gt; with a target
     * of &lt;em&gt;&quot;sun.misc.Perf.getPerf&quot;&lt;/em&gt;. A security exception will result
     * if the caller has not been granted this permission.
     * &lt;p&gt;
     * Access to the returned &lt;code&gt;Perf&lt;/code&gt; object should be protected
     * by its caller and not passed on to untrusted code. This object can
     * be used to attach to the instrumentation buffer provided by this Java
     * virtual machine or for those of other Java virtual machines running
     * on the same system. The instrumentation buffer may contain senstitive
     * information. API's built on top of this interface may want to provide
     * finer grained access control to the contents of individual
     * instrumentation objects contained within the buffer.
     * &lt;p&gt;
     * Please note that the &lt;em&gt;&quot;sun.misc.Perf.getPerf&quot;&lt;/em&gt; permission
     * is not a JDK specified permission.
     *
     * @return       A reference to the singleton Perf instance.
     * @throws AccessControlException  if a security manager exists and
     *               its &lt;code&gt;checkPermission&lt;/code&gt; method doesn't allow
     *               access to the &lt;em&gt;&quot;sun.misc.Perf.getPerf&quot;&lt;/em&gt; target.
     * @see  java.lang.RuntimePermission
     * @see  #attach
     */
    public static Perf getPerf()
    {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            Permission perm = new RuntimePermission(&quot;sun.misc.Perf.getPerf&quot;);
            security.checkPermission(perm);
        }

        return instance;
    }

    /**
     * Attach to the instrumentation buffer for the specified Java virtual
     * machine.
     * &lt;p&gt;
     * This method will attach to the instrumentation buffer for the
     * specified virtual machine. It returns a &lt;code&gt;ByteBuffer&lt;/code&gt; object
     * that is initialized to access the instrumentation buffer for the
     * indicated Java virtual machine. The &lt;code&gt;lvmid&lt;/code&gt; parameter is
     * a integer value that uniquely identifies the target local Java virtual
     * machine. It is typically, but not necessarily, the process id of
     * the target Java virtual machine.
     * &lt;p&gt;
     * If the &lt;code&gt;lvmid&lt;/code&gt; identifies a Java virtual machine different
     * from the one running this method, then the coherency characteristics
     * of the buffer are implementation dependent. Implementations that do
     * not support named, coherent, shared memory may return a
     * &lt;code&gt;ByteBuffer&lt;/code&gt; object that contains only a snap shot of the
     * data in the instrumentation buffer. Implementations that support named,
     * coherent, shared memory, may return a &lt;code&gt;ByteBuffer&lt;/code&gt; object
     * that will be changing dynamically over time as the target Java virtual
     * machine updates its mapping of this buffer.
     * &lt;p&gt;
     * If the &lt;code&gt;lvmid&lt;/code&gt; is 0 or equal to the actual &lt;code&gt;lvmid&lt;/code&gt;
     * for the Java virtual machine running this method, then the returned
     * &lt;code&gt;ByteBuffer&lt;/code&gt; object will always be coherent and dynamically
     * changing.
     * &lt;p&gt;
     * The attach mode specifies the access permissions requested for the
     * instrumentation buffer of the target virtual machine. The permitted
     * access permissions are:
     * &lt;p&gt;
     * &lt;bl&gt;
     * &lt;li&gt;&quot;r&quot;  - Read only access. This Java virtual machine has only
     * read access to the instrumentation buffer for the target Java
     * virtual machine.
     * &lt;li&gt;&quot;rw&quot;  - Read/Write access. This Java virtual machine has read and
     * write access to the instrumentation buffer for the target Java virtual
     * machine. This mode is currently not supported and is reserved for
     * future enhancements.
     * &lt;/bl&gt;
     *
     * @param   lvmid            an integer that uniquely identifies the
     *                           target local Java virtual machine.
     * @param   mode             a string indicating the attach mode.
     * @return  ByteBuffer       a direct allocated byte buffer
     * @throws  IllegalArgumentException  The lvmid or mode was invalid.
     * @throws  IOException      An I/O error occurred while trying to acquire
     *                           the instrumentation buffer.
     * @throws  OutOfMemoryError The instrumentation buffer could not be mapped
     *                           into the virtual machine's address space.
     * @see     java.nio.ByteBuffer
     */
    public ByteBuffer attach(int lvmid, String mode)
           throws IllegalArgumentException, IOException
    {
        if (mode.compareTo(&quot;r&quot;) == 0) {
            return attachImpl(null, lvmid, PERF_MODE_RO);
        }
        else if (mode.compareTo(&quot;rw&quot;) == 0) {
            return attachImpl(null, lvmid, PERF_MODE_RW);
        }
        else {
            throw new IllegalArgumentException(&quot;unknown mode&quot;);
        }
    }

    /**
     * Attach to the instrumentation buffer for the specified Java virtual
     * machine owned by the given user.
     * &lt;p&gt;
     * This method behaves just as the &lt;code&gt;attach(int lvmid, String mode)
     * &lt;/code&gt; method, except that it only searches for Java virtual machines
     * owned by the specified user.
     *
     * @param   user             A &lt;code&gt;String&lt;/code&gt; object containing the
     *                           name of the user that owns the target Java
     *                           virtual machine.
     * @param   lvmid            an integer that uniquely identifies the
     *                           target local Java virtual machine.
     * @param   mode             a string indicating the attach mode.
     * @return  ByteBuffer       a direct allocated byte buffer
     * @throws  IllegalArgumentException  The lvmid or mode was invalid.
     * @throws  IOException      An I/O error occurred while trying to acquire
     *                           the instrumentation buffer.
     * @throws  OutOfMemoryError The instrumentation buffer could not be mapped
     *                           into the virtual machine's address space.
     * @see     java.nio.ByteBuffer
     */
    public ByteBuffer attach(String user, int lvmid, String mode)
           throws IllegalArgumentException, IOException
    {
        if (mode.compareTo(&quot;r&quot;) == 0) {
            return attachImpl(user, lvmid, PERF_MODE_RO);
        }
        else if (mode.compareTo(&quot;rw&quot;) == 0) {
            return attachImpl(user, lvmid, PERF_MODE_RW);
        }
        else {
            throw new IllegalArgumentException(&quot;unknown mode&quot;);
        }
    }

    /**
     * Call the implementation specific attach method.
     * &lt;p&gt;
     * This method calls into the Java virtual machine to perform the platform
     * specific attach method. Buffers returned from this method are
     * internally managed as &lt;code&gt;PhantomRefereces&lt;/code&gt; to provide for
     * guaranteed, secure release of the native resources.
     *
     * @param   user             A &lt;code&gt;String&lt;/code&gt; object containing the
     *                           name of the user that owns the target Java
     *                           virtual machine.
     * @param   lvmid            an integer that uniquely identifies the
     *                           target local Java virtual machine.
     * @param   mode             a string indicating the attach mode.
     * @return  ByteBuffer       a direct allocated byte buffer
     * @throws  IllegalArgumentException  The lvmid or mode was invalid.
     * @throws  IOException      An I/O error occurred while trying to acquire
     *                           the instrumentation buffer.
     * @throws  OutOfMemoryError The instrumentation buffer could not be mapped
     *                           into the virtual machine's address space.
     */
    private ByteBuffer attachImpl(String user, int lvmid, int mode)
            throws IllegalArgumentException, IOException
    {
        final ByteBuffer b = attach(user, lvmid, mode);

        if (lvmid == 0) {
            // The native instrumentation buffer for this Java virtual
            // machine is never unmapped.
            return b;
        }
        else {
            // This is an instrumentation buffer for another Java virtual
            // machine with native resources that need to be managed. We
            // create a duplicate of the native ByteBuffer and manage it
            // with a Cleaner object (PhantomReference). When the duplicate
            // becomes only phantomly reachable, the native resources will
            // be released.

            final ByteBuffer dup = b.duplicate();
            Cleaner.create(dup, new Runnable() {
                    public void run() {
                        try {
                            instance.detach(b);
                        }
                        catch (Throwable th) {
                            // avoid crashing the reference handler thread,
                            // but provide for some diagnosability
                            assert false : th.toString();
                        }
                    }
                });
            return dup;
        }
    }

    /**
     * Native method to perform the implementation specific attach mechanism.
     * &lt;p&gt;
     * The implementation of this method may return distinct or identical
     * &lt;code&gt;ByteBuffer&lt;/code&gt; objects for two distinct calls requesting
     * attachment to the same Java virtual machine.
     * &lt;p&gt;
     * For the Sun HotSpot JVM, two distinct calls to attach to the same
     * target Java virtual machine will result in two distinct ByteBuffer
     * objects returned by this method. This may change in a future release.
     *
     * @param   user             A &lt;code&gt;String&lt;/code&gt; object containing the
     *                           name of the user that owns the target Java
     *                           virtual machine.
     * @param   lvmid            an integer that uniquely identifies the
     *                           target local Java virtual machine.
     * @param   mode             a string indicating the attach mode.
     * @return  ByteBuffer       a direct allocated byte buffer
     * @throws  IllegalArgumentException  The lvmid or mode was invalid.
     * @throws  IOException      An I/O error occurred while trying to acquire
     *                           the instrumentation buffer.
     * @throws  OutOfMemoryError The instrumentation buffer could not be mapped
     *                           into the virtual machine's address space.
     */
    private native ByteBuffer attach(String user, int lvmid, int mode)
                   throws IllegalArgumentException, IOException;

    /**
     * Native method to perform the implementation specific detach mechanism.
     * &lt;p&gt;
     * If this method is passed a &lt;code&gt;ByteBuffer&lt;/code&gt; object that is
     * not created by the &lt;code&gt;attach&lt;/code&gt; method, then the results of
     * this method are undefined, with unpredictable and potentially damaging
     * effects to the Java virtual machine. To prevent accidental or malicious
     * use of this method, all native ByteBuffer created by the &lt;code&gt;
     * attach&lt;/code&gt; method are managed internally as PhantomReferences
     * and resources are freed by the system.
     * &lt;p&gt;
     * If this method is passed a &lt;code&gt;ByteBuffer&lt;/code&gt; object created
     * by the &lt;code&gt;attach&lt;/code&gt; method with a lvmid for the Java virtual
     * machine running this method (lvmid=0, for example), then the detach
     * request is silently ignored.
     *
     * @param ByteBuffer  A direct allocated byte buffer created by the
     *                    &lt;code&gt;attach&lt;/code&gt; method.
     * @see   java.nio.ByteBuffer
     * @see   #attach
     */
    private native void detach(ByteBuffer bb);

    /**
     * Create a &lt;code&gt;long&lt;/code&gt; scalar entry in the instrumentation buffer
     * with the given variability characteristic, units, and initial value.
     * &lt;p&gt;
     * Access to the instrument is provided through the returned &lt;code&gt;
     * ByteBuffer&lt;/code&gt; object. Typically, this object should be wrapped
     * with &lt;code&gt;LongBuffer&lt;/code&gt; view object.
     *
     * @param   variability the variability characteristic for this entry.
     * @param   units       the units for this entry.
     * @param   name        the name of this entry.
     * @param   value       the initial value for this entry.
     * @return  ByteBuffer  a direct allocated ByteBuffer object that
     *                      allows write access to a native memory location
     *                      containing a &lt;code&gt;long&lt;/code&gt; value.
     *
     * see sun.misc.perf.Variability
     * see sun.misc.perf.Units
     * @see java.nio.ByteBuffer
     */
    public native ByteBuffer createLong(String name, int variability,
                                        int units, long value);

    /**
     * Create a &lt;code&gt;String&lt;/code&gt; entry in the instrumentation buffer with
     * the given variability characteristic, units, and initial value.
     * &lt;p&gt;
     * The maximum length of the &lt;code&gt;String&lt;/code&gt; stored in this string
     * instrument is given in by &lt;code&gt;maxLength&lt;/code&gt; parameter. Updates
     * to this instrument with &lt;code&gt;String&lt;/code&gt; values with lengths greater
     * than &lt;code&gt;maxLength&lt;/code&gt; will be truncated to &lt;code&gt;maxLength&lt;/code&gt;.
     * The truncated value will be terminated by a null character.
     * &lt;p&gt;
     * The underlying implementation may further limit the length of the
     * value, but will continue to preserve the null terminator.
     * &lt;p&gt;
     * Access to the instrument is provided through the returned &lt;code&gt;
     * ByteBuffer&lt;/code&gt; object.
     *
     * @param   variability the variability characteristic for this entry.
     * @param   units       the units for this entry.
     * @param   name        the name of this entry.
     * @param   value       the initial value for this entry.
     * @param   maxLength   the maximum string length for this string
     *                      instrument.
     * @return  ByteBuffer  a direct allocated ByteBuffer that allows
     *                      write access to a native memory location
     *                      containing a &lt;code&gt;long&lt;/code&gt; value.
     *
     * see sun.misc.perf.Variability
     * see sun.misc.perf.Units
     * @see java.nio.ByteBuffer
     */
    public ByteBuffer createString(String name, int variability,
                                   int units, String value, int maxLength)
    {
        byte[] v = getBytes(value);
        byte[] v1 = new byte[v.length+1];
        System.arraycopy(v, 0, v1, 0, v.length);
        v1[v.length] = '\0';
        return createByteArray(name, variability, units, v1, Math.max(v1.length, maxLength));
    }

    /**
     * Create a &lt;code&gt;String&lt;/code&gt; entry in the instrumentation buffer with
     * the given variability characteristic, units, and initial value.
     * &lt;p&gt;
     * The maximum length of the &lt;code&gt;String&lt;/code&gt; stored in this string
     * instrument is implied by the length of the &lt;code&gt;value&lt;/code&gt; parameter.
     * Subsequent updates to the value of this instrument will be truncated
     * to this implied maximum length. The truncated value will be terminated
     * by a null character.
     * &lt;p&gt;
     * The underlying implementation may further limit the length of the
     * initial or subsequent value, but will continue to preserve the null
     * terminator.
     * &lt;p&gt;
     * Access to the instrument is provided through the returned &lt;code&gt;
     * ByteBuffer&lt;/code&gt; object.
     *
     * @param   variability the variability characteristic for this entry.
     * @param   units       the units for this entry.
     * @param   name        the name of this entry.
     * @param   value       the initial value for this entry.
     * @return  ByteBuffer  a direct allocated ByteBuffer that allows
     *                      write access to a native memory location
     *                      containing a &lt;code&gt;long&lt;/code&gt; value.
     *
     * see sun.misc.perf.Variability
     * see sun.misc.perf.Units
     * @see java.nio.ByteBuffer
     */
    public ByteBuffer createString(String name, int variability,
                                   int units, String value)
    {
        byte[] v = getBytes(value);
        byte[] v1 = new byte[v.length+1];
        System.arraycopy(v, 0, v1, 0, v.length);
        v1[v.length] = '\0';
        return createByteArray(name, variability, units, v1, v1.length);
    }

    /**
     * Create a &lt;code&gt;byte&lt;/code&gt; vector entry in the instrumentation buffer
     * with the given variability characteristic, units, and initial value.
     * &lt;p&gt;
     * The &lt;code&gt;maxLength&lt;/code&gt; parameter limits the size of the byte
     * array instrument such that the initial or subsequent updates beyond
     * this length are silently ignored. No special handling of truncated
     * updates is provided.
     * &lt;p&gt;
     * The underlying implementation may further limit the length of the
     * length of the initial or subsequent value.
     * &lt;p&gt;
     * Access to the instrument is provided through the returned &lt;code&gt;
     * ByteBuffer&lt;/code&gt; object.
     *
     * @param   variability the variability characteristic for this entry.
     * @param   units       the units for this entry.
     * @param   name        the name of this entry.
     * @param   value       the initial value for this entry.
     * @param   maxLength   the maximum length of this byte array.
     * @return  ByteBuffer  a direct allocated byte buffer that allows
     *                      write access to a native memory location
     *                      containing a &lt;code&gt;long&lt;/code&gt; value.
     *
     * see sun.misc.perf.Variability
     * see sun.misc.perf.Units
     * @see java.nio.ByteBuffer
     */
    public native ByteBuffer createByteArray(String name, int variability,
                                             int units, byte[] value,
                                             int maxLength);


    /**
     * convert string to an array of UTF-8 bytes
     */
    private static byte[] getBytes(String s)
    {
        byte[] bytes = null;

        try {
            bytes = s.getBytes(&quot;UTF-8&quot;);
        }
        catch (UnsupportedEncodingException e) {
            // ignore, UTF-8 encoding is always known
        }

        return bytes;
    }

    /**
     * Return the value of the High Resolution Counter.
     *
     * The High Resolution Counter returns the number of ticks since
     * since the start of the Java virtual machine. The resolution of
     * the counter is machine dependent and can be determined from the
     * value return by the {@link #highResFrequency} method.
     *
     * @return  the number of ticks of machine dependent resolution since
     *          the start of the Java virtual machine.
     *
     * @see #highResFrequency
     * @see java.lang.System#currentTimeMillis()
     */
    public native long highResCounter();

    /**
     * Returns the frequency of the High Resolution Counter, in ticks per
     * second.
     *
     * This value can be used to convert the value of the High Resolution
     * Counter, as returned from a call to the {@link #highResCounter} method,
     * into the number of seconds since the start of the Java virtual machine.
     *
     * @return  the frequency of the High Resolution Counter.
     * @see #highResCounter
     */
    public native long highResFrequency();

    private static native void registerNatives();

    static {
        registerNatives();
        instance = new Perf();
    }
}
</pre>
</body>
</html>
