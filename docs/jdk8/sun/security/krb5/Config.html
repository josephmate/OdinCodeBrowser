<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 *
 *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 */
package sun.security.krb5;

import java.io.File;
import java.io.FileInputStream;
import java.util.Hashtable;
import java.util.Vector;
import java.util.ArrayList;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.StringTokenizer;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.security.AccessController;
import java.security.PrivilegedExceptionAction;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import sun.net.dns.ResolverConfiguration;
import sun.security.krb5.internal.crypto.EType;
import sun.security.krb5.internal.Krb5;

/**
 * This class maintains key-value pairs of Kerberos configurable constants
 * from configuration file or from user specified system properties.
 */

public class Config {

    /*
     * Only allow a single instance of Config.
     */
    private static Config singleton = null;

    /*
     * Hashtable used to store configuration information.
     */
    private Hashtable&lt;String,Object&gt; stanzaTable = new Hashtable&lt;&gt;();

    private static boolean DEBUG = sun.security.krb5.internal.Krb5.DEBUG;

    // these are used for hexdecimal calculation.
    private static final int BASE16_0 = 1;
    private static final int BASE16_1 = 16;
    private static final int BASE16_2 = 16 * 16;
    private static final int BASE16_3 = 16 * 16 * 16;

    /**
     * Specified by system properties. Must be both null or non-null.
     */
    private final String defaultRealm;
    private final String defaultKDC;

    // used for native interface
    private static native String getWindowsDirectory(boolean isSystem);


    /**
     * Gets an instance of Config class. One and only one instance (the
     * singleton) is returned.
     *
     * @exception KrbException if error occurs when constructing a Config
     * instance. Possible causes would be either of java.security.krb5.realm or
     * java.security.krb5.kdc not specified, error reading configuration file.
     */
    public static synchronized Config getInstance() throws KrbException {
        if (singleton == null) {
            singleton = new Config();
        }
        return singleton;
    }

    /**
     * Refresh and reload the Configuration. This could involve,
     * for example reading the Configuration file again or getting
     * the java.security.krb5.* system properties again. This method
     * also tries its best to update static fields in other classes
     * that depend on the configuration.
     *
     * @exception KrbException if error occurs when constructing a Config
     * instance. Possible causes would be either of java.security.krb5.realm or
     * java.security.krb5.kdc not specified, error reading configuration file.
     */

    public static synchronized void refresh() throws KrbException {
        singleton = new Config();
        KdcComm.initStatic();
        EType.initStatic();
        Checksum.initStatic();
    }


    private static boolean isMacosLionOrBetter() {
        // split the &quot;10.x.y&quot; version number
        String osname = getProperty(&quot;os.name&quot;);
        if (!osname.contains(&quot;OS X&quot;)) {
            return false;
        }

        String osVersion = getProperty(&quot;os.version&quot;);
        String[] fragments = osVersion.split(&quot;\\.&quot;);

        // sanity check the &quot;10.&quot; part of the version
        if (!fragments[0].equals(&quot;10&quot;)) return false;
        if (fragments.length &lt; 2) return false;

        // check if Mac OS X 10.7(.y)
        try {
            int minorVers = Integer.parseInt(fragments[1]);
            if (minorVers &gt;= 7) return true;
        } catch (NumberFormatException e) {
            // was not an integer
        }

        return false;
    }

    /**
     * Private constructor - can not be instantiated externally.
     */
    private Config() throws KrbException {
        /*
         * If either one system property is specified, we throw exception.
         */
        String tmp = getProperty(&quot;java.security.krb5.kdc&quot;);
        if (tmp != null) {
            // The user can specify a list of kdc hosts separated by &quot;:&quot;
            defaultKDC = tmp.replace(':', ' ');
        } else {
            defaultKDC = null;
        }
        defaultRealm = getProperty(&quot;java.security.krb5.realm&quot;);
        if ((defaultKDC == null &amp;&amp; defaultRealm != null) ||
            (defaultRealm == null &amp;&amp; defaultKDC != null)) {
            throw new KrbException
                (&quot;System property java.security.krb5.kdc and &quot; +
                 &quot;java.security.krb5.realm both must be set or &quot; +
                 &quot;neither must be set.&quot;);
        }

        // Always read the Kerberos configuration file
        try {
            List&lt;String&gt; configFile;
            String fileName = getJavaFileName();
            if (fileName != null) {
                configFile = loadConfigFile(fileName);
                stanzaTable = parseStanzaTable(configFile);
                if (DEBUG) {
                    System.out.println(&quot;Loaded from Java config&quot;);
                }
            } else {
                boolean found = false;
                if (isMacosLionOrBetter()) {
                    try {
                        stanzaTable = SCDynamicStoreConfig.getConfig();
                        if (DEBUG) {
                            System.out.println(&quot;Loaded from SCDynamicStoreConfig&quot;);
                        }
                        found = true;
                    } catch (IOException ioe) {
                        // OK. Will go on with file
                    }
                }
                if (!found) {
                    fileName = getNativeFileName();
                    configFile = loadConfigFile(fileName);
                    stanzaTable = parseStanzaTable(configFile);
                    if (DEBUG) {
                        System.out.println(&quot;Loaded from native config&quot;);
                    }
                }
            }
        } catch (IOException ioe) {
            // I/O error, mostly like krb5.conf missing.
            // No problem. We'll use DNS or system property etc.
        }
    }

    /**
     * Gets the last-defined string value for the specified keys.
     * @param keys the keys, as an array from section name, sub-section names
     * (if any), to value name.
     * @return the value. When there are multiple values for the same key,
     * returns the last one. {@code null} is returned if not all the keys are
     * defined. For example, {@code get(&quot;libdefaults&quot;, &quot;forwardable&quot;)} will
     * return null if &quot;forwardable&quot; is not defined in [libdefaults], and
     * {@code get(&quot;realms&quot;, &quot;R&quot;, &quot;kdc&quot;)} will return null if &quot;R&quot; is not
     * defined in [realms] or &quot;kdc&quot; is not defined for &quot;R&quot;.
     * @throws IllegalArgumentException if any of the keys is illegal, either
     * because a key not the last one is not a (sub)section name or the last
     * key is still a section name. For example, {@code get(&quot;libdefaults&quot;)}
     * throws this exception because [libdefaults] is a section name instead of
     * a value name, and {@code get(&quot;libdefaults&quot;, &quot;forwardable&quot;, &quot;tail&quot;)}
     * also throws this exception because &quot;forwardable&quot; is already a value name
     * and has no sub-key at all (given &quot;forwardable&quot; is defined, otherwise,
     * this method has no knowledge if it's a value name or a section name),
     */
    public String get(String... keys) {
        Vector&lt;String&gt; v = getString0(keys);
        if (v == null) return null;
        return v.lastElement();
    }

    /**
     * Gets all values for the specified keys.
     * @throws IllegalArgumentException if any of the keys is illegal
     *         (See {@link #get})
     */
    public String getAll(String... keys) {
        Vector&lt;String&gt; v = getString0(keys);
        if (v == null) return null;
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (String s: v) {
            if (first) {
                sb.append(s);
                first = false;
            } else {
                sb.append(' ').append(s);
            }
        }
        return sb.toString();
    }

    /**
     * Returns true if keys exists, can be either final string(s) or sub-stanza
     * @throws IllegalArgumentException if any of the keys is illegal
     *         (See {@link #get})
     */
    public boolean exists(String... keys) {
        return get0(keys) != null;
    }

    // Returns final string value(s) for given keys.
    @SuppressWarnings(&quot;unchecked&quot;)
    private Vector&lt;String&gt; getString0(String... keys) {
        try {
            return (Vector&lt;String&gt;)get0(keys);
        } catch (ClassCastException cce) {
            throw new IllegalArgumentException(cce);
        }
    }

    // Internal method. Returns the value for keys, which can be a sub-stanza
    // or final string value(s).
    // The only method (except for toString) that reads stanzaTable directly.
    @SuppressWarnings(&quot;unchecked&quot;)
    private Object get0(String... keys) {
        Object current = stanzaTable;
        try {
            for (String key: keys) {
                current = ((Hashtable&lt;String,Object&gt;)current).get(key);
                if (current == null) return null;
            }
            return current;
        } catch (ClassCastException cce) {
            throw new IllegalArgumentException(cce);
        }
    }

    /**
     * Gets the int value for the specified keys.
     * @param keys the keys
     * @return the int value, Integer.MIN_VALUE is returned if it cannot be
     * found or the value is not a legal integer.
     * @throw IllegalArgumentException if any of the keys is illegal
     * @see #get(java.lang.String[])
     */
    public int getIntValue(String... keys) {
        String result = get(keys);
        int value = Integer.MIN_VALUE;
        if (result != null) {
            try {
                value = parseIntValue(result);
            } catch (NumberFormatException e) {
                if (DEBUG) {
                    System.out.println(&quot;Exception in getting value of &quot; +
                                       Arrays.toString(keys) + &quot; &quot; +
                                       e.getMessage());
                    System.out.println(&quot;Setting &quot; + Arrays.toString(keys) +
                                       &quot; to minimum value&quot;);
                }
                value = Integer.MIN_VALUE;
            }
        }
        return value;
    }

    /**
     * Gets the boolean value for the specified keys.
     * @param keys the keys
     * @return the boolean value, false is returned if it cannot be
     * found or the value is not &quot;true&quot; (case insensitive).
     * @throw IllegalArgumentException if any of the keys is illegal
     * @see #get(java.lang.String[])
     */
    public boolean getBooleanValue(String... keys) {
        String val = get(keys);
        if (val != null &amp;&amp; val.equalsIgnoreCase(&quot;true&quot;)) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Parses a string to an integer. The convertible strings include the
     * string representations of positive integers, negative integers, and
     * hex decimal integers.  Valid inputs are, e.g., -1234, +1234,
     * 0x40000.
     *
     * @param input the String to be converted to an Integer.
     * @return an numeric value represented by the string
     * @exception NumberFormationException if the String does not contain a
     * parsable integer.
     */
    private int parseIntValue(String input) throws NumberFormatException {
        int value = 0;
        if (input.startsWith(&quot;+&quot;)) {
            String temp = input.substring(1);
            return Integer.parseInt(temp);
        } else if (input.startsWith(&quot;0x&quot;)) {
            String temp = input.substring(2);
            char[] chars = temp.toCharArray();
            if (chars.length &gt; 8) {
                throw new NumberFormatException();
            } else {
                for (int i = 0; i &lt; chars.length; i++) {
                    int index = chars.length - i - 1;
                    switch (chars[i]) {
                    case '0':
                        value += 0;
                        break;
                    case '1':
                        value += 1 * getBase(index);
                        break;
                    case '2':
                        value += 2 * getBase(index);
                        break;
                    case '3':
                        value += 3 * getBase(index);
                        break;
                    case '4':
                        value += 4 * getBase(index);
                        break;
                    case '5':
                        value += 5 * getBase(index);
                        break;
                    case '6':
                        value += 6 * getBase(index);
                        break;
                    case '7':
                        value += 7 * getBase(index);
                        break;
                    case '8':
                        value += 8 * getBase(index);
                        break;
                    case '9':
                        value += 9 * getBase(index);
                        break;
                    case 'a':
                    case 'A':
                        value += 10 * getBase(index);
                        break;
                    case 'b':
                    case 'B':
                        value += 11 * getBase(index);
                        break;
                    case 'c':
                    case 'C':
                        value += 12 * getBase(index);
                        break;
                    case 'd':
                    case 'D':
                        value += 13 * getBase(index);
                        break;
                    case 'e':
                    case 'E':
                        value += 14 * getBase(index);
                        break;
                    case 'f':
                    case 'F':
                        value += 15 * getBase(index);
                        break;
                    default:
                        throw new NumberFormatException(&quot;Invalid numerical format&quot;);
                    }
                }
            }
            if (value &lt; 0) {
                throw new NumberFormatException(&quot;Data overflow.&quot;);
            }
        } else {
            value = Integer.parseInt(input);
        }
        return value;
    }

    private int getBase(int i) {
        int result = 16;
        switch (i) {
        case 0:
            result = BASE16_0;
            break;
        case 1:
            result = BASE16_1;
            break;
        case 2:
            result = BASE16_2;
            break;
        case 3:
            result = BASE16_3;
            break;
        default:
            for (int j = 1; j &lt; i; j++) {
                result *= 16;
            }
        }
        return result;
    }

    /**
     * Reads lines to the memory from the configuration file.
     *
     * Configuration file contains information about the default realm,
     * ticket parameters, location of the KDC and the admin server for
     * known realms, etc. The file is divided into sections. Each section
     * contains one or more name/value pairs with one pair per line. A
     * typical file would be:
     * &lt;pre&gt;
     * [libdefaults]
     *          default_realm = EXAMPLE.COM
     *          default_tgs_enctypes = des-cbc-md5
     *          default_tkt_enctypes = des-cbc-md5
     * [realms]
     *          EXAMPLE.COM = {
     *                  kdc = kerberos.example.com
     *                  kdc = kerberos-1.example.com
     *                  admin_server = kerberos.example.com
     *                  }
     *          SAMPLE_COM = {
     *                  kdc = orange.sample.com
     *                  admin_server = orange.sample.com
     *                  }
     * [domain_realm]
     *          blue.sample.com = TEST.SAMPLE.COM
     *          .backup.com     = EXAMPLE.COM
     * &lt;/pre&gt;
     * @return an ordered list of strings representing the config file after
     * some initial processing, including:&lt;ol&gt;
     * &lt;li&gt; Comment lines and empty lines are removed
     * &lt;li&gt; &quot;{&quot; not at the end of a line is appended to the previous line
     * &lt;li&gt; The content of a section is also placed between &quot;{&quot; and &quot;}&quot;.
     * &lt;li&gt; Lines are trimmed&lt;/ol&gt;
     * @throws IOException if there is an I/O error
     * @throws KrbException if there is a file format error
     */
    private List&lt;String&gt; loadConfigFile(final String fileName)
            throws IOException, KrbException {
        try {
            List&lt;String&gt; v = new ArrayList&lt;&gt;();
            try (BufferedReader br = new BufferedReader(new InputStreamReader(
                AccessController.doPrivileged(
                    new PrivilegedExceptionAction&lt;FileInputStream&gt; () {
                        public FileInputStream run() throws IOException {
                            return new FileInputStream(fileName);
                        }
                    })))) {
                String line;
                String previous = null;
                while ((line = br.readLine()) != null) {
                    line = line.trim();
                    if (line.startsWith(&quot;#&quot;) || line.isEmpty()) {
                        // ignore comments and blank line
                        // Comments start with #.
                        continue;
                    }
                    // In practice, a subsection might look like:
                    //      [realms]
                    //      EXAMPLE.COM =
                    //      {
                    //          kdc = kerberos.example.com
                    //          ...
                    //      }
                    // Before parsed into stanza table, it needs to be
                    // converted into a canonicalized style (no indent):
                    //      realms = {
                    //          EXAMPLE.COM = {
                    //              kdc = kerberos.example.com
                    //              ...
                    //          }
                    //      }
                    //
                    if (line.startsWith(&quot;[&quot;)) {
                        if (!line.endsWith(&quot;]&quot;)) {
                            throw new KrbException(&quot;Illegal config content:&quot;
                                    + line);
                        }
                        if (previous != null) {
                            v.add(previous);
                            v.add(&quot;}&quot;);
                        }
                        String title = line.substring(
                                1, line.length()-1).trim();
                        if (title.isEmpty()) {
                            throw new KrbException(&quot;Illegal config content:&quot;
                                    + line);
                        }
                        previous = title + &quot; = {&quot;;
                    } else if (line.startsWith(&quot;{&quot;)) {
                        if (previous == null) {
                            throw new KrbException(
                                &quot;Config file should not start with \&quot;{\&quot;&quot;);
                        }
                        previous += &quot; {&quot;;
                        if (line.length() &gt; 1) {
                            // { and content on the same line
                            v.add(previous);
                            previous = line.substring(1).trim();
                        }
                    } else {
                        if (previous == null) {
                            throw new KrbException(
                                &quot;Config file must starts with a section&quot;);
                        }
                        v.add(previous);
                        previous = line;
                    }
                }
                if (previous != null) {
                    v.add(previous);
                    v.add(&quot;}&quot;);
                }
            }
            return v;
        } catch (java.security.PrivilegedActionException pe) {
            throw (IOException)pe.getException();
        }
    }

    /**
     * Parses stanza names and values from configuration file to
     * stanzaTable (Hashtable). Hashtable key would be stanza names,
     * (libdefaults, realms, domain_realms, etc), and the hashtable value
     * would be another hashtable which contains the key-value pairs under
     * a stanza name. The value of this sub-hashtable can be another hashtable
     * containing another sub-sub-section or a vector of strings for
     * final values (even if there is only one value defined).
     * &lt;p&gt;
     * For duplicates section names, the latter overwrites the former. For
     * duplicate value names, the values are in a vector in its appearing order.
     * &lt;/ol&gt;
     * Please note that this behavior is Java traditional. and it is
     * not the same as the MIT krb5 behavior, where:&lt;ol&gt;
     * &lt;li&gt;Duplicated root sections will be merged
     * &lt;li&gt;For duplicated sub-sections, the former overwrites the latter
     * &lt;li&gt;Duplicate keys for values are always saved in a vector
     * &lt;/ol&gt;
     * @param v the strings in the file, never null, might be empty
     * @throws KrbException if there is a file format error
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private Hashtable&lt;String,Object&gt; parseStanzaTable(List&lt;String&gt; v)
            throws KrbException {
        Hashtable&lt;String,Object&gt; current = stanzaTable;
        for (String line: v) {
            // There are 3 kinds of lines
            // 1. a = b
            // 2. a = {
            // 3. }
            if (line.equals(&quot;}&quot;)) {
                // Go back to parent, see below
                current = (Hashtable&lt;String,Object&gt;)current.remove(&quot; PARENT &quot;);
                if (current == null) {
                    throw new KrbException(&quot;Unmatched close brace&quot;);
                }
            } else {
                int pos = line.indexOf('=');
                if (pos &lt; 0) {
                    throw new KrbException(&quot;Illegal config content:&quot; + line);
                }
                String key = line.substring(0, pos).trim();
                String value = trimmed(line.substring(pos+1));
                if (value.equals(&quot;{&quot;)) {
                    Hashtable&lt;String,Object&gt; subTable;
                    if (current == stanzaTable) {
                        key = key.toLowerCase(Locale.US);
                    }
                    subTable = new Hashtable&lt;&gt;();
                    current.put(key, subTable);
                    // A special entry for its parent. Put whitespaces around,
                    // so will never be confused with a normal key
                    subTable.put(&quot; PARENT &quot;, current);
                    current = subTable;
                } else {
                    Vector&lt;String&gt; values;
                    if (current.containsKey(key)) {
                        Object obj = current.get(key);
                        // If a key first shows as a section and then a value,
                        // this is illegal. However, we haven't really forbid
                        // first value then section, which the final result
                        // is a section.
                        if (!(obj instanceof Vector)) {
                            throw new KrbException(&quot;Key &quot; + key
                                    + &quot;used for both value and section&quot;);
                        }
                        values = (Vector&lt;String&gt;)current.get(key);
                    } else {
                        values = new Vector&lt;String&gt;();
                        current.put(key, values);
                    }
                    values.add(value);
                }
            }
        }
        if (current != stanzaTable) {
            throw new KrbException(&quot;Not closed&quot;);
        }
        return current;
    }

    /**
     * Gets the default Java configuration file name.
     *
     * If the system property &quot;java.security.krb5.conf&quot; is defined, we'll
     * use its value, no matter if the file exists or not. Otherwise, we
     * will look at $JAVA_HOME/lib/security directory with &quot;krb5.conf&quot; name,
     * and return it if the file exists.
     *
     * The method returns null if it cannot find a Java config file.
     */
    private String getJavaFileName() {
        String name = getProperty(&quot;java.security.krb5.conf&quot;);
        if (name == null) {
            name = getProperty(&quot;java.home&quot;) + File.separator +
                                &quot;lib&quot; + File.separator + &quot;security&quot; +
                                File.separator + &quot;krb5.conf&quot;;
            if (!fileExists(name)) {
                name = null;
            }
        }
        if (DEBUG) {
            System.out.println(&quot;Java config name: &quot; + name);
        }
        return name;
    }

    /**
     * Gets the default native configuration file name.
     *
     * Depending on the OS type, the method returns the default native
     * kerberos config file name, which is at windows directory with
     * the name of &quot;krb5.ini&quot; for Windows, /etc/krb5/krb5.conf for Solaris,
     * /etc/krb5.conf otherwise. Mac OSX X has a different file name.
     *
     * Note: When the Terminal Service is started in Windows (from 2003),
     * there are two kinds of Windows directories: A system one (say,
     * C:\Windows), and a user-private one (say, C:\Users\Me\Windows).
     * We will first look for krb5.ini in the user-private one. If not
     * found, try the system one instead.
     *
     * This method will always return a non-null non-empty file name,
     * even if that file does not exist.
     */
    private String getNativeFileName() {
        String name = null;
        String osname = getProperty(&quot;os.name&quot;);
        if (osname.startsWith(&quot;Windows&quot;)) {
            try {
                Credentials.ensureLoaded();
            } catch (Exception e) {
                // ignore exceptions
            }
            if (Credentials.alreadyLoaded) {
                String path = getWindowsDirectory(false);
                if (path != null) {
                    if (path.endsWith(&quot;\\&quot;)) {
                        path = path + &quot;krb5.ini&quot;;
                    } else {
                        path = path + &quot;\\krb5.ini&quot;;
                    }
                    if (fileExists(path)) {
                        name = path;
                    }
                }
                if (name == null) {
                    path = getWindowsDirectory(true);
                    if (path != null) {
                        if (path.endsWith(&quot;\\&quot;)) {
                            path = path + &quot;krb5.ini&quot;;
                        } else {
                            path = path + &quot;\\krb5.ini&quot;;
                        }
                        name = path;
                    }
                }
            }
            if (name == null) {
                name = &quot;c:\\winnt\\krb5.ini&quot;;
            }
        } else if (osname.startsWith(&quot;SunOS&quot;)) {
            name =  &quot;/etc/krb5/krb5.conf&quot;;
        } else if (osname.contains(&quot;OS X&quot;)) {
            name = findMacosConfigFile();
        } else {
            name =  &quot;/etc/krb5.conf&quot;;
        }
        if (DEBUG) {
            System.out.println(&quot;Native config name: &quot; + name);
        }
        return name;
    }

    private static String getProperty(String property) {
        return java.security.AccessController.doPrivileged(
                new sun.security.action.GetPropertyAction(property));
    }

    private String findMacosConfigFile() {
        String userHome = getProperty(&quot;user.home&quot;);
        final String PREF_FILE = &quot;/Library/Preferences/edu.mit.Kerberos&quot;;
        String userPrefs = userHome + PREF_FILE;

        if (fileExists(userPrefs)) {
            return userPrefs;
        }

        if (fileExists(PREF_FILE)) {
            return PREF_FILE;
        }

        return &quot;/etc/krb5.conf&quot;;
    }

    private static String trimmed(String s) {
        s = s.trim();
        if (s.isEmpty()) return s;
        if (s.charAt(0) == '&quot;' &amp;&amp; s.charAt(s.length()-1) == '&quot;' ||
                s.charAt(0) == '\'' &amp;&amp; s.charAt(s.length()-1) == '\'') {
            s = s.substring(1, s.length()-1).trim();
        }
        return s;
    }

    /**
     * For testing purpose. This method lists all information being parsed from
     * the configuration file to the hashtable.
     */
    public void listTable() {
        System.out.println(this);
    }

    /**
     * Returns all etypes specified in krb5.conf for the given configName,
     * or all the builtin defaults. This result is always non-empty.
     * If no etypes are found, an exception is thrown.
     */
    public int[] defaultEtype(String configName) throws KrbException {
        String default_enctypes;
        default_enctypes = get(&quot;libdefaults&quot;, configName);
        int[] etype;
        if (default_enctypes == null) {
            if (DEBUG) {
                System.out.println(&quot;Using builtin default etypes for &quot; +
                    configName);
            }
            etype = EType.getBuiltInDefaults();
        } else {
            String delim = &quot; &quot;;
            StringTokenizer st;
            for (int j = 0; j &lt; default_enctypes.length(); j++) {
                if (default_enctypes.substring(j, j + 1).equals(&quot;,&quot;)) {
                    // only two delimiters are allowed to use
                    // according to Kerberos DCE doc.
                    delim = &quot;,&quot;;
                    break;
                }
            }
            st = new StringTokenizer(default_enctypes, delim);
            int len = st.countTokens();
            ArrayList&lt;Integer&gt; ls = new ArrayList&lt;&gt;(len);
            int type;
            for (int i = 0; i &lt; len; i++) {
                type = Config.getType(st.nextToken());
                if (type != -1 &amp;&amp; EType.isSupported(type)) {
                    ls.add(type);
                }
            }
            if (ls.isEmpty()) {
                throw new KrbException(&quot;no supported default etypes for &quot;
                        + configName);
            } else {
                etype = new int[ls.size()];
                for (int i = 0; i &lt; etype.length; i++) {
                    etype[i] = ls.get(i);
                }
            }
        }

        if (DEBUG) {
            System.out.print(&quot;default etypes for &quot; + configName + &quot;:&quot;);
            for (int i = 0; i &lt; etype.length; i++) {
                System.out.print(&quot; &quot; + etype[i]);
            }
            System.out.println(&quot;.&quot;);
        }
        return etype;
    }


    /**
     * Get the etype and checksum value for the specified encryption and
     * checksum type.
     *
     */
    /*
     * This method converts the string representation of encryption type and
     * checksum type to int value that can be later used by EType and
     * Checksum classes.
     */
    public static int getType(String input) {
        int result = -1;
        if (input == null) {
            return result;
        }
        if (input.startsWith(&quot;d&quot;) || (input.startsWith(&quot;D&quot;))) {
            if (input.equalsIgnoreCase(&quot;des-cbc-crc&quot;)) {
                result = EncryptedData.ETYPE_DES_CBC_CRC;
            } else if (input.equalsIgnoreCase(&quot;des-cbc-md5&quot;)) {
                result = EncryptedData.ETYPE_DES_CBC_MD5;
            } else if (input.equalsIgnoreCase(&quot;des-mac&quot;)) {
                result = Checksum.CKSUMTYPE_DES_MAC;
            } else if (input.equalsIgnoreCase(&quot;des-mac-k&quot;)) {
                result = Checksum.CKSUMTYPE_DES_MAC_K;
            } else if (input.equalsIgnoreCase(&quot;des-cbc-md4&quot;)) {
                result = EncryptedData.ETYPE_DES_CBC_MD4;
            } else if (input.equalsIgnoreCase(&quot;des3-cbc-sha1&quot;) ||
                input.equalsIgnoreCase(&quot;des3-hmac-sha1&quot;) ||
                input.equalsIgnoreCase(&quot;des3-cbc-sha1-kd&quot;) ||
                input.equalsIgnoreCase(&quot;des3-cbc-hmac-sha1-kd&quot;)) {
                result = EncryptedData.ETYPE_DES3_CBC_HMAC_SHA1_KD;
            }
        } else if (input.startsWith(&quot;a&quot;) || (input.startsWith(&quot;A&quot;))) {
            // AES
            if (input.equalsIgnoreCase(&quot;aes128-cts&quot;) ||
                input.equalsIgnoreCase(&quot;aes128-cts-hmac-sha1-96&quot;)) {
                result = EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96;
            } else if (input.equalsIgnoreCase(&quot;aes256-cts&quot;) ||
                input.equalsIgnoreCase(&quot;aes256-cts-hmac-sha1-96&quot;)) {
                result = EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96;
            // ARCFOUR-HMAC
            } else if (input.equalsIgnoreCase(&quot;arcfour-hmac&quot;) ||
                   input.equalsIgnoreCase(&quot;arcfour-hmac-md5&quot;)) {
                result = EncryptedData.ETYPE_ARCFOUR_HMAC;
            }
        // RC4-HMAC
        } else if (input.equalsIgnoreCase(&quot;rc4-hmac&quot;)) {
            result = EncryptedData.ETYPE_ARCFOUR_HMAC;
        } else if (input.equalsIgnoreCase(&quot;CRC32&quot;)) {
            result = Checksum.CKSUMTYPE_CRC32;
        } else if (input.startsWith(&quot;r&quot;) || (input.startsWith(&quot;R&quot;))) {
            if (input.equalsIgnoreCase(&quot;rsa-md5&quot;)) {
                result = Checksum.CKSUMTYPE_RSA_MD5;
            } else if (input.equalsIgnoreCase(&quot;rsa-md5-des&quot;)) {
                result = Checksum.CKSUMTYPE_RSA_MD5_DES;
            }
        } else if (input.equalsIgnoreCase(&quot;hmac-sha1-des3-kd&quot;)) {
            result = Checksum.CKSUMTYPE_HMAC_SHA1_DES3_KD;
        } else if (input.equalsIgnoreCase(&quot;hmac-sha1-96-aes128&quot;)) {
            result = Checksum.CKSUMTYPE_HMAC_SHA1_96_AES128;
        } else if (input.equalsIgnoreCase(&quot;hmac-sha1-96-aes256&quot;)) {
            result = Checksum.CKSUMTYPE_HMAC_SHA1_96_AES256;
        } else if (input.equalsIgnoreCase(&quot;hmac-md5-rc4&quot;) ||
                input.equalsIgnoreCase(&quot;hmac-md5-arcfour&quot;) ||
                input.equalsIgnoreCase(&quot;hmac-md5-enc&quot;)) {
            result = Checksum.CKSUMTYPE_HMAC_MD5_ARCFOUR;
        } else if (input.equalsIgnoreCase(&quot;NULL&quot;)) {
            result = EncryptedData.ETYPE_NULL;
        }

        return result;
    }

    /**
     * Resets the default kdc realm.
     * We do not need to synchronize these methods since assignments are atomic
     *
     * This method was useless. Kept here in case some class still calls it.
     */
    public void resetDefaultRealm(String realm) {
        if (DEBUG) {
            System.out.println(&quot;&gt;&gt;&gt; Config try resetting default kdc &quot; + realm);
        }
    }

    /**
     * Check to use addresses in tickets
     * use addresses if &quot;no_addresses&quot; or &quot;noaddresses&quot; is set to false
     */
    public boolean useAddresses() {
        boolean useAddr = false;
        // use addresses if &quot;no_addresses&quot; is set to false
        String value = get(&quot;libdefaults&quot;, &quot;no_addresses&quot;);
        useAddr = (value != null &amp;&amp; value.equalsIgnoreCase(&quot;false&quot;));
        if (useAddr == false) {
            // use addresses if &quot;noaddresses&quot; is set to false
            value = get(&quot;libdefaults&quot;, &quot;noaddresses&quot;);
            useAddr = (value != null &amp;&amp; value.equalsIgnoreCase(&quot;false&quot;));
        }
        return useAddr;
    }

    /**
     * Check if need to use DNS to locate Kerberos services
     */
    private boolean useDNS(String name) {
        String value = get(&quot;libdefaults&quot;, name);
        if (value == null) {
            value = get(&quot;libdefaults&quot;, &quot;dns_fallback&quot;);
            if (&quot;false&quot;.equalsIgnoreCase(value)) {
                return false;
            } else {
                return true;
            }
        } else {
            return value.equalsIgnoreCase(&quot;true&quot;);
        }
    }

    /**
     * Check if need to use DNS to locate the KDC
     */
    private boolean useDNS_KDC() {
        return useDNS(&quot;dns_lookup_kdc&quot;);
    }

    /*
     * Check if need to use DNS to locate the Realm
     */
    private boolean useDNS_Realm() {
        return useDNS(&quot;dns_lookup_realm&quot;);
    }

    /**
     * Gets default realm.
     * @throws KrbException where no realm can be located
     * @return the default realm, always non null
     */
    public String getDefaultRealm() throws KrbException {
        if (defaultRealm != null) {
            return defaultRealm;
        }
        Exception cause = null;
        String realm = get(&quot;libdefaults&quot;, &quot;default_realm&quot;);
        if ((realm == null) &amp;&amp; useDNS_Realm()) {
            // use DNS to locate Kerberos realm
            try {
                realm = getRealmFromDNS();
            } catch (KrbException ke) {
                cause = ke;
            }
        }
        if (realm == null) {
            realm = java.security.AccessController.doPrivileged(
                    new java.security.PrivilegedAction&lt;String&gt;() {
                @Override
                public String run() {
                    String osname = System.getProperty(&quot;os.name&quot;);
                    if (osname.startsWith(&quot;Windows&quot;)) {
                        return System.getenv(&quot;USERDNSDOMAIN&quot;);
                    }
                    return null;
                }
            });
        }
        if (realm == null) {
            KrbException ke = new KrbException(&quot;Cannot locate default realm&quot;);
            if (cause != null) {
                ke.initCause(cause);
            }
            throw ke;
        }
        return realm;
    }

    /**
     * Returns a list of KDC's with each KDC separated by a space
     *
     * @param realm the realm for which the KDC list is desired
     * @throws KrbException if there's no way to find KDC for the realm
     * @return the list of KDCs separated by a space, always non null
     */
    public String getKDCList(String realm) throws KrbException {
        if (realm == null) {
            realm = getDefaultRealm();
        }
        if (realm.equalsIgnoreCase(defaultRealm)) {
            return defaultKDC;
        }
        Exception cause = null;
        String kdcs = getAll(&quot;realms&quot;, realm, &quot;kdc&quot;);
        if ((kdcs == null) &amp;&amp; useDNS_KDC()) {
            // use DNS to locate KDC
            try {
                kdcs = getKDCFromDNS(realm);
            } catch (KrbException ke) {
                cause = ke;
            }
        }
        if (kdcs == null) {
            kdcs = java.security.AccessController.doPrivileged(
                    new java.security.PrivilegedAction&lt;String&gt;() {
                @Override
                public String run() {
                    String osname = System.getProperty(&quot;os.name&quot;);
                    if (osname.startsWith(&quot;Windows&quot;)) {
                        String logonServer = System.getenv(&quot;LOGONSERVER&quot;);
                        if (logonServer != null
                                &amp;&amp; logonServer.startsWith(&quot;\\\\&quot;)) {
                            logonServer = logonServer.substring(2);
                        }
                        return logonServer;
                    }
                    return null;
                }
            });
        }
        if (kdcs == null) {
            if (defaultKDC != null) {
                return defaultKDC;
            }
            KrbException ke = new KrbException(&quot;Cannot locate KDC&quot;);
            if (cause != null) {
                ke.initCause(cause);
            }
            throw ke;
        }
        return kdcs;
    }

    /**
     * Locate Kerberos realm using DNS
     *
     * @return the Kerberos realm
     */
    private String getRealmFromDNS() throws KrbException {
        // use DNS to locate Kerberos realm
        String realm = null;
        String hostName = null;
        try {
            hostName = InetAddress.getLocalHost().getCanonicalHostName();
        } catch (UnknownHostException e) {
            KrbException ke = new KrbException(Krb5.KRB_ERR_GENERIC,
                &quot;Unable to locate Kerberos realm: &quot; + e.getMessage());
            ke.initCause(e);
            throw (ke);
        }
        // get the domain realm mapping from the configuration
        String mapRealm = PrincipalName.mapHostToRealm(hostName);
        if (mapRealm == null) {
            // No match. Try search and/or domain in /etc/resolv.conf
            List&lt;String&gt; srchlist = ResolverConfiguration.open().searchlist();
            for (String domain: srchlist) {
                realm = checkRealm(domain);
                if (realm != null) {
                    break;
                }
            }
        } else {
            realm = checkRealm(mapRealm);
        }
        if (realm == null) {
            throw new KrbException(Krb5.KRB_ERR_GENERIC,
                                &quot;Unable to locate Kerberos realm&quot;);
        }
        return realm;
    }

    /**
     * Check if the provided realm is the correct realm
     * @return the realm if correct, or null otherwise
     */
    private static String checkRealm(String mapRealm) {
        if (DEBUG) {
            System.out.println(&quot;getRealmFromDNS: trying &quot; + mapRealm);
        }
        String[] records = null;
        String newRealm = mapRealm;
        while ((records == null) &amp;&amp; (newRealm != null)) {
            // locate DNS TXT record
            records = KrbServiceLocator.getKerberosService(newRealm);
            newRealm = Realm.parseRealmComponent(newRealm);
            // if no DNS TXT records found, try again using sub-realm
        }
        if (records != null) {
            for (int i = 0; i &lt; records.length; i++) {
                if (records[i].equalsIgnoreCase(mapRealm)) {
                    return records[i];
                }
            }
        }
        return null;
    }

    /**
     * Locate KDC using DNS
     *
     * @param realm the realm for which the master KDC is desired
     * @return the KDC
     */
    private String getKDCFromDNS(String realm) throws KrbException {
        // use DNS to locate KDC
        String kdcs = &quot;&quot;;
        String[] srvs = null;
        // locate DNS SRV record using UDP
        if (DEBUG) {
            System.out.println(&quot;getKDCFromDNS using UDP&quot;);
        }
        srvs = KrbServiceLocator.getKerberosService(realm, &quot;_udp&quot;);
        if (srvs == null) {
            // locate DNS SRV record using TCP
            if (DEBUG) {
                System.out.println(&quot;getKDCFromDNS using TCP&quot;);
            }
            srvs = KrbServiceLocator.getKerberosService(realm, &quot;_tcp&quot;);
        }
        if (srvs == null) {
            // no DNS SRV records
            throw new KrbException(Krb5.KRB_ERR_GENERIC,
                &quot;Unable to locate KDC for realm &quot; + realm);
        }
        if (srvs.length == 0) {
            return null;
        }
        for (int i = 0; i &lt; srvs.length; i++) {
            kdcs += srvs[i].trim() + &quot; &quot;;
        }
        kdcs = kdcs.trim();
        if (kdcs.equals(&quot;&quot;)) {
            return null;
        }
        return kdcs;
    }

    private boolean fileExists(String name) {
        return java.security.AccessController.doPrivileged(
                                new FileExistsAction(name));
    }

    static class FileExistsAction
        implements java.security.PrivilegedAction&lt;Boolean&gt; {

        private String fileName;

        public FileExistsAction(String fileName) {
            this.fileName = fileName;
        }

        public Boolean run() {
            return new File(fileName).exists();
        }
    }

    // Shows the content of the Config object for debug purpose.
    //
    // {
    //      libdefaults = {
    //          default_realm = R
    //      }
    //      realms = {
    //          R = {
    //              kdc = [k1,k2]
    //          }
    //      }
    // }

    @Override
    public String toString() {
        StringBuffer sb = new StringBuffer();
        toStringInternal(&quot;&quot;, stanzaTable, sb);
        return sb.toString();
    }
    private static void toStringInternal(String prefix, Object obj,
            StringBuffer sb) {
        if (obj instanceof String) {
            // A string value, just print it
            sb.append(obj).append('\n');
        } else if (obj instanceof Hashtable) {
            // A table, start a new sub-section...
            Hashtable&lt;?, ?&gt; tab = (Hashtable&lt;?, ?&gt;)obj;
            sb.append(&quot;{\n&quot;);
            for (Object o: tab.keySet()) {
                // ...indent, print &quot;key = &quot;, and
                sb.append(prefix).append(&quot;    &quot;).append(o).append(&quot; = &quot;);
                // ...go recursively into value
                toStringInternal(prefix + &quot;    &quot;, tab.get(o), sb);
            }
            sb.append(prefix).append(&quot;}\n&quot;);
        } else if (obj instanceof Vector) {
            // A vector of strings, print them inside [ and ]
            Vector&lt;?&gt; v = (Vector&lt;?&gt;)obj;
            sb.append(&quot;[&quot;);
            boolean first = true;
            for (Object o: v.toArray()) {
                if (!first) sb.append(&quot;,&quot;);
                sb.append(o);
                first = false;
            }
            sb.append(&quot;]\n&quot;);
        }
    }
}
</pre>
</body>
</html>
