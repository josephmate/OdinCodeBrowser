<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider;

import java.io.*;
import java.lang.RuntimePermission;
import java.net.SocketPermission;
import java.net.URL;
import java.security.GeneralSecurityException;
import java.security.Principal;
import java.text.MessageFormat;
import java.util.*;
import javax.security.auth.x500.X500Principal;

import sun.security.util.Debug;
import sun.security.util.PropertyExpander;
import sun.security.util.ResourcesMgr;

/**
 * The policy for a Java runtime (specifying
 * which permissions are available for code from various principals)
 * is represented as a separate
 * persistent configuration.  The configuration may be stored as a
 * flat ASCII file, as a serialized binary file of
 * the Policy class, or as a database. &lt;p&gt;
 *
 * &lt;p&gt;The Java runtime creates one global Policy object, which is used to
 * represent the static policy configuration file.  It is consulted by
 * a ProtectionDomain when the protection domain initializes its set of
 * permissions. &lt;p&gt;
 *
 * &lt;p&gt;The Policy &lt;code&gt;init&lt;/code&gt; method parses the policy
 * configuration file, and then
 * populates the Policy object.  The Policy object is agnostic in that
 * it is not involved in making policy decisions.  It is merely the
 * Java runtime representation of the persistent policy configuration
 * file. &lt;p&gt;
 *
 * &lt;p&gt;When a protection domain needs to initialize its set of
 * permissions, it executes code such as the following
 * to ask the global Policy object to populate a
 * Permissions object with the appropriate permissions:
 * &lt;pre&gt;
 *  policy = Policy.getPolicy();
 *  Permissions perms = policy.getPermissions(protectiondomain)
 * &lt;/pre&gt;
 *
 * &lt;p&gt;The protection domain contains a CodeSource
 * object, which encapsulates its codebase (URL) and public key attributes.
 * It also contains the principals associated with the domain.
 * The Policy object evaluates the global policy in light of who the
 * principal is and what the code source is and returns an appropriate
 * Permissions object.
 *
 * @author Roland Schemers
 * @author Ram Marti
 *
 * @since 1.2
 */

public class PolicyParser {

    private static final String EXTDIRS_PROPERTY = &quot;java.ext.dirs&quot;;
    private static final String OLD_EXTDIRS_EXPANSION =
        &quot;${&quot; + EXTDIRS_PROPERTY + &quot;}&quot;;

    // package-private: used by PolicyFile for static policy
    static final String EXTDIRS_EXPANSION = &quot;${{&quot; + EXTDIRS_PROPERTY + &quot;}}&quot;;


    private Vector&lt;GrantEntry&gt; grantEntries;
    private Map&lt;String, DomainEntry&gt; domainEntries;

    // Convenience variables for parsing
    private static final Debug debug = Debug.getInstance(&quot;parser&quot;,
                                                &quot;\t[Policy Parser]&quot;);
    private StreamTokenizer st;
    private int lookahead;
    private boolean expandProp = false;
    private String keyStoreUrlString = null; // unexpanded
    private String keyStoreType = null;
    private String keyStoreProvider = null;
    private String storePassURL = null;

    private String expand(String value)
        throws PropertyExpander.ExpandException
    {
        return expand(value, false);
    }

    private String expand(String value, boolean encodeURL)
        throws PropertyExpander.ExpandException
    {
        if (!expandProp) {
            return value;
        } else {
            return PropertyExpander.expand(value, encodeURL);
        }
    }

    /**
     * Creates a PolicyParser object.
     */

    public PolicyParser() {
        grantEntries = new Vector&lt;GrantEntry&gt;();
    }


    public PolicyParser(boolean expandProp) {
        this();
        this.expandProp = expandProp;
    }

    /**
     * Reads a policy configuration into the Policy object using a
     * Reader object. &lt;p&gt;
     *
     * @param policy the policy Reader object.
     *
     * @exception ParsingException if the policy configuration contains
     *          a syntax error.
     *
     * @exception IOException if an error occurs while reading the policy
     *          configuration.
     */

    public void read(Reader policy)
        throws ParsingException, IOException
    {
        if (!(policy instanceof BufferedReader)) {
            policy = new BufferedReader(policy);
        }

        /**
         * Configure the stream tokenizer:
         *      Recognize strings between &quot;...&quot;
         *      Don't convert words to lowercase
         *      Recognize both C-style and C++-style comments
         *      Treat end-of-line as white space, not as a token
         */
        st   = new StreamTokenizer(policy);

        st.resetSyntax();
        st.wordChars('a', 'z');
        st.wordChars('A', 'Z');
        st.wordChars('.', '.');
        st.wordChars('0', '9');
        st.wordChars('_', '_');
        st.wordChars('$', '$');
        st.wordChars(128 + 32, 255);
        st.whitespaceChars(0, ' ');
        st.commentChar('/');
        st.quoteChar('\'');
        st.quoteChar('&quot;');
        st.lowerCaseMode(false);
        st.ordinaryChar('/');
        st.slashSlashComments(true);
        st.slashStarComments(true);

        /**
         * The main parsing loop.  The loop is executed once
         * for each entry in the config file.      The entries
         * are delimited by semicolons.   Once we've read in
         * the information for an entry, go ahead and try to
         * add it to the policy vector.
         *
         */

        lookahead = st.nextToken();
        GrantEntry ge = null;
        while (lookahead != StreamTokenizer.TT_EOF) {
            if (peek(&quot;grant&quot;)) {
                ge = parseGrantEntry();
                // could be null if we couldn't expand a property
                if (ge != null)
                    add(ge);
            } else if (peek(&quot;keystore&quot;) &amp;&amp; keyStoreUrlString==null) {
                // only one keystore entry per policy file, others will be
                // ignored
                parseKeyStoreEntry();
            } else if (peek(&quot;keystorePasswordURL&quot;) &amp;&amp; storePassURL==null) {
                // only one keystore passwordURL per policy file, others will be
                // ignored
                parseStorePassURL();
            } else if (ge == null &amp;&amp; keyStoreUrlString == null &amp;&amp;
                storePassURL == null &amp;&amp; peek(&quot;domain&quot;)) {
                if (domainEntries == null) {
                    domainEntries = new TreeMap&lt;&gt;();
                }
                DomainEntry de = parseDomainEntry();
                if (de != null) {
                    String domainName = de.getName();
                    if (!domainEntries.containsKey(domainName)) {
                        domainEntries.put(domainName, de);
                    } else {
                        MessageFormat form =
                            new MessageFormat(ResourcesMgr.getString(
                                &quot;duplicate.keystore.domain.name&quot;));
                        Object[] source = {domainName};
                        throw new ParsingException(form.format(source));
                    }
                }
            } else {
                // error?
            }
            match(&quot;;&quot;);
        }

        if (keyStoreUrlString == null &amp;&amp; storePassURL != null) {
            throw new ParsingException(ResourcesMgr.getString
                (&quot;keystorePasswordURL.can.not.be.specified.without.also.specifying.keystore&quot;));
        }
    }

    public void add(GrantEntry ge)
    {
        grantEntries.addElement(ge);
    }

    public void replace(GrantEntry origGe, GrantEntry newGe)
    {
        grantEntries.setElementAt(newGe, grantEntries.indexOf(origGe));
    }

    public boolean remove(GrantEntry ge)
    {
        return grantEntries.removeElement(ge);
    }

    /**
     * Returns the (possibly expanded) keystore location, or null if the
     * expansion fails.
     */
    public String getKeyStoreUrl() {
        try {
            if (keyStoreUrlString!=null &amp;&amp; keyStoreUrlString.length()!=0) {
                return expand(keyStoreUrlString, true).replace
                                                (File.separatorChar, '/');
            }
        } catch (PropertyExpander.ExpandException peee) {
            if (debug != null) {
                debug.println(peee.toString());
            }
            return null;
        }
        return null;
    }

    public void setKeyStoreUrl(String url) {
        keyStoreUrlString = url;
    }

    public String getKeyStoreType() {
        return keyStoreType;
    }

    public void setKeyStoreType(String type) {
        keyStoreType = type;
    }

    public String getKeyStoreProvider() {
        return keyStoreProvider;
    }

    public void setKeyStoreProvider(String provider) {
        keyStoreProvider = provider;
    }

    public String getStorePassURL() {
        try {
            if (storePassURL!=null &amp;&amp; storePassURL.length()!=0) {
                return expand(storePassURL, true).replace
                                                (File.separatorChar, '/');
            }
        } catch (PropertyExpander.ExpandException peee) {
            if (debug != null) {
                debug.println(peee.toString());
            }
            return null;
        }
        return null;
    }

    public void setStorePassURL(String storePassURL) {
        this.storePassURL = storePassURL;
    }

    /**
     * Enumerate all the entries in the global policy object.
     * This method is used by policy admin tools.   The tools
     * should use the Enumeration methods on the returned object
     * to fetch the elements sequentially.
     */
    public Enumeration&lt;GrantEntry&gt; grantElements(){
        return grantEntries.elements();
    }

    public Collection&lt;DomainEntry&gt; getDomainEntries() {
        return domainEntries.values();
    }

    /**
     * write out the policy
     */

    public void write(Writer policy)
    {
        PrintWriter out = new PrintWriter(new BufferedWriter(policy));

        Enumeration&lt;GrantEntry&gt; enum_ = grantElements();

        out.println(&quot;/* AUTOMATICALLY GENERATED ON &quot;+
                    (new java.util.Date()) + &quot;*/&quot;);
        out.println(&quot;/* DO NOT EDIT */&quot;);
        out.println();

        // write the (unexpanded) keystore entry as the first entry of the
        // policy file
        if (keyStoreUrlString != null) {
            writeKeyStoreEntry(out);
        }
        if (storePassURL != null) {
            writeStorePassURL(out);
        }

        // write &quot;grant&quot; entries
        while (enum_.hasMoreElements()) {
            GrantEntry ge = enum_.nextElement();
            ge.write(out);
            out.println();
        }
        out.flush();
    }

    /**
     * parses a keystore entry
     */
    private void parseKeyStoreEntry() throws ParsingException, IOException {
        match(&quot;keystore&quot;);
        keyStoreUrlString = match(&quot;quoted string&quot;);

        // parse keystore type
        if (!peek(&quot;,&quot;)) {
            return; // default type
        }
        match(&quot;,&quot;);

        if (peek(&quot;\&quot;&quot;)) {
            keyStoreType = match(&quot;quoted string&quot;);
        } else {
            throw new ParsingException(st.lineno(),
                        ResourcesMgr.getString(&quot;expected.keystore.type&quot;));
        }

        // parse keystore provider
        if (!peek(&quot;,&quot;)) {
            return; // provider optional
        }
        match(&quot;,&quot;);

        if (peek(&quot;\&quot;&quot;)) {
            keyStoreProvider = match(&quot;quoted string&quot;);
        } else {
            throw new ParsingException(st.lineno(),
                        ResourcesMgr.getString(&quot;expected.keystore.provider&quot;));
        }
    }

    private void parseStorePassURL() throws ParsingException, IOException {
        match(&quot;keyStorePasswordURL&quot;);
        storePassURL = match(&quot;quoted string&quot;);
    }

    /**
     * writes the (unexpanded) keystore entry
     */
    private void writeKeyStoreEntry(PrintWriter out) {
        out.print(&quot;keystore \&quot;&quot;);
        out.print(keyStoreUrlString);
        out.print('&quot;');
        if (keyStoreType != null &amp;&amp; keyStoreType.length() &gt; 0)
            out.print(&quot;, \&quot;&quot; + keyStoreType + &quot;\&quot;&quot;);
        if (keyStoreProvider != null &amp;&amp; keyStoreProvider.length() &gt; 0)
            out.print(&quot;, \&quot;&quot; + keyStoreProvider + &quot;\&quot;&quot;);
        out.println(&quot;;&quot;);
        out.println();
    }

    private void writeStorePassURL(PrintWriter out) {
        out.print(&quot;keystorePasswordURL \&quot;&quot;);
        out.print(storePassURL);
        out.print('&quot;');
        out.println(&quot;;&quot;);
        out.println();
    }

    /**
     * parse a Grant entry
     */
    private GrantEntry parseGrantEntry()
        throws ParsingException, IOException
    {
        GrantEntry e = new GrantEntry();
        LinkedList&lt;PrincipalEntry&gt; principals = null;
        boolean ignoreEntry = false;

        match(&quot;grant&quot;);

        while(!peek(&quot;{&quot;)) {

            if (peekAndMatch(&quot;Codebase&quot;)) {
                if (e.codeBase != null)
                    throw new ParsingException(
                            st.lineno(),
                            ResourcesMgr.getString
                                (&quot;multiple.Codebase.expressions&quot;));
                e.codeBase = match(&quot;quoted string&quot;);
                peekAndMatch(&quot;,&quot;);
            } else if (peekAndMatch(&quot;SignedBy&quot;)) {
                if (e.signedBy != null)
                    throw new ParsingException(
                            st.lineno(),
                            ResourcesMgr.getString(
                                &quot;multiple.SignedBy.expressions&quot;));
                e.signedBy = match(&quot;quoted string&quot;);

                // verify syntax of the aliases
                StringTokenizer aliases = new StringTokenizer(e.signedBy,
                                                              &quot;,&quot;, true);
                int actr = 0;
                int cctr = 0;
                while (aliases.hasMoreTokens()) {
                    String alias = aliases.nextToken().trim();
                    if (alias.equals(&quot;,&quot;))
                        cctr++;
                    else if (alias.length() &gt; 0)
                        actr++;
                }
                if (actr &lt;= cctr)
                    throw new ParsingException(
                            st.lineno(),
                            ResourcesMgr.getString(
                                &quot;SignedBy.has.empty.alias&quot;));

                peekAndMatch(&quot;,&quot;);
            } else if (peekAndMatch(&quot;Principal&quot;)) {
                if (principals == null) {
                    principals = new LinkedList&lt;&gt;();
                }

                String principalClass;
                String principalName;

                if (peek(&quot;\&quot;&quot;)) {
                    // both the principalClass and principalName
                    // will be replaced later
                    principalClass = PrincipalEntry.REPLACE_NAME;
                    principalName = match(&quot;principal type&quot;);
                } else {
                    // check for principalClass wildcard
                    if (peek(&quot;*&quot;)) {
                        match(&quot;*&quot;);
                        principalClass = PrincipalEntry.WILDCARD_CLASS;
                    } else {
                        principalClass = match(&quot;principal type&quot;);
                    }

                    // check for principalName wildcard
                    if (peek(&quot;*&quot;)) {
                        match(&quot;*&quot;);
                        principalName = PrincipalEntry.WILDCARD_NAME;
                    } else {
                        principalName = match(&quot;quoted string&quot;);
                    }

                    // disallow WILDCARD_CLASS &amp;&amp; actual name
                    if (principalClass.equals(PrincipalEntry.WILDCARD_CLASS) &amp;&amp;
                        !principalName.equals(PrincipalEntry.WILDCARD_NAME)) {
                        if (debug != null) {
                                debug.println(&quot;disallowing principal that &quot; +
                                    &quot;has WILDCARD class but no WILDCARD name&quot;);
                        }
                        throw new ParsingException
                                (st.lineno(),
                                 ResourcesMgr.getString
                                    (&quot;can.not.specify.Principal.with.a.wildcard.class.without.a.wildcard.name&quot;));
                    }
                }

                try {
                    principalName = expand(principalName);

                    if (principalClass.equals
                                (&quot;javax.security.auth.x500.X500Principal&quot;) &amp;&amp;
                        !principalName.equals(PrincipalEntry.WILDCARD_NAME)) {

                        // 4702543:  X500 names with an EmailAddress
                        // were encoded incorrectly.  construct a new
                        // X500Principal with correct encoding.

                        X500Principal p = new X500Principal
                                ((new X500Principal(principalName)).toString());
                        principalName = p.getName();
                    }

                    principals.add
                        (new PrincipalEntry(principalClass, principalName));
                } catch (PropertyExpander.ExpandException peee) {
                    // ignore the entire policy entry
                    // but continue parsing all the info
                    // so we can get to the next entry
                    if (debug != null) {
                        debug.println(&quot;principal name expansion failed: &quot; +
                                        principalName);
                    }
                    ignoreEntry = true;
                }
                peekAndMatch(&quot;,&quot;);

            } else {
                throw new ParsingException(st.lineno(),
                                  ResourcesMgr.getString(
                                      &quot;expected.codeBase.or.SignedBy.or.Principal&quot;));
            }
        }

        if (principals != null) e.principals = principals;
        match(&quot;{&quot;);

        while(!peek(&quot;}&quot;)) {
            if (peek(&quot;Permission&quot;)) {
                try {
                    PermissionEntry pe = parsePermissionEntry();
                    e.add(pe);
                } catch (PropertyExpander.ExpandException peee) {
                    // ignore. The add never happened
                    if (debug != null) {
                        debug.println(peee.toString());
                    }
                    skipEntry();  // BugId 4219343
                }
                match(&quot;;&quot;);
            } else {
                throw new
                    ParsingException(st.lineno(),
                                     ResourcesMgr.getString(
                                        &quot;expected.permission.entry&quot;));
            }
        }
        match(&quot;}&quot;);

        try {
            if (e.signedBy != null) e.signedBy = expand(e.signedBy);
            if (e.codeBase != null) {

                // For backward compatibility with 1.4
                if (e.codeBase.equals(OLD_EXTDIRS_EXPANSION)) {
                    e.codeBase = EXTDIRS_EXPANSION;
                }
                int es;
                if ((es=e.codeBase.indexOf(EXTDIRS_EXPANSION)) &lt; 0) {
                    e.codeBase = expand(e.codeBase, true).replace
                                        (File.separatorChar, '/');
                } else {
                    // expand the system property &quot;java.ext.dirs&quot;,
                    // parse it into its path components,
                    // and then create a grant entry for each component
                    String[] extDirs = parseExtDirs(e.codeBase, es);
                    if (extDirs != null &amp;&amp; extDirs.length &gt; 0) {
                        for (int i = 0; i &lt; extDirs.length; i++) {
                            GrantEntry newGe = (GrantEntry)e.clone();
                            newGe.codeBase = extDirs[i];
                            add(newGe);

                            if (debug != null) {
                                debug.println(&quot;creating policy entry for &quot; +
                                        &quot;expanded java.ext.dirs path:\n\t\t&quot; +
                                        extDirs[i]);
                            }
                        }
                    }
                    ignoreEntry = true;
                }
            }
        } catch (PropertyExpander.ExpandException peee) {
            if (debug != null) {
                debug.println(peee.toString());
            }
            return null;
        }

        return (ignoreEntry == true) ? null : e;
    }

    /**
     * parse a Permission entry
     */
    private PermissionEntry parsePermissionEntry()
        throws ParsingException, IOException, PropertyExpander.ExpandException
    {
        PermissionEntry e = new PermissionEntry();

        // Permission
        match(&quot;Permission&quot;);
        e.permission = match(&quot;permission type&quot;);

        if (peek(&quot;\&quot;&quot;)) {
            // Permission name
            e.name = expand(match(&quot;quoted string&quot;));
        }

        if (!peek(&quot;,&quot;)) {
            return e;
        }
        match(&quot;,&quot;);

        if (peek(&quot;\&quot;&quot;)) {
                e.action = expand(match(&quot;quoted string&quot;));
                if (!peek(&quot;,&quot;)) {
                    return e;
                }
                match(&quot;,&quot;);
        }

        if (peekAndMatch(&quot;SignedBy&quot;)) {
            e.signedBy = expand(match(&quot;quoted string&quot;));
        }
        return e;
    }

    /**
     * parse a domain entry
     */
    private DomainEntry parseDomainEntry()
        throws ParsingException, IOException
    {
        boolean ignoreEntry = false;
        DomainEntry domainEntry;
        String name = null;
        Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();

        match(&quot;domain&quot;);
        name = match(&quot;domain name&quot;);

        while(!peek(&quot;{&quot;)) {
            // get the domain properties
            properties = parseProperties(&quot;{&quot;);
        }
        match(&quot;{&quot;);
        domainEntry = new DomainEntry(name, properties);

        while(!peek(&quot;}&quot;)) {

            match(&quot;keystore&quot;);
            name = match(&quot;keystore name&quot;);
            // get the keystore properties
            if (!peek(&quot;}&quot;)) {
                properties = parseProperties(&quot;;&quot;);
            }
            match(&quot;;&quot;);
            domainEntry.add(new KeyStoreEntry(name, properties));
        }
        match(&quot;}&quot;);

        return (ignoreEntry == true) ? null : domainEntry;
    }

    /*
     * Return a collection of domain properties or keystore properties.
     */
    private Map&lt;String, String&gt; parseProperties(String terminator)
        throws ParsingException, IOException {

        Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();
        String key;
        String value;
        while (!peek(terminator)) {
            key = match(&quot;property name&quot;);
            match(&quot;=&quot;);

            try {
                value = expand(match(&quot;quoted string&quot;));
            } catch (PropertyExpander.ExpandException peee) {
                throw new IOException(peee.getLocalizedMessage());
            }
            properties.put(key.toLowerCase(), value);
        }

        return properties;
    }

    // package-private: used by PolicyFile for static policy
    static String[] parseExtDirs(String codebase, int start) {

        String s = System.getProperty(EXTDIRS_PROPERTY);
        String globalPrefix = (start &gt; 0 ? codebase.substring(0, start) : &quot;file:&quot;);
        int end = start + EXTDIRS_EXPANSION.length();
        String globalSuffix = (end &lt; codebase.length() ? codebase.substring(end) :
            (String) null);

        String[] dirs = null;
        String localSuffix;
        if (s != null) {
            StringTokenizer st =
                new StringTokenizer(s, File.pathSeparator);
            int count = st.countTokens();
            dirs = new String[count];
            for (int i = 0; i &lt; count; i++) {
                File file = new File(st.nextToken());
                dirs[i] = sun.net.www.ParseUtil.encodePath
                        (file.getAbsolutePath());

                if (!dirs[i].startsWith(&quot;/&quot;)) {
                    dirs[i] = &quot;/&quot; + dirs[i];
                }

                localSuffix = (globalSuffix == null ?
                    (dirs[i].endsWith(&quot;/&quot;) ? &quot;*&quot; : &quot;/*&quot;) :
                    globalSuffix);

                dirs[i] = globalPrefix + dirs[i] + localSuffix;
            }
        }
        return dirs;
    }

    private boolean peekAndMatch(String expect)
        throws ParsingException, IOException
    {
        if (peek(expect)) {
            match(expect);
            return true;
        } else {
            return false;
        }
    }

    private boolean peek(String expect) {
        boolean found = false;

        switch (lookahead) {

        case StreamTokenizer.TT_WORD:
            if (expect.equalsIgnoreCase(st.sval))
                found = true;
            break;
        case ',':
            if (expect.equalsIgnoreCase(&quot;,&quot;))
                found = true;
            break;
        case '{':
            if (expect.equalsIgnoreCase(&quot;{&quot;))
                found = true;
            break;
        case '}':
            if (expect.equalsIgnoreCase(&quot;}&quot;))
                found = true;
            break;
        case '&quot;':
            if (expect.equalsIgnoreCase(&quot;\&quot;&quot;))
                found = true;
            break;
        case '*':
            if (expect.equalsIgnoreCase(&quot;*&quot;))
                found = true;
            break;
        case ';':
            if (expect.equalsIgnoreCase(&quot;;&quot;))
                found = true;
            break;
        default:

        }
        return found;
    }

    private String match(String expect)
        throws ParsingException, IOException
    {
        String value = null;

        switch (lookahead) {
        case StreamTokenizer.TT_NUMBER:
            throw new ParsingException(st.lineno(), expect,
                                       ResourcesMgr.getString(&quot;number.&quot;) +
                                       String.valueOf(st.nval));
        case StreamTokenizer.TT_EOF:
            MessageFormat form = new MessageFormat(
                    ResourcesMgr.getString
                            (&quot;expected.expect.read.end.of.file.&quot;));
            Object[] source = {expect};
            throw new ParsingException(form.format(source));
        case StreamTokenizer.TT_WORD:
            if (expect.equalsIgnoreCase(st.sval)) {
                lookahead = st.nextToken();
            } else if (expect.equalsIgnoreCase(&quot;permission type&quot;)) {
                value = st.sval;
                lookahead = st.nextToken();
            } else if (expect.equalsIgnoreCase(&quot;principal type&quot;)) {
                value = st.sval;
                lookahead = st.nextToken();
            } else if (expect.equalsIgnoreCase(&quot;domain name&quot;) ||
                       expect.equalsIgnoreCase(&quot;keystore name&quot;) ||
                       expect.equalsIgnoreCase(&quot;property name&quot;)) {
                value = st.sval;
                lookahead = st.nextToken();
            } else {
                 throw new ParsingException(st.lineno(), expect,
                                            st.sval);
            }
            break;
        case '&quot;':
            if (expect.equalsIgnoreCase(&quot;quoted string&quot;)) {
                value = st.sval;
                lookahead = st.nextToken();
            } else if (expect.equalsIgnoreCase(&quot;permission type&quot;)) {
                value = st.sval;
                lookahead = st.nextToken();
            } else if (expect.equalsIgnoreCase(&quot;principal type&quot;)) {
                value = st.sval;
                lookahead = st.nextToken();
            } else {
                throw new ParsingException(st.lineno(), expect, st.sval);
            }
            break;
        case ',':
            if (expect.equalsIgnoreCase(&quot;,&quot;))
                lookahead = st.nextToken();
            else
                throw new ParsingException(st.lineno(), expect, &quot;,&quot;);
            break;
        case '{':
            if (expect.equalsIgnoreCase(&quot;{&quot;))
                lookahead = st.nextToken();
            else
                throw new ParsingException(st.lineno(), expect, &quot;{&quot;);
            break;
        case '}':
            if (expect.equalsIgnoreCase(&quot;}&quot;))
                lookahead = st.nextToken();
            else
                throw new ParsingException(st.lineno(), expect, &quot;}&quot;);
            break;
        case ';':
            if (expect.equalsIgnoreCase(&quot;;&quot;))
                lookahead = st.nextToken();
            else
                throw new ParsingException(st.lineno(), expect, &quot;;&quot;);
            break;
        case '*':
            if (expect.equalsIgnoreCase(&quot;*&quot;))
                lookahead = st.nextToken();
            else
                throw new ParsingException(st.lineno(), expect, &quot;*&quot;);
            break;
        case '=':
            if (expect.equalsIgnoreCase(&quot;=&quot;))
                lookahead = st.nextToken();
            else
                throw new ParsingException(st.lineno(), expect, &quot;=&quot;);
            break;
        default:
            throw new ParsingException(st.lineno(), expect,
                               new String(new char[] {(char)lookahead}));
        }
        return value;
    }

    /**
     * skip all tokens for this entry leaving the delimiter &quot;;&quot;
     * in the stream.
     */
    private void skipEntry() throws ParsingException, IOException {
        while(lookahead != ';') {
            switch (lookahead) {
            case StreamTokenizer.TT_NUMBER:
                throw new ParsingException(st.lineno(), &quot;;&quot;,
                                          ResourcesMgr.getString(&quot;number.&quot;) +
                                          String.valueOf(st.nval));
            case StreamTokenizer.TT_EOF:
                throw new ParsingException(ResourcesMgr.getString
                        (&quot;expected.read.end.of.file.&quot;));
            default:
                lookahead = st.nextToken();
            }
        }
    }

    /**
     * Each grant entry in the policy configuration file is
     * represented by a
     * GrantEntry object.  &lt;p&gt;
     *
     * &lt;p&gt;
     * For example, the entry
     * &lt;pre&gt;
     *      grant signedBy &quot;Duke&quot; {
     *          permission java.io.FilePermission &quot;/tmp&quot;, &quot;read,write&quot;;
     *      };
     *
     * &lt;/pre&gt;
     * is represented internally
     * &lt;pre&gt;
     *
     * pe = new PermissionEntry(&quot;java.io.FilePermission&quot;,
     *                           &quot;/tmp&quot;, &quot;read,write&quot;);
     *
     * ge = new GrantEntry(&quot;Duke&quot;, null);
     *
     * ge.add(pe);
     *
     * &lt;/pre&gt;
     *
     * @author Roland Schemers
     *
     * version 1.19, 05/21/98
     */

    public static class GrantEntry {

        public String signedBy;
        public String codeBase;
        public LinkedList&lt;PrincipalEntry&gt; principals;
        public Vector&lt;PermissionEntry&gt; permissionEntries;

        public GrantEntry() {
            principals = new LinkedList&lt;PrincipalEntry&gt;();
            permissionEntries = new Vector&lt;PermissionEntry&gt;();
        }

        public GrantEntry(String signedBy, String codeBase) {
            this.codeBase = codeBase;
            this.signedBy = signedBy;
            principals = new LinkedList&lt;PrincipalEntry&gt;();
            permissionEntries = new Vector&lt;PermissionEntry&gt;();
        }

        public void add(PermissionEntry pe)
        {
            permissionEntries.addElement(pe);
        }

        public boolean remove(PrincipalEntry pe)
        {
            return principals.remove(pe);
        }

        public boolean remove(PermissionEntry pe)
        {
            return permissionEntries.removeElement(pe);
        }

        public boolean contains(PrincipalEntry pe)
        {
            return principals.contains(pe);
        }

        public boolean contains(PermissionEntry pe)
        {
            return permissionEntries.contains(pe);
        }

        /**
         * Enumerate all the permission entries in this GrantEntry.
         */
        public Enumeration&lt;PermissionEntry&gt; permissionElements(){
            return permissionEntries.elements();
        }


        public void write(PrintWriter out) {
            out.print(&quot;grant&quot;);
            if (signedBy != null) {
                out.print(&quot; signedBy \&quot;&quot;);
                out.print(signedBy);
                out.print('&quot;');
                if (codeBase != null)
                    out.print(&quot;, &quot;);
            }
            if (codeBase != null) {
                out.print(&quot; codeBase \&quot;&quot;);
                out.print(codeBase);
                out.print('&quot;');
                if (principals != null &amp;&amp; principals.size() &gt; 0)
                    out.print(&quot;,\n&quot;);
            }
            if (principals != null &amp;&amp; principals.size() &gt; 0) {
                Iterator&lt;PrincipalEntry&gt; pli = principals.iterator();
                while (pli.hasNext()) {
                    out.print(&quot;      &quot;);
                    PrincipalEntry pe = pli.next();
                    pe.write(out);
                    if (pli.hasNext())
                        out.print(&quot;,\n&quot;);
                }
            }
            out.println(&quot; {&quot;);
            Enumeration&lt;PermissionEntry&gt; enum_ = permissionEntries.elements();
            while (enum_.hasMoreElements()) {
                PermissionEntry pe = enum_.nextElement();
                out.write(&quot;  &quot;);
                pe.write(out);
            }
            out.println(&quot;};&quot;);
        }

        public Object clone() {
            GrantEntry ge = new GrantEntry();
            ge.codeBase = this.codeBase;
            ge.signedBy = this.signedBy;
            ge.principals = new LinkedList&lt;PrincipalEntry&gt;(this.principals);
            ge.permissionEntries =
                        new Vector&lt;PermissionEntry&gt;(this.permissionEntries);
            return ge;
        }
    }

    /**
     * Principal info (class and name) in a grant entry
     */
    public static class PrincipalEntry implements Principal {

        public static final String WILDCARD_CLASS = &quot;WILDCARD_PRINCIPAL_CLASS&quot;;
        public static final String WILDCARD_NAME = &quot;WILDCARD_PRINCIPAL_NAME&quot;;
        public static final String REPLACE_NAME = &quot;PolicyParser.REPLACE_NAME&quot;;

        String principalClass;
        String principalName;

        /**
         * A PrincipalEntry consists of the Principal class and Principal name.
         *
         * @param principalClass the Principal class
         * @param principalName the Principal name
         * @throws NullPointerException if principalClass or principalName
         *                              are null
         */
        public PrincipalEntry(String principalClass, String principalName) {
            if (principalClass == null || principalName == null)
                throw new NullPointerException(ResourcesMgr.getString(
                                  &quot;null.principalClass.or.principalName&quot;));
            this.principalClass = principalClass;
            this.principalName = principalName;
        }

        boolean isWildcardName() {
            return principalName.equals(WILDCARD_NAME);
        }

        boolean isWildcardClass() {
            return principalClass.equals(WILDCARD_CLASS);
        }

        boolean isReplaceName() {
            return principalClass.equals(REPLACE_NAME);
        }

        public String getPrincipalClass() {
            return principalClass;
        }

        public String getPrincipalName() {
            return principalName;
        }

        public String getDisplayClass() {
            if (isWildcardClass()) {
                return &quot;*&quot;;
            } else if (isReplaceName()) {
                return &quot;&quot;;
            }
            else return principalClass;
        }

        public String getDisplayName() {
            return getDisplayName(false);
        }

        public String getDisplayName(boolean addQuote) {
            if (isWildcardName()) {
                return &quot;*&quot;;
            }
            else {
                if (addQuote) return &quot;\&quot;&quot; + principalName + &quot;\&quot;&quot;;
                else return principalName;
            }
        }

        @Override
        public String getName() {
            return principalName;
        }

        @Override
        public String toString() {
            if (!isReplaceName()) {
                return getDisplayClass() + &quot;/&quot; + getDisplayName();
            } else {
                return getDisplayName();
            }
        }

        /**
         * Test for equality between the specified object and this object.
         * Two PrincipalEntries are equal if their class and name values
         * are equal.
         *
         * @param obj the object to test for equality with this object
         * @return true if the objects are equal, false otherwise
         */
        @Override
        public boolean equals(Object obj) {
            if (this == obj)
                return true;

            if (!(obj instanceof PrincipalEntry))
                return false;

            PrincipalEntry that = (PrincipalEntry)obj;
            return (principalClass.equals(that.principalClass) &amp;&amp;
                    principalName.equals(that.principalName));
        }

        /**
         * Return a hashcode for this PrincipalEntry.
         *
         * @return a hashcode for this PrincipalEntry
         */
        @Override
        public int hashCode() {
            return principalClass.hashCode();
        }

        public void write(PrintWriter out) {
            out.print(&quot;principal &quot; + getDisplayClass() + &quot; &quot; +
                      getDisplayName(true));
        }
    }

    /**
     * Each permission entry in the policy configuration file is
     * represented by a
     * PermissionEntry object.  &lt;p&gt;
     *
     * &lt;p&gt;
     * For example, the entry
     * &lt;pre&gt;
     *          permission java.io.FilePermission &quot;/tmp&quot;, &quot;read,write&quot;;
     * &lt;/pre&gt;
     * is represented internally
     * &lt;pre&gt;
     *
     * pe = new PermissionEntry(&quot;java.io.FilePermission&quot;,
     *                           &quot;/tmp&quot;, &quot;read,write&quot;);
     * &lt;/pre&gt;
     *
     * @author Roland Schemers
     *
     * version 1.19, 05/21/98
     */

    public static class PermissionEntry {

        public String permission;
        public String name;
        public String action;
        public String signedBy;

        public PermissionEntry() {
        }

        public PermissionEntry(String permission,
                        String name,
                        String action) {
            this.permission = permission;
            this.name = name;
            this.action = action;
        }

        /**
         * Calculates a hash code value for the object.  Objects
         * which are equal will also have the same hashcode.
         */
        @Override
        public int hashCode() {
            int retval = permission.hashCode();
            if (name != null) retval ^= name.hashCode();
            if (action != null) retval ^= action.hashCode();
            return retval;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == this)
                return true;

            if (! (obj instanceof PermissionEntry))
                return false;

            PermissionEntry that = (PermissionEntry) obj;

            if (this.permission == null) {
                if (that.permission != null) return false;
            } else {
                if (!this.permission.equals(that.permission)) return false;
            }

            if (this.name == null) {
                if (that.name != null) return false;
            } else {
                if (!this.name.equals(that.name)) return false;
            }

            if (this.action == null) {
                if (that.action != null) return false;
            } else {
                if (!this.action.equals(that.action)) return false;
            }

            if (this.signedBy == null) {
                if (that.signedBy != null) return false;
            } else {
                if (!this.signedBy.equals(that.signedBy)) return false;
            }

            // everything matched -- the 2 objects are equal
            return true;
        }

        public void write(PrintWriter out) {
            out.print(&quot;permission &quot;);
            out.print(permission);
            if (name != null) {
                out.print(&quot; \&quot;&quot;);

                // ATTENTION: regex with double escaping,
                // the normal forms look like:
                // $name =~ s/\\/\\\\/g; and
                // $name =~ s/\&quot;/\\\&quot;/g;
                // and then in a java string, it's escaped again

                out.print(name.replaceAll(&quot;\\\\&quot;, &quot;\\\\\\\\&quot;).replaceAll(&quot;\\\&quot;&quot;, &quot;\\\\\\\&quot;&quot;));
                out.print('&quot;');
            }
            if (action != null) {
                out.print(&quot;, \&quot;&quot;);
                out.print(action);
                out.print('&quot;');
            }
            if (signedBy != null) {
                out.print(&quot;, signedBy \&quot;&quot;);
                out.print(signedBy);
                out.print('&quot;');
            }
            out.println(&quot;;&quot;);
        }
    }

    /**
     * Each domain entry in the keystore domain configuration file is
     * represented by a DomainEntry object.
     */
    static class DomainEntry {
        private final String name;
        private final Map&lt;String, String&gt; properties;
        private final Map&lt;String, KeyStoreEntry&gt; entries;

        DomainEntry(String name, Map&lt;String, String&gt; properties) {
            this.name = name;
            this.properties = properties;
            entries = new HashMap&lt;&gt;();
        }

        String getName() {
            return name;
        }

        Map&lt;String, String&gt; getProperties() {
            return properties;
        }

        Collection&lt;KeyStoreEntry&gt; getEntries() {
            return entries.values();
        }

        void add(KeyStoreEntry entry) throws ParsingException {
            String keystoreName = entry.getName();
            if (!entries.containsKey(keystoreName)) {
                entries.put(keystoreName, entry);
            } else {
                MessageFormat form = new MessageFormat(ResourcesMgr.getString(
                    &quot;duplicate.keystore.name&quot;));
                Object[] source = {keystoreName};
                throw new ParsingException(form.format(source));
            }
        }

        @Override
        public String toString() {
            StringBuilder s =
                new StringBuilder(&quot;\ndomain &quot;).append(name);

            if (properties != null) {
                for (Map.Entry&lt;String, String&gt; property :
                    properties.entrySet()) {
                    s.append(&quot;\n        &quot;).append(property.getKey()).append('=')
                        .append(property.getValue());
                }
            }
            s.append(&quot; {\n&quot;);

            if (entries != null) {
                for (KeyStoreEntry entry : entries.values()) {
                    s.append(entry).append(&quot;\n&quot;);
                }
            }
            s.append(&quot;}&quot;);

            return s.toString();
        }
    }

    /**
     * Each keystore entry in the keystore domain configuration file is
     * represented by a KeyStoreEntry object.
     */

    static class KeyStoreEntry {
        private final String name;
        private final Map&lt;String, String&gt; properties;

        KeyStoreEntry(String name, Map&lt;String, String&gt; properties) {
            this.name = name;
            this.properties = properties;
        }

        String getName() {
            return name;
        }

        Map&lt;String, String&gt;  getProperties() {
            return properties;
        }

        @Override
        public String toString() {
            StringBuilder s = new StringBuilder(&quot;\n    keystore &quot;).append(name);
            if (properties != null) {
                for (Map.Entry&lt;String, String&gt; property :
                    properties.entrySet()) {
                    s.append(&quot;\n        &quot;).append(property.getKey()).append('=')
                        .append(property.getValue());
                }
            }
            s.append(&quot;;&quot;);

            return s.toString();
        }
    }

    public static class ParsingException extends GeneralSecurityException {

        private static final long serialVersionUID = -4330692689482574072L;

        private String i18nMessage;

        /**
         * Constructs a ParsingException with the specified
         * detail message. A detail message is a String that describes
         * this particular exception, which may, for example, specify which
         * algorithm is not available.
         *
         * @param msg the detail message.
         */
        public ParsingException(String msg) {
            super(msg);
            i18nMessage = msg;
        }

        public ParsingException(int line, String msg) {
            super(&quot;line &quot; + line + &quot;: &quot; + msg);
            MessageFormat form = new MessageFormat
                (ResourcesMgr.getString(&quot;line.number.msg&quot;));
            Object[] source = {new Integer(line), msg};
            i18nMessage = form.format(source);
        }

        public ParsingException(int line, String expect, String actual) {
            super(&quot;line &quot; + line + &quot;: expected [&quot; + expect +
                &quot;], found [&quot; + actual + &quot;]&quot;);
            MessageFormat form = new MessageFormat(ResourcesMgr.getString
                (&quot;line.number.expected.expect.found.actual.&quot;));
            Object[] source = {new Integer(line), expect, actual};
            i18nMessage = form.format(source);
        }

        @Override
        public String getLocalizedMessage() {
            return i18nMessage;
        }
    }

    public static void main(String arg[]) throws Exception {
        try (FileReader fr = new FileReader(arg[0]);
             FileWriter fw = new FileWriter(arg[1])) {
            PolicyParser pp = new PolicyParser(true);
            pp.read(fr);
            pp.write(fw);
        }
    }
}
</pre>
</body>
</html>
