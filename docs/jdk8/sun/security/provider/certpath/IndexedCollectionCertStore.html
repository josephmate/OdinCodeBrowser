<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider.certpath;

import java.util.*;

import java.security.InvalidAlgorithmParameterException;
import java.security.cert.*;

import javax.security.auth.x500.X500Principal;

/**
 * A &lt;code&gt;CertStore&lt;/code&gt; that retrieves &lt;code&gt;Certificates&lt;/code&gt; and
 * &lt;code&gt;CRL&lt;/code&gt;s from a &lt;code&gt;Collection&lt;/code&gt;.
 * &lt;p&gt;
 * This implementation is functionally equivalent to CollectionCertStore
 * with two differences:
 * &lt;ol&gt;
 * &lt;li&gt;Upon construction, the elements in the specified Collection are
 * partially indexed. X509Certificates are indexed by subject, X509CRLs
 * by issuer, non-X509 Certificates and CRLs are copied without indexing,
 * other objects are ignored. This increases CertStore construction time
 * but allows significant speedups for searches which specify the indexed
 * attributes, in particular for large Collections (reduction from linear
 * time to effectively constant time). Searches for non-indexed queries
 * are as fast (or marginally faster) than for the standard
 * CollectionCertStore. Certificate subjects and CRL issuers
 * were found to be specified in most searches used internally by the
 * CertPath provider. Additional attributes could indexed if there are
 * queries that justify the effort.
 *
 * &lt;li&gt;Changes to the specified Collection after construction time are
 * not detected and ignored. This is because there is no way to efficiently
 * detect if a Collection has been modified, a full traversal would be
 * required. That would degrade lookup performance to linear time and
 * eliminated the benefit of indexing. We may fix this via the introduction
 * of new public APIs in the future.
 * &lt;/ol&gt;
 * &lt;p&gt;
 * Before calling the {@link #engineGetCertificates engineGetCertificates} or
 * {@link #engineGetCRLs engineGetCRLs} methods, the
 * {@link #CollectionCertStore(CertStoreParameters)
 * CollectionCertStore(CertStoreParameters)} constructor is called to
 * create the &lt;code&gt;CertStore&lt;/code&gt; and establish the
 * &lt;code&gt;Collection&lt;/code&gt; from which &lt;code&gt;Certificate&lt;/code&gt;s and
 * &lt;code&gt;CRL&lt;/code&gt;s will be retrieved. If the specified
 * &lt;code&gt;Collection&lt;/code&gt; contains an object that is not a
 * &lt;code&gt;Certificate&lt;/code&gt; or &lt;code&gt;CRL&lt;/code&gt;, that object will be
 * ignored.
 * &lt;p&gt;
 * &lt;b&gt;Concurrent Access&lt;/b&gt;
 * &lt;p&gt;
 * As described in the javadoc for &lt;code&gt;CertStoreSpi&lt;/code&gt;, the
 * &lt;code&gt;engineGetCertificates&lt;/code&gt; and &lt;code&gt;engineGetCRLs&lt;/code&gt; methods
 * must be thread-safe. That is, multiple threads may concurrently
 * invoke these methods on a single &lt;code&gt;CollectionCertStore&lt;/code&gt;
 * object (or more than one) with no ill effects.
 * &lt;p&gt;
 * This is achieved by requiring that the &lt;code&gt;Collection&lt;/code&gt; passed to
 * the {@link #CollectionCertStore(CertStoreParameters)
 * CollectionCertStore(CertStoreParameters)} constructor (via the
 * &lt;code&gt;CollectionCertStoreParameters&lt;/code&gt; object) must have fail-fast
 * iterators. Simultaneous modifications to the &lt;code&gt;Collection&lt;/code&gt; can thus be
 * detected and certificate or CRL retrieval can be retried. The fact that
 * &lt;code&gt;Certificate&lt;/code&gt;s and &lt;code&gt;CRL&lt;/code&gt;s must be thread-safe is also
 * essential.
 *
 * @see java.security.cert.CertStore
 * @see CollectionCertStore
 *
 * @author Andreas Sterbenz
 */
public class IndexedCollectionCertStore extends CertStoreSpi {

    /**
     * Map X500Principal(subject) -&gt; X509Certificate | List of X509Certificate
     */
    private Map&lt;X500Principal, Object&gt; certSubjects;
    /**
     * Map X500Principal(issuer) -&gt; X509CRL | List of X509CRL
     */
    private Map&lt;X500Principal, Object&gt; crlIssuers;
    /**
     * Sets of non-X509 certificates and CRLs
     */
    private Set&lt;Certificate&gt; otherCertificates;
    private Set&lt;CRL&gt; otherCRLs;

    /**
     * Creates a &lt;code&gt;CertStore&lt;/code&gt; with the specified parameters.
     * For this class, the parameters object must be an instance of
     * &lt;code&gt;CollectionCertStoreParameters&lt;/code&gt;.
     *
     * @param params the algorithm parameters
     * @exception InvalidAlgorithmParameterException if params is not an
     *   instance of &lt;code&gt;CollectionCertStoreParameters&lt;/code&gt;
     */
    public IndexedCollectionCertStore(CertStoreParameters params)
            throws InvalidAlgorithmParameterException {
        super(params);
        if (!(params instanceof CollectionCertStoreParameters)) {
            throw new InvalidAlgorithmParameterException(
                &quot;parameters must be CollectionCertStoreParameters&quot;);
        }
        Collection&lt;?&gt; coll = ((CollectionCertStoreParameters)params).getCollection();
        if (coll == null) {
            throw new InvalidAlgorithmParameterException
                                        (&quot;Collection must not be null&quot;);
        }
        buildIndex(coll);
    }

    /**
     * Index the specified Collection copying all references to Certificates
     * and CRLs.
     */
    private void buildIndex(Collection&lt;?&gt; coll) {
        certSubjects = new HashMap&lt;X500Principal, Object&gt;();
        crlIssuers = new HashMap&lt;X500Principal, Object&gt;();
        otherCertificates = null;
        otherCRLs = null;
        for (Object obj : coll) {
            if (obj instanceof X509Certificate) {
                indexCertificate((X509Certificate)obj);
            } else if (obj instanceof X509CRL) {
                indexCRL((X509CRL)obj);
            } else if (obj instanceof Certificate) {
                if (otherCertificates == null) {
                    otherCertificates = new HashSet&lt;Certificate&gt;();
                }
                otherCertificates.add((Certificate)obj);
            } else if (obj instanceof CRL) {
                if (otherCRLs == null) {
                    otherCRLs = new HashSet&lt;CRL&gt;();
                }
                otherCRLs.add((CRL)obj);
            } else {
                // ignore
            }
        }
        if (otherCertificates == null) {
            otherCertificates = Collections.&lt;Certificate&gt;emptySet();
        }
        if (otherCRLs == null) {
            otherCRLs = Collections.&lt;CRL&gt;emptySet();
        }
    }

    /**
     * Add an X509Certificate to the index.
     */
    private void indexCertificate(X509Certificate cert) {
        X500Principal subject = cert.getSubjectX500Principal();
        Object oldEntry = certSubjects.put(subject, cert);
        if (oldEntry != null) { // assume this is unlikely
            if (oldEntry instanceof X509Certificate) {
                if (cert.equals(oldEntry)) {
                    return;
                }
                List&lt;X509Certificate&gt; list = new ArrayList&lt;&gt;(2);
                list.add(cert);
                list.add((X509Certificate)oldEntry);
                certSubjects.put(subject, list);
            } else {
                @SuppressWarnings(&quot;unchecked&quot;) // See certSubjects javadoc.
                List&lt;X509Certificate&gt; list = (List&lt;X509Certificate&gt;)oldEntry;
                if (list.contains(cert) == false) {
                    list.add(cert);
                }
                certSubjects.put(subject, list);
            }
        }
    }

    /**
     * Add an X509CRL to the index.
     */
    private void indexCRL(X509CRL crl) {
        X500Principal issuer = crl.getIssuerX500Principal();
        Object oldEntry = crlIssuers.put(issuer, crl);
        if (oldEntry != null) { // assume this is unlikely
            if (oldEntry instanceof X509CRL) {
                if (crl.equals(oldEntry)) {
                    return;
                }
                List&lt;X509CRL&gt; list = new ArrayList&lt;&gt;(2);
                list.add(crl);
                list.add((X509CRL)oldEntry);
                crlIssuers.put(issuer, list);
            } else {
                // See crlIssuers javadoc.
                @SuppressWarnings(&quot;unchecked&quot;)
                List&lt;X509CRL&gt; list = (List&lt;X509CRL&gt;)oldEntry;
                if (list.contains(crl) == false) {
                    list.add(crl);
                }
                crlIssuers.put(issuer, list);
            }
        }
    }

    /**
     * Returns a &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;Certificate&lt;/code&gt;s that
     * match the specified selector. If no &lt;code&gt;Certificate&lt;/code&gt;s
     * match the selector, an empty &lt;code&gt;Collection&lt;/code&gt; will be returned.
     *
     * @param selector a &lt;code&gt;CertSelector&lt;/code&gt; used to select which
     *  &lt;code&gt;Certificate&lt;/code&gt;s should be returned. Specify &lt;code&gt;null&lt;/code&gt;
     *  to return all &lt;code&gt;Certificate&lt;/code&gt;s.
     * @return a &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;Certificate&lt;/code&gt;s that
     *         match the specified selector
     * @throws CertStoreException if an exception occurs
     */
    @Override
    public Collection&lt;? extends Certificate&gt; engineGetCertificates(CertSelector selector)
            throws CertStoreException {

        // no selector means match all
        if (selector == null) {
            Set&lt;Certificate&gt; matches = new HashSet&lt;&gt;();
            matchX509Certs(new X509CertSelector(), matches);
            matches.addAll(otherCertificates);
            return matches;
        }

        if (selector instanceof X509CertSelector == false) {
            Set&lt;Certificate&gt; matches = new HashSet&lt;&gt;();
            matchX509Certs(selector, matches);
            for (Certificate cert : otherCertificates) {
                if (selector.match(cert)) {
                    matches.add(cert);
                }
            }
            return matches;
        }

        if (certSubjects.isEmpty()) {
            return Collections.&lt;X509Certificate&gt;emptySet();
        }
        X509CertSelector x509Selector = (X509CertSelector)selector;
        // see if the subject is specified
        X500Principal subject;
        X509Certificate matchCert = x509Selector.getCertificate();
        if (matchCert != null) {
            subject = matchCert.getSubjectX500Principal();
        } else {
            subject = x509Selector.getSubject();
        }
        if (subject != null) {
            // yes, narrow down candidates to indexed possibilities
            Object entry = certSubjects.get(subject);
            if (entry == null) {
                return Collections.&lt;X509Certificate&gt;emptySet();
            }
            if (entry instanceof X509Certificate) {
                X509Certificate x509Entry = (X509Certificate)entry;
                if (x509Selector.match(x509Entry)) {
                    return Collections.singleton(x509Entry);
                } else {
                    return Collections.&lt;X509Certificate&gt;emptySet();
                }
            } else {
                // See certSubjects javadoc.
                @SuppressWarnings(&quot;unchecked&quot;)
                List&lt;X509Certificate&gt; list = (List&lt;X509Certificate&gt;)entry;
                Set&lt;X509Certificate&gt; matches = new HashSet&lt;&gt;(16);
                for (X509Certificate cert : list) {
                    if (x509Selector.match(cert)) {
                        matches.add(cert);
                    }
                }
                return matches;
            }
        }
        // cannot use index, iterate all
        Set&lt;Certificate&gt; matches = new HashSet&lt;&gt;(16);
        matchX509Certs(x509Selector, matches);
        return matches;
    }

    /**
     * Iterate through all the X509Certificates and add matches to the
     * collection.
     */
    private void matchX509Certs(CertSelector selector,
        Collection&lt;Certificate&gt; matches) {

        for (Object obj : certSubjects.values()) {
            if (obj instanceof X509Certificate) {
                X509Certificate cert = (X509Certificate)obj;
                if (selector.match(cert)) {
                    matches.add(cert);
                }
            } else {
                // See certSubjects javadoc.
                @SuppressWarnings(&quot;unchecked&quot;)
                List&lt;X509Certificate&gt; list = (List&lt;X509Certificate&gt;)obj;
                for (X509Certificate cert : list) {
                    if (selector.match(cert)) {
                        matches.add(cert);
                    }
                }
            }
        }
    }

    /**
     * Returns a &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;CRL&lt;/code&gt;s that
     * match the specified selector. If no &lt;code&gt;CRL&lt;/code&gt;s
     * match the selector, an empty &lt;code&gt;Collection&lt;/code&gt; will be returned.
     *
     * @param selector a &lt;code&gt;CRLSelector&lt;/code&gt; used to select which
     *  &lt;code&gt;CRL&lt;/code&gt;s should be returned. Specify &lt;code&gt;null&lt;/code&gt;
     *  to return all &lt;code&gt;CRL&lt;/code&gt;s.
     * @return a &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;CRL&lt;/code&gt;s that
     *         match the specified selector
     * @throws CertStoreException if an exception occurs
     */
    @Override
    public Collection&lt;CRL&gt; engineGetCRLs(CRLSelector selector)
            throws CertStoreException {

        if (selector == null) {
            Set&lt;CRL&gt; matches = new HashSet&lt;&gt;();
            matchX509CRLs(new X509CRLSelector(), matches);
            matches.addAll(otherCRLs);
            return matches;
        }

        if (selector instanceof X509CRLSelector == false) {
            Set&lt;CRL&gt; matches = new HashSet&lt;&gt;();
            matchX509CRLs(selector, matches);
            for (CRL crl : otherCRLs) {
                if (selector.match(crl)) {
                    matches.add(crl);
                }
            }
            return matches;
        }

        if (crlIssuers.isEmpty()) {
            return Collections.&lt;CRL&gt;emptySet();
        }
        X509CRLSelector x509Selector = (X509CRLSelector)selector;
        // see if the issuer is specified
        Collection&lt;X500Principal&gt; issuers = x509Selector.getIssuers();
        if (issuers != null) {
            HashSet&lt;CRL&gt; matches = new HashSet&lt;&gt;(16);
            for (X500Principal issuer : issuers) {
                Object entry = crlIssuers.get(issuer);
                if (entry == null) {
                    // empty
                } else if (entry instanceof X509CRL) {
                    X509CRL crl = (X509CRL)entry;
                    if (x509Selector.match(crl)) {
                        matches.add(crl);
                    }
                } else { // List
                    // See crlIssuers javadoc.
                    @SuppressWarnings(&quot;unchecked&quot;)
                    List&lt;X509CRL&gt; list = (List&lt;X509CRL&gt;)entry;
                    for (X509CRL crl : list) {
                        if (x509Selector.match(crl)) {
                            matches.add(crl);
                        }
                    }
                }
            }
            return matches;
        }
        // cannot use index, iterate all
        Set&lt;CRL&gt; matches = new HashSet&lt;&gt;(16);
        matchX509CRLs(x509Selector, matches);
        return matches;
    }

    /**
     * Iterate through all the X509CRLs and add matches to the
     * collection.
     */
    private void matchX509CRLs(CRLSelector selector, Collection&lt;CRL&gt; matches) {
        for (Object obj : crlIssuers.values()) {
            if (obj instanceof X509CRL) {
                X509CRL crl = (X509CRL)obj;
                if (selector.match(crl)) {
                    matches.add(crl);
                }
            } else {
                // See crlIssuers javadoc.
                @SuppressWarnings(&quot;unchecked&quot;)
                List&lt;X509CRL&gt; list = (List&lt;X509CRL&gt;)obj;
                for (X509CRL crl : list) {
                    if (selector.match(crl)) {
                        matches.add(crl);
                    }
                }
            }
        }
    }

}
</pre>
</body>
</html>
