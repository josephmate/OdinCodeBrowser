<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider;

import java.net.URL;
import java.util.*;
import java.security.CodeSource;
import java.security.Principal;
import java.security.cert.Certificate;
import java.lang.reflect.Constructor;

import javax.security.auth.Subject;
import sun.security.provider.PolicyParser.PrincipalEntry;

/**
 * &lt;p&gt; This &lt;code&gt;SubjectCodeSource&lt;/code&gt; class contains
 * a &lt;code&gt;URL&lt;/code&gt;, signer certificates, and either a &lt;code&gt;Subject&lt;/code&gt;
 * (that represents the &lt;code&gt;Subject&lt;/code&gt; in the current
 * &lt;code&gt;AccessControlContext&lt;/code&gt;), or a linked list of Principals
 * (that represent a &quot;subject&quot; in a &lt;code&gt;Policy&lt;/code&gt;).
 *
 */
class SubjectCodeSource extends CodeSource implements java.io.Serializable {

    private static final long serialVersionUID = 6039418085604715275L;

    private static final java.util.ResourceBundle rb =
        java.security.AccessController.doPrivileged
        (new java.security.PrivilegedAction&lt;java.util.ResourceBundle&gt;() {
            public java.util.ResourceBundle run() {
                return (java.util.ResourceBundle.getBundle
                        (&quot;sun.security.util.AuthResources&quot;));
            }
        });

    private Subject subject;
    private LinkedList&lt;PrincipalEntry&gt; principals;
    private static final Class&lt;?&gt;[] PARAMS = { String.class };
    private static final sun.security.util.Debug debug =
        sun.security.util.Debug.getInstance(&quot;auth&quot;, &quot;\t[Auth Access]&quot;);
    private ClassLoader sysClassLoader;

    /**
     * Creates a new &lt;code&gt;SubjectCodeSource&lt;/code&gt;
     * with the given &lt;code&gt;Subject&lt;/code&gt;, principals, &lt;code&gt;URL&lt;/code&gt;,
     * and signers (Certificates).  The &lt;code&gt;Subject&lt;/code&gt;
     * represents the &lt;code&gt;Subject&lt;/code&gt; associated with the current
     * &lt;code&gt;AccessControlContext&lt;/code&gt;.
     * The Principals are given as a &lt;code&gt;LinkedList&lt;/code&gt;
     * of &lt;code&gt;PolicyParser.PrincipalEntry&lt;/code&gt; objects.
     * Typically either a &lt;code&gt;Subject&lt;/code&gt; will be provided,
     * or a list of &lt;code&gt;principals&lt;/code&gt; will be provided
     * (not both).
     *
     * &lt;p&gt;
     *
     * @param subject the &lt;code&gt;Subject&lt;/code&gt; associated with this
     *                  &lt;code&gt;SubjectCodeSource&lt;/code&gt; &lt;p&gt;
     *
     * @param url the &lt;code&gt;URL&lt;/code&gt; associated with this
     *                  &lt;code&gt;SubjectCodeSource&lt;/code&gt; &lt;p&gt;
     *
     * @param certs the signers associated with this
     *                  &lt;code&gt;SubjectCodeSource&lt;/code&gt; &lt;p&gt;
     */
    SubjectCodeSource(Subject subject,
        LinkedList&lt;PrincipalEntry&gt; principals,
        URL url, Certificate[] certs) {

        super(url, certs);
        this.subject = subject;
        this.principals = (principals == null ?
                new LinkedList&lt;PrincipalEntry&gt;() :
                new LinkedList&lt;PrincipalEntry&gt;(principals));
        sysClassLoader = java.security.AccessController.doPrivileged
        (new java.security.PrivilegedAction&lt;ClassLoader&gt;() {
            public ClassLoader run() {
                    return ClassLoader.getSystemClassLoader();
            }
        });
    }

    /**
     * Get the Principals associated with this &lt;code&gt;SubjectCodeSource&lt;/code&gt;.
     * The Principals are retrieved as a &lt;code&gt;LinkedList&lt;/code&gt;
     * of &lt;code&gt;PolicyParser.PrincipalEntry&lt;/code&gt; objects.
     *
     * &lt;p&gt;
     *
     * @return the Principals associated with this
     *          &lt;code&gt;SubjectCodeSource&lt;/code&gt; as a &lt;code&gt;LinkedList&lt;/code&gt;
     *          of &lt;code&gt;PolicyParser.PrincipalEntry&lt;/code&gt; objects.
     */
    LinkedList&lt;PrincipalEntry&gt; getPrincipals() {
        return principals;
    }

    /**
     * Get the &lt;code&gt;Subject&lt;/code&gt; associated with this
     * &lt;code&gt;SubjectCodeSource&lt;/code&gt;.  The &lt;code&gt;Subject&lt;/code&gt;
     * represents the &lt;code&gt;Subject&lt;/code&gt; associated with the
     * current &lt;code&gt;AccessControlContext&lt;/code&gt;.
     *
     * &lt;p&gt;
     *
     * @return the &lt;code&gt;Subject&lt;/code&gt; associated with this
     *          &lt;code&gt;SubjectCodeSource&lt;/code&gt;.
     */
    Subject getSubject() {
        return subject;
    }

    /**
     * Returns true if this &lt;code&gt;SubjectCodeSource&lt;/code&gt; object &quot;implies&quot;
     * the specified &lt;code&gt;CodeSource&lt;/code&gt;.
     * More specifically, this method makes the following checks.
     * If any fail, it returns false.  If they all succeed, it returns true.
     *
     * &lt;p&gt;
     * &lt;ol&gt;
     * &lt;li&gt; The provided codesource must not be &lt;code&gt;null&lt;/code&gt;.
     * &lt;li&gt; codesource must be an instance of &lt;code&gt;SubjectCodeSource&lt;/code&gt;.
     * &lt;li&gt; super.implies(codesource) must return true.
     * &lt;li&gt; for each principal in this codesource's principal list:
     * &lt;ol&gt;
     * &lt;li&gt;     if the principal is an instanceof
     *          &lt;code&gt;Principal&lt;/code&gt;, then the principal must
     *          imply the provided codesource's &lt;code&gt;Subject&lt;/code&gt;.
     * &lt;li&gt;     if the principal is not an instanceof
     *          &lt;code&gt;Principal&lt;/code&gt;, then the provided
     *          codesource's &lt;code&gt;Subject&lt;/code&gt; must have an
     *          associated &lt;code&gt;Principal&lt;/code&gt;, &lt;i&gt;P&lt;/i&gt;, where
     *          P.getClass().getName equals principal.principalClass,
     *          and P.getName() equals principal.principalName.
     * &lt;/ol&gt;
     * &lt;/ol&gt;
     *
     * &lt;p&gt;
     *
     * @param codesource the &lt;code&gt;CodeSource&lt;/code&gt; to compare against.
     *
     * @return true if this &lt;code&gt;SubjectCodeSource&lt;/code&gt; implies the
     *          the specified &lt;code&gt;CodeSource&lt;/code&gt;.
     */
    public boolean implies(CodeSource codesource) {

        LinkedList&lt;PrincipalEntry&gt; subjectList = null;

        if (codesource == null ||
            !(codesource instanceof SubjectCodeSource) ||
            !(super.implies(codesource))) {

            if (debug != null)
                debug.println(&quot;\tSubjectCodeSource.implies: FAILURE 1&quot;);
            return false;
        }

        SubjectCodeSource that = (SubjectCodeSource)codesource;

        // if the principal list in the policy &quot;implies&quot;
        // the Subject associated with the current AccessControlContext,
        // then return true

        if (this.principals == null) {
            if (debug != null)
                debug.println(&quot;\tSubjectCodeSource.implies: PASS 1&quot;);
            return true;
        }

        if (that.getSubject() == null ||
            that.getSubject().getPrincipals().size() == 0) {
            if (debug != null)
                debug.println(&quot;\tSubjectCodeSource.implies: FAILURE 2&quot;);
            return false;
        }

        ListIterator&lt;PrincipalEntry&gt; li = this.principals.listIterator(0);
        while (li.hasNext()) {
            PrincipalEntry pppe = li.next();
            try {

                // use new Principal.implies method

                Class&lt;?&gt; pClass = Class.forName(pppe.principalClass,
                                                true, sysClassLoader);
                if (!Principal.class.isAssignableFrom(pClass)) {
                    // not the right subtype
                    throw new ClassCastException(pppe.principalClass +
                                                 &quot; is not a Principal&quot;);
                }
                Constructor&lt;?&gt; c = pClass.getConstructor(PARAMS);
                Principal p = (Principal)c.newInstance(new Object[] {
                                                       pppe.principalName });

                if (!p.implies(that.getSubject())) {
                    if (debug != null)
                        debug.println(&quot;\tSubjectCodeSource.implies: FAILURE 3&quot;);
                    return false;
                } else {
                    if (debug != null)
                        debug.println(&quot;\tSubjectCodeSource.implies: PASS 2&quot;);
                    return true;
                }
            } catch (Exception e) {

                // simply compare Principals

                if (subjectList == null) {

                    if (that.getSubject() == null) {
                        if (debug != null)
                            debug.println(&quot;\tSubjectCodeSource.implies: &quot; +
                                        &quot;FAILURE 4&quot;);
                        return false;
                    }
                    Iterator&lt;Principal&gt; i =
                                that.getSubject().getPrincipals().iterator();

                    subjectList = new LinkedList&lt;PrincipalEntry&gt;();
                    while (i.hasNext()) {
                        Principal p = i.next();
                        PrincipalEntry spppe = new PrincipalEntry
                                (p.getClass().getName(), p.getName());
                        subjectList.add(spppe);
                    }
                }

                if (!subjectListImpliesPrincipalEntry(subjectList, pppe)) {
                    if (debug != null)
                        debug.println(&quot;\tSubjectCodeSource.implies: FAILURE 5&quot;);
                    return false;
                }
            }
        }

        if (debug != null)
            debug.println(&quot;\tSubjectCodeSource.implies: PASS 3&quot;);
        return true;
    }

    /**
     * This method returns, true, if the provided &lt;i&gt;subjectList&lt;/i&gt;
     * &quot;contains&quot; the &lt;code&gt;Principal&lt;/code&gt; specified
     * in the provided &lt;i&gt;pppe&lt;/i&gt; argument.
     *
     * Note that the provided &lt;i&gt;pppe&lt;/i&gt; argument may have
     * wildcards (*) for the &lt;code&gt;Principal&lt;/code&gt; class and name,
     * which need to be considered.
     *
     * &lt;p&gt;
     *
     * @param subjectList a list of PolicyParser.PrincipalEntry objects
     *          that correspond to all the Principals in the Subject currently
     *          on this thread's AccessControlContext. &lt;p&gt;
     *
     * @param pppe the Principals specified in a grant entry.
     *
     * @return true if the provided &lt;i&gt;subjectList&lt;/i&gt; &quot;contains&quot;
     *          the &lt;code&gt;Principal&lt;/code&gt; specified in the provided
     *          &lt;i&gt;pppe&lt;/i&gt; argument.
     */
    private boolean subjectListImpliesPrincipalEntry(
                LinkedList&lt;PrincipalEntry&gt; subjectList, PrincipalEntry pppe) {

        ListIterator&lt;PrincipalEntry&gt; li = subjectList.listIterator(0);
        while (li.hasNext()) {
            PrincipalEntry listPppe = li.next();

            if (pppe.getPrincipalClass().equals
                        (PrincipalEntry.WILDCARD_CLASS) ||
                pppe.getPrincipalClass().equals(listPppe.getPrincipalClass()))
            {
                if (pppe.getPrincipalName().equals
                        (PrincipalEntry.WILDCARD_NAME) ||
                    pppe.getPrincipalName().equals(listPppe.getPrincipalName()))
                    return true;
            }
        }
        return false;
    }

    /**
     * Tests for equality between the specified object and this
     * object. Two &lt;code&gt;SubjectCodeSource&lt;/code&gt; objects are considered equal
     * if their locations are of identical value, if the two sets of
     * Certificates are of identical values, and if the
     * Subjects are equal, and if the PolicyParser.PrincipalEntry values
     * are of identical values.  It is not required that
     * the Certificates or PolicyParser.PrincipalEntry values
     * be in the same order.
     *
     * &lt;p&gt;
     *
     * @param obj the object to test for equality with this object.
     *
     * @return true if the objects are considered equal, false otherwise.
     */
    public boolean equals(Object obj) {

        if (obj == this)
            return true;

        if (super.equals(obj) == false)
            return false;

        if (!(obj instanceof SubjectCodeSource))
            return false;

        SubjectCodeSource that = (SubjectCodeSource)obj;

        // the principal lists must match
        try {
            if (this.getSubject() != that.getSubject())
                return false;
        } catch (SecurityException se) {
            return false;
        }

        if ((this.principals == null &amp;&amp; that.principals != null) ||
            (this.principals != null &amp;&amp; that.principals == null))
            return false;

        if (this.principals != null &amp;&amp; that.principals != null) {
            if (!this.principals.containsAll(that.principals) ||
                !that.principals.containsAll(this.principals))

                return false;
        }

        return true;
    }

    /**
     * Return a hashcode for this &lt;code&gt;SubjectCodeSource&lt;/code&gt;.
     *
     * &lt;p&gt;
     *
     * @return a hashcode for this &lt;code&gt;SubjectCodeSource&lt;/code&gt;.
     */
    public int hashCode() {
        return super.hashCode();
    }

    /**
     * Return a String representation of this &lt;code&gt;SubjectCodeSource&lt;/code&gt;.
     *
     * &lt;p&gt;
     *
     * @return a String representation of this &lt;code&gt;SubjectCodeSource&lt;/code&gt;.
     */
    public String toString() {
        String returnMe = super.toString();
        if (getSubject() != null) {
            if (debug != null) {
                final Subject finalSubject = getSubject();
                returnMe = returnMe + &quot;\n&quot; +
                        java.security.AccessController.doPrivileged
                                (new java.security.PrivilegedAction&lt;String&gt;() {
                                public String run() {
                                    return finalSubject.toString();
                                }
                        });
            } else {
                returnMe = returnMe + &quot;\n&quot; + getSubject().toString();
            }
        }
        if (principals != null) {
            ListIterator&lt;PrincipalEntry&gt; li = principals.listIterator();
            while (li.hasNext()) {
                PrincipalEntry pppe = li.next();
                returnMe = returnMe + rb.getString(&quot;NEWLINE&quot;) +
                        pppe.getPrincipalClass() + &quot; &quot; +
                        pppe.getPrincipalName();
            }
        }
        return returnMe;
    }
}
</pre>
</body>
</html>
