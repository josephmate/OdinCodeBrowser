<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider;

import java.io.*;
import java.net.*;
import java.security.*;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.CertificateException;
import java.util.*;

import sun.misc.IOUtils;
import sun.security.pkcs.EncryptedPrivateKeyInfo;
import sun.security.util.PolicyUtil;

/**
 * This class provides the domain keystore type identified as &quot;DKS&quot;.
 * DKS presents a collection of separate keystores as a single logical keystore.
 * The collection of keystores is specified in a domain configuration file which
 * is passed to DKS in a {@link DomainLoadStoreParameter}.
 * &lt;p&gt;
 * The following properties are supported:
 * &lt;dl&gt;
 * &lt;dt&gt; {@code keystoreType=&quot;&lt;type&gt;&quot;} &lt;/dt&gt;
 *     &lt;dd&gt; The keystore type. &lt;/dd&gt;
 * &lt;dt&gt; {@code keystoreURI=&quot;&lt;url&gt;&quot;} &lt;/dt&gt;
 *     &lt;dd&gt; The keystore location. &lt;/dd&gt;
 * &lt;dt&gt; {@code keystoreProviderName=&quot;&lt;name&gt;&quot;} &lt;/dt&gt;
 *     &lt;dd&gt; The name of the keystore's JCE provider. &lt;/dd&gt;
 * &lt;dt&gt; {@code keystorePasswordEnv=&quot;&lt;environment-variable&gt;&quot;} &lt;/dt&gt;
 *     &lt;dd&gt; The environment variable that stores a keystore password.
 * &lt;dt&gt; {@code entryNameSeparator=&quot;&lt;separator&gt;&quot;} &lt;/dt&gt;
 *     &lt;dd&gt; The separator between a keystore name prefix and an entry name.
 *          When specified, it applies to all the entries in a domain.
 *          Its default value is a space. &lt;/dd&gt;
 * &lt;/dl&gt;
 *
 * @since 1.8
 */

abstract class DomainKeyStore extends KeyStoreSpi {

    // regular DKS
    public static final class DKS extends DomainKeyStore {
        String convertAlias(String alias) {
            return alias.toLowerCase(Locale.ENGLISH);
        }
    }

    // DKS property names
    private static final String ENTRY_NAME_SEPARATOR = &quot;entrynameseparator&quot;;
    private static final String KEYSTORE_PROVIDER_NAME = &quot;keystoreprovidername&quot;;
    private static final String KEYSTORE_TYPE = &quot;keystoretype&quot;;
    private static final String KEYSTORE_URI = &quot;keystoreuri&quot;;
    private static final String KEYSTORE_PASSWORD_ENV = &quot;keystorepasswordenv&quot;;

    // RegEx meta characters
    private static final String REGEX_META = &quot;.$|()[{^?*+\\&quot;;

    // Default prefix for keystores loaded-by-stream
    private static final String DEFAULT_STREAM_PREFIX = &quot;iostream&quot;;
    private int streamCounter = 1;
    private String entryNameSeparator = &quot; &quot;;
    private String entryNameSeparatorRegEx = &quot; &quot;;

    // Default keystore type
    private static final String DEFAULT_KEYSTORE_TYPE =
        KeyStore.getDefaultType();

    // Domain keystores
    private final Map&lt;String, KeyStore&gt; keystores = new HashMap&lt;&gt;();

    DomainKeyStore() {
    }

    // convert an alias to internal form, overridden in subclasses:
    // lower case for regular DKS
    abstract String convertAlias(String alias);

    /**
     * Returns the key associated with the given alias, using the given
     * password to recover it.
     *
     * @param alias the alias name
     * @param password the password for recovering the key
     *
     * @return the requested key, or null if the given alias does not exist
     * or does not identify a &lt;i&gt;key entry&lt;/i&gt;.
     *
     * @exception NoSuchAlgorithmException if the algorithm for recovering the
     * key cannot be found
     * @exception UnrecoverableKeyException if the key cannot be recovered
     * (e.g., the given password is wrong).
     */
    public Key engineGetKey(String alias, char[] password)
        throws NoSuchAlgorithmException, UnrecoverableKeyException
    {
        AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt; pair =
            getKeystoresForReading(alias);
        Key key = null;

        try {
            String entryAlias = pair.getKey();
            for (KeyStore keystore : pair.getValue()) {
                key = keystore.getKey(entryAlias, password);
                if (key != null) {
                    break;
                }
            }
        } catch (KeyStoreException e) {
            throw new IllegalStateException(e);
        }

        return key;
    }

    /**
     * Returns the certificate chain associated with the given alias.
     *
     * @param alias the alias name
     *
     * @return the certificate chain (ordered with the user's certificate first
     * and the root certificate authority last), or null if the given alias
     * does not exist or does not contain a certificate chain (i.e., the given
     * alias identifies either a &lt;i&gt;trusted certificate entry&lt;/i&gt; or a
     * &lt;i&gt;key entry&lt;/i&gt; without a certificate chain).
     */
    public Certificate[] engineGetCertificateChain(String alias) {

        AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt; pair =
            getKeystoresForReading(alias);
        Certificate[] chain = null;

        try {
            String entryAlias = pair.getKey();
            for (KeyStore keystore : pair.getValue()) {
                chain = keystore.getCertificateChain(entryAlias);
                if (chain != null) {
                    break;
                }
            }
        } catch (KeyStoreException e) {
            throw new IllegalStateException(e);
        }

        return chain;
    }

    /**
     * Returns the certificate associated with the given alias.
     *
     * &lt;p&gt;If the given alias name identifies a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with that
     * entry is returned. If the given alias name identifies a
     * &lt;i&gt;key entry&lt;/i&gt;, the first element of the certificate chain of that
     * entry is returned, or null if that entry does not have a certificate
     * chain.
     *
     * @param alias the alias name
     *
     * @return the certificate, or null if the given alias does not exist or
     * does not contain a certificate.
     */
    public Certificate engineGetCertificate(String alias) {

        AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt; pair =
            getKeystoresForReading(alias);
        Certificate cert = null;

        try {
            String entryAlias = pair.getKey();
            for (KeyStore keystore : pair.getValue()) {
                cert = keystore.getCertificate(entryAlias);
                if (cert != null) {
                    break;
                }
            }
        } catch (KeyStoreException e) {
            throw new IllegalStateException(e);
        }

        return cert;
    }

    /**
     * Returns the creation date of the entry identified by the given alias.
     *
     * @param alias the alias name
     *
     * @return the creation date of this entry, or null if the given alias does
     * not exist
     */
    public Date engineGetCreationDate(String alias) {

        AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt; pair =
            getKeystoresForReading(alias);
        Date date = null;

        try {
            String entryAlias = pair.getKey();
            for (KeyStore keystore : pair.getValue()) {
                date = keystore.getCreationDate(entryAlias);
                if (date != null) {
                    break;
                }
            }
        } catch (KeyStoreException e) {
            throw new IllegalStateException(e);
        }

        return date;
    }

    /**
     * Assigns the given private key to the given alias, protecting
     * it with the given password as defined in PKCS8.
     *
     * &lt;p&gt;The given java.security.PrivateKey &lt;code&gt;key&lt;/code&gt; must
     * be accompanied by a certificate chain certifying the
     * corresponding public key.
     *
     * &lt;p&gt;If the given alias already exists, the keystore information
     * associated with it is overridden by the given key and certificate
     * chain.
     *
     * @param alias the alias name
     * @param key the private key to be associated with the alias
     * @param password the password to protect the key
     * @param chain the certificate chain for the corresponding public
     * key (only required if the given key is of type
     * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
     *
     * @exception KeyStoreException if the given key is not a private key,
     * cannot be protected, or this operation fails for some other reason
     */
    public void engineSetKeyEntry(String alias, Key key, char[] password,
                                  Certificate[] chain)
        throws KeyStoreException
    {
        AbstractMap.SimpleEntry&lt;String,
            AbstractMap.SimpleEntry&lt;String, KeyStore&gt;&gt; pair =
                getKeystoreForWriting(alias);

        if (pair == null) {
            throw new KeyStoreException(&quot;Error setting key entry for '&quot; +
                alias + &quot;'&quot;);
        }
        String entryAlias = pair.getKey();
        Map.Entry&lt;String, KeyStore&gt; keystore = pair.getValue();
        keystore.getValue().setKeyEntry(entryAlias, key, password, chain);
    }

    /**
     * Assigns the given key (that has already been protected) to the given
     * alias.
     *
     * &lt;p&gt;If the protected key is of type
     * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a
     * certificate chain certifying the corresponding public key. If the
     * underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;,
     * &lt;code&gt;key&lt;/code&gt; must be encoded as an
     * &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.
     *
     * &lt;p&gt;If the given alias already exists, the keystore information
     * associated with it is overridden by the given key (and possibly
     * certificate chain).
     *
     * @param alias the alias name
     * @param key the key (in protected format) to be associated with the alias
     * @param chain the certificate chain for the corresponding public
     * key (only useful if the protected key is of type
     * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
     *
     * @exception KeyStoreException if this operation fails.
     */
    public void engineSetKeyEntry(String alias, byte[] key,
                                  Certificate[] chain)
        throws KeyStoreException
    {
        AbstractMap.SimpleEntry&lt;String,
            AbstractMap.SimpleEntry&lt;String, KeyStore&gt;&gt; pair =
                getKeystoreForWriting(alias);

        if (pair == null) {
            throw new KeyStoreException(
                &quot;Error setting protected key entry for '&quot; + alias + &quot;'&quot;);
        }
        String entryAlias = pair.getKey();
        Map.Entry&lt;String, KeyStore&gt; keystore = pair.getValue();
        keystore.getValue().setKeyEntry(entryAlias, key, chain);
    }

    /**
     * Assigns the given certificate to the given alias.
     *
     * &lt;p&gt;If the given alias already exists in this keystore and identifies a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with it is
     * overridden by the given certificate.
     *
     * @param alias the alias name
     * @param cert the certificate
     *
     * @exception KeyStoreException if the given alias already exists and does
     * not identify a &lt;i&gt;trusted certificate entry&lt;/i&gt;, or this operation
     * fails for some other reason.
     */
    public void engineSetCertificateEntry(String alias, Certificate cert)
        throws KeyStoreException
    {
        AbstractMap.SimpleEntry&lt;String,
            AbstractMap.SimpleEntry&lt;String, KeyStore&gt;&gt; pair =
                getKeystoreForWriting(alias);

        if (pair == null) {
            throw new KeyStoreException(&quot;Error setting certificate entry for '&quot;
                + alias + &quot;'&quot;);
        }
        String entryAlias = pair.getKey();
        Map.Entry&lt;String, KeyStore&gt; keystore = pair.getValue();
        keystore.getValue().setCertificateEntry(entryAlias, cert);
    }

    /**
     * Deletes the entry identified by the given alias from this keystore.
     *
     * @param alias the alias name
     *
     * @exception KeyStoreException if the entry cannot be removed.
     */
    public void engineDeleteEntry(String alias) throws KeyStoreException
    {
        AbstractMap.SimpleEntry&lt;String,
            AbstractMap.SimpleEntry&lt;String, KeyStore&gt;&gt; pair =
                getKeystoreForWriting(alias);

        if (pair == null) {
            throw new KeyStoreException(&quot;Error deleting entry for '&quot; + alias +
                &quot;'&quot;);
        }
        String entryAlias = pair.getKey();
        Map.Entry&lt;String, KeyStore&gt; keystore = pair.getValue();
        keystore.getValue().deleteEntry(entryAlias);
    }

    /**
     * Lists all the alias names of this keystore.
     *
     * @return enumeration of the alias names
     */
    public Enumeration&lt;String&gt; engineAliases() {
        final Iterator&lt;Map.Entry&lt;String, KeyStore&gt;&gt; iterator =
            keystores.entrySet().iterator();

        return new Enumeration&lt;String&gt;() {
            private int index = 0;
            private Map.Entry&lt;String, KeyStore&gt; keystoresEntry = null;
            private String prefix = null;
            private Enumeration&lt;String&gt; aliases = null;

            public boolean hasMoreElements() {
                try {
                    if (aliases == null) {
                        if (iterator.hasNext()) {
                            keystoresEntry = iterator.next();
                            prefix = keystoresEntry.getKey() +
                                entryNameSeparator;
                            aliases = keystoresEntry.getValue().aliases();
                        } else {
                            return false;
                        }
                    }
                    if (aliases.hasMoreElements()) {
                        return true;
                    } else {
                        if (iterator.hasNext()) {
                            keystoresEntry = iterator.next();
                            prefix = keystoresEntry.getKey() +
                                entryNameSeparator;
                            aliases = keystoresEntry.getValue().aliases();
                        } else {
                            return false;
                        }
                    }
                } catch (KeyStoreException e) {
                    return false;
                }

                return aliases.hasMoreElements();
            }

            public String nextElement() {
                if (hasMoreElements()) {
                    return prefix + aliases.nextElement();
                }
                throw new NoSuchElementException();
            }
        };
    }

    /**
     * Checks if the given alias exists in this keystore.
     *
     * @param alias the alias name
     *
     * @return true if the alias exists, false otherwise
     */
    public boolean engineContainsAlias(String alias) {

        AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt; pair =
            getKeystoresForReading(alias);

        try {
            String entryAlias = pair.getKey();
            for (KeyStore keystore : pair.getValue()) {
                if (keystore.containsAlias(entryAlias)) {
                    return true;
                }
            }
        } catch (KeyStoreException e) {
            throw new IllegalStateException(e);
        }

        return false;
    }

    /**
     * Retrieves the number of entries in this keystore.
     *
     * @return the number of entries in this keystore
     */
    public int engineSize() {

        int size = 0;
        try {
            for (KeyStore keystore : keystores.values()) {
                size += keystore.size();
            }
        } catch (KeyStoreException e) {
            throw new IllegalStateException(e);
        }

        return size;
    }

    /**
     * Returns true if the entry identified by the given alias is a
     * &lt;i&gt;key entry&lt;/i&gt;, and false otherwise.
     *
     * @return true if the entry identified by the given alias is a
     * &lt;i&gt;key entry&lt;/i&gt;, false otherwise.
     */
    public boolean engineIsKeyEntry(String alias) {

        AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt; pair =
            getKeystoresForReading(alias);

        try {
            String entryAlias = pair.getKey();
            for (KeyStore keystore : pair.getValue()) {
                if (keystore.isKeyEntry(entryAlias)) {
                    return true;
                }
            }
        } catch (KeyStoreException e) {
            throw new IllegalStateException(e);
        }

        return false;
    }

    /**
     * Returns true if the entry identified by the given alias is a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, and false otherwise.
     *
     * @return true if the entry identified by the given alias is a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, false otherwise.
     */
    public boolean engineIsCertificateEntry(String alias) {

        AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt; pair =
            getKeystoresForReading(alias);

        try {
            String entryAlias = pair.getKey();
            for (KeyStore keystore : pair.getValue()) {
                if (keystore.isCertificateEntry(entryAlias)) {
                    return true;
                }
            }
        } catch (KeyStoreException e) {
            throw new IllegalStateException(e);
        }

        return false;
    }

    /*
     * Returns a keystore entry alias and a list of target keystores.
     * When the supplied alias prefix identifies a keystore then that single
     * keystore is returned. When no alias prefix is supplied then all the
     * keystores are returned.
     */
    private AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt;
        getKeystoresForReading(String alias) {

        String[] splits = alias.split(this.entryNameSeparatorRegEx, 2);
        if (splits.length == 2) { // prefixed alias
            KeyStore keystore = keystores.get(splits[0]);
            if (keystore != null) {
                return new AbstractMap.SimpleEntry&lt;&gt;(splits[1],
                    (Collection&lt;KeyStore&gt;) Collections.singleton(keystore));
            }
        } else if (splits.length == 1) { // unprefixed alias
            // Check all keystores for the first occurrence of the alias
            return new AbstractMap.SimpleEntry&lt;&gt;(alias, keystores.values());
        }
        return new AbstractMap.SimpleEntry&lt;&gt;(&quot;&quot;,
            (Collection&lt;KeyStore&gt;) Collections.&lt;KeyStore&gt;emptyList());
    }

    /*
     * Returns a keystore entry alias and a single target keystore.
     * An alias prefix must be supplied.
     */
    private
    AbstractMap.SimpleEntry&lt;String, AbstractMap.SimpleEntry&lt;String, KeyStore&gt;&gt;
        getKeystoreForWriting(String alias) {

        String[] splits = alias.split(this.entryNameSeparator, 2);
        if (splits.length == 2) { // prefixed alias
            KeyStore keystore = keystores.get(splits[0]);
            if (keystore != null) {
                return new AbstractMap.SimpleEntry&lt;&gt;(splits[1],
                    new AbstractMap.SimpleEntry&lt;&gt;(splits[0], keystore));
            }
        }
        return null;
    }

    /**
     * Returns the (alias) name of the first keystore entry whose certificate
     * matches the given certificate.
     *
     * &lt;p&gt;This method attempts to match the given certificate with each
     * keystore entry. If the entry being considered
     * is a &lt;i&gt;trusted certificate entry&lt;/i&gt;, the given certificate is
     * compared to that entry's certificate. If the entry being considered is
     * a &lt;i&gt;key entry&lt;/i&gt;, the given certificate is compared to the first
     * element of that entry's certificate chain (if a chain exists).
     *
     * @param cert the certificate to match with.
     *
     * @return the (alias) name of the first entry with matching certificate,
     * or null if no such entry exists in this keystore.
     */
    public String engineGetCertificateAlias(Certificate cert) {

        try {

            String alias = null;
            for (KeyStore keystore : keystores.values()) {
                if ((alias = keystore.getCertificateAlias(cert)) != null) {
                    break;
                }
            }
            return alias;

        } catch (KeyStoreException e) {
            throw new IllegalStateException(e);
        }
    }

    /**
     * Stores this keystore to the given output stream, and protects its
     * integrity with the given password.
     *
     * @param stream the output stream to which this keystore is written.
     * @param password the password to generate the keystore integrity check
     *
     * @exception IOException if there was an I/O problem with data
     * @exception NoSuchAlgorithmException if the appropriate data integrity
     * algorithm could not be found
     * @exception CertificateException if any of the certificates included in
     * the keystore data could not be stored
     */
    public void engineStore(OutputStream stream, char[] password)
        throws IOException, NoSuchAlgorithmException, CertificateException
    {
        // Support storing to a stream only when a single keystore has been
        // configured
        try {
            if (keystores.size() == 1) {
                keystores.values().iterator().next().store(stream, password);
                return;
            }
        } catch (KeyStoreException e) {
            throw new IllegalStateException(e);
        }

        throw new UnsupportedOperationException(
            &quot;This keystore must be stored using a DomainLoadStoreParameter&quot;);
    }

    @Override
    public void engineStore(KeyStore.LoadStoreParameter param)
        throws IOException, NoSuchAlgorithmException, CertificateException
    {
        if (param instanceof DomainLoadStoreParameter) {
            DomainLoadStoreParameter domainParameter =
                (DomainLoadStoreParameter) param;
            List&lt;KeyStoreBuilderComponents&gt; builders = getBuilders(
                domainParameter.getConfiguration(),
                    domainParameter.getProtectionParams());

            for (KeyStoreBuilderComponents builder : builders) {

                try {

                    KeyStore.ProtectionParameter pp = builder.protection;
                    if (!(pp instanceof KeyStore.PasswordProtection)) {
                        throw new KeyStoreException(
                            new IllegalArgumentException(&quot;ProtectionParameter&quot; +
                                &quot; must be a KeyStore.PasswordProtection&quot;));
                    }
                    char[] password =
                        ((KeyStore.PasswordProtection) builder.protection)
                            .getPassword();

                    // Store the keystores
                    KeyStore keystore = keystores.get(builder.name);

                    try (FileOutputStream stream =
                        new FileOutputStream(builder.file)) {

                        keystore.store(stream, password);
                    }
                } catch (KeyStoreException e) {
                    throw new IOException(e);
                }
            }
        } else {
            throw new UnsupportedOperationException(
                &quot;This keystore must be stored using a &quot; +
                &quot;DomainLoadStoreParameter&quot;);
        }
    }

    /**
     * Loads the keystore from the given input stream.
     *
     * &lt;p&gt;If a password is given, it is used to check the integrity of the
     * keystore data. Otherwise, the integrity of the keystore is not checked.
     *
     * @param stream the input stream from which the keystore is loaded
     * @param password the (optional) password used to check the integrity of
     * the keystore.
     *
     * @exception IOException if there is an I/O or format problem with the
     * keystore data
     * @exception NoSuchAlgorithmException if the algorithm used to check
     * the integrity of the keystore cannot be found
     * @exception CertificateException if any of the certificates in the
     * keystore could not be loaded
     */
    public void engineLoad(InputStream stream, char[] password)
        throws IOException, NoSuchAlgorithmException, CertificateException
    {
        // Support loading from a stream only for a JKS or default type keystore
        try {
            KeyStore keystore = null;

            try {
                keystore = KeyStore.getInstance(&quot;JKS&quot;);
                keystore.load(stream, password);

            } catch (Exception e) {
                // Retry
                if (!&quot;JKS&quot;.equalsIgnoreCase(DEFAULT_KEYSTORE_TYPE)) {
                    keystore = KeyStore.getInstance(DEFAULT_KEYSTORE_TYPE);
                    keystore.load(stream, password);
                } else {
                    throw e;
                }
            }
            String keystoreName = DEFAULT_STREAM_PREFIX + streamCounter++;
            keystores.put(keystoreName, keystore);

        } catch (Exception e) {
            throw new UnsupportedOperationException(
                &quot;This keystore must be loaded using a &quot; +
                &quot;DomainLoadStoreParameter&quot;);
        }
    }

    @Override
    public void engineLoad(KeyStore.LoadStoreParameter param)
        throws IOException, NoSuchAlgorithmException, CertificateException
    {
        if (param instanceof DomainLoadStoreParameter) {
            DomainLoadStoreParameter domainParameter =
                (DomainLoadStoreParameter) param;
            List&lt;KeyStoreBuilderComponents&gt; builders = getBuilders(
                domainParameter.getConfiguration(),
                    domainParameter.getProtectionParams());

            for (KeyStoreBuilderComponents builder : builders) {

                try {
                    // Load the keystores (file-based and non-file-based)
                    if (builder.file != null) {
                        keystores.put(builder.name,
                            KeyStore.Builder.newInstance(builder.type,
                                builder.provider, builder.file,
                                builder.protection)
                                    .getKeyStore());
                    } else {
                        keystores.put(builder.name,
                            KeyStore.Builder.newInstance(builder.type,
                                builder.provider, builder.protection)
                                    .getKeyStore());
                    }
                } catch (KeyStoreException e) {
                    throw new IOException(e);
                }
            }
        } else {
            throw new UnsupportedOperationException(
                &quot;This keystore must be loaded using a &quot; +
                &quot;DomainLoadStoreParameter&quot;);
        }
    }

    /*
     * Parse a keystore domain configuration file and associated collection
     * of keystore passwords to create a collection of KeyStore.Builder.
     */
    private List&lt;KeyStoreBuilderComponents&gt; getBuilders(URI configuration,
        Map&lt;String, KeyStore.ProtectionParameter&gt; passwords)
            throws IOException {

        PolicyParser parser = new PolicyParser(true); // expand properties
        Collection&lt;PolicyParser.DomainEntry&gt; domains = null;
        List&lt;KeyStoreBuilderComponents&gt; builders = new ArrayList&lt;&gt;();
        String uriDomain = configuration.getFragment();

        try (InputStreamReader configurationReader =
            new InputStreamReader(
                PolicyUtil.getInputStream(configuration.toURL()), &quot;UTF-8&quot;)) {
            parser.read(configurationReader);
            domains = parser.getDomainEntries();

        } catch (MalformedURLException mue) {
            throw new IOException(mue);

        } catch (PolicyParser.ParsingException pe) {
            throw new IOException(pe);
        }

        for (PolicyParser.DomainEntry domain : domains) {
            Map&lt;String, String&gt; domainProperties = domain.getProperties();

            if (uriDomain != null &amp;&amp;
                (!uriDomain.equalsIgnoreCase(domain.getName()))) {
                continue; // skip this domain
            }

            if (domainProperties.containsKey(ENTRY_NAME_SEPARATOR)) {
                this.entryNameSeparator =
                    domainProperties.get(ENTRY_NAME_SEPARATOR);
                // escape any regex meta characters
                char ch = 0;
                StringBuilder s = new StringBuilder();
                for (int i = 0; i &lt; this.entryNameSeparator.length(); i++) {
                    ch = this.entryNameSeparator.charAt(i);
                    if (REGEX_META.indexOf(ch) != -1) {
                        s.append('\\');
                    }
                    s.append(ch);
                }
                this.entryNameSeparatorRegEx = s.toString();
            }

            Collection&lt;PolicyParser.KeyStoreEntry&gt; keystores =
                domain.getEntries();
            for (PolicyParser.KeyStoreEntry keystore : keystores) {
                String keystoreName = keystore.getName();
                Map&lt;String, String&gt; properties =
                    new HashMap&lt;&gt;(domainProperties);
                properties.putAll(keystore.getProperties());

                String keystoreType = DEFAULT_KEYSTORE_TYPE;
                if (properties.containsKey(KEYSTORE_TYPE)) {
                    keystoreType = properties.get(KEYSTORE_TYPE);
                }

                Provider keystoreProvider = null;
                if (properties.containsKey(KEYSTORE_PROVIDER_NAME)) {
                    String keystoreProviderName =
                        properties.get(KEYSTORE_PROVIDER_NAME);
                    keystoreProvider =
                        Security.getProvider(keystoreProviderName);
                    if (keystoreProvider == null) {
                        throw new IOException(&quot;Error locating JCE provider: &quot; +
                            keystoreProviderName);
                    }
                }

                File keystoreFile = null;
                if (properties.containsKey(KEYSTORE_URI)) {
                    String uri = properties.get(KEYSTORE_URI);

                    try {
                        if (uri.startsWith(&quot;file://&quot;)) {
                            keystoreFile = new File(new URI(uri));
                        } else {
                            keystoreFile = new File(uri);
                        }

                    } catch (URISyntaxException | IllegalArgumentException e) {
                        throw new IOException(
                            &quot;Error processing keystore property: &quot; +
                                &quot;keystoreURI=\&quot;&quot; + uri + &quot;\&quot;&quot;, e);
                    }
                }

                KeyStore.ProtectionParameter keystoreProtection = null;
                if (passwords.containsKey(keystoreName)) {
                    keystoreProtection = passwords.get(keystoreName);

                } else if (properties.containsKey(KEYSTORE_PASSWORD_ENV)) {
                    String env = properties.get(KEYSTORE_PASSWORD_ENV);
                    String pwd = System.getenv(env);
                    if (pwd != null) {
                        keystoreProtection =
                            new KeyStore.PasswordProtection(pwd.toCharArray());
                    } else {
                        throw new IOException(
                            &quot;Error processing keystore property: &quot; +
                                &quot;keystorePasswordEnv=\&quot;&quot; + env + &quot;\&quot;&quot;);
                    }
                } else {
                    keystoreProtection = new KeyStore.PasswordProtection(null);
                }

                builders.add(new KeyStoreBuilderComponents(keystoreName,
                    keystoreType, keystoreProvider, keystoreFile,
                    keystoreProtection));
            }
            break; // skip other domains
        }
        if (builders.isEmpty()) {
            throw new IOException(&quot;Error locating domain configuration data &quot; +
                &quot;for: &quot; + configuration);
        }

        return builders;
    }

/*
 * Utility class that holds the components used to construct a KeyStore.Builder
 */
class KeyStoreBuilderComponents {
    String name;
    String type;
    Provider provider;
    File file;
    KeyStore.ProtectionParameter protection;

    KeyStoreBuilderComponents(String name, String type, Provider provider,
        File file, KeyStore.ProtectionParameter protection) {
        this.name = name;
        this.type = type;
        this.provider = provider;
        this.file = file;
        this.protection = protection;
    }
}
}
</pre>
</body>
</html>
