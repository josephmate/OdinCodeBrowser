<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider;

import java.io.*;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.security.Security;
import java.security.URIParameter;
import java.text.MessageFormat;
import java.util.*;
import javax.security.auth.AuthPermission;
import javax.security.auth.login.AppConfigurationEntry;
import javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag;
import javax.security.auth.login.Configuration;
import javax.security.auth.login.ConfigurationSpi;
import sun.security.util.Debug;
import sun.security.util.PropertyExpander;
import sun.security.util.ResourcesMgr;

/**
 * This class represents a default implementation for
 * {@code javax.security.auth.login.Configuration}.
 *
 * &lt;p&gt; This object stores the runtime login configuration representation,
 * and is the amalgamation of multiple static login configurations that
 * resides in files. The algorithm for locating the login configuration
 * file(s) and reading their information into this {@code Configuration}
 * object is:
 *
 * &lt;ol&gt;
 * &lt;li&gt;
 *   Loop through the security properties,
 *   &lt;i&gt;login.config.url.1&lt;/i&gt;, &lt;i&gt;login.config.url.2&lt;/i&gt;, ...,
 *   &lt;i&gt;login.config.url.X&lt;/i&gt;.
 *   Each property value specifies a {@code URL} pointing to a
 *   login configuration file to be loaded.  Read in and load
 *   each configuration.
 *
 * &lt;li&gt;
 *   The {@code java.lang.System} property
 *   &lt;i&gt;java.security.auth.login.config&lt;/i&gt;
 *   may also be set to a {@code URL} pointing to another
 *   login configuration file
 *   (which is the case when a user uses the -D switch at runtime).
 *   If this property is defined, and its use is allowed by the
 *   security property file (the Security property,
 *   &lt;i&gt;policy.allowSystemProperty&lt;/i&gt; is set to &lt;i&gt;true&lt;/i&gt;),
 *   also load that login configuration.
 *
 * &lt;li&gt;
 *   If the &lt;i&gt;java.security.auth.login.config&lt;/i&gt; property is defined using
 *   &quot;==&quot; (rather than &quot;=&quot;), then ignore all other specified
 *   login configurations and only load this configuration.
 *
 * &lt;li&gt;
 *   If no system or security properties were set, try to read from the file,
 *   ${user.home}/.java.login.config, where ${user.home} is the value
 *   represented by the &quot;user.home&quot; System property.
 * &lt;/ol&gt;
 *
 * &lt;p&gt; The configuration syntax supported by this implementation
 * is exactly that syntax specified in the
 * {@code javax.security.auth.login.Configuration} class.
 *
 * @see javax.security.auth.login.LoginContext
 * @see java.security.Security security properties
 */
public final class ConfigFile extends Configuration {

    private final Spi spi;

    public ConfigFile() {
        spi = new Spi();
    }

    @Override
    public AppConfigurationEntry[] getAppConfigurationEntry(String appName) {
        return spi.engineGetAppConfigurationEntry(appName);
    }

    @Override
    public synchronized void refresh() {
        spi.engineRefresh();
    }

    public final static class Spi extends ConfigurationSpi {

        private URL url;
        private boolean expandProp = true;
        private Map&lt;String, List&lt;AppConfigurationEntry&gt;&gt; configuration;
        private int linenum;
        private StreamTokenizer st;
        private int lookahead;

        private static Debug debugConfig = Debug.getInstance(&quot;configfile&quot;);
        private static Debug debugParser = Debug.getInstance(&quot;configparser&quot;);

        /**
         * Creates a new {@code ConfigurationSpi} object.
         *
         * @throws SecurityException if the {@code ConfigurationSpi} can not be
         *                           initialized
         */
        public Spi() {
            try {
                init();
            } catch (IOException ioe) {
                throw new SecurityException(ioe);
            }
        }

        /**
         * Creates a new {@code ConfigurationSpi} object from the specified
         * {@code URI}.
         *
         * @param uri the {@code URI}
         * @throws SecurityException if the {@code ConfigurationSpi} can not be
         *                           initialized
         * @throws NullPointerException if {@code uri} is null
         */
        public Spi(URI uri) {
            // only load config from the specified URI
            try {
                url = uri.toURL();
                init();
            } catch (IOException ioe) {
                throw new SecurityException(ioe);
            }
        }

        public Spi(final Configuration.Parameters params) throws IOException {

            // call in a doPrivileged
            //
            // we have already passed the Configuration.getInstance
            // security check.  also this class is not freely accessible
            // (it is in the &quot;sun&quot; package).

            try {
                AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Void&gt;() {
                    public Void run() throws IOException {
                        if (params == null) {
                            init();
                        } else {
                            if (!(params instanceof URIParameter)) {
                                throw new IllegalArgumentException
                                        (&quot;Unrecognized parameter: &quot; + params);
                            }
                            URIParameter uriParam = (URIParameter)params;
                            url = uriParam.getURI().toURL();
                            init();
                        }
                        return null;
                    }
                });
            } catch (PrivilegedActionException pae) {
                throw (IOException)pae.getException();
            }

            // if init() throws some other RuntimeException,
            // let it percolate up naturally.
        }

        /**
         * Read and initialize the entire login Configuration from the
         * configured URL.
         *
         * @throws IOException if the Configuration can not be initialized
         * @throws SecurityException if the caller does not have permission
         *                           to initialize the Configuration
         */
        private void init() throws IOException {

            boolean initialized = false;

            // For policy.expandProperties, check if either a security or system
            // property is set to false (old code erroneously checked the system
            // prop so we must check both to preserve compatibility).
            String expand = Security.getProperty(&quot;policy.expandProperties&quot;);
            if (expand == null) {
                expand = System.getProperty(&quot;policy.expandProperties&quot;);
            }
            if (&quot;false&quot;.equals(expand)) {
                expandProp = false;
            }

            // new configuration
            Map&lt;String, List&lt;AppConfigurationEntry&gt;&gt; newConfig = new HashMap&lt;&gt;();

            if (url != null) {
                /**
                 * If the caller specified a URI via Configuration.getInstance,
                 * we only read from that URI
                 */
                if (debugConfig != null) {
                    debugConfig.println(&quot;reading &quot; + url);
                }
                init(url, newConfig);
                configuration = newConfig;
                return;
            }

            /**
             * Caller did not specify URI via Configuration.getInstance.
             * Read from URLs listed in the java.security properties file.
             */
            String allowSys = Security.getProperty(&quot;policy.allowSystemProperty&quot;);

            if (&quot;true&quot;.equalsIgnoreCase(allowSys)) {
                String extra_config = System.getProperty
                                      (&quot;java.security.auth.login.config&quot;);
                if (extra_config != null) {
                    boolean overrideAll = false;
                    if (extra_config.startsWith(&quot;=&quot;)) {
                        overrideAll = true;
                        extra_config = extra_config.substring(1);
                    }
                    try {
                        extra_config = PropertyExpander.expand(extra_config);
                    } catch (PropertyExpander.ExpandException peee) {
                        throw ioException(&quot;Unable.to.properly.expand.config&quot;,
                                          extra_config);
                    }

                    URL configURL = null;
                    try {
                        configURL = new URL(extra_config);
                    } catch (MalformedURLException mue) {
                        File configFile = new File(extra_config);
                        if (configFile.exists()) {
                            configURL = configFile.toURI().toURL();
                        } else {
                            throw ioException(
                                &quot;extra.config.No.such.file.or.directory.&quot;,
                                extra_config);
                        }
                    }

                    if (debugConfig != null) {
                        debugConfig.println(&quot;reading &quot;+configURL);
                    }
                    init(configURL, newConfig);
                    initialized = true;
                    if (overrideAll) {
                        if (debugConfig != null) {
                            debugConfig.println(&quot;overriding other policies!&quot;);
                        }
                        configuration = newConfig;
                        return;
                    }
                }
            }

            int n = 1;
            String config_url;
            while ((config_url = Security.getProperty
                                     (&quot;login.config.url.&quot;+n)) != null) {
                try {
                    config_url = PropertyExpander.expand
                        (config_url).replace(File.separatorChar, '/');
                    if (debugConfig != null) {
                        debugConfig.println(&quot;\tReading config: &quot; + config_url);
                    }
                    init(new URL(config_url), newConfig);
                    initialized = true;
                } catch (PropertyExpander.ExpandException peee) {
                    throw ioException(&quot;Unable.to.properly.expand.config&quot;,
                                      config_url);
                }
                n++;
            }

            if (initialized == false &amp;&amp; n == 1 &amp;&amp; config_url == null) {

                // get the config from the user's home directory
                if (debugConfig != null) {
                    debugConfig.println(&quot;\tReading Policy &quot; +
                                &quot;from ~/.java.login.config&quot;);
                }
                config_url = System.getProperty(&quot;user.home&quot;);
                String userConfigFile = config_url + File.separatorChar +
                                        &quot;.java.login.config&quot;;

                // No longer throws an exception when there's no config file
                // at all. Returns an empty Configuration instead.
                if (new File(userConfigFile).exists()) {
                    init(new File(userConfigFile).toURI().toURL(), newConfig);
                }
            }

            configuration = newConfig;
        }

        private void init(URL config,
                          Map&lt;String, List&lt;AppConfigurationEntry&gt;&gt; newConfig)
                          throws IOException {

            try (InputStreamReader isr
                    = new InputStreamReader(getInputStream(config), &quot;UTF-8&quot;)) {
                readConfig(isr, newConfig);
            } catch (FileNotFoundException fnfe) {
                if (debugConfig != null) {
                    debugConfig.println(fnfe.toString());
                }
                throw new IOException(ResourcesMgr.getString
                    (&quot;Configuration.Error.No.such.file.or.directory&quot;,
                    &quot;sun.security.util.AuthResources&quot;));
            }
        }

        /**
         * Retrieve an entry from the Configuration using an application name
         * as an index.
         *
         * @param applicationName the name used to index the Configuration.
         * @return an array of AppConfigurationEntries which correspond to
         *         the stacked configuration of LoginModules for this
         *         application, or null if this application has no configured
         *         LoginModules.
         */
        @Override
        public AppConfigurationEntry[] engineGetAppConfigurationEntry
            (String applicationName) {

            List&lt;AppConfigurationEntry&gt; list = null;
            synchronized (configuration) {
                list = configuration.get(applicationName);
            }

            if (list == null || list.size() == 0) {
                return null;
            }

            AppConfigurationEntry[] entries =
                                    new AppConfigurationEntry[list.size()];
            Iterator&lt;AppConfigurationEntry&gt; iterator = list.iterator();
            for (int i = 0; iterator.hasNext(); i++) {
                AppConfigurationEntry e = iterator.next();
                entries[i] = new AppConfigurationEntry(e.getLoginModuleName(),
                                                       e.getControlFlag(),
                                                       e.getOptions());
            }
            return entries;
        }

        /**
         * Refresh and reload the Configuration by re-reading all of the
         * login configurations.
         *
         * @throws SecurityException if the caller does not have permission
         *                           to refresh the Configuration.
         */
        @Override
        public synchronized void engineRefresh() {

            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                sm.checkPermission(
                    new AuthPermission(&quot;refreshLoginConfiguration&quot;));
            }

            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
                public Void run() {
                    try {
                        init();
                    } catch (IOException ioe) {
                        throw new SecurityException(ioe.getLocalizedMessage(),
                                                    ioe);
                    }
                    return null;
                }
            });
        }

        private void readConfig(Reader reader,
            Map&lt;String, List&lt;AppConfigurationEntry&gt;&gt; newConfig)
            throws IOException {

            linenum = 1;

            if (!(reader instanceof BufferedReader)) {
                reader = new BufferedReader(reader);
            }

            st = new StreamTokenizer(reader);
            st.quoteChar('&quot;');
            st.wordChars('$', '$');
            st.wordChars('_', '_');
            st.wordChars('-', '-');
            st.wordChars('*', '*');
            st.lowerCaseMode(false);
            st.slashSlashComments(true);
            st.slashStarComments(true);
            st.eolIsSignificant(true);

            lookahead = nextToken();
            while (lookahead != StreamTokenizer.TT_EOF) {
                parseLoginEntry(newConfig);
            }
        }

        private void parseLoginEntry(
            Map&lt;String, List&lt;AppConfigurationEntry&gt;&gt; newConfig)
            throws IOException {

            List&lt;AppConfigurationEntry&gt; configEntries = new LinkedList&lt;&gt;();

            // application name
            String appName = st.sval;
            lookahead = nextToken();

            if (debugParser != null) {
                debugParser.println(&quot;\tReading next config entry: &quot; + appName);
            }

            match(&quot;{&quot;);

            // get the modules
            while (peek(&quot;}&quot;) == false) {
                // get the module class name
                String moduleClass = match(&quot;module class name&quot;);

                // controlFlag (required, optional, etc)
                LoginModuleControlFlag controlFlag;
                String sflag = match(&quot;controlFlag&quot;).toUpperCase();
                switch (sflag) {
                    case &quot;REQUIRED&quot;:
                        controlFlag = LoginModuleControlFlag.REQUIRED;
                        break;
                    case &quot;REQUISITE&quot;:
                        controlFlag = LoginModuleControlFlag.REQUISITE;
                        break;
                    case &quot;SUFFICIENT&quot;:
                        controlFlag = LoginModuleControlFlag.SUFFICIENT;
                        break;
                    case &quot;OPTIONAL&quot;:
                        controlFlag = LoginModuleControlFlag.OPTIONAL;
                        break;
                    default:
                        throw ioException(
                            &quot;Configuration.Error.Invalid.control.flag.flag&quot;,
                            sflag);
                }

                // get the args
                Map&lt;String, String&gt; options = new HashMap&lt;&gt;();
                while (peek(&quot;;&quot;) == false) {
                    String key = match(&quot;option key&quot;);
                    match(&quot;=&quot;);
                    try {
                        options.put(key, expand(match(&quot;option value&quot;)));
                    } catch (PropertyExpander.ExpandException peee) {
                        throw new IOException(peee.getLocalizedMessage());
                    }
                }

                lookahead = nextToken();

                // create the new element
                if (debugParser != null) {
                    debugParser.println(&quot;\t\t&quot; + moduleClass + &quot;, &quot; + sflag);
                    for (String key : options.keySet()) {
                        debugParser.println(&quot;\t\t\t&quot; + key +
                                            &quot;=&quot; + options.get(key));
                    }
                }
                configEntries.add(new AppConfigurationEntry(moduleClass,
                                                            controlFlag,
                                                            options));
            }

            match(&quot;}&quot;);
            match(&quot;;&quot;);

            // add this configuration entry
            if (newConfig.containsKey(appName)) {
                throw ioException(
                    &quot;Configuration.Error.Can.not.specify.multiple.entries.for.appName&quot;,
                    appName);
            }
            newConfig.put(appName, configEntries);
        }

        private String match(String expect) throws IOException {

            String value = null;

            switch(lookahead) {
            case StreamTokenizer.TT_EOF:
                throw ioException(
                    &quot;Configuration.Error.expected.expect.read.end.of.file.&quot;,
                    expect);

            case '&quot;':
            case StreamTokenizer.TT_WORD:
                if (expect.equalsIgnoreCase(&quot;module class name&quot;) ||
                    expect.equalsIgnoreCase(&quot;controlFlag&quot;) ||
                    expect.equalsIgnoreCase(&quot;option key&quot;) ||
                    expect.equalsIgnoreCase(&quot;option value&quot;)) {
                    value = st.sval;
                    lookahead = nextToken();
                } else {
                    throw ioException(
                        &quot;Configuration.Error.Line.line.expected.expect.found.value.&quot;,
                        new Integer(linenum), expect, st.sval);
                }
                break;

            case '{':
                if (expect.equalsIgnoreCase(&quot;{&quot;)) {
                    lookahead = nextToken();
                } else {
                    throw ioException(
                        &quot;Configuration.Error.Line.line.expected.expect.&quot;,
                        new Integer(linenum), expect, st.sval);
                }
                break;

            case ';':
                if (expect.equalsIgnoreCase(&quot;;&quot;)) {
                    lookahead = nextToken();
                } else {
                    throw ioException(
                        &quot;Configuration.Error.Line.line.expected.expect.&quot;,
                        new Integer(linenum), expect, st.sval);
                }
                break;

            case '}':
                if (expect.equalsIgnoreCase(&quot;}&quot;)) {
                    lookahead = nextToken();
                } else {
                    throw ioException(
                        &quot;Configuration.Error.Line.line.expected.expect.&quot;,
                        new Integer(linenum), expect, st.sval);
                }
                break;

            case '=':
                if (expect.equalsIgnoreCase(&quot;=&quot;)) {
                    lookahead = nextToken();
                } else {
                    throw ioException(
                        &quot;Configuration.Error.Line.line.expected.expect.&quot;,
                        new Integer(linenum), expect, st.sval);
                }
                break;

            default:
                throw ioException(
                    &quot;Configuration.Error.Line.line.expected.expect.found.value.&quot;,
                    new Integer(linenum), expect, st.sval);
            }
            return value;
        }

        private boolean peek(String expect) {
            switch (lookahead) {
                case ',':
                    return expect.equalsIgnoreCase(&quot;,&quot;);
                case ';':
                    return expect.equalsIgnoreCase(&quot;;&quot;);
                case '{':
                    return expect.equalsIgnoreCase(&quot;{&quot;);
                case '}':
                    return expect.equalsIgnoreCase(&quot;}&quot;);
                default:
                    return false;
            }
        }

        private int nextToken() throws IOException {
            int tok;
            while ((tok = st.nextToken()) == StreamTokenizer.TT_EOL) {
                linenum++;
            }
            return tok;
        }

        private InputStream getInputStream(URL url) throws IOException {
            if (&quot;file&quot;.equalsIgnoreCase(url.getProtocol())) {
                // Compatibility notes:
                //
                // Code changed from
                //   String path = url.getFile().replace('/', File.separatorChar);
                //   return new FileInputStream(path);
                //
                // The original implementation would search for &quot;/tmp/a%20b&quot;
                // when url is &quot;file:///tmp/a%20b&quot;. This is incorrect. The
                // current codes fix this bug and searches for &quot;/tmp/a b&quot;.
                // For compatibility reasons, when the file &quot;/tmp/a b&quot; does
                // not exist, the file named &quot;/tmp/a%20b&quot; will be tried.
                //
                // This also means that if both file exists, the behavior of
                // this method is changed, and the current codes choose the
                // correct one.
                try {
                    return url.openStream();
                } catch (Exception e) {
                    String file = url.getPath();
                    if (url.getHost().length() &gt; 0) {  // For Windows UNC
                        file = &quot;//&quot; + url.getHost() + file;
                    }
                    if (debugConfig != null) {
                        debugConfig.println(&quot;cannot read &quot; + url +
                                            &quot;, try &quot; + file);
                    }
                    return new FileInputStream(file);
                }
            } else {
                return url.openStream();
            }
        }

        private String expand(String value)
            throws PropertyExpander.ExpandException, IOException {

            if (value.isEmpty()) {
                return value;
            }

            if (!expandProp) {
                return value;
            }
            String s = PropertyExpander.expand(value);
            if (s == null || s.length() == 0) {
                throw ioException(
                    &quot;Configuration.Error.Line.line.system.property.value.expanded.to.empty.value&quot;,
                    new Integer(linenum), value);
            }
            return s;
        }

        private IOException ioException(String resourceKey, Object... args) {
            MessageFormat form = new MessageFormat(ResourcesMgr.getString
                (resourceKey, &quot;sun.security.util.AuthResources&quot;));
            return new IOException(form.format(args));
        }
    }
}
</pre>
</body>
</html>
