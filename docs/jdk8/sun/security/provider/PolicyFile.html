<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider;

import java.io.*;
import java.lang.reflect.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URI;
import java.util.*;
import java.text.MessageFormat;
import java.security.*;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import javax.security.auth.Subject;
import javax.security.auth.x500.X500Principal;
import java.io.FilePermission;
import java.net.SocketPermission;
import java.net.NetPermission;
import java.util.concurrent.atomic.AtomicReference;
import sun.misc.JavaSecurityProtectionDomainAccess;
import static sun.misc.JavaSecurityProtectionDomainAccess.ProtectionDomainCache;
import sun.misc.SharedSecrets;
import sun.security.util.PolicyUtil;
import sun.security.util.PropertyExpander;
import sun.security.util.Debug;
import sun.security.util.ResourcesMgr;
import sun.security.util.SecurityConstants;
import sun.net.www.ParseUtil;

/**
 * This class represents a default implementation for
 * &lt;code&gt;java.security.Policy&lt;/code&gt;.
 *
 * Note:
 * For backward compatibility with JAAS 1.0 it loads
 * both java.auth.policy and java.policy. However it
 * is recommended that java.auth.policy be not used
 * and the java.policy contain all grant entries including
 * that contain principal-based entries.
 *
 *
 * &lt;p&gt; This object stores the policy for entire Java runtime,
 * and is the amalgamation of multiple static policy
 * configurations that resides in files.
 * The algorithm for locating the policy file(s) and reading their
 * information into this &lt;code&gt;Policy&lt;/code&gt; object is:
 *
 * &lt;ol&gt;
 * &lt;li&gt;
 *   Loop through the &lt;code&gt;java.security.Security&lt;/code&gt; properties,
 *   &lt;i&gt;policy.url.1&lt;/i&gt;, &lt;i&gt;policy.url.2&lt;/i&gt;, ...,
 *   &lt;i&gt;policy.url.X&lt;/i&gt;&quot; and
 *   &lt;i&gt;auth.policy.url.1&lt;/i&gt;, &lt;i&gt;auth.policy.url.2&lt;/i&gt;, ...,
 *   &lt;i&gt;auth.policy.url.X&lt;/i&gt;&quot;.  These properties are set
 *   in the Java security properties file, which is located in the file named
 *   &amp;lt;JAVA_HOME&amp;gt;/lib/security/java.security.
 *   &amp;lt;JAVA_HOME&amp;gt; refers to the value of the java.home system property,
 *   and specifies the directory where the JRE is installed.
 *   Each property value specifies a &lt;code&gt;URL&lt;/code&gt; pointing to a
 *   policy file to be loaded.  Read in and load each policy.
 *
 *   &lt;i&gt;auth.policy.url&lt;/i&gt; is supported only for backward compatibility.
 *
 * &lt;li&gt;
 *   The &lt;code&gt;java.lang.System&lt;/code&gt; property &lt;i&gt;java.security.policy&lt;/i&gt;
 *   may also be set to a &lt;code&gt;URL&lt;/code&gt; pointing to another policy file
 *   (which is the case when a user uses the -D switch at runtime).
 *   If this property is defined, and its use is allowed by the
 *   security property file (the Security property,
 *   &lt;i&gt;policy.allowSystemProperty&lt;/i&gt; is set to &lt;i&gt;true&lt;/i&gt;),
 *   also load that policy.
 *
 * &lt;li&gt;
 *   The &lt;code&gt;java.lang.System&lt;/code&gt; property
 *   &lt;i&gt;java.security.auth.policy&lt;/i&gt; may also be set to a
 *   &lt;code&gt;URL&lt;/code&gt; pointing to another policy file
 *   (which is the case when a user uses the -D switch at runtime).
 *   If this property is defined, and its use is allowed by the
 *   security property file (the Security property,
 *   &lt;i&gt;policy.allowSystemProperty&lt;/i&gt; is set to &lt;i&gt;true&lt;/i&gt;),
 *   also load that policy.
 *
 *   &lt;i&gt;java.security.auth.policy&lt;/i&gt; is supported only for backward
 *   compatibility.
 *
 *   If the  &lt;i&gt;java.security.policy&lt;/i&gt; or
 *   &lt;i&gt;java.security.auth.policy&lt;/i&gt; property is defined using
 *   &quot;==&quot; (rather than &quot;=&quot;), then ignore all other specified
 *   policies and only load this policy.
 * &lt;/ol&gt;
 *
 * Each policy file consists of one or more grant entries, each of
 * which consists of a number of permission entries.
 *
 * &lt;pre&gt;
 *   grant signedBy &quot;&lt;b&gt;alias&lt;/b&gt;&quot;, codeBase &quot;&lt;b&gt;URL&lt;/b&gt;&quot;,
 *         principal &lt;b&gt;principalClass&lt;/b&gt; &quot;&lt;b&gt;principalName&lt;/b&gt;&quot;,
 *         principal &lt;b&gt;principalClass&lt;/b&gt; &quot;&lt;b&gt;principalName&lt;/b&gt;&quot;,
 *         ... {
 *
 *     permission &lt;b&gt;Type&lt;/b&gt; &quot;&lt;b&gt;name&lt;/b&gt; &quot;&lt;b&gt;action&lt;/b&gt;&quot;,
 *         signedBy &quot;&lt;b&gt;alias&lt;/b&gt;&quot;;
 *     permission &lt;b&gt;Type&lt;/b&gt; &quot;&lt;b&gt;name&lt;/b&gt; &quot;&lt;b&gt;action&lt;/b&gt;&quot;,
 *         signedBy &quot;&lt;b&gt;alias&lt;/b&gt;&quot;;
 *     ....
 *   };
 * &lt;/pre&gt;
 *
 * All non-bold items above must appear as is (although case
 * doesn't matter and some are optional, as noted below).
 * principal entries are optional and need not be present.
 * Italicized items represent variable values.
 *
 * &lt;p&gt; A grant entry must begin with the word &lt;code&gt;grant&lt;/code&gt;.
 * The &lt;code&gt;signedBy&lt;/code&gt;,&lt;code&gt;codeBase&lt;/code&gt; and &lt;code&gt;principal&lt;/code&gt;
 * name/value pairs are optional.
 * If they are not present, then any signer (including unsigned code)
 * will match, and any codeBase will match.
 * Note that the &lt;i&gt;principalClass&lt;/i&gt;
 * may be set to the wildcard value, *, which allows it to match
 * any &lt;code&gt;Principal&lt;/code&gt; class.  In addition, the &lt;i&gt;principalName&lt;/i&gt;
 * may also be set to the wildcard value, *, allowing it to match
 * any &lt;code&gt;Principal&lt;/code&gt; name.  When setting the &lt;i&gt;principalName&lt;/i&gt;
 * to the *, do not surround the * with quotes.
 *
 * &lt;p&gt; A permission entry must begin with the word &lt;code&gt;permission&lt;/code&gt;.
 * The word &lt;code&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/code&gt; in the template above is
 * a specific permission type, such as &lt;code&gt;java.io.FilePermission&lt;/code&gt;
 * or &lt;code&gt;java.lang.RuntimePermission&lt;/code&gt;.
 *
 * &lt;p&gt; The &quot;&lt;i&gt;action&lt;/i&gt;&quot; is required for
 * many permission types, such as &lt;code&gt;java.io.FilePermission&lt;/code&gt;
 * (where it specifies what type of file access that is permitted).
 * It is not required for categories such as
 * &lt;code&gt;java.lang.RuntimePermission&lt;/code&gt;
 * where it is not necessary - you either have the
 * permission specified by the &lt;code&gt;&quot;&lt;i&gt;name&lt;/i&gt;&quot;&lt;/code&gt;
 * value following the type name or you don't.
 *
 * &lt;p&gt; The &lt;code&gt;signedBy&lt;/code&gt; name/value pair for a permission entry
 * is optional. If present, it indicates a signed permission. That is,
 * the permission class itself must be signed by the given alias in
 * order for it to be granted. For example,
 * suppose you have the following grant entry:
 *
 * &lt;pre&gt;
 *   grant principal foo.com.Principal &quot;Duke&quot; {
 *     permission Foo &quot;foobar&quot;, signedBy &quot;FooSoft&quot;;
 *   }
 * &lt;/pre&gt;
 *
 * &lt;p&gt; Then this permission of type &lt;i&gt;Foo&lt;/i&gt; is granted if the
 * &lt;code&gt;Foo.class&lt;/code&gt; permission has been signed by the
 * &quot;FooSoft&quot; alias, or if XXX &lt;code&gt;Foo.class&lt;/code&gt; is a
 * system class (i.e., is found on the CLASSPATH).
 *
 *
 * &lt;p&gt; Items that appear in an entry must appear in the specified order
 * (&lt;code&gt;permission&lt;/code&gt;, &lt;i&gt;Type&lt;/i&gt;, &quot;&lt;i&gt;name&lt;/i&gt;&quot;, and
 * &quot;&lt;i&gt;action&lt;/i&gt;&quot;). An entry is terminated with a semicolon.
 *
 * &lt;p&gt; Case is unimportant for the identifiers (&lt;code&gt;permission&lt;/code&gt;,
 * &lt;code&gt;signedBy&lt;/code&gt;, &lt;code&gt;codeBase&lt;/code&gt;, etc.) but is
 * significant for the &lt;i&gt;Type&lt;/i&gt;
 * or for any string that is passed in as a value. &lt;p&gt;
 *
 * &lt;p&gt; An example of two entries in a policy configuration file is
 * &lt;pre&gt;
 *   // if the code is comes from &quot;foo.com&quot; and is running as &quot;Duke&quot;,
 *   // grant it read/write to all files in /tmp.
 *
 *   grant codeBase &quot;foo.com&quot;, principal foo.com.Principal &quot;Duke&quot; {
 *              permission java.io.FilePermission &quot;/tmp/*&quot;, &quot;read,write&quot;;
 *   };
 *
 *   // grant any code running as &quot;Duke&quot; permission to read
 *   // the &quot;java.vendor&quot; Property.
 *
 *   grant principal foo.com.Principal &quot;Duke&quot; {
 *         permission java.util.PropertyPermission &quot;java.vendor&quot;;
 *
 *
 * &lt;/pre&gt;
 *  This Policy implementation supports special handling of any
 *  permission that contains the string, &quot;&lt;b&gt;${{self}}&lt;/b&gt;&quot;, as part of
 *  its target name.  When such a permission is evaluated
 *  (such as during a security check), &lt;b&gt;${{self}}&lt;/b&gt; is replaced
 *  with one or more Principal class/name pairs.  The exact
 *  replacement performed depends upon the contents of the
 *  grant clause to which the permission belongs.
 *&lt;p&gt;
 *
 *  If the grant clause does not contain any principal information,
 *  the permission will be ignored (permissions containing
 *  &lt;b&gt;${{self}}&lt;/b&gt; in their target names are only valid in the context
 *  of a principal-based grant clause).  For example, BarPermission
 *  will always be ignored in the following grant clause:
 *
 *&lt;pre&gt;
 *    grant codebase &quot;www.foo.com&quot;, signedby &quot;duke&quot; {
 *      permission BarPermission &quot;... ${{self}} ...&quot;;
 *    };
 *&lt;/pre&gt;
 *
 *  If the grant clause contains principal information, &lt;b&gt;${{self}}&lt;/b&gt;
 *  will be replaced with that same principal information.
 *  For example, &lt;b&gt;${{self}}&lt;/b&gt; in BarPermission will be replaced by
 *  &lt;b&gt;javax.security.auth.x500.X500Principal &quot;cn=Duke&quot;&lt;/b&gt;
 *  in the following grant clause:
 *
 *  &lt;pre&gt;
 *    grant principal javax.security.auth.x500.X500Principal &quot;cn=Duke&quot; {
 *      permission BarPermission &quot;... ${{self}} ...&quot;;
 *    };
 *  &lt;/pre&gt;
 *
 *  If there is a comma-separated list of principals in the grant
 *  clause, then &lt;b&gt;${{self}}&lt;/b&gt; will be replaced by the same
 *  comma-separated list or principals.
 *  In the case where both the principal class and name are
 *  wildcarded in the grant clause, &lt;b&gt;${{self}}&lt;/b&gt; is replaced
 *  with all the principals associated with the &lt;code&gt;Subject&lt;/code&gt;
 *  in the current &lt;code&gt;AccessControlContext&lt;/code&gt;.
 *
 *
 * &lt;p&gt; For PrivateCredentialPermissions, you can also use &quot;&lt;b&gt;self&lt;/b&gt;&quot;
 * instead of &quot;&lt;b&gt;${{self}}&lt;/b&gt;&quot;. However the use of &quot;&lt;b&gt;self&lt;/b&gt;&quot; is
 * deprecated in favour of &quot;&lt;b&gt;${{self}}&lt;/b&gt;&quot;.
 *
 * @see java.security.CodeSource
 * @see java.security.Permissions
 * @see java.security.ProtectionDomain
 */
public class PolicyFile extends java.security.Policy {

    private static final Debug debug = Debug.getInstance(&quot;policy&quot;);

    private static final String NONE = &quot;NONE&quot;;
    private static final String P11KEYSTORE = &quot;PKCS11&quot;;

    private static final String SELF = &quot;${{self}}&quot;;
    private static final String X500PRINCIPAL =
                        &quot;javax.security.auth.x500.X500Principal&quot;;
    private static final String POLICY = &quot;java.security.policy&quot;;
    private static final String SECURITY_MANAGER = &quot;java.security.manager&quot;;
    private static final String POLICY_URL = &quot;policy.url.&quot;;
    private static final String AUTH_POLICY = &quot;java.security.auth.policy&quot;;
    private static final String AUTH_POLICY_URL = &quot;auth.policy.url.&quot;;

    private static final int DEFAULT_CACHE_SIZE = 1;

    // contains the policy grant entries, PD cache, and alias mapping
    private AtomicReference&lt;PolicyInfo&gt; policyInfo = new AtomicReference&lt;&gt;();
    private boolean constructed = false;

    private boolean expandProperties = true;
    private boolean ignoreIdentityScope = true;
    private boolean allowSystemProperties = true;
    private boolean notUtf8 = false;
    private URL url;

    // for use with the reflection API

    private static final Class[] PARAMS0 = { };
    private static final Class[] PARAMS1 = { String.class };
    private static final Class[] PARAMS2 = { String.class, String.class };

    /**
     * Initializes the Policy object and reads the default policy
     * configuration file(s) into the Policy object.
     */
    public PolicyFile() {
        init((URL)null);
    }

    /**
     * Initializes the Policy object and reads the default policy
     * from the specified URL only.
     */
    public PolicyFile(URL url) {
        this.url = url;
        init(url);
    }

    /**
     * Initializes the Policy object and reads the default policy
     * configuration file(s) into the Policy object.
     *
     * The algorithm for locating the policy file(s) and reading their
     * information into the Policy object is:
     * &lt;pre&gt;
     *   loop through the Security Properties named &quot;policy.url.1&quot;,
     *  &quot;&quot;policy.url.2&quot;, &quot;auth.policy.url.1&quot;,  &quot;auth.policy.url.2&quot; etc, until
     *   you don't find one. Each of these specify a policy file.
     *
     *   if none of these could be loaded, use a builtin static policy
     *      equivalent to the default lib/security/java.policy file.
     *
     *   if the system property &quot;java.policy&quot; or &quot;java.auth.policy&quot; is defined
     * (which is the
     *      case when the user uses the -D switch at runtime), and
     *     its use is allowed by the security property file,
     *     also load it.
     * &lt;/pre&gt;
     *
     * Each policy file consists of one or more grant entries, each of
     * which consists of a number of permission entries.
     * &lt;pre&gt;
     *   grant signedBy &quot;&lt;i&gt;alias&lt;/i&gt;&quot;, codeBase &quot;&lt;i&gt;URL&lt;/i&gt;&quot; {
     *     permission &lt;i&gt;Type&lt;/i&gt; &quot;&lt;i&gt;name&lt;/i&gt;&quot;, &quot;&lt;i&gt;action&lt;/i&gt;&quot;,
     *         signedBy &quot;&lt;i&gt;alias&lt;/i&gt;&quot;;
     *     ....
     *     permission &lt;i&gt;Type&lt;/i&gt; &quot;&lt;i&gt;name&lt;/i&gt;&quot;, &quot;&lt;i&gt;action&lt;/i&gt;&quot;,
     *         signedBy &quot;&lt;i&gt;alias&lt;/i&gt;&quot;;
     *   };
     *
     * &lt;/pre&gt;
     *
     * All non-italicized items above must appear as is (although case
     * doesn't matter and some are optional, as noted below).
     * Italicized items represent variable values.
     *
     * &lt;p&gt; A grant entry must begin with the word &lt;code&gt;grant&lt;/code&gt;.
     * The &lt;code&gt;signedBy&lt;/code&gt; and &lt;code&gt;codeBase&lt;/code&gt; name/value
     * pairs are optional.
     * If they are not present, then any signer (including unsigned code)
     * will match, and any codeBase will match.
     *
     * &lt;p&gt; A permission entry must begin with the word &lt;code&gt;permission&lt;/code&gt;.
     * The word &lt;code&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/code&gt; in the template above would actually
     * be a specific permission type, such as
     * &lt;code&gt;java.io.FilePermission&lt;/code&gt; or
     * &lt;code&gt;java.lang.RuntimePermission&lt;/code&gt;.
     *
     * &lt;p&gt;The &quot;&lt;i&gt;action&lt;/i&gt;&quot; is required for
     * many permission types, such as &lt;code&gt;java.io.FilePermission&lt;/code&gt;
     * (where it specifies what type of file access is permitted).
     * It is not required for categories such as
     * &lt;code&gt;java.lang.RuntimePermission&lt;/code&gt;
     * where it is not necessary - you either have the
     * permission specified by the &lt;code&gt;&quot;&lt;i&gt;name&lt;/i&gt;&quot;&lt;/code&gt;
     * value following the type name or you don't.
     *
     * &lt;p&gt;The &lt;code&gt;signedBy&lt;/code&gt; name/value pair for a permission entry
     * is optional. If present, it indicates a signed permission. That is,
     * the permission class itself must be signed by the given alias in
     * order for it to be granted. For example,
     * suppose you have the following grant entry:
     *
     * &lt;pre&gt;
     *   grant {
     *     permission Foo &quot;foobar&quot;, signedBy &quot;FooSoft&quot;;
     *   }
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Then this permission of type &lt;i&gt;Foo&lt;/i&gt; is granted if the
     * &lt;code&gt;Foo.class&lt;/code&gt; permission has been signed by the
     * &quot;FooSoft&quot; alias, or if &lt;code&gt;Foo.class&lt;/code&gt; is a
     * system class (i.e., is found on the CLASSPATH).
     *
     * &lt;p&gt;Items that appear in an entry must appear in the specified order
     * (&lt;code&gt;permission&lt;/code&gt;, &lt;i&gt;Type&lt;/i&gt;, &quot;&lt;i&gt;name&lt;/i&gt;&quot;, and
     * &quot;&lt;i&gt;action&lt;/i&gt;&quot;). An entry is terminated with a semicolon.
     *
     * &lt;p&gt;Case is unimportant for the identifiers (&lt;code&gt;permission&lt;/code&gt;,
     * &lt;code&gt;signedBy&lt;/code&gt;, &lt;code&gt;codeBase&lt;/code&gt;, etc.) but is
     * significant for the &lt;i&gt;Type&lt;/i&gt;
     * or for any string that is passed in as a value. &lt;p&gt;
     *
     * &lt;p&gt;An example of two entries in a policy configuration file is
     * &lt;pre&gt;
     *   //  if the code is signed by &quot;Duke&quot;, grant it read/write to all
     *   // files in /tmp.
     *
     *   grant signedBy &quot;Duke&quot; {
     *          permission java.io.FilePermission &quot;/tmp/*&quot;, &quot;read,write&quot;;
     *   };
     * &lt;p&gt;
     *   // grant everyone the following permission
     *
     *   grant {
     *     permission java.util.PropertyPermission &quot;java.vendor&quot;;
     *   };
     *  &lt;/pre&gt;
     */
    private void init(URL url) {
        // Properties are set once for each init(); ignore changes between
        // between diff invocations of initPolicyFile(policy, url, info).
        String numCacheStr =
          AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
            public String run() {
                expandProperties = &quot;true&quot;.equalsIgnoreCase
                    (Security.getProperty(&quot;policy.expandProperties&quot;));
                ignoreIdentityScope = &quot;true&quot;.equalsIgnoreCase
                    (Security.getProperty(&quot;policy.ignoreIdentityScope&quot;));
                allowSystemProperties = &quot;true&quot;.equalsIgnoreCase
                    (Security.getProperty(&quot;policy.allowSystemProperty&quot;));
                notUtf8 = &quot;false&quot;.equalsIgnoreCase
                    (System.getProperty(&quot;sun.security.policy.utf8&quot;));
                return System.getProperty(&quot;sun.security.policy.numcaches&quot;);
            }});

        int numCaches;
        if (numCacheStr != null) {
            try {
                numCaches = Integer.parseInt(numCacheStr);
            } catch (NumberFormatException e) {
                numCaches = DEFAULT_CACHE_SIZE;
            }
        } else {
            numCaches = DEFAULT_CACHE_SIZE;
        }
        // System.out.println(&quot;number caches=&quot; + numCaches);
        PolicyInfo newInfo = new PolicyInfo(numCaches);
        initPolicyFile(newInfo, url);
        policyInfo.set(newInfo);
    }

    private void initPolicyFile(final PolicyInfo newInfo, final URL url) {

        if (url != null) {

            /**
             * If the caller specified a URL via Policy.getInstance,
             * we only read from that URL
             */

            if (debug != null) {
                debug.println(&quot;reading &quot;+url);
            }
            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
                public Void run() {
                    if (init(url, newInfo) == false) {
                        // use static policy if all else fails
                        initStaticPolicy(newInfo);
                    }
                    return null;
                }
            });

        } else {

            /**
             * Caller did not specify URL via Policy.getInstance.
             * Read from URLs listed in the java.security properties file.
             *
             * We call initPolicyFile with POLICY , POLICY_URL and then
             * call it with AUTH_POLICY and AUTH_POLICY_URL
             * So first we will process the JAVA standard policy
             * and then process the JAVA AUTH Policy.
             * This is for backward compatibility as well as to handle
             * cases where the user has a single unified policyfile
             * with both java policy entries and auth entries
             */

            boolean loaded_one = initPolicyFile(POLICY, POLICY_URL, newInfo);
            // To maintain strict backward compatibility
            // we load the static policy only if POLICY load failed
            if (!loaded_one) {
                // use static policy if all else fails
                initStaticPolicy(newInfo);
            }

            initPolicyFile(AUTH_POLICY, AUTH_POLICY_URL, newInfo);
        }
    }

    private boolean initPolicyFile(final String propname, final String urlname,
                                final PolicyInfo newInfo) {
        Boolean loadedPolicy =
            AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() {
            public Boolean run() {
                boolean loaded_policy = false;

                if (allowSystemProperties) {
                    String extra_policy = System.getProperty(propname);
                    if (extra_policy != null) {
                        boolean overrideAll = false;
                        if (extra_policy.startsWith(&quot;=&quot;)) {
                            overrideAll = true;
                            extra_policy = extra_policy.substring(1);
                        }
                        try {
                            extra_policy =
                                PropertyExpander.expand(extra_policy);
                            URL policyURL;

                            File policyFile = new File(extra_policy);
                            if (policyFile.exists()) {
                                policyURL = ParseUtil.fileToEncodedURL
                                    (new File(policyFile.getCanonicalPath()));
                            } else {
                                policyURL = new URL(extra_policy);
                            }
                            if (debug != null)
                                debug.println(&quot;reading &quot;+policyURL);
                            if (init(policyURL, newInfo))
                                loaded_policy = true;
                        } catch (Exception e) {
                            // ignore.
                            if (debug != null) {
                                debug.println(&quot;caught exception: &quot;+e);
                            }
                        }
                        if (overrideAll) {
                            if (debug != null) {
                                debug.println(&quot;overriding other policies!&quot;);
                            }
                            return Boolean.valueOf(loaded_policy);
                        }
                    }
                }

                int n = 1;
                String policy_uri;

                while ((policy_uri = Security.getProperty(urlname+n)) != null) {
                    try {
                        URL policy_url = null;
                        String expanded_uri = PropertyExpander.expand
                                (policy_uri).replace(File.separatorChar, '/');

                        if (policy_uri.startsWith(&quot;file:${java.home}/&quot;) ||
                            policy_uri.startsWith(&quot;file:${user.home}/&quot;)) {

                            // this special case accommodates
                            // the situation java.home/user.home
                            // expand to a single slash, resulting in
                            // a file://foo URI
                            policy_url = new File
                                (expanded_uri.substring(5)).toURI().toURL();
                        } else {
                            policy_url = new URI(expanded_uri).toURL();
                        }

                        if (debug != null)
                            debug.println(&quot;reading &quot;+policy_url);
                        if (init(policy_url, newInfo))
                            loaded_policy = true;
                    } catch (Exception e) {
                        if (debug != null) {
                            debug.println(&quot;error reading policy &quot;+e);
                            e.printStackTrace();
                        }
                        // ignore that policy
                    }
                    n++;
                }
                return Boolean.valueOf(loaded_policy);
            }
        });

        return loadedPolicy.booleanValue();
    }

    /**
     * Reads a policy configuration into the Policy object using a
     * Reader object.
     *
     * @param policyFile the policy Reader object.
     */
    private boolean init(URL policy, PolicyInfo newInfo) {
        boolean success = false;
        PolicyParser pp = new PolicyParser(expandProperties);
        InputStreamReader isr = null;
        try {

            // read in policy using UTF-8 by default
            //
            // check non-standard system property to see if
            // the default encoding should be used instead

            if (notUtf8) {
                isr = new InputStreamReader
                                (PolicyUtil.getInputStream(policy));
            } else {
                isr = new InputStreamReader
                                (PolicyUtil.getInputStream(policy), &quot;UTF-8&quot;);
            }

            pp.read(isr);

            KeyStore keyStore = null;
            try {
                keyStore = PolicyUtil.getKeyStore
                                (policy,
                                pp.getKeyStoreUrl(),
                                pp.getKeyStoreType(),
                                pp.getKeyStoreProvider(),
                                pp.getStorePassURL(),
                                debug);
            } catch (Exception e) {
                // ignore, treat it like we have no keystore
                if (debug != null) {
                    e.printStackTrace();
                }
            }

            Enumeration&lt;PolicyParser.GrantEntry&gt; enum_ = pp.grantElements();
            while (enum_.hasMoreElements()) {
                PolicyParser.GrantEntry ge = enum_.nextElement();
                addGrantEntry(ge, keyStore, newInfo);
            }
        } catch (PolicyParser.ParsingException pe) {
            MessageFormat form = new MessageFormat(ResourcesMgr.getString
                (POLICY + &quot;.error.parsing.policy.message&quot;));
            Object[] source = {policy, pe.getLocalizedMessage()};
            System.err.println(form.format(source));
            if (debug != null)
                pe.printStackTrace();

        } catch (Exception e) {
            if (debug != null) {
                debug.println(&quot;error parsing &quot;+policy);
                debug.println(e.toString());
                e.printStackTrace();
            }
        } finally {
            if (isr != null) {
                try {
                    isr.close();
                    success = true;
                } catch (IOException e) {
                    // ignore the exception
                }
            } else {
                success = true;
            }
        }

        return success;
    }

    private void initStaticPolicy(final PolicyInfo newInfo) {
        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
            public Void run() {
                PolicyEntry pe = new PolicyEntry(new CodeSource(null,
                    (Certificate[]) null));
                pe.add(SecurityConstants.LOCAL_LISTEN_PERMISSION);
                pe.add(new PropertyPermission(&quot;java.version&quot;,
                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission(&quot;java.vendor&quot;,
                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission(&quot;java.vendor.url&quot;,
                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission(&quot;java.class.version&quot;,
                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission(&quot;os.name&quot;,
                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission(&quot;os.version&quot;,
                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission(&quot;os.arch&quot;,
                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission(&quot;file.separator&quot;,
                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission(&quot;path.separator&quot;,
                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission(&quot;line.separator&quot;,
                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission
                                (&quot;java.specification.version&quot;,
                                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission
                                (&quot;java.specification.vendor&quot;,
                                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission
                                (&quot;java.specification.name&quot;,
                                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission
                                (&quot;java.vm.specification.version&quot;,
                                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission
                                (&quot;java.vm.specification.vendor&quot;,
                                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission
                                (&quot;java.vm.specification.name&quot;,
                                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission(&quot;java.vm.version&quot;,
                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission(&quot;java.vm.vendor&quot;,
                    SecurityConstants.PROPERTY_READ_ACTION));
                pe.add(new PropertyPermission(&quot;java.vm.name&quot;,
                    SecurityConstants.PROPERTY_READ_ACTION));

                // No need to sync because noone has access to newInfo yet
                newInfo.policyEntries.add(pe);

                // Add AllPermissions for standard extensions
                String[] extCodebases = PolicyParser.parseExtDirs(
                    PolicyParser.EXTDIRS_EXPANSION, 0);
                if (extCodebases != null &amp;&amp; extCodebases.length &gt; 0) {
                    for (int i = 0; i &lt; extCodebases.length; i++) {
                        try {
                            pe = new PolicyEntry(canonicalizeCodebase(
                                new CodeSource(new URL(extCodebases[i]),
                                    (Certificate[]) null), false ));
                            pe.add(SecurityConstants.ALL_PERMISSION);

                            // No need to sync because noone has access to
                            // newInfo yet
                            newInfo.policyEntries.add(pe);
                        } catch (Exception e) {
                            // this is probably bad (though not dangerous).
                            // What should we do?
                        }
                    }
                }
                return null;
            }
        });
    }

    /**
     * Given a GrantEntry, create a codeSource.
     *
     * @return null if signedBy alias is not recognized
     */
    private CodeSource getCodeSource(PolicyParser.GrantEntry ge, KeyStore keyStore,
        PolicyInfo newInfo) throws java.net.MalformedURLException
    {
        Certificate[] certs = null;
        if (ge.signedBy != null) {
            certs = getCertificates(keyStore, ge.signedBy, newInfo);
            if (certs == null) {
                // we don't have a key for this alias,
                // just return
                if (debug != null) {
                    debug.println(&quot;  -- No certs for alias '&quot; +
                                       ge.signedBy + &quot;' - ignoring entry&quot;);
                }
                return null;
            }
        }

        URL location;

        if (ge.codeBase != null)
            location = new URL(ge.codeBase);
        else
            location = null;

        return (canonicalizeCodebase(new CodeSource(location, certs),false));
    }

    /**
     * Add one policy entry to the list.
     */
    private void addGrantEntry(PolicyParser.GrantEntry ge,
                               KeyStore keyStore, PolicyInfo newInfo) {

        if (debug != null) {
            debug.println(&quot;Adding policy entry: &quot;);
            debug.println(&quot;  signedBy &quot; + ge.signedBy);
            debug.println(&quot;  codeBase &quot; + ge.codeBase);
            if (ge.principals != null) {
                for (PolicyParser.PrincipalEntry pppe : ge.principals) {
                    debug.println(&quot;  &quot; + pppe.toString());
                }
            }
        }

        try {
            CodeSource codesource = getCodeSource(ge, keyStore, newInfo);
            // skip if signedBy alias was unknown...
            if (codesource == null) return;

            // perform keystore alias principal replacement.
            // for example, if alias resolves to X509 certificate,
            // replace principal with:  &lt;X500Principal class&gt;  &lt;SubjectDN&gt;
            // -- skip if alias is unknown
            if (replacePrincipals(ge.principals, keyStore) == false)
                return;
            PolicyEntry entry = new PolicyEntry(codesource, ge.principals);
            Enumeration&lt;PolicyParser.PermissionEntry&gt; enum_ =
                                                ge.permissionElements();
            while (enum_.hasMoreElements()) {
                PolicyParser.PermissionEntry pe = enum_.nextElement();

                try {
                    // perform ${{ ... }} expansions within permission name
                    expandPermissionName(pe, keyStore);

                    // XXX special case PrivateCredentialPermission-SELF
                    Permission perm;
                    if (pe.permission.equals
                        (&quot;javax.security.auth.PrivateCredentialPermission&quot;) &amp;&amp;
                        pe.name.endsWith(&quot; self&quot;)) {
                        pe.name = pe.name.substring(0, pe.name.indexOf(&quot;self&quot;))
                                + SELF;
                    }
                    // check for self
                    if (pe.name != null &amp;&amp; pe.name.indexOf(SELF) != -1) {
                        // Create a &quot;SelfPermission&quot; , it could be an
                        // an unresolved permission which will be resolved
                        // when implies is called
                        // Add it to entry
                        Certificate certs[];
                        if (pe.signedBy != null) {
                            certs = getCertificates(keyStore,
                                                    pe.signedBy,
                                                    newInfo);
                        } else {
                            certs = null;
                        }
                        perm = new SelfPermission(pe.permission,
                                                  pe.name,
                                                  pe.action,
                                                  certs);
                    } else {
                        perm = getInstance(pe.permission,
                                           pe.name,
                                           pe.action);
                    }
                    entry.add(perm);
                    if (debug != null) {
                        debug.println(&quot;  &quot;+perm);
                    }
                } catch (ClassNotFoundException cnfe) {
                    Certificate certs[];
                    if (pe.signedBy != null) {
                        certs = getCertificates(keyStore,
                                                pe.signedBy,
                                                newInfo);
                    } else {
                        certs = null;
                    }

                    // only add if we had no signer or we had a
                    // a signer and found the keys for it.
                    if (certs != null || pe.signedBy == null) {
                        Permission perm = new UnresolvedPermission(
                                                  pe.permission,
                                                  pe.name,
                                                  pe.action,
                                                  certs);
                        entry.add(perm);
                        if (debug != null) {
                            debug.println(&quot;  &quot;+perm);
                        }
                    }
                } catch (java.lang.reflect.InvocationTargetException ite) {
                    MessageFormat form = new MessageFormat
                        (ResourcesMgr.getString
                         (POLICY +
                          &quot;.error.adding.Permission.perm.message&quot;));
                    Object[] source = {pe.permission,
                                       ite.getTargetException().toString()};
                    System.err.println(form.format(source));
                } catch (Exception e) {
                    MessageFormat form = new MessageFormat
                        (ResourcesMgr.getString
                         (POLICY +
                          &quot;.error.adding.Permission.perm.message&quot;));
                    Object[] source = {pe.permission,
                                       e.toString()};
                    System.err.println(form.format(source));
                }
            }

            // No need to sync because noone has access to newInfo yet
            newInfo.policyEntries.add(entry);
        } catch (Exception e) {
            MessageFormat form = new MessageFormat(ResourcesMgr.getString
                                         (POLICY
                                         + &quot;.error.adding.Entry.message&quot;));
            Object[] source = {e.toString()};
            System.err.println(form.format(source));
        }
        if (debug != null)
            debug.println();
    }

    /**
     * Returns a new Permission object of the given Type. The Permission is
     * created by getting the
     * Class object using the &lt;code&gt;Class.forName&lt;/code&gt; method, and using
     * the reflection API to invoke the (String name, String actions)
     * constructor on the
     * object.
     *
     * @param type the type of Permission being created.
     * @param name the name of the Permission being created.
     * @param actions the actions of the Permission being created.
     *
     * @exception  ClassNotFoundException  if the particular Permission
     *             class could not be found.
     *
     * @exception  IllegalAccessException  if the class or initializer is
     *               not accessible.
     *
     * @exception  InstantiationException  if getInstance tries to
     *               instantiate an abstract class or an interface, or if the
     *               instantiation fails for some other reason.
     *
     * @exception  NoSuchMethodException if the (String, String) constructor
     *               is not found.
     *
     * @exception  InvocationTargetException if the underlying Permission
     *               constructor throws an exception.
     *
     */

    private static final Permission getInstance(String type,
                                    String name,
                                    String actions)
        throws ClassNotFoundException,
               InstantiationException,
               IllegalAccessException,
               NoSuchMethodException,
               InvocationTargetException
    {
        //XXX we might want to keep a hash of created factories...
        Class&lt;?&gt; pc = Class.forName(type, false, null);
        Permission answer = getKnownInstance(pc, name, actions);
        if (answer != null) {
            return answer;
        }
        if (!Permission.class.isAssignableFrom(pc)) {
            // not the right subtype
            throw new ClassCastException(type + &quot; is not a Permission&quot;);
        }

        if (name == null &amp;&amp; actions == null) {
            try {
                Constructor&lt;?&gt; c = pc.getConstructor(PARAMS0);
                return (Permission) c.newInstance(new Object[] {});
            } catch (NoSuchMethodException ne) {
                try {
                    Constructor&lt;?&gt; c = pc.getConstructor(PARAMS1);
                    return (Permission) c.newInstance(
                              new Object[] { name});
                } catch (NoSuchMethodException ne1 ) {
                    Constructor&lt;?&gt; c = pc.getConstructor(PARAMS2);
                    return (Permission) c.newInstance(
                        new Object[] { name, actions });
                }
            }
        } else {
            if (name != null &amp;&amp; actions == null) {
                try {
                    Constructor&lt;?&gt; c = pc.getConstructor(PARAMS1);
                    return (Permission) c.newInstance(new Object[] { name});
                } catch (NoSuchMethodException ne) {
                    Constructor&lt;?&gt; c = pc.getConstructor(PARAMS2);
                    return (Permission) c.newInstance(
                          new Object[] { name, actions });
                }
            } else {
                Constructor&lt;?&gt; c = pc.getConstructor(PARAMS2);
                return (Permission) c.newInstance(
                      new Object[] { name, actions });
             }
        }
    }

    /**
     * Creates one of the well-known permissions directly instead of
     * via reflection. Keep list short to not penalize non-JDK-defined
     * permissions.
     */
    private static final Permission getKnownInstance(Class&lt;?&gt; claz,
        String name, String actions) {
        if (claz.equals(FilePermission.class)) {
            return new FilePermission(name, actions);
        } else if (claz.equals(SocketPermission.class)) {
            return new SocketPermission(name, actions);
        } else if (claz.equals(RuntimePermission.class)) {
            return new RuntimePermission(name, actions);
        } else if (claz.equals(PropertyPermission.class)) {
            return new PropertyPermission(name, actions);
        } else if (claz.equals(NetPermission.class)) {
            return new NetPermission(name, actions);
        } else if (claz.equals(AllPermission.class)) {
            return SecurityConstants.ALL_PERMISSION;
        } else {
            return null;
        }
    }

    /**
     * Fetch all certs associated with this alias.
     */
    private Certificate[] getCertificates
                (KeyStore keyStore, String aliases, PolicyInfo newInfo) {

        List&lt;Certificate&gt; vcerts = null;

        StringTokenizer st = new StringTokenizer(aliases, &quot;,&quot;);
        int n = 0;

        while (st.hasMoreTokens()) {
            String alias = st.nextToken().trim();
            n++;
            Certificate cert = null;
            // See if this alias's cert has already been cached
            synchronized (newInfo.aliasMapping) {
                cert = (Certificate)newInfo.aliasMapping.get(alias);

                if (cert == null &amp;&amp; keyStore != null) {

                    try {
                        cert = keyStore.getCertificate(alias);
                    } catch (KeyStoreException kse) {
                        // never happens, because keystore has already been loaded
                        // when we call this
                    }
                    if (cert != null) {
                        newInfo.aliasMapping.put(alias, cert);
                        newInfo.aliasMapping.put(cert, alias);
                    }
                }
            }

            if (cert != null) {
                if (vcerts == null)
                    vcerts = new ArrayList&lt;&gt;();
                vcerts.add(cert);
            }
        }

        // make sure n == vcerts.size, since we are doing a logical *and*
        if (vcerts != null &amp;&amp; n == vcerts.size()) {
            Certificate[] certs = new Certificate[vcerts.size()];
            vcerts.toArray(certs);
            return certs;
        } else {
            return null;
        }
    }

    /**
     * Refreshes the policy object by re-reading all the policy files.
     */
    @Override public void refresh() {
        init(url);
    }

    /**
     * Evaluates the the global policy for the permissions granted to
     * the ProtectionDomain and tests whether the permission is
     * granted.
     *
     * @param domain the ProtectionDomain to test
     * @param permission the Permission object to be tested for implication.
     *
     * @return true if &quot;permission&quot; is a proper subset of a permission
     * granted to this ProtectionDomain.
     *
     * @see java.security.ProtectionDomain
     */
    @Override
    public boolean implies(ProtectionDomain pd, Permission p) {
        PolicyInfo pi = policyInfo.get();
        ProtectionDomainCache pdMap = pi.getPdMapping();

        PermissionCollection pc = pdMap.get(pd);

        if (pc != null) {
            return pc.implies(p);
        }

        pc = getPermissions(pd);
        if (pc == null) {
            return false;
        }

        // cache mapping of protection domain to its PermissionCollection
        pdMap.put(pd, pc);
        return pc.implies(p);
    }

    /**
     * Examines this &lt;code&gt;Policy&lt;/code&gt; and returns the permissions granted
     * to the specified &lt;code&gt;ProtectionDomain&lt;/code&gt;.  This includes
     * the permissions currently associated with the domain as well
     * as the policy permissions granted to the domain's
     * CodeSource, ClassLoader, and Principals.
     *
     * &lt;p&gt; Note that this &lt;code&gt;Policy&lt;/code&gt; implementation has
     * special handling for PrivateCredentialPermissions.
     * When this method encounters a &lt;code&gt;PrivateCredentialPermission&lt;/code&gt;
     * which specifies &quot;self&quot; as the &lt;code&gt;Principal&lt;/code&gt; class and name,
     * it does not add that &lt;code&gt;Permission&lt;/code&gt; to the returned
     * &lt;code&gt;PermissionCollection&lt;/code&gt;.  Instead, it builds
     * a new &lt;code&gt;PrivateCredentialPermission&lt;/code&gt;
     * for each &lt;code&gt;Principal&lt;/code&gt; associated with the provided
     * &lt;code&gt;Subject&lt;/code&gt;.  Each new &lt;code&gt;PrivateCredentialPermission&lt;/code&gt;
     * contains the same Credential class as specified in the
     * originally granted permission, as well as the Class and name
     * for the respective &lt;code&gt;Principal&lt;/code&gt;.
     *
     * &lt;p&gt;
     *
     * @param domain the Permissions granted to this
     *          &lt;code&gt;ProtectionDomain&lt;/code&gt; are returned.
     *
     * @return the Permissions granted to the provided
     *          &lt;code&gt;ProtectionDomain&lt;/code&gt;.
     */
    @Override
    public PermissionCollection getPermissions(ProtectionDomain domain) {
        Permissions perms = new Permissions();

        if (domain == null)
           return perms;

        // first get policy perms
        getPermissions(perms, domain);

        // add static perms
        //      - adding static perms after policy perms is necessary
        //        to avoid a regression for 4301064
        PermissionCollection pc = domain.getPermissions();
        if (pc != null) {
            synchronized (pc) {
                Enumeration&lt;Permission&gt; e = pc.elements();
                while (e.hasMoreElements()) {
                    perms.add(e.nextElement());
                }
            }
        }

        return perms;
    }

    /**
     * Examines this Policy and creates a PermissionCollection object with
     * the set of permissions for the specified CodeSource.
     *
     * @param CodeSource the codesource associated with the caller.
     * This encapsulates the original location of the code (where the code
     * came from) and the public key(s) of its signer.
     *
     * @return the set of permissions according to the policy.
     */
    @Override
    public PermissionCollection getPermissions(CodeSource codesource) {
        return getPermissions(new Permissions(), codesource);
    }

    /**
     * Examines the global policy and returns the provided Permissions
     * object with additional permissions granted to the specified
     * ProtectionDomain.
     *
     * @param perm the Permissions to populate
     * @param pd the ProtectionDomain associated with the caller.
     *
     * @return the set of Permissions according to the policy.
     */
    private PermissionCollection getPermissions(Permissions perms,
                                        ProtectionDomain pd ) {
        if (debug != null) {
            debug.println(&quot;getPermissions:\n\t&quot; + printPD(pd));
        }

        final CodeSource cs = pd.getCodeSource();
        if (cs == null)
            return perms;

        CodeSource canonCodeSource = AccessController.doPrivileged(
            new java.security.PrivilegedAction&lt;CodeSource&gt;(){
                public CodeSource run() {
                    return canonicalizeCodebase(cs, true);
                }
            });
        return getPermissions(perms, canonCodeSource, pd.getPrincipals());
    }

    /**
     * Examines the global policy and returns the provided Permissions
     * object with additional permissions granted to the specified
     * CodeSource.
     *
     * @param permissions the permissions to populate
     * @param codesource the codesource associated with the caller.
     * This encapsulates the original location of the code (where the code
     * came from) and the public key(s) of its signer.
     *
     * @return the set of permissions according to the policy.
     */
    private PermissionCollection getPermissions(Permissions perms,
                                                final CodeSource cs) {

        if (cs == null)
            return perms;

        CodeSource canonCodeSource = AccessController.doPrivileged(
            new java.security.PrivilegedAction&lt;CodeSource&gt;(){
                public CodeSource run() {
                    return canonicalizeCodebase(cs, true);
                }
            });

        return getPermissions(perms, canonCodeSource, null);
    }

    private Permissions getPermissions(Permissions perms,
                                       final CodeSource cs,
                                       Principal[] principals) {
        PolicyInfo pi = policyInfo.get();

        for (PolicyEntry entry : pi.policyEntries) {
            addPermissions(perms, cs, principals, entry);
        }

        // Go through policyEntries gotten from identity db; sync required
        // because checkForTrustedIdentity (below) might update list
        synchronized (pi.identityPolicyEntries) {
            for (PolicyEntry entry : pi.identityPolicyEntries) {
                addPermissions(perms, cs, principals, entry);
            }
        }

        // now see if any of the keys are trusted ids.
        if (!ignoreIdentityScope) {
            Certificate certs[] = cs.getCertificates();
            if (certs != null) {
                for (int k=0; k &lt; certs.length; k++) {
                    Object idMap = pi.aliasMapping.get(certs[k]);
                    if (idMap == null &amp;&amp;
                        checkForTrustedIdentity(certs[k], pi)) {
                        // checkForTrustedIdentity added it
                        // to the policy for us. next time
                        // around we'll find it. This time
                        // around we need to add it.
                        perms.add(SecurityConstants.ALL_PERMISSION);
                    }
                }
            }
        }
        return perms;
    }

    private void addPermissions(Permissions perms,
        final CodeSource cs,
        Principal[] principals,
        final PolicyEntry entry) {

        if (debug != null) {
            debug.println(&quot;evaluate codesources:\n&quot; +
                &quot;\tPolicy CodeSource: &quot; + entry.getCodeSource() + &quot;\n&quot; +
                &quot;\tActive CodeSource: &quot; + cs);
        }

        // check to see if the CodeSource implies
        Boolean imp = AccessController.doPrivileged
            (new PrivilegedAction&lt;Boolean&gt;() {
            public Boolean run() {
                return new Boolean(entry.getCodeSource().implies(cs));
            }
        });
        if (!imp.booleanValue()) {
            if (debug != null) {
                debug.println(&quot;evaluation (codesource) failed&quot;);
            }

            // CodeSource does not imply - return and try next policy entry
            return;
        }

        // check to see if the Principals imply

        List&lt;PolicyParser.PrincipalEntry&gt; entryPs = entry.getPrincipals();
        if (debug != null) {
            List&lt;PolicyParser.PrincipalEntry&gt; accPs = new ArrayList&lt;&gt;();
            if (principals != null) {
                for (int i = 0; i &lt; principals.length; i++) {
                    accPs.add(new PolicyParser.PrincipalEntry
                                        (principals[i].getClass().getName(),
                                        principals[i].getName()));
                }
            }
            debug.println(&quot;evaluate principals:\n&quot; +
                &quot;\tPolicy Principals: &quot; + entryPs + &quot;\n&quot; +
                &quot;\tActive Principals: &quot; + accPs);
        }

        if (entryPs == null || entryPs.isEmpty()) {

            // policy entry has no principals -
            // add perms regardless of principals in current ACC

            addPerms(perms, principals, entry);
            if (debug != null) {
                debug.println(&quot;evaluation (codesource/principals) passed&quot;);
            }
            return;

        } else if (principals == null || principals.length == 0) {

            // current thread has no principals but this policy entry
            // has principals - perms are not added

            if (debug != null) {
                debug.println(&quot;evaluation (principals) failed&quot;);
            }
            return;
        }

        // current thread has principals and this policy entry
        // has principals.  see if policy entry principals match
        // principals in current ACC

        for (PolicyParser.PrincipalEntry pppe : entryPs) {

            // Check for wildcards
            if (pppe.isWildcardClass()) {
                // a wildcard class matches all principals in current ACC
                continue;
            }

            if (pppe.isWildcardName()) {
                // a wildcard name matches any principal with the same class
                if (wildcardPrincipalNameImplies(pppe.principalClass,
                                                 principals)) {
                    continue;
                }
                if (debug != null) {
                    debug.println(&quot;evaluation (principal name wildcard) failed&quot;);
                }
                // policy entry principal not in current ACC -
                // immediately return and go to next policy entry
                return;
            }

            Set&lt;Principal&gt; pSet = new HashSet&lt;&gt;(Arrays.asList(principals));
            Subject subject = new Subject(true, pSet,
                                          Collections.EMPTY_SET,
                                          Collections.EMPTY_SET);
            try {
                ClassLoader cl = Thread.currentThread().getContextClassLoader();
                Class&lt;?&gt; pClass = Class.forName(pppe.principalClass, false, cl);
                if (!Principal.class.isAssignableFrom(pClass)) {
                    // not the right subtype
                    throw new ClassCastException(pppe.principalClass +
                                                 &quot; is not a Principal&quot;);
                }

                Constructor&lt;?&gt; c = pClass.getConstructor(PARAMS1);
                Principal p = (Principal)c.newInstance(new Object[] {
                                                       pppe.principalName });

                if (debug != null) {
                    debug.println(&quot;found Principal &quot; + p.getClass().getName());
                }

                // check if the Principal implies the current
                // thread's principals
                if (!p.implies(subject)) {
                    if (debug != null) {
                        debug.println(&quot;evaluation (principal implies) failed&quot;);
                    }

                    // policy principal does not imply the current Subject -
                    // immediately return and go to next policy entry
                    return;
                }
            } catch (Exception e) {
                // fall back to default principal comparison.
                // see if policy entry principal is in current ACC

                if (debug != null) {
                    e.printStackTrace();
                }

                if (!pppe.implies(subject)) {
                    if (debug != null) {
                        debug.println(&quot;evaluation (default principal implies) failed&quot;);
                    }

                    // policy entry principal not in current ACC -
                    // immediately return and go to next policy entry
                    return;
                }
            }

            // either the principal information matched,
            // or the Principal.implies succeeded.
            // continue loop and test the next policy principal
        }

        // all policy entry principals were found in the current ACC -
        // grant the policy permissions

        if (debug != null) {
            debug.println(&quot;evaluation (codesource/principals) passed&quot;);
        }
        addPerms(perms, principals, entry);
    }

    /**
     * Returns true if the array of principals contains at least one
     * principal of the specified class.
     */
    private static boolean wildcardPrincipalNameImplies(String principalClass,
                                                        Principal[] principals)
    {
        for (Principal p : principals) {
            if (principalClass.equals(p.getClass().getName())) {
                return true;
            }
        }
        return false;
    }

    private void addPerms(Permissions perms,
                        Principal[] accPs,
                        PolicyEntry entry) {
        for (int i = 0; i &lt; entry.permissions.size(); i++) {
            Permission p = entry.permissions.get(i);
            if (debug != null) {
                debug.println(&quot;  granting &quot; + p);
            }

            if (p instanceof SelfPermission) {
                // handle &quot;SELF&quot; permissions
                expandSelf((SelfPermission)p,
                        entry.getPrincipals(),
                        accPs,
                        perms);
            } else {
                perms.add(p);
            }
        }
    }

    /**
     * &lt;p&gt;
     *
     * @param sp the SelfPermission that needs to be expanded &lt;p&gt;
     *
     * @param entryPs list of principals for the Policy entry.
     *
     * @param pdp Principal array from the current ProtectionDomain.
     *
     * @param perms the PermissionCollection where the individual
     *                  Permissions will be added after expansion.
     */

    private void expandSelf(SelfPermission sp,
                            List&lt;PolicyParser.PrincipalEntry&gt; entryPs,
                            Principal[] pdp,
                            Permissions perms) {

        if (entryPs == null || entryPs.isEmpty()) {
            // No principals in the grant to substitute
            if (debug != null) {
                debug.println(&quot;Ignoring permission &quot;
                                + sp.getSelfType()
                                + &quot; with target name (&quot;
                                + sp.getSelfName() + &quot;).  &quot;
                                + &quot;No Principal(s) specified &quot;
                                + &quot;in the grant clause.  &quot;
                                + &quot;SELF-based target names are &quot;
                                + &quot;only valid in the context &quot;
                                + &quot;of a Principal-based grant entry.&quot;
                             );
            }
            return;
        }
        int startIndex = 0;
        int v;
        StringBuilder sb = new StringBuilder();
        while ((v = sp.getSelfName().indexOf(SELF, startIndex)) != -1) {

            // add non-SELF string
            sb.append(sp.getSelfName().substring(startIndex, v));

            // expand SELF
            Iterator&lt;PolicyParser.PrincipalEntry&gt; pli = entryPs.iterator();
            while (pli.hasNext()) {
                PolicyParser.PrincipalEntry pppe = pli.next();
                String[][] principalInfo = getPrincipalInfo(pppe,pdp);
                for (int i = 0; i &lt; principalInfo.length; i++) {
                    if (i != 0) {
                        sb.append(&quot;, &quot;);
                    }
                    sb.append(principalInfo[i][0] + &quot; &quot; +
                        &quot;\&quot;&quot; + principalInfo[i][1] + &quot;\&quot;&quot;);
                }
                if (pli.hasNext()) {
                    sb.append(&quot;, &quot;);
                }
            }
            startIndex = v + SELF.length();
        }
        // add remaining string (might be the entire string)
        sb.append(sp.getSelfName().substring(startIndex));

        if (debug != null) {
            debug.println(&quot;  expanded:\n\t&quot; + sp.getSelfName()
                        + &quot;\n  into:\n\t&quot; + sb.toString());
        }
        try {
            // first try to instantiate the permission
            perms.add(getInstance(sp.getSelfType(),
                                  sb.toString(),
                                  sp.getSelfActions()));
        } catch (ClassNotFoundException cnfe) {
            // ok, the permission is not in the bootclasspath.
            // before we add an UnresolvedPermission, check to see
            // whether this perm already belongs to the collection.
            // if so, use that perm's ClassLoader to create a new
            // one.
            Class&lt;?&gt; pc = null;
            synchronized (perms) {
                Enumeration&lt;Permission&gt; e = perms.elements();
                while (e.hasMoreElements()) {
                    Permission pElement = e.nextElement();
                    if (pElement.getClass().getName().equals(sp.getSelfType())) {
                        pc = pElement.getClass();
                        break;
                    }
                }
            }
            if (pc == null) {
                // create an UnresolvedPermission
                perms.add(new UnresolvedPermission(sp.getSelfType(),
                                                        sb.toString(),
                                                        sp.getSelfActions(),
                                                        sp.getCerts()));
            } else {
                try {
                    // we found an instantiated permission.
                    // use its class loader to instantiate a new permission.
                    Constructor&lt;?&gt; c;
                    // name parameter can not be null
                    if (sp.getSelfActions() == null) {
                        try {
                            c = pc.getConstructor(PARAMS1);
                            perms.add((Permission)c.newInstance
                                 (new Object[] {sb.toString()}));
                        } catch (NoSuchMethodException ne) {
                            c = pc.getConstructor(PARAMS2);
                            perms.add((Permission)c.newInstance
                                 (new Object[] {sb.toString(),
                                                sp.getSelfActions() }));
                        }
                    } else {
                        c = pc.getConstructor(PARAMS2);
                        perms.add((Permission)c.newInstance
                           (new Object[] {sb.toString(),
                                          sp.getSelfActions()}));
                    }
                } catch (Exception nme) {
                    if (debug != null) {
                        debug.println(&quot;self entry expansion &quot; +
                        &quot; instantiation failed: &quot;
                        +  nme.toString());
                    }
                }
            }
        } catch (Exception e) {
            if (debug != null) {
                debug.println(e.toString());
            }
        }
    }

    /**
     * return the principal class/name pair in the 2D array.
     * array[x][y]:     x corresponds to the array length.
     *                  if (y == 0), it's the principal class.
     *                  if (y == 1), it's the principal name.
     */
    private String[][] getPrincipalInfo
        (PolicyParser.PrincipalEntry pe, Principal[] pdp) {

        // there are 3 possibilities:
        // 1) the entry's Principal class and name are not wildcarded
        // 2) the entry's Principal name is wildcarded only
        // 3) the entry's Principal class and name are wildcarded

        if (!pe.isWildcardClass() &amp;&amp; !pe.isWildcardName()) {

            // build an info array for the principal
            // from the Policy entry
            String[][] info = new String[1][2];
            info[0][0] = pe.principalClass;
            info[0][1] = pe.principalName;
            return info;

        } else if (!pe.isWildcardClass() &amp;&amp; pe.isWildcardName()) {

            // build an info array for every principal
            // in the current domain which has a principal class
            // that is equal to policy entry principal class name
            List&lt;Principal&gt; plist = new ArrayList&lt;&gt;();
            for (int i = 0; i &lt; pdp.length; i++) {
                if (pe.principalClass.equals(pdp[i].getClass().getName()))
                    plist.add(pdp[i]);
            }
            String[][] info = new String[plist.size()][2];
            int i = 0;
            for (Principal p : plist) {
                info[i][0] = p.getClass().getName();
                info[i][1] = p.getName();
                i++;
            }
            return info;

        } else {

            // build an info array for every
            // one of the current Domain's principals

            String[][] info = new String[pdp.length][2];

            for (int i = 0; i &lt; pdp.length; i++) {
                info[i][0] = pdp[i].getClass().getName();
                info[i][1] = pdp[i].getName();
            }
            return info;
        }
    }

    /*
     * Returns the signer certificates from the list of certificates
     * associated with the given code source.
     *
     * The signer certificates are those certificates that were used
     * to verifysigned code originating from the codesource location.
     *
     * This method assumes that in the given code source, each signer
     * certificate is followed by its supporting certificate chain
     * (which may be empty), and that the signer certificate and its
     * supporting certificate chain are ordered bottom-to-top
     * (i.e., with the signer certificate first and the (root) certificate
     * authority last).
     */
    protected Certificate[] getSignerCertificates(CodeSource cs) {
        Certificate[] certs = null;
        if ((certs = cs.getCertificates()) == null)
            return null;
        for (int i=0; i&lt;certs.length; i++) {
            if (!(certs[i] instanceof X509Certificate))
                return cs.getCertificates();
        }

        // Do we have to do anything?
        int i = 0;
        int count = 0;
        while (i &lt; certs.length) {
            count++;
            while (((i+1) &lt; certs.length)
                   &amp;&amp; ((X509Certificate)certs[i]).getIssuerDN().equals(
                           ((X509Certificate)certs[i+1]).getSubjectDN())) {
                i++;
            }
            i++;
        }
        if (count == certs.length)
            // Done
            return certs;

        List&lt;Certificate&gt; userCertList = new ArrayList&lt;&gt;();
        i = 0;
        while (i &lt; certs.length) {
            userCertList.add(certs[i]);
            while (((i+1) &lt; certs.length)
                   &amp;&amp; ((X509Certificate)certs[i]).getIssuerDN().equals(
                           ((X509Certificate)certs[i+1]).getSubjectDN())) {
                i++;
            }
            i++;
        }
        Certificate[] userCerts = new Certificate[userCertList.size()];
        userCertList.toArray(userCerts);
        return userCerts;
    }

    private CodeSource canonicalizeCodebase(CodeSource cs,
                                            boolean extractSignerCerts) {

        String path = null;

        CodeSource canonCs = cs;
        URL u = cs.getLocation();
        if (u != null) {
            if (u.getProtocol().equals(&quot;jar&quot;)) {
                // unwrap url embedded inside jar url
                String spec = u.getFile();
                int separator = spec.indexOf(&quot;!/&quot;);
                if (separator != -1) {
                    try {
                        u = new URL(spec.substring(0, separator));
                    } catch (MalformedURLException e) {
                        // Fail silently. In this case, url stays what
                        // it was above
                    }
                }
            }
            if (u.getProtocol().equals(&quot;file&quot;)) {
                boolean isLocalFile = false;
                String host = u.getHost();
                isLocalFile = (host == null || host.equals(&quot;&quot;) ||
                    host.equals(&quot;~&quot;) || host.equalsIgnoreCase(&quot;localhost&quot;));

                if (isLocalFile) {
                    path = u.getFile().replace('/', File.separatorChar);
                    path = ParseUtil.decode(path);
                }
            }
        }

        if (path != null) {
            try {
                URL csUrl = null;
                path = canonPath(path);
                csUrl = ParseUtil.fileToEncodedURL(new File(path));

                if (extractSignerCerts) {
                    canonCs = new CodeSource(csUrl,
                                             getSignerCertificates(cs));
                } else {
                    canonCs = new CodeSource(csUrl,
                                             cs.getCertificates());
                }
            } catch (IOException ioe) {
                // leave codesource as it is, unless we have to extract its
                // signer certificates
                if (extractSignerCerts) {
                    canonCs = new CodeSource(cs.getLocation(),
                                             getSignerCertificates(cs));
                }
            }
        } else {
            if (extractSignerCerts) {
                canonCs = new CodeSource(cs.getLocation(),
                                         getSignerCertificates(cs));
            }
        }
        return canonCs;
    }

    // Wrapper to return a canonical path that avoids calling getCanonicalPath()
    // with paths that are intended to match all entries in the directory
    private static String canonPath(String path) throws IOException {
        if (path.endsWith(&quot;*&quot;)) {
            path = path.substring(0, path.length()-1) + &quot;-&quot;;
            path = new File(path).getCanonicalPath();
            return path.substring(0, path.length()-1) + &quot;*&quot;;
        } else {
            return new File(path).getCanonicalPath();
        }
    }

    private String printPD(ProtectionDomain pd) {
        Principal[] principals = pd.getPrincipals();
        String pals = &quot;&lt;no principals&gt;&quot;;
        if (principals != null &amp;&amp; principals.length &gt; 0) {
            StringBuilder palBuf = new StringBuilder(&quot;(principals &quot;);
            for (int i = 0; i &lt; principals.length; i++) {
                palBuf.append(principals[i].getClass().getName() +
                              &quot; \&quot;&quot; + principals[i].getName() +
                              &quot;\&quot;&quot;);
                if (i &lt; principals.length-1)
                    palBuf.append(&quot;, &quot;);
                else
                    palBuf.append(&quot;)&quot;);
            }
            pals = palBuf.toString();
        }
        return &quot;PD CodeSource: &quot;
                + pd.getCodeSource()
                +&quot;\n\t&quot; + &quot;PD ClassLoader: &quot;
                + pd.getClassLoader()
                +&quot;\n\t&quot; + &quot;PD Principals: &quot;
                + pals;
    }

    /**
     * return true if no replacement was performed,
     * or if replacement succeeded.
     */
    private boolean replacePrincipals(
        List&lt;PolicyParser.PrincipalEntry&gt; principals, KeyStore keystore) {

        if (principals == null || principals.isEmpty() || keystore == null)
            return true;

        for (PolicyParser.PrincipalEntry pppe : principals) {
            if (pppe.isReplaceName()) {

                // perform replacement
                // (only X509 replacement is possible now)
                String name;
                if ((name = getDN(pppe.principalName, keystore)) == null) {
                    return false;
                }

                if (debug != null) {
                    debug.println(&quot;  Replacing \&quot;&quot; +
                        pppe.principalName +
                        &quot;\&quot; with &quot; +
                        X500PRINCIPAL + &quot;/\&quot;&quot; +
                        name +
                        &quot;\&quot;&quot;);
                }

                pppe.principalClass = X500PRINCIPAL;
                pppe.principalName = name;
            }
        }
        // return true if no replacement was performed,
        // or if replacement succeeded
        return true;
    }

    private void expandPermissionName(PolicyParser.PermissionEntry pe,
                                        KeyStore keystore) throws Exception {
        // short cut the common case
        if (pe.name == null || pe.name.indexOf(&quot;${{&quot;, 0) == -1) {
            return;
        }

        int startIndex = 0;
        int b, e;
        StringBuilder sb = new StringBuilder();
        while ((b = pe.name.indexOf(&quot;${{&quot;, startIndex)) != -1) {
            e = pe.name.indexOf(&quot;}}&quot;, b);
            if (e &lt; 1) {
                break;
            }
            sb.append(pe.name.substring(startIndex, b));

            // get the value in ${{...}}
            String value = pe.name.substring(b+3, e);

            // parse up to the first ':'
            int colonIndex;
            String prefix = value;
            String suffix;
            if ((colonIndex = value.indexOf(&quot;:&quot;)) != -1) {
                prefix = value.substring(0, colonIndex);
            }

            // handle different prefix possibilities
            if (prefix.equalsIgnoreCase(&quot;self&quot;)) {
                // do nothing - handled later
                sb.append(pe.name.substring(b, e+2));
                startIndex = e+2;
                continue;
            } else if (prefix.equalsIgnoreCase(&quot;alias&quot;)) {
                // get the suffix and perform keystore alias replacement
                if (colonIndex == -1) {
                    MessageFormat form = new MessageFormat
                        (ResourcesMgr.getString
                        (&quot;alias.name.not.provided.pe.name.&quot;));
                    Object[] source = {pe.name};
                    throw new Exception(form.format(source));
                }
                suffix = value.substring(colonIndex+1);
                if ((suffix = getDN(suffix, keystore)) == null) {
                    MessageFormat form = new MessageFormat
                        (ResourcesMgr.getString
                        (&quot;unable.to.perform.substitution.on.alias.suffix&quot;));
                    Object[] source = {value.substring(colonIndex+1)};
                    throw new Exception(form.format(source));
                }

                sb.append(X500PRINCIPAL + &quot; \&quot;&quot; + suffix + &quot;\&quot;&quot;);
                startIndex = e+2;
            } else {
                MessageFormat form = new MessageFormat
                        (ResourcesMgr.getString
                        (&quot;substitution.value.prefix.unsupported&quot;));
                Object[] source = {prefix};
                throw new Exception(form.format(source));
            }
        }

        // copy the rest of the value
        sb.append(pe.name.substring(startIndex));

        // replace the name with expanded value
        if (debug != null) {
            debug.println(&quot;  Permission name expanded from:\n\t&quot; +
                        pe.name + &quot;\nto\n\t&quot; + sb.toString());
        }
        pe.name = sb.toString();
    }

    private String getDN(String alias, KeyStore keystore) {
        Certificate cert = null;
        try {
            cert = keystore.getCertificate(alias);
        } catch (Exception e) {
            if (debug != null) {
                debug.println(&quot;  Error retrieving certificate for '&quot; +
                                alias +
                                &quot;': &quot; +
                                e.toString());
            }
            return null;
        }

        if (cert == null || !(cert instanceof X509Certificate)) {
            if (debug != null) {
                debug.println(&quot;  -- No certificate for '&quot; +
                                alias +
                                &quot;' - ignoring entry&quot;);
            }
            return null;
        } else {
            X509Certificate x509Cert = (X509Certificate)cert;

            // 4702543:  X500 names with an EmailAddress
            // were encoded incorrectly.  create new
            // X500Principal name with correct encoding

            X500Principal p = new X500Principal
                (x509Cert.getSubjectX500Principal().toString());
            return p.getName();
        }
    }

    /**
     * Checks public key. If it is marked as trusted in
     * the identity database, add it to the policy
     * with the AllPermission.
     */
    private boolean checkForTrustedIdentity(final Certificate cert,
        PolicyInfo myInfo)
    {
        return false;
    }

    /**
     * Each entry in the policy configuration file is represented by a
     * PolicyEntry object.  &lt;p&gt;
     *
     * A PolicyEntry is a (CodeSource,Permission) pair.  The
     * CodeSource contains the (URL, PublicKey) that together identify
     * where the Java bytecodes come from and who (if anyone) signed
     * them.  The URL could refer to localhost.  The URL could also be
     * null, meaning that this policy entry is given to all comers, as
     * long as they match the signer field.  The signer could be null,
     * meaning the code is not signed. &lt;p&gt;
     *
     * The Permission contains the (Type, Name, Action) triplet. &lt;p&gt;
     *
     * For now, the Policy object retrieves the public key from the
     * X.509 certificate on disk that corresponds to the signedBy
     * alias specified in the Policy config file.  For reasons of
     * efficiency, the Policy object keeps a hashtable of certs already
     * read in.  This could be replaced by a secure internal key
     * store.
     *
     * &lt;p&gt;
     * For example, the entry
     * &lt;pre&gt;
     *          permission java.io.File &quot;/tmp&quot;, &quot;read,write&quot;,
     *          signedBy &quot;Duke&quot;;
     * &lt;/pre&gt;
     * is represented internally
     * &lt;pre&gt;
     *
     * FilePermission f = new FilePermission(&quot;/tmp&quot;, &quot;read,write&quot;);
     * PublicKey p = publickeys.get(&quot;Duke&quot;);
     * URL u = InetAddress.getLocalHost();
     * CodeBase c = new CodeBase( p, u );
     * pe = new PolicyEntry(f, c);
     * &lt;/pre&gt;
     *
     * @author Marianne Mueller
     * @author Roland Schemers
     * @see java.security.CodeSource
     * @see java.security.Policy
     * @see java.security.Permissions
     * @see java.security.ProtectionDomain
     */
    private static class PolicyEntry {

        private final CodeSource codesource;
        final List&lt;Permission&gt; permissions;
        private final List&lt;PolicyParser.PrincipalEntry&gt; principals;

        /**
         * Given a Permission and a CodeSource, create a policy entry.
         *
         * XXX Decide if/how to add validity fields and &quot;purpose&quot; fields to
         * XXX policy entries
         *
         * @param cs the CodeSource, which encapsulates the URL and the
         *        public key
         *        attributes from the policy config file. Validity checks
         *        are performed on the public key before PolicyEntry is
         *        called.
         *
         */
        PolicyEntry(CodeSource cs, List&lt;PolicyParser.PrincipalEntry&gt; principals)
        {
            this.codesource = cs;
            this.permissions = new ArrayList&lt;Permission&gt;();
            this.principals = principals; // can be null
        }

        PolicyEntry(CodeSource cs)
        {
            this(cs, null);
        }

        List&lt;PolicyParser.PrincipalEntry&gt; getPrincipals() {
            return principals; // can be null
        }

        /**
         * add a Permission object to this entry.
         * No need to sync add op because perms are added to entry only
         * while entry is being initialized
         */
        void add(Permission p) {
            permissions.add(p);
        }

        /**
         * Return the CodeSource for this policy entry
         */
        CodeSource getCodeSource() {
            return codesource;
        }

        @Override public String toString(){
            StringBuilder sb = new StringBuilder();
            sb.append(ResourcesMgr.getString(&quot;LPARAM&quot;));
            sb.append(getCodeSource());
            sb.append(&quot;\n&quot;);
            for (int j = 0; j &lt; permissions.size(); j++) {
                Permission p = permissions.get(j);
                sb.append(ResourcesMgr.getString(&quot;SPACE&quot;));
                sb.append(ResourcesMgr.getString(&quot;SPACE&quot;));
                sb.append(p);
                sb.append(ResourcesMgr.getString(&quot;NEWLINE&quot;));
            }
            sb.append(ResourcesMgr.getString(&quot;RPARAM&quot;));
            sb.append(ResourcesMgr.getString(&quot;NEWLINE&quot;));
            return sb.toString();
        }
    }

    private static class SelfPermission extends Permission {

        private static final long serialVersionUID = -8315562579967246806L;

        /**
         * The class name of the Permission class that will be
         * created when this self permission is expanded .
         *
         * @serial
         */
        private String type;

        /**
         * The permission name.
         *
         * @serial
         */
        private String name;

        /**
         * The actions of the permission.
         *
         * @serial
         */
        private String actions;

        /**
         * The certs of the permission.
         *
         * @serial
         */
        private Certificate certs[];

        /**
         * Creates a new SelfPermission containing the permission
         * information needed later to expand the self
         * @param type the class name of the Permission class that will be
         * created when this permission is expanded and if necessary resolved.
         * @param name the name of the permission.
         * @param actions the actions of the permission.
         * @param certs the certificates the permission's class was signed with.
         * This is a list of certificate chains, where each chain is composed of
         * a signer certificate and optionally its supporting certificate chain.
         * Each chain is ordered bottom-to-top (i.e., with the signer
         * certificate first and the (root) certificate authority last).
         */
        public SelfPermission(String type, String name, String actions,
                              Certificate certs[])
        {
            super(type);
            if (type == null) {
                throw new NullPointerException
                    (ResourcesMgr.getString(&quot;type.can.t.be.null&quot;));
            }
            this.type = type;
            this.name = name;
            this.actions = actions;
            if (certs != null) {
                // Extract the signer certs from the list of certificates.
                for (int i=0; i&lt;certs.length; i++) {
                    if (!(certs[i] instanceof X509Certificate)) {
                        // there is no concept of signer certs, so we store the
                        // entire cert array
                        this.certs = certs.clone();
                        break;
                    }
                }

                if (this.certs == null) {
                    // Go through the list of certs and see if all the certs are
                    // signer certs.
                    int i = 0;
                    int count = 0;
                    while (i &lt; certs.length) {
                        count++;
                        while (((i+1) &lt; certs.length) &amp;&amp;
                            ((X509Certificate)certs[i]).getIssuerDN().equals(
                            ((X509Certificate)certs[i+1]).getSubjectDN())) {
                            i++;
                        }
                        i++;
                    }
                    if (count == certs.length) {
                        // All the certs are signer certs, so we store the
                        // entire array
                        this.certs = certs.clone();
                    }

                    if (this.certs == null) {
                        // extract the signer certs
                        List&lt;Certificate&gt; signerCerts = new ArrayList&lt;&gt;();
                        i = 0;
                        while (i &lt; certs.length) {
                            signerCerts.add(certs[i]);
                            while (((i+1) &lt; certs.length) &amp;&amp;
                                ((X509Certificate)certs[i]).getIssuerDN().equals(
                                ((X509Certificate)certs[i+1]).getSubjectDN())) {
                                i++;
                            }
                            i++;
                        }
                        this.certs = new Certificate[signerCerts.size()];
                        signerCerts.toArray(this.certs);
                    }
                }
            }
        }

        /**
         * This method always returns false for SelfPermission permissions.
         * That is, an SelfPermission never considered to
         * imply another permission.
         *
         * @param p the permission to check against.
         *
         * @return false.
         */
        @Override public boolean implies(Permission p) {
            return false;
        }

        /**
         * Checks two SelfPermission objects for equality.
         *
         * Checks that &lt;i&gt;obj&lt;/i&gt; is an SelfPermission, and has
         * the same type (class) name, permission name, actions, and
         * certificates as this object.
         *
         * @param obj the object we are testing for equality with this object.
         *
         * @return true if obj is an SelfPermission, and has the same
         * type (class) name, permission name, actions, and
         * certificates as this object.
         */
        @Override public boolean equals(Object obj) {
            if (obj == this)
                return true;

            if (! (obj instanceof SelfPermission))
                return false;
            SelfPermission that = (SelfPermission) obj;

            if (!(this.type.equals(that.type) &amp;&amp;
                this.name.equals(that.name) &amp;&amp;
                this.actions.equals(that.actions)))
                return false;

            if (this.certs.length != that.certs.length)
                return false;

            int i,j;
            boolean match;

            for (i = 0; i &lt; this.certs.length; i++) {
                match = false;
                for (j = 0; j &lt; that.certs.length; j++) {
                    if (this.certs[i].equals(that.certs[j])) {
                        match = true;
                        break;
                    }
                }
                if (!match) return false;
            }

            for (i = 0; i &lt; that.certs.length; i++) {
                match = false;
                for (j = 0; j &lt; this.certs.length; j++) {
                    if (that.certs[i].equals(this.certs[j])) {
                        match = true;
                        break;
                    }
                }
                if (!match) return false;
            }
            return true;
        }

        /**
         * Returns the hash code value for this object.
         *
         * @return a hash code value for this object.
         */
        @Override public int hashCode() {
            int hash = type.hashCode();
            if (name != null)
                hash ^= name.hashCode();
            if (actions != null)
                hash ^= actions.hashCode();
            return hash;
        }

        /**
         * Returns the canonical string representation of the actions,
         * which currently is the empty string &quot;&quot;, since there are no actions
         * for an SelfPermission. That is, the actions for the
         * permission that will be created when this SelfPermission
         * is resolved may be non-null, but an SelfPermission
         * itself is never considered to have any actions.
         *
         * @return the empty string &quot;&quot;.
         */
        @Override public String getActions() {
            return &quot;&quot;;
        }

        public String getSelfType() {
            return type;
        }

        public String getSelfName() {
            return name;
        }

        public String getSelfActions() {
            return actions;
        }

        public Certificate[] getCerts() {
            return certs;
        }

        /**
         * Returns a string describing this SelfPermission.  The convention
         * is to specify the class name, the permission name, and the actions,
         * in the following format: '(unresolved &quot;ClassName&quot; &quot;name&quot; &quot;actions&quot;)'.
         *
         * @return information about this SelfPermission.
         */
        @Override public String toString() {
            return &quot;(SelfPermission &quot; + type + &quot; &quot; + name + &quot; &quot; + actions + &quot;)&quot;;
        }
    }

    /**
     * holds policy information that we need to synch on
     */
    private static class PolicyInfo {
        private static final boolean verbose = false;

        // Stores grant entries in the policy
        final List&lt;PolicyEntry&gt; policyEntries;

        // Stores grant entries gotten from identity database
        // Use separate lists to avoid sync on policyEntries
        final List&lt;PolicyEntry&gt; identityPolicyEntries;

        // Maps aliases to certs
        final Map&lt;Object, Object&gt; aliasMapping;

        // Maps ProtectionDomain to PermissionCollection
        private final ProtectionDomainCache[] pdMapping;
        private java.util.Random random;

        PolicyInfo(int numCaches) {
            policyEntries = new ArrayList&lt;&gt;();
            identityPolicyEntries =
                Collections.synchronizedList(new ArrayList&lt;PolicyEntry&gt;(2));
            aliasMapping = Collections.synchronizedMap(new HashMap&lt;&gt;(11));

            pdMapping = new ProtectionDomainCache[numCaches];
            JavaSecurityProtectionDomainAccess jspda
                = SharedSecrets.getJavaSecurityProtectionDomainAccess();
            for (int i = 0; i &lt; numCaches; i++) {
                pdMapping[i] = jspda.getProtectionDomainCache();
            }
            if (numCaches &gt; 1) {
                random = new java.util.Random();
            }
        }
        ProtectionDomainCache getPdMapping() {
            if (pdMapping.length == 1) {
                return pdMapping[0];
            } else {
                int i = java.lang.Math.abs(random.nextInt() % pdMapping.length);
                return pdMapping[i];
            }
        }
    }
}
</pre>
</body>
</html>
