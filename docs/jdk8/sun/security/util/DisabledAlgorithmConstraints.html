<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.util;

import java.security.AlgorithmConstraints;
import java.security.CryptoPrimitive;
import java.security.AlgorithmParameters;

import java.security.Key;
import java.security.Security;
import java.security.PrivilegedAction;
import java.security.AccessController;

import java.util.Locale;
import java.util.Set;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

/**
 * Algorithm constraints for disabled algorithms property
 *
 * See the &quot;jdk.certpath.disabledAlgorithms&quot; specification in java.security
 * for the syntax of the disabled algorithm string.
 */
public class DisabledAlgorithmConstraints implements AlgorithmConstraints {

    // the known security property, jdk.certpath.disabledAlgorithms
    public final static String PROPERTY_CERTPATH_DISABLED_ALGS =
            &quot;jdk.certpath.disabledAlgorithms&quot;;

    // the known security property, jdk.tls.disabledAlgorithms
    public final static String PROPERTY_TLS_DISABLED_ALGS =
            &quot;jdk.tls.disabledAlgorithms&quot;;

    private final static Map&lt;String, String[]&gt; disabledAlgorithmsMap =
                                                            new HashMap&lt;&gt;();
    private final static Map&lt;String, KeySizeConstraints&gt; keySizeConstraintsMap =
                                                            new HashMap&lt;&gt;();

    private String[] disabledAlgorithms;
    private KeySizeConstraints keySizeConstraints;

    /**
     * Initialize algorithm constraints with the specified security property.
     *
     * @param propertyName the security property name that define the disabled
     *        algorithm constraints
     */
    public DisabledAlgorithmConstraints(String propertyName) {
        // Both disabledAlgorithmsMap and keySizeConstraintsMap are
        // synchronized with the lock of disabledAlgorithmsMap.
        synchronized (disabledAlgorithmsMap) {
            if(!disabledAlgorithmsMap.containsKey(propertyName)) {
                loadDisabledAlgorithmsMap(propertyName);
            }

            disabledAlgorithms = disabledAlgorithmsMap.get(propertyName);
            keySizeConstraints = keySizeConstraintsMap.get(propertyName);
        }
    }

    @Override
    final public boolean permits(Set&lt;CryptoPrimitive&gt; primitives,
            String algorithm, AlgorithmParameters parameters) {

        if (algorithm == null || algorithm.length() == 0) {
            throw new IllegalArgumentException(&quot;No algorithm name specified&quot;);
        }

        if (primitives == null || primitives.isEmpty()) {
            throw new IllegalArgumentException(
                        &quot;No cryptographic primitive specified&quot;);
        }

        Set&lt;String&gt; elements = null;
        for (String disabled : disabledAlgorithms) {
            if (disabled == null || disabled.isEmpty()) {
                continue;
            }

            // check the full name
            if (disabled.equalsIgnoreCase(algorithm)) {
                return false;
            }

            // decompose the algorithm into sub-elements
            if (elements == null) {
                elements = decomposes(algorithm);
            }

            // check the items of the algorithm
            for (String element : elements) {
                if (disabled.equalsIgnoreCase(element)) {
                    return false;
                }
            }
        }

        return true;
    }

    @Override
    final public boolean permits(Set&lt;CryptoPrimitive&gt; primitives, Key key) {
        return checkConstraints(primitives, &quot;&quot;, key, null);
    }

    @Override
    final public boolean permits(Set&lt;CryptoPrimitive&gt; primitives,
            String algorithm, Key key, AlgorithmParameters parameters) {

        if (algorithm == null || algorithm.length() == 0) {
            throw new IllegalArgumentException(&quot;No algorithm name specified&quot;);
        }

        return checkConstraints(primitives, algorithm, key, parameters);
    }

    /**
     * Decompose the standard algorithm name into sub-elements.
     * &lt;p&gt;
     * For example, we need to decompose &quot;SHA1WithRSA&quot; into &quot;SHA1&quot; and &quot;RSA&quot;
     * so that we can check the &quot;SHA1&quot; and &quot;RSA&quot; algorithm constraints
     * separately.
     * &lt;p&gt;
     * Please override the method if need to support more name pattern.
     */
    protected Set&lt;String&gt; decomposes(String algorithm) {
        if (algorithm == null || algorithm.length() == 0) {
            return new HashSet&lt;String&gt;();
        }

        // algorithm/mode/padding
        Pattern transPattern = Pattern.compile(&quot;/&quot;);
        String[] transTockens = transPattern.split(algorithm);

        Set&lt;String&gt; elements = new HashSet&lt;String&gt;();
        for (String transTocken : transTockens) {
            if (transTocken == null || transTocken.length() == 0) {
                continue;
            }

            // PBEWith&lt;digest&gt;And&lt;encryption&gt;
            // PBEWith&lt;prf&gt;And&lt;encryption&gt;
            // OAEPWith&lt;digest&gt;And&lt;mgf&gt;Padding
            // &lt;digest&gt;with&lt;encryption&gt;
            // &lt;digest&gt;with&lt;encryption&gt;and&lt;mgf&gt;
            Pattern pattern =
                    Pattern.compile(&quot;with|and&quot;, Pattern.CASE_INSENSITIVE);
            String[] tokens = pattern.split(transTocken);

            for (String token : tokens) {
                if (token == null || token.length() == 0) {
                    continue;
                }

                elements.add(token);
            }
        }

        // In Java standard algorithm name specification, for different
        // purpose, the SHA-1 and SHA-2 algorithm names are different. For
        // example, for MessageDigest, the standard name is &quot;SHA-256&quot;, while
        // for Signature, the digest algorithm component is &quot;SHA256&quot; for
        // signature algorithm &quot;SHA256withRSA&quot;. So we need to check both
        // &quot;SHA-256&quot; and &quot;SHA256&quot; to make the right constraint checking.

        // handle special name: SHA-1 and SHA1
        if (elements.contains(&quot;SHA1&quot;) &amp;&amp; !elements.contains(&quot;SHA-1&quot;)) {
            elements.add(&quot;SHA-1&quot;);
        }
        if (elements.contains(&quot;SHA-1&quot;) &amp;&amp; !elements.contains(&quot;SHA1&quot;)) {
            elements.add(&quot;SHA1&quot;);
        }

        // handle special name: SHA-224 and SHA224
        if (elements.contains(&quot;SHA224&quot;) &amp;&amp; !elements.contains(&quot;SHA-224&quot;)) {
            elements.add(&quot;SHA-224&quot;);
        }
        if (elements.contains(&quot;SHA-224&quot;) &amp;&amp; !elements.contains(&quot;SHA224&quot;)) {
            elements.add(&quot;SHA224&quot;);
        }

        // handle special name: SHA-256 and SHA256
        if (elements.contains(&quot;SHA256&quot;) &amp;&amp; !elements.contains(&quot;SHA-256&quot;)) {
            elements.add(&quot;SHA-256&quot;);
        }
        if (elements.contains(&quot;SHA-256&quot;) &amp;&amp; !elements.contains(&quot;SHA256&quot;)) {
            elements.add(&quot;SHA256&quot;);
        }

        // handle special name: SHA-384 and SHA384
        if (elements.contains(&quot;SHA384&quot;) &amp;&amp; !elements.contains(&quot;SHA-384&quot;)) {
            elements.add(&quot;SHA-384&quot;);
        }
        if (elements.contains(&quot;SHA-384&quot;) &amp;&amp; !elements.contains(&quot;SHA384&quot;)) {
            elements.add(&quot;SHA384&quot;);
        }

        // handle special name: SHA-512 and SHA512
        if (elements.contains(&quot;SHA512&quot;) &amp;&amp; !elements.contains(&quot;SHA-512&quot;)) {
            elements.add(&quot;SHA-512&quot;);
        }
        if (elements.contains(&quot;SHA-512&quot;) &amp;&amp; !elements.contains(&quot;SHA512&quot;)) {
            elements.add(&quot;SHA512&quot;);
        }

        return elements;
    }

    // Check algorithm constraints
    private boolean checkConstraints(Set&lt;CryptoPrimitive&gt; primitives,
            String algorithm, Key key, AlgorithmParameters parameters) {

        // check the key parameter, it cannot be null.
        if (key == null) {
            throw new IllegalArgumentException(&quot;The key cannot be null&quot;);
        }

        // check the target algorithm
        if (algorithm != null &amp;&amp; algorithm.length() != 0) {
            if (!permits(primitives, algorithm, parameters)) {
                return false;
            }
        }

        // check the key algorithm
        if (!permits(primitives, key.getAlgorithm(), null)) {
            return false;
        }

        // check the key constraints
        if (keySizeConstraints.disables(key)) {
            return false;
        }

        return true;
    }

    // Get disabled algorithm constraints from the specified security property.
    private static void loadDisabledAlgorithmsMap(
            final String propertyName) {

        String property = AccessController.doPrivileged(
            new PrivilegedAction&lt;String&gt;() {
                public String run() {
                    return Security.getProperty(propertyName);
                }
            });

        String[] algorithmsInProperty = null;

        if (property != null &amp;&amp; !property.isEmpty()) {

            // remove double quote marks from beginning/end of the property
            if (property.charAt(0) == '&quot;' &amp;&amp;
                    property.charAt(property.length() - 1) == '&quot;') {
                property = property.substring(1, property.length() - 1);
            }

            algorithmsInProperty = property.split(&quot;,&quot;);
            for (int i = 0; i &lt; algorithmsInProperty.length; i++) {
                algorithmsInProperty[i] = algorithmsInProperty[i].trim();
            }
        }

        // map the disabled algorithms
        if (algorithmsInProperty == null) {
            algorithmsInProperty = new String[0];
        }
        disabledAlgorithmsMap.put(propertyName, algorithmsInProperty);

        // map the key constraints
        KeySizeConstraints keySizeConstraints =
            new KeySizeConstraints(algorithmsInProperty);
        keySizeConstraintsMap.put(propertyName, keySizeConstraints);
    }

    /**
     * key constraints
     */
    private static class KeySizeConstraints {
        private static final Pattern pattern = Pattern.compile(
                &quot;(\\S+)\\s+keySize\\s*(&lt;=|&lt;|==|!=|&gt;|&gt;=)\\s*(\\d+)&quot;);

        private Map&lt;String, Set&lt;KeySizeConstraint&gt;&gt; constraintsMap =
            Collections.synchronizedMap(
                        new HashMap&lt;String, Set&lt;KeySizeConstraint&gt;&gt;());

        public KeySizeConstraints(String[] restrictions) {
            for (String restriction : restrictions) {
                if (restriction == null || restriction.isEmpty()) {
                    continue;
                }

                Matcher matcher = pattern.matcher(restriction);
                if (matcher.matches()) {
                    String algorithm = matcher.group(1);

                    KeySizeConstraint.Operator operator =
                             KeySizeConstraint.Operator.of(matcher.group(2));
                    int length = Integer.parseInt(matcher.group(3));

                    algorithm = algorithm.toLowerCase(Locale.ENGLISH);

                    synchronized (constraintsMap) {
                        if (!constraintsMap.containsKey(algorithm)) {
                            constraintsMap.put(algorithm,
                                new HashSet&lt;KeySizeConstraint&gt;());
                        }

                        Set&lt;KeySizeConstraint&gt; constraintSet =
                            constraintsMap.get(algorithm);
                        KeySizeConstraint constraint =
                            new KeySizeConstraint(operator, length);
                        constraintSet.add(constraint);
                    }
                }
            }
        }

        // Does this KeySizeConstraints disable the specified key?
        public boolean disables(Key key) {
            String algorithm = key.getAlgorithm().toLowerCase(Locale.ENGLISH);
            synchronized (constraintsMap) {
                if (constraintsMap.containsKey(algorithm)) {
                    Set&lt;KeySizeConstraint&gt; constraintSet =
                                        constraintsMap.get(algorithm);
                    for (KeySizeConstraint constraint : constraintSet) {
                        if (constraint.disables(key)) {
                            return true;
                        }
                    }
                }
            }

            return false;
        }
    }

    /**
     * Key size constraint.
     *
     * e.g.  &quot;keysize &lt;= 1024&quot;
     */
    private static class KeySizeConstraint {
        // operator
        static enum Operator {
            EQ,         // &quot;==&quot;
            NE,         // &quot;!=&quot;
            LT,         // &quot;&lt;&quot;
            LE,         // &quot;&lt;=&quot;
            GT,         // &quot;&gt;&quot;
            GE;         // &quot;&gt;=&quot;

            static Operator of(String s) {
                switch (s) {
                    case &quot;==&quot;:
                        return EQ;
                    case &quot;!=&quot;:
                        return NE;
                    case &quot;&lt;&quot;:
                        return LT;
                    case &quot;&lt;=&quot;:
                        return LE;
                    case &quot;&gt;&quot;:
                        return GT;
                    case &quot;&gt;=&quot;:
                        return GE;
                }

                throw new IllegalArgumentException(
                        s + &quot; is not a legal Operator&quot;);
            }
        }

        private int minSize;            // the minimal available key size
        private int maxSize;            // the maximal available key size
        private int prohibitedSize = -1;    // unavailable key sizes

        public KeySizeConstraint(Operator operator, int length) {
            switch (operator) {
                case EQ:      // an unavailable key size
                    this.minSize = 0;
                    this.maxSize = Integer.MAX_VALUE;
                    prohibitedSize = length;
                    break;
                case NE:
                    this.minSize = length;
                    this.maxSize = length;
                    break;
                case LT:
                    this.minSize = length;
                    this.maxSize = Integer.MAX_VALUE;
                    break;
                case LE:
                    this.minSize = length + 1;
                    this.maxSize = Integer.MAX_VALUE;
                    break;
                case GT:
                    this.minSize = 0;
                    this.maxSize = length;
                    break;
                case GE:
                    this.minSize = 0;
                    this.maxSize = length &gt; 1 ? (length - 1) : 0;
                    break;
                default:
                    // unlikely to happen
                    this.minSize = Integer.MAX_VALUE;
                    this.maxSize = -1;
            }
        }

        // Does this key constraint disable the specified key?
        public boolean disables(Key key) {
            int size = KeyUtil.getKeySize(key);

            if (size == 0) {
                return true;    // we don't allow any key of size 0.
            } else if (size &gt; 0) {
                return ((size &lt; minSize) || (size &gt; maxSize) ||
                    (prohibitedSize == size));
            }   // Otherwise, the key size is not accessible. Conservatively,
                // please don't disable such keys.

            return false;
        }
    }

}

</pre>
</body>
</html>
