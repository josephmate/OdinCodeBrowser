<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.pkcs11;

import java.io.*;
import static java.io.StreamTokenizer.*;
import java.math.BigInteger;
import java.util.*;

import java.security.*;

import sun.security.action.GetPropertyAction;
import sun.security.util.PropertyExpander;

import sun.security.pkcs11.wrapper.*;
import static sun.security.pkcs11.wrapper.PKCS11Constants.*;
import static sun.security.pkcs11.wrapper.CK_ATTRIBUTE.*;

import static sun.security.pkcs11.TemplateManager.*;

/**
 * Configuration container and file parsing.
 *
 * @author  Andreas Sterbenz
 * @since   1.5
 */
final class Config {

    static final int ERR_HALT       = 1;
    static final int ERR_IGNORE_ALL = 2;
    static final int ERR_IGNORE_LIB = 3;

    // same as allowSingleThreadedModules but controlled via a system property
    // and applied to all providers. if set to false, no SunPKCS11 instances
    // will accept single threaded modules regardless of the setting in their
    // config files.
    private static final boolean staticAllowSingleThreadedModules;

    static {
        String p = &quot;sun.security.pkcs11.allowSingleThreadedModules&quot;;
        String s = AccessController.doPrivileged(new GetPropertyAction(p));
        if (&quot;false&quot;.equalsIgnoreCase(s)) {
            staticAllowSingleThreadedModules = false;
        } else {
            staticAllowSingleThreadedModules = true;
        }
    }

    // temporary storage for configurations
    // needed because the SunPKCS11 needs to call the superclass constructor
    // in provider before accessing any instance variables
    private final static Map&lt;String,Config&gt; configMap =
                                        new HashMap&lt;String,Config&gt;();

    static Config getConfig(final String name, final InputStream stream) {
        Config config = configMap.get(name);
        if (config != null) {
            return config;
        }
        try {
            config = new Config(name, stream);
            configMap.put(name, config);
            return config;
        } catch (Exception e) {
            throw new ProviderException(&quot;Error parsing configuration&quot;, e);
        }
    }

    static Config removeConfig(String name) {
        return configMap.remove(name);
    }

    private final static boolean DEBUG = false;

    private static void debug(Object o) {
        if (DEBUG) {
            System.out.println(o);
        }
    }

    // Reader and StringTokenizer used during parsing
    private Reader reader;

    private StreamTokenizer st;

    private Set&lt;String&gt; parsedKeywords;

    // name suffix of the provider
    private String name;

    // name of the PKCS#11 library
    private String library;

    // description to pass to the provider class
    private String description;

    // slotID of the slot to use
    private int slotID = -1;

    // slot to use, specified as index in the slotlist
    private int slotListIndex = -1;

    // set of enabled mechanisms (or null to use default)
    private Set&lt;Long&gt; enabledMechanisms;

    // set of disabled mechanisms
    private Set&lt;Long&gt; disabledMechanisms;

    // whether to print debug info during startup
    private boolean showInfo = false;

    // template manager, initialized from parsed attributes
    private TemplateManager templateManager;

    // how to handle error during startup, one of ERR_
    private int handleStartupErrors = ERR_HALT;

    // flag indicating whether the P11KeyStore should
    // be more tolerant of input parameters
    private boolean keyStoreCompatibilityMode = true;

    // flag indicating whether we need to explicitly cancel operations
    // see Token
    private boolean explicitCancel = true;

    // how often to test for token insertion, if no token is present
    private int insertionCheckInterval = 2000;

    // flag inidicating whether to omit the call to C_Initialize()
    // should be used only if we are running within a process that
    // has already called it (e.g. Plugin inside of Mozilla/NSS)
    private boolean omitInitialize = false;

    // whether to allow modules that only support single threaded access.
    // they cannot be used safely from multiple PKCS#11 consumers in the
    // same process, for example NSS and SunPKCS11
    private boolean allowSingleThreadedModules = true;

    // name of the C function that returns the PKCS#11 functionlist
    // This option primarily exists for the deprecated
    // Secmod.Module.getProvider() method.
    private String functionList = &quot;C_GetFunctionList&quot;;

    // whether to use NSS secmod mode. Implicitly set if nssLibraryDirectory,
    // nssSecmodDirectory, or nssModule is specified.
    private boolean nssUseSecmod;

    // location of the NSS library files (libnss3.so, etc.)
    private String nssLibraryDirectory;

    // location of secmod.db
    private String nssSecmodDirectory;

    // which NSS module to use
    private String nssModule;

    private Secmod.DbMode nssDbMode = Secmod.DbMode.READ_WRITE;

    // Whether the P11KeyStore should specify the CKA_NETSCAPE_DB attribute
    // when creating private keys. Only valid if nssUseSecmod is true.
    private boolean nssNetscapeDbWorkaround = true;

    // Special init argument string for the NSS softtoken.
    // This is used when using the NSS softtoken directly without secmod mode.
    private String nssArgs;

    // whether to use NSS trust attributes for the KeyStore of this provider
    // this option is for internal use by the SunPKCS11 code only and
    // works only for NSS providers created via the Secmod API
    private boolean nssUseSecmodTrust = false;

    // Flag to indicate whether the X9.63 encoding for EC points shall be used
    // (true) or whether that encoding shall be wrapped in an ASN.1 OctetString
    // (false).
    private boolean useEcX963Encoding = false;

    // Flag to indicate whether NSS should favour performance (false) or
    // memory footprint (true).
    private boolean nssOptimizeSpace = false;

    private Config(String filename, InputStream in) throws IOException {
        if (in == null) {
            if (filename.startsWith(&quot;--&quot;)) {
                // inline config
                String config = filename.substring(2).replace(&quot;\\n&quot;, &quot;\n&quot;);
                reader = new StringReader(config);
            } else {
                in = new FileInputStream(expand(filename));
            }
        }
        if (reader == null) {
            reader = new BufferedReader(new InputStreamReader(in));
        }
        parsedKeywords = new HashSet&lt;String&gt;();
        st = new StreamTokenizer(reader);
        setupTokenizer();
        parse();
    }

    String getName() {
        return name;
    }

    String getLibrary() {
        return library;
    }

    String getDescription() {
        if (description != null) {
            return description;
        }
        return &quot;SunPKCS11-&quot; + name + &quot; using library &quot; + library;
    }

    int getSlotID() {
        return slotID;
    }

    int getSlotListIndex() {
        if ((slotID == -1) &amp;&amp; (slotListIndex == -1)) {
            // if neither is set, default to first slot
            return 0;
        } else {
            return slotListIndex;
        }
    }

    boolean getShowInfo() {
        return (SunPKCS11.debug != null) || showInfo;
    }

    TemplateManager getTemplateManager() {
        if (templateManager == null) {
            templateManager = new TemplateManager();
        }
        return templateManager;
    }

    boolean isEnabled(long m) {
        if (enabledMechanisms != null) {
            return enabledMechanisms.contains(Long.valueOf(m));
        }
        if (disabledMechanisms != null) {
            return !disabledMechanisms.contains(Long.valueOf(m));
        }
        return true;
    }

    int getHandleStartupErrors() {
        return handleStartupErrors;
    }

    boolean getKeyStoreCompatibilityMode() {
        return keyStoreCompatibilityMode;
    }

    boolean getExplicitCancel() {
        return explicitCancel;
    }

    int getInsertionCheckInterval() {
        return insertionCheckInterval;
    }

    boolean getOmitInitialize() {
        return omitInitialize;
    }

    boolean getAllowSingleThreadedModules() {
        return staticAllowSingleThreadedModules &amp;&amp; allowSingleThreadedModules;
    }

    String getFunctionList() {
        return functionList;
    }

    boolean getNssUseSecmod() {
        return nssUseSecmod;
    }

    String getNssLibraryDirectory() {
        return nssLibraryDirectory;
    }

    String getNssSecmodDirectory() {
        return nssSecmodDirectory;
    }

    String getNssModule() {
        return nssModule;
    }

    Secmod.DbMode getNssDbMode() {
        return nssDbMode;
    }

    public boolean getNssNetscapeDbWorkaround() {
        return nssUseSecmod &amp;&amp; nssNetscapeDbWorkaround;
    }

    String getNssArgs() {
        return nssArgs;
    }

    boolean getNssUseSecmodTrust() {
        return nssUseSecmodTrust;
    }

    boolean getUseEcX963Encoding() {
        return useEcX963Encoding;
    }

    boolean getNssOptimizeSpace() {
        return nssOptimizeSpace;
    }

    private static String expand(final String s) throws IOException {
        try {
            return PropertyExpander.expand(s);
        } catch (Exception e) {
            throw new RuntimeException(e.getMessage());
        }
    }

    private void setupTokenizer() {
        st.resetSyntax();
        st.wordChars('a', 'z');
        st.wordChars('A', 'Z');
        st.wordChars('0', '9');
        st.wordChars(':', ':');
        st.wordChars('.', '.');
        st.wordChars('_', '_');
        st.wordChars('-', '-');
        st.wordChars('/', '/');
        st.wordChars('\\', '\\');
        st.wordChars('$', '$');
        st.wordChars('{', '{'); // need {} for property subst
        st.wordChars('}', '}');
        st.wordChars('*', '*');
        st.wordChars('+', '+');
        st.wordChars('~', '~');
        // XXX check ASCII table and add all other characters except special

        // special: #=&quot;(),
        st.whitespaceChars(0, ' ');
        st.commentChar('#');
        st.eolIsSignificant(true);
        st.quoteChar('\&quot;');
    }

    private ConfigurationException excToken(String msg) {
        return new ConfigurationException(msg + &quot; &quot; + st);
    }

    private ConfigurationException excLine(String msg) {
        return new ConfigurationException(msg + &quot;, line &quot; + st.lineno());
    }

    private void parse() throws IOException {
        while (true) {
            int token = nextToken();
            if (token == TT_EOF) {
                break;
            }
            if (token == TT_EOL) {
                continue;
            }
            if (token != TT_WORD) {
                throw excToken(&quot;Unexpected token:&quot;);
            }
            String word = st.sval;
            if (word.equals(&quot;name&quot;)) {
                name = parseStringEntry(word);
            } else if (word.equals(&quot;library&quot;)) {
                library = parseLibrary(word);
            } else if (word.equals(&quot;description&quot;)) {
                parseDescription(word);
            } else if (word.equals(&quot;slot&quot;)) {
                parseSlotID(word);
            } else if (word.equals(&quot;slotListIndex&quot;)) {
                parseSlotListIndex(word);
            } else if (word.equals(&quot;enabledMechanisms&quot;)) {
                parseEnabledMechanisms(word);
            } else if (word.equals(&quot;disabledMechanisms&quot;)) {
                parseDisabledMechanisms(word);
            } else if (word.equals(&quot;attributes&quot;)) {
                parseAttributes(word);
            } else if (word.equals(&quot;handleStartupErrors&quot;)) {
                parseHandleStartupErrors(word);
            } else if (word.endsWith(&quot;insertionCheckInterval&quot;)) {
                insertionCheckInterval = parseIntegerEntry(word);
                if (insertionCheckInterval &lt; 100) {
                    throw excLine(word + &quot; must be at least 100 ms&quot;);
                }
            } else if (word.equals(&quot;showInfo&quot;)) {
                showInfo = parseBooleanEntry(word);
            } else if (word.equals(&quot;keyStoreCompatibilityMode&quot;)) {
                keyStoreCompatibilityMode = parseBooleanEntry(word);
            } else if (word.equals(&quot;explicitCancel&quot;)) {
                explicitCancel = parseBooleanEntry(word);
            } else if (word.equals(&quot;omitInitialize&quot;)) {
                omitInitialize = parseBooleanEntry(word);
            } else if (word.equals(&quot;allowSingleThreadedModules&quot;)) {
                allowSingleThreadedModules = parseBooleanEntry(word);
            } else if (word.equals(&quot;functionList&quot;)) {
                functionList = parseStringEntry(word);
            } else if (word.equals(&quot;nssUseSecmod&quot;)) {
                nssUseSecmod = parseBooleanEntry(word);
            } else if (word.equals(&quot;nssLibraryDirectory&quot;)) {
                nssLibraryDirectory = parseLibrary(word);
                nssUseSecmod = true;
            } else if (word.equals(&quot;nssSecmodDirectory&quot;)) {
                nssSecmodDirectory = expand(parseStringEntry(word));
                nssUseSecmod = true;
            } else if (word.equals(&quot;nssModule&quot;)) {
                nssModule = parseStringEntry(word);
                nssUseSecmod = true;
            } else if (word.equals(&quot;nssDbMode&quot;)) {
                String mode = parseStringEntry(word);
                if (mode.equals(&quot;readWrite&quot;)) {
                    nssDbMode = Secmod.DbMode.READ_WRITE;
                } else if (mode.equals(&quot;readOnly&quot;)) {
                    nssDbMode = Secmod.DbMode.READ_ONLY;
                } else if (mode.equals(&quot;noDb&quot;)) {
                    nssDbMode = Secmod.DbMode.NO_DB;
                } else {
                    throw excToken(&quot;nssDbMode must be one of readWrite, readOnly, and noDb:&quot;);
                }
                nssUseSecmod = true;
            } else if (word.equals(&quot;nssNetscapeDbWorkaround&quot;)) {
                nssNetscapeDbWorkaround = parseBooleanEntry(word);
                nssUseSecmod = true;
            } else if (word.equals(&quot;nssArgs&quot;)) {
                parseNSSArgs(word);
            } else if (word.equals(&quot;nssUseSecmodTrust&quot;)) {
                nssUseSecmodTrust = parseBooleanEntry(word);
            } else if (word.equals(&quot;useEcX963Encoding&quot;)) {
                useEcX963Encoding = parseBooleanEntry(word);
            } else if (word.equals(&quot;nssOptimizeSpace&quot;)) {
                nssOptimizeSpace = parseBooleanEntry(word);
            } else {
                throw new ConfigurationException
                        (&quot;Unknown keyword '&quot; + word + &quot;', line &quot; + st.lineno());
            }
            parsedKeywords.add(word);
        }
        reader.close();
        reader = null;
        st = null;
        parsedKeywords = null;
        if (name == null) {
            throw new ConfigurationException(&quot;name must be specified&quot;);
        }
        if (nssUseSecmod == false) {
            if (library == null) {
                throw new ConfigurationException(&quot;library must be specified&quot;);
            }
        } else {
            if (library != null) {
                throw new ConfigurationException
                    (&quot;library must not be specified in NSS mode&quot;);
            }
            if ((slotID != -1) || (slotListIndex != -1)) {
                throw new ConfigurationException
                    (&quot;slot and slotListIndex must not be specified in NSS mode&quot;);
            }
            if (nssArgs != null) {
                throw new ConfigurationException
                    (&quot;nssArgs must not be specified in NSS mode&quot;);
            }
            if (nssUseSecmodTrust != false) {
                throw new ConfigurationException(&quot;nssUseSecmodTrust is an &quot;
                    + &quot;internal option and must not be specified in NSS mode&quot;);
            }
        }
    }

    //
    // Parsing helper methods
    //

    private int nextToken() throws IOException {
        int token = st.nextToken();
        debug(st);
        return token;
    }

    private void parseEquals() throws IOException {
        int token = nextToken();
        if (token != '=') {
            throw excToken(&quot;Expected '=', read&quot;);
        }
    }

    private void parseOpenBraces() throws IOException {
        while (true) {
            int token = nextToken();
            if (token == TT_EOL) {
                continue;
            }
            if ((token == TT_WORD) &amp;&amp; st.sval.equals(&quot;{&quot;)) {
                return;
            }
            throw excToken(&quot;Expected '{', read&quot;);
        }
    }

    private boolean isCloseBraces(int token) {
        return (token == TT_WORD) &amp;&amp; st.sval.equals(&quot;}&quot;);
    }

    private String parseWord() throws IOException {
        int token = nextToken();
        if (token != TT_WORD) {
            throw excToken(&quot;Unexpected value:&quot;);
        }
        return st.sval;
    }

    private String parseStringEntry(String keyword) throws IOException {
        checkDup(keyword);
        parseEquals();

        int token = nextToken();
        if (token != TT_WORD &amp;&amp; token != '\&quot;') {
            // not a word token nor a string enclosed by double quotes
            throw excToken(&quot;Unexpected value:&quot;);
        }
        String value = st.sval;

        debug(keyword + &quot;: &quot; + value);
        return value;
    }

    private boolean parseBooleanEntry(String keyword) throws IOException {
        checkDup(keyword);
        parseEquals();
        boolean value = parseBoolean();
        debug(keyword + &quot;: &quot; + value);
        return value;
    }

    private int parseIntegerEntry(String keyword) throws IOException {
        checkDup(keyword);
        parseEquals();
        int value = decodeNumber(parseWord());
        debug(keyword + &quot;: &quot; + value);
        return value;
    }

    private boolean parseBoolean() throws IOException {
        String val = parseWord();
        switch (val) {
            case &quot;true&quot;:
                return true;
            case &quot;false&quot;:
                return false;
            default:
                throw excToken(&quot;Expected boolean value, read:&quot;);
        }
    }

    private String parseLine() throws IOException {
        String s = parseWord();
        while (true) {
            int token = nextToken();
            if ((token == TT_EOL) || (token == TT_EOF)) {
                break;
            }
            if (token != TT_WORD) {
                throw excToken(&quot;Unexpected value&quot;);
            }
            s = s + &quot; &quot; + st.sval;
        }
        return s;
    }

    private int decodeNumber(String str) throws IOException {
        try {
            if (str.startsWith(&quot;0x&quot;) || str.startsWith(&quot;0X&quot;)) {
                return Integer.parseInt(str.substring(2), 16);
            } else {
                return Integer.parseInt(str);
            }
        } catch (NumberFormatException e) {
            throw excToken(&quot;Expected number, read&quot;);
        }
    }

    private static boolean isNumber(String s) {
        if (s.length() == 0) {
            return false;
        }
        char ch = s.charAt(0);
        return ((ch &gt;= '0') &amp;&amp; (ch &lt;= '9'));
    }

    private void parseComma() throws IOException {
        int token = nextToken();
        if (token != ',') {
            throw excToken(&quot;Expected ',', read&quot;);
        }
    }

    private static boolean isByteArray(String val) {
        return val.startsWith(&quot;0h&quot;);
    }

    private byte[] decodeByteArray(String str) throws IOException {
        if (str.startsWith(&quot;0h&quot;) == false) {
            throw excToken(&quot;Expected byte array value, read&quot;);
        }
        str = str.substring(2);
        // XXX proper hex parsing
        try {
            return new BigInteger(str, 16).toByteArray();
        } catch (NumberFormatException e) {
            throw excToken(&quot;Expected byte array value, read&quot;);
        }
    }

    private void checkDup(String keyword) throws IOException {
        if (parsedKeywords.contains(keyword)) {
            throw excLine(keyword + &quot; must only be specified once&quot;);
        }
    }

    //
    // individual entry parsing methods
    //

    private String parseLibrary(String keyword) throws IOException {
        String lib = parseStringEntry(keyword);
        lib = expand(lib);
        int i = lib.indexOf(&quot;/$ISA/&quot;);
        if (i != -1) {
            // replace &quot;/$ISA/&quot; with &quot;/sparcv9/&quot; on 64-bit Solaris SPARC
            // and with &quot;/amd64/&quot; on Solaris AMD64.
            // On all other platforms, just turn it into a &quot;/&quot;
            String osName = System.getProperty(&quot;os.name&quot;, &quot;&quot;);
            String osArch = System.getProperty(&quot;os.arch&quot;, &quot;&quot;);
            String prefix = lib.substring(0, i);
            String suffix = lib.substring(i + 5);
            if (osName.equals(&quot;SunOS&quot;) &amp;&amp; osArch.equals(&quot;sparcv9&quot;)) {
                lib = prefix + &quot;/sparcv9&quot; + suffix;
            } else if (osName.equals(&quot;SunOS&quot;) &amp;&amp; osArch.equals(&quot;amd64&quot;)) {
                lib = prefix + &quot;/amd64&quot; + suffix;
            } else {
                lib = prefix + suffix;
            }
        }
        debug(keyword + &quot;: &quot; + lib);

        // Check to see if full path is specified to prevent the DLL
        // preloading attack
        if (!(new File(lib)).isAbsolute()) {
            throw new ConfigurationException(
                &quot;Absolute path required for library value: &quot; + lib);
        }
        return lib;
    }

    private void parseDescription(String keyword) throws IOException {
        checkDup(keyword);
        parseEquals();
        description = parseLine();
        debug(&quot;description: &quot; + description);
    }

    private void parseSlotID(String keyword) throws IOException {
        if (slotID &gt;= 0) {
            throw excLine(&quot;Duplicate slot definition&quot;);
        }
        if (slotListIndex &gt;= 0) {
            throw excLine
                (&quot;Only one of slot and slotListIndex must be specified&quot;);
        }
        parseEquals();
        String slotString = parseWord();
        slotID = decodeNumber(slotString);
        debug(&quot;slot: &quot; + slotID);
    }

    private void parseSlotListIndex(String keyword) throws IOException {
        if (slotListIndex &gt;= 0) {
            throw excLine(&quot;Duplicate slotListIndex definition&quot;);
        }
        if (slotID &gt;= 0) {
            throw excLine
                (&quot;Only one of slot and slotListIndex must be specified&quot;);
        }
        parseEquals();
        String slotString = parseWord();
        slotListIndex = decodeNumber(slotString);
        debug(&quot;slotListIndex: &quot; + slotListIndex);
    }

    private void parseEnabledMechanisms(String keyword) throws IOException {
        enabledMechanisms = parseMechanisms(keyword);
    }

    private void parseDisabledMechanisms(String keyword) throws IOException {
        disabledMechanisms = parseMechanisms(keyword);
    }

    private Set&lt;Long&gt; parseMechanisms(String keyword) throws IOException {
        checkDup(keyword);
        Set&lt;Long&gt; mechs = new HashSet&lt;Long&gt;();
        parseEquals();
        parseOpenBraces();
        while (true) {
            int token = nextToken();
            if (isCloseBraces(token)) {
                break;
            }
            if (token == TT_EOL) {
                continue;
            }
            if (token != TT_WORD) {
                throw excToken(&quot;Expected mechanism, read&quot;);
            }
            long mech = parseMechanism(st.sval);
            mechs.add(Long.valueOf(mech));
        }
        if (DEBUG) {
            System.out.print(&quot;mechanisms: [&quot;);
            for (Long mech : mechs) {
                System.out.print(Functions.getMechanismName(mech));
                System.out.print(&quot;, &quot;);
            }
            System.out.println(&quot;]&quot;);
        }
        return mechs;
    }

    private long parseMechanism(String mech) throws IOException {
        if (isNumber(mech)) {
            return decodeNumber(mech);
        } else {
            try {
                return Functions.getMechanismId(mech);
            } catch (IllegalArgumentException e) {
                throw excLine(&quot;Unknown mechanism: &quot; + mech);
            }
        }
    }

    private void parseAttributes(String keyword) throws IOException {
        if (templateManager == null) {
            templateManager = new TemplateManager();
        }
        int token = nextToken();
        if (token == '=') {
            String s = parseWord();
            if (s.equals(&quot;compatibility&quot;) == false) {
                throw excLine(&quot;Expected 'compatibility', read &quot; + s);
            }
            setCompatibilityAttributes();
            return;
        }
        if (token != '(') {
            throw excToken(&quot;Expected '(' or '=', read&quot;);
        }
        String op = parseOperation();
        parseComma();
        long objectClass = parseObjectClass();
        parseComma();
        long keyAlg = parseKeyAlgorithm();
        token = nextToken();
        if (token != ')') {
            throw excToken(&quot;Expected ')', read&quot;);
        }
        parseEquals();
        parseOpenBraces();
        List&lt;CK_ATTRIBUTE&gt; attributes = new ArrayList&lt;CK_ATTRIBUTE&gt;();
        while (true) {
            token = nextToken();
            if (isCloseBraces(token)) {
                break;
            }
            if (token == TT_EOL) {
                continue;
            }
            if (token != TT_WORD) {
                throw excToken(&quot;Expected mechanism, read&quot;);
            }
            String attributeName = st.sval;
            long attributeId = decodeAttributeName(attributeName);
            parseEquals();
            String attributeValue = parseWord();
            attributes.add(decodeAttributeValue(attributeId, attributeValue));
        }
        templateManager.addTemplate
                (op, objectClass, keyAlg, attributes.toArray(CK_A0));
    }

    private void setCompatibilityAttributes() {
        // all secret keys
        templateManager.addTemplate(O_ANY, CKO_SECRET_KEY, PCKK_ANY,
        new CK_ATTRIBUTE[] {
            TOKEN_FALSE,
            SENSITIVE_FALSE,
            EXTRACTABLE_TRUE,
            ENCRYPT_TRUE,
            DECRYPT_TRUE,
            WRAP_TRUE,
            UNWRAP_TRUE,
        });

        // generic secret keys are special
        // They are used as MAC keys plus for the SSL/TLS (pre)master secrets
        templateManager.addTemplate(O_ANY, CKO_SECRET_KEY, CKK_GENERIC_SECRET,
        new CK_ATTRIBUTE[] {
            SIGN_TRUE,
            VERIFY_TRUE,
            ENCRYPT_NULL,
            DECRYPT_NULL,
            WRAP_NULL,
            UNWRAP_NULL,
            DERIVE_TRUE,
        });

        // all private and public keys
        templateManager.addTemplate(O_ANY, CKO_PRIVATE_KEY, PCKK_ANY,
        new CK_ATTRIBUTE[] {
            TOKEN_FALSE,
            SENSITIVE_FALSE,
            EXTRACTABLE_TRUE,
        });
        templateManager.addTemplate(O_ANY, CKO_PUBLIC_KEY, PCKK_ANY,
        new CK_ATTRIBUTE[] {
            TOKEN_FALSE,
        });

        // additional attributes for RSA private keys
        templateManager.addTemplate(O_ANY, CKO_PRIVATE_KEY, CKK_RSA,
        new CK_ATTRIBUTE[] {
            DECRYPT_TRUE,
            SIGN_TRUE,
            SIGN_RECOVER_TRUE,
            UNWRAP_TRUE,
        });
        // additional attributes for RSA public keys
        templateManager.addTemplate(O_ANY, CKO_PUBLIC_KEY, CKK_RSA,
        new CK_ATTRIBUTE[] {
            ENCRYPT_TRUE,
            VERIFY_TRUE,
            VERIFY_RECOVER_TRUE,
            WRAP_TRUE,
        });

        // additional attributes for DSA private keys
        templateManager.addTemplate(O_ANY, CKO_PRIVATE_KEY, CKK_DSA,
        new CK_ATTRIBUTE[] {
            SIGN_TRUE,
        });
        // additional attributes for DSA public keys
        templateManager.addTemplate(O_ANY, CKO_PUBLIC_KEY, CKK_DSA,
        new CK_ATTRIBUTE[] {
            VERIFY_TRUE,
        });

        // additional attributes for DH private keys
        templateManager.addTemplate(O_ANY, CKO_PRIVATE_KEY, CKK_DH,
        new CK_ATTRIBUTE[] {
            DERIVE_TRUE,
        });

        // additional attributes for EC private keys
        templateManager.addTemplate(O_ANY, CKO_PRIVATE_KEY, CKK_EC,
        new CK_ATTRIBUTE[] {
            SIGN_TRUE,
            DERIVE_TRUE,
        });
        // additional attributes for EC public keys
        templateManager.addTemplate(O_ANY, CKO_PUBLIC_KEY, CKK_EC,
        new CK_ATTRIBUTE[] {
            VERIFY_TRUE,
        });
    }

    private final static CK_ATTRIBUTE[] CK_A0 = new CK_ATTRIBUTE[0];

    private String parseOperation() throws IOException {
        String op = parseWord();
        switch (op) {
            case &quot;*&quot;:
                return TemplateManager.O_ANY;
            case &quot;generate&quot;:
                return TemplateManager.O_GENERATE;
            case &quot;import&quot;:
                return TemplateManager.O_IMPORT;
            default:
                throw excLine(&quot;Unknown operation &quot; + op);
        }
    }

    private long parseObjectClass() throws IOException {
        String name = parseWord();
        try {
            return Functions.getObjectClassId(name);
        } catch (IllegalArgumentException e) {
            throw excLine(&quot;Unknown object class &quot; + name);
        }
    }

    private long parseKeyAlgorithm() throws IOException {
        String name = parseWord();
        if (isNumber(name)) {
            return decodeNumber(name);
        } else {
            try {
                return Functions.getKeyId(name);
            } catch (IllegalArgumentException e) {
                throw excLine(&quot;Unknown key algorithm &quot; + name);
            }
        }
    }

    private long decodeAttributeName(String name) throws IOException {
        if (isNumber(name)) {
            return decodeNumber(name);
        } else {
            try {
                return Functions.getAttributeId(name);
            } catch (IllegalArgumentException e) {
                throw excLine(&quot;Unknown attribute name &quot; + name);
            }
        }
    }

    private CK_ATTRIBUTE decodeAttributeValue(long id, String value)
            throws IOException {
        if (value.equals(&quot;null&quot;)) {
            return new CK_ATTRIBUTE(id);
        } else if (value.equals(&quot;true&quot;)) {
            return new CK_ATTRIBUTE(id, true);
        } else if (value.equals(&quot;false&quot;)) {
            return new CK_ATTRIBUTE(id, false);
        } else if (isByteArray(value)) {
            return new CK_ATTRIBUTE(id, decodeByteArray(value));
        } else if (isNumber(value)) {
            return new CK_ATTRIBUTE(id, Integer.valueOf(decodeNumber(value)));
        } else {
            throw excLine(&quot;Unknown attribute value &quot; + value);
        }
    }

    private void parseNSSArgs(String keyword) throws IOException {
        checkDup(keyword);
        parseEquals();
        int token = nextToken();
        if (token != '&quot;') {
            throw excToken(&quot;Expected quoted string&quot;);
        }
        nssArgs = expand(st.sval);
        debug(&quot;nssArgs: &quot; + nssArgs);
    }

    private void parseHandleStartupErrors(String keyword) throws IOException {
        checkDup(keyword);
        parseEquals();
        String val = parseWord();
        if (val.equals(&quot;ignoreAll&quot;)) {
            handleStartupErrors = ERR_IGNORE_ALL;
        } else if (val.equals(&quot;ignoreMissingLibrary&quot;)) {
            handleStartupErrors = ERR_IGNORE_LIB;
        } else if (val.equals(&quot;halt&quot;)) {
            handleStartupErrors = ERR_HALT;
        } else {
            throw excToken(&quot;Invalid value for handleStartupErrors:&quot;);
        }
        debug(&quot;handleStartupErrors: &quot; + handleStartupErrors);
    }

}

class ConfigurationException extends IOException {
    private static final long serialVersionUID = 254492758807673194L;
    ConfigurationException(String msg) {
        super(msg);
    }
}
</pre>
</body>
</html>
