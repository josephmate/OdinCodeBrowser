<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.pkcs11;

import java.io.*;
import java.util.*;

import java.security.*;
import java.security.interfaces.*;

import javax.crypto.interfaces.*;

import javax.security.auth.Subject;
import javax.security.auth.login.LoginException;
import javax.security.auth.login.FailedLoginException;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.ConfirmationCallback;
import javax.security.auth.callback.PasswordCallback;
import javax.security.auth.callback.TextOutputCallback;

import sun.security.util.Debug;
import sun.security.util.ResourcesMgr;

import sun.security.pkcs11.Secmod.*;

import sun.security.pkcs11.wrapper.*;
import static sun.security.pkcs11.wrapper.PKCS11Constants.*;

/**
 * PKCS#11 provider main class.
 *
 * @author  Andreas Sterbenz
 * @since   1.5
 */
public final class SunPKCS11 extends AuthProvider {

    private static final long serialVersionUID = -1354835039035306505L;

    static final Debug debug = Debug.getInstance(&quot;sunpkcs11&quot;);

    private static int dummyConfigId;

    // the PKCS11 object through which we make the native calls
    final PKCS11 p11;

    // name of the configuration file
    private final String configName;

    // configuration information
    final Config config;

    // id of the PKCS#11 slot we are using
    final long slotID;

    private CallbackHandler pHandler;
    private final Object LOCK_HANDLER = new Object();

    final boolean removable;

    final Module nssModule;

    final boolean nssUseSecmodTrust;

    private volatile Token token;

    private TokenPoller poller;

    Token getToken() {
        return token;
    }

    public SunPKCS11() {
        super(&quot;SunPKCS11-Dummy&quot;, 1.8d, &quot;SunPKCS11-Dummy&quot;);
        throw new ProviderException
            (&quot;SunPKCS11 requires configuration file argument&quot;);
    }

    public SunPKCS11(String configName) {
        this(checkNull(configName), null);
    }

    public SunPKCS11(InputStream configStream) {
        this(getDummyConfigName(), checkNull(configStream));
    }

    private static &lt;T&gt; T checkNull(T obj) {
        if (obj == null) {
            throw new NullPointerException();
        }
        return obj;
    }

    private static synchronized String getDummyConfigName() {
        int id = ++dummyConfigId;
        return &quot;---DummyConfig-&quot; + id + &quot;---&quot;;
    }

    /**
     * @deprecated use new SunPKCS11(String) or new SunPKCS11(InputStream)
     *         instead
     */
    @Deprecated
    public SunPKCS11(String configName, InputStream configStream) {
        super(&quot;SunPKCS11-&quot; +
            Config.getConfig(configName, configStream).getName(),
            1.8d, Config.getConfig(configName, configStream).getDescription());
        this.configName = configName;
        this.config = Config.removeConfig(configName);

        if (debug != null) {
            System.out.println(&quot;SunPKCS11 loading &quot; + configName);
        }

        String library = config.getLibrary();
        String functionList = config.getFunctionList();
        long slotID = config.getSlotID();
        int slotListIndex = config.getSlotListIndex();

        boolean useSecmod = config.getNssUseSecmod();
        boolean nssUseSecmodTrust = config.getNssUseSecmodTrust();
        Module nssModule = null;

        //
        // Initialization via Secmod. The way this works is as follows:
        // SunPKCS11 is either in normal mode or in NSS Secmod mode.
        // Secmod is activated by specifying one or more of the following
        // options in the config file:
        // nssUseSecmod, nssSecmodDirectory, nssLibrary, nssModule
        //
        // XXX add more explanation here
        //
        // If we are in Secmod mode and configured to use either the
        // nssKeyStore or the nssTrustAnchors module, we automatically
        // switch to using the NSS trust attributes for trusted certs
        // (KeyStore).
        //

        if (useSecmod) {
            // note: Config ensures library/slot/slotListIndex not specified
            // in secmod mode.
            Secmod secmod = Secmod.getInstance();
            DbMode nssDbMode = config.getNssDbMode();
            try {
                String nssLibraryDirectory = config.getNssLibraryDirectory();
                String nssSecmodDirectory = config.getNssSecmodDirectory();
                boolean nssOptimizeSpace = config.getNssOptimizeSpace();

                if (secmod.isInitialized()) {
                    if (nssSecmodDirectory != null) {
                        String s = secmod.getConfigDir();
                        if ((s != null) &amp;&amp;
                                (s.equals(nssSecmodDirectory) == false)) {
                            throw new ProviderException(&quot;Secmod directory &quot;
                                + nssSecmodDirectory
                                + &quot; invalid, NSS already initialized with &quot;
                                + s);
                        }
                    }
                    if (nssLibraryDirectory != null) {
                        String s = secmod.getLibDir();
                        if ((s != null) &amp;&amp;
                                (s.equals(nssLibraryDirectory) == false)) {
                            throw new ProviderException(&quot;NSS library directory &quot;
                                + nssLibraryDirectory
                                + &quot; invalid, NSS already initialized with &quot;
                                + s);
                        }
                    }
                } else {
                    if (nssDbMode != DbMode.NO_DB) {
                        if (nssSecmodDirectory == null) {
                            throw new ProviderException(
                                &quot;Secmod not initialized and &quot;
                                 + &quot;nssSecmodDirectory not specified&quot;);
                        }
                    } else {
                        if (nssSecmodDirectory != null) {
                            throw new ProviderException(
                                &quot;nssSecmodDirectory must not be &quot;
                                + &quot;specified in noDb mode&quot;);
                        }
                    }
                    secmod.initialize(nssDbMode, nssSecmodDirectory,
                        nssLibraryDirectory, nssOptimizeSpace);
                }
            } catch (IOException e) {
                // XXX which exception to throw
                throw new ProviderException(&quot;Could not initialize NSS&quot;, e);
            }
            List&lt;Module&gt; modules = secmod.getModules();
            if (config.getShowInfo()) {
                System.out.println(&quot;NSS modules: &quot; + modules);
            }

            String moduleName = config.getNssModule();
            if (moduleName == null) {
                nssModule = secmod.getModule(ModuleType.FIPS);
                if (nssModule != null) {
                    moduleName = &quot;fips&quot;;
                } else {
                    moduleName = (nssDbMode == DbMode.NO_DB) ?
                        &quot;crypto&quot; : &quot;keystore&quot;;
                }
            }
            if (moduleName.equals(&quot;fips&quot;)) {
                nssModule = secmod.getModule(ModuleType.FIPS);
                nssUseSecmodTrust = true;
                functionList = &quot;FC_GetFunctionList&quot;;
            } else if (moduleName.equals(&quot;keystore&quot;)) {
                nssModule = secmod.getModule(ModuleType.KEYSTORE);
                nssUseSecmodTrust = true;
            } else if (moduleName.equals(&quot;crypto&quot;)) {
                nssModule = secmod.getModule(ModuleType.CRYPTO);
            } else if (moduleName.equals(&quot;trustanchors&quot;)) {
                // XXX should the option be called trustanchor or trustanchors??
                nssModule = secmod.getModule(ModuleType.TRUSTANCHOR);
                nssUseSecmodTrust = true;
            } else if (moduleName.startsWith(&quot;external-&quot;)) {
                int moduleIndex;
                try {
                    moduleIndex = Integer.parseInt
                            (moduleName.substring(&quot;external-&quot;.length()));
                } catch (NumberFormatException e) {
                    moduleIndex = -1;
                }
                if (moduleIndex &lt; 1) {
                    throw new ProviderException
                            (&quot;Invalid external module: &quot; + moduleName);
                }
                int k = 0;
                for (Module module : modules) {
                    if (module.getType() == ModuleType.EXTERNAL) {
                        if (++k == moduleIndex) {
                            nssModule = module;
                            break;
                        }
                    }
                }
                if (nssModule == null) {
                    throw new ProviderException(&quot;Invalid module &quot; + moduleName
                        + &quot;: only &quot; + k + &quot; external NSS modules available&quot;);
                }
            } else {
                throw new ProviderException(
                    &quot;Unknown NSS module: &quot; + moduleName);
            }
            if (nssModule == null) {
                throw new ProviderException(
                    &quot;NSS module not available: &quot; + moduleName);
            }
            if (nssModule.hasInitializedProvider()) {
                throw new ProviderException(&quot;Secmod module already configured&quot;);
            }
            library = nssModule.libraryName;
            slotListIndex = nssModule.slot;
        }
        this.nssUseSecmodTrust = nssUseSecmodTrust;
        this.nssModule = nssModule;

        File libraryFile = new File(library);
        // if the filename is a simple filename without path
        // (e.g. &quot;libpkcs11.so&quot;), it may refer to a library somewhere on the
        // OS library search path. Omit the test for file existance as that
        // only looks in the current directory.
        if (libraryFile.getName().equals(library) == false) {
            if (new File(library).isFile() == false) {
                String msg = &quot;Library &quot; + library + &quot; does not exist&quot;;
                if (config.getHandleStartupErrors() == Config.ERR_HALT) {
                    throw new ProviderException(msg);
                } else {
                    throw new UnsupportedOperationException(msg);
                }
            }
        }

        try {
            if (debug != null) {
                debug.println(&quot;Initializing PKCS#11 library &quot; + library);
            }
            CK_C_INITIALIZE_ARGS initArgs = new CK_C_INITIALIZE_ARGS();
            String nssArgs = config.getNssArgs();
            if (nssArgs != null) {
                initArgs.pReserved = nssArgs;
            }
            // request multithreaded access first
            initArgs.flags = CKF_OS_LOCKING_OK;
            PKCS11 tmpPKCS11;
            try {
                tmpPKCS11 = PKCS11.getInstance(
                    library, functionList, initArgs,
                    config.getOmitInitialize());
            } catch (PKCS11Exception e) {
                if (debug != null) {
                    debug.println(&quot;Multi-threaded initialization failed: &quot; + e);
                }
                if (config.getAllowSingleThreadedModules() == false) {
                    throw e;
                }
                // fall back to single threaded access
                if (nssArgs == null) {
                    // if possible, use null initArgs for better compatibility
                    initArgs = null;
                } else {
                    initArgs.flags = 0;
                }
                tmpPKCS11 = PKCS11.getInstance(library,
                    functionList, initArgs, config.getOmitInitialize());
            }
            p11 = tmpPKCS11;

            CK_INFO p11Info = p11.C_GetInfo();
            if (p11Info.cryptokiVersion.major &lt; 2) {
                throw new ProviderException(&quot;Only PKCS#11 v2.0 and later &quot;
                + &quot;supported, library version is v&quot; + p11Info.cryptokiVersion);
            }
            boolean showInfo = config.getShowInfo();
            if (showInfo) {
                System.out.println(&quot;Information for provider &quot; + getName());
                System.out.println(&quot;Library info:&quot;);
                System.out.println(p11Info);
            }

            if ((slotID &lt; 0) || showInfo) {
                long[] slots = p11.C_GetSlotList(false);
                if (showInfo) {
                    System.out.println(&quot;All slots: &quot; + toString(slots));
                    slots = p11.C_GetSlotList(true);
                    System.out.println(&quot;Slots with tokens: &quot; + toString(slots));
                }
                if (slotID &lt; 0) {
                    if ((slotListIndex &lt; 0)
                            || (slotListIndex &gt;= slots.length)) {
                        throw new ProviderException(&quot;slotListIndex is &quot;
                            + slotListIndex
                            + &quot; but token only has &quot; + slots.length + &quot; slots&quot;);
                    }
                    slotID = slots[slotListIndex];
                }
            }
            this.slotID = slotID;
            CK_SLOT_INFO slotInfo = p11.C_GetSlotInfo(slotID);
            removable = (slotInfo.flags &amp; CKF_REMOVABLE_DEVICE) != 0;
            initToken(slotInfo);
            if (nssModule != null) {
                nssModule.setProvider(this);
            }
        } catch (Exception e) {
            if (config.getHandleStartupErrors() == Config.ERR_IGNORE_ALL) {
                throw new UnsupportedOperationException
                        (&quot;Initialization failed&quot;, e);
            } else {
                throw new ProviderException
                        (&quot;Initialization failed&quot;, e);
            }
        }
    }

    private static String toString(long[] longs) {
        if (longs.length == 0) {
            return &quot;(none)&quot;;
        }
        StringBuilder sb = new StringBuilder();
        sb.append(longs[0]);
        for (int i = 1; i &lt; longs.length; i++) {
            sb.append(&quot;, &quot;);
            sb.append(longs[i]);
        }
        return sb.toString();
    }

    public boolean equals(Object obj) {
        return this == obj;
    }

    public int hashCode() {
        return System.identityHashCode(this);
    }

    private static String[] s(String ...aliases) {
        return aliases;
    }

    private static final class Descriptor {
        final String type;
        final String algorithm;
        final String className;
        final String[] aliases;
        final int[] mechanisms;

        private Descriptor(String type, String algorithm, String className,
                String[] aliases, int[] mechanisms) {
            this.type = type;
            this.algorithm = algorithm;
            this.className = className;
            this.aliases = aliases;
            this.mechanisms = mechanisms;
        }
        private P11Service service(Token token, int mechanism) {
            return new P11Service
                (token, type, algorithm, className, aliases, mechanism);
        }
        public String toString() {
            return type + &quot;.&quot; + algorithm;
        }
    }

    // Map from mechanism to List of Descriptors that should be
    // registered if the mechanism is supported
    private final static Map&lt;Integer,List&lt;Descriptor&gt;&gt; descriptors =
        new HashMap&lt;Integer,List&lt;Descriptor&gt;&gt;();

    private static int[] m(long m1) {
        return new int[] {(int)m1};
    }

    private static int[] m(long m1, long m2) {
        return new int[] {(int)m1, (int)m2};
    }

    private static int[] m(long m1, long m2, long m3) {
        return new int[] {(int)m1, (int)m2, (int)m3};
    }

    private static int[] m(long m1, long m2, long m3, long m4) {
        return new int[] {(int)m1, (int)m2, (int)m3, (int)m4};
    }

    private static void d(String type, String algorithm, String className,
            int[] m) {
        register(new Descriptor(type, algorithm, className, null, m));
    }

    private static void d(String type, String algorithm, String className,
            String[] aliases, int[] m) {
        register(new Descriptor(type, algorithm, className, aliases, m));
    }

    private static void register(Descriptor d) {
        for (int i = 0; i &lt; d.mechanisms.length; i++) {
            int m = d.mechanisms[i];
            Integer key = Integer.valueOf(m);
            List&lt;Descriptor&gt; list = descriptors.get(key);
            if (list == null) {
                list = new ArrayList&lt;Descriptor&gt;();
                descriptors.put(key, list);
            }
            list.add(d);
        }
    }

    private final static String MD  = &quot;MessageDigest&quot;;

    private final static String SIG = &quot;Signature&quot;;

    private final static String KPG = &quot;KeyPairGenerator&quot;;

    private final static String KG  = &quot;KeyGenerator&quot;;

    private final static String AGP = &quot;AlgorithmParameters&quot;;

    private final static String KF  = &quot;KeyFactory&quot;;

    private final static String SKF = &quot;SecretKeyFactory&quot;;

    private final static String CIP = &quot;Cipher&quot;;

    private final static String MAC = &quot;Mac&quot;;

    private final static String KA  = &quot;KeyAgreement&quot;;

    private final static String KS  = &quot;KeyStore&quot;;

    private final static String SR  = &quot;SecureRandom&quot;;

    static {
        // names of all the implementation classes
        // use local variables, only used here
        String P11Digest           = &quot;sun.security.pkcs11.P11Digest&quot;;
        String P11MAC              = &quot;sun.security.pkcs11.P11MAC&quot;;
        String P11KeyPairGenerator = &quot;sun.security.pkcs11.P11KeyPairGenerator&quot;;
        String P11KeyGenerator     = &quot;sun.security.pkcs11.P11KeyGenerator&quot;;
        String P11RSAKeyFactory    = &quot;sun.security.pkcs11.P11RSAKeyFactory&quot;;
        String P11DSAKeyFactory    = &quot;sun.security.pkcs11.P11DSAKeyFactory&quot;;
        String P11DHKeyFactory     = &quot;sun.security.pkcs11.P11DHKeyFactory&quot;;
        String P11KeyAgreement     = &quot;sun.security.pkcs11.P11KeyAgreement&quot;;
        String P11SecretKeyFactory = &quot;sun.security.pkcs11.P11SecretKeyFactory&quot;;
        String P11Cipher           = &quot;sun.security.pkcs11.P11Cipher&quot;;
        String P11RSACipher        = &quot;sun.security.pkcs11.P11RSACipher&quot;;
        String P11Signature        = &quot;sun.security.pkcs11.P11Signature&quot;;

        // XXX register all aliases

        d(MD, &quot;MD2&quot;,            P11Digest,
                m(CKM_MD2));
        d(MD, &quot;MD5&quot;,            P11Digest,
                m(CKM_MD5));
        d(MD, &quot;SHA1&quot;,           P11Digest,
                s(&quot;SHA&quot;, &quot;SHA-1&quot;, &quot;1.3.14.3.2.26&quot;, &quot;OID.1.3.14.3.2.26&quot;),
                m(CKM_SHA_1));

        d(MD, &quot;SHA-224&quot;,        P11Digest,
                s(&quot;2.16.840.1.101.3.4.2.4&quot;, &quot;OID.2.16.840.1.101.3.4.2.4&quot;),
                m(CKM_SHA224));
        d(MD, &quot;SHA-256&quot;,        P11Digest,
                s(&quot;2.16.840.1.101.3.4.2.1&quot;, &quot;OID.2.16.840.1.101.3.4.2.1&quot;),
                m(CKM_SHA256));
        d(MD, &quot;SHA-384&quot;,        P11Digest,
                s(&quot;2.16.840.1.101.3.4.2.2&quot;, &quot;OID.2.16.840.1.101.3.4.2.2&quot;),
                m(CKM_SHA384));
        d(MD, &quot;SHA-512&quot;,        P11Digest,
                s(&quot;2.16.840.1.101.3.4.2.3&quot;, &quot;OID.2.16.840.1.101.3.4.2.3&quot;),
                m(CKM_SHA512));

        d(MAC, &quot;HmacMD5&quot;,       P11MAC,
                m(CKM_MD5_HMAC));
        d(MAC, &quot;HmacSHA1&quot;,      P11MAC,
                s(&quot;1.2.840.113549.2.7&quot;, &quot;OID.1.2.840.113549.2.7&quot;),
                m(CKM_SHA_1_HMAC));
        d(MAC, &quot;HmacSHA224&quot;,    P11MAC,
                s(&quot;1.2.840.113549.2.8&quot;, &quot;OID.1.2.840.113549.2.8&quot;),
                m(CKM_SHA224_HMAC));
        d(MAC, &quot;HmacSHA256&quot;,    P11MAC,
                s(&quot;1.2.840.113549.2.9&quot;, &quot;OID.1.2.840.113549.2.9&quot;),
                m(CKM_SHA256_HMAC));
        d(MAC, &quot;HmacSHA384&quot;,    P11MAC,
                s(&quot;1.2.840.113549.2.10&quot;, &quot;OID.1.2.840.113549.2.10&quot;),
                m(CKM_SHA384_HMAC));
        d(MAC, &quot;HmacSHA512&quot;,    P11MAC,
                s(&quot;1.2.840.113549.2.11&quot;, &quot;OID.1.2.840.113549.2.11&quot;),
                m(CKM_SHA512_HMAC));
        d(MAC, &quot;SslMacMD5&quot;,     P11MAC,
                m(CKM_SSL3_MD5_MAC));
        d(MAC, &quot;SslMacSHA1&quot;,    P11MAC,
                m(CKM_SSL3_SHA1_MAC));

        d(KPG, &quot;RSA&quot;,           P11KeyPairGenerator,
                m(CKM_RSA_PKCS_KEY_PAIR_GEN));
        d(KPG, &quot;DSA&quot;,           P11KeyPairGenerator,
                s(&quot;1.3.14.3.2.12&quot;, &quot;1.2.840.10040.4.1&quot;, &quot;OID.1.2.840.10040.4.1&quot;),
                m(CKM_DSA_KEY_PAIR_GEN));
        d(KPG, &quot;DH&quot;,            P11KeyPairGenerator,    s(&quot;DiffieHellman&quot;),
                m(CKM_DH_PKCS_KEY_PAIR_GEN));
        d(KPG, &quot;EC&quot;,            P11KeyPairGenerator,
                m(CKM_EC_KEY_PAIR_GEN));

        d(KG,  &quot;ARCFOUR&quot;,       P11KeyGenerator,        s(&quot;RC4&quot;),
                m(CKM_RC4_KEY_GEN));
        d(KG,  &quot;DES&quot;,           P11KeyGenerator,
                m(CKM_DES_KEY_GEN));
        d(KG,  &quot;DESede&quot;,        P11KeyGenerator,
                m(CKM_DES3_KEY_GEN, CKM_DES2_KEY_GEN));
        d(KG,  &quot;AES&quot;,           P11KeyGenerator,
                m(CKM_AES_KEY_GEN));
        d(KG,  &quot;Blowfish&quot;,      P11KeyGenerator,
                m(CKM_BLOWFISH_KEY_GEN));

        // register (Secret)KeyFactories if there are any mechanisms
        // for a particular algorithm that we support
        d(KF, &quot;RSA&quot;,            P11RSAKeyFactory,
                m(CKM_RSA_PKCS_KEY_PAIR_GEN, CKM_RSA_PKCS, CKM_RSA_X_509));
        d(KF, &quot;DSA&quot;,            P11DSAKeyFactory,
                s(&quot;1.3.14.3.2.12&quot;, &quot;1.2.840.10040.4.1&quot;, &quot;OID.1.2.840.10040.4.1&quot;),
                m(CKM_DSA_KEY_PAIR_GEN, CKM_DSA, CKM_DSA_SHA1));
        d(KF, &quot;DH&quot;,             P11DHKeyFactory,        s(&quot;DiffieHellman&quot;),
                m(CKM_DH_PKCS_KEY_PAIR_GEN, CKM_DH_PKCS_DERIVE));
        d(KF, &quot;EC&quot;,             P11DHKeyFactory,
                m(CKM_EC_KEY_PAIR_GEN, CKM_ECDH1_DERIVE,
                    CKM_ECDSA, CKM_ECDSA_SHA1));

        // AlgorithmParameters for EC.
        // Only needed until we have an EC implementation in the SUN provider.
        d(AGP, &quot;EC&quot;,            &quot;sun.security.ec.ECParameters&quot;,
                                                s(&quot;1.2.840.10045.2.1&quot;),
                m(CKM_EC_KEY_PAIR_GEN, CKM_ECDH1_DERIVE,
                    CKM_ECDSA, CKM_ECDSA_SHA1));

        d(KA, &quot;DH&quot;,             P11KeyAgreement,        s(&quot;DiffieHellman&quot;),
                m(CKM_DH_PKCS_DERIVE));
        d(KA, &quot;ECDH&quot;,           &quot;sun.security.pkcs11.P11ECDHKeyAgreement&quot;,
                m(CKM_ECDH1_DERIVE));

        d(SKF, &quot;ARCFOUR&quot;,       P11SecretKeyFactory,    s(&quot;RC4&quot;),
                m(CKM_RC4));
        d(SKF, &quot;DES&quot;,           P11SecretKeyFactory,
                m(CKM_DES_CBC));
        d(SKF, &quot;DESede&quot;,        P11SecretKeyFactory,
                m(CKM_DES3_CBC));
        d(SKF, &quot;AES&quot;,           P11SecretKeyFactory,
                s(&quot;2.16.840.1.101.3.4.1&quot;, &quot;OID.2.16.840.1.101.3.4.1&quot;),
                m(CKM_AES_CBC));
        d(SKF, &quot;Blowfish&quot;,      P11SecretKeyFactory,
                m(CKM_BLOWFISH_CBC));

        // XXX attributes for Ciphers (supported modes, padding)
        d(CIP, &quot;ARCFOUR&quot;,                       P11Cipher,      s(&quot;RC4&quot;),
                m(CKM_RC4));
        d(CIP, &quot;DES/CBC/NoPadding&quot;,             P11Cipher,
                m(CKM_DES_CBC));
        d(CIP, &quot;DES/CBC/PKCS5Padding&quot;,          P11Cipher,
                m(CKM_DES_CBC_PAD, CKM_DES_CBC));
        d(CIP, &quot;DES/ECB/NoPadding&quot;,             P11Cipher,
                m(CKM_DES_ECB));
        d(CIP, &quot;DES/ECB/PKCS5Padding&quot;,          P11Cipher,      s(&quot;DES&quot;),
                m(CKM_DES_ECB));

        d(CIP, &quot;DESede/CBC/NoPadding&quot;,          P11Cipher,
                m(CKM_DES3_CBC));
        d(CIP, &quot;DESede/CBC/PKCS5Padding&quot;,       P11Cipher,
                m(CKM_DES3_CBC_PAD, CKM_DES3_CBC));
        d(CIP, &quot;DESede/ECB/NoPadding&quot;,          P11Cipher,
                m(CKM_DES3_ECB));
        d(CIP, &quot;DESede/ECB/PKCS5Padding&quot;,       P11Cipher,      s(&quot;DESede&quot;),
                m(CKM_DES3_ECB));
        d(CIP, &quot;AES/CBC/NoPadding&quot;,             P11Cipher,
                m(CKM_AES_CBC));
        d(CIP, &quot;AES_128/CBC/NoPadding&quot;,          P11Cipher,
                s(&quot;2.16.840.1.101.3.4.1.2&quot;, &quot;OID.2.16.840.1.101.3.4.1.2&quot;),
                m(CKM_AES_CBC));
        d(CIP, &quot;AES_192/CBC/NoPadding&quot;,          P11Cipher,
                s(&quot;2.16.840.1.101.3.4.1.22&quot;, &quot;OID.2.16.840.1.101.3.4.1.22&quot;),
                m(CKM_AES_CBC));
        d(CIP, &quot;AES_256/CBC/NoPadding&quot;,          P11Cipher,
                s(&quot;2.16.840.1.101.3.4.1.42&quot;, &quot;OID.2.16.840.1.101.3.4.1.42&quot;),
                m(CKM_AES_CBC));
        d(CIP, &quot;AES/CBC/PKCS5Padding&quot;,          P11Cipher,
                m(CKM_AES_CBC_PAD, CKM_AES_CBC));
        d(CIP, &quot;AES/ECB/NoPadding&quot;,             P11Cipher,
                m(CKM_AES_ECB));
        d(CIP, &quot;AES_128/ECB/NoPadding&quot;,          P11Cipher,
                s(&quot;2.16.840.1.101.3.4.1.1&quot;, &quot;OID.2.16.840.1.101.3.4.1.1&quot;),
                m(CKM_AES_ECB));
        d(CIP, &quot;AES_192/ECB/NoPadding&quot;,          P11Cipher,
                s(&quot;2.16.840.1.101.3.4.1.21&quot;, &quot;OID.2.16.840.1.101.3.4.1.21&quot;),
                m(CKM_AES_ECB));
        d(CIP, &quot;AES_256/ECB/NoPadding&quot;,          P11Cipher,
                s(&quot;2.16.840.1.101.3.4.1.41&quot;, &quot;OID.2.16.840.1.101.3.4.1.41&quot;),
                m(CKM_AES_ECB));
        d(CIP, &quot;AES/ECB/PKCS5Padding&quot;,          P11Cipher,      s(&quot;AES&quot;),
                m(CKM_AES_ECB));
        d(CIP, &quot;AES/CTR/NoPadding&quot;,             P11Cipher,
                m(CKM_AES_CTR));
        d(CIP, &quot;Blowfish/CBC/NoPadding&quot;,        P11Cipher,
                m(CKM_BLOWFISH_CBC));
        d(CIP, &quot;Blowfish/CBC/PKCS5Padding&quot;,     P11Cipher,
                m(CKM_BLOWFISH_CBC));

        // XXX RSA_X_509, RSA_OAEP not yet supported
        d(CIP, &quot;RSA/ECB/PKCS1Padding&quot;,          P11RSACipher,   s(&quot;RSA&quot;),
                m(CKM_RSA_PKCS));
        d(CIP, &quot;RSA/ECB/NoPadding&quot;,             P11RSACipher,
                m(CKM_RSA_X_509));

        d(SIG, &quot;RawDSA&quot;,        P11Signature,   s(&quot;NONEwithDSA&quot;),
                m(CKM_DSA));
        d(SIG, &quot;DSA&quot;,           P11Signature,
                s(&quot;SHA1withDSA&quot;, &quot;1.3.14.3.2.13&quot;, &quot;1.3.14.3.2.27&quot;,
                  &quot;1.2.840.10040.4.3&quot;, &quot;OID.1.2.840.10040.4.3&quot;),
                m(CKM_DSA_SHA1, CKM_DSA));
        d(SIG, &quot;NONEwithECDSA&quot;, P11Signature,
                m(CKM_ECDSA));
        d(SIG, &quot;SHA1withECDSA&quot;, P11Signature,
                s(&quot;ECDSA&quot;, &quot;1.2.840.10045.4.1&quot;, &quot;OID.1.2.840.10045.4.1&quot;),
                m(CKM_ECDSA_SHA1, CKM_ECDSA));
        d(SIG, &quot;SHA224withECDSA&quot;,       P11Signature,
                s(&quot;1.2.840.10045.4.3.1&quot;, &quot;OID.1.2.840.10045.4.3.1&quot;),
                m(CKM_ECDSA));
        d(SIG, &quot;SHA256withECDSA&quot;,       P11Signature,
                s(&quot;1.2.840.10045.4.3.2&quot;, &quot;OID.1.2.840.10045.4.3.2&quot;),
                m(CKM_ECDSA));
        d(SIG, &quot;SHA384withECDSA&quot;,       P11Signature,
                s(&quot;1.2.840.10045.4.3.3&quot;, &quot;OID.1.2.840.10045.4.3.3&quot;),
                m(CKM_ECDSA));
        d(SIG, &quot;SHA512withECDSA&quot;,       P11Signature,
                s(&quot;1.2.840.10045.4.3.4&quot;, &quot;OID.1.2.840.10045.4.3.4&quot;),
                m(CKM_ECDSA));
        d(SIG, &quot;MD2withRSA&quot;,    P11Signature,
                s(&quot;1.2.840.113549.1.1.2&quot;, &quot;OID.1.2.840.113549.1.1.2&quot;),
                m(CKM_MD2_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
        d(SIG, &quot;MD5withRSA&quot;,    P11Signature,
                s(&quot;1.2.840.113549.1.1.4&quot;, &quot;OID.1.2.840.113549.1.1.4&quot;),
                m(CKM_MD5_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
        d(SIG, &quot;SHA1withRSA&quot;,   P11Signature,
                s(&quot;1.2.840.113549.1.1.5&quot;, &quot;OID.1.2.840.113549.1.1.5&quot;,
                  &quot;1.3.14.3.2.29&quot;),
                m(CKM_SHA1_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
        d(SIG, &quot;SHA224withRSA&quot;, P11Signature,
                s(&quot;1.2.840.113549.1.1.14&quot;, &quot;OID.1.2.840.113549.1.1.14&quot;),
                m(CKM_SHA224_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
        d(SIG, &quot;SHA256withRSA&quot;, P11Signature,
                s(&quot;1.2.840.113549.1.1.11&quot;, &quot;OID.1.2.840.113549.1.1.11&quot;),
                m(CKM_SHA256_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
        d(SIG, &quot;SHA384withRSA&quot;, P11Signature,
                s(&quot;1.2.840.113549.1.1.12&quot;, &quot;OID.1.2.840.113549.1.1.12&quot;),
                m(CKM_SHA384_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
        d(SIG, &quot;SHA512withRSA&quot;, P11Signature,
                s(&quot;1.2.840.113549.1.1.13&quot;, &quot;OID.1.2.840.113549.1.1.13&quot;),
                m(CKM_SHA512_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));

        /*
         * TLS 1.2 uses a different hash algorithm than 1.0/1.1 for the
         * PRF calculations.  As of 2010, there is no PKCS11-level
         * support for TLS 1.2 PRF calculations, and no known OS's have
         * an internal variant we could use.  Therefore for TLS 1.2, we
         * are updating JSSE to request different provider algorithms
         * (e.g. &quot;SunTls12Prf&quot;), and currently only SunJCE has these
         * TLS 1.2 algorithms.
         *
         * If we reused the names such as &quot;SunTlsPrf&quot;, the PKCS11
         * providers would need be updated to fail correctly when
         * presented with the wrong version number (via
         * Provider.Service.supportsParameters()), and we would also
         * need to add the appropriate supportsParamters() checks into
         * KeyGenerators (not currently there).
         *
         * In the future, if PKCS11 support is added, we will restructure
         * this.
         */
        d(KG, &quot;SunTlsRsaPremasterSecret&quot;,
                    &quot;sun.security.pkcs11.P11TlsRsaPremasterSecretGenerator&quot;,
                m(CKM_SSL3_PRE_MASTER_KEY_GEN, CKM_TLS_PRE_MASTER_KEY_GEN));
        d(KG, &quot;SunTlsMasterSecret&quot;,
                    &quot;sun.security.pkcs11.P11TlsMasterSecretGenerator&quot;,
                m(CKM_SSL3_MASTER_KEY_DERIVE, CKM_TLS_MASTER_KEY_DERIVE,
                    CKM_SSL3_MASTER_KEY_DERIVE_DH,
                    CKM_TLS_MASTER_KEY_DERIVE_DH));
        d(KG, &quot;SunTlsKeyMaterial&quot;,
                    &quot;sun.security.pkcs11.P11TlsKeyMaterialGenerator&quot;,
                m(CKM_SSL3_KEY_AND_MAC_DERIVE, CKM_TLS_KEY_AND_MAC_DERIVE));
        d(KG, &quot;SunTlsPrf&quot;, &quot;sun.security.pkcs11.P11TlsPrfGenerator&quot;,
                m(CKM_TLS_PRF, CKM_NSS_TLS_PRF_GENERAL));
    }

    // background thread that periodically checks for token insertion
    // if no token is present. We need to do that in a separate thread because
    // the insertion check may block for quite a long time on some tokens.
    private static class TokenPoller implements Runnable {
        private final SunPKCS11 provider;
        private volatile boolean enabled;
        private TokenPoller(SunPKCS11 provider) {
            this.provider = provider;
            enabled = true;
        }
        public void run() {
            int interval = provider.config.getInsertionCheckInterval();
            while (enabled) {
                try {
                    Thread.sleep(interval);
                } catch (InterruptedException e) {
                    break;
                }
                if (enabled == false) {
                    break;
                }
                try {
                    provider.initToken(null);
                } catch (PKCS11Exception e) {
                    // ignore
                }
            }
        }
        void disable() {
            enabled = false;
        }
    }

    // create the poller thread, if not already active
    private void createPoller() {
        if (poller != null) {
            return;
        }
        TokenPoller poller = new TokenPoller(this);
        Thread t = new Thread(poller, &quot;Poller &quot; + getName());
        t.setDaemon(true);
        t.setPriority(Thread.MIN_PRIORITY);
        t.start();
        this.poller = poller;
    }

    // destroy the poller thread, if active
    private void destroyPoller() {
        if (poller != null) {
            poller.disable();
            poller = null;
        }
    }

    private boolean hasValidToken() {
        /* Commented out to work with Solaris softtoken impl which
           returns 0-value flags, e.g. both REMOVABLE_DEVICE and
           TOKEN_PRESENT are false, when it can't access the token.
        if (removable == false) {
            return true;
        }
        */
        Token token = this.token;
        return (token != null) &amp;&amp; token.isValid();
    }

    // destroy the token. Called if we detect that it has been removed
    synchronized void uninitToken(Token token) {
        if (this.token != token) {
            // mismatch, our token must already be destroyed
            return;
        }
        destroyPoller();
        this.token = null;
        // unregister all algorithms
        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
            public Object run() {
                clear();
                return null;
            }
        });
        createPoller();
    }

    // test if a token is present and initialize this provider for it if so.
    // does nothing if no token is found
    // called from constructor and by poller
    private void initToken(CK_SLOT_INFO slotInfo) throws PKCS11Exception {
        if (slotInfo == null) {
            slotInfo = p11.C_GetSlotInfo(slotID);
        }
        if (removable &amp;&amp; (slotInfo.flags &amp; CKF_TOKEN_PRESENT) == 0) {
            createPoller();
            return;
        }
        destroyPoller();
        boolean showInfo = config.getShowInfo();
        if (showInfo) {
            System.out.println(&quot;Slot info for slot &quot; + slotID + &quot;:&quot;);
            System.out.println(slotInfo);
        }
        final Token token = new Token(this);
        if (showInfo) {
            System.out.println
                (&quot;Token info for token in slot &quot; + slotID + &quot;:&quot;);
            System.out.println(token.tokenInfo);
        }
        long[] supportedMechanisms = p11.C_GetMechanismList(slotID);

        // Create a map from the various Descriptors to the &quot;most
        // preferred&quot; mechanism that was defined during the
        // static initialization.  For example, DES/CBC/PKCS5Padding
        // could be mapped to CKM_DES_CBC_PAD or CKM_DES_CBC.  Prefer
        // the earliest entry.  When asked for &quot;DES/CBC/PKCS5Padding&quot;, we
        // return a CKM_DES_CBC_PAD.
        final Map&lt;Descriptor,Integer&gt; supportedAlgs =
                                        new HashMap&lt;Descriptor,Integer&gt;();
        for (int i = 0; i &lt; supportedMechanisms.length; i++) {
            long longMech = supportedMechanisms[i];
            boolean isEnabled = config.isEnabled(longMech);
            if (showInfo) {
                CK_MECHANISM_INFO mechInfo =
                        p11.C_GetMechanismInfo(slotID, longMech);
                System.out.println(&quot;Mechanism &quot; +
                        Functions.getMechanismName(longMech) + &quot;:&quot;);
                if (isEnabled == false) {
                    System.out.println(&quot;DISABLED in configuration&quot;);
                }
                System.out.println(mechInfo);
            }
            if (isEnabled == false) {
                continue;
            }
            // we do not know of mechs with the upper 32 bits set
            if (longMech &gt;&gt;&gt; 32 != 0) {
                continue;
            }
            int mech = (int)longMech;
            Integer integerMech = Integer.valueOf(mech);
            List&lt;Descriptor&gt; ds = descriptors.get(integerMech);
            if (ds == null) {
                continue;
            }
            for (Descriptor d : ds) {
                Integer oldMech = supportedAlgs.get(d);
                if (oldMech == null) {
                    supportedAlgs.put(d, integerMech);
                    continue;
                }
                // See if there is something &quot;more preferred&quot;
                // than what we currently have in the supportedAlgs
                // map.
                int intOldMech = oldMech.intValue();
                for (int j = 0; j &lt; d.mechanisms.length; j++) {
                    int nextMech = d.mechanisms[j];
                    if (mech == nextMech) {
                        supportedAlgs.put(d, integerMech);
                        break;
                    } else if (intOldMech == nextMech) {
                        break;
                    }
                }
            }

        }

        // register algorithms in provider
        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
            public Object run() {
                for (Map.Entry&lt;Descriptor,Integer&gt; entry
                        : supportedAlgs.entrySet()) {
                    Descriptor d = entry.getKey();
                    int mechanism = entry.getValue().intValue();
                    Service s = d.service(token, mechanism);
                    putService(s);
                }
                if (((token.tokenInfo.flags &amp; CKF_RNG) != 0)
                        &amp;&amp; config.isEnabled(PCKM_SECURERANDOM)
                        &amp;&amp; !token.sessionManager.lowMaxSessions()) {
                    // do not register SecureRandom if the token does
                    // not support many sessions. if we did, we might
                    // run out of sessions in the middle of a
                    // nextBytes() call where we cannot fail over.
                    putService(new P11Service(token, SR, &quot;PKCS11&quot;,
                        &quot;sun.security.pkcs11.P11SecureRandom&quot;, null,
                        PCKM_SECURERANDOM));
                }
                if (config.isEnabled(PCKM_KEYSTORE)) {
                    putService(new P11Service(token, KS, &quot;PKCS11&quot;,
                        &quot;sun.security.pkcs11.P11KeyStore&quot;,
                        s(&quot;PKCS11-&quot; + config.getName()),
                        PCKM_KEYSTORE));
                }
                return null;
            }
        });

        this.token = token;
    }

    private static final class P11Service extends Service {

        private final Token token;

        private final long mechanism;

        P11Service(Token token, String type, String algorithm,
                String className, String[] al, long mechanism) {
            super(token.provider, type, algorithm, className, toList(al), null);
            this.token = token;
            this.mechanism = mechanism &amp; 0xFFFFFFFFL;
        }

        private static List&lt;String&gt; toList(String[] aliases) {
            return (aliases == null) ? null : Arrays.asList(aliases);
        }

        public Object newInstance(Object param)
                throws NoSuchAlgorithmException {
            if (token.isValid() == false) {
                throw new NoSuchAlgorithmException(&quot;Token has been removed&quot;);
            }
            try {
                return newInstance0(param);
            } catch (PKCS11Exception e) {
                throw new NoSuchAlgorithmException(e);
            }
        }

        public Object newInstance0(Object param) throws
                PKCS11Exception, NoSuchAlgorithmException {
            String algorithm = getAlgorithm();
            String type = getType();
            if (type == MD) {
                return new P11Digest(token, algorithm, mechanism);
            } else if (type == CIP) {
                if (algorithm.startsWith(&quot;RSA&quot;)) {
                    return new P11RSACipher(token, algorithm, mechanism);
                } else {
                    return new P11Cipher(token, algorithm, mechanism);
                }
            } else if (type == SIG) {
                return new P11Signature(token, algorithm, mechanism);
            } else if (type == MAC) {
                return new P11Mac(token, algorithm, mechanism);
            } else if (type == KPG) {
                return new P11KeyPairGenerator(token, algorithm, mechanism);
            } else if (type == KA) {
                if (algorithm.equals(&quot;ECDH&quot;)) {
                    return new P11ECDHKeyAgreement(token, algorithm, mechanism);
                } else {
                    return new P11KeyAgreement(token, algorithm, mechanism);
                }
            } else if (type == KF) {
                return token.getKeyFactory(algorithm);
            } else if (type == SKF) {
                return new P11SecretKeyFactory(token, algorithm);
            } else if (type == KG) {
                // reference equality
                if (algorithm == &quot;SunTlsRsaPremasterSecret&quot;) {
                    return new P11TlsRsaPremasterSecretGenerator(
                        token, algorithm, mechanism);
                } else if (algorithm == &quot;SunTlsMasterSecret&quot;) {
                    return new P11TlsMasterSecretGenerator(
                        token, algorithm, mechanism);
                } else if (algorithm == &quot;SunTlsKeyMaterial&quot;) {
                    return new P11TlsKeyMaterialGenerator(
                        token, algorithm, mechanism);
                } else if (algorithm == &quot;SunTlsPrf&quot;) {
                    return new P11TlsPrfGenerator(token, algorithm, mechanism);
                } else {
                    return new P11KeyGenerator(token, algorithm, mechanism);
                }
            } else if (type == SR) {
                return token.getRandom();
            } else if (type == KS) {
                return token.getKeyStore();
            } else if (type == AGP) {
                return new sun.security.ec.ECParameters();
            } else {
                throw new NoSuchAlgorithmException(&quot;Unknown type: &quot; + type);
            }
        }

        public boolean supportsParameter(Object param) {
            if ((param == null) || (token.isValid() == false)) {
                return false;
            }
            if (param instanceof Key == false) {
                throw new InvalidParameterException(&quot;Parameter must be a Key&quot;);
            }
            String algorithm = getAlgorithm();
            String type = getType();
            Key key = (Key)param;
            String keyAlgorithm = key.getAlgorithm();
            // RSA signatures and cipher
            if (((type == CIP) &amp;&amp; algorithm.startsWith(&quot;RSA&quot;))
                    || (type == SIG) &amp;&amp; algorithm.endsWith(&quot;RSA&quot;)) {
                if (keyAlgorithm.equals(&quot;RSA&quot;) == false) {
                    return false;
                }
                return isLocalKey(key)
                        || (key instanceof RSAPrivateKey)
                        || (key instanceof RSAPublicKey);
            }
            // EC
            if (((type == KA) &amp;&amp; algorithm.equals(&quot;ECDH&quot;))
                    || ((type == SIG) &amp;&amp; algorithm.endsWith(&quot;ECDSA&quot;))) {
                if (keyAlgorithm.equals(&quot;EC&quot;) == false) {
                    return false;
                }
                return isLocalKey(key)
                        || (key instanceof ECPrivateKey)
                        || (key instanceof ECPublicKey);
            }
            // DSA signatures
            if ((type == SIG) &amp;&amp; algorithm.endsWith(&quot;DSA&quot;)) {
                if (keyAlgorithm.equals(&quot;DSA&quot;) == false) {
                    return false;
                }
                return isLocalKey(key)
                        || (key instanceof DSAPrivateKey)
                        || (key instanceof DSAPublicKey);
            }
            // MACs and symmetric ciphers
            if ((type == CIP) || (type == MAC)) {
                // do not check algorithm name, mismatch is unlikely anyway
                return isLocalKey(key) || &quot;RAW&quot;.equals(key.getFormat());
            }
            // DH key agreement
            if (type == KA) {
                if (keyAlgorithm.equals(&quot;DH&quot;) == false) {
                    return false;
                }
                return isLocalKey(key)
                        || (key instanceof DHPrivateKey)
                        || (key instanceof DHPublicKey);
            }
            // should not reach here,
            // unknown engine type or algorithm
            throw new AssertionError
                (&quot;SunPKCS11 error: &quot; + type + &quot;, &quot; + algorithm);
        }

        private boolean isLocalKey(Key key) {
            return (key instanceof P11Key) &amp;&amp; (((P11Key)key).token == token);
        }

        public String toString() {
            return super.toString() +
                &quot; (&quot; + Functions.getMechanismName(mechanism) + &quot;)&quot;;
        }

    }

    /**
     * Log in to this provider.
     *
     * &lt;p&gt; If the token expects a PIN to be supplied by the caller,
     * the &lt;code&gt;handler&lt;/code&gt; implementation must support
     * a &lt;code&gt;PasswordCallback&lt;/code&gt;.
     *
     * &lt;p&gt; To determine if the token supports a protected authentication path,
     * the CK_TOKEN_INFO flag, CKF_PROTECTED_AUTHENTICATION_PATH, is consulted.
     *
     * @param subject this parameter is ignored
     * @param handler the &lt;code&gt;CallbackHandler&lt;/code&gt; used by
     *  this provider to communicate with the caller
     *
     * @exception LoginException if the login operation fails
     * @exception SecurityException if the does not pass a security check for
     *  &lt;code&gt;SecurityPermission(&quot;authProvider.&lt;i&gt;name&lt;/i&gt;&quot;)&lt;/code&gt;,
     *  where &lt;i&gt;name&lt;/i&gt; is the value returned by
     *  this provider's &lt;code&gt;getName&lt;/code&gt; method
     */
    public void login(Subject subject, CallbackHandler handler)
        throws LoginException {

        // security check

        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            if (debug != null) {
                debug.println(&quot;checking login permission&quot;);
            }
            sm.checkPermission(new SecurityPermission
                        (&quot;authProvider.&quot; + this.getName()));
        }

        if (hasValidToken() == false) {
            throw new LoginException(&quot;No token present&quot;);
        }

        // see if a login is required

        if ((token.tokenInfo.flags &amp; CKF_LOGIN_REQUIRED) == 0) {
            if (debug != null) {
                debug.println(&quot;login operation not required for token - &quot; +
                                &quot;ignoring login request&quot;);
            }
            return;
        }

        // see if user already logged in

        try {
            if (token.isLoggedInNow(null)) {
                // user already logged in
                if (debug != null) {
                    debug.println(&quot;user already logged in&quot;);
                }
                return;
            }
        } catch (PKCS11Exception e) {
            // ignore - fall thru and attempt login
        }

        // get the pin if necessary

        char[] pin = null;
        if ((token.tokenInfo.flags &amp; CKF_PROTECTED_AUTHENTICATION_PATH) == 0) {

            // get password

            CallbackHandler myHandler = getCallbackHandler(handler);
            if (myHandler == null) {
                // XXX PolicyTool is dependent on this message text
                throw new LoginException
                        (&quot;no password provided, and no callback handler &quot; +
                        &quot;available for retrieving password&quot;);
            }

            java.text.MessageFormat form = new java.text.MessageFormat
                        (ResourcesMgr.getString
                        (&quot;PKCS11.Token.providerName.Password.&quot;));
            Object[] source = { getName() };

            PasswordCallback pcall = new PasswordCallback(form.format(source),
                                                        false);
            Callback[] callbacks = { pcall };
            try {
                myHandler.handle(callbacks);
            } catch (Exception e) {
                LoginException le = new LoginException
                        (&quot;Unable to perform password callback&quot;);
                le.initCause(e);
                throw le;
            }

            pin = pcall.getPassword();
            pcall.clearPassword();
            if (pin == null) {
                if (debug != null) {
                    debug.println(&quot;caller passed NULL pin&quot;);
                }
            }
        }

        // perform token login

        Session session = null;
        try {
            session = token.getOpSession();

            // pin is NULL if using CKF_PROTECTED_AUTHENTICATION_PATH
            p11.C_Login(session.id(), CKU_USER, pin);
            if (debug != null) {
                debug.println(&quot;login succeeded&quot;);
            }
        } catch (PKCS11Exception pe) {
            if (pe.getErrorCode() == CKR_USER_ALREADY_LOGGED_IN) {
                // let this one go
                if (debug != null) {
                    debug.println(&quot;user already logged in&quot;);
                }
                return;
            } else if (pe.getErrorCode() == CKR_PIN_INCORRECT) {
                FailedLoginException fle = new FailedLoginException();
                fle.initCause(pe);
                throw fle;
            } else {
                LoginException le = new LoginException();
                le.initCause(pe);
                throw le;
            }
        } finally {
            token.releaseSession(session);
            if (pin != null) {
                Arrays.fill(pin, ' ');
            }
        }

        // we do not store the PIN in the subject for now
    }

    /**
     * Log out from this provider
     *
     * @exception LoginException if the logout operation fails
     * @exception SecurityException if the does not pass a security check for
     *  &lt;code&gt;SecurityPermission(&quot;authProvider.&lt;i&gt;name&lt;/i&gt;&quot;)&lt;/code&gt;,
     *  where &lt;i&gt;name&lt;/i&gt; is the value returned by
     *  this provider's &lt;code&gt;getName&lt;/code&gt; method
     */
    public void logout() throws LoginException {

        // security check

        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            sm.checkPermission
                (new SecurityPermission(&quot;authProvider.&quot; + this.getName()));
        }

        if (hasValidToken() == false) {
            // app may call logout for cleanup, allow
            return;
        }

        if ((token.tokenInfo.flags &amp; CKF_LOGIN_REQUIRED) == 0) {
            if (debug != null) {
                debug.println(&quot;logout operation not required for token - &quot; +
                                &quot;ignoring logout request&quot;);
            }
            return;
        }

        try {
            if (token.isLoggedInNow(null) == false) {
                if (debug != null) {
                    debug.println(&quot;user not logged in&quot;);
                }
                return;
            }
        } catch (PKCS11Exception e) {
            // ignore
        }

        // perform token logout

        Session session = null;
        try {
            session = token.getOpSession();
            p11.C_Logout(session.id());
            if (debug != null) {
                debug.println(&quot;logout succeeded&quot;);
            }
        } catch (PKCS11Exception pe) {
            if (pe.getErrorCode() == CKR_USER_NOT_LOGGED_IN) {
                // let this one go
                if (debug != null) {
                    debug.println(&quot;user not logged in&quot;);
                }
                return;
            }
            LoginException le = new LoginException();
            le.initCause(pe);
            throw le;
        } finally {
            token.releaseSession(session);
        }
    }

    /**
     * Set a &lt;code&gt;CallbackHandler&lt;/code&gt;
     *
     * &lt;p&gt; The provider uses this handler if one is not passed to the
     * &lt;code&gt;login&lt;/code&gt; method.  The provider also uses this handler
     * if it invokes &lt;code&gt;login&lt;/code&gt; on behalf of callers.
     * In either case if a handler is not set via this method,
     * the provider queries the
     * &lt;i&gt;auth.login.defaultCallbackHandler&lt;/i&gt; security property
     * for the fully qualified class name of a default handler implementation.
     * If the security property is not set,
     * the provider is assumed to have alternative means
     * for obtaining authentication information.
     *
     * @param handler a &lt;code&gt;CallbackHandler&lt;/code&gt; for obtaining
     *          authentication information, which may be &lt;code&gt;null&lt;/code&gt;
     *
     * @exception SecurityException if the caller does not pass a
     *  security check for
     *  &lt;code&gt;SecurityPermission(&quot;authProvider.&lt;i&gt;name&lt;/i&gt;&quot;)&lt;/code&gt;,
     *  where &lt;i&gt;name&lt;/i&gt; is the value returned by
     *  this provider's &lt;code&gt;getName&lt;/code&gt; method
     */
    public void setCallbackHandler(CallbackHandler handler) {

        // security check

        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            sm.checkPermission
                (new SecurityPermission(&quot;authProvider.&quot; + this.getName()));
        }

        synchronized (LOCK_HANDLER) {
            pHandler = handler;
        }
    }

    private CallbackHandler getCallbackHandler(CallbackHandler handler) {

        // get default handler if necessary

        if (handler != null) {
            return handler;
        }

        if (debug != null) {
            debug.println(&quot;getting provider callback handler&quot;);
        }

        synchronized (LOCK_HANDLER) {
            // see if handler was set via setCallbackHandler
            if (pHandler != null) {
                return pHandler;
            }

            try {
                if (debug != null) {
                    debug.println(&quot;getting default callback handler&quot;);
                }

                CallbackHandler myHandler = AccessController.doPrivileged
                    (new PrivilegedExceptionAction&lt;CallbackHandler&gt;() {
                    public CallbackHandler run() throws Exception {

                        String defaultHandler =
                                java.security.Security.getProperty
                                (&quot;auth.login.defaultCallbackHandler&quot;);

                        if (defaultHandler == null ||
                            defaultHandler.length() == 0) {

                            // ok
                            if (debug != null) {
                                debug.println(&quot;no default handler set&quot;);
                            }
                            return null;
                        }

                        Class&lt;?&gt; c = Class.forName
                                   (defaultHandler,
                                   true,
                                   Thread.currentThread().getContextClassLoader());
                        return (CallbackHandler)c.newInstance();
                    }
                });

                // save it
                pHandler = myHandler;
                return myHandler;

            } catch (PrivilegedActionException pae) {
                // ok
                if (debug != null) {
                    debug.println(&quot;Unable to load default callback handler&quot;);
                    pae.printStackTrace();
                }
            }
        }
        return null;
    }

    private Object writeReplace() throws ObjectStreamException {
        return new SunPKCS11Rep(this);
    }

    /**
     * Serialized representation of the SunPKCS11 provider.
     */
    private static class SunPKCS11Rep implements Serializable {

        static final long serialVersionUID = -2896606995897745419L;

        private final String providerName;

        private final String configName;

        SunPKCS11Rep(SunPKCS11 provider) throws NotSerializableException {
            providerName = provider.getName();
            configName = provider.configName;
            if (Security.getProvider(providerName) != provider) {
                throw new NotSerializableException(&quot;Only SunPKCS11 providers &quot;
                    + &quot;installed in java.security.Security can be serialized&quot;);
            }
        }

        private Object readResolve() throws ObjectStreamException {
            SunPKCS11 p = (SunPKCS11)Security.getProvider(providerName);
            if ((p == null) || (p.configName.equals(configName) == false)) {
                throw new NotSerializableException(&quot;Could not find &quot;
                        + providerName + &quot; in installed providers&quot;);
            }
            return p;
        }
    }
}
</pre>
</body>
</html>
