<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.tools.keytool;

/**
 * &lt;p&gt; This class represents the &lt;code&gt;ResourceBundle&lt;/code&gt;
 * for the keytool.
 *
 */
public class Resources_fr extends java.util.ListResourceBundle {

    private static final Object[][] contents = {
        {&quot;NEWLINE&quot;, &quot;\n&quot;},
        {&quot;STAR&quot;,
                &quot;*******************************************&quot;},
        {&quot;STARNN&quot;,
                &quot;*******************************************\n\n&quot;},

        // keytool: Help part
        {&quot;.OPTION.&quot;, &quot; [OPTION]...&quot;},
        {&quot;Options.&quot;, &quot;Options :&quot;},
        {&quot;Use.keytool.help.for.all.available.commands&quot;,
                 &quot;Utiliser \&quot;keytool -help\&quot; pour toutes les commandes disponibles&quot;},
        {&quot;Key.and.Certificate.Management.Tool&quot;,
                 &quot;Outil de gestion de certificats et de cl\u00E9s&quot;},
        {&quot;Commands.&quot;, &quot;Commandes :&quot;},
        {&quot;Use.keytool.command.name.help.for.usage.of.command.name&quot;,
                &quot;Utiliser \&quot;keytool -command_name -help\&quot; pour la syntaxe de command_name&quot;},
        // keytool: help: commands
        {&quot;Generates.a.certificate.request&quot;,
                &quot;G\u00E9n\u00E8re une demande de certificat&quot;}, //-certreq
        {&quot;Changes.an.entry.s.alias&quot;,
                &quot;Modifie l'alias d'une entr\u00E9e&quot;}, //-changealias
        {&quot;Deletes.an.entry&quot;,
                &quot;Supprime une entr\u00E9e&quot;}, //-delete
        {&quot;Exports.certificate&quot;,
                &quot;Exporte le certificat&quot;}, //-exportcert
        {&quot;Generates.a.key.pair&quot;,
                &quot;G\u00E9n\u00E8re une paire de cl\u00E9s&quot;}, //-genkeypair
        {&quot;Generates.a.secret.key&quot;,
                &quot;G\u00E9n\u00E8re une cl\u00E9 secr\u00E8te&quot;}, //-genseckey
        {&quot;Generates.certificate.from.a.certificate.request&quot;,
                &quot;G\u00E9n\u00E8re le certificat \u00E0 partir d'une demande de certificat&quot;}, //-gencert
        {&quot;Generates.CRL&quot;, &quot;G\u00E9n\u00E8re la liste des certificats r\u00E9voqu\u00E9s (CRL)&quot;}, //-gencrl
        {&quot;Generated.keyAlgName.secret.key&quot;,
                &quot;Cl\u00E9 secr\u00E8te {0} g\u00E9n\u00E9r\u00E9e&quot;}, //-genseckey
        {&quot;Generated.keysize.bit.keyAlgName.secret.key&quot;,
                &quot;Cl\u00E9 secr\u00E8te {0} bits {1} g\u00E9n\u00E9r\u00E9e&quot;}, //-genseckey
        {&quot;Imports.entries.from.a.JDK.1.1.x.style.identity.database&quot;,
                &quot;Importe les entr\u00E9es \u00E0 partir d'une base de donn\u00E9es d'identit\u00E9s de type JDK 1.1.x&quot;}, //-identitydb
        {&quot;Imports.a.certificate.or.a.certificate.chain&quot;,
                &quot;Importe un certificat ou une cha\u00EEne de certificat&quot;}, //-importcert
        {&quot;Imports.a.password&quot;,
                &quot;Importe un mot de passe&quot;}, //-importpass
        {&quot;Imports.one.or.all.entries.from.another.keystore&quot;,
                &quot;Importe une entr\u00E9e ou la totalit\u00E9 des entr\u00E9es depuis un autre fichier de cl\u00E9s&quot;}, //-importkeystore
        {&quot;Clones.a.key.entry&quot;,
                &quot;Clone une entr\u00E9e de cl\u00E9&quot;}, //-keyclone
        {&quot;Changes.the.key.password.of.an.entry&quot;,
                &quot;Modifie le mot de passe de cl\u00E9 d'une entr\u00E9e&quot;}, //-keypasswd
        {&quot;Lists.entries.in.a.keystore&quot;,
                &quot;R\u00E9pertorie les entr\u00E9es d'un fichier de cl\u00E9s&quot;}, //-list
        {&quot;Prints.the.content.of.a.certificate&quot;,
                &quot;Imprime le contenu d'un certificat&quot;}, //-printcert
        {&quot;Prints.the.content.of.a.certificate.request&quot;,
                &quot;Imprime le contenu d'une demande de certificat&quot;}, //-printcertreq
        {&quot;Prints.the.content.of.a.CRL.file&quot;,
                &quot;Imprime le contenu d'un fichier de liste des certificats r\u00E9voqu\u00E9s (CRL)&quot;}, //-printcrl
        {&quot;Generates.a.self.signed.certificate&quot;,
                &quot;G\u00E9n\u00E8re un certificat auto-sign\u00E9&quot;}, //-selfcert
        {&quot;Changes.the.store.password.of.a.keystore&quot;,
                &quot;Modifie le mot de passe de banque d'un fichier de cl\u00E9s&quot;}, //-storepasswd
        // keytool: help: options
        {&quot;alias.name.of.the.entry.to.process&quot;,
                &quot;nom d'alias de l'entr\u00E9e \u00E0 traiter&quot;}, //-alias
        {&quot;destination.alias&quot;,
                &quot;alias de destination&quot;}, //-destalias
        {&quot;destination.key.password&quot;,
                &quot;mot de passe de la cl\u00E9 de destination&quot;}, //-destkeypass
        {&quot;destination.keystore.name&quot;,
                &quot;nom du fichier de cl\u00E9s de destination&quot;}, //-destkeystore
        {&quot;destination.keystore.password.protected&quot;,
                &quot;mot de passe du fichier de cl\u00E9s de destination prot\u00E9g\u00E9&quot;}, //-destprotected
        {&quot;destination.keystore.provider.name&quot;,
                &quot;nom du fournisseur du fichier de cl\u00E9s de destination&quot;}, //-destprovidername
        {&quot;destination.keystore.password&quot;,
                &quot;mot de passe du fichier de cl\u00E9s de destination&quot;}, //-deststorepass
        {&quot;destination.keystore.type&quot;,
                &quot;type du fichier de cl\u00E9s de destination&quot;}, //-deststoretype
        {&quot;distinguished.name&quot;,
                &quot;nom distinctif&quot;}, //-dname
        {&quot;X.509.extension&quot;,
                &quot;extension X.509&quot;}, //-ext
        {&quot;output.file.name&quot;,
                &quot;nom du fichier de sortie&quot;}, //-file and -outfile
        {&quot;input.file.name&quot;,
                &quot;nom du fichier d'entr\u00E9e&quot;}, //-file and -infile
        {&quot;key.algorithm.name&quot;,
                &quot;nom de l'algorithme de cl\u00E9&quot;}, //-keyalg
        {&quot;key.password&quot;,
                &quot;mot de passe de la cl\u00E9&quot;}, //-keypass
        {&quot;key.bit.size&quot;,
                &quot;taille en bits de la cl\u00E9&quot;}, //-keysize
        {&quot;keystore.name&quot;,
                &quot;nom du fichier de cl\u00E9s&quot;}, //-keystore
        {&quot;new.password&quot;,
                &quot;nouveau mot de passe&quot;}, //-new
        {&quot;do.not.prompt&quot;,
                &quot;ne pas inviter&quot;}, //-noprompt
        {&quot;password.through.protected.mechanism&quot;,
                &quot;mot de passe via m\u00E9canisme prot\u00E9g\u00E9&quot;}, //-protected
        {&quot;provider.argument&quot;,
                &quot;argument du fournisseur&quot;}, //-providerarg
        {&quot;provider.class.name&quot;,
                &quot;nom de la classe de fournisseur&quot;}, //-providerclass
        {&quot;provider.name&quot;,
                &quot;nom du fournisseur&quot;}, //-providername
        {&quot;provider.classpath&quot;,
                &quot;variable d'environnement CLASSPATH du fournisseur&quot;}, //-providerpath
        {&quot;output.in.RFC.style&quot;,
                &quot;sortie au style RFC&quot;}, //-rfc
        {&quot;signature.algorithm.name&quot;,
                &quot;nom de l'algorithme de signature&quot;}, //-sigalg
        {&quot;source.alias&quot;,
                &quot;alias source&quot;}, //-srcalias
        {&quot;source.key.password&quot;,
                &quot;mot de passe de la cl\u00E9 source&quot;}, //-srckeypass
        {&quot;source.keystore.name&quot;,
                &quot;nom du fichier de cl\u00E9s source&quot;}, //-srckeystore
        {&quot;source.keystore.password.protected&quot;,
                &quot;mot de passe du fichier de cl\u00E9s source prot\u00E9g\u00E9&quot;}, //-srcprotected
        {&quot;source.keystore.provider.name&quot;,
                &quot;nom du fournisseur du fichier de cl\u00E9s source&quot;}, //-srcprovidername
        {&quot;source.keystore.password&quot;,
                &quot;mot de passe du fichier de cl\u00E9s source&quot;}, //-srcstorepass
        {&quot;source.keystore.type&quot;,
                &quot;type du fichier de cl\u00E9s source&quot;}, //-srcstoretype
        {&quot;SSL.server.host.and.port&quot;,
                &quot;Port et h\u00F4te du serveur SSL&quot;}, //-sslserver
        {&quot;signed.jar.file&quot;,
                &quot;fichier JAR sign\u00E9&quot;}, //=jarfile
        {&quot;certificate.validity.start.date.time&quot;,
                &quot;date/heure de d\u00E9but de validit\u00E9 du certificat&quot;}, //-startdate
        {&quot;keystore.password&quot;,
                &quot;mot de passe du fichier de cl\u00E9s&quot;}, //-storepass
        {&quot;keystore.type&quot;,
                &quot;type du fichier de cl\u00E9s&quot;}, //-storetype
        {&quot;trust.certificates.from.cacerts&quot;,
                &quot;certificats s\u00E9curis\u00E9s issus de certificats CA&quot;}, //-trustcacerts
        {&quot;verbose.output&quot;,
                &quot;sortie en mode verbose&quot;}, //-v
        {&quot;validity.number.of.days&quot;,
                &quot;nombre de jours de validit\u00E9&quot;}, //-validity
        {&quot;Serial.ID.of.cert.to.revoke&quot;,
                 &quot;ID de s\u00E9rie du certificat \u00E0 r\u00E9voquer&quot;}, //-id
        // keytool: Running part
        {&quot;keytool.error.&quot;, &quot;erreur keytool : &quot;},
        {&quot;Illegal.option.&quot;, &quot;Option non admise :  &quot;},
        {&quot;Illegal.value.&quot;, &quot;Valeur non admise : &quot;},
        {&quot;Unknown.password.type.&quot;, &quot;Type de mot de passe inconnu : &quot;},
        {&quot;Cannot.find.environment.variable.&quot;,
                &quot;Variable d'environnement introuvable : &quot;},
        {&quot;Cannot.find.file.&quot;, &quot;Fichier introuvable : &quot;},
        {&quot;Command.option.flag.needs.an.argument.&quot;, &quot;L''option de commande {0} requiert un argument.&quot;},
        {&quot;Warning.Different.store.and.key.passwords.not.supported.for.PKCS12.KeyStores.Ignoring.user.specified.command.value.&quot;,
                &quot;Avertissement\u00A0: les mots de passe de cl\u00E9 et de banque distincts ne sont pas pris en charge pour les fichiers de cl\u00E9s d''acc\u00E8s PKCS12. La valeur {0} sp\u00E9cifi\u00E9e par l''utilisateur est ignor\u00E9e.&quot;},
        {&quot;.keystore.must.be.NONE.if.storetype.is.{0}&quot;,
                &quot;-keystore doit \u00EAtre d\u00E9fini sur NONE si -storetype est {0}&quot;},
        {&quot;Too.many.retries.program.terminated&quot;,
                 &quot;Trop de tentatives, fin du programme&quot;},
        {&quot;.storepasswd.and.keypasswd.commands.not.supported.if.storetype.is.{0}&quot;,
                &quot;Les commandes -storepasswd et -keypasswd ne sont pas prises en charge si -storetype est d\u00E9fini sur {0}&quot;},
        {&quot;.keypasswd.commands.not.supported.if.storetype.is.PKCS12&quot;,
                &quot;Les commandes -keypasswd ne sont pas prises en charge si -storetype est d\u00E9fini sur PKCS12&quot;},
        {&quot;.keypass.and.new.can.not.be.specified.if.storetype.is.{0}&quot;,
                &quot;Les commandes -keypass et -new ne peuvent pas \u00EAtre sp\u00E9cifi\u00E9es si -storetype est d\u00E9fini sur {0}&quot;},
        {&quot;if.protected.is.specified.then.storepass.keypass.and.new.must.not.be.specified&quot;,
                &quot;si -protected est sp\u00E9cifi\u00E9, -storepass, -keypass et -new ne doivent pas \u00EAtre indiqu\u00E9s&quot;},
        {&quot;if.srcprotected.is.specified.then.srcstorepass.and.srckeypass.must.not.be.specified&quot;,
                &quot;Si -srcprotected est indiqu\u00E9, les commandes -srcstorepass et -srckeypass ne doivent pas \u00EAtre sp\u00E9cifi\u00E9es&quot;},
        {&quot;if.keystore.is.not.password.protected.then.storepass.keypass.and.new.must.not.be.specified&quot;,
                &quot;Si le fichier de cl\u00E9s n'est pas prot\u00E9g\u00E9 par un mot de passe, les commandes -storepass, -keypass et -new ne doivent pas \u00EAtre sp\u00E9cifi\u00E9es&quot;},
        {&quot;if.source.keystore.is.not.password.protected.then.srcstorepass.and.srckeypass.must.not.be.specified&quot;,
                &quot;Si le fichier de cl\u00E9s source n'est pas prot\u00E9g\u00E9 par un mot de passe, les commandes -srcstorepass et -srckeypass ne doivent pas \u00EAtre sp\u00E9cifi\u00E9es&quot;},
        {&quot;Illegal.startdate.value&quot;, &quot;Valeur de date de d\u00E9but non admise&quot;},
        {&quot;Validity.must.be.greater.than.zero&quot;,
                &quot;La validit\u00E9 doit \u00EAtre sup\u00E9rieure \u00E0 z\u00E9ro&quot;},
        {&quot;provName.not.a.provider&quot;, &quot;{0} n''est pas un fournisseur&quot;},
        {&quot;Usage.error.no.command.provided&quot;, &quot;Erreur de syntaxe\u00A0: aucune commande fournie&quot;},
        {&quot;Source.keystore.file.exists.but.is.empty.&quot;, &quot;Le fichier de cl\u00E9s source existe mais il est vide : &quot;},
        {&quot;Please.specify.srckeystore&quot;, &quot;Indiquez -srckeystore&quot;},
        {&quot;Must.not.specify.both.v.and.rfc.with.list.command&quot;,
                &quot;-v et -rfc ne doivent pas \u00EAtre sp\u00E9cifi\u00E9s avec la commande 'list'&quot;},
        {&quot;Key.password.must.be.at.least.6.characters&quot;,
                &quot;Un mot de passe de cl\u00E9 doit comporter au moins 6 caract\u00E8res&quot;},
        {&quot;New.password.must.be.at.least.6.characters&quot;,
                &quot;Le nouveau mot de passe doit comporter au moins 6 caract\u00E8res&quot;},
        {&quot;Keystore.file.exists.but.is.empty.&quot;,
                &quot;Fichier de cl\u00E9s existant mais vide : &quot;},
        {&quot;Keystore.file.does.not.exist.&quot;,
                &quot;Le fichier de cl\u00E9s n'existe pas : &quot;},
        {&quot;Must.specify.destination.alias&quot;, &quot;L'alias de destination doit \u00EAtre sp\u00E9cifi\u00E9&quot;},
        {&quot;Must.specify.alias&quot;, &quot;L'alias doit \u00EAtre sp\u00E9cifi\u00E9&quot;},
        {&quot;Keystore.password.must.be.at.least.6.characters&quot;,
                &quot;Un mot de passe de fichier de cl\u00E9s doit comporter au moins 6 caract\u00E8res&quot;},
        {&quot;Enter.the.password.to.be.stored.&quot;,
                &quot;Saisissez le mot de passe \u00E0 stocker :  &quot;},
        {&quot;Enter.keystore.password.&quot;, &quot;Entrez le mot de passe du fichier de cl\u00E9s :  &quot;},
        {&quot;Enter.source.keystore.password.&quot;, &quot;Entrez le mot de passe du fichier de cl\u00E9s source\u00A0:  &quot;},
        {&quot;Enter.destination.keystore.password.&quot;, &quot;Entrez le mot de passe du fichier de cl\u00E9s de destination\u00A0:  &quot;},
        {&quot;Keystore.password.is.too.short.must.be.at.least.6.characters&quot;,
         &quot;Le mot de passe du fichier de cl\u00E9s est trop court : il doit comporter au moins 6 caract\u00E8res&quot;},
        {&quot;Unknown.Entry.Type&quot;, &quot;Type d'entr\u00E9e inconnu&quot;},
        {&quot;Too.many.failures.Alias.not.changed&quot;, &quot;Trop d'erreurs. Alias non modifi\u00E9&quot;},
        {&quot;Entry.for.alias.alias.successfully.imported.&quot;,
                 &quot;L''entr\u00E9e de l''alias {0} a \u00E9t\u00E9 import\u00E9e.&quot;},
        {&quot;Entry.for.alias.alias.not.imported.&quot;, &quot;L''entr\u00E9e de l''alias {0} n''a pas \u00E9t\u00E9 import\u00E9e.&quot;},
        {&quot;Problem.importing.entry.for.alias.alias.exception.Entry.for.alias.alias.not.imported.&quot;,
                 &quot;Probl\u00E8me lors de l''import de l''entr\u00E9e de l''alias {0}\u00A0: {1}.\nL''entr\u00E9e de l''alias {0} n''a pas \u00E9t\u00E9 import\u00E9e.&quot;},
        {&quot;Import.command.completed.ok.entries.successfully.imported.fail.entries.failed.or.cancelled&quot;,
                 &quot;Commande d''import ex\u00E9cut\u00E9e\u00A0: {0} entr\u00E9es import\u00E9es, \u00E9chec ou annulation de {1} entr\u00E9es&quot;},
        {&quot;Warning.Overwriting.existing.alias.alias.in.destination.keystore&quot;,
                 &quot;Avertissement\u00A0: l''alias {0} existant sera remplac\u00E9 dans le fichier de cl\u00E9s d''acc\u00E8s de destination&quot;},
        {&quot;Existing.entry.alias.alias.exists.overwrite.no.&quot;,
                 &quot;L''alias d''entr\u00E9e {0} existe d\u00E9j\u00E0. Voulez-vous le remplacer ? [non]\u00A0:  &quot;},
        {&quot;Too.many.failures.try.later&quot;, &quot;Trop d'erreurs. R\u00E9essayez plus tard&quot;},
        {&quot;Certification.request.stored.in.file.filename.&quot;,
                &quot;Demande de certification stock\u00E9e dans le fichier &lt;{0}&gt;&quot;},
        {&quot;Submit.this.to.your.CA&quot;, &quot;Soumettre \u00E0 votre CA&quot;},
        {&quot;if.alias.not.specified.destalias.and.srckeypass.must.not.be.specified&quot;,
            &quot;si l'alias n'est pas sp\u00E9cifi\u00E9, destalias et srckeypass ne doivent pas \u00EAtre sp\u00E9cifi\u00E9s&quot;},
        {&quot;The.destination.pkcs12.keystore.has.different.storepass.and.keypass.Please.retry.with.destkeypass.specified.&quot;,
            &quot;Le fichier de cl\u00E9s pkcs12 de destination contient un mot de passe de fichier de cl\u00E9s et un mot de passe de cl\u00E9 diff\u00E9rents. R\u00E9essayez en sp\u00E9cifiant -destkeypass.&quot;},
        {&quot;Certificate.stored.in.file.filename.&quot;,
                &quot;Certificat stock\u00E9 dans le fichier &lt;{0}&gt;&quot;},
        {&quot;Certificate.reply.was.installed.in.keystore&quot;,
                &quot;R\u00E9ponse de certificat install\u00E9e dans le fichier de cl\u00E9s&quot;},
        {&quot;Certificate.reply.was.not.installed.in.keystore&quot;,
                &quot;R\u00E9ponse de certificat non install\u00E9e dans le fichier de cl\u00E9s&quot;},
        {&quot;Certificate.was.added.to.keystore&quot;,
                &quot;Certificat ajout\u00E9 au fichier de cl\u00E9s&quot;},
        {&quot;Certificate.was.not.added.to.keystore&quot;,
                &quot;Certificat non ajout\u00E9 au fichier de cl\u00E9s&quot;},
        {&quot;.Storing.ksfname.&quot;, &quot;[Stockage de {0}]&quot;},
        {&quot;alias.has.no.public.key.certificate.&quot;,
                &quot;{0} ne poss\u00E8de pas de cl\u00E9 publique (certificat)&quot;},
        {&quot;Cannot.derive.signature.algorithm&quot;,
                &quot;Impossible de d\u00E9duire l'algorithme de signature&quot;},
        {&quot;Alias.alias.does.not.exist&quot;,
                &quot;L''alias &lt;{0}&gt; n''existe pas&quot;},
        {&quot;Alias.alias.has.no.certificate&quot;,
                &quot;L''alias &lt;{0}&gt; ne poss\u00E8de pas de certificat&quot;},
        {&quot;Key.pair.not.generated.alias.alias.already.exists&quot;,
                &quot;Paire de cl\u00E9s non g\u00E9n\u00E9r\u00E9e, l''alias &lt;{0}&gt; existe d\u00E9j\u00E0&quot;},
        {&quot;Generating.keysize.bit.keyAlgName.key.pair.and.self.signed.certificate.sigAlgName.with.a.validity.of.validality.days.for&quot;,
                &quot;G\u00E9n\u00E9ration d''une paire de cl\u00E9s {1} de {0} bits et d''un certificat auto-sign\u00E9 ({2}) d''une validit\u00E9 de {3} jours\n\tpour : {4}&quot;},
        {&quot;Enter.key.password.for.alias.&quot;, &quot;Entrez le mot de passe de la cl\u00E9 pour &lt;{0}&gt;&quot;},
        {&quot;.RETURN.if.same.as.keystore.password.&quot;,
                &quot;\t(appuyez sur Entr\u00E9e s'il s'agit du mot de passe du fichier de cl\u00E9s) :  &quot;},
        {&quot;Key.password.is.too.short.must.be.at.least.6.characters&quot;,
                &quot;Le mot de passe de la cl\u00E9 est trop court : il doit comporter au moins 6 caract\u00E8res&quot;},
        {&quot;Too.many.failures.key.not.added.to.keystore&quot;,
                &quot;Trop d'erreurs. Cl\u00E9 non ajout\u00E9e au fichier de cl\u00E9s&quot;},
        {&quot;Destination.alias.dest.already.exists&quot;,
                &quot;L''alias de la destination &lt;{0}&gt; existe d\u00E9j\u00E0&quot;},
        {&quot;Password.is.too.short.must.be.at.least.6.characters&quot;,
                &quot;Le mot de passe est trop court : il doit comporter au moins 6 caract\u00E8res&quot;},
        {&quot;Too.many.failures.Key.entry.not.cloned&quot;,
                &quot;Trop d'erreurs. Entr\u00E9e de cl\u00E9 non clon\u00E9e&quot;},
        {&quot;key.password.for.alias.&quot;, &quot;mot de passe de cl\u00E9 pour &lt;{0}&gt;&quot;},
        {&quot;Keystore.entry.for.id.getName.already.exists&quot;,
                &quot;L''entr\u00E9e de fichier de cl\u00E9s d''acc\u00E8s pour &lt;{0}&gt; existe d\u00E9j\u00E0&quot;},
        {&quot;Creating.keystore.entry.for.id.getName.&quot;,
                &quot;Cr\u00E9ation d''une entr\u00E9e de fichier de cl\u00E9s d''acc\u00E8s pour &lt;{0}&gt;...&quot;},
        {&quot;No.entries.from.identity.database.added&quot;,
                &quot;Aucune entr\u00E9e ajout\u00E9e \u00E0 partir de la base de donn\u00E9es d'identit\u00E9s&quot;},
        {&quot;Alias.name.alias&quot;, &quot;Nom d''alias : {0}&quot;},
        {&quot;Creation.date.keyStore.getCreationDate.alias.&quot;,
                &quot;Date de cr\u00E9ation : {0,date}&quot;},
        {&quot;alias.keyStore.getCreationDate.alias.&quot;,
                &quot;{0}, {1,date}, &quot;},
        {&quot;alias.&quot;, &quot;{0}, &quot;},
        {&quot;Entry.type.type.&quot;, &quot;Type d''entr\u00E9e\u00A0: {0}&quot;},
        {&quot;Certificate.chain.length.&quot;, &quot;Longueur de cha\u00EEne du certificat : &quot;},
        {&quot;Certificate.i.1.&quot;, &quot;Certificat[{0,number,integer}]:&quot;},
        {&quot;Certificate.fingerprint.SHA1.&quot;, &quot;Empreinte du certificat (SHA1) : &quot;},
        {&quot;Keystore.type.&quot;, &quot;Type de fichier de cl\u00E9s : &quot;},
        {&quot;Keystore.provider.&quot;, &quot;Fournisseur de fichier de cl\u00E9s : &quot;},
        {&quot;Your.keystore.contains.keyStore.size.entry&quot;,
                &quot;Votre fichier de cl\u00E9s d''acc\u00E8s contient {0,number,integer} entr\u00E9e&quot;},
        {&quot;Your.keystore.contains.keyStore.size.entries&quot;,
                &quot;Votre fichier de cl\u00E9s d''acc\u00E8s contient {0,number,integer} entr\u00E9es&quot;},
        {&quot;Failed.to.parse.input&quot;, &quot;L'analyse de l'entr\u00E9e a \u00E9chou\u00E9&quot;},
        {&quot;Empty.input&quot;, &quot;Entr\u00E9e vide&quot;},
        {&quot;Not.X.509.certificate&quot;, &quot;Pas un certificat X.509&quot;},
        {&quot;alias.has.no.public.key&quot;, &quot;{0} ne poss\u00E8de pas de cl\u00E9 publique&quot;},
        {&quot;alias.has.no.X.509.certificate&quot;, &quot;{0} ne poss\u00E8de pas de certificat X.509&quot;},
        {&quot;New.certificate.self.signed.&quot;, &quot;Nouveau certificat (auto-sign\u00E9) :&quot;},
        {&quot;Reply.has.no.certificates&quot;, &quot;La r\u00E9ponse n'a pas de certificat&quot;},
        {&quot;Certificate.not.imported.alias.alias.already.exists&quot;,
                &quot;Certificat non import\u00E9, l''alias &lt;{0}&gt; existe d\u00E9j\u00E0&quot;},
        {&quot;Input.not.an.X.509.certificate&quot;, &quot;L'entr\u00E9e n'est pas un certificat X.509&quot;},
        {&quot;Certificate.already.exists.in.keystore.under.alias.trustalias.&quot;,
                &quot;Le certificat existe d\u00E9j\u00E0 dans le fichier de cl\u00E9s d''acc\u00E8s sous l''alias &lt;{0}&gt;&quot;},
        {&quot;Do.you.still.want.to.add.it.no.&quot;,
                &quot;Voulez-vous toujours l'ajouter ? [non] :  &quot;},
        {&quot;Certificate.already.exists.in.system.wide.CA.keystore.under.alias.trustalias.&quot;,
                &quot;Le certificat existe d\u00E9j\u00E0 dans le fichier de cl\u00E9s d''acc\u00E8s CA syst\u00E8me sous l''alias &lt;{0}&gt;&quot;},
        {&quot;Do.you.still.want.to.add.it.to.your.own.keystore.no.&quot;,
                &quot;Voulez-vous toujours l'ajouter \u00E0 votre fichier de cl\u00E9s ? [non] :  &quot;},
        {&quot;Trust.this.certificate.no.&quot;, &quot;Faire confiance \u00E0 ce certificat ? [non] :  &quot;},
        {&quot;YES&quot;, &quot;OUI&quot;},
        {&quot;New.prompt.&quot;, &quot;Nouveau {0} : &quot;},
        {&quot;Passwords.must.differ&quot;, &quot;Les mots de passe doivent diff\u00E9rer&quot;},
        {&quot;Re.enter.new.prompt.&quot;, &quot;Indiquez encore le nouveau {0} : &quot;},
        {&quot;Re.enter.passpword.&quot;, &quot;R\u00E9p\u00E9tez le mot de passe : &quot;},
        {&quot;Re.enter.new.password.&quot;, &quot;Ressaisissez le nouveau mot de passe : &quot;},
        {&quot;They.don.t.match.Try.again&quot;, &quot;Ils sont diff\u00E9rents. R\u00E9essayez.&quot;},
        {&quot;Enter.prompt.alias.name.&quot;, &quot;Indiquez le nom d''alias {0} :  &quot;},
        {&quot;Enter.new.alias.name.RETURN.to.cancel.import.for.this.entry.&quot;,
                 &quot;Saisissez le nom du nouvel alias\t(ou appuyez sur Entr\u00E9e pour annuler l'import de cette entr\u00E9e)\u00A0:  &quot;},
        {&quot;Enter.alias.name.&quot;, &quot;Indiquez le nom d'alias :  &quot;},
        {&quot;.RETURN.if.same.as.for.otherAlias.&quot;,
                &quot;\t(appuyez sur Entr\u00E9e si le r\u00E9sultat est identique \u00E0 &lt;{0}&gt;)&quot;},
        {&quot;.PATTERN.printX509Cert&quot;,
                &quot;Propri\u00E9taire : {0}\nEmetteur : {1}\nNum\u00E9ro de s\u00E9rie : {2}\nValide du : {3} au : {4}\nEmpreintes du certificat :\n\t MD5:  {5}\n\t SHA1 : {6}\n\t SHA256 : {7}\n\t Nom de l''algorithme de signature : {8}\n\t Version : {9}&quot;},
        {&quot;What.is.your.first.and.last.name.&quot;,
                &quot;Quels sont vos nom et pr\u00E9nom ?&quot;},
        {&quot;What.is.the.name.of.your.organizational.unit.&quot;,
                &quot;Quel est le nom de votre unit\u00E9 organisationnelle ?&quot;},
        {&quot;What.is.the.name.of.your.organization.&quot;,
                &quot;Quel est le nom de votre entreprise ?&quot;},
        {&quot;What.is.the.name.of.your.City.or.Locality.&quot;,
                &quot;Quel est le nom de votre ville de r\u00E9sidence ?&quot;},
        {&quot;What.is.the.name.of.your.State.or.Province.&quot;,
                &quot;Quel est le nom de votre \u00E9tat ou province ?&quot;},
        {&quot;What.is.the.two.letter.country.code.for.this.unit.&quot;,
                &quot;Quel est le code pays \u00E0 deux lettres pour cette unit\u00E9 ?&quot;},
        {&quot;Is.name.correct.&quot;, &quot;Est-ce {0} ?&quot;},
        {&quot;no&quot;, &quot;non&quot;},
        {&quot;yes&quot;, &quot;oui&quot;},
        {&quot;y&quot;, &quot;o&quot;},
        {&quot;.defaultValue.&quot;, &quot;  [{0}]:  &quot;},
        {&quot;Alias.alias.has.no.key&quot;,
                &quot;L''alias &lt;{0}&gt; n''est associ\u00E9 \u00E0 aucune cl\u00E9&quot;},
        {&quot;Alias.alias.references.an.entry.type.that.is.not.a.private.key.entry.The.keyclone.command.only.supports.cloning.of.private.key&quot;,
                 &quot;L''entr\u00E9e \u00E0 laquelle l''alias &lt;{0}&gt; fait r\u00E9f\u00E9rence n''est pas une entr\u00E9e de type cl\u00E9 priv\u00E9e. La commande -keyclone prend uniquement en charge le clonage des cl\u00E9s priv\u00E9es&quot;},

        {&quot;.WARNING.WARNING.WARNING.&quot;,
            &quot;*****************  WARNING WARNING WARNING  *****************&quot;},
        {&quot;Signer.d.&quot;, &quot;Signataire n\u00B0%d :&quot;},
        {&quot;Timestamp.&quot;, &quot;Horodatage :&quot;},
        {&quot;Signature.&quot;, &quot;Signature :&quot;},
        {&quot;CRLs.&quot;, &quot;Listes des certificats r\u00E9voqu\u00E9s (CRL) :&quot;},
        {&quot;Certificate.owner.&quot;, &quot;Propri\u00E9taire du certificat : &quot;},
        {&quot;Not.a.signed.jar.file&quot;, &quot;Fichier JAR non sign\u00E9&quot;},
        {&quot;No.certificate.from.the.SSL.server&quot;,
                &quot;Aucun certificat du serveur SSL&quot;},

        {&quot;.The.integrity.of.the.information.stored.in.your.keystore.&quot;,
            &quot;* L'int\u00E9grit\u00E9 des informations stock\u00E9es dans votre fichier de cl\u00E9s  *\n* n'a PAS \u00E9t\u00E9 v\u00E9rifi\u00E9e. Pour cela, *\n* vous devez fournir le mot de passe de votre fichier de cl\u00E9s.                  *&quot;},
        {&quot;.The.integrity.of.the.information.stored.in.the.srckeystore.&quot;,
            &quot;* L'int\u00E9grit\u00E9 des informations stock\u00E9es dans le fichier de cl\u00E9s source  *\n* n'a PAS \u00E9t\u00E9 v\u00E9rifi\u00E9e. Pour cela, *\n* vous devez fournir le mot de passe de votre fichier de cl\u00E9s source.                  *&quot;},

        {&quot;Certificate.reply.does.not.contain.public.key.for.alias.&quot;,
                &quot;La r\u00E9ponse au certificat ne contient pas de cl\u00E9 publique pour &lt;{0}&gt;&quot;},
        {&quot;Incomplete.certificate.chain.in.reply&quot;,
                &quot;Cha\u00EEne de certificat incompl\u00E8te dans la r\u00E9ponse&quot;},
        {&quot;Certificate.chain.in.reply.does.not.verify.&quot;,
                &quot;La cha\u00EEne de certificat de la r\u00E9ponse ne concorde pas : &quot;},
        {&quot;Top.level.certificate.in.reply.&quot;,
                &quot;Certificat de niveau sup\u00E9rieur dans la r\u00E9ponse :\n&quot;},
        {&quot;.is.not.trusted.&quot;, &quot;... non s\u00E9curis\u00E9. &quot;},
        {&quot;Install.reply.anyway.no.&quot;, &quot;Installer la r\u00E9ponse quand m\u00EAme ? [non] :  &quot;},
        {&quot;NO&quot;, &quot;NON&quot;},
        {&quot;Public.keys.in.reply.and.keystore.don.t.match&quot;,
                &quot;Les cl\u00E9s publiques de la r\u00E9ponse et du fichier de cl\u00E9s ne concordent pas&quot;},
        {&quot;Certificate.reply.and.certificate.in.keystore.are.identical&quot;,
                &quot;La r\u00E9ponse au certificat et le certificat du fichier de cl\u00E9s sont identiques&quot;},
        {&quot;Failed.to.establish.chain.from.reply&quot;,
                &quot;Impossible de cr\u00E9er une cha\u00EEne \u00E0 partir de la r\u00E9ponse&quot;},
        {&quot;n&quot;, &quot;n&quot;},
        {&quot;Wrong.answer.try.again&quot;, &quot;R\u00E9ponse incorrecte, recommencez&quot;},
        {&quot;Secret.key.not.generated.alias.alias.already.exists&quot;,
                &quot;Cl\u00E9 secr\u00E8te non g\u00E9n\u00E9r\u00E9e, l''alias &lt;{0}&gt; existe d\u00E9j\u00E0&quot;},
        {&quot;Please.provide.keysize.for.secret.key.generation&quot;,
                &quot;Indiquez -keysize pour la g\u00E9n\u00E9ration de la cl\u00E9 secr\u00E8te&quot;},

        {&quot;verified.by.s.in.s&quot;, &quot;V\u00E9rifi\u00E9 par %s dans %s&quot;},
        {&quot;warning.not.verified.make.sure.keystore.is.correct&quot;,
            &quot;AVERTISSEMENT : non v\u00E9rifi\u00E9. Assurez-vous que -keystore est correct.&quot;},

        {&quot;Extensions.&quot;, &quot;Extensions\u00A0: &quot;},
        {&quot;.Empty.value.&quot;, &quot;(Valeur vide)&quot;},
        {&quot;Extension.Request.&quot;, &quot;Demande d'extension :&quot;},
        {&quot;PKCS.10.Certificate.Request.Version.1.0.Subject.s.Public.Key.s.format.s.key.&quot;,
                &quot;Demande de certificat PKCS #10 (version 1.0)\nSujet : %s\nCl\u00E9 publique : format %s pour la cl\u00E9 %s\n&quot;},
        {&quot;Unknown.keyUsage.type.&quot;, &quot;Type keyUsage inconnu : &quot;},
        {&quot;Unknown.extendedkeyUsage.type.&quot;, &quot;Type extendedkeyUsage inconnu : &quot;},
        {&quot;Unknown.AccessDescription.type.&quot;, &quot;Type AccessDescription inconnu : &quot;},
        {&quot;Unrecognized.GeneralName.type.&quot;, &quot;Type GeneralName non reconnu : &quot;},
        {&quot;This.extension.cannot.be.marked.as.critical.&quot;,
                 &quot;Cette extension ne peut pas \u00EAtre marqu\u00E9e comme critique. &quot;},
        {&quot;Odd.number.of.hex.digits.found.&quot;, &quot;Nombre impair de chiffres hexad\u00E9cimaux trouv\u00E9 : &quot;},
        {&quot;Unknown.extension.type.&quot;, &quot;Type d'extension inconnu : &quot;},
        {&quot;command.{0}.is.ambiguous.&quot;, &quot;commande {0} ambigu\u00EB :&quot;}
    };


    /**
     * Returns the contents of this &lt;code&gt;ResourceBundle&lt;/code&gt;.
     *
     * &lt;p&gt;
     *
     * @return the contents of this &lt;code&gt;ResourceBundle&lt;/code&gt;.
     */
    @Override
    public Object[][] getContents() {
        return contents;
    }
}
</pre>
</body>
</html>
