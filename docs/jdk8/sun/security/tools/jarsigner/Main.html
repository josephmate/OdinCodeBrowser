<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.tools.jarsigner;

import java.io.*;
import java.util.*;
import java.util.zip.*;
import java.util.jar.*;
import java.math.BigInteger;
import java.net.URI;
import java.net.URISyntaxException;
import java.text.Collator;
import java.text.MessageFormat;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.security.cert.CertificateException;
import java.security.*;
import java.lang.reflect.Constructor;

import com.sun.jarsigner.ContentSigner;
import com.sun.jarsigner.ContentSignerParameters;
import java.net.SocketTimeoutException;
import java.net.URL;
import java.net.URLClassLoader;
import java.security.cert.CertPath;
import java.security.cert.CertPathValidator;
import java.security.cert.CertificateExpiredException;
import java.security.cert.CertificateFactory;
import java.security.cert.CertificateNotYetValidException;
import java.security.cert.PKIXParameters;
import java.security.cert.TrustAnchor;
import java.util.Map.Entry;
import sun.security.tools.KeyStoreUtil;
import sun.security.tools.PathList;
import sun.security.x509.*;
import sun.security.util.*;
import java.util.Base64;


/**
 * &lt;p&gt;The jarsigner utility.
 *
 * The exit codes for the main method are:
 *
 * 0: success
 * 1: any error that the jar cannot be signed or verified, including:
 *      keystore loading error
 *      TSP communication error
 *      jarsigner command line error...
 * otherwise: error codes from -strict
 *
 * @author Roland Schemers
 * @author Jan Luehe
 */

public class Main {

    // for i18n
    private static final java.util.ResourceBundle rb =
        java.util.ResourceBundle.getBundle
        (&quot;sun.security.tools.jarsigner.Resources&quot;);
    private static final Collator collator = Collator.getInstance();
    static {
        // this is for case insensitive string comparisions
        collator.setStrength(Collator.PRIMARY);
    }

    private static final String META_INF = &quot;META-INF/&quot;;

    // prefix for new signature-related files in META-INF directory
    private static final String SIG_PREFIX = META_INF + &quot;SIG-&quot;;

    private static final Class&lt;?&gt;[] PARAM_STRING = { String.class };

    private static final String NONE = &quot;NONE&quot;;
    private static final String P11KEYSTORE = &quot;PKCS11&quot;;

    private static final long SIX_MONTHS = 180*24*60*60*1000L; //milliseconds

    // Attention:
    // This is the entry that get launched by the security tool jarsigner.
    public static void main(String args[]) throws Exception {
        Main js = new Main();
        js.run(args);
    }

    static final String VERSION = &quot;1.0&quot;;

    static final int IN_KEYSTORE = 0x01;        // signer is in keystore
    static final int IN_SCOPE = 0x02;
    static final int NOT_ALIAS = 0x04;          // alias list is NOT empty and
                                                // signer is not in alias list
    static final int SIGNED_BY_ALIAS = 0x08;    // signer is in alias list

    X509Certificate[] certChain;    // signer's cert chain (when composing)
    PrivateKey privateKey;          // private key
    KeyStore store;                 // the keystore specified by -keystore
                                    // or the default keystore, never null

    String keystore; // key store file
    boolean nullStream = false; // null keystore input stream (NONE)
    boolean token = false; // token-based keystore
    String jarfile;  // jar files to sign or verify
    String alias;    // alias to sign jar with
    List&lt;String&gt; ckaliases = new ArrayList&lt;&gt;(); // aliases in -verify
    char[] storepass; // keystore password
    boolean protectedPath; // protected authentication path
    String storetype; // keystore type
    String providerName; // provider name
    Vector&lt;String&gt; providers = null; // list of providers
    // arguments for provider constructors
    HashMap&lt;String,String&gt; providerArgs = new HashMap&lt;&gt;();
    char[] keypass; // private key password
    String sigfile; // name of .SF file
    String sigalg; // name of signature algorithm
    String digestalg = &quot;SHA-256&quot;; // name of digest algorithm
    String signedjar; // output filename
    String tsaUrl; // location of the Timestamping Authority
    String tsaAlias; // alias for the Timestamping Authority's certificate
    String altCertChain; // file to read alternative cert chain from
    String tSAPolicyID;
    boolean verify = false; // verify the jar
    String verbose = null; // verbose output when signing/verifying
    boolean showcerts = false; // show certs when verifying
    boolean debug = false; // debug
    boolean signManifest = true; // &quot;sign&quot; the whole manifest
    boolean externalSF = true; // leave the .SF out of the PKCS7 block
    boolean strict = false;  // treat warnings as error

    // read zip entry raw bytes
    private ByteArrayOutputStream baos = new ByteArrayOutputStream(2048);
    private byte[] buffer = new byte[8192];
    private ContentSigner signingMechanism = null;
    private String altSignerClass = null;
    private String altSignerClasspath = null;
    private ZipFile zipFile = null;

    // Informational warnings
    private boolean hasExpiringCert = false;
    private boolean noTimestamp = false;
    private Date expireDate = new Date(0L);     // used in noTimestamp warning

    // Severe warnings
    private boolean hasExpiredCert = false;
    private boolean notYetValidCert = false;
    private boolean chainNotValidated = false;
    private boolean notSignedByAlias = false;
    private boolean aliasNotInStore = false;
    private boolean hasUnsignedEntry = false;
    private boolean badKeyUsage = false;
    private boolean badExtendedKeyUsage = false;
    private boolean badNetscapeCertType = false;

    CertificateFactory certificateFactory;
    CertPathValidator validator;
    PKIXParameters pkixParameters;

    public void run(String args[]) {
        try {
            parseArgs(args);

            // Try to load and install the specified providers
            if (providers != null) {
                ClassLoader cl = ClassLoader.getSystemClassLoader();
                Enumeration&lt;String&gt; e = providers.elements();
                while (e.hasMoreElements()) {
                    String provName = e.nextElement();
                    Class&lt;?&gt; provClass;
                    if (cl != null) {
                        provClass = cl.loadClass(provName);
                    } else {
                        provClass = Class.forName(provName);
                    }

                    String provArg = providerArgs.get(provName);
                    Object obj;
                    if (provArg == null) {
                        obj = provClass.newInstance();
                    } else {
                        Constructor&lt;?&gt; c =
                                provClass.getConstructor(PARAM_STRING);
                        obj = c.newInstance(provArg);
                    }

                    if (!(obj instanceof Provider)) {
                        MessageFormat form = new MessageFormat(rb.getString
                            (&quot;provName.not.a.provider&quot;));
                        Object[] source = {provName};
                        throw new Exception(form.format(source));
                    }
                    Security.addProvider((Provider)obj);
                }
            }

            if (verify) {
                try {
                    loadKeyStore(keystore, false);
                } catch (Exception e) {
                    if ((keystore != null) || (storepass != null)) {
                        System.out.println(rb.getString(&quot;jarsigner.error.&quot;) +
                                        e.getMessage());
                        System.exit(1);
                    }
                }
                /*              if (debug) {
                    SignatureFileVerifier.setDebug(true);
                    ManifestEntryVerifier.setDebug(true);
                }
                */
                verifyJar(jarfile);
            } else {
                loadKeyStore(keystore, true);
                getAliasInfo(alias);

                // load the alternative signing mechanism
                if (altSignerClass != null) {
                    signingMechanism = loadSigningMechanism(altSignerClass,
                        altSignerClasspath);
                }
                signJar(jarfile, alias, args);
            }
        } catch (Exception e) {
            System.out.println(rb.getString(&quot;jarsigner.error.&quot;) + e);
            if (debug) {
                e.printStackTrace();
            }
            System.exit(1);
        } finally {
            // zero-out private key password
            if (keypass != null) {
                Arrays.fill(keypass, ' ');
                keypass = null;
            }
            // zero-out keystore password
            if (storepass != null) {
                Arrays.fill(storepass, ' ');
                storepass = null;
            }
        }

        if (strict) {
            int exitCode = 0;
            if (chainNotValidated || hasExpiredCert || notYetValidCert) {
                exitCode |= 4;
            }
            if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType) {
                exitCode |= 8;
            }
            if (hasUnsignedEntry) {
                exitCode |= 16;
            }
            if (notSignedByAlias || aliasNotInStore) {
                exitCode |= 32;
            }
            if (exitCode != 0) {
                System.exit(exitCode);
            }
        }
    }

    /*
     * Parse command line arguments.
     */
    void parseArgs(String args[]) {
        /* parse flags */
        int n = 0;

        if (args.length == 0) fullusage();
        for (n=0; n &lt; args.length; n++) {

            String flags = args[n];
            String modifier = null;

            if (flags.startsWith(&quot;-&quot;)) {
                int pos = flags.indexOf(':');
                if (pos &gt; 0) {
                    modifier = flags.substring(pos+1);
                    flags = flags.substring(0, pos);
                }
            }

            if (!flags.startsWith(&quot;-&quot;)) {
                if (jarfile == null) {
                    jarfile = flags;
                } else {
                    alias = flags;
                    ckaliases.add(alias);
                }
            } else if (collator.compare(flags, &quot;-keystore&quot;) == 0) {
                if (++n == args.length) usageNoArg();
                keystore = args[n];
            } else if (collator.compare(flags, &quot;-storepass&quot;) ==0) {
                if (++n == args.length) usageNoArg();
                storepass = getPass(modifier, args[n]);
            } else if (collator.compare(flags, &quot;-storetype&quot;) ==0) {
                if (++n == args.length) usageNoArg();
                storetype = args[n];
            } else if (collator.compare(flags, &quot;-providerName&quot;) ==0) {
                if (++n == args.length) usageNoArg();
                providerName = args[n];
            } else if ((collator.compare(flags, &quot;-provider&quot;) == 0) ||
                        (collator.compare(flags, &quot;-providerClass&quot;) == 0)) {
                if (++n == args.length) usageNoArg();
                if (providers == null) {
                    providers = new Vector&lt;String&gt;(3);
                }
                providers.add(args[n]);

                if (args.length &gt; (n+1)) {
                    flags = args[n+1];
                    if (collator.compare(flags, &quot;-providerArg&quot;) == 0) {
                        if (args.length == (n+2)) usageNoArg();
                        providerArgs.put(args[n], args[n+2]);
                        n += 2;
                    }
                }
            } else if (collator.compare(flags, &quot;-protected&quot;) ==0) {
                protectedPath = true;
            } else if (collator.compare(flags, &quot;-certchain&quot;) ==0) {
                if (++n == args.length) usageNoArg();
                altCertChain = args[n];
            } else if (collator.compare(flags, &quot;-tsapolicyid&quot;) ==0) {
                if (++n == args.length) usageNoArg();
                tSAPolicyID = args[n];
            } else if (collator.compare(flags, &quot;-debug&quot;) ==0) {
                debug = true;
            } else if (collator.compare(flags, &quot;-keypass&quot;) ==0) {
                if (++n == args.length) usageNoArg();
                keypass = getPass(modifier, args[n]);
            } else if (collator.compare(flags, &quot;-sigfile&quot;) ==0) {
                if (++n == args.length) usageNoArg();
                sigfile = args[n];
            } else if (collator.compare(flags, &quot;-signedjar&quot;) ==0) {
                if (++n == args.length) usageNoArg();
                signedjar = args[n];
            } else if (collator.compare(flags, &quot;-tsa&quot;) ==0) {
                if (++n == args.length) usageNoArg();
                tsaUrl = args[n];
            } else if (collator.compare(flags, &quot;-tsacert&quot;) ==0) {
                if (++n == args.length) usageNoArg();
                tsaAlias = args[n];
            } else if (collator.compare(flags, &quot;-altsigner&quot;) ==0) {
                if (++n == args.length) usageNoArg();
                altSignerClass = args[n];
            } else if (collator.compare(flags, &quot;-altsignerpath&quot;) ==0) {
                if (++n == args.length) usageNoArg();
                altSignerClasspath = args[n];
            } else if (collator.compare(flags, &quot;-sectionsonly&quot;) ==0) {
                signManifest = false;
            } else if (collator.compare(flags, &quot;-internalsf&quot;) ==0) {
                externalSF = false;
            } else if (collator.compare(flags, &quot;-verify&quot;) ==0) {
                verify = true;
            } else if (collator.compare(flags, &quot;-verbose&quot;) ==0) {
                verbose = (modifier != null) ? modifier : &quot;all&quot;;
            } else if (collator.compare(flags, &quot;-sigalg&quot;) ==0) {
                if (++n == args.length) usageNoArg();
                sigalg = args[n];
            } else if (collator.compare(flags, &quot;-digestalg&quot;) ==0) {
                if (++n == args.length) usageNoArg();
                digestalg = args[n];
            } else if (collator.compare(flags, &quot;-certs&quot;) ==0) {
                showcerts = true;
            } else if (collator.compare(flags, &quot;-strict&quot;) ==0) {
                strict = true;
            } else if (collator.compare(flags, &quot;-h&quot;) == 0 ||
                        collator.compare(flags, &quot;-help&quot;) == 0) {
                fullusage();
            } else {
                System.err.println(
                        rb.getString(&quot;Illegal.option.&quot;) + flags);
                usage();
            }
        }

        // -certs must always be specified with -verbose
        if (verbose == null) showcerts = false;

        if (jarfile == null) {
            System.err.println(rb.getString(&quot;Please.specify.jarfile.name&quot;));
            usage();
        }
        if (!verify &amp;&amp; alias == null) {
            System.err.println(rb.getString(&quot;Please.specify.alias.name&quot;));
            usage();
        }
        if (!verify &amp;&amp; ckaliases.size() &gt; 1) {
            System.err.println(rb.getString(&quot;Only.one.alias.can.be.specified&quot;));
            usage();
        }

        if (storetype == null) {
            storetype = KeyStore.getDefaultType();
        }
        storetype = KeyStoreUtil.niceStoreTypeName(storetype);

        try {
            if (signedjar != null &amp;&amp; new File(signedjar).getCanonicalPath().equals(
                    new File(jarfile).getCanonicalPath())) {
                signedjar = null;
            }
        } catch (IOException ioe) {
            // File system error?
            // Just ignore it.
        }

        if (P11KEYSTORE.equalsIgnoreCase(storetype) ||
                KeyStoreUtil.isWindowsKeyStore(storetype)) {
            token = true;
            if (keystore == null) {
                keystore = NONE;
            }
        }

        if (NONE.equals(keystore)) {
            nullStream = true;
        }

        if (token &amp;&amp; !nullStream) {
            System.err.println(MessageFormat.format(rb.getString
                (&quot;.keystore.must.be.NONE.if.storetype.is.{0}&quot;), storetype));
            usage();
        }

        if (token &amp;&amp; keypass != null) {
            System.err.println(MessageFormat.format(rb.getString
                (&quot;.keypass.can.not.be.specified.if.storetype.is.{0}&quot;), storetype));
            usage();
        }

        if (protectedPath) {
            if (storepass != null || keypass != null) {
                System.err.println(rb.getString
                        (&quot;If.protected.is.specified.then.storepass.and.keypass.must.not.be.specified&quot;));
                usage();
            }
        }
        if (KeyStoreUtil.isWindowsKeyStore(storetype)) {
            if (storepass != null || keypass != null) {
                System.err.println(rb.getString
                        (&quot;If.keystore.is.not.password.protected.then.storepass.and.keypass.must.not.be.specified&quot;));
                usage();
            }
        }
    }

    static char[] getPass(String modifier, String arg) {
        char[] output = KeyStoreUtil.getPassWithModifier(modifier, arg, rb);
        if (output != null) return output;
        usage();
        return null;    // Useless, usage() already exit
    }

    static void usageNoArg() {
        System.out.println(rb.getString(&quot;Option.lacks.argument&quot;));
        usage();
    }

    static void usage() {
        System.out.println();
        System.out.println(rb.getString(&quot;Please.type.jarsigner.help.for.usage&quot;));
        System.exit(1);
    }

    static void fullusage() {
        System.out.println(rb.getString
                (&quot;Usage.jarsigner.options.jar.file.alias&quot;));
        System.out.println(rb.getString
                (&quot;.jarsigner.verify.options.jar.file.alias.&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.keystore.url.keystore.location&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.storepass.password.password.for.keystore.integrity&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.storetype.type.keystore.type&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.keypass.password.password.for.private.key.if.different.&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.certchain.file.name.of.alternative.certchain.file&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.sigfile.file.name.of.SF.DSA.file&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.signedjar.file.name.of.signed.JAR.file&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.digestalg.algorithm.name.of.digest.algorithm&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.sigalg.algorithm.name.of.signature.algorithm&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.verify.verify.a.signed.JAR.file&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.verbose.suboptions.verbose.output.when.signing.verifying.&quot;));
        System.out.println(rb.getString
                (&quot;.suboptions.can.be.all.grouped.or.summary&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.certs.display.certificates.when.verbose.and.verifying&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.tsa.url.location.of.the.Timestamping.Authority&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.tsacert.alias.public.key.certificate.for.Timestamping.Authority&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.tsapolicyid.tsapolicyid.for.Timestamping.Authority&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.altsigner.class.class.name.of.an.alternative.signing.mechanism&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.altsignerpath.pathlist.location.of.an.alternative.signing.mechanism&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.internalsf.include.the.SF.file.inside.the.signature.block&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.sectionsonly.don.t.compute.hash.of.entire.manifest&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.protected.keystore.has.protected.authentication.path&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.providerName.name.provider.name&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.providerClass.class.name.of.cryptographic.service.provider.s&quot;));
        System.out.println(rb.getString
                (&quot;.providerArg.arg.master.class.file.and.constructor.argument&quot;));
        System.out.println();
        System.out.println(rb.getString
                (&quot;.strict.treat.warnings.as.errors&quot;));
        System.out.println();

        System.exit(0);
    }

    void verifyJar(String jarName)
        throws Exception
    {
        boolean anySigned = false;  // if there exists entry inside jar signed
        JarFile jf = null;

        try {
            jf = new JarFile(jarName, true);
            Vector&lt;JarEntry&gt; entriesVec = new Vector&lt;&gt;();
            byte[] buffer = new byte[8192];

            Enumeration&lt;JarEntry&gt; entries = jf.entries();
            while (entries.hasMoreElements()) {
                JarEntry je = entries.nextElement();
                entriesVec.addElement(je);
                InputStream is = null;
                try {
                    is = jf.getInputStream(je);
                    int n;
                    while ((n = is.read(buffer, 0, buffer.length)) != -1) {
                        // we just read. this will throw a SecurityException
                        // if  a signature/digest check fails.
                    }
                } finally {
                    if (is != null) {
                        is.close();
                    }
                }
            }

            Manifest man = jf.getManifest();

            // The map to record display info, only used when -verbose provided
            //      key: signer info string
            //      value: the list of files with common key
            Map&lt;String,List&lt;String&gt;&gt; output = new LinkedHashMap&lt;&gt;();

            if (man != null) {
                if (verbose != null) System.out.println();
                Enumeration&lt;JarEntry&gt; e = entriesVec.elements();

                String tab = rb.getString(&quot;6SPACE&quot;);

                while (e.hasMoreElements()) {
                    JarEntry je = e.nextElement();
                    String name = je.getName();
                    CodeSigner[] signers = je.getCodeSigners();
                    boolean isSigned = (signers != null);
                    anySigned |= isSigned;
                    hasUnsignedEntry |= !je.isDirectory() &amp;&amp; !isSigned
                                        &amp;&amp; !signatureRelated(name);

                    int inStoreOrScope = inKeyStore(signers);

                    boolean inStore = (inStoreOrScope &amp; IN_KEYSTORE) != 0;
                    boolean inScope = (inStoreOrScope &amp; IN_SCOPE) != 0;

                    notSignedByAlias |= (inStoreOrScope &amp; NOT_ALIAS) != 0;
                    if (keystore != null) {
                        aliasNotInStore |= isSigned &amp;&amp; (!inStore &amp;&amp; !inScope);
                    }

                    // Only used when -verbose provided
                    StringBuffer sb = null;
                    if (verbose != null) {
                        sb = new StringBuffer();
                        boolean inManifest =
                            ((man.getAttributes(name) != null) ||
                             (man.getAttributes(&quot;./&quot;+name) != null) ||
                             (man.getAttributes(&quot;/&quot;+name) != null));
                        sb.append(
                          (isSigned ? rb.getString(&quot;s&quot;) : rb.getString(&quot;SPACE&quot;)) +
                          (inManifest ? rb.getString(&quot;m&quot;) : rb.getString(&quot;SPACE&quot;)) +
                          (inStore ? rb.getString(&quot;k&quot;) : rb.getString(&quot;SPACE&quot;)) +
                          (inScope ? rb.getString(&quot;i&quot;) : rb.getString(&quot;SPACE&quot;)) +
                          ((inStoreOrScope &amp; NOT_ALIAS) != 0 ?&quot;X&quot;:&quot; &quot;) +
                          rb.getString(&quot;SPACE&quot;));
                        sb.append(&quot;|&quot;);
                    }

                    // When -certs provided, display info has extra empty
                    // lines at the beginning and end.
                    if (isSigned) {
                        if (showcerts) sb.append('\n');
                        for (CodeSigner signer: signers) {
                            // signerInfo() must be called even if -verbose
                            // not provided. The method updates various
                            // warning flags.
                            String si = signerInfo(signer, tab);
                            if (showcerts) {
                                sb.append(si);
                                sb.append('\n');
                            }
                        }
                    } else if (showcerts &amp;&amp; !verbose.equals(&quot;all&quot;)) {
                        // Print no info for unsigned entries when -verbose:all,
                        // to be consistent with old behavior.
                        if (signatureRelated(name)) {
                            sb.append(&quot;\n&quot; + tab + rb.getString(
                                    &quot;.Signature.related.entries.&quot;) + &quot;\n\n&quot;);
                        } else {
                            sb.append(&quot;\n&quot; + tab + rb.getString(
                                    &quot;.Unsigned.entries.&quot;) + &quot;\n\n&quot;);
                        }
                    }

                    if (verbose != null) {
                        String label = sb.toString();
                        if (signatureRelated(name)) {
                            // Entries inside META-INF and other unsigned
                            // entries are grouped separately.
                            label = &quot;-&quot; + label;
                        }

                        // The label finally contains 2 parts separated by '|':
                        // The legend displayed before the entry names, and
                        // the cert info (if -certs specified).

                        if (!output.containsKey(label)) {
                            output.put(label, new ArrayList&lt;String&gt;());
                        }

                        StringBuffer fb = new StringBuffer();
                        String s = Long.toString(je.getSize());
                        for (int i = 6 - s.length(); i &gt; 0; --i) {
                            fb.append(' ');
                        }
                        fb.append(s).append(' ').
                                append(new Date(je.getTime()).toString());
                        fb.append(' ').append(name);

                        output.get(label).add(fb.toString());
                    }
                }
            }
            if (verbose != null) {
                for (Entry&lt;String,List&lt;String&gt;&gt; s: output.entrySet()) {
                    List&lt;String&gt; files = s.getValue();
                    String key = s.getKey();
                    if (key.charAt(0) == '-') { // the signature-related group
                        key = key.substring(1);
                    }
                    int pipe = key.indexOf('|');
                    if (verbose.equals(&quot;all&quot;)) {
                        for (String f: files) {
                            System.out.println(key.substring(0, pipe) + f);
                            System.out.printf(key.substring(pipe+1));
                        }
                    } else {
                        if (verbose.equals(&quot;grouped&quot;)) {
                            for (String f: files) {
                                System.out.println(key.substring(0, pipe) + f);
                            }
                        } else if (verbose.equals(&quot;summary&quot;)) {
                            System.out.print(key.substring(0, pipe));
                            if (files.size() &gt; 1) {
                                System.out.println(files.get(0) + &quot; &quot; +
                                        String.format(rb.getString(
                                        &quot;.and.d.more.&quot;), files.size()-1));
                            } else {
                                System.out.println(files.get(0));
                            }
                        }
                        System.out.printf(key.substring(pipe+1));
                    }
                }
                System.out.println();
                System.out.println(rb.getString(
                    &quot;.s.signature.was.verified.&quot;));
                System.out.println(rb.getString(
                    &quot;.m.entry.is.listed.in.manifest&quot;));
                System.out.println(rb.getString(
                    &quot;.k.at.least.one.certificate.was.found.in.keystore&quot;));
                System.out.println(rb.getString(
                    &quot;.i.at.least.one.certificate.was.found.in.identity.scope&quot;));
                if (ckaliases.size() &gt; 0) {
                    System.out.println(rb.getString(
                        &quot;.X.not.signed.by.specified.alias.es.&quot;));
                }
                System.out.println();
            }
            if (man == null)
                System.out.println(rb.getString(&quot;no.manifest.&quot;));

            if (!anySigned) {
                System.out.println(rb.getString(
                      &quot;jar.is.unsigned.signatures.missing.or.not.parsable.&quot;));
            } else {
                boolean warningAppeared = false;
                boolean errorAppeared = false;
                if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType ||
                        notYetValidCert || chainNotValidated || hasExpiredCert ||
                        hasUnsignedEntry ||
                        aliasNotInStore || notSignedByAlias) {

                    if (strict) {
                        System.out.println(rb.getString(&quot;jar.verified.with.signer.errors.&quot;));
                        System.out.println();
                        System.out.println(rb.getString(&quot;Error.&quot;));
                        errorAppeared = true;
                    } else {
                        System.out.println(rb.getString(&quot;jar.verified.&quot;));
                        System.out.println();
                        System.out.println(rb.getString(&quot;Warning.&quot;));
                        warningAppeared = true;
                    }

                    if (badKeyUsage) {
                        System.out.println(
                            rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.&quot;));
                    }

                    if (badExtendedKeyUsage) {
                        System.out.println(
                            rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.&quot;));
                    }

                    if (badNetscapeCertType) {
                        System.out.println(
                            rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.&quot;));
                    }

                    if (hasUnsignedEntry) {
                        System.out.println(rb.getString(
                            &quot;This.jar.contains.unsigned.entries.which.have.not.been.integrity.checked.&quot;));
                    }
                    if (hasExpiredCert) {
                        System.out.println(rb.getString(
                            &quot;This.jar.contains.entries.whose.signer.certificate.has.expired.&quot;));
                    }
                    if (notYetValidCert) {
                        System.out.println(rb.getString(
                            &quot;This.jar.contains.entries.whose.signer.certificate.is.not.yet.valid.&quot;));
                    }

                    if (chainNotValidated) {
                        System.out.println(
                                rb.getString(&quot;This.jar.contains.entries.whose.certificate.chain.is.not.validated.&quot;));
                    }

                    if (notSignedByAlias) {
                        System.out.println(
                                rb.getString(&quot;This.jar.contains.signed.entries.which.is.not.signed.by.the.specified.alias.es.&quot;));
                    }

                    if (aliasNotInStore) {
                        System.out.println(rb.getString(&quot;This.jar.contains.signed.entries.that.s.not.signed.by.alias.in.this.keystore.&quot;));
                    }
                } else {
                    System.out.println(rb.getString(&quot;jar.verified.&quot;));
                }
                if (hasExpiringCert || noTimestamp) {
                    if (!warningAppeared) {
                        System.out.println();
                        System.out.println(rb.getString(&quot;Warning.&quot;));
                        warningAppeared = true;
                    }
                    if (hasExpiringCert) {
                        System.out.println(rb.getString(
                                &quot;This.jar.contains.entries.whose.signer.certificate.will.expire.within.six.months.&quot;));
                    }
                    if (noTimestamp) {
                        System.out.println(
                                String.format(rb.getString(&quot;no.timestamp.verifying&quot;), expireDate));
                    }
                }
                if (warningAppeared || errorAppeared) {
                    if (! (verbose != null &amp;&amp; showcerts)) {
                        System.out.println();
                        System.out.println(rb.getString(
                                &quot;Re.run.with.the.verbose.and.certs.options.for.more.details.&quot;));
                    }
                }
            }
            return;
        } catch (Exception e) {
            System.out.println(rb.getString(&quot;jarsigner.&quot;) + e);
            if (debug) {
                e.printStackTrace();
            }
        } finally { // close the resource
            if (jf != null) {
                jf.close();
            }
        }

        System.exit(1);
    }

    private static MessageFormat validityTimeForm = null;
    private static MessageFormat notYetTimeForm = null;
    private static MessageFormat expiredTimeForm = null;
    private static MessageFormat expiringTimeForm = null;

    /*
     * Display some details about a certificate:
     *
     * [&lt;tab&gt;] &lt;cert-type&gt; [&quot;, &quot; &lt;subject-DN&gt;] [&quot; (&quot; &lt;keystore-entry-alias&gt; &quot;)&quot;]
     * [&lt;validity-period&gt; | &lt;expiry-warning&gt;]
     *
     * Note: no newline character at the end
     */
    String printCert(String tab, Certificate c, boolean checkValidityPeriod,
        Date timestamp, boolean checkUsage) {

        StringBuilder certStr = new StringBuilder();
        String space = rb.getString(&quot;SPACE&quot;);
        X509Certificate x509Cert = null;

        if (c instanceof X509Certificate) {
            x509Cert = (X509Certificate) c;
            certStr.append(tab).append(x509Cert.getType())
                .append(rb.getString(&quot;COMMA&quot;))
                .append(x509Cert.getSubjectDN().getName());
        } else {
            certStr.append(tab).append(c.getType());
        }

        String alias = storeHash.get(c);
        if (alias != null) {
            certStr.append(space).append(alias);
        }

        if (checkValidityPeriod &amp;&amp; x509Cert != null) {

            certStr.append(&quot;\n&quot;).append(tab).append(&quot;[&quot;);
            Date notAfter = x509Cert.getNotAfter();
            try {
                boolean printValidity = true;
                if (timestamp == null) {
                    if (expireDate.getTime() == 0 || expireDate.after(notAfter)) {
                        expireDate = notAfter;
                    }
                    x509Cert.checkValidity();
                    // test if cert will expire within six months
                    if (notAfter.getTime() &lt; System.currentTimeMillis() + SIX_MONTHS) {
                        hasExpiringCert = true;
                        if (expiringTimeForm == null) {
                            expiringTimeForm = new MessageFormat(
                                rb.getString(&quot;certificate.will.expire.on&quot;));
                        }
                        Object[] source = { notAfter };
                        certStr.append(expiringTimeForm.format(source));
                        printValidity = false;
                    }
                } else {
                    x509Cert.checkValidity(timestamp);
                }
                if (printValidity) {
                    if (validityTimeForm == null) {
                        validityTimeForm = new MessageFormat(
                            rb.getString(&quot;certificate.is.valid.from&quot;));
                    }
                    Object[] source = { x509Cert.getNotBefore(), notAfter };
                    certStr.append(validityTimeForm.format(source));
                }
            } catch (CertificateExpiredException cee) {
                hasExpiredCert = true;

                if (expiredTimeForm == null) {
                    expiredTimeForm = new MessageFormat(
                        rb.getString(&quot;certificate.expired.on&quot;));
                }
                Object[] source = { notAfter };
                certStr.append(expiredTimeForm.format(source));

            } catch (CertificateNotYetValidException cnyve) {
                notYetValidCert = true;

                if (notYetTimeForm == null) {
                    notYetTimeForm = new MessageFormat(
                        rb.getString(&quot;certificate.is.not.valid.until&quot;));
                }
                Object[] source = { x509Cert.getNotBefore() };
                certStr.append(notYetTimeForm.format(source));
            }
            certStr.append(&quot;]&quot;);

            if (checkUsage) {
                boolean[] bad = new boolean[3];
                checkCertUsage(x509Cert, bad);
                if (bad[0] || bad[1] || bad[2]) {
                    String x = &quot;&quot;;
                    if (bad[0]) {
                        x =&quot;KeyUsage&quot;;
                    }
                    if (bad[1]) {
                        if (x.length() &gt; 0) x = x + &quot;, &quot;;
                        x = x + &quot;ExtendedKeyUsage&quot;;
                    }
                    if (bad[2]) {
                        if (x.length() &gt; 0) x = x + &quot;, &quot;;
                        x = x + &quot;NetscapeCertType&quot;;
                    }
                    certStr.append(&quot;\n&quot;).append(tab)
                        .append(MessageFormat.format(rb.getString(
                        &quot;.{0}.extension.does.not.support.code.signing.&quot;), x));
                }
            }
        }
        return certStr.toString();
    }

    private static MessageFormat signTimeForm = null;

    private String printTimestamp(String tab, Timestamp timestamp) {

        if (signTimeForm == null) {
            signTimeForm =
                new MessageFormat(rb.getString(&quot;entry.was.signed.on&quot;));
        }
        Object[] source = { timestamp.getTimestamp() };

        return new StringBuilder().append(tab).append(&quot;[&quot;)
            .append(signTimeForm.format(source)).append(&quot;]&quot;).toString();
    }

    private Map&lt;CodeSigner,Integer&gt; cacheForInKS = new IdentityHashMap&lt;&gt;();

    private int inKeyStoreForOneSigner(CodeSigner signer) {
        if (cacheForInKS.containsKey(signer)) {
            return cacheForInKS.get(signer);
        }

        boolean found = false;
        int result = 0;
        List&lt;? extends Certificate&gt; certs = signer.getSignerCertPath().getCertificates();
        for (Certificate c : certs) {
            String alias = storeHash.get(c);
            if (alias != null) {
                if (alias.startsWith(&quot;(&quot;)) {
                    result |= IN_KEYSTORE;
                } else if (alias.startsWith(&quot;[&quot;)) {
                    result |= IN_SCOPE;
                }
                if (ckaliases.contains(alias.substring(1, alias.length() - 1))) {
                    result |= SIGNED_BY_ALIAS;
                }
            } else {
                if (store != null) {
                    try {
                        alias = store.getCertificateAlias(c);
                    } catch (KeyStoreException kse) {
                        // never happens, because keystore has been loaded
                    }
                    if (alias != null) {
                        storeHash.put(c, &quot;(&quot; + alias + &quot;)&quot;);
                        found = true;
                        result |= IN_KEYSTORE;
                    }
                }
                if (ckaliases.contains(alias)) {
                    result |= SIGNED_BY_ALIAS;
                }
            }
        }
        cacheForInKS.put(signer, result);
        return result;
    }

    Hashtable&lt;Certificate, String&gt; storeHash = new Hashtable&lt;&gt;();

    int inKeyStore(CodeSigner[] signers) {

        if (signers == null)
            return 0;

        int output = 0;

        for (CodeSigner signer: signers) {
            int result = inKeyStoreForOneSigner(signer);
            output |= result;
        }
        if (ckaliases.size() &gt; 0 &amp;&amp; (output &amp; SIGNED_BY_ALIAS) == 0) {
            output |= NOT_ALIAS;
        }
        return output;
    }

    void signJar(String jarName, String alias, String[] args)
        throws Exception {
        boolean aliasUsed = false;
        X509Certificate tsaCert = null;

        if (sigfile == null) {
            sigfile = alias;
            aliasUsed = true;
        }

        if (sigfile.length() &gt; 8) {
            sigfile = sigfile.substring(0, 8).toUpperCase(Locale.ENGLISH);
        } else {
            sigfile = sigfile.toUpperCase(Locale.ENGLISH);
        }

        StringBuilder tmpSigFile = new StringBuilder(sigfile.length());
        for (int j = 0; j &lt; sigfile.length(); j++) {
            char c = sigfile.charAt(j);
            if (!
                ((c&gt;= 'A' &amp;&amp; c&lt;= 'Z') ||
                (c&gt;= '0' &amp;&amp; c&lt;= '9') ||
                (c == '-') ||
                (c == '_'))) {
                if (aliasUsed) {
                    // convert illegal characters from the alias to be _'s
                    c = '_';
                } else {
                 throw new
                   RuntimeException(rb.getString
                        (&quot;signature.filename.must.consist.of.the.following.characters.A.Z.0.9.or.&quot;));
                }
            }
            tmpSigFile.append(c);
        }

        sigfile = tmpSigFile.toString();

        String tmpJarName;
        if (signedjar == null) tmpJarName = jarName+&quot;.sig&quot;;
        else tmpJarName = signedjar;

        File jarFile = new File(jarName);
        File signedJarFile = new File(tmpJarName);

        // Open the jar (zip) file
        try {
            zipFile = new ZipFile(jarName);
        } catch (IOException ioe) {
            error(rb.getString(&quot;unable.to.open.jar.file.&quot;)+jarName, ioe);
        }

        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(signedJarFile);
        } catch (IOException ioe) {
            error(rb.getString(&quot;unable.to.create.&quot;)+tmpJarName, ioe);
        }

        PrintStream ps = new PrintStream(fos);
        ZipOutputStream zos = new ZipOutputStream(ps);

        /* First guess at what they might be - we don't xclude RSA ones. */
        String sfFilename = (META_INF + sigfile + &quot;.SF&quot;).toUpperCase(Locale.ENGLISH);
        String bkFilename = (META_INF + sigfile + &quot;.DSA&quot;).toUpperCase(Locale.ENGLISH);

        Manifest manifest = new Manifest();
        Map&lt;String,Attributes&gt; mfEntries = manifest.getEntries();

        // The Attributes of manifest before updating
        Attributes oldAttr = null;

        boolean mfModified = false;
        boolean mfCreated = false;
        byte[] mfRawBytes = null;

        try {
            MessageDigest digests[] = { MessageDigest.getInstance(digestalg) };

            // Check if manifest exists
            ZipEntry mfFile;
            if ((mfFile = getManifestFile(zipFile)) != null) {
                // Manifest exists. Read its raw bytes.
                mfRawBytes = getBytes(zipFile, mfFile);
                manifest.read(new ByteArrayInputStream(mfRawBytes));
                oldAttr = (Attributes)(manifest.getMainAttributes().clone());
            } else {
                // Create new manifest
                Attributes mattr = manifest.getMainAttributes();
                mattr.putValue(Attributes.Name.MANIFEST_VERSION.toString(),
                               &quot;1.0&quot;);
                String javaVendor = System.getProperty(&quot;java.vendor&quot;);
                String jdkVersion = System.getProperty(&quot;java.version&quot;);
                mattr.putValue(&quot;Created-By&quot;, jdkVersion + &quot; (&quot; +javaVendor
                               + &quot;)&quot;);
                mfFile = new ZipEntry(JarFile.MANIFEST_NAME);
                mfCreated = true;
            }

            /*
             * For each entry in jar
             * (except for signature-related META-INF entries),
             * do the following:
             *
             * - if entry is not contained in manifest, add it to manifest;
             * - if entry is contained in manifest, calculate its hash and
             *   compare it with the one in the manifest; if they are
             *   different, replace the hash in the manifest with the newly
             *   generated one. (This may invalidate existing signatures!)
             */
            Vector&lt;ZipEntry&gt; mfFiles = new Vector&lt;&gt;();

            boolean wasSigned = false;

            for (Enumeration&lt;? extends ZipEntry&gt; enum_=zipFile.entries();
                        enum_.hasMoreElements();) {
                ZipEntry ze = enum_.nextElement();

                if (ze.getName().startsWith(META_INF)) {
                    // Store META-INF files in vector, so they can be written
                    // out first
                    mfFiles.addElement(ze);

                    if (SignatureFileVerifier.isBlockOrSF(
                            ze.getName().toUpperCase(Locale.ENGLISH))) {
                        wasSigned = true;
                    }

                    if (signatureRelated(ze.getName())) {
                        // ignore signature-related and manifest files
                        continue;
                    }
                }

                if (manifest.getAttributes(ze.getName()) != null) {
                    // jar entry is contained in manifest, check and
                    // possibly update its digest attributes
                    if (updateDigests(ze, zipFile, digests,
                                      manifest) == true) {
                        mfModified = true;
                    }
                } else if (!ze.isDirectory()) {
                    // Add entry to manifest
                    Attributes attrs = getDigestAttributes(ze, zipFile,
                                                           digests);
                    mfEntries.put(ze.getName(), attrs);
                    mfModified = true;
                }
            }

            // Recalculate the manifest raw bytes if necessary
            if (mfModified) {
                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                manifest.write(baos);
                if (wasSigned) {
                    byte[] newBytes = baos.toByteArray();
                    if (mfRawBytes != null
                            &amp;&amp; oldAttr.equals(manifest.getMainAttributes())) {

                        /*
                         * Note:
                         *
                         * The Attributes object is based on HashMap and can handle
                         * continuation columns. Therefore, even if the contents are
                         * not changed (in a Map view), the bytes that it write()
                         * may be different from the original bytes that it read()
                         * from. Since the signature on the main attributes is based
                         * on raw bytes, we must retain the exact bytes.
                         */

                        int newPos = findHeaderEnd(newBytes);
                        int oldPos = findHeaderEnd(mfRawBytes);

                        if (newPos == oldPos) {
                            System.arraycopy(mfRawBytes, 0, newBytes, 0, oldPos);
                        } else {
                            // cat oldHead newTail &gt; newBytes
                            byte[] lastBytes = new byte[oldPos +
                                    newBytes.length - newPos];
                            System.arraycopy(mfRawBytes, 0, lastBytes, 0, oldPos);
                            System.arraycopy(newBytes, newPos, lastBytes, oldPos,
                                    newBytes.length - newPos);
                            newBytes = lastBytes;
                        }
                    }
                    mfRawBytes = newBytes;
                } else {
                    mfRawBytes = baos.toByteArray();
                }
            }

            // Write out the manifest
            if (mfModified) {
                // manifest file has new length
                mfFile = new ZipEntry(JarFile.MANIFEST_NAME);
            }
            if (verbose != null) {
                if (mfCreated) {
                    System.out.println(rb.getString(&quot;.adding.&quot;) +
                                        mfFile.getName());
                } else if (mfModified) {
                    System.out.println(rb.getString(&quot;.updating.&quot;) +
                                        mfFile.getName());
                }
            }
            zos.putNextEntry(mfFile);
            zos.write(mfRawBytes);

            // Calculate SignatureFile (&quot;.SF&quot;) and SignatureBlockFile
            ManifestDigester manDig = new ManifestDigester(mfRawBytes);
            SignatureFile sf = new SignatureFile(digests, manifest, manDig,
                                                 sigfile, signManifest);

            if (tsaAlias != null) {
                tsaCert = getTsaCert(tsaAlias);
            }

            if (tsaUrl == null &amp;&amp; tsaCert == null) {
                noTimestamp = true;
            }

            SignatureFile.Block block = null;

            try {
                block =
                    sf.generateBlock(privateKey, sigalg, certChain,
                        externalSF, tsaUrl, tsaCert, tSAPolicyID, signingMechanism, args,
                        zipFile);
            } catch (SocketTimeoutException e) {
                // Provide a helpful message when TSA is beyond a firewall
                error(rb.getString(&quot;unable.to.sign.jar.&quot;) +
                rb.getString(&quot;no.response.from.the.Timestamping.Authority.&quot;) +
                &quot;\n  -J-Dhttp.proxyHost=&lt;hostname&gt;&quot; +
                &quot;\n  -J-Dhttp.proxyPort=&lt;portnumber&gt;\n&quot; +
                rb.getString(&quot;or&quot;) +
                &quot;\n  -J-Dhttps.proxyHost=&lt;hostname&gt; &quot; +
                &quot;\n  -J-Dhttps.proxyPort=&lt;portnumber&gt; &quot;, e);
            }

            sfFilename = sf.getMetaName();
            bkFilename = block.getMetaName();

            ZipEntry sfFile = new ZipEntry(sfFilename);
            ZipEntry bkFile = new ZipEntry(bkFilename);

            long time = System.currentTimeMillis();
            sfFile.setTime(time);
            bkFile.setTime(time);

            // signature file
            zos.putNextEntry(sfFile);
            sf.write(zos);
            if (verbose != null) {
                if (zipFile.getEntry(sfFilename) != null) {
                    System.out.println(rb.getString(&quot;.updating.&quot;) +
                                sfFilename);
                } else {
                    System.out.println(rb.getString(&quot;.adding.&quot;) +
                                sfFilename);
                }
            }

            if (verbose != null) {
                if (tsaUrl != null || tsaCert != null) {
                    System.out.println(
                        rb.getString(&quot;requesting.a.signature.timestamp&quot;));
                }
                if (tsaUrl != null) {
                    System.out.println(rb.getString(&quot;TSA.location.&quot;) + tsaUrl);
                }
                if (tsaCert != null) {
                    URI tsaURI = TimestampedSigner.getTimestampingURI(tsaCert);
                    if (tsaURI != null) {
                        System.out.println(rb.getString(&quot;TSA.location.&quot;) +
                            tsaURI);
                    }
                    System.out.println(rb.getString(&quot;TSA.certificate.&quot;) +
                        printCert(&quot;&quot;, tsaCert, false, null, false));
                }
                if (signingMechanism != null) {
                    System.out.println(
                        rb.getString(&quot;using.an.alternative.signing.mechanism&quot;));
                }
            }

            // signature block file
            zos.putNextEntry(bkFile);
            block.write(zos);
            if (verbose != null) {
                if (zipFile.getEntry(bkFilename) != null) {
                    System.out.println(rb.getString(&quot;.updating.&quot;) +
                        bkFilename);
                } else {
                    System.out.println(rb.getString(&quot;.adding.&quot;) +
                        bkFilename);
                }
            }

            // Write out all other META-INF files that we stored in the
            // vector
            for (int i=0; i&lt;mfFiles.size(); i++) {
                ZipEntry ze = mfFiles.elementAt(i);
                if (!ze.getName().equalsIgnoreCase(JarFile.MANIFEST_NAME)
                    &amp;&amp; !ze.getName().equalsIgnoreCase(sfFilename)
                    &amp;&amp; !ze.getName().equalsIgnoreCase(bkFilename)) {
                    writeEntry(zipFile, zos, ze);
                }
            }

            // Write out all other files
            for (Enumeration&lt;? extends ZipEntry&gt; enum_=zipFile.entries();
                        enum_.hasMoreElements();) {
                ZipEntry ze = enum_.nextElement();

                if (!ze.getName().startsWith(META_INF)) {
                    if (verbose != null) {
                        if (manifest.getAttributes(ze.getName()) != null)
                          System.out.println(rb.getString(&quot;.signing.&quot;) +
                                ze.getName());
                        else
                          System.out.println(rb.getString(&quot;.adding.&quot;) +
                                ze.getName());
                    }
                    writeEntry(zipFile, zos, ze);
                }
            }
        } catch(IOException ioe) {
            error(rb.getString(&quot;unable.to.sign.jar.&quot;)+ioe, ioe);
        } finally {
            // close the resouces
            if (zipFile != null) {
                zipFile.close();
                zipFile = null;
            }

            if (zos != null) {
                zos.close();
            }
        }

        // no IOException thrown in the follow try clause, so disable
        // the try clause.
        // try {
            if (signedjar == null) {
                // attempt an atomic rename. If that fails,
                // rename the original jar file, then the signed
                // one, then delete the original.
                if (!signedJarFile.renameTo(jarFile)) {
                    File origJar = new File(jarName+&quot;.orig&quot;);

                    if (jarFile.renameTo(origJar)) {
                        if (signedJarFile.renameTo(jarFile)) {
                            origJar.delete();
                        } else {
                            MessageFormat form = new MessageFormat(rb.getString
                        (&quot;attempt.to.rename.signedJarFile.to.jarFile.failed&quot;));
                            Object[] source = {signedJarFile, jarFile};
                            error(form.format(source));
                        }
                    } else {
                        MessageFormat form = new MessageFormat(rb.getString
                            (&quot;attempt.to.rename.jarFile.to.origJar.failed&quot;));
                        Object[] source = {jarFile, origJar};
                        error(form.format(source));
                    }
                }
            }

            boolean warningAppeared = false;
            if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType ||
                    notYetValidCert || chainNotValidated || hasExpiredCert) {
                if (strict) {
                    System.out.println(rb.getString(&quot;jar.signed.with.signer.errors.&quot;));
                    System.out.println();
                    System.out.println(rb.getString(&quot;Error.&quot;));
                } else {
                    System.out.println(rb.getString(&quot;jar.signed.&quot;));
                    System.out.println();
                    System.out.println(rb.getString(&quot;Warning.&quot;));
                    warningAppeared = true;
                }

                if (badKeyUsage) {
                    System.out.println(
                        rb.getString(&quot;The.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.&quot;));
                }

                if (badExtendedKeyUsage) {
                    System.out.println(
                        rb.getString(&quot;The.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.&quot;));
                }

                if (badNetscapeCertType) {
                    System.out.println(
                        rb.getString(&quot;The.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.&quot;));
                }

                if (hasExpiredCert) {
                    System.out.println(
                        rb.getString(&quot;The.signer.certificate.has.expired.&quot;));
                } else if (notYetValidCert) {
                    System.out.println(
                        rb.getString(&quot;The.signer.certificate.is.not.yet.valid.&quot;));
                }

                if (chainNotValidated) {
                    System.out.println(
                            rb.getString(&quot;The.signer.s.certificate.chain.is.not.validated.&quot;));
                }
            } else {
                System.out.println(rb.getString(&quot;jar.signed.&quot;));
            }
            if (hasExpiringCert || noTimestamp) {
                if (!warningAppeared) {
                    System.out.println();
                    System.out.println(rb.getString(&quot;Warning.&quot;));
                }

                if (hasExpiringCert) {
                    System.out.println(
                            rb.getString(&quot;The.signer.certificate.will.expire.within.six.months.&quot;));
                }

                if (noTimestamp) {
                    System.out.println(
                            String.format(rb.getString(&quot;no.timestamp.signing&quot;), expireDate));
                }
            }

        // no IOException thrown in the above try clause, so disable
        // the catch clause.
        // } catch(IOException ioe) {
        //     error(rb.getString(&quot;unable.to.sign.jar.&quot;)+ioe, ioe);
        // }
    }

    /**
     * Find the length of header inside bs. The header is a multiple (&gt;=0)
     * lines of attributes plus an empty line. The empty line is included
     * in the header.
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private int findHeaderEnd(byte[] bs) {
        // Initial state true to deal with empty header
        boolean newline = true;     // just met a newline
        int len = bs.length;
        for (int i=0; i&lt;len; i++) {
            switch (bs[i]) {
                case '\r':
                    if (i &lt; len - 1 &amp;&amp; bs[i+1] == '\n') i++;
                    // fallthrough
                case '\n':
                    if (newline) return i+1;    //+1 to get length
                    newline = true;
                    break;
                default:
                    newline = false;
            }
        }
        // If header end is not found, it means the MANIFEST.MF has only
        // the main attributes section and it does not end with 2 newlines.
        // Returns the whole length so that it can be completely replaced.
        return len;
    }

    /**
     * signature-related files include:
     * . META-INF/MANIFEST.MF
     * . META-INF/SIG-*
     * . META-INF/*.SF
     * . META-INF/*.DSA
     * . META-INF/*.RSA
     * . META-INF/*.EC
     */
    private boolean signatureRelated(String name) {
        String ucName = name.toUpperCase(Locale.ENGLISH);
        if (ucName.equals(JarFile.MANIFEST_NAME) ||
            ucName.equals(META_INF) ||
            (ucName.startsWith(SIG_PREFIX) &amp;&amp;
                ucName.indexOf(&quot;/&quot;) == ucName.lastIndexOf(&quot;/&quot;))) {
            return true;
        }

        if (ucName.startsWith(META_INF) &amp;&amp;
            SignatureFileVerifier.isBlockOrSF(ucName)) {
            // .SF/.DSA/.RSA/.EC files in META-INF subdirs
            // are not considered signature-related
            return (ucName.indexOf(&quot;/&quot;) == ucName.lastIndexOf(&quot;/&quot;));
        }

        return false;
    }

    Map&lt;CodeSigner,String&gt; cacheForSignerInfo = new IdentityHashMap&lt;&gt;();

    /**
     * Returns a string of singer info, with a newline at the end
     */
    private String signerInfo(CodeSigner signer, String tab) {
        if (cacheForSignerInfo.containsKey(signer)) {
            return cacheForSignerInfo.get(signer);
        }
        StringBuffer s = new StringBuffer();
        List&lt;? extends Certificate&gt; certs = signer.getSignerCertPath().getCertificates();
        // display the signature timestamp, if present
        Date timestamp;
        Timestamp ts = signer.getTimestamp();
        if (ts != null) {
            s.append(printTimestamp(tab, ts));
            s.append('\n');
            timestamp = ts.getTimestamp();
        } else {
            timestamp = null;
            noTimestamp = true;
        }
        // display the certificate(s). The first one is end-entity cert and
        // its KeyUsage should be checked.
        boolean first = true;
        for (Certificate c : certs) {
            s.append(printCert(tab, c, true, timestamp, first));
            s.append('\n');
            first = false;
        }
        try {
            CertPath cp = certificateFactory.generateCertPath(certs);
            validator.validate(cp, pkixParameters);
        } catch (Exception e) {
            if (debug) {
                e.printStackTrace();
            }
            if (e.getCause() != null &amp;&amp;
                    (e.getCause() instanceof CertificateExpiredException ||
                     e.getCause() instanceof CertificateNotYetValidException)) {
                // No more warning, we alreay have hasExpiredCert or notYetValidCert
            } else {
                chainNotValidated = true;
                s.append(tab + rb.getString(&quot;.CertPath.not.validated.&quot;) +
                        e.getLocalizedMessage() + &quot;]\n&quot;);   // TODO
            }
        }
        String result = s.toString();
        cacheForSignerInfo.put(signer, result);
        return result;
    }

    private void writeEntry(ZipFile zf, ZipOutputStream os, ZipEntry ze)
    throws IOException
    {
        ZipEntry ze2 = new ZipEntry(ze.getName());
        ze2.setMethod(ze.getMethod());
        ze2.setTime(ze.getTime());
        ze2.setComment(ze.getComment());
        ze2.setExtra(ze.getExtra());
        if (ze.getMethod() == ZipEntry.STORED) {
            ze2.setSize(ze.getSize());
            ze2.setCrc(ze.getCrc());
        }
        os.putNextEntry(ze2);
        writeBytes(zf, ze, os);
    }

    /**
     * Writes all the bytes for a given entry to the specified output stream.
     */
    private synchronized void writeBytes
        (ZipFile zf, ZipEntry ze, ZipOutputStream os) throws IOException {
        int n;

        InputStream is = null;
        try {
            is = zf.getInputStream(ze);
            long left = ze.getSize();

            while((left &gt; 0) &amp;&amp; (n = is.read(buffer, 0, buffer.length)) != -1) {
                os.write(buffer, 0, n);
                left -= n;
            }
        } finally {
            if (is != null) {
                is.close();
            }
        }
    }

    void loadKeyStore(String keyStoreName, boolean prompt) {

        if (!nullStream &amp;&amp; keyStoreName == null) {
            keyStoreName = System.getProperty(&quot;user.home&quot;) + File.separator
                + &quot;.keystore&quot;;
        }

        try {

            certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);
            validator = CertPathValidator.getInstance(&quot;PKIX&quot;);
            Set&lt;TrustAnchor&gt; tas = new HashSet&lt;&gt;();
            try {
                KeyStore caks = KeyStoreUtil.getCacertsKeyStore();
                if (caks != null) {
                    Enumeration&lt;String&gt; aliases = caks.aliases();
                    while (aliases.hasMoreElements()) {
                        String a = aliases.nextElement();
                        try {
                            tas.add(new TrustAnchor((X509Certificate)caks.getCertificate(a), null));
                        } catch (Exception e2) {
                            // ignore, when a SecretkeyEntry does not include a cert
                        }
                    }
                }
            } catch (Exception e) {
                // Ignore, if cacerts cannot be loaded
            }

            if (providerName == null) {
                store = KeyStore.getInstance(storetype);
            } else {
                store = KeyStore.getInstance(storetype, providerName);
            }

            // Get pass phrase
            // XXX need to disable echo; on UNIX, call getpass(char *prompt)Z
            // and on NT call ??
            if (token &amp;&amp; storepass == null &amp;&amp; !protectedPath
                    &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)) {
                storepass = getPass
                        (rb.getString(&quot;Enter.Passphrase.for.keystore.&quot;));
            } else if (!token &amp;&amp; storepass == null &amp;&amp; prompt) {
                storepass = getPass
                        (rb.getString(&quot;Enter.Passphrase.for.keystore.&quot;));
            }

            try {
                if (nullStream) {
                    store.load(null, storepass);
                } else {
                    keyStoreName = keyStoreName.replace(File.separatorChar, '/');
                    URL url = null;
                    try {
                        url = new URL(keyStoreName);
                    } catch (java.net.MalformedURLException e) {
                        // try as file
                        url = new File(keyStoreName).toURI().toURL();
                    }
                    InputStream is = null;
                    try {
                        is = url.openStream();
                        store.load(is, storepass);
                    } finally {
                        if (is != null) {
                            is.close();
                        }
                    }
                }
                Enumeration&lt;String&gt; aliases = store.aliases();
                while (aliases.hasMoreElements()) {
                    String a = aliases.nextElement();
                    try {
                        X509Certificate c = (X509Certificate)store.getCertificate(a);
                        // Only add TrustedCertificateEntry and self-signed
                        // PrivateKeyEntry
                        if (store.isCertificateEntry(a) ||
                                c.getSubjectDN().equals(c.getIssuerDN())) {
                            tas.add(new TrustAnchor(c, null));
                        }
                    } catch (Exception e2) {
                        // ignore, when a SecretkeyEntry does not include a cert
                    }
                }
            } finally {
                try {
                    pkixParameters = new PKIXParameters(tas);
                    pkixParameters.setRevocationEnabled(false);
                } catch (InvalidAlgorithmParameterException ex) {
                    // Only if tas is empty
                }
            }
        } catch (IOException ioe) {
            throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
                                        ioe.getMessage());
        } catch (java.security.cert.CertificateException ce) {
            throw new RuntimeException(rb.getString(&quot;certificate.exception.&quot;) +
                                        ce.getMessage());
        } catch (NoSuchProviderException pe) {
            throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
                                        pe.getMessage());
        } catch (NoSuchAlgorithmException nsae) {
            throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
                                        nsae.getMessage());
        } catch (KeyStoreException kse) {
            throw new RuntimeException
                (rb.getString(&quot;unable.to.instantiate.keystore.class.&quot;) +
                kse.getMessage());
        }
    }

    X509Certificate getTsaCert(String alias) {

        java.security.cert.Certificate cs = null;

        try {
            cs = store.getCertificate(alias);
        } catch (KeyStoreException kse) {
            // this never happens, because keystore has been loaded
        }
        if (cs == null || (!(cs instanceof X509Certificate))) {
            MessageFormat form = new MessageFormat(rb.getString
                (&quot;Certificate.not.found.for.alias.alias.must.reference.a.valid.KeyStore.entry.containing.an.X.509.public.key.certificate.for.the&quot;));
            Object[] source = {alias, alias};
            error(form.format(source));
        }
        return (X509Certificate) cs;
    }

    /**
     * Check if userCert is designed to be a code signer
     * @param userCert the certificate to be examined
     * @param bad 3 booleans to show if the KeyUsage, ExtendedKeyUsage,
     *            NetscapeCertType has codeSigning flag turned on.
     *            If null, the class field badKeyUsage, badExtendedKeyUsage,
     *            badNetscapeCertType will be set.
     */
    void checkCertUsage(X509Certificate userCert, boolean[] bad) {

        // Can act as a signer?
        // 1. if KeyUsage, then [0:digitalSignature] or
        //    [1:nonRepudiation] should be true
        // 2. if ExtendedKeyUsage, then should contains ANY or CODE_SIGNING
        // 3. if NetscapeCertType, then should contains OBJECT_SIGNING
        // 1,2,3 must be true

        if (bad != null) {
            bad[0] = bad[1] = bad[2] = false;
        }

        boolean[] keyUsage = userCert.getKeyUsage();
        if (keyUsage != null) {
            keyUsage = Arrays.copyOf(keyUsage, 9);
            if (!keyUsage[0] &amp;&amp; !keyUsage[1]) {
                if (bad != null) {
                    bad[0] = true;
                    badKeyUsage = true;
                }
            }
        }

        try {
            List&lt;String&gt; xKeyUsage = userCert.getExtendedKeyUsage();
            if (xKeyUsage != null) {
                if (!xKeyUsage.contains(&quot;2.5.29.37.0&quot;) // anyExtendedKeyUsage
                        &amp;&amp; !xKeyUsage.contains(&quot;1.3.6.1.5.5.7.3.3&quot;)) {  // codeSigning
                    if (bad != null) {
                        bad[1] = true;
                        badExtendedKeyUsage = true;
                    }
                }
            }
        } catch (java.security.cert.CertificateParsingException e) {
            // shouldn't happen
        }

        try {
            // OID_NETSCAPE_CERT_TYPE
            byte[] netscapeEx = userCert.getExtensionValue
                    (&quot;2.16.840.1.113730.1.1&quot;);
            if (netscapeEx != null) {
                DerInputStream in = new DerInputStream(netscapeEx);
                byte[] encoded = in.getOctetString();
                encoded = new DerValue(encoded).getUnalignedBitString()
                        .toByteArray();

                NetscapeCertTypeExtension extn =
                        new NetscapeCertTypeExtension(encoded);

                Boolean val = extn.get(NetscapeCertTypeExtension.OBJECT_SIGNING);
                if (!val) {
                    if (bad != null) {
                        bad[2] = true;
                        badNetscapeCertType = true;
                    }
                }
            }
        } catch (IOException e) {
            //
        }
    }

    void getAliasInfo(String alias) {

        Key key = null;

        try {
            java.security.cert.Certificate[] cs = null;
            if (altCertChain != null) {
                try (FileInputStream fis = new FileInputStream(altCertChain)) {
                    cs = CertificateFactory.getInstance(&quot;X.509&quot;).
                            generateCertificates(fis).
                            toArray(new Certificate[0]);
                } catch (FileNotFoundException ex) {
                    error(rb.getString(&quot;File.specified.by.certchain.does.not.exist&quot;));
                } catch (CertificateException | IOException ex) {
                    error(rb.getString(&quot;Cannot.restore.certchain.from.file.specified&quot;));
                }
            } else {
                try {
                    cs = store.getCertificateChain(alias);
                } catch (KeyStoreException kse) {
                    // this never happens, because keystore has been loaded
                }
            }
            if (cs == null || cs.length == 0) {
                if (altCertChain != null) {
                    error(rb.getString
                            (&quot;Certificate.chain.not.found.in.the.file.specified.&quot;));
                } else {
                    MessageFormat form = new MessageFormat(rb.getString
                        (&quot;Certificate.chain.not.found.for.alias.alias.must.reference.a.valid.KeyStore.key.entry.containing.a.private.key.and&quot;));
                    Object[] source = {alias, alias};
                    error(form.format(source));
                }
            }

            certChain = new X509Certificate[cs.length];
            for (int i=0; i&lt;cs.length; i++) {
                if (!(cs[i] instanceof X509Certificate)) {
                    error(rb.getString
                        (&quot;found.non.X.509.certificate.in.signer.s.chain&quot;));
                }
                certChain[i] = (X509Certificate)cs[i];
            }

            // We don't meant to print anything, the next call
            // checks validity and keyUsage etc
            printCert(&quot;&quot;, certChain[0], true, null, true);

            try {
                CertPath cp = certificateFactory.generateCertPath(Arrays.asList(certChain));
                validator.validate(cp, pkixParameters);
            } catch (Exception e) {
                if (debug) {
                    e.printStackTrace();
                }
                if (e.getCause() != null &amp;&amp;
                        (e.getCause() instanceof CertificateExpiredException ||
                        e.getCause() instanceof CertificateNotYetValidException)) {
                    // No more warning, we alreay have hasExpiredCert or notYetValidCert
                } else {
                    chainNotValidated = true;
                }
            }

            try {
                if (!token &amp;&amp; keypass == null)
                    key = store.getKey(alias, storepass);
                else
                    key = store.getKey(alias, keypass);
            } catch (UnrecoverableKeyException e) {
                if (token) {
                    throw e;
                } else if (keypass == null) {
                    // Did not work out, so prompt user for key password
                    MessageFormat form = new MessageFormat(rb.getString
                        (&quot;Enter.key.password.for.alias.&quot;));
                    Object[] source = {alias};
                    keypass = getPass(form.format(source));
                    key = store.getKey(alias, keypass);
                }
            }
        } catch (NoSuchAlgorithmException e) {
            error(e.getMessage());
        } catch (UnrecoverableKeyException e) {
            error(rb.getString(&quot;unable.to.recover.key.from.keystore&quot;));
        } catch (KeyStoreException kse) {
            // this never happens, because keystore has been loaded
        }

        if (!(key instanceof PrivateKey)) {
            MessageFormat form = new MessageFormat(rb.getString
                (&quot;key.associated.with.alias.not.a.private.key&quot;));
            Object[] source = {alias};
            error(form.format(source));
        } else {
            privateKey = (PrivateKey)key;
        }
    }

    void error(String message)
    {
        System.out.println(rb.getString(&quot;jarsigner.&quot;)+message);
        System.exit(1);
    }


    void error(String message, Exception e)
    {
        System.out.println(rb.getString(&quot;jarsigner.&quot;)+message);
        if (debug) {
            e.printStackTrace();
        }
        System.exit(1);
    }

    char[] getPass(String prompt)
    {
        System.err.print(prompt);
        System.err.flush();
        try {
            char[] pass = Password.readPassword(System.in);

            if (pass == null) {
                error(rb.getString(&quot;you.must.enter.key.password&quot;));
            } else {
                return pass;
            }
        } catch (IOException ioe) {
            error(rb.getString(&quot;unable.to.read.password.&quot;)+ioe.getMessage());
        }
        // this shouldn't happen
        return null;
    }

    /*
     * Reads all the bytes for a given zip entry.
     */
    private synchronized byte[] getBytes(ZipFile zf,
                                         ZipEntry ze) throws IOException {
        int n;

        InputStream is = null;
        try {
            is = zf.getInputStream(ze);
            baos.reset();
            long left = ze.getSize();

            while((left &gt; 0) &amp;&amp; (n = is.read(buffer, 0, buffer.length)) != -1) {
                baos.write(buffer, 0, n);
                left -= n;
            }
        } finally {
            if (is != null) {
                is.close();
            }
        }

        return baos.toByteArray();
    }

    /*
     * Returns manifest entry from given jar file, or null if given jar file
     * does not have a manifest entry.
     */
    private ZipEntry getManifestFile(ZipFile zf) {
        ZipEntry ze = zf.getEntry(JarFile.MANIFEST_NAME);
        if (ze == null) {
            // Check all entries for matching name
            Enumeration&lt;? extends ZipEntry&gt; enum_ = zf.entries();
            while (enum_.hasMoreElements() &amp;&amp; ze == null) {
                ze = enum_.nextElement();
                if (!JarFile.MANIFEST_NAME.equalsIgnoreCase
                    (ze.getName())) {
                    ze = null;
                }
            }
        }
        return ze;
    }

    /*
     * Computes the digests of a zip entry, and returns them as an array
     * of base64-encoded strings.
     */
    private synchronized String[] getDigests(ZipEntry ze, ZipFile zf,
                                             MessageDigest[] digests)
        throws IOException {

        int n, i;
        InputStream is = null;
        try {
            is = zf.getInputStream(ze);
            long left = ze.getSize();
            while((left &gt; 0)
                &amp;&amp; (n = is.read(buffer, 0, buffer.length)) != -1) {
                for (i=0; i&lt;digests.length; i++) {
                    digests[i].update(buffer, 0, n);
                }
                left -= n;
            }
        } finally {
            if (is != null) {
                is.close();
            }
        }

        // complete the digests
        String[] base64Digests = new String[digests.length];
        for (i=0; i&lt;digests.length; i++) {
            base64Digests[i] = Base64.getEncoder().encodeToString(digests[i].digest());
        }
        return base64Digests;
    }

    /*
     * Computes the digests of a zip entry, and returns them as a list of
     * attributes
     */
    private Attributes getDigestAttributes(ZipEntry ze, ZipFile zf,
                                           MessageDigest[] digests)
        throws IOException {

        String[] base64Digests = getDigests(ze, zf, digests);
        Attributes attrs = new Attributes();

        for (int i=0; i&lt;digests.length; i++) {
            attrs.putValue(digests[i].getAlgorithm()+&quot;-Digest&quot;,
                           base64Digests[i]);
        }
        return attrs;
    }

    /*
     * Updates the digest attributes of a manifest entry, by adding or
     * replacing digest values.
     * A digest value is added if the manifest entry does not contain a digest
     * for that particular algorithm.
     * A digest value is replaced if it is obsolete.
     *
     * Returns true if the manifest entry has been changed, and false
     * otherwise.
     */
    private boolean updateDigests(ZipEntry ze, ZipFile zf,
                                  MessageDigest[] digests,
                                  Manifest mf) throws IOException {
        boolean update = false;

        Attributes attrs = mf.getAttributes(ze.getName());
        String[] base64Digests = getDigests(ze, zf, digests);

        for (int i=0; i&lt;digests.length; i++) {
            // The entry name to be written into attrs
            String name = null;
            try {
                // Find if the digest already exists
                AlgorithmId aid = AlgorithmId.get(digests[i].getAlgorithm());
                for (Object key: attrs.keySet()) {
                    if (key instanceof Attributes.Name) {
                        String n = ((Attributes.Name)key).toString();
                        if (n.toUpperCase(Locale.ENGLISH).endsWith(&quot;-DIGEST&quot;)) {
                            String tmp = n.substring(0, n.length() - 7);
                            if (AlgorithmId.get(tmp).equals(aid)) {
                                name = n;
                                break;
                            }
                        }
                    }
                }
            } catch (NoSuchAlgorithmException nsae) {
                // Ignored. Writing new digest entry.
            }

            if (name == null) {
                name = digests[i].getAlgorithm()+&quot;-Digest&quot;;
                attrs.putValue(name, base64Digests[i]);
                update=true;
            } else {
                // compare digests, and replace the one in the manifest
                // if they are different
                String mfDigest = attrs.getValue(name);
                if (!mfDigest.equalsIgnoreCase(base64Digests[i])) {
                    attrs.putValue(name, base64Digests[i]);
                    update=true;
                }
            }
        }
        return update;
    }

    /*
     * Try to load the specified signing mechanism.
     * The URL class loader is used.
     */
    private ContentSigner loadSigningMechanism(String signerClassName,
        String signerClassPath) throws Exception {

        // construct class loader
        String cpString = null;   // make sure env.class.path defaults to dot

        // do prepends to get correct ordering
        cpString = PathList.appendPath(System.getProperty(&quot;env.class.path&quot;), cpString);
        cpString = PathList.appendPath(System.getProperty(&quot;java.class.path&quot;), cpString);
        cpString = PathList.appendPath(signerClassPath, cpString);
        URL[] urls = PathList.pathToURLs(cpString);
        ClassLoader appClassLoader = new URLClassLoader(urls);

        // attempt to find signer
        Class&lt;?&gt; signerClass = appClassLoader.loadClass(signerClassName);

        // Check that it implements ContentSigner
        Object signer = signerClass.newInstance();
        if (!(signer instanceof ContentSigner)) {
            MessageFormat form = new MessageFormat(
                rb.getString(&quot;signerClass.is.not.a.signing.mechanism&quot;));
            Object[] source = {signerClass.getName()};
            throw new IllegalArgumentException(form.format(source));
        }
        return (ContentSigner)signer;
    }
}

class SignatureFile {

    /** SignatureFile */
    Manifest sf;

    /** .SF base name */
    String baseName;

    public SignatureFile(MessageDigest digests[],
                         Manifest mf,
                         ManifestDigester md,
                         String baseName,
                         boolean signManifest)

    {
        this.baseName = baseName;

        String version = System.getProperty(&quot;java.version&quot;);
        String javaVendor = System.getProperty(&quot;java.vendor&quot;);

        sf = new Manifest();
        Attributes mattr = sf.getMainAttributes();

        mattr.putValue(Attributes.Name.SIGNATURE_VERSION.toString(), &quot;1.0&quot;);
        mattr.putValue(&quot;Created-By&quot;, version + &quot; (&quot; + javaVendor + &quot;)&quot;);

        if (signManifest) {
            // sign the whole manifest
            for (int i=0; i &lt; digests.length; i++) {
                mattr.putValue(digests[i].getAlgorithm()+&quot;-Digest-Manifest&quot;,
                               Base64.getEncoder().encodeToString(md.manifestDigest(digests[i])));
            }
        }

        // create digest of the manifest main attributes
        ManifestDigester.Entry mde =
                md.get(ManifestDigester.MF_MAIN_ATTRS, false);
        if (mde != null) {
            for (int i=0; i &lt; digests.length; i++) {
                mattr.putValue(digests[i].getAlgorithm() +
                        &quot;-Digest-&quot; + ManifestDigester.MF_MAIN_ATTRS,
                        Base64.getEncoder().encodeToString(mde.digest(digests[i])));
            }
        } else {
            throw new IllegalStateException
                (&quot;ManifestDigester failed to create &quot; +
                &quot;Manifest-Main-Attribute entry&quot;);
        }

        /* go through the manifest entries and create the digests */

        Map&lt;String,Attributes&gt; entries = sf.getEntries();
        Iterator&lt;Map.Entry&lt;String,Attributes&gt;&gt; mit =
                                mf.getEntries().entrySet().iterator();
        while(mit.hasNext()) {
            Map.Entry&lt;String,Attributes&gt; e = mit.next();
            String name = e.getKey();
            mde = md.get(name, false);
            if (mde != null) {
                Attributes attr = new Attributes();
                for (int i=0; i &lt; digests.length; i++) {
                    attr.putValue(digests[i].getAlgorithm()+&quot;-Digest&quot;,
                                  Base64.getEncoder().encodeToString(mde.digest(digests[i])));
                }
                entries.put(name, attr);
            }
        }
    }

    /**
     * Writes the SignatureFile to the specified OutputStream.
     *
     * @param out the output stream
     * @exception IOException if an I/O error has occurred
     */

    public void write(OutputStream out) throws IOException
    {
        sf.write(out);
    }

    /**
     * get .SF file name
     */
    public String getMetaName()
    {
        return &quot;META-INF/&quot;+ baseName + &quot;.SF&quot;;
    }

    /**
     * get base file name
     */
    public String getBaseName()
    {
        return baseName;
    }

    /*
     * Generate a signed data block.
     * If a URL or a certificate (containing a URL) for a Timestamping
     * Authority is supplied then a signature timestamp is generated and
     * inserted into the signed data block.
     *
     * @param sigalg signature algorithm to use, or null to use default
     * @param tsaUrl The location of the Timestamping Authority. If null
     *               then no timestamp is requested.
     * @param tsaCert The certificate for the Timestamping Authority. If null
     *               then no timestamp is requested.
     * @param signingMechanism The signing mechanism to use.
     * @param args The command-line arguments to jarsigner.
     * @param zipFile The original source Zip file.
     */
    public Block generateBlock(PrivateKey privateKey,
                               String sigalg,
                               X509Certificate[] certChain,
                               boolean externalSF, String tsaUrl,
                               X509Certificate tsaCert,
                               String tSAPolicyID,
                               ContentSigner signingMechanism,
                               String[] args, ZipFile zipFile)
        throws NoSuchAlgorithmException, InvalidKeyException, IOException,
            SignatureException, CertificateException
    {
        return new Block(this, privateKey, sigalg, certChain, externalSF,
                tsaUrl, tsaCert, tSAPolicyID, signingMechanism, args, zipFile);
    }


    public static class Block {

        private byte[] block;
        private String blockFileName;

        /*
         * Construct a new signature block.
         */
        Block(SignatureFile sfg, PrivateKey privateKey, String sigalg,
            X509Certificate[] certChain, boolean externalSF, String tsaUrl,
            X509Certificate tsaCert, String tSAPolicyID, ContentSigner signingMechanism,
            String[] args, ZipFile zipFile)
            throws NoSuchAlgorithmException, InvalidKeyException, IOException,
            SignatureException, CertificateException {

            Principal issuerName = certChain[0].getIssuerDN();
            if (!(issuerName instanceof X500Name)) {
                // must extract the original encoded form of DN for subsequent
                // name comparison checks (converting to a String and back to
                // an encoded DN could cause the types of String attribute
                // values to be changed)
                X509CertInfo tbsCert = new
                    X509CertInfo(certChain[0].getTBSCertificate());
                issuerName = (Principal)
                    tbsCert.get(X509CertInfo.ISSUER + &quot;.&quot; +
                                X509CertInfo.DN_NAME);
                }
            BigInteger serial = certChain[0].getSerialNumber();

            String signatureAlgorithm;
            String keyAlgorithm = privateKey.getAlgorithm();
            /*
             * If no signature algorithm was specified, we choose a
             * default that is compatible with the private key algorithm.
             */
            if (sigalg == null) {

                if (keyAlgorithm.equalsIgnoreCase(&quot;DSA&quot;))
                    signatureAlgorithm = &quot;SHA1withDSA&quot;;
                else if (keyAlgorithm.equalsIgnoreCase(&quot;RSA&quot;))
                    signatureAlgorithm = &quot;SHA256withRSA&quot;;
                else if (keyAlgorithm.equalsIgnoreCase(&quot;EC&quot;))
                    signatureAlgorithm = &quot;SHA256withECDSA&quot;;
                else
                    throw new RuntimeException(&quot;private key is not a DSA or &quot;
                                               + &quot;RSA key&quot;);
            } else {
                signatureAlgorithm = sigalg;
            }

            // check common invalid key/signature algorithm combinations
            String sigAlgUpperCase = signatureAlgorithm.toUpperCase(Locale.ENGLISH);
            if ((sigAlgUpperCase.endsWith(&quot;WITHRSA&quot;) &amp;&amp;
                !keyAlgorithm.equalsIgnoreCase(&quot;RSA&quot;)) ||
                (sigAlgUpperCase.endsWith(&quot;WITHECDSA&quot;) &amp;&amp;
                !keyAlgorithm.equalsIgnoreCase(&quot;EC&quot;)) ||
                (sigAlgUpperCase.endsWith(&quot;WITHDSA&quot;) &amp;&amp;
                !keyAlgorithm.equalsIgnoreCase(&quot;DSA&quot;))) {
                throw new SignatureException
                    (&quot;private key algorithm is not compatible with signature algorithm&quot;);
            }

            blockFileName = &quot;META-INF/&quot;+sfg.getBaseName()+&quot;.&quot;+keyAlgorithm;

            AlgorithmId sigAlg = AlgorithmId.get(signatureAlgorithm);
            AlgorithmId digEncrAlg = AlgorithmId.get(keyAlgorithm);

            Signature sig = Signature.getInstance(signatureAlgorithm);
            sig.initSign(privateKey);

            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            sfg.write(baos);

            byte[] content = baos.toByteArray();

            sig.update(content);
            byte[] signature = sig.sign();

            // Timestamp the signature and generate the signature block file
            if (signingMechanism == null) {
                signingMechanism = new TimestampedSigner();
            }
            URI tsaUri = null;
            try {
                if (tsaUrl != null) {
                    tsaUri = new URI(tsaUrl);
                }
            } catch (URISyntaxException e) {
                throw new IOException(e);
            }

            // Assemble parameters for the signing mechanism
            ContentSignerParameters params =
                new JarSignerParameters(args, tsaUri, tsaCert, tSAPolicyID, signature,
                    signatureAlgorithm, certChain, content, zipFile);

            // Generate the signature block
            block = signingMechanism.generateSignedData(
                    params, externalSF, (tsaUrl != null || tsaCert != null));
        }

        /*
         * get block file name.
         */
        public String getMetaName()
        {
            return blockFileName;
        }

        /**
         * Writes the block file to the specified OutputStream.
         *
         * @param out the output stream
         * @exception IOException if an I/O error has occurred
         */

        public void write(OutputStream out) throws IOException
        {
            out.write(block);
        }
    }
}


/*
 * This object encapsulates the parameters used to perform content signing.
 */
class JarSignerParameters implements ContentSignerParameters {

    private String[] args;
    private URI tsa;
    private X509Certificate tsaCertificate;
    private byte[] signature;
    private String signatureAlgorithm;
    private X509Certificate[] signerCertificateChain;
    private byte[] content;
    private ZipFile source;
    private String tSAPolicyID;

    /**
     * Create a new object.
     */
    JarSignerParameters(String[] args, URI tsa, X509Certificate tsaCertificate,
        String tSAPolicyID,
        byte[] signature, String signatureAlgorithm,
        X509Certificate[] signerCertificateChain, byte[] content,
        ZipFile source) {

        if (signature == null || signatureAlgorithm == null ||
            signerCertificateChain == null) {
            throw new NullPointerException();
        }
        this.args = args;
        this.tsa = tsa;
        this.tsaCertificate = tsaCertificate;
        this.tSAPolicyID = tSAPolicyID;
        this.signature = signature;
        this.signatureAlgorithm = signatureAlgorithm;
        this.signerCertificateChain = signerCertificateChain;
        this.content = content;
        this.source = source;
    }

    /**
     * Retrieves the command-line arguments.
     *
     * @return The command-line arguments. May be null.
     */
    public String[] getCommandLine() {
        return args;
    }

    /**
     * Retrieves the identifier for a Timestamping Authority (TSA).
     *
     * @return The TSA identifier. May be null.
     */
    public URI getTimestampingAuthority() {
        return tsa;
    }

    /**
     * Retrieves the certificate for a Timestamping Authority (TSA).
     *
     * @return The TSA certificate. May be null.
     */
    public X509Certificate getTimestampingAuthorityCertificate() {
        return tsaCertificate;
    }

    public String getTSAPolicyID() {
        return tSAPolicyID;
    }

    /**
     * Retrieves the signature.
     *
     * @return The non-null signature bytes.
     */
    public byte[] getSignature() {
        return signature;
    }

    /**
     * Retrieves the name of the signature algorithm.
     *
     * @return The non-null string name of the signature algorithm.
     */
    public String getSignatureAlgorithm() {
        return signatureAlgorithm;
    }

    /**
     * Retrieves the signer's X.509 certificate chain.
     *
     * @return The non-null array of X.509 public-key certificates.
     */
    public X509Certificate[] getSignerCertificateChain() {
        return signerCertificateChain;
    }

    /**
     * Retrieves the content that was signed.
     *
     * @return The content bytes. May be null.
     */
    public byte[] getContent() {
        return content;
    }

    /**
     * Retrieves the original source ZIP file before it was signed.
     *
     * @return The original ZIP file. May be null.
     */
    public ZipFile getSource() {
        return source;
    }
}
</pre>
</body>
</html>
