<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.imageio.plugins.bmp;

import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.imageio.ImageTypeSpecifier;
import javax.imageio.metadata.IIOMetadata;
import javax.imageio.metadata.IIOMetadataNode;
import javax.imageio.metadata.IIOMetadataFormat;
import javax.imageio.metadata.IIOMetadataFormatImpl;
import org.w3c.dom.Node;
import com.sun.imageio.plugins.common.I18N;

import com.sun.imageio.plugins.common.ImageUtil;

public class BMPMetadata extends IIOMetadata implements BMPConstants {
    public static final String nativeMetadataFormatName =
        &quot;javax_imageio_bmp_1.0&quot;;

    // Fields for Image Descriptor
    public String bmpVersion;
    public int width ;
    public int height;
    public short bitsPerPixel;
    public int compression;
    public int imageSize;

    // Fields for PixelsPerMeter
    public int xPixelsPerMeter;
    public int yPixelsPerMeter;

    public int colorsUsed;
    public int colorsImportant;

    // Fields for BI_BITFIELDS compression(Mask)
    public int redMask;
    public int greenMask;
    public int blueMask;
    public int alphaMask;

    public int colorSpace;

    // Fields for CIE XYZ for the LCS_CALIBRATED_RGB color space
    public double redX;
    public double redY;
    public double redZ;
    public double greenX;
    public double greenY;
    public double greenZ;
    public double blueX;
    public double blueY;
    public double blueZ;

    // Fields for Gamma values for the LCS_CALIBRATED_RGB color space
    public int gammaRed;
    public int gammaGreen;
    public int gammaBlue;

    public int intent;

    // Fields for the Palette and Entries
    public byte[] palette = null;
    public int paletteSize;
    public int red;
    public int green;
    public int blue;

    // Fields from CommentExtension
    // List of byte[]
    public List comments = null; // new ArrayList();

    public BMPMetadata() {
        super(true,
              nativeMetadataFormatName,
              &quot;com.sun.imageio.plugins.bmp.BMPMetadataFormat&quot;,
              null, null);
    }

    public boolean isReadOnly() {
        return true;
    }

    public Node getAsTree(String formatName) {
        if (formatName.equals(nativeMetadataFormatName)) {
            return getNativeTree();
        } else if (formatName.equals
                   (IIOMetadataFormatImpl.standardMetadataFormatName)) {
            return getStandardTree();
        } else {
            throw new IllegalArgumentException(I18N.getString(&quot;BMPMetadata0&quot;));
        }
    }

    private String toISO8859(byte[] data) {
        try {
            return new String(data, &quot;ISO-8859-1&quot;);
        } catch (UnsupportedEncodingException e) {
            return &quot;&quot;;
        }
    }

    private Node getNativeTree() {
        IIOMetadataNode root =
            new IIOMetadataNode(nativeMetadataFormatName);

        addChildNode(root, &quot;BMPVersion&quot;, bmpVersion);
        addChildNode(root, &quot;Width&quot;, new Integer(width));
        addChildNode(root, &quot;Height&quot;, new Integer(height));
        addChildNode(root, &quot;BitsPerPixel&quot;, new Short(bitsPerPixel));
        addChildNode(root, &quot;Compression&quot;, new Integer(compression));
        addChildNode(root, &quot;ImageSize&quot;, new Integer(imageSize));

        IIOMetadataNode node = addChildNode(root, &quot;PixelsPerMeter&quot;, null);
        addChildNode(node, &quot;X&quot;, new Integer(xPixelsPerMeter));
        addChildNode(node, &quot;Y&quot;, new Integer(yPixelsPerMeter));

        addChildNode(root, &quot;ColorsUsed&quot;, new Integer(colorsUsed));
        addChildNode(root, &quot;ColorsImportant&quot;, new Integer(colorsImportant));

        int version = 0;
        for (int i = 0; i &lt; bmpVersion.length(); i++)
            if (Character.isDigit(bmpVersion.charAt(i)))
                version = bmpVersion.charAt(i) -'0';

        if (version &gt;= 4) {
            node = addChildNode(root, &quot;Mask&quot;, null);
            addChildNode(node, &quot;Red&quot;, new Integer(redMask));
            addChildNode(node, &quot;Green&quot;, new Integer(greenMask));
            addChildNode(node, &quot;Blue&quot;, new Integer(blueMask));
            addChildNode(node, &quot;Alpha&quot;, new Integer(alphaMask));

            addChildNode(root, &quot;ColorSpaceType&quot;, new Integer(colorSpace));

            node = addChildNode(root, &quot;CIEXYZEndPoints&quot;, null);
            addXYZPoints(node, &quot;Red&quot;, redX, redY, redZ);
            addXYZPoints(node, &quot;Green&quot;, greenX, greenY, greenZ);
            addXYZPoints(node, &quot;Blue&quot;, blueX, blueY, blueZ);

            node = addChildNode(root, &quot;Intent&quot;, new Integer(intent));
        }

        // Palette
        if ((palette != null) &amp;&amp; (paletteSize &gt; 0)) {
            node = addChildNode(root, &quot;Palette&quot;, null);
            int numComps = palette.length / paletteSize;

            for (int i = 0, j = 0; i &lt; paletteSize; i++) {
                IIOMetadataNode entry =
                    addChildNode(node, &quot;PaletteEntry&quot;, null);
                red = palette[j++] &amp; 0xff;
                green = palette[j++] &amp; 0xff;
                blue = palette[j++] &amp; 0xff;
                addChildNode(entry, &quot;Red&quot;, new Byte((byte)red));
                addChildNode(entry, &quot;Green&quot;, new Byte((byte)green));
                addChildNode(entry, &quot;Blue&quot;, new Byte((byte)blue));
                if (numComps == 4)
                    addChildNode(entry, &quot;Alpha&quot;,
                                 new Byte((byte)(palette[j++] &amp; 0xff)));
            }
        }

        return root;
    }

    // Standard tree node methods
    protected IIOMetadataNode getStandardChromaNode() {

        if ((palette != null) &amp;&amp; (paletteSize &gt; 0)) {
            IIOMetadataNode node = new IIOMetadataNode(&quot;Chroma&quot;);
            IIOMetadataNode subNode = new IIOMetadataNode(&quot;Palette&quot;);
            int numComps = palette.length / paletteSize;
            subNode.setAttribute(&quot;value&quot;, &quot;&quot; + numComps);

            for (int i = 0, j = 0; i &lt; paletteSize; i++) {
                IIOMetadataNode subNode1 = new IIOMetadataNode(&quot;PaletteEntry&quot;);
                subNode1.setAttribute(&quot;index&quot;, &quot;&quot;+i);
                subNode1.setAttribute(&quot;red&quot;, &quot;&quot; + palette[j++]);
                subNode1.setAttribute(&quot;green&quot;, &quot;&quot; + palette[j++]);
                subNode1.setAttribute(&quot;blue&quot;, &quot;&quot; + palette[j++]);
                if (numComps == 4 &amp;&amp; palette[j] != 0)
                    subNode1.setAttribute(&quot;alpha&quot;, &quot;&quot; + palette[j++]);
                subNode.appendChild(subNode1);
            }
            node.appendChild(subNode);
            return node;
        }

        return null;
    }

    protected IIOMetadataNode getStandardCompressionNode() {
        IIOMetadataNode node = new IIOMetadataNode(&quot;Compression&quot;);

        // CompressionTypeName
        IIOMetadataNode subNode = new IIOMetadataNode(&quot;CompressionTypeName&quot;);
        subNode.setAttribute(&quot;value&quot;, BMPCompressionTypes.getName(compression));
        node.appendChild(subNode);
        return node;
    }

    protected IIOMetadataNode getStandardDataNode() {
        IIOMetadataNode node = new IIOMetadataNode(&quot;Data&quot;);

        String bits = &quot;&quot;;
        if (bitsPerPixel == 24)
            bits = &quot;8 8 8 &quot;;
        else if (bitsPerPixel == 16 || bitsPerPixel == 32) {
            bits = &quot;&quot; + countBits(redMask) + &quot; &quot; + countBits(greenMask) +
                  countBits(blueMask) + &quot;&quot; + countBits(alphaMask);
        }

        IIOMetadataNode subNode = new IIOMetadataNode(&quot;BitsPerSample&quot;);
        subNode.setAttribute(&quot;value&quot;, bits);
        node.appendChild(subNode);

        return node;
    }

    protected IIOMetadataNode getStandardDimensionNode() {
        if (yPixelsPerMeter &gt; 0.0F &amp;&amp; xPixelsPerMeter &gt; 0.0F) {
            IIOMetadataNode node = new IIOMetadataNode(&quot;Dimension&quot;);
            float ratio = yPixelsPerMeter / xPixelsPerMeter;
            IIOMetadataNode subNode = new IIOMetadataNode(&quot;PixelAspectRatio&quot;);
            subNode.setAttribute(&quot;value&quot;, &quot;&quot; + ratio);
            node.appendChild(subNode);

            subNode = new IIOMetadataNode(&quot;HorizontalPhysicalPixelSpacing&quot;);
            subNode.setAttribute(&quot;value&quot;, &quot;&quot; + (1 / xPixelsPerMeter * 1000));
            node.appendChild(subNode);

            subNode = new IIOMetadataNode(&quot;VerticalPhysicalPixelSpacing&quot;);
            subNode.setAttribute(&quot;value&quot;, &quot;&quot; + (1 / yPixelsPerMeter * 1000));
            node.appendChild(subNode);

            return node;
        }
        return null;
    }

    public void setFromTree(String formatName, Node root) {
        throw new IllegalStateException(I18N.getString(&quot;BMPMetadata1&quot;));
    }

    public void mergeTree(String formatName, Node root) {
        throw new IllegalStateException(I18N.getString(&quot;BMPMetadata1&quot;));
    }

    public void reset() {
        throw new IllegalStateException(I18N.getString(&quot;BMPMetadata1&quot;));
    }

    private String countBits(int num) {
        int count = 0;
        while(num &gt; 0) {
            if ((num &amp; 1) == 1)
                count++;
            num &gt;&gt;&gt;= 1;
        }

        return count == 0 ? &quot;&quot; : &quot;&quot; + count;
    }

    private void addXYZPoints(IIOMetadataNode root, String name, double x, double y, double z) {
        IIOMetadataNode node = addChildNode(root, name, null);
        addChildNode(node, &quot;X&quot;, new Double(x));
        addChildNode(node, &quot;Y&quot;, new Double(y));
        addChildNode(node, &quot;Z&quot;, new Double(z));
    }

    private IIOMetadataNode addChildNode(IIOMetadataNode root,
                                         String name,
                                         Object object) {
        IIOMetadataNode child = new IIOMetadataNode(name);
        if (object != null) {
            child.setUserObject(object);
            child.setNodeValue(ImageUtil.convertObjectToString(object));
        }
        root.appendChild(child);
        return child;
    }
}
</pre>
</body>
</html>
