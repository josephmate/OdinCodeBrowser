<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.imageio.plugins.png;

import java.awt.image.ColorModel;
import java.awt.image.IndexColorModel;
import java.awt.image.SampleModel;
import java.util.ArrayList;
import java.util.StringTokenizer;
import javax.imageio.ImageTypeSpecifier;
import javax.imageio.metadata.IIOInvalidTreeException;
import javax.imageio.metadata.IIOMetadata;
import javax.imageio.metadata.IIOMetadataFormatImpl;
import javax.imageio.metadata.IIOMetadataNode;
import org.w3c.dom.Node;

public class PNGMetadata extends IIOMetadata implements Cloneable {

    // package scope
    public static final String
        nativeMetadataFormatName = &quot;javax_imageio_png_1.0&quot;;

    protected static final String nativeMetadataFormatClassName
        = &quot;com.sun.imageio.plugins.png.PNGMetadataFormat&quot;;

    // Color types for IHDR chunk
    static final String[] IHDR_colorTypeNames = {
        &quot;Grayscale&quot;, null, &quot;RGB&quot;, &quot;Palette&quot;,
        &quot;GrayAlpha&quot;, null, &quot;RGBAlpha&quot;
    };

    static final int[] IHDR_numChannels = {
        1, 0, 3, 3, 2, 0, 4
    };

    // Bit depths for IHDR chunk
    static final String[] IHDR_bitDepths = {
        &quot;1&quot;, &quot;2&quot;, &quot;4&quot;, &quot;8&quot;, &quot;16&quot;
    };

    // Compression methods for IHDR chunk
    static final String[] IHDR_compressionMethodNames = {
        &quot;deflate&quot;
    };

    // Filter methods for IHDR chunk
    static final String[] IHDR_filterMethodNames = {
        &quot;adaptive&quot;
    };

    // Interlace methods for IHDR chunk
    static final String[] IHDR_interlaceMethodNames = {
        &quot;none&quot;, &quot;adam7&quot;
    };

    // Compression methods for iCCP chunk
    static final String[] iCCP_compressionMethodNames = {
        &quot;deflate&quot;
    };

    // Compression methods for zTXt chunk
    static final String[] zTXt_compressionMethodNames = {
        &quot;deflate&quot;
    };

    // &quot;Unknown&quot; unit for pHYs chunk
    public static final int PHYS_UNIT_UNKNOWN = 0;

    // &quot;Meter&quot; unit for pHYs chunk
    public static final int PHYS_UNIT_METER = 1;

    // Unit specifiers for pHYs chunk
    static final String[] unitSpecifierNames = {
        &quot;unknown&quot;, &quot;meter&quot;
    };

    // Rendering intents for sRGB chunk
    static final String[] renderingIntentNames = {
        &quot;Perceptual&quot;, // 0
        &quot;Relative colorimetric&quot;, // 1
        &quot;Saturation&quot;, // 2
        &quot;Absolute colorimetric&quot; // 3

    };

    // Color space types for Chroma-&gt;ColorSpaceType node
    static final String[] colorSpaceTypeNames = {
        &quot;GRAY&quot;, null, &quot;RGB&quot;, &quot;RGB&quot;,
        &quot;GRAY&quot;, null, &quot;RGB&quot;
    };

    // IHDR chunk
    public boolean IHDR_present;
    public int IHDR_width;
    public int IHDR_height;
    public int IHDR_bitDepth;
    public int IHDR_colorType;
    public int IHDR_compressionMethod;
    public int IHDR_filterMethod;
    public int IHDR_interlaceMethod; // 0 == none, 1 == adam7

    // PLTE chunk
    public boolean PLTE_present;
    public byte[] PLTE_red;
    public byte[] PLTE_green;
    public byte[] PLTE_blue;

    // If non-null, used to reorder palette entries during encoding in
    // order to minimize the size of the tRNS chunk.  Thus an index of
    // 'i' in the source should be encoded as index 'PLTE_order[i]'.
    // PLTE_order will be null unless 'initialize' is called with an
    // IndexColorModel image type.
    public int[] PLTE_order = null;

    // bKGD chunk
    // If external (non-PNG sourced) data has red = green = blue,
    // always store it as gray and promote when writing
    public boolean bKGD_present;
    public int bKGD_colorType; // PNG_COLOR_GRAY, _RGB, or _PALETTE
    public int bKGD_index;
    public int bKGD_gray;
    public int bKGD_red;
    public int bKGD_green;
    public int bKGD_blue;

    // cHRM chunk
    public boolean cHRM_present;
    public int cHRM_whitePointX;
    public int cHRM_whitePointY;
    public int cHRM_redX;
    public int cHRM_redY;
    public int cHRM_greenX;
    public int cHRM_greenY;
    public int cHRM_blueX;
    public int cHRM_blueY;

    // gAMA chunk
    public boolean gAMA_present;
    public int gAMA_gamma;

    // hIST chunk
    public boolean hIST_present;
    public char[] hIST_histogram;

    // iCCP chunk
    public boolean iCCP_present;
    public String iCCP_profileName;
    public int iCCP_compressionMethod;
    public byte[] iCCP_compressedProfile;

    // iTXt chunk
    public ArrayList&lt;String&gt; iTXt_keyword = new ArrayList&lt;String&gt;();
    public ArrayList&lt;Boolean&gt; iTXt_compressionFlag = new ArrayList&lt;Boolean&gt;();
    public ArrayList&lt;Integer&gt; iTXt_compressionMethod = new ArrayList&lt;Integer&gt;();
    public ArrayList&lt;String&gt; iTXt_languageTag = new ArrayList&lt;String&gt;();
    public ArrayList&lt;String&gt; iTXt_translatedKeyword = new ArrayList&lt;String&gt;();
    public ArrayList&lt;String&gt; iTXt_text = new ArrayList&lt;String&gt;();

    // pHYs chunk
    public boolean pHYs_present;
    public int pHYs_pixelsPerUnitXAxis;
    public int pHYs_pixelsPerUnitYAxis;
    public int pHYs_unitSpecifier; // 0 == unknown, 1 == meter

    // sBIT chunk
    public boolean sBIT_present;
    public int sBIT_colorType; // PNG_COLOR_GRAY, _GRAY_ALPHA, _RGB, _RGB_ALPHA
    public int sBIT_grayBits;
    public int sBIT_redBits;
    public int sBIT_greenBits;
    public int sBIT_blueBits;
    public int sBIT_alphaBits;

    // sPLT chunk
    public boolean sPLT_present;
    public String sPLT_paletteName; // 1-79 characters
    public int sPLT_sampleDepth; // 8 or 16
    public int[] sPLT_red;
    public int[] sPLT_green;
    public int[] sPLT_blue;
    public int[] sPLT_alpha;
    public int[] sPLT_frequency;

    // sRGB chunk
    public boolean sRGB_present;
    public int sRGB_renderingIntent;

    // tEXt chunk
    public ArrayList&lt;String&gt; tEXt_keyword = new ArrayList&lt;String&gt;(); // 1-79 characters
    public ArrayList&lt;String&gt; tEXt_text = new ArrayList&lt;String&gt;();

    // tIME chunk
    public boolean tIME_present;
    public int tIME_year;
    public int tIME_month;
    public int tIME_day;
    public int tIME_hour;
    public int tIME_minute;
    public int tIME_second;

    // tRNS chunk
    // If external (non-PNG sourced) data has red = green = blue,
    // always store it as gray and promote when writing
    public boolean tRNS_present;
    public int tRNS_colorType; // PNG_COLOR_GRAY, _RGB, or _PALETTE
    public byte[] tRNS_alpha; // May have fewer entries than PLTE_red, etc.
    public int tRNS_gray;
    public int tRNS_red;
    public int tRNS_green;
    public int tRNS_blue;

    // zTXt chunk
    public ArrayList&lt;String&gt; zTXt_keyword = new ArrayList&lt;String&gt;();
    public ArrayList&lt;Integer&gt; zTXt_compressionMethod = new ArrayList&lt;Integer&gt;();
    public ArrayList&lt;String&gt; zTXt_text = new ArrayList&lt;String&gt;();

    // Unknown chunks
    public ArrayList&lt;String&gt; unknownChunkType = new ArrayList&lt;String&gt;();
    public ArrayList&lt;byte[]&gt; unknownChunkData = new ArrayList&lt;byte[]&gt;();

    public PNGMetadata() {
        super(true,
              nativeMetadataFormatName,
              nativeMetadataFormatClassName,
              null, null);
    }

    public PNGMetadata(IIOMetadata metadata) {
        // TODO -- implement
    }

    /**
     * Sets the IHDR_bitDepth and IHDR_colorType variables.
     * The &lt;code&gt;numBands&lt;/code&gt; parameter is necessary since
     * we may only be writing a subset of the image bands.
     */
    public void initialize(ImageTypeSpecifier imageType, int numBands) {
        ColorModel colorModel = imageType.getColorModel();
        SampleModel sampleModel = imageType.getSampleModel();

        // Initialize IHDR_bitDepth
        int[] sampleSize = sampleModel.getSampleSize();
        int bitDepth = sampleSize[0];
        // Choose max bit depth over all channels
        // Fixes bug 4413109
        for (int i = 1; i &lt; sampleSize.length; i++) {
            if (sampleSize[i] &gt; bitDepth) {
                bitDepth = sampleSize[i];
            }
        }
        // Multi-channel images must have a bit depth of 8 or 16
        if (sampleSize.length &gt; 1 &amp;&amp; bitDepth &lt; 8) {
            bitDepth = 8;
        }

        // Round bit depth up to a power of 2
        if (bitDepth &gt; 2 &amp;&amp; bitDepth &lt; 4) {
            bitDepth = 4;
        } else if (bitDepth &gt; 4 &amp;&amp; bitDepth &lt; 8) {
            bitDepth = 8;
        } else if (bitDepth &gt; 8 &amp;&amp; bitDepth &lt; 16) {
            bitDepth = 16;
        } else if (bitDepth &gt; 16) {
            throw new RuntimeException(&quot;bitDepth &gt; 16!&quot;);
        }
        IHDR_bitDepth = bitDepth;

        // Initialize IHDR_colorType
        if (colorModel instanceof IndexColorModel) {
            IndexColorModel icm = (IndexColorModel)colorModel;
            int size = icm.getMapSize();

            byte[] reds = new byte[size];
            icm.getReds(reds);
            byte[] greens = new byte[size];
            icm.getGreens(greens);
            byte[] blues = new byte[size];
            icm.getBlues(blues);

            // Determine whether the color tables are actually a gray ramp
            // if the color type has not been set previously
            boolean isGray = false;
            if (!IHDR_present ||
                (IHDR_colorType != PNGImageReader.PNG_COLOR_PALETTE)) {
                isGray = true;
                int scale = 255/((1 &lt;&lt; IHDR_bitDepth) - 1);
                for (int i = 0; i &lt; size; i++) {
                    byte red = reds[i];
                    if ((red != (byte)(i*scale)) ||
                        (red != greens[i]) ||
                        (red != blues[i])) {
                        isGray = false;
                        break;
                    }
                }
            }

            // Determine whether transparency exists
            boolean hasAlpha = colorModel.hasAlpha();

            byte[] alpha = null;
            if (hasAlpha) {
                alpha = new byte[size];
                icm.getAlphas(alpha);
            }

            /*
             * NB: PNG_COLOR_GRAY_ALPHA color type may be not optimal for images
             * contained more than 1024 pixels (or even than 768 pixels in case of
             * single transparent pixel in palette).
             * For such images alpha samples in raster will occupy more space than
             * it is required to store palette so it could be reasonable to
             * use PNG_COLOR_PALETTE color type for large images.
             */

            if (isGray &amp;&amp; hasAlpha &amp;&amp; (bitDepth == 8 || bitDepth == 16)) {
                IHDR_colorType = PNGImageReader.PNG_COLOR_GRAY_ALPHA;
            } else if (isGray &amp;&amp; !hasAlpha) {
                IHDR_colorType = PNGImageReader.PNG_COLOR_GRAY;
            } else {
                IHDR_colorType = PNGImageReader.PNG_COLOR_PALETTE;
                PLTE_present = true;
                PLTE_order = null;
                PLTE_red = (byte[])reds.clone();
                PLTE_green = (byte[])greens.clone();
                PLTE_blue = (byte[])blues.clone();

                if (hasAlpha) {
                    tRNS_present = true;
                    tRNS_colorType = PNGImageReader.PNG_COLOR_PALETTE;

                    PLTE_order = new int[alpha.length];

                    // Reorder the palette so that non-opaque entries
                    // come first.  Since the tRNS chunk does not have
                    // to store trailing 255's, this can save a
                    // considerable amount of space when encoding
                    // images with only one transparent pixel value,
                    // e.g., images from GIF sources.

                    byte[] newAlpha = new byte[alpha.length];

                    // Scan for non-opaque entries and assign them
                    // positions starting at 0.
                    int newIndex = 0;
                    for (int i = 0; i &lt; alpha.length; i++) {
                        if (alpha[i] != (byte)255) {
                            PLTE_order[i] = newIndex;
                            newAlpha[newIndex] = alpha[i];
                            ++newIndex;
                        }
                    }
                    int numTransparent = newIndex;

                    // Scan for opaque entries and assign them
                    // positions following the non-opaque entries.
                    for (int i = 0; i &lt; alpha.length; i++) {
                        if (alpha[i] == (byte)255) {
                            PLTE_order[i] = newIndex++;
                        }
                    }

                    // Reorder the palettes
                    byte[] oldRed = PLTE_red;
                    byte[] oldGreen = PLTE_green;
                    byte[] oldBlue = PLTE_blue;
                    int len = oldRed.length; // All have the same length
                    PLTE_red = new byte[len];
                    PLTE_green = new byte[len];
                    PLTE_blue = new byte[len];
                    for (int i = 0; i &lt; len; i++) {
                        PLTE_red[PLTE_order[i]] = oldRed[i];
                        PLTE_green[PLTE_order[i]] = oldGreen[i];
                        PLTE_blue[PLTE_order[i]] = oldBlue[i];
                    }

                    // Copy only the transparent entries into tRNS_alpha
                    tRNS_alpha = new byte[numTransparent];
                    System.arraycopy(newAlpha, 0,
                                     tRNS_alpha, 0, numTransparent);
                }
            }
        } else {
            if (numBands == 1) {
                IHDR_colorType = PNGImageReader.PNG_COLOR_GRAY;
            } else if (numBands == 2) {
                IHDR_colorType = PNGImageReader.PNG_COLOR_GRAY_ALPHA;
            } else if (numBands == 3) {
                IHDR_colorType = PNGImageReader.PNG_COLOR_RGB;
            } else if (numBands == 4) {
                IHDR_colorType = PNGImageReader.PNG_COLOR_RGB_ALPHA;
            } else {
                throw new RuntimeException(&quot;Number of bands not 1-4!&quot;);
            }
        }

        IHDR_present = true;
    }

    public boolean isReadOnly() {
        return false;
    }

    private ArrayList&lt;byte[]&gt; cloneBytesArrayList(ArrayList&lt;byte[]&gt; in) {
        if (in == null) {
            return null;
        } else {
            ArrayList&lt;byte[]&gt; list = new ArrayList&lt;byte[]&gt;(in.size());
            for (byte[] b: in) {
                list.add((b == null) ? null : (byte[])b.clone());
            }
            return list;
        }
    }

    // Deep clone
    public Object clone() {
        PNGMetadata metadata;
        try {
            metadata = (PNGMetadata)super.clone();
        } catch (CloneNotSupportedException e) {
            return null;
        }

        // unknownChunkData needs deep clone
        metadata.unknownChunkData =
            cloneBytesArrayList(this.unknownChunkData);

        return metadata;
    }

    public Node getAsTree(String formatName) {
        if (formatName.equals(nativeMetadataFormatName)) {
            return getNativeTree();
        } else if (formatName.equals
                   (IIOMetadataFormatImpl.standardMetadataFormatName)) {
            return getStandardTree();
        } else {
            throw new IllegalArgumentException(&quot;Not a recognized format!&quot;);
        }
    }

    private Node getNativeTree() {
        IIOMetadataNode node = null; // scratch node
        IIOMetadataNode root = new IIOMetadataNode(nativeMetadataFormatName);

        // IHDR
        if (IHDR_present) {
            IIOMetadataNode IHDR_node = new IIOMetadataNode(&quot;IHDR&quot;);
            IHDR_node.setAttribute(&quot;width&quot;, Integer.toString(IHDR_width));
            IHDR_node.setAttribute(&quot;height&quot;, Integer.toString(IHDR_height));
            IHDR_node.setAttribute(&quot;bitDepth&quot;,
                                   Integer.toString(IHDR_bitDepth));
            IHDR_node.setAttribute(&quot;colorType&quot;,
                                   IHDR_colorTypeNames[IHDR_colorType]);
            // IHDR_compressionMethod must be 0 in PNG 1.1
            IHDR_node.setAttribute(&quot;compressionMethod&quot;,
                          IHDR_compressionMethodNames[IHDR_compressionMethod]);
            // IHDR_filterMethod must be 0 in PNG 1.1
            IHDR_node.setAttribute(&quot;filterMethod&quot;,
                                    IHDR_filterMethodNames[IHDR_filterMethod]);
            IHDR_node.setAttribute(&quot;interlaceMethod&quot;,
                              IHDR_interlaceMethodNames[IHDR_interlaceMethod]);
            root.appendChild(IHDR_node);
        }

        // PLTE
        if (PLTE_present) {
            IIOMetadataNode PLTE_node = new IIOMetadataNode(&quot;PLTE&quot;);
            int numEntries = PLTE_red.length;
            for (int i = 0; i &lt; numEntries; i++) {
                IIOMetadataNode entry = new IIOMetadataNode(&quot;PLTEEntry&quot;);
                entry.setAttribute(&quot;index&quot;, Integer.toString(i));
                entry.setAttribute(&quot;red&quot;,
                                   Integer.toString(PLTE_red[i] &amp; 0xff));
                entry.setAttribute(&quot;green&quot;,
                                   Integer.toString(PLTE_green[i] &amp; 0xff));
                entry.setAttribute(&quot;blue&quot;,
                                   Integer.toString(PLTE_blue[i] &amp; 0xff));
                PLTE_node.appendChild(entry);
            }

            root.appendChild(PLTE_node);
        }

        // bKGD
        if (bKGD_present) {
            IIOMetadataNode bKGD_node = new IIOMetadataNode(&quot;bKGD&quot;);

            if (bKGD_colorType == PNGImageReader.PNG_COLOR_PALETTE) {
                node = new IIOMetadataNode(&quot;bKGD_Palette&quot;);
                node.setAttribute(&quot;index&quot;, Integer.toString(bKGD_index));
            } else if (bKGD_colorType == PNGImageReader.PNG_COLOR_GRAY) {
                node = new IIOMetadataNode(&quot;bKGD_Grayscale&quot;);
                node.setAttribute(&quot;gray&quot;, Integer.toString(bKGD_gray));
            } else if (bKGD_colorType == PNGImageReader.PNG_COLOR_RGB) {
                node = new IIOMetadataNode(&quot;bKGD_RGB&quot;);
                node.setAttribute(&quot;red&quot;, Integer.toString(bKGD_red));
                node.setAttribute(&quot;green&quot;, Integer.toString(bKGD_green));
                node.setAttribute(&quot;blue&quot;, Integer.toString(bKGD_blue));
            }
            bKGD_node.appendChild(node);

            root.appendChild(bKGD_node);
        }

        // cHRM
        if (cHRM_present) {
            IIOMetadataNode cHRM_node = new IIOMetadataNode(&quot;cHRM&quot;);
            cHRM_node.setAttribute(&quot;whitePointX&quot;,
                              Integer.toString(cHRM_whitePointX));
            cHRM_node.setAttribute(&quot;whitePointY&quot;,
                              Integer.toString(cHRM_whitePointY));
            cHRM_node.setAttribute(&quot;redX&quot;, Integer.toString(cHRM_redX));
            cHRM_node.setAttribute(&quot;redY&quot;, Integer.toString(cHRM_redY));
            cHRM_node.setAttribute(&quot;greenX&quot;, Integer.toString(cHRM_greenX));
            cHRM_node.setAttribute(&quot;greenY&quot;, Integer.toString(cHRM_greenY));
            cHRM_node.setAttribute(&quot;blueX&quot;, Integer.toString(cHRM_blueX));
            cHRM_node.setAttribute(&quot;blueY&quot;, Integer.toString(cHRM_blueY));

            root.appendChild(cHRM_node);
        }

        // gAMA
        if (gAMA_present) {
            IIOMetadataNode gAMA_node = new IIOMetadataNode(&quot;gAMA&quot;);
            gAMA_node.setAttribute(&quot;value&quot;, Integer.toString(gAMA_gamma));

            root.appendChild(gAMA_node);
        }

        // hIST
        if (hIST_present) {
            IIOMetadataNode hIST_node = new IIOMetadataNode(&quot;hIST&quot;);

            for (int i = 0; i &lt; hIST_histogram.length; i++) {
                IIOMetadataNode hist =
                    new IIOMetadataNode(&quot;hISTEntry&quot;);
                hist.setAttribute(&quot;index&quot;, Integer.toString(i));
                hist.setAttribute(&quot;value&quot;,
                                  Integer.toString(hIST_histogram[i]));
                hIST_node.appendChild(hist);
            }

            root.appendChild(hIST_node);
        }

        // iCCP
        if (iCCP_present) {
            IIOMetadataNode iCCP_node = new IIOMetadataNode(&quot;iCCP&quot;);
            iCCP_node.setAttribute(&quot;profileName&quot;, iCCP_profileName);
            iCCP_node.setAttribute(&quot;compressionMethod&quot;,
                          iCCP_compressionMethodNames[iCCP_compressionMethod]);

            Object profile = iCCP_compressedProfile;
            if (profile != null) {
                profile = ((byte[])profile).clone();
            }
            iCCP_node.setUserObject(profile);

            root.appendChild(iCCP_node);
        }

        // iTXt
        if (iTXt_keyword.size() &gt; 0) {
            IIOMetadataNode iTXt_parent = new IIOMetadataNode(&quot;iTXt&quot;);
            for (int i = 0; i &lt; iTXt_keyword.size(); i++) {
                IIOMetadataNode iTXt_node = new IIOMetadataNode(&quot;iTXtEntry&quot;);
                iTXt_node.setAttribute(&quot;keyword&quot;, iTXt_keyword.get(i));
                iTXt_node.setAttribute(&quot;compressionFlag&quot;,
                        iTXt_compressionFlag.get(i) ? &quot;TRUE&quot; : &quot;FALSE&quot;);
                iTXt_node.setAttribute(&quot;compressionMethod&quot;,
                        iTXt_compressionMethod.get(i).toString());
                iTXt_node.setAttribute(&quot;languageTag&quot;,
                                       iTXt_languageTag.get(i));
                iTXt_node.setAttribute(&quot;translatedKeyword&quot;,
                                       iTXt_translatedKeyword.get(i));
                iTXt_node.setAttribute(&quot;text&quot;, iTXt_text.get(i));

                iTXt_parent.appendChild(iTXt_node);
            }

            root.appendChild(iTXt_parent);
        }

        // pHYs
        if (pHYs_present) {
            IIOMetadataNode pHYs_node = new IIOMetadataNode(&quot;pHYs&quot;);
            pHYs_node.setAttribute(&quot;pixelsPerUnitXAxis&quot;,
                              Integer.toString(pHYs_pixelsPerUnitXAxis));
            pHYs_node.setAttribute(&quot;pixelsPerUnitYAxis&quot;,
                                   Integer.toString(pHYs_pixelsPerUnitYAxis));
            pHYs_node.setAttribute(&quot;unitSpecifier&quot;,
                                   unitSpecifierNames[pHYs_unitSpecifier]);

            root.appendChild(pHYs_node);
        }

        // sBIT
        if (sBIT_present) {
            IIOMetadataNode sBIT_node = new IIOMetadataNode(&quot;sBIT&quot;);

            if (sBIT_colorType == PNGImageReader.PNG_COLOR_GRAY) {
                node = new IIOMetadataNode(&quot;sBIT_Grayscale&quot;);
                node.setAttribute(&quot;gray&quot;,
                                  Integer.toString(sBIT_grayBits));
            } else if (sBIT_colorType == PNGImageReader.PNG_COLOR_GRAY_ALPHA) {
                node = new IIOMetadataNode(&quot;sBIT_GrayAlpha&quot;);
                node.setAttribute(&quot;gray&quot;,
                                  Integer.toString(sBIT_grayBits));
                node.setAttribute(&quot;alpha&quot;,
                                  Integer.toString(sBIT_alphaBits));
            } else if (sBIT_colorType == PNGImageReader.PNG_COLOR_RGB) {
                node = new IIOMetadataNode(&quot;sBIT_RGB&quot;);
                node.setAttribute(&quot;red&quot;,
                                  Integer.toString(sBIT_redBits));
                node.setAttribute(&quot;green&quot;,
                                  Integer.toString(sBIT_greenBits));
                node.setAttribute(&quot;blue&quot;,
                                  Integer.toString(sBIT_blueBits));
            } else if (sBIT_colorType == PNGImageReader.PNG_COLOR_RGB_ALPHA) {
                node = new IIOMetadataNode(&quot;sBIT_RGBAlpha&quot;);
                node.setAttribute(&quot;red&quot;,
                                  Integer.toString(sBIT_redBits));
                node.setAttribute(&quot;green&quot;,
                                  Integer.toString(sBIT_greenBits));
                node.setAttribute(&quot;blue&quot;,
                                  Integer.toString(sBIT_blueBits));
                node.setAttribute(&quot;alpha&quot;,
                                  Integer.toString(sBIT_alphaBits));
            } else if (sBIT_colorType == PNGImageReader.PNG_COLOR_PALETTE) {
                node = new IIOMetadataNode(&quot;sBIT_Palette&quot;);
                node.setAttribute(&quot;red&quot;,
                                  Integer.toString(sBIT_redBits));
                node.setAttribute(&quot;green&quot;,
                                  Integer.toString(sBIT_greenBits));
                node.setAttribute(&quot;blue&quot;,
                                  Integer.toString(sBIT_blueBits));
            }
            sBIT_node.appendChild(node);

            root.appendChild(sBIT_node);
        }

        // sPLT
        if (sPLT_present) {
            IIOMetadataNode sPLT_node = new IIOMetadataNode(&quot;sPLT&quot;);

            sPLT_node.setAttribute(&quot;name&quot;, sPLT_paletteName);
            sPLT_node.setAttribute(&quot;sampleDepth&quot;,
                                   Integer.toString(sPLT_sampleDepth));

            int numEntries = sPLT_red.length;
            for (int i = 0; i &lt; numEntries; i++) {
                IIOMetadataNode entry = new IIOMetadataNode(&quot;sPLTEntry&quot;);
                entry.setAttribute(&quot;index&quot;, Integer.toString(i));
                entry.setAttribute(&quot;red&quot;, Integer.toString(sPLT_red[i]));
                entry.setAttribute(&quot;green&quot;, Integer.toString(sPLT_green[i]));
                entry.setAttribute(&quot;blue&quot;, Integer.toString(sPLT_blue[i]));
                entry.setAttribute(&quot;alpha&quot;, Integer.toString(sPLT_alpha[i]));
                entry.setAttribute(&quot;frequency&quot;,
                                  Integer.toString(sPLT_frequency[i]));
                sPLT_node.appendChild(entry);
            }

            root.appendChild(sPLT_node);
        }

        // sRGB
        if (sRGB_present) {
            IIOMetadataNode sRGB_node = new IIOMetadataNode(&quot;sRGB&quot;);
            sRGB_node.setAttribute(&quot;renderingIntent&quot;,
                                   renderingIntentNames[sRGB_renderingIntent]);

            root.appendChild(sRGB_node);
        }

        // tEXt
        if (tEXt_keyword.size() &gt; 0) {
            IIOMetadataNode tEXt_parent = new IIOMetadataNode(&quot;tEXt&quot;);
            for (int i = 0; i &lt; tEXt_keyword.size(); i++) {
                IIOMetadataNode tEXt_node = new IIOMetadataNode(&quot;tEXtEntry&quot;);
                tEXt_node.setAttribute(&quot;keyword&quot; , (String)tEXt_keyword.get(i));
                tEXt_node.setAttribute(&quot;value&quot; , (String)tEXt_text.get(i));

                tEXt_parent.appendChild(tEXt_node);
            }

            root.appendChild(tEXt_parent);
        }

        // tIME
        if (tIME_present) {
            IIOMetadataNode tIME_node = new IIOMetadataNode(&quot;tIME&quot;);
            tIME_node.setAttribute(&quot;year&quot;, Integer.toString(tIME_year));
            tIME_node.setAttribute(&quot;month&quot;, Integer.toString(tIME_month));
            tIME_node.setAttribute(&quot;day&quot;, Integer.toString(tIME_day));
            tIME_node.setAttribute(&quot;hour&quot;, Integer.toString(tIME_hour));
            tIME_node.setAttribute(&quot;minute&quot;, Integer.toString(tIME_minute));
            tIME_node.setAttribute(&quot;second&quot;, Integer.toString(tIME_second));

            root.appendChild(tIME_node);
        }

        // tRNS
        if (tRNS_present) {
            IIOMetadataNode tRNS_node = new IIOMetadataNode(&quot;tRNS&quot;);

            if (tRNS_colorType == PNGImageReader.PNG_COLOR_PALETTE) {
                node = new IIOMetadataNode(&quot;tRNS_Palette&quot;);

                for (int i = 0; i &lt; tRNS_alpha.length; i++) {
                    IIOMetadataNode entry =
                        new IIOMetadataNode(&quot;tRNS_PaletteEntry&quot;);
                    entry.setAttribute(&quot;index&quot;, Integer.toString(i));
                    entry.setAttribute(&quot;alpha&quot;,
                                       Integer.toString(tRNS_alpha[i] &amp; 0xff));
                    node.appendChild(entry);
                }
            } else if (tRNS_colorType == PNGImageReader.PNG_COLOR_GRAY) {
                node = new IIOMetadataNode(&quot;tRNS_Grayscale&quot;);
                node.setAttribute(&quot;gray&quot;, Integer.toString(tRNS_gray));
            } else if (tRNS_colorType == PNGImageReader.PNG_COLOR_RGB) {
                node = new IIOMetadataNode(&quot;tRNS_RGB&quot;);
                node.setAttribute(&quot;red&quot;, Integer.toString(tRNS_red));
                node.setAttribute(&quot;green&quot;, Integer.toString(tRNS_green));
                node.setAttribute(&quot;blue&quot;, Integer.toString(tRNS_blue));
            }
            tRNS_node.appendChild(node);

            root.appendChild(tRNS_node);
        }

        // zTXt
        if (zTXt_keyword.size() &gt; 0) {
            IIOMetadataNode zTXt_parent = new IIOMetadataNode(&quot;zTXt&quot;);
            for (int i = 0; i &lt; zTXt_keyword.size(); i++) {
                IIOMetadataNode zTXt_node = new IIOMetadataNode(&quot;zTXtEntry&quot;);
                zTXt_node.setAttribute(&quot;keyword&quot;, (String)zTXt_keyword.get(i));

                int cm = ((Integer)zTXt_compressionMethod.get(i)).intValue();
                zTXt_node.setAttribute(&quot;compressionMethod&quot;,
                                       zTXt_compressionMethodNames[cm]);

                zTXt_node.setAttribute(&quot;text&quot;, (String)zTXt_text.get(i));

                zTXt_parent.appendChild(zTXt_node);
            }

            root.appendChild(zTXt_parent);
        }

        // Unknown chunks
        if (unknownChunkType.size() &gt; 0) {
            IIOMetadataNode unknown_parent =
                new IIOMetadataNode(&quot;UnknownChunks&quot;);
            for (int i = 0; i &lt; unknownChunkType.size(); i++) {
                IIOMetadataNode unknown_node =
                    new IIOMetadataNode(&quot;UnknownChunk&quot;);
                unknown_node.setAttribute(&quot;type&quot;,
                                          (String)unknownChunkType.get(i));
                unknown_node.setUserObject((byte[])unknownChunkData.get(i));

                unknown_parent.appendChild(unknown_node);
            }

            root.appendChild(unknown_parent);
        }

        return root;
    }

    private int getNumChannels() {
        // Determine number of channels
        // Be careful about palette color with transparency
        int numChannels = IHDR_numChannels[IHDR_colorType];
        if (IHDR_colorType == PNGImageReader.PNG_COLOR_PALETTE &amp;&amp;
            tRNS_present &amp;&amp; tRNS_colorType == IHDR_colorType) {
            numChannels = 4;
        }
        return numChannels;
    }

    public IIOMetadataNode getStandardChromaNode() {
        IIOMetadataNode chroma_node = new IIOMetadataNode(&quot;Chroma&quot;);
        IIOMetadataNode node = null; // scratch node

        node = new IIOMetadataNode(&quot;ColorSpaceType&quot;);
        node.setAttribute(&quot;name&quot;, colorSpaceTypeNames[IHDR_colorType]);
        chroma_node.appendChild(node);

        node = new IIOMetadataNode(&quot;NumChannels&quot;);
        node.setAttribute(&quot;value&quot;, Integer.toString(getNumChannels()));
        chroma_node.appendChild(node);

        if (gAMA_present) {
            node = new IIOMetadataNode(&quot;Gamma&quot;);
            node.setAttribute(&quot;value&quot;, Float.toString(gAMA_gamma*1.0e-5F));
            chroma_node.appendChild(node);
        }

        node = new IIOMetadataNode(&quot;BlackIsZero&quot;);
        node.setAttribute(&quot;value&quot;, &quot;TRUE&quot;);
        chroma_node.appendChild(node);

        if (PLTE_present) {
            boolean hasAlpha = tRNS_present &amp;&amp;
                (tRNS_colorType == PNGImageReader.PNG_COLOR_PALETTE);

            node = new IIOMetadataNode(&quot;Palette&quot;);
            for (int i = 0; i &lt; PLTE_red.length; i++) {
                IIOMetadataNode entry =
                    new IIOMetadataNode(&quot;PaletteEntry&quot;);
                entry.setAttribute(&quot;index&quot;, Integer.toString(i));
                entry.setAttribute(&quot;red&quot;,
                                   Integer.toString(PLTE_red[i] &amp; 0xff));
                entry.setAttribute(&quot;green&quot;,
                                   Integer.toString(PLTE_green[i] &amp; 0xff));
                entry.setAttribute(&quot;blue&quot;,
                                   Integer.toString(PLTE_blue[i] &amp; 0xff));
                if (hasAlpha) {
                    int alpha = (i &lt; tRNS_alpha.length) ?
                        (tRNS_alpha[i] &amp; 0xff) : 255;
                    entry.setAttribute(&quot;alpha&quot;, Integer.toString(alpha));
                }
                node.appendChild(entry);
            }
            chroma_node.appendChild(node);
        }

        if (bKGD_present) {
            if (bKGD_colorType == PNGImageReader.PNG_COLOR_PALETTE) {
                node = new IIOMetadataNode(&quot;BackgroundIndex&quot;);
                node.setAttribute(&quot;value&quot;, Integer.toString(bKGD_index));
            } else {
                node = new IIOMetadataNode(&quot;BackgroundColor&quot;);
                int r, g, b;

                if (bKGD_colorType == PNGImageReader.PNG_COLOR_GRAY) {
                    r = g = b = bKGD_gray;
                } else {
                    r = bKGD_red;
                    g = bKGD_green;
                    b = bKGD_blue;
                }
                node.setAttribute(&quot;red&quot;, Integer.toString(r));
                node.setAttribute(&quot;green&quot;, Integer.toString(g));
                node.setAttribute(&quot;blue&quot;, Integer.toString(b));
            }
            chroma_node.appendChild(node);
        }

        return chroma_node;
    }

    public IIOMetadataNode getStandardCompressionNode() {
        IIOMetadataNode compression_node = new IIOMetadataNode(&quot;Compression&quot;);
        IIOMetadataNode node = null; // scratch node

        node = new IIOMetadataNode(&quot;CompressionTypeName&quot;);
        node.setAttribute(&quot;value&quot;, &quot;deflate&quot;);
        compression_node.appendChild(node);

        node = new IIOMetadataNode(&quot;Lossless&quot;);
        node.setAttribute(&quot;value&quot;, &quot;TRUE&quot;);
        compression_node.appendChild(node);

        node = new IIOMetadataNode(&quot;NumProgressiveScans&quot;);
        node.setAttribute(&quot;value&quot;,
                          (IHDR_interlaceMethod == 0) ? &quot;1&quot; : &quot;7&quot;);
        compression_node.appendChild(node);

        return compression_node;
    }

    private String repeat(String s, int times) {
        if (times == 1) {
            return s;
        }
        StringBuffer sb = new StringBuffer((s.length() + 1)*times - 1);
        sb.append(s);
        for (int i = 1; i &lt; times; i++) {
            sb.append(&quot; &quot;);
            sb.append(s);
        }
        return sb.toString();
    }

    public IIOMetadataNode getStandardDataNode() {
        IIOMetadataNode data_node = new IIOMetadataNode(&quot;Data&quot;);
        IIOMetadataNode node = null; // scratch node

        node = new IIOMetadataNode(&quot;PlanarConfiguration&quot;);
        node.setAttribute(&quot;value&quot;, &quot;PixelInterleaved&quot;);
        data_node.appendChild(node);

        node = new IIOMetadataNode(&quot;SampleFormat&quot;);
        node.setAttribute(&quot;value&quot;,
                          IHDR_colorType == PNGImageReader.PNG_COLOR_PALETTE ?
                          &quot;Index&quot; : &quot;UnsignedIntegral&quot;);
        data_node.appendChild(node);

        String bitDepth = Integer.toString(IHDR_bitDepth);
        node = new IIOMetadataNode(&quot;BitsPerSample&quot;);
        node.setAttribute(&quot;value&quot;, repeat(bitDepth, getNumChannels()));
        data_node.appendChild(node);

        if (sBIT_present) {
            node = new IIOMetadataNode(&quot;SignificantBitsPerSample&quot;);
            String sbits;
            if (sBIT_colorType == PNGImageReader.PNG_COLOR_GRAY ||
                sBIT_colorType == PNGImageReader.PNG_COLOR_GRAY_ALPHA) {
                sbits = Integer.toString(sBIT_grayBits);
            } else { // sBIT_colorType == PNGImageReader.PNG_COLOR_RGB ||
                     // sBIT_colorType == PNGImageReader.PNG_COLOR_RGB_ALPHA
                sbits = Integer.toString(sBIT_redBits) + &quot; &quot; +
                    Integer.toString(sBIT_greenBits) + &quot; &quot; +
                    Integer.toString(sBIT_blueBits);
            }

            if (sBIT_colorType == PNGImageReader.PNG_COLOR_GRAY_ALPHA ||
                sBIT_colorType == PNGImageReader.PNG_COLOR_RGB_ALPHA) {
                sbits += &quot; &quot; + Integer.toString(sBIT_alphaBits);
            }

            node.setAttribute(&quot;value&quot;, sbits);
            data_node.appendChild(node);
        }

        // SampleMSB

        return data_node;
    }

    public IIOMetadataNode getStandardDimensionNode() {
        IIOMetadataNode dimension_node = new IIOMetadataNode(&quot;Dimension&quot;);
        IIOMetadataNode node = null; // scratch node

        node = new IIOMetadataNode(&quot;PixelAspectRatio&quot;);
        float ratio = pHYs_present ?
            (float)pHYs_pixelsPerUnitXAxis/pHYs_pixelsPerUnitYAxis : 1.0F;
        node.setAttribute(&quot;value&quot;, Float.toString(ratio));
        dimension_node.appendChild(node);

        node = new IIOMetadataNode(&quot;ImageOrientation&quot;);
        node.setAttribute(&quot;value&quot;, &quot;Normal&quot;);
        dimension_node.appendChild(node);

        if (pHYs_present &amp;&amp; pHYs_unitSpecifier == PHYS_UNIT_METER) {
            node = new IIOMetadataNode(&quot;HorizontalPixelSize&quot;);
            node.setAttribute(&quot;value&quot;,
                              Float.toString(1000.0F/pHYs_pixelsPerUnitXAxis));
            dimension_node.appendChild(node);

            node = new IIOMetadataNode(&quot;VerticalPixelSize&quot;);
            node.setAttribute(&quot;value&quot;,
                              Float.toString(1000.0F/pHYs_pixelsPerUnitYAxis));
            dimension_node.appendChild(node);
        }

        return dimension_node;
    }

    public IIOMetadataNode getStandardDocumentNode() {
        if (!tIME_present) {
            return null;
        }

        IIOMetadataNode document_node = new IIOMetadataNode(&quot;Document&quot;);
        IIOMetadataNode node = null; // scratch node

        node = new IIOMetadataNode(&quot;ImageModificationTime&quot;);
        node.setAttribute(&quot;year&quot;, Integer.toString(tIME_year));
        node.setAttribute(&quot;month&quot;, Integer.toString(tIME_month));
        node.setAttribute(&quot;day&quot;, Integer.toString(tIME_day));
        node.setAttribute(&quot;hour&quot;, Integer.toString(tIME_hour));
        node.setAttribute(&quot;minute&quot;, Integer.toString(tIME_minute));
        node.setAttribute(&quot;second&quot;, Integer.toString(tIME_second));
        document_node.appendChild(node);

        return document_node;
    }

    public IIOMetadataNode getStandardTextNode() {
        int numEntries = tEXt_keyword.size() +
            iTXt_keyword.size() + zTXt_keyword.size();
        if (numEntries == 0) {
            return null;
        }

        IIOMetadataNode text_node = new IIOMetadataNode(&quot;Text&quot;);
        IIOMetadataNode node = null; // scratch node

        for (int i = 0; i &lt; tEXt_keyword.size(); i++) {
            node = new IIOMetadataNode(&quot;TextEntry&quot;);
            node.setAttribute(&quot;keyword&quot;, (String)tEXt_keyword.get(i));
            node.setAttribute(&quot;value&quot;, (String)tEXt_text.get(i));
            node.setAttribute(&quot;encoding&quot;, &quot;ISO-8859-1&quot;);
            node.setAttribute(&quot;compression&quot;, &quot;none&quot;);

            text_node.appendChild(node);
        }

        for (int i = 0; i &lt; iTXt_keyword.size(); i++) {
            node = new IIOMetadataNode(&quot;TextEntry&quot;);
            node.setAttribute(&quot;keyword&quot;, iTXt_keyword.get(i));
            node.setAttribute(&quot;value&quot;, iTXt_text.get(i));
            node.setAttribute(&quot;language&quot;,
                              iTXt_languageTag.get(i));
            if (iTXt_compressionFlag.get(i)) {
                node.setAttribute(&quot;compression&quot;, &quot;zip&quot;);
            } else {
                node.setAttribute(&quot;compression&quot;, &quot;none&quot;);
            }

            text_node.appendChild(node);
        }

        for (int i = 0; i &lt; zTXt_keyword.size(); i++) {
            node = new IIOMetadataNode(&quot;TextEntry&quot;);
            node.setAttribute(&quot;keyword&quot;, (String)zTXt_keyword.get(i));
            node.setAttribute(&quot;value&quot;, (String)zTXt_text.get(i));
            node.setAttribute(&quot;compression&quot;, &quot;zip&quot;);

            text_node.appendChild(node);
        }

        return text_node;
    }

    public IIOMetadataNode getStandardTransparencyNode() {
        IIOMetadataNode transparency_node =
            new IIOMetadataNode(&quot;Transparency&quot;);
        IIOMetadataNode node = null; // scratch node

        node = new IIOMetadataNode(&quot;Alpha&quot;);
        boolean hasAlpha =
            (IHDR_colorType == PNGImageReader.PNG_COLOR_RGB_ALPHA) ||
            (IHDR_colorType == PNGImageReader.PNG_COLOR_GRAY_ALPHA) ||
            (IHDR_colorType == PNGImageReader.PNG_COLOR_PALETTE &amp;&amp;
             tRNS_present &amp;&amp;
             (tRNS_colorType == IHDR_colorType) &amp;&amp;
             (tRNS_alpha != null));
        node.setAttribute(&quot;value&quot;, hasAlpha ? &quot;nonpremultipled&quot; : &quot;none&quot;);
        transparency_node.appendChild(node);

        if (tRNS_present) {
            node = new IIOMetadataNode(&quot;TransparentColor&quot;);
            if (tRNS_colorType == PNGImageReader.PNG_COLOR_RGB) {
                node.setAttribute(&quot;value&quot;,
                                  Integer.toString(tRNS_red) + &quot; &quot; +
                                  Integer.toString(tRNS_green) + &quot; &quot; +
                                  Integer.toString(tRNS_blue));
            } else if (tRNS_colorType == PNGImageReader.PNG_COLOR_GRAY) {
                node.setAttribute(&quot;value&quot;, Integer.toString(tRNS_gray));
            }
            transparency_node.appendChild(node);
        }

        return transparency_node;
    }

    // Shorthand for throwing an IIOInvalidTreeException
    private void fatal(Node node, String reason)
        throws IIOInvalidTreeException {
        throw new IIOInvalidTreeException(reason, node);
    }

    // Get an integer-valued attribute
    private String getStringAttribute(Node node, String name,
                                      String defaultValue, boolean required)
        throws IIOInvalidTreeException {
        Node attr = node.getAttributes().getNamedItem(name);
        if (attr == null) {
            if (!required) {
                return defaultValue;
            } else {
                fatal(node, &quot;Required attribute &quot; + name + &quot; not present!&quot;);
            }
        }
        return attr.getNodeValue();
    }


    // Get an integer-valued attribute
    private int getIntAttribute(Node node, String name,
                                int defaultValue, boolean required)
        throws IIOInvalidTreeException {
        String value = getStringAttribute(node, name, null, required);
        if (value == null) {
            return defaultValue;
        }
        return Integer.parseInt(value);
    }

    // Get a float-valued attribute
    private float getFloatAttribute(Node node, String name,
                                    float defaultValue, boolean required)
        throws IIOInvalidTreeException {
        String value = getStringAttribute(node, name, null, required);
        if (value == null) {
            return defaultValue;
        }
        return Float.parseFloat(value);
    }

    // Get a required integer-valued attribute
    private int getIntAttribute(Node node, String name)
        throws IIOInvalidTreeException {
        return getIntAttribute(node, name, -1, true);
    }

    // Get a required float-valued attribute
    private float getFloatAttribute(Node node, String name)
        throws IIOInvalidTreeException {
        return getFloatAttribute(node, name, -1.0F, true);
    }

    // Get a boolean-valued attribute
    private boolean getBooleanAttribute(Node node, String name,
                                        boolean defaultValue,
                                        boolean required)
        throws IIOInvalidTreeException {
        Node attr = node.getAttributes().getNamedItem(name);
        if (attr == null) {
            if (!required) {
                return defaultValue;
            } else {
                fatal(node, &quot;Required attribute &quot; + name + &quot; not present!&quot;);
            }
        }
        String value = attr.getNodeValue();
        // Allow lower case booleans for backward compatibility, #5082756
        if (value.equals(&quot;TRUE&quot;) || value.equals(&quot;true&quot;)) {
            return true;
        } else if (value.equals(&quot;FALSE&quot;) || value.equals(&quot;false&quot;)) {
            return false;
        } else {
            fatal(node, &quot;Attribute &quot; + name + &quot; must be 'TRUE' or 'FALSE'!&quot;);
            return false;
        }
    }

    // Get a required boolean-valued attribute
    private boolean getBooleanAttribute(Node node, String name)
        throws IIOInvalidTreeException {
        return getBooleanAttribute(node, name, false, true);
    }

    // Get an enumerated attribute as an index into a String array
    private int getEnumeratedAttribute(Node node,
                                       String name, String[] legalNames,
                                       int defaultValue, boolean required)
        throws IIOInvalidTreeException {
        Node attr = node.getAttributes().getNamedItem(name);
        if (attr == null) {
            if (!required) {
                return defaultValue;
            } else {
                fatal(node, &quot;Required attribute &quot; + name + &quot; not present!&quot;);
            }
        }
        String value = attr.getNodeValue();
        for (int i = 0; i &lt; legalNames.length; i++) {
            if (value.equals(legalNames[i])) {
                return i;
            }
        }

        fatal(node, &quot;Illegal value for attribute &quot; + name + &quot;!&quot;);
        return -1;
    }

    // Get a required enumerated attribute as an index into a String array
    private int getEnumeratedAttribute(Node node,
                                       String name, String[] legalNames)
        throws IIOInvalidTreeException {
        return getEnumeratedAttribute(node, name, legalNames, -1, true);
    }

    // Get a String-valued attribute
    private String getAttribute(Node node, String name,
                                String defaultValue, boolean required)
        throws IIOInvalidTreeException {
        Node attr = node.getAttributes().getNamedItem(name);
        if (attr == null) {
            if (!required) {
                return defaultValue;
            } else {
                fatal(node, &quot;Required attribute &quot; + name + &quot; not present!&quot;);
            }
        }
        return attr.getNodeValue();
    }

    // Get a required String-valued attribute
    private String getAttribute(Node node, String name)
        throws IIOInvalidTreeException {
            return getAttribute(node, name, null, true);
    }

    public void mergeTree(String formatName, Node root)
        throws IIOInvalidTreeException {
        if (formatName.equals(nativeMetadataFormatName)) {
            if (root == null) {
                throw new IllegalArgumentException(&quot;root == null!&quot;);
            }
            mergeNativeTree(root);
        } else if (formatName.equals
                   (IIOMetadataFormatImpl.standardMetadataFormatName)) {
            if (root == null) {
                throw new IllegalArgumentException(&quot;root == null!&quot;);
            }
            mergeStandardTree(root);
        } else {
            throw new IllegalArgumentException(&quot;Not a recognized format!&quot;);
        }
    }

    private void mergeNativeTree(Node root)
        throws IIOInvalidTreeException {
        Node node = root;
        if (!node.getNodeName().equals(nativeMetadataFormatName)) {
            fatal(node, &quot;Root must be &quot; + nativeMetadataFormatName);
        }

        node = node.getFirstChild();
        while (node != null) {
            String name = node.getNodeName();

            if (name.equals(&quot;IHDR&quot;)) {
                IHDR_width = getIntAttribute(node, &quot;width&quot;);
                IHDR_height = getIntAttribute(node, &quot;height&quot;);
                IHDR_bitDepth = getEnumeratedAttribute(node, &quot;bitDepth&quot;,
                                                       IHDR_bitDepths);
                IHDR_colorType = getEnumeratedAttribute(node, &quot;colorType&quot;,
                                                        IHDR_colorTypeNames);
                IHDR_compressionMethod =
                    getEnumeratedAttribute(node, &quot;compressionMethod&quot;,
                                           IHDR_compressionMethodNames);
                IHDR_filterMethod =
                    getEnumeratedAttribute(node,
                                           &quot;filterMethod&quot;,
                                           IHDR_filterMethodNames);
                IHDR_interlaceMethod =
                    getEnumeratedAttribute(node, &quot;interlaceMethod&quot;,
                                           IHDR_interlaceMethodNames);
                IHDR_present = true;
            } else if (name.equals(&quot;PLTE&quot;)) {
                byte[] red = new byte[256];
                byte[] green  = new byte[256];
                byte[] blue = new byte[256];
                int maxindex = -1;

                Node PLTE_entry = node.getFirstChild();
                if (PLTE_entry == null) {
                    fatal(node, &quot;Palette has no entries!&quot;);
                }

                while (PLTE_entry != null) {
                    if (!PLTE_entry.getNodeName().equals(&quot;PLTEEntry&quot;)) {
                        fatal(node,
                              &quot;Only a PLTEEntry may be a child of a PLTE!&quot;);
                    }

                    int index = getIntAttribute(PLTE_entry, &quot;index&quot;);
                    if (index &lt; 0 || index &gt; 255) {
                        fatal(node,
                              &quot;Bad value for PLTEEntry attribute index!&quot;);
                    }
                    if (index &gt; maxindex) {
                        maxindex = index;
                    }
                    red[index] =
                        (byte)getIntAttribute(PLTE_entry, &quot;red&quot;);
                    green[index] =
                        (byte)getIntAttribute(PLTE_entry, &quot;green&quot;);
                    blue[index] =
                        (byte)getIntAttribute(PLTE_entry, &quot;blue&quot;);

                    PLTE_entry = PLTE_entry.getNextSibling();
                }

                int numEntries = maxindex + 1;
                PLTE_red = new byte[numEntries];
                PLTE_green = new byte[numEntries];
                PLTE_blue = new byte[numEntries];
                System.arraycopy(red, 0, PLTE_red, 0, numEntries);
                System.arraycopy(green, 0, PLTE_green, 0, numEntries);
                System.arraycopy(blue, 0, PLTE_blue, 0, numEntries);
                PLTE_present = true;
            } else if (name.equals(&quot;bKGD&quot;)) {
                bKGD_present = false; // Guard against partial overwrite
                Node bKGD_node = node.getFirstChild();
                if (bKGD_node == null) {
                    fatal(node, &quot;bKGD node has no children!&quot;);
                }
                String bKGD_name = bKGD_node.getNodeName();
                if (bKGD_name.equals(&quot;bKGD_Palette&quot;)) {
                    bKGD_index = getIntAttribute(bKGD_node, &quot;index&quot;);
                    bKGD_colorType = PNGImageReader.PNG_COLOR_PALETTE;
                } else if (bKGD_name.equals(&quot;bKGD_Grayscale&quot;)) {
                    bKGD_gray = getIntAttribute(bKGD_node, &quot;gray&quot;);
                    bKGD_colorType = PNGImageReader.PNG_COLOR_GRAY;
                } else if (bKGD_name.equals(&quot;bKGD_RGB&quot;)) {
                    bKGD_red = getIntAttribute(bKGD_node, &quot;red&quot;);
                    bKGD_green = getIntAttribute(bKGD_node, &quot;green&quot;);
                    bKGD_blue = getIntAttribute(bKGD_node, &quot;blue&quot;);
                    bKGD_colorType = PNGImageReader.PNG_COLOR_RGB;
                } else {
                    fatal(node, &quot;Bad child of a bKGD node!&quot;);
                }
                if (bKGD_node.getNextSibling() != null) {
                    fatal(node, &quot;bKGD node has more than one child!&quot;);
                }

                bKGD_present = true;
            } else if (name.equals(&quot;cHRM&quot;)) {
                cHRM_whitePointX = getIntAttribute(node, &quot;whitePointX&quot;);
                cHRM_whitePointY = getIntAttribute(node, &quot;whitePointY&quot;);
                cHRM_redX = getIntAttribute(node, &quot;redX&quot;);
                cHRM_redY = getIntAttribute(node, &quot;redY&quot;);
                cHRM_greenX = getIntAttribute(node, &quot;greenX&quot;);
                cHRM_greenY = getIntAttribute(node, &quot;greenY&quot;);
                cHRM_blueX = getIntAttribute(node, &quot;blueX&quot;);
                cHRM_blueY = getIntAttribute(node, &quot;blueY&quot;);

                cHRM_present = true;
            } else if (name.equals(&quot;gAMA&quot;)) {
                gAMA_gamma = getIntAttribute(node, &quot;value&quot;);
                gAMA_present = true;
            } else if (name.equals(&quot;hIST&quot;)) {
                char[] hist = new char[256];
                int maxindex = -1;

                Node hIST_entry = node.getFirstChild();
                if (hIST_entry == null) {
                    fatal(node, &quot;hIST node has no children!&quot;);
                }

                while (hIST_entry != null) {
                    if (!hIST_entry.getNodeName().equals(&quot;hISTEntry&quot;)) {
                        fatal(node,
                              &quot;Only a hISTEntry may be a child of a hIST!&quot;);
                    }

                    int index = getIntAttribute(hIST_entry, &quot;index&quot;);
                    if (index &lt; 0 || index &gt; 255) {
                        fatal(node,
                              &quot;Bad value for histEntry attribute index!&quot;);
                    }
                    if (index &gt; maxindex) {
                        maxindex = index;
                    }
                    hist[index] =
                        (char)getIntAttribute(hIST_entry, &quot;value&quot;);

                    hIST_entry = hIST_entry.getNextSibling();
                }

                int numEntries = maxindex + 1;
                hIST_histogram = new char[numEntries];
                System.arraycopy(hist, 0, hIST_histogram, 0, numEntries);

                hIST_present = true;
            } else if (name.equals(&quot;iCCP&quot;)) {
                iCCP_profileName = getAttribute(node, &quot;profileName&quot;);
                iCCP_compressionMethod =
                    getEnumeratedAttribute(node, &quot;compressionMethod&quot;,
                                           iCCP_compressionMethodNames);
                Object compressedProfile =
                    ((IIOMetadataNode)node).getUserObject();
                if (compressedProfile == null) {
                    fatal(node, &quot;No ICCP profile present in user object!&quot;);
                }
                if (!(compressedProfile instanceof byte[])) {
                    fatal(node, &quot;User object not a byte array!&quot;);
                }

                iCCP_compressedProfile =
                    (byte[])((byte[])compressedProfile).clone();

                iCCP_present = true;
            } else if (name.equals(&quot;iTXt&quot;)) {
                Node iTXt_node = node.getFirstChild();
                while (iTXt_node != null) {
                    if (!iTXt_node.getNodeName().equals(&quot;iTXtEntry&quot;)) {
                        fatal(node,
                              &quot;Only an iTXtEntry may be a child of an iTXt!&quot;);
                    }

                    String keyword = getAttribute(iTXt_node, &quot;keyword&quot;);
                    if (isValidKeyword(keyword)) {
                        iTXt_keyword.add(keyword);

                        boolean compressionFlag =
                            getBooleanAttribute(iTXt_node, &quot;compressionFlag&quot;);
                        iTXt_compressionFlag.add(Boolean.valueOf(compressionFlag));

                        String compressionMethod =
                            getAttribute(iTXt_node, &quot;compressionMethod&quot;);
                        iTXt_compressionMethod.add(Integer.valueOf(compressionMethod));

                        String languageTag =
                            getAttribute(iTXt_node, &quot;languageTag&quot;);
                        iTXt_languageTag.add(languageTag);

                        String translatedKeyword =
                            getAttribute(iTXt_node, &quot;translatedKeyword&quot;);
                        iTXt_translatedKeyword.add(translatedKeyword);

                        String text = getAttribute(iTXt_node, &quot;text&quot;);
                        iTXt_text.add(text);

                    }
                    // silently skip invalid text entry

                    iTXt_node = iTXt_node.getNextSibling();
                }
            } else if (name.equals(&quot;pHYs&quot;)) {
                pHYs_pixelsPerUnitXAxis =
                    getIntAttribute(node, &quot;pixelsPerUnitXAxis&quot;);
                pHYs_pixelsPerUnitYAxis =
                    getIntAttribute(node, &quot;pixelsPerUnitYAxis&quot;);
                pHYs_unitSpecifier =
                    getEnumeratedAttribute(node, &quot;unitSpecifier&quot;,
                                           unitSpecifierNames);

                pHYs_present = true;
            } else if (name.equals(&quot;sBIT&quot;)) {
                sBIT_present = false; // Guard against partial overwrite
                Node sBIT_node = node.getFirstChild();
                if (sBIT_node == null) {
                    fatal(node, &quot;sBIT node has no children!&quot;);
                }
                String sBIT_name = sBIT_node.getNodeName();
                if (sBIT_name.equals(&quot;sBIT_Grayscale&quot;)) {
                    sBIT_grayBits = getIntAttribute(sBIT_node, &quot;gray&quot;);
                    sBIT_colorType = PNGImageReader.PNG_COLOR_GRAY;
                } else if (sBIT_name.equals(&quot;sBIT_GrayAlpha&quot;)) {
                    sBIT_grayBits = getIntAttribute(sBIT_node, &quot;gray&quot;);
                    sBIT_alphaBits = getIntAttribute(sBIT_node, &quot;alpha&quot;);
                    sBIT_colorType = PNGImageReader.PNG_COLOR_GRAY_ALPHA;
                } else if (sBIT_name.equals(&quot;sBIT_RGB&quot;)) {
                    sBIT_redBits = getIntAttribute(sBIT_node, &quot;red&quot;);
                    sBIT_greenBits = getIntAttribute(sBIT_node, &quot;green&quot;);
                    sBIT_blueBits = getIntAttribute(sBIT_node, &quot;blue&quot;);
                    sBIT_colorType = PNGImageReader.PNG_COLOR_RGB;
                } else if (sBIT_name.equals(&quot;sBIT_RGBAlpha&quot;)) {
                    sBIT_redBits = getIntAttribute(sBIT_node, &quot;red&quot;);
                    sBIT_greenBits = getIntAttribute(sBIT_node, &quot;green&quot;);
                    sBIT_blueBits = getIntAttribute(sBIT_node, &quot;blue&quot;);
                    sBIT_alphaBits = getIntAttribute(sBIT_node, &quot;alpha&quot;);
                    sBIT_colorType = PNGImageReader.PNG_COLOR_RGB_ALPHA;
                } else if (sBIT_name.equals(&quot;sBIT_Palette&quot;)) {
                    sBIT_redBits = getIntAttribute(sBIT_node, &quot;red&quot;);
                    sBIT_greenBits = getIntAttribute(sBIT_node, &quot;green&quot;);
                    sBIT_blueBits = getIntAttribute(sBIT_node, &quot;blue&quot;);
                    sBIT_colorType = PNGImageReader.PNG_COLOR_PALETTE;
                } else {
                    fatal(node, &quot;Bad child of an sBIT node!&quot;);
                }
                if (sBIT_node.getNextSibling() != null) {
                    fatal(node, &quot;sBIT node has more than one child!&quot;);
                }

                sBIT_present = true;
            } else if (name.equals(&quot;sPLT&quot;)) {
                sPLT_paletteName = getAttribute(node, &quot;name&quot;);
                sPLT_sampleDepth = getIntAttribute(node, &quot;sampleDepth&quot;);

                int[] red = new int[256];
                int[] green  = new int[256];
                int[] blue = new int[256];
                int[] alpha = new int[256];
                int[] frequency = new int[256];
                int maxindex = -1;

                Node sPLT_entry = node.getFirstChild();
                if (sPLT_entry == null) {
                    fatal(node, &quot;sPLT node has no children!&quot;);
                }

                while (sPLT_entry != null) {
                    if (!sPLT_entry.getNodeName().equals(&quot;sPLTEntry&quot;)) {
                        fatal(node,
                              &quot;Only an sPLTEntry may be a child of an sPLT!&quot;);
                    }

                    int index = getIntAttribute(sPLT_entry, &quot;index&quot;);
                    if (index &lt; 0 || index &gt; 255) {
                        fatal(node,
                              &quot;Bad value for PLTEEntry attribute index!&quot;);
                    }
                    if (index &gt; maxindex) {
                        maxindex = index;
                    }
                    red[index] = getIntAttribute(sPLT_entry, &quot;red&quot;);
                    green[index] = getIntAttribute(sPLT_entry, &quot;green&quot;);
                    blue[index] = getIntAttribute(sPLT_entry, &quot;blue&quot;);
                    alpha[index] = getIntAttribute(sPLT_entry, &quot;alpha&quot;);
                    frequency[index] =
                        getIntAttribute(sPLT_entry, &quot;frequency&quot;);

                    sPLT_entry = sPLT_entry.getNextSibling();
                }

                int numEntries = maxindex + 1;
                sPLT_red = new int[numEntries];
                sPLT_green = new int[numEntries];
                sPLT_blue = new int[numEntries];
                sPLT_alpha = new int[numEntries];
                sPLT_frequency = new int[numEntries];
                System.arraycopy(red, 0, sPLT_red, 0, numEntries);
                System.arraycopy(green, 0, sPLT_green, 0, numEntries);
                System.arraycopy(blue, 0, sPLT_blue, 0, numEntries);
                System.arraycopy(alpha, 0, sPLT_alpha, 0, numEntries);
                System.arraycopy(frequency, 0,
                                 sPLT_frequency, 0, numEntries);

                sPLT_present = true;
            } else if (name.equals(&quot;sRGB&quot;)) {
                sRGB_renderingIntent =
                    getEnumeratedAttribute(node, &quot;renderingIntent&quot;,
                                           renderingIntentNames);

                sRGB_present = true;
            } else if (name.equals(&quot;tEXt&quot;)) {
                Node tEXt_node = node.getFirstChild();
                while (tEXt_node != null) {
                    if (!tEXt_node.getNodeName().equals(&quot;tEXtEntry&quot;)) {
                        fatal(node,
                              &quot;Only an tEXtEntry may be a child of an tEXt!&quot;);
                    }

                    String keyword = getAttribute(tEXt_node, &quot;keyword&quot;);
                    tEXt_keyword.add(keyword);

                    String text = getAttribute(tEXt_node, &quot;value&quot;);
                    tEXt_text.add(text);

                    tEXt_node = tEXt_node.getNextSibling();
                }
            } else if (name.equals(&quot;tIME&quot;)) {
                tIME_year = getIntAttribute(node, &quot;year&quot;);
                tIME_month = getIntAttribute(node, &quot;month&quot;);
                tIME_day = getIntAttribute(node, &quot;day&quot;);
                tIME_hour = getIntAttribute(node, &quot;hour&quot;);
                tIME_minute = getIntAttribute(node, &quot;minute&quot;);
                tIME_second = getIntAttribute(node, &quot;second&quot;);

                tIME_present = true;
            } else if (name.equals(&quot;tRNS&quot;)) {
                tRNS_present = false; // Guard against partial overwrite
                Node tRNS_node = node.getFirstChild();
                if (tRNS_node == null) {
                    fatal(node, &quot;tRNS node has no children!&quot;);
                }
                String tRNS_name = tRNS_node.getNodeName();
                if (tRNS_name.equals(&quot;tRNS_Palette&quot;)) {
                    byte[] alpha = new byte[256];
                    int maxindex = -1;

                    Node tRNS_paletteEntry = tRNS_node.getFirstChild();
                    if (tRNS_paletteEntry == null) {
                        fatal(node, &quot;tRNS_Palette node has no children!&quot;);
                    }
                    while (tRNS_paletteEntry != null) {
                        if (!tRNS_paletteEntry.getNodeName().equals(
                                                        &quot;tRNS_PaletteEntry&quot;)) {
                            fatal(node,
                 &quot;Only a tRNS_PaletteEntry may be a child of a tRNS_Palette!&quot;);
                        }
                        int index =
                            getIntAttribute(tRNS_paletteEntry, &quot;index&quot;);
                        if (index &lt; 0 || index &gt; 255) {
                            fatal(node,
                           &quot;Bad value for tRNS_PaletteEntry attribute index!&quot;);
                        }
                        if (index &gt; maxindex) {
                            maxindex = index;
                        }
                        alpha[index] =
                            (byte)getIntAttribute(tRNS_paletteEntry,
                                                  &quot;alpha&quot;);

                        tRNS_paletteEntry =
                            tRNS_paletteEntry.getNextSibling();
                    }

                    int numEntries = maxindex + 1;
                    tRNS_alpha = new byte[numEntries];
                    tRNS_colorType = PNGImageReader.PNG_COLOR_PALETTE;
                    System.arraycopy(alpha, 0, tRNS_alpha, 0, numEntries);
                } else if (tRNS_name.equals(&quot;tRNS_Grayscale&quot;)) {
                    tRNS_gray = getIntAttribute(tRNS_node, &quot;gray&quot;);
                    tRNS_colorType = PNGImageReader.PNG_COLOR_GRAY;
                } else if (tRNS_name.equals(&quot;tRNS_RGB&quot;)) {
                    tRNS_red = getIntAttribute(tRNS_node, &quot;red&quot;);
                    tRNS_green = getIntAttribute(tRNS_node, &quot;green&quot;);
                    tRNS_blue = getIntAttribute(tRNS_node, &quot;blue&quot;);
                    tRNS_colorType = PNGImageReader.PNG_COLOR_RGB;
                } else {
                    fatal(node, &quot;Bad child of a tRNS node!&quot;);
                }
                if (tRNS_node.getNextSibling() != null) {
                    fatal(node, &quot;tRNS node has more than one child!&quot;);
                }

                tRNS_present = true;
            } else if (name.equals(&quot;zTXt&quot;)) {
                Node zTXt_node = node.getFirstChild();
                while (zTXt_node != null) {
                    if (!zTXt_node.getNodeName().equals(&quot;zTXtEntry&quot;)) {
                        fatal(node,
                              &quot;Only an zTXtEntry may be a child of an zTXt!&quot;);
                    }

                    String keyword = getAttribute(zTXt_node, &quot;keyword&quot;);
                    zTXt_keyword.add(keyword);

                    int compressionMethod =
                        getEnumeratedAttribute(zTXt_node, &quot;compressionMethod&quot;,
                                               zTXt_compressionMethodNames);
                    zTXt_compressionMethod.add(new Integer(compressionMethod));

                    String text = getAttribute(zTXt_node, &quot;text&quot;);
                    zTXt_text.add(text);

                    zTXt_node = zTXt_node.getNextSibling();
                }
            } else if (name.equals(&quot;UnknownChunks&quot;)) {
                Node unknown_node = node.getFirstChild();
                while (unknown_node != null) {
                    if (!unknown_node.getNodeName().equals(&quot;UnknownChunk&quot;)) {
                        fatal(node,
                   &quot;Only an UnknownChunk may be a child of an UnknownChunks!&quot;);
                    }
                    String chunkType = getAttribute(unknown_node, &quot;type&quot;);
                    Object chunkData =
                        ((IIOMetadataNode)unknown_node).getUserObject();

                    if (chunkType.length() != 4) {
                        fatal(unknown_node,
                              &quot;Chunk type must be 4 characters!&quot;);
                    }
                    if (chunkData == null) {
                        fatal(unknown_node,
                              &quot;No chunk data present in user object!&quot;);
                    }
                    if (!(chunkData instanceof byte[])) {
                        fatal(unknown_node,
                              &quot;User object not a byte array!&quot;);
                    }
                    unknownChunkType.add(chunkType);
                    unknownChunkData.add(((byte[])chunkData).clone());

                    unknown_node = unknown_node.getNextSibling();
                }
            } else {
                fatal(node, &quot;Unknown child of root node!&quot;);
            }

            node = node.getNextSibling();
        }
    }

    /*
     * Accrding to PNG spec, keywords are restricted to 1 to 79 bytes
     * in length. Keywords shall contain only printable Latin-1 characters
     * and spaces; To reduce the chances for human misreading of a keyword,
     * leading spaces, trailing spaces, and consecutive spaces are not
     * permitted in keywords.
     *
     * See: http://www.w3.org/TR/PNG/#11keywords
     */
    private boolean isValidKeyword(String s) {
        int len = s.length();
        if (len &lt; 1 || len &gt;= 80) {
            return false;
        }
        if (s.startsWith(&quot; &quot;) || s.endsWith(&quot; &quot;) || s.contains(&quot;  &quot;)) {
            return false;
        }
        return isISOLatin(s, false);
    }

    /*
     * According to PNG spec, keyword shall contain only printable
     * Latin-1 [ISO-8859-1] characters and spaces; that is, only
     * character codes 32-126 and 161-255 decimal are allowed.
     * For Latin-1 value fields the 0x10 (linefeed) control
     * character is aloowed too.
     *
     * See: http://www.w3.org/TR/PNG/#11keywords
     */
    private boolean isISOLatin(String s, boolean isLineFeedAllowed) {
        int len = s.length();
        for (int i = 0; i &lt; len; i++) {
            char c = s.charAt(i);
            if (c &lt; 32 || c &gt; 255 || (c &gt; 126 &amp;&amp; c &lt; 161)) {
                // not printable. Check whether this is an allowed
                // control char
                if (!isLineFeedAllowed || c != 0x10) {
                    return false;
                }
            }
        }
        return true;
    }

    private void mergeStandardTree(Node root)
        throws IIOInvalidTreeException {
        Node node = root;
        if (!node.getNodeName()
            .equals(IIOMetadataFormatImpl.standardMetadataFormatName)) {
            fatal(node, &quot;Root must be &quot; +
                  IIOMetadataFormatImpl.standardMetadataFormatName);
        }

        node = node.getFirstChild();
        while (node != null) {
            String name = node.getNodeName();

            if (name.equals(&quot;Chroma&quot;)) {
                Node child = node.getFirstChild();
                while (child != null) {
                    String childName = child.getNodeName();
                    if (childName.equals(&quot;Gamma&quot;)) {
                        float gamma = getFloatAttribute(child, &quot;value&quot;);
                        gAMA_present = true;
                        gAMA_gamma = (int)(gamma*100000 + 0.5);
                    } else if (childName.equals(&quot;Palette&quot;)) {
                        byte[] red = new byte[256];
                        byte[] green = new byte[256];
                        byte[] blue = new byte[256];
                        int maxindex = -1;

                        Node entry = child.getFirstChild();
                        while (entry != null) {
                            int index = getIntAttribute(entry, &quot;index&quot;);
                            if (index &gt;= 0 &amp;&amp; index &lt;= 255) {
                                red[index] =
                                    (byte)getIntAttribute(entry, &quot;red&quot;);
                                green[index] =
                                    (byte)getIntAttribute(entry, &quot;green&quot;);
                                blue[index] =
                                    (byte)getIntAttribute(entry, &quot;blue&quot;);
                                if (index &gt; maxindex) {
                                    maxindex = index;
                                }
                            }
                            entry = entry.getNextSibling();
                        }

                        int numEntries = maxindex + 1;
                        PLTE_red = new byte[numEntries];
                        PLTE_green = new byte[numEntries];
                        PLTE_blue = new byte[numEntries];
                        System.arraycopy(red, 0, PLTE_red, 0, numEntries);
                        System.arraycopy(green, 0, PLTE_green, 0, numEntries);
                        System.arraycopy(blue, 0, PLTE_blue, 0, numEntries);
                        PLTE_present = true;
                    } else if (childName.equals(&quot;BackgroundIndex&quot;)) {
                        bKGD_present = true;
                        bKGD_colorType = PNGImageReader.PNG_COLOR_PALETTE;
                        bKGD_index = getIntAttribute(child, &quot;value&quot;);
                    } else if (childName.equals(&quot;BackgroundColor&quot;)) {
                        int red = getIntAttribute(child, &quot;red&quot;);
                        int green = getIntAttribute(child, &quot;green&quot;);
                        int blue = getIntAttribute(child, &quot;blue&quot;);
                        if (red == green &amp;&amp; red == blue) {
                            bKGD_colorType = PNGImageReader.PNG_COLOR_GRAY;
                            bKGD_gray = red;
                        } else {
                            bKGD_red = red;
                            bKGD_green = green;
                            bKGD_blue = blue;
                        }
                        bKGD_present = true;
                    }
//                  } else if (childName.equals(&quot;ColorSpaceType&quot;)) {
//                  } else if (childName.equals(&quot;NumChannels&quot;)) {

                    child = child.getNextSibling();
                }
            } else if (name.equals(&quot;Compression&quot;)) {
                Node child = node.getFirstChild();
                while (child != null) {
                    String childName = child.getNodeName();
                    if (childName.equals(&quot;NumProgressiveScans&quot;)) {
                        // Use Adam7 if NumProgressiveScans &gt; 1
                        int scans = getIntAttribute(child, &quot;value&quot;);
                        IHDR_interlaceMethod = (scans &gt; 1) ? 1 : 0;
//                  } else if (childName.equals(&quot;CompressionTypeName&quot;)) {
//                  } else if (childName.equals(&quot;Lossless&quot;)) {
//                  } else if (childName.equals(&quot;BitRate&quot;)) {
                    }
                    child = child.getNextSibling();
                }
            } else if (name.equals(&quot;Data&quot;)) {
                Node child = node.getFirstChild();
                while (child != null) {
                    String childName = child.getNodeName();
                    if (childName.equals(&quot;BitsPerSample&quot;)) {
                        String s = getAttribute(child, &quot;value&quot;);
                        StringTokenizer t = new StringTokenizer(s);
                        int maxBits = -1;
                        while (t.hasMoreTokens()) {
                            int bits = Integer.parseInt(t.nextToken());
                            if (bits &gt; maxBits) {
                                maxBits = bits;
                            }
                        }
                        if (maxBits &lt; 1) {
                            maxBits = 1;
                        }
                        if (maxBits == 3) maxBits = 4;
                        if (maxBits &gt; 4 || maxBits &lt; 8) {
                            maxBits = 8;
                        }
                        if (maxBits &gt; 8) {
                            maxBits = 16;
                        }
                        IHDR_bitDepth = maxBits;
                    } else if (childName.equals(&quot;SignificantBitsPerSample&quot;)) {
                        String s = getAttribute(child, &quot;value&quot;);
                        StringTokenizer t = new StringTokenizer(s);
                        int numTokens = t.countTokens();
                        if (numTokens == 1) {
                            sBIT_colorType = PNGImageReader.PNG_COLOR_GRAY;
                            sBIT_grayBits = Integer.parseInt(t.nextToken());
                        } else if (numTokens == 2) {
                            sBIT_colorType =
                              PNGImageReader.PNG_COLOR_GRAY_ALPHA;
                            sBIT_grayBits = Integer.parseInt(t.nextToken());
                            sBIT_alphaBits = Integer.parseInt(t.nextToken());
                        } else if (numTokens == 3) {
                            sBIT_colorType = PNGImageReader.PNG_COLOR_RGB;
                            sBIT_redBits = Integer.parseInt(t.nextToken());
                            sBIT_greenBits = Integer.parseInt(t.nextToken());
                            sBIT_blueBits = Integer.parseInt(t.nextToken());
                        } else if (numTokens == 4) {
                            sBIT_colorType =
                              PNGImageReader.PNG_COLOR_RGB_ALPHA;
                            sBIT_redBits = Integer.parseInt(t.nextToken());
                            sBIT_greenBits = Integer.parseInt(t.nextToken());
                            sBIT_blueBits = Integer.parseInt(t.nextToken());
                            sBIT_alphaBits = Integer.parseInt(t.nextToken());
                        }
                        if (numTokens &gt;= 1 &amp;&amp; numTokens &lt;= 4) {
                            sBIT_present = true;
                        }
//                      } else if (childName.equals(&quot;PlanarConfiguration&quot;)) {
//                      } else if (childName.equals(&quot;SampleFormat&quot;)) {
//                      } else if (childName.equals(&quot;SampleMSB&quot;)) {
                    }
                    child = child.getNextSibling();
                }
            } else if (name.equals(&quot;Dimension&quot;)) {
                boolean gotWidth = false;
                boolean gotHeight = false;
                boolean gotAspectRatio = false;

                float width = -1.0F;
                float height = -1.0F;
                float aspectRatio = -1.0F;

                Node child = node.getFirstChild();
                while (child != null) {
                    String childName = child.getNodeName();
                    if (childName.equals(&quot;PixelAspectRatio&quot;)) {
                        aspectRatio = getFloatAttribute(child, &quot;value&quot;);
                        gotAspectRatio = true;
                    } else if (childName.equals(&quot;HorizontalPixelSize&quot;)) {
                        width = getFloatAttribute(child, &quot;value&quot;);
                        gotWidth = true;
                    } else if (childName.equals(&quot;VerticalPixelSize&quot;)) {
                        height = getFloatAttribute(child, &quot;value&quot;);
                        gotHeight = true;
//                  } else if (childName.equals(&quot;ImageOrientation&quot;)) {
//                  } else if
//                      (childName.equals(&quot;HorizontalPhysicalPixelSpacing&quot;)) {
//                  } else if
//                      (childName.equals(&quot;VerticalPhysicalPixelSpacing&quot;)) {
//                  } else if (childName.equals(&quot;HorizontalPosition&quot;)) {
//                  } else if (childName.equals(&quot;VerticalPosition&quot;)) {
//                  } else if (childName.equals(&quot;HorizontalPixelOffset&quot;)) {
//                  } else if (childName.equals(&quot;VerticalPixelOffset&quot;)) {
                    }
                    child = child.getNextSibling();
                }

                if (gotWidth &amp;&amp; gotHeight) {
                    pHYs_present = true;
                    pHYs_unitSpecifier = 1;
                    pHYs_pixelsPerUnitXAxis = (int)(width*1000 + 0.5F);
                    pHYs_pixelsPerUnitYAxis = (int)(height*1000 + 0.5F);
                } else if (gotAspectRatio) {
                    pHYs_present = true;
                    pHYs_unitSpecifier = 0;

                    // Find a reasonable rational approximation
                    int denom = 1;
                    for (; denom &lt; 100; denom++) {
                        int num = (int)(aspectRatio*denom);
                        if (Math.abs(num/denom - aspectRatio) &lt; 0.001) {
                            break;
                        }
                    }
                    pHYs_pixelsPerUnitXAxis = (int)(aspectRatio*denom);
                    pHYs_pixelsPerUnitYAxis = denom;
                }
            } else if (name.equals(&quot;Document&quot;)) {
                Node child = node.getFirstChild();
                while (child != null) {
                    String childName = child.getNodeName();
                    if (childName.equals(&quot;ImageModificationTime&quot;)) {
                        tIME_present = true;
                        tIME_year = getIntAttribute(child, &quot;year&quot;);
                        tIME_month = getIntAttribute(child, &quot;month&quot;);
                        tIME_day = getIntAttribute(child, &quot;day&quot;);
                        tIME_hour =
                            getIntAttribute(child, &quot;hour&quot;, 0, false);
                        tIME_minute =
                            getIntAttribute(child, &quot;minute&quot;, 0, false);
                        tIME_second =
                            getIntAttribute(child, &quot;second&quot;, 0, false);
//                  } else if (childName.equals(&quot;SubimageInterpretation&quot;)) {
//                  } else if (childName.equals(&quot;ImageCreationTime&quot;)) {
                    }
                    child = child.getNextSibling();
                }
            } else if (name.equals(&quot;Text&quot;)) {
                Node child = node.getFirstChild();
                while (child != null) {
                    String childName = child.getNodeName();
                    if (childName.equals(&quot;TextEntry&quot;)) {
                        String keyword =
                            getAttribute(child, &quot;keyword&quot;, &quot;&quot;, false);
                        String value = getAttribute(child, &quot;value&quot;);
                        String language =
                            getAttribute(child, &quot;language&quot;, &quot;&quot;, false);
                        String compression =
                            getAttribute(child, &quot;compression&quot;, &quot;none&quot;, false);

                        if (!isValidKeyword(keyword)) {
                            // Just ignore this node, PNG requires keywords
                        } else if (isISOLatin(value, true)) {
                            if (compression.equals(&quot;zip&quot;)) {
                                // Use a zTXt node
                                zTXt_keyword.add(keyword);
                                zTXt_text.add(value);
                                zTXt_compressionMethod.add(Integer.valueOf(0));
                            } else {
                                // Use a tEXt node
                                tEXt_keyword.add(keyword);
                                tEXt_text.add(value);
                            }
                        } else {
                            // Use an iTXt node
                            iTXt_keyword.add(keyword);
                            iTXt_compressionFlag.add(Boolean.valueOf(compression.equals(&quot;zip&quot;)));
                            iTXt_compressionMethod.add(Integer.valueOf(0));
                            iTXt_languageTag.add(language);
                            iTXt_translatedKeyword.add(keyword); // fake it
                            iTXt_text.add(value);
                        }
                    }
                    child = child.getNextSibling();
                }
//          } else if (name.equals(&quot;Transparency&quot;)) {
//              Node child = node.getFirstChild();
//              while (child != null) {
//                  String childName = child.getNodeName();
//                  if (childName.equals(&quot;Alpha&quot;)) {
//                  } else if (childName.equals(&quot;TransparentIndex&quot;)) {
//                  } else if (childName.equals(&quot;TransparentColor&quot;)) {
//                  } else if (childName.equals(&quot;TileTransparencies&quot;)) {
//                  } else if (childName.equals(&quot;TileOpacities&quot;)) {
//                  }
//                  child = child.getNextSibling();
//              }
//          } else {
//              // fatal(node, &quot;Unknown child of root node!&quot;);
            }

            node = node.getNextSibling();
        }
    }

    // Reset all instance variables to their initial state
    public void reset() {
        IHDR_present = false;
        PLTE_present = false;
        bKGD_present = false;
        cHRM_present = false;
        gAMA_present = false;
        hIST_present = false;
        iCCP_present = false;
        iTXt_keyword = new ArrayList&lt;String&gt;();
        iTXt_compressionFlag = new ArrayList&lt;Boolean&gt;();
        iTXt_compressionMethod = new ArrayList&lt;Integer&gt;();
        iTXt_languageTag = new ArrayList&lt;String&gt;();
        iTXt_translatedKeyword = new ArrayList&lt;String&gt;();
        iTXt_text = new ArrayList&lt;String&gt;();
        pHYs_present = false;
        sBIT_present = false;
        sPLT_present = false;
        sRGB_present = false;
        tEXt_keyword = new ArrayList&lt;String&gt;();
        tEXt_text = new ArrayList&lt;String&gt;();
        tIME_present = false;
        tRNS_present = false;
        zTXt_keyword = new ArrayList&lt;String&gt;();
        zTXt_compressionMethod = new ArrayList&lt;Integer&gt;();
        zTXt_text = new ArrayList&lt;String&gt;();
        unknownChunkType = new ArrayList&lt;String&gt;();
        unknownChunkData = new ArrayList&lt;byte[]&gt;();
    }
}
</pre>
</body>
</html>
