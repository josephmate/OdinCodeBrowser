<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.crypto.provider;

import java.math.BigInteger;
import java.io.*;
import sun.security.util.*;
import sun.security.x509.*;
import java.security.AlgorithmParametersSpi;
import java.security.NoSuchAlgorithmException;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.InvalidParameterSpecException;
import java.security.spec.MGF1ParameterSpec;
import javax.crypto.spec.PSource;
import javax.crypto.spec.OAEPParameterSpec;

/**
 * This class implements the OAEP parameters used with the RSA
 * algorithm in OAEP padding. Here is its ASN.1 definition:
 * RSAES-OAEP-params ::= SEQUENCE {
 *   hashAlgorithm      [0] HashAlgorithm     DEFAULT sha1,
 *   maskGenAlgorithm   [1] MaskGenAlgorithm  DEFAULT mgf1SHA1,
 *   pSourceAlgorithm   [2] PSourceAlgorithm  DEFAULT pSpecifiedEmpty
 * }
 *
 * @author Valerie Peng
 *
 */

public final class OAEPParameters extends AlgorithmParametersSpi {

    private String mdName;
    private MGF1ParameterSpec mgfSpec;
    private byte[] p;
    private static ObjectIdentifier OID_MGF1;
    private static ObjectIdentifier OID_PSpecified;

    static {
        try {
            OID_MGF1 = new ObjectIdentifier(new int[] {1,2,840,113549,1,1,8});
        } catch (IOException ioe) {
            // should not happen
            OID_MGF1 = null;
        }
        try {
            OID_PSpecified =
                new ObjectIdentifier(new int[] {1,2,840,113549,1,1,9});
        } catch (IOException ioe) {
            // should not happen
            OID_PSpecified = null;
        }
    }

    public OAEPParameters() {
    }

    protected void engineInit(AlgorithmParameterSpec paramSpec)
        throws InvalidParameterSpecException {
        if (!(paramSpec instanceof OAEPParameterSpec)) {
            throw new InvalidParameterSpecException
                (&quot;Inappropriate parameter specification&quot;);
        }
        OAEPParameterSpec spec = (OAEPParameterSpec) paramSpec;
        mdName = spec.getDigestAlgorithm();
        String mgfName = spec.getMGFAlgorithm();
        if (!mgfName.equalsIgnoreCase(&quot;MGF1&quot;)) {
            throw new InvalidParameterSpecException(&quot;Unsupported mgf &quot; +
                mgfName + &quot;; MGF1 only&quot;);
        }
        AlgorithmParameterSpec mgfSpec = spec.getMGFParameters();
        if (!(mgfSpec instanceof MGF1ParameterSpec)) {
            throw new InvalidParameterSpecException(&quot;Inappropriate mgf &quot; +
                &quot;parameters; non-null MGF1ParameterSpec only&quot;);
        }
        this.mgfSpec = (MGF1ParameterSpec) mgfSpec;
        PSource pSrc = spec.getPSource();
        if (pSrc.getAlgorithm().equals(&quot;PSpecified&quot;)) {
            p = ((PSource.PSpecified) pSrc).getValue();
        } else {
            throw new InvalidParameterSpecException(&quot;Unsupported pSource &quot; +
                pSrc.getAlgorithm() + &quot;; PSpecified only&quot;);
        }
    }

    protected void engineInit(byte[] encoded)
        throws IOException {
        DerInputStream der = new DerInputStream(encoded);
        mdName = &quot;SHA-1&quot;;
        mgfSpec = MGF1ParameterSpec.SHA1;
        p = new byte[0];
        DerValue[] datum = der.getSequence(3);
        for (int i=0; i&lt;datum.length; i++) {
            DerValue data = datum[i];
            if (data.isContextSpecific((byte) 0x00)) {
                // hash algid
                mdName = AlgorithmId.parse
                    (data.data.getDerValue()).getName();
            } else if (data.isContextSpecific((byte) 0x01)) {
                // mgf algid
                AlgorithmId val = AlgorithmId.parse(data.data.getDerValue());
                if (!val.getOID().equals((Object) OID_MGF1)) {
                    throw new IOException(&quot;Only MGF1 mgf is supported&quot;);
                }
                AlgorithmId params = AlgorithmId.parse(
                    new DerValue(val.getEncodedParams()));
                String mgfDigestName = params.getName();
                if (mgfDigestName.equals(&quot;SHA-1&quot;)) {
                    mgfSpec = MGF1ParameterSpec.SHA1;
                } else if (mgfDigestName.equals(&quot;SHA-224&quot;)) {
                    mgfSpec = MGF1ParameterSpec.SHA224;
                } else if (mgfDigestName.equals(&quot;SHA-256&quot;)) {
                    mgfSpec = MGF1ParameterSpec.SHA256;
                } else if (mgfDigestName.equals(&quot;SHA-384&quot;)) {
                    mgfSpec = MGF1ParameterSpec.SHA384;
                } else if (mgfDigestName.equals(&quot;SHA-512&quot;)) {
                    mgfSpec = MGF1ParameterSpec.SHA512;
                } else {
                    throw new IOException(
                        &quot;Unrecognized message digest algorithm&quot;);
                }
            } else if (data.isContextSpecific((byte) 0x02)) {
                // pSource algid
                AlgorithmId val = AlgorithmId.parse(data.data.getDerValue());
                if (!val.getOID().equals((Object) OID_PSpecified)) {
                    throw new IOException(&quot;Wrong OID for pSpecified&quot;);
                }
                DerInputStream dis = new DerInputStream(val.getEncodedParams());
                p = dis.getOctetString();
                if (dis.available() != 0) {
                    throw new IOException(&quot;Extra data for pSpecified&quot;);
                }
            } else {
                throw new IOException(&quot;Invalid encoded OAEPParameters&quot;);
            }
        }
    }

    protected void engineInit(byte[] encoded, String decodingMethod)
        throws IOException {
        if ((decodingMethod != null) &amp;&amp;
            (!decodingMethod.equalsIgnoreCase(&quot;ASN.1&quot;))) {
            throw new IllegalArgumentException(&quot;Only support ASN.1 format&quot;);
        }
        engineInit(encoded);
    }

    protected &lt;T extends AlgorithmParameterSpec&gt;
        T engineGetParameterSpec(Class&lt;T&gt; paramSpec)
        throws InvalidParameterSpecException {
        if (OAEPParameterSpec.class.isAssignableFrom(paramSpec)) {
            return paramSpec.cast(
                new OAEPParameterSpec(mdName, &quot;MGF1&quot;, mgfSpec,
                                      new PSource.PSpecified(p)));
        } else {
            throw new InvalidParameterSpecException
                (&quot;Inappropriate parameter specification&quot;);
        }
    }

    protected byte[] engineGetEncoded() throws IOException {
        DerOutputStream tmp = new DerOutputStream();
        DerOutputStream tmp2, tmp3;

        // MD
        AlgorithmId mdAlgId;
        try {
            mdAlgId = AlgorithmId.get(mdName);
        } catch (NoSuchAlgorithmException nsae) {
            throw new IOException(&quot;AlgorithmId &quot; + mdName +
                                  &quot; impl not found&quot;);
        }
        tmp2 = new DerOutputStream();
        mdAlgId.derEncode(tmp2);
        tmp.write(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)0),
                      tmp2);

        // MGF
        tmp2 = new DerOutputStream();
        tmp2.putOID(OID_MGF1);
        AlgorithmId mgfDigestId;
        try {
            mgfDigestId = AlgorithmId.get(mgfSpec.getDigestAlgorithm());
        } catch (NoSuchAlgorithmException nase) {
            throw new IOException(&quot;AlgorithmId &quot; +
                    mgfSpec.getDigestAlgorithm() + &quot; impl not found&quot;);
        }
        mgfDigestId.encode(tmp2);
        tmp3 = new DerOutputStream();
        tmp3.write(DerValue.tag_Sequence, tmp2);
        tmp.write(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)1),
                  tmp3);

        // PSource
        tmp2 = new DerOutputStream();
        tmp2.putOID(OID_PSpecified);
        tmp2.putOctetString(p);
        tmp3 = new DerOutputStream();
        tmp3.write(DerValue.tag_Sequence, tmp2);
        tmp.write(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)2),
                  tmp3);

        // Put all together under a SEQUENCE tag
        DerOutputStream out = new DerOutputStream();
        out.write(DerValue.tag_Sequence, tmp);
        return out.toByteArray();
    }

    protected byte[] engineGetEncoded(String encodingMethod)
        throws IOException {
        if ((encodingMethod != null) &amp;&amp;
            (!encodingMethod.equalsIgnoreCase(&quot;ASN.1&quot;))) {
            throw new IllegalArgumentException(&quot;Only support ASN.1 format&quot;);
        }
        return engineGetEncoded();
    }

    protected String engineToString() {
        StringBuffer sb = new StringBuffer();
        sb.append(&quot;MD: &quot; + mdName + &quot;\n&quot;);
        sb.append(&quot;MGF: MGF1&quot; + mgfSpec.getDigestAlgorithm() + &quot;\n&quot;);
        sb.append(&quot;PSource: PSpecified &quot; +
            (p.length==0? &quot;&quot;:Debug.toHexString(new BigInteger(p))) + &quot;\n&quot;);
        return sb.toString();
    }
}
</pre>
</body>
</html>
