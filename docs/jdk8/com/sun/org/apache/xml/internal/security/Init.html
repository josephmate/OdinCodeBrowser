<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * reserved comment block
 * DO NOT REMOVE OR ALTER!
 */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.sun.org.apache.xml.internal.security;

import java.io.InputStream;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.List;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import com.sun.org.apache.xml.internal.security.algorithms.JCEMapper;
import com.sun.org.apache.xml.internal.security.algorithms.SignatureAlgorithm;
import com.sun.org.apache.xml.internal.security.c14n.Canonicalizer;
import com.sun.org.apache.xml.internal.security.keys.keyresolver.KeyResolver;
import com.sun.org.apache.xml.internal.security.transforms.Transform;
import com.sun.org.apache.xml.internal.security.utils.ElementProxy;
import com.sun.org.apache.xml.internal.security.utils.I18n;
import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolver;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;


/**
 * This class does the configuration of the library. This includes creating
 * the mapping of Canonicalization and Transform algorithms. Initialization is
 * done by calling {@link Init#init} which should be done in any static block
 * of the files of this library. We ensure that this call is only executed once.
 */
public class Init {

    /** The namespace for CONF file **/
    public static final String CONF_NS = &quot;http://www.xmlsecurity.org/NS/#configuration&quot;;

    /** {@link org.apache.commons.logging} logging facility */
    private static java.util.logging.Logger log =
        java.util.logging.Logger.getLogger(Init.class.getName());

    /** Field alreadyInitialized */
    private static boolean alreadyInitialized = false;

    /**
     * Method isInitialized
     * @return true if the library is already initialized.
     */
    public static synchronized final boolean isInitialized() {
        return Init.alreadyInitialized;
    }

    /**
     * Method init
     *
     */
    public static synchronized void init() {
        if (alreadyInitialized) {
            return;
        }

        InputStream is =
            AccessController.doPrivileged(
                new PrivilegedAction&lt;InputStream&gt;() {
                    public InputStream run() {
                        String cfile =
                            System.getProperty(&quot;com.sun.org.apache.xml.internal.security.resource.config&quot;);
                        if (cfile == null) {
                            return null;
                        }
                        return getClass().getResourceAsStream(cfile);
                    }
                });
        if (is == null) {
            dynamicInit();
        } else {
            fileInit(is);
        }

        alreadyInitialized = true;
    }

    /**
     * Dynamically initialise the library by registering the default algorithms/implementations
     */
    private static void dynamicInit() {
        //
        // Load the Resource Bundle - the default is the English resource bundle.
        // To load another resource bundle, call I18n.init(...) before calling this
        // method.
        //
        I18n.init(&quot;en&quot;, &quot;US&quot;);

        if (log.isLoggable(java.util.logging.Level.FINE)) {
            log.log(java.util.logging.Level.FINE, &quot;Registering default algorithms&quot;);
        }
        try {
            //
            // Bind the default prefixes
            //
            ElementProxy.registerDefaultPrefixes();

            //
            // Set the default Transforms
            //
            Transform.registerDefaultAlgorithms();

            //
            // Set the default signature algorithms
            //
            SignatureAlgorithm.registerDefaultAlgorithms();

            //
            // Set the default JCE algorithms
            //
            JCEMapper.registerDefaultAlgorithms();

            //
            // Set the default c14n algorithms
            //
            Canonicalizer.registerDefaultAlgorithms();

            //
            // Register the default resolvers
            //
            ResourceResolver.registerDefaultResolvers();

            //
            // Register the default key resolvers
            //
            KeyResolver.registerDefaultResolvers();
        } catch (Exception ex) {
            log.log(java.util.logging.Level.SEVERE, ex.getMessage(), ex);
            ex.printStackTrace();
        }
    }

    /**
     * Initialise the library from a configuration file
     */
    private static void fileInit(InputStream is) {
        try {
            /* read library configuration file */
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE);

            dbf.setNamespaceAware(true);
            dbf.setValidating(false);

            DocumentBuilder db = dbf.newDocumentBuilder();
            Document doc = db.parse(is);
            Node config = doc.getFirstChild();
            for (; config != null; config = config.getNextSibling()) {
                if (&quot;Configuration&quot;.equals(config.getLocalName())) {
                    break;
                }
            }
            if (config == null) {
                log.log(java.util.logging.Level.SEVERE, &quot;Error in reading configuration file - Configuration element not found&quot;);
                return;
            }
            for (Node el = config.getFirstChild(); el != null; el = el.getNextSibling()) {
                if (Node.ELEMENT_NODE != el.getNodeType()) {
                    continue;
                }
                String tag = el.getLocalName();
                if (tag.equals(&quot;ResourceBundles&quot;)) {
                    Element resource = (Element)el;
                    /* configure internationalization */
                    Attr langAttr = resource.getAttributeNode(&quot;defaultLanguageCode&quot;);
                    Attr countryAttr = resource.getAttributeNode(&quot;defaultCountryCode&quot;);
                    String languageCode =
                        (langAttr == null) ? null : langAttr.getNodeValue();
                    String countryCode =
                        (countryAttr == null) ? null : countryAttr.getNodeValue();
                    I18n.init(languageCode, countryCode);
                }

                if (tag.equals(&quot;CanonicalizationMethods&quot;)) {
                    Element[] list =
                        XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;CanonicalizationMethod&quot;);

                    for (int i = 0; i &lt; list.length; i++) {
                        String uri = list[i].getAttributeNS(null, &quot;URI&quot;);
                        String javaClass =
                            list[i].getAttributeNS(null, &quot;JAVACLASS&quot;);
                        try {
                            Canonicalizer.register(uri, javaClass);
                            if (log.isLoggable(java.util.logging.Level.FINE)) {
                                log.log(java.util.logging.Level.FINE, &quot;Canonicalizer.register(&quot; + uri + &quot;, &quot; + javaClass + &quot;)&quot;);
                            }
                        } catch (ClassNotFoundException e) {
                            Object exArgs[] = { uri, javaClass };
                            log.log(java.util.logging.Level.SEVERE, I18n.translate(&quot;algorithm.classDoesNotExist&quot;, exArgs));
                        }
                    }
                }

                if (tag.equals(&quot;TransformAlgorithms&quot;)) {
                    Element[] tranElem =
                        XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;TransformAlgorithm&quot;);

                    for (int i = 0; i &lt; tranElem.length; i++) {
                        String uri = tranElem[i].getAttributeNS(null, &quot;URI&quot;);
                        String javaClass =
                            tranElem[i].getAttributeNS(null, &quot;JAVACLASS&quot;);
                        try {
                            Transform.register(uri, javaClass);
                            if (log.isLoggable(java.util.logging.Level.FINE)) {
                                log.log(java.util.logging.Level.FINE, &quot;Transform.register(&quot; + uri + &quot;, &quot; + javaClass + &quot;)&quot;);
                            }
                        } catch (ClassNotFoundException e) {
                            Object exArgs[] = { uri, javaClass };

                            log.log(java.util.logging.Level.SEVERE, I18n.translate(&quot;algorithm.classDoesNotExist&quot;, exArgs));
                        } catch (NoClassDefFoundError ex) {
                            log.log(java.util.logging.Level.WARNING, &quot;Not able to found dependencies for algorithm, I'll keep working.&quot;);
                        }
                    }
                }

                if (&quot;JCEAlgorithmMappings&quot;.equals(tag)) {
                    Node algorithmsNode = ((Element)el).getElementsByTagName(&quot;Algorithms&quot;).item(0);
                    if (algorithmsNode != null) {
                        Element[] algorithms =
                            XMLUtils.selectNodes(algorithmsNode.getFirstChild(), CONF_NS, &quot;Algorithm&quot;);
                        for (int i = 0; i &lt; algorithms.length; i++) {
                            Element element = algorithms[i];
                            String id = element.getAttribute(&quot;URI&quot;);
                            JCEMapper.register(id, new JCEMapper.Algorithm(element));
                        }
                    }
                }

                if (tag.equals(&quot;SignatureAlgorithms&quot;)) {
                    Element[] sigElems =
                        XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;SignatureAlgorithm&quot;);

                    for (int i = 0; i &lt; sigElems.length; i++) {
                        String uri = sigElems[i].getAttributeNS(null, &quot;URI&quot;);
                        String javaClass =
                            sigElems[i].getAttributeNS(null, &quot;JAVACLASS&quot;);

                        /** $todo$ handle registering */

                        try {
                            SignatureAlgorithm.register(uri, javaClass);
                            if (log.isLoggable(java.util.logging.Level.FINE)) {
                                log.log(java.util.logging.Level.FINE, &quot;SignatureAlgorithm.register(&quot; + uri + &quot;, &quot;
                                          + javaClass + &quot;)&quot;);
                            }
                        } catch (ClassNotFoundException e) {
                            Object exArgs[] = { uri, javaClass };

                            log.log(java.util.logging.Level.SEVERE, I18n.translate(&quot;algorithm.classDoesNotExist&quot;, exArgs));
                        }
                    }
                }

                if (tag.equals(&quot;ResourceResolvers&quot;)) {
                    Element[]resolverElem =
                        XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;Resolver&quot;);

                    for (int i = 0; i &lt; resolverElem.length; i++) {
                        String javaClass =
                            resolverElem[i].getAttributeNS(null, &quot;JAVACLASS&quot;);
                        String description =
                            resolverElem[i].getAttributeNS(null, &quot;DESCRIPTION&quot;);

                        if ((description != null) &amp;&amp; (description.length() &gt; 0)) {
                            if (log.isLoggable(java.util.logging.Level.FINE)) {
                                log.log(java.util.logging.Level.FINE, &quot;Register Resolver: &quot; + javaClass + &quot;: &quot;
                                          + description);
                            }
                        } else {
                            if (log.isLoggable(java.util.logging.Level.FINE)) {
                                log.log(java.util.logging.Level.FINE, &quot;Register Resolver: &quot; + javaClass
                                          + &quot;: For unknown purposes&quot;);
                            }
                        }
                        try {
                            ResourceResolver.register(javaClass);
                        } catch (Throwable e) {
                            log.log(java.util.logging.Level.WARNING,
                                 &quot;Cannot register:&quot; + javaClass
                                 + &quot; perhaps some needed jars are not installed&quot;,
                                 e
                             );
                        }
                    }
                }

                if (tag.equals(&quot;KeyResolver&quot;)){
                    Element[] resolverElem =
                        XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;Resolver&quot;);
                    List&lt;String&gt; classNames = new ArrayList&lt;String&gt;(resolverElem.length);
                    for (int i = 0; i &lt; resolverElem.length; i++) {
                        String javaClass =
                            resolverElem[i].getAttributeNS(null, &quot;JAVACLASS&quot;);
                        String description =
                            resolverElem[i].getAttributeNS(null, &quot;DESCRIPTION&quot;);

                        if ((description != null) &amp;&amp; (description.length() &gt; 0)) {
                            if (log.isLoggable(java.util.logging.Level.FINE)) {
                                log.log(java.util.logging.Level.FINE, &quot;Register Resolver: &quot; + javaClass + &quot;: &quot;
                                          + description);
                            }
                        } else {
                            if (log.isLoggable(java.util.logging.Level.FINE)) {
                                log.log(java.util.logging.Level.FINE, &quot;Register Resolver: &quot; + javaClass
                                          + &quot;: For unknown purposes&quot;);
                            }
                        }
                        classNames.add(javaClass);
                    }
                    KeyResolver.registerClassNames(classNames);
                }


                if (tag.equals(&quot;PrefixMappings&quot;)){
                    if (log.isLoggable(java.util.logging.Level.FINE)) {
                        log.log(java.util.logging.Level.FINE, &quot;Now I try to bind prefixes:&quot;);
                    }

                    Element[] nl =
                        XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;PrefixMapping&quot;);

                    for (int i = 0; i &lt; nl.length; i++) {
                        String namespace = nl[i].getAttributeNS(null, &quot;namespace&quot;);
                        String prefix = nl[i].getAttributeNS(null, &quot;prefix&quot;);
                        if (log.isLoggable(java.util.logging.Level.FINE)) {
                            log.log(java.util.logging.Level.FINE, &quot;Now I try to bind &quot; + prefix + &quot; to &quot; + namespace);
                        }
                        ElementProxy.setDefaultPrefix(namespace, prefix);
                    }
                }
            }
        } catch (Exception e) {
            log.log(java.util.logging.Level.SEVERE, &quot;Bad: &quot;, e);
            e.printStackTrace();
        }
    }

}

</pre>
</body>
</html>
