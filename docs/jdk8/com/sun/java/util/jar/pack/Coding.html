<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<table>
<tr>
<td><a class="linenum-cell" data-linenum="1" href="#"></a></td>
<td><pre>/*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2" href="#"></a></td>
<td><pre> * Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3" href="#"></a></td>
<td><pre> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5" href="#"></a></td>
<td><pre> * This code is free software; you can redistribute it and/or modify it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="6" href="#"></a></td>
<td><pre> * under the terms of the GNU General Public License version 2 only, as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="7" href="#"></a></td>
<td><pre> * published by the Free Software Foundation.  Oracle designates this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="8" href="#"></a></td>
<td><pre> * particular file as subject to the &quot;Classpath&quot; exception as provided</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="9" href="#"></a></td>
<td><pre> * by Oracle in the LICENSE file that accompanied this code.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="10" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="11" href="#"></a></td>
<td><pre> * This code is distributed in the hope that it will be useful, but WITHOUT</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="12" href="#"></a></td>
<td><pre> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="13" href="#"></a></td>
<td><pre> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="14" href="#"></a></td>
<td><pre> * version 2 for more details (a copy is included in the LICENSE file that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="15" href="#"></a></td>
<td><pre> * accompanied this code).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="16" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="17" href="#"></a></td>
<td><pre> * You should have received a copy of the GNU General Public License version</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="18" href="#"></a></td>
<td><pre> * 2 along with this work; if not, write to the Free Software Foundation,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="19" href="#"></a></td>
<td><pre> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="20" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="21" href="#"></a></td>
<td><pre> * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="22" href="#"></a></td>
<td><pre> * or visit www.oracle.com if you need additional information or have any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="23" href="#"></a></td>
<td><pre> * questions.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="24" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="25" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="26" href="#"></a></td>
<td><pre>package com.sun.java.util.jar.pack;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="27" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="28" href="#"></a></td>
<td><pre>import java.io.IOException;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="29" href="#"></a></td>
<td><pre>import java.io.InputStream;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="30" href="#"></a></td>
<td><pre>import java.io.OutputStream;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="31" href="#"></a></td>
<td><pre>import java.util.HashMap;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="32" href="#"></a></td>
<td><pre>import java.util.Map;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="33" href="#"></a></td>
<td><pre>import static com.sun.java.util.jar.pack.Constants.*;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="34" href="#"></a></td>
<td><pre>/**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="35" href="#"></a></td>
<td><pre> * Define the conversions between sequences of small integers and raw bytes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="36" href="#"></a></td>
<td><pre> * This is a schema of encodings which incorporates varying lengths,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="37" href="#"></a></td>
<td><pre> * varying degrees of length variability, and varying amounts of signed-ness.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="38" href="#"></a></td>
<td><pre> * @author John Rose</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="39" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="40" href="#"></a></td>
<td><pre>class Coding implements Comparable&lt;Coding&gt;, CodingMethod, Histogram.BitMetric {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="41" href="#"></a></td>
<td><pre>    /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="42" href="#"></a></td>
<td><pre>      Coding schema for single integers, parameterized by (B,H,S):</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="43" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="44" href="#"></a></td>
<td><pre>      Let B in [1,5], H in [1,256], S in [0,3].</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="45" href="#"></a></td>
<td><pre>      (S limit is arbitrary.  B follows the 32-bit limit.  H is byte size.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="46" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="47" href="#"></a></td>
<td><pre>      A given (B,H,S) code varies in length from 1 to B bytes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="48" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="49" href="#"></a></td>
<td><pre>      The 256 values a byte may take on are divided into L=(256-H) and H</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="50" href="#"></a></td>
<td><pre>      values, with all the H values larger than the L values.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="51" href="#"></a></td>
<td><pre>      (That is, the L values are [0,L) and the H are [L,256).)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="52" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="53" href="#"></a></td>
<td><pre>      The last byte is always either the B-th byte, a byte with &quot;L value&quot;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="54" href="#"></a></td>
<td><pre>      (&lt;L), or both.  There is no other byte that satisfies these conditions.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="55" href="#"></a></td>
<td><pre>      All bytes before the last always have &quot;H values&quot; (&gt;=L).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="56" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="57" href="#"></a></td>
<td><pre>      Therefore, if L==0, the code always has the full length of B bytes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="58" href="#"></a></td>
<td><pre>      The coding then becomes a classic B-byte little-endian unsigned integer.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="59" href="#"></a></td>
<td><pre>      (Also, if L==128, the high bit of each byte acts signals the presence</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="60" href="#"></a></td>
<td><pre>      of a following byte, up to the maximum length.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="61" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="62" href="#"></a></td>
<td><pre>      In the unsigned case (S==0), the coding is compact and monotonic</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="63" href="#"></a></td>
<td><pre>      in the ordering of byte sequences defined by appending zero bytes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="64" href="#"></a></td>
<td><pre>      to pad them to a common length B, reversing them, and ordering them</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="65" href="#"></a></td>
<td><pre>      lexicographically.  (This agrees with &quot;little-endian&quot; byte order.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="66" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="67" href="#"></a></td>
<td><pre>      Therefore, the unsigned value of a byte sequence may be defined as:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="68" href="#"></a></td>
<td><pre>      &lt;pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="69" href="#"></a></td>
<td><pre>        U(b0)           == b0</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="70" href="#"></a></td>
<td><pre>                           in [0..L)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="71" href="#"></a></td>
<td><pre>                           or [0..256) if B==1 (**)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="72" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="73" href="#"></a></td>
<td><pre>        U(b0,b1)        == b0 + b1*H</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="74" href="#"></a></td>
<td><pre>                           in [L..L*(1+H))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="75" href="#"></a></td>
<td><pre>                           or [L..L*(1+H) + H^2) if B==2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="76" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="77" href="#"></a></td>
<td><pre>        U(b0,b1,b2)     == b0 + b1*H + b2*H^2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="78" href="#"></a></td>
<td><pre>                           in [L*(1+H)..L*(1+H+H^2))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="79" href="#"></a></td>
<td><pre>                           or [L*(1+H)..L*(1+H+H^2) + H^3) if B==3</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="80" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="81" href="#"></a></td>
<td><pre>        U(b[i]: i&lt;n)    == Sum[i&lt;n]( b[i] * H^i )</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="82" href="#"></a></td>
<td><pre>                           up to  L*Sum[i&lt;n]( H^i )</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="83" href="#"></a></td>
<td><pre>                           or to  L*Sum[i&lt;n]( H^i ) + H^n if n==B</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="84" href="#"></a></td>
<td><pre>      &lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="85" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="86" href="#"></a></td>
<td><pre>      (**) If B==1, the values H,L play no role in the coding.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="87" href="#"></a></td>
<td><pre>      As a convention, we require that any (1,H,S) code must always</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="88" href="#"></a></td>
<td><pre>      encode values less than H.  Thus, a simple unsigned byte is coded</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="89" href="#"></a></td>
<td><pre>      specifically by the code (1,256,0).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="90" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="91" href="#"></a></td>
<td><pre>      (Properly speaking, the unsigned case should be parameterized as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="92" href="#"></a></td>
<td><pre>      S==Infinity.  If the schema were regular, the case S==0 would really</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="93" href="#"></a></td>
<td><pre>      denote a numbering in which all coded values are negative.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="94" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="95" href="#"></a></td>
<td><pre>      If S&gt;0, the unsigned value of a byte sequence is regarded as a binary</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="96" href="#"></a></td>
<td><pre>      integer.  If any of the S low-order bits are zero, the corresponding</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="97" href="#"></a></td>
<td><pre>      signed value will be non-negative.  If all of the S low-order bits</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="98" href="#"></a></td>
<td><pre>      (S&gt;0) are one, the the corresponding signed value will be negative.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="99" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="100" href="#"></a></td>
<td><pre>      The non-negative signed values are compact and monotonically increasing</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="101" href="#"></a></td>
<td><pre>      (from 0) in the ordering of the corresponding unsigned values.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="102" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="103" href="#"></a></td>
<td><pre>      The negative signed values are compact and monotonically decreasing</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="104" href="#"></a></td>
<td><pre>      (from -1) in the ordering of the corresponding unsigned values.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="105" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="106" href="#"></a></td>
<td><pre>      In essence, the low-order S bits function as a collective sign bit</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="107" href="#"></a></td>
<td><pre>      for negative signed numbers, and as a low-order base-(2^S-1) digit</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="108" href="#"></a></td>
<td><pre>      for non-negative signed numbers.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="109" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="110" href="#"></a></td>
<td><pre>      Therefore, the signed value corresponding to an unsigned value is:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="111" href="#"></a></td>
<td><pre>      &lt;pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="112" href="#"></a></td>
<td><pre>        Sgn(x)  == x                               if S==0</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="113" href="#"></a></td>
<td><pre>        Sgn(x)  == (x / 2^S)*(2^S-1) + (x % 2^S),  if S&gt;0, (x % 2^S) &lt; 2^S-1</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="114" href="#"></a></td>
<td><pre>        Sgn(x)  == -(x / 2^S)-1,                   if S&gt;0, (x % 2^S) == 2^S-1</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="115" href="#"></a></td>
<td><pre>      &lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="116" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="117" href="#"></a></td>
<td><pre>      Finally, the value of a byte sequence, given the coding parameters</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="118" href="#"></a></td>
<td><pre>      (B,H,S), is defined as:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="119" href="#"></a></td>
<td><pre>      &lt;pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="120" href="#"></a></td>
<td><pre>        V(b[i]: i&lt;n)  == Sgn(U(b[i]: i&lt;n))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="121" href="#"></a></td>
<td><pre>      &lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="122" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="123" href="#"></a></td>
<td><pre>      The extremal positive and negative signed value for a given range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="124" href="#"></a></td>
<td><pre>      of unsigned values may be found by sign-encoding the largest unsigned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="125" href="#"></a></td>
<td><pre>      value which is not 2^S-1 mod 2^S, and that which is, respectively.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="126" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="127" href="#"></a></td>
<td><pre>      Because B,H,S are variable, this is not a single coding but a schema</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="128" href="#"></a></td>
<td><pre>      of codings.  For optimal compression, it is necessary to adaptively</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="129" href="#"></a></td>
<td><pre>      select specific codings to the data being compressed.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="130" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="131" href="#"></a></td>
<td><pre>      For example, if a sequence of values happens never to be negative,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="132" href="#"></a></td>
<td><pre>      S==0 is the best choice.  If the values are equally balanced between</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="133" href="#"></a></td>
<td><pre>      negative and positive, S==1.  If negative values are rare, then S&gt;1</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="134" href="#"></a></td>
<td><pre>      is more appropriate.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="135" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="136" href="#"></a></td>
<td><pre>      A (B,H,S) encoding is called a &quot;subrange&quot; if it does not encode</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="137" href="#"></a></td>
<td><pre>      the largest 32-bit value, and if the number R of values it does</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="138" href="#"></a></td>
<td><pre>      encode can be expressed as a positive 32-bit value.  (Note that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="139" href="#"></a></td>
<td><pre>      B=1 implies R&lt;=256, B=2 implies R&lt;=65536, etc.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="140" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="141" href="#"></a></td>
<td><pre>      A delta version of a given (B,H,S) coding encodes an array of integers</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="142" href="#"></a></td>
<td><pre>      by writing their successive differences in the (B,H,S) coding.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="143" href="#"></a></td>
<td><pre>      The original integers themselves may be recovered by making a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="144" href="#"></a></td>
<td><pre>      running accumulation of sum of the differences as they are read.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="145" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="146" href="#"></a></td>
<td><pre>      As a special case, if a (B,H,S) encoding is a subrange, its delta</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="147" href="#"></a></td>
<td><pre>      version will only encode arrays of numbers in the coding's unsigned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="148" href="#"></a></td>
<td><pre>      range, [0..R-1].  The coding of deltas is still in the normal signed</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="149" href="#"></a></td>
<td><pre>      range, if S!=0.  During delta encoding, all subtraction results are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="150" href="#"></a></td>
<td><pre>      reduced to the signed range, by adding multiples of R.  Likewise,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="151" href="#"></a></td>
<td><pre>.     during encoding, all addition results are reduced to the unsigned range.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="152" href="#"></a></td>
<td><pre>      This special case for subranges allows the benefits of wraparound</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="153" href="#"></a></td>
<td><pre>      when encoding correlated sequences of very small positive numbers.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="154" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="155" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="156" href="#"></a></td>
<td><pre>    // Code-specific limits:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="157" href="#"></a></td>
<td><pre>    private static int saturate32(long x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="158" href="#"></a></td>
<td><pre>        if (x &gt; Integer.MAX_VALUE)   return Integer.MAX_VALUE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="159" href="#"></a></td>
<td><pre>        if (x &lt; Integer.MIN_VALUE)   return Integer.MIN_VALUE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="160" href="#"></a></td>
<td><pre>        return (int)x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="161" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="162" href="#"></a></td>
<td><pre>    private static long codeRangeLong(int B, int H) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="163" href="#"></a></td>
<td><pre>        return codeRangeLong(B, H, B);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="164" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="165" href="#"></a></td>
<td><pre>    private static long codeRangeLong(int B, int H, int nMax) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="166" href="#"></a></td>
<td><pre>        // Code range for a all (B,H) codes of length &lt;=nMax (&lt;=B).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="167" href="#"></a></td>
<td><pre>        // n &lt; B:   L*Sum[i&lt;n]( H^i )</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="168" href="#"></a></td>
<td><pre>        // n == B:  L*Sum[i&lt;B]( H^i ) + H^B</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="169" href="#"></a></td>
<td><pre>        assert(nMax &gt;= 0 &amp;&amp; nMax &lt;= B);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="170" href="#"></a></td>
<td><pre>        assert(B &gt;= 1 &amp;&amp; B &lt;= 5);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="171" href="#"></a></td>
<td><pre>        assert(H &gt;= 1 &amp;&amp; H &lt;= 256);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="172" href="#"></a></td>
<td><pre>        if (nMax == 0)  return 0;  // no codes of zero length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="173" href="#"></a></td>
<td><pre>        if (B == 1)     return H;  // special case; see (**) above</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="174" href="#"></a></td>
<td><pre>        int L = 256-H;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="175" href="#"></a></td>
<td><pre>        long sum = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="176" href="#"></a></td>
<td><pre>        long H_i = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="177" href="#"></a></td>
<td><pre>        for (int n = 1; n &lt;= nMax; n++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="178" href="#"></a></td>
<td><pre>            sum += H_i;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="179" href="#"></a></td>
<td><pre>            H_i *= H;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="180" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="181" href="#"></a></td>
<td><pre>        sum *= L;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="182" href="#"></a></td>
<td><pre>        if (nMax == B)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="183" href="#"></a></td>
<td><pre>            sum += H_i;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="184" href="#"></a></td>
<td><pre>        return sum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="185" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="186" href="#"></a></td>
<td><pre>    /** Largest int representable by (B,H,S) in up to nMax bytes. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="187" href="#"></a></td>
<td><pre>    public static int codeMax(int B, int H, int S, int nMax) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="188" href="#"></a></td>
<td><pre>        //assert(S &gt;= 0 &amp;&amp; S &lt;= S_MAX);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="189" href="#"></a></td>
<td><pre>        long range = codeRangeLong(B, H, nMax);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="190" href="#"></a></td>
<td><pre>        if (range == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="191" href="#"></a></td>
<td><pre>            return -1;  // degenerate max value for empty set of codes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="192" href="#"></a></td>
<td><pre>        if (S == 0 || range &gt;= (long)1&lt;&lt;32)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="193" href="#"></a></td>
<td><pre>            return saturate32(range-1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="194" href="#"></a></td>
<td><pre>        long maxPos = range-1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="195" href="#"></a></td>
<td><pre>        while (isNegativeCode(maxPos, S)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="196" href="#"></a></td>
<td><pre>            --maxPos;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="197" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="198" href="#"></a></td>
<td><pre>        if (maxPos &lt; 0)  return -1;  // No positive codings at all.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="199" href="#"></a></td>
<td><pre>        int smax = decodeSign32(maxPos, S);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="200" href="#"></a></td>
<td><pre>        // check for 32-bit wraparound:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="201" href="#"></a></td>
<td><pre>        if (smax &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="202" href="#"></a></td>
<td><pre>            return Integer.MAX_VALUE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="203" href="#"></a></td>
<td><pre>        return smax;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="204" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="205" href="#"></a></td>
<td><pre>    /** Smallest int representable by (B,H,S) in up to nMax bytes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="206" href="#"></a></td>
<td><pre>        Returns Integer.MIN_VALUE if 32-bit wraparound covers</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="207" href="#"></a></td>
<td><pre>        the entire negative range.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="208" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="209" href="#"></a></td>
<td><pre>    public static int codeMin(int B, int H, int S, int nMax) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="210" href="#"></a></td>
<td><pre>        //assert(S &gt;= 0 &amp;&amp; S &lt;= S_MAX);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="211" href="#"></a></td>
<td><pre>        long range = codeRangeLong(B, H, nMax);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="212" href="#"></a></td>
<td><pre>        if (range &gt;= (long)1&lt;&lt;32 &amp;&amp; nMax == B) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="213" href="#"></a></td>
<td><pre>            // Can code negative values via 32-bit wraparound.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="214" href="#"></a></td>
<td><pre>            return Integer.MIN_VALUE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="215" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="216" href="#"></a></td>
<td><pre>        if (S == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="217" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="218" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="219" href="#"></a></td>
<td><pre>        long maxNeg = range-1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="220" href="#"></a></td>
<td><pre>        while (!isNegativeCode(maxNeg, S))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="221" href="#"></a></td>
<td><pre>            --maxNeg;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="222" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="223" href="#"></a></td>
<td><pre>        if (maxNeg &lt; 0)  return 0;  // No negative codings at all.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="224" href="#"></a></td>
<td><pre>        return decodeSign32(maxNeg, S);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="225" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="226" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="227" href="#"></a></td>
<td><pre>    // Some of the arithmetic below is on unsigned 32-bit integers.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="228" href="#"></a></td>
<td><pre>    // These must be represented in Java as longs in the range [0..2^32-1].</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="229" href="#"></a></td>
<td><pre>    // The conversion to a signed int is just the Java cast (int), but</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="230" href="#"></a></td>
<td><pre>    // the conversion to an unsigned int is the following little method:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="231" href="#"></a></td>
<td><pre>    private static long toUnsigned32(int sx) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="232" href="#"></a></td>
<td><pre>        return ((long)sx &lt;&lt; 32) &gt;&gt;&gt; 32;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="233" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="234" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="235" href="#"></a></td>
<td><pre>    // Sign encoding:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="236" href="#"></a></td>
<td><pre>    private static boolean isNegativeCode(long ux, int S) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="237" href="#"></a></td>
<td><pre>        assert(S &gt; 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="238" href="#"></a></td>
<td><pre>        assert(ux &gt;= -1);  // can be out of 32-bit range; who cares</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="239" href="#"></a></td>
<td><pre>        int Smask = (1&lt;&lt;S)-1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="240" href="#"></a></td>
<td><pre>        return (((int)ux+1) &amp; Smask) == 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="241" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="242" href="#"></a></td>
<td><pre>    private static boolean hasNegativeCode(int sx, int S) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="243" href="#"></a></td>
<td><pre>        assert(S &gt; 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="244" href="#"></a></td>
<td><pre>        // If S&gt;=2 very low negatives are coded by 32-bit-wrapped positives.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="245" href="#"></a></td>
<td><pre>        // The lowest negative representable by a negative coding is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="246" href="#"></a></td>
<td><pre>        // ~(umax32 &gt;&gt; S), and the next lower number is coded by wrapping</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="247" href="#"></a></td>
<td><pre>        // the highest positive:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="248" href="#"></a></td>
<td><pre>        //    CodePos(umax32-1)  -&gt;  (umax32-1)-((umax32-1)&gt;&gt;S)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="249" href="#"></a></td>
<td><pre>        // which simplifies to ~(umax32 &gt;&gt; S)-1.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="250" href="#"></a></td>
<td><pre>        return (0 &gt; sx) &amp;&amp; (sx &gt;= ~(-1&gt;&gt;&gt;S));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="251" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="252" href="#"></a></td>
<td><pre>    private static int decodeSign32(long ux, int S) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="253" href="#"></a></td>
<td><pre>        assert(ux == toUnsigned32((int)ux))  // must be unsigned 32-bit number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="254" href="#"></a></td>
<td><pre>            : (Long.toHexString(ux));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="255" href="#"></a></td>
<td><pre>        if (S == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="256" href="#"></a></td>
<td><pre>            return (int) ux;  // cast to signed int</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="257" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="258" href="#"></a></td>
<td><pre>        int sx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="259" href="#"></a></td>
<td><pre>        if (isNegativeCode(ux, S)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="260" href="#"></a></td>
<td><pre>            // Sgn(x)  == -(x / 2^S)-1</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="261" href="#"></a></td>
<td><pre>            sx = ~((int)ux &gt;&gt;&gt; S);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="262" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="263" href="#"></a></td>
<td><pre>            // Sgn(x)  == (x / 2^S)*(2^S-1) + (x % 2^S)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="264" href="#"></a></td>
<td><pre>            sx = (int)ux - ((int)ux &gt;&gt;&gt; S);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="265" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="266" href="#"></a></td>
<td><pre>        // Assert special case of S==1:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="267" href="#"></a></td>
<td><pre>        assert(!(S == 1) || sx == (((int)ux &gt;&gt;&gt; 1) ^ -((int)ux &amp; 1)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="268" href="#"></a></td>
<td><pre>        return sx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="269" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="270" href="#"></a></td>
<td><pre>    private static long encodeSign32(int sx, int S) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="271" href="#"></a></td>
<td><pre>        if (S == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="272" href="#"></a></td>
<td><pre>            return toUnsigned32(sx);  // unsigned 32-bit int</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="273" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="274" href="#"></a></td>
<td><pre>        int Smask = (1&lt;&lt;S)-1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="275" href="#"></a></td>
<td><pre>        long ux;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="276" href="#"></a></td>
<td><pre>        if (!hasNegativeCode(sx, S)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="277" href="#"></a></td>
<td><pre>            // InvSgn(sx) = (sx / (2^S-1))*2^S + (sx % (2^S-1))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="278" href="#"></a></td>
<td><pre>            ux = sx + (toUnsigned32(sx) / Smask);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="279" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="280" href="#"></a></td>
<td><pre>            // InvSgn(sx) = (-sx-1)*2^S + (2^S-1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="281" href="#"></a></td>
<td><pre>            ux = (-sx &lt;&lt; S) - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="282" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="283" href="#"></a></td>
<td><pre>        ux = toUnsigned32((int)ux);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="284" href="#"></a></td>
<td><pre>        assert(sx == decodeSign32(ux, S))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="285" href="#"></a></td>
<td><pre>            : (Long.toHexString(ux)+&quot; -&gt; &quot;+</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="286" href="#"></a></td>
<td><pre>               Integer.toHexString(sx)+&quot; != &quot;+</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="287" href="#"></a></td>
<td><pre>               Integer.toHexString(decodeSign32(ux, S)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="288" href="#"></a></td>
<td><pre>        return ux;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="289" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="290" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="291" href="#"></a></td>
<td><pre>    // Top-level coding of single integers:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="292" href="#"></a></td>
<td><pre>    public static void writeInt(byte[] out, int[] outpos, int sx, int B, int H, int S) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="293" href="#"></a></td>
<td><pre>        long ux = encodeSign32(sx, S);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="294" href="#"></a></td>
<td><pre>        assert(ux == toUnsigned32((int)ux));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="295" href="#"></a></td>
<td><pre>        assert(ux &lt; codeRangeLong(B, H))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="296" href="#"></a></td>
<td><pre>            : Long.toHexString(ux);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="297" href="#"></a></td>
<td><pre>        int L = 256-H;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="298" href="#"></a></td>
<td><pre>        long sum = ux;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="299" href="#"></a></td>
<td><pre>        int pos = outpos[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="300" href="#"></a></td>
<td><pre>        for (int i = 0; i &lt; B-1; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="301" href="#"></a></td>
<td><pre>            if (sum &lt; L)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="302" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="303" href="#"></a></td>
<td><pre>            sum -= L;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="304" href="#"></a></td>
<td><pre>            int b_i = (int)( L + (sum % H) );</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="305" href="#"></a></td>
<td><pre>            sum /= H;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="306" href="#"></a></td>
<td><pre>            out[pos++] = (byte)b_i;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="307" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="308" href="#"></a></td>
<td><pre>        out[pos++] = (byte)sum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="309" href="#"></a></td>
<td><pre>        // Report number of bytes written by updating outpos[0]:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="310" href="#"></a></td>
<td><pre>        outpos[0] = pos;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="311" href="#"></a></td>
<td><pre>        // Check right away for mis-coding.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="312" href="#"></a></td>
<td><pre>        //assert(sx == readInt(out, new int[1], B, H, S));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="313" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="314" href="#"></a></td>
<td><pre>    public static int readInt(byte[] in, int[] inpos, int B, int H, int S) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="315" href="#"></a></td>
<td><pre>        // U(b[i]: i&lt;n) == Sum[i&lt;n]( b[i] * H^i )</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="316" href="#"></a></td>
<td><pre>        int L = 256-H;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="317" href="#"></a></td>
<td><pre>        long sum = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="318" href="#"></a></td>
<td><pre>        long H_i = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="319" href="#"></a></td>
<td><pre>        int pos = inpos[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="320" href="#"></a></td>
<td><pre>        for (int i = 0; i &lt; B; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="321" href="#"></a></td>
<td><pre>            int b_i = in[pos++] &amp; 0xFF;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="322" href="#"></a></td>
<td><pre>            sum += b_i*H_i;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="323" href="#"></a></td>
<td><pre>            H_i *= H;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="324" href="#"></a></td>
<td><pre>            if (b_i &lt; L)  break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="325" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="326" href="#"></a></td>
<td><pre>        //assert(sum &gt;= 0 &amp;&amp; sum &lt; codeRangeLong(B, H));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="327" href="#"></a></td>
<td><pre>        // Report number of bytes read by updating inpos[0]:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="328" href="#"></a></td>
<td><pre>        inpos[0] = pos;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="329" href="#"></a></td>
<td><pre>        return decodeSign32(sum, S);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="330" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="331" href="#"></a></td>
<td><pre>    // The Stream version doesn't fetch a byte unless it is needed for coding.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="332" href="#"></a></td>
<td><pre>    public static int readIntFrom(InputStream in, int B, int H, int S) throws IOException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="333" href="#"></a></td>
<td><pre>        // U(b[i]: i&lt;n) == Sum[i&lt;n]( b[i] * H^i )</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="334" href="#"></a></td>
<td><pre>        int L = 256-H;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="335" href="#"></a></td>
<td><pre>        long sum = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="336" href="#"></a></td>
<td><pre>        long H_i = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="337" href="#"></a></td>
<td><pre>        for (int i = 0; i &lt; B; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="338" href="#"></a></td>
<td><pre>            int b_i = in.read();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="339" href="#"></a></td>
<td><pre>            if (b_i &lt; 0)  throw new RuntimeException(&quot;unexpected EOF&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="340" href="#"></a></td>
<td><pre>            sum += b_i*H_i;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="341" href="#"></a></td>
<td><pre>            H_i *= H;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="342" href="#"></a></td>
<td><pre>            if (b_i &lt; L)  break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="343" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="344" href="#"></a></td>
<td><pre>        assert(sum &gt;= 0 &amp;&amp; sum &lt; codeRangeLong(B, H));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="345" href="#"></a></td>
<td><pre>        return decodeSign32(sum, S);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="346" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="347" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="348" href="#"></a></td>
<td><pre>    public static final int B_MAX = 5;    /* B: [1,5] */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="349" href="#"></a></td>
<td><pre>    public static final int H_MAX = 256;  /* H: [1,256] */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="350" href="#"></a></td>
<td><pre>    public static final int S_MAX = 2;    /* S: [0,2] */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="351" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="352" href="#"></a></td>
<td><pre>    // END OF STATICS.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="353" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="354" href="#"></a></td>
<td><pre>    private final int B; /*1..5*/       // # bytes (1..5)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="355" href="#"></a></td>
<td><pre>    private final int H; /*1..256*/     // # codes requiring a higher byte</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="356" href="#"></a></td>
<td><pre>    private final int L; /*0..255*/     // # codes requiring a higher byte</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="357" href="#"></a></td>
<td><pre>    private final int S; /*0..3*/       // # low-order bits representing sign</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="358" href="#"></a></td>
<td><pre>    private final int del; /*0..2*/     // type of delta encoding (0 == none)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="359" href="#"></a></td>
<td><pre>    private final int min;              // smallest representable value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="360" href="#"></a></td>
<td><pre>    private final int max;              // largest representable value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="361" href="#"></a></td>
<td><pre>    private final int umin;             // smallest representable uns. value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="362" href="#"></a></td>
<td><pre>    private final int umax;             // largest representable uns. value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="363" href="#"></a></td>
<td><pre>    private final int[] byteMin;        // smallest repr. value, given # bytes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="364" href="#"></a></td>
<td><pre>    private final int[] byteMax;        // largest repr. value, given # bytes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="365" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="366" href="#"></a></td>
<td><pre>    private Coding(int B, int H, int S) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="367" href="#"></a></td>
<td><pre>        this(B, H, S, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="368" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="369" href="#"></a></td>
<td><pre>    private Coding(int B, int H, int S, int del) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="370" href="#"></a></td>
<td><pre>        this.B = B;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="371" href="#"></a></td>
<td><pre>        this.H = H;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="372" href="#"></a></td>
<td><pre>        this.L = 256-H;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="373" href="#"></a></td>
<td><pre>        this.S = S;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="374" href="#"></a></td>
<td><pre>        this.del = del;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="375" href="#"></a></td>
<td><pre>        this.min = codeMin(B, H, S, B);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="376" href="#"></a></td>
<td><pre>        this.max = codeMax(B, H, S, B);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="377" href="#"></a></td>
<td><pre>        this.umin = codeMin(B, H, 0, B);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="378" href="#"></a></td>
<td><pre>        this.umax = codeMax(B, H, 0, B);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="379" href="#"></a></td>
<td><pre>        this.byteMin = new int[B];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="380" href="#"></a></td>
<td><pre>        this.byteMax = new int[B];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="381" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="382" href="#"></a></td>
<td><pre>        for (int nMax = 1; nMax &lt;= B; nMax++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="383" href="#"></a></td>
<td><pre>            byteMin[nMax-1] = codeMin(B, H, S, nMax);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="384" href="#"></a></td>
<td><pre>            byteMax[nMax-1] = codeMax(B, H, S, nMax);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="385" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="386" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="387" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="388" href="#"></a></td>
<td><pre>    public boolean equals(Object x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="389" href="#"></a></td>
<td><pre>        if (!(x instanceof Coding))  return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="390" href="#"></a></td>
<td><pre>        Coding that = (Coding) x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="391" href="#"></a></td>
<td><pre>        if (this.B != that.B)  return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="392" href="#"></a></td>
<td><pre>        if (this.H != that.H)  return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="393" href="#"></a></td>
<td><pre>        if (this.S != that.S)  return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="394" href="#"></a></td>
<td><pre>        if (this.del != that.del)  return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="395" href="#"></a></td>
<td><pre>        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="396" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="397" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="398" href="#"></a></td>
<td><pre>    public int hashCode() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="399" href="#"></a></td>
<td><pre>        return (del&lt;&lt;14)+(S&lt;&lt;11)+(B&lt;&lt;8)+(H&lt;&lt;0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="400" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="401" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="402" href="#"></a></td>
<td><pre>    private static Map&lt;Coding, Coding&gt; codeMap;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="403" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="404" href="#"></a></td>
<td><pre>    private static synchronized Coding of(int B, int H, int S, int del) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="405" href="#"></a></td>
<td><pre>        if (codeMap == null)  codeMap = new HashMap&lt;&gt;();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="406" href="#"></a></td>
<td><pre>        Coding x0 = new Coding(B, H, S, del);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="407" href="#"></a></td>
<td><pre>        Coding x1 = codeMap.get(x0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="408" href="#"></a></td>
<td><pre>        if (x1 == null)  codeMap.put(x0, x1 = x0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="409" href="#"></a></td>
<td><pre>        return x1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="410" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="411" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="412" href="#"></a></td>
<td><pre>    public static Coding of(int B, int H) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="413" href="#"></a></td>
<td><pre>        return of(B, H, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="414" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="415" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="416" href="#"></a></td>
<td><pre>    public static Coding of(int B, int H, int S) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="417" href="#"></a></td>
<td><pre>        return of(B, H, S, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="418" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="419" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="420" href="#"></a></td>
<td><pre>    public boolean canRepresentValue(int x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="421" href="#"></a></td>
<td><pre>        if (isSubrange())</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="422" href="#"></a></td>
<td><pre>            return canRepresentUnsigned(x);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="423" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="424" href="#"></a></td>
<td><pre>            return canRepresentSigned(x);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="425" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="426" href="#"></a></td>
<td><pre>    /** Can this coding represent a single value, possibly a delta?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="427" href="#"></a></td>
<td><pre>     *  This ignores the D property.  That is, for delta codings,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="428" href="#"></a></td>
<td><pre>     *  this tests whether a delta value of 'x' can be coded.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="429" href="#"></a></td>
<td><pre>     *  For signed delta codings which produce unsigned end values,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="430" href="#"></a></td>
<td><pre>     *  use canRepresentUnsigned.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="431" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="432" href="#"></a></td>
<td><pre>    public boolean canRepresentSigned(int x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="433" href="#"></a></td>
<td><pre>        return (x &gt;= min &amp;&amp; x &lt;= max);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="434" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="435" href="#"></a></td>
<td><pre>    /** Can this coding, apart from its S property,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="436" href="#"></a></td>
<td><pre>     *  represent a single value?  (Negative values</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="437" href="#"></a></td>
<td><pre>     *  can only be represented via 32-bit overflow,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="438" href="#"></a></td>
<td><pre>     *  so this returns true for negative values</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="439" href="#"></a></td>
<td><pre>     *  if isFullRange is true.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="440" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="441" href="#"></a></td>
<td><pre>    public boolean canRepresentUnsigned(int x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="442" href="#"></a></td>
<td><pre>        return (x &gt;= umin &amp;&amp; x &lt;= umax);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="443" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="444" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="445" href="#"></a></td>
<td><pre>    // object-oriented code/decode</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="446" href="#"></a></td>
<td><pre>    public int readFrom(byte[] in, int[] inpos) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="447" href="#"></a></td>
<td><pre>        return readInt(in, inpos, B, H, S);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="448" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="449" href="#"></a></td>
<td><pre>    public void writeTo(byte[] out, int[] outpos, int x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="450" href="#"></a></td>
<td><pre>        writeInt(out, outpos, x, B, H, S);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="451" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="452" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="453" href="#"></a></td>
<td><pre>    // Stream versions</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="454" href="#"></a></td>
<td><pre>    public int readFrom(InputStream in) throws IOException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="455" href="#"></a></td>
<td><pre>        return readIntFrom(in, B, H, S);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="456" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="457" href="#"></a></td>
<td><pre>    public void writeTo(OutputStream out, int x) throws IOException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="458" href="#"></a></td>
<td><pre>        byte[] buf = new byte[B];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="459" href="#"></a></td>
<td><pre>        int[] pos = new int[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="460" href="#"></a></td>
<td><pre>        writeInt(buf, pos, x, B, H, S);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="461" href="#"></a></td>
<td><pre>        out.write(buf, 0, pos[0]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="462" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="463" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="464" href="#"></a></td>
<td><pre>    // Stream/array versions</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="465" href="#"></a></td>
<td><pre>    public void readArrayFrom(InputStream in, int[] a, int start, int end) throws IOException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="466" href="#"></a></td>
<td><pre>        // %%% use byte[] buffer</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="467" href="#"></a></td>
<td><pre>        for (int i = start; i &lt; end; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="468" href="#"></a></td>
<td><pre>            a[i] = readFrom(in);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="469" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="470" href="#"></a></td>
<td><pre>        for (int dstep = 0; dstep &lt; del; dstep++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="471" href="#"></a></td>
<td><pre>            long state = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="472" href="#"></a></td>
<td><pre>            for (int i = start; i &lt; end; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="473" href="#"></a></td>
<td><pre>                state += a[i];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="474" href="#"></a></td>
<td><pre>                // Reduce array values to the required range.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="475" href="#"></a></td>
<td><pre>                if (isSubrange()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="476" href="#"></a></td>
<td><pre>                    state = reduceToUnsignedRange(state);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="477" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="478" href="#"></a></td>
<td><pre>                a[i] = (int) state;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="479" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="480" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="481" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="482" href="#"></a></td>
<td><pre>    public void writeArrayTo(OutputStream out, int[] a, int start, int end) throws IOException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="483" href="#"></a></td>
<td><pre>        if (end &lt;= start)  return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="484" href="#"></a></td>
<td><pre>        for (int dstep = 0; dstep &lt; del; dstep++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="485" href="#"></a></td>
<td><pre>            int[] deltas;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="486" href="#"></a></td>
<td><pre>            if (!isSubrange())</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="487" href="#"></a></td>
<td><pre>                deltas = makeDeltas(a, start, end, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="488" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="489" href="#"></a></td>
<td><pre>                deltas = makeDeltas(a, start, end, min, max);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="490" href="#"></a></td>
<td><pre>            a = deltas;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="491" href="#"></a></td>
<td><pre>            start = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="492" href="#"></a></td>
<td><pre>            end = deltas.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="493" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="494" href="#"></a></td>
<td><pre>        // The following code is a buffered version of this loop:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="495" href="#"></a></td>
<td><pre>        //    for (int i = start; i &lt; end; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="496" href="#"></a></td>
<td><pre>        //        writeTo(out, a[i]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="497" href="#"></a></td>
<td><pre>        byte[] buf = new byte[1&lt;&lt;8];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="498" href="#"></a></td>
<td><pre>        final int bufmax = buf.length-B;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="499" href="#"></a></td>
<td><pre>        int[] pos = { 0 };</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="500" href="#"></a></td>
<td><pre>        for (int i = start; i &lt; end; ) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="501" href="#"></a></td>
<td><pre>            while (pos[0] &lt;= bufmax) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="502" href="#"></a></td>
<td><pre>                writeTo(buf, pos, a[i++]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="503" href="#"></a></td>
<td><pre>                if (i &gt;= end)  break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="504" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="505" href="#"></a></td>
<td><pre>            out.write(buf, 0, pos[0]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="506" href="#"></a></td>
<td><pre>            pos[0] = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="507" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="508" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="509" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="510" href="#"></a></td>
<td><pre>    /** Tell if the range of this coding (number of distinct</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="511" href="#"></a></td>
<td><pre>     *  representable values) can be expressed in 32 bits.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="512" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="513" href="#"></a></td>
<td><pre>    boolean isSubrange() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="514" href="#"></a></td>
<td><pre>        return max &lt; Integer.MAX_VALUE</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="515" href="#"></a></td>
<td><pre>            &amp;&amp; ((long)max - (long)min + 1) &lt;= Integer.MAX_VALUE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="516" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="517" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="518" href="#"></a></td>
<td><pre>    /** Tell if this coding can represent all 32-bit values.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="519" href="#"></a></td>
<td><pre>     *  Note:  Some codings, such as unsigned ones, can be neither</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="520" href="#"></a></td>
<td><pre>     *  subranges nor full-range codings.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="521" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="522" href="#"></a></td>
<td><pre>    boolean isFullRange() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="523" href="#"></a></td>
<td><pre>        return max == Integer.MAX_VALUE &amp;&amp; min == Integer.MIN_VALUE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="524" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="525" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="526" href="#"></a></td>
<td><pre>    /** Return the number of values this coding (a subrange) can represent. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="527" href="#"></a></td>
<td><pre>    int getRange() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="528" href="#"></a></td>
<td><pre>        assert(isSubrange());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="529" href="#"></a></td>
<td><pre>        return (max - min) + 1;  // range includes both min &amp; max</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="530" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="531" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="532" href="#"></a></td>
<td><pre>    Coding setB(int B) { return Coding.of(B, H, S, del); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="533" href="#"></a></td>
<td><pre>    Coding setH(int H) { return Coding.of(B, H, S, del); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="534" href="#"></a></td>
<td><pre>    Coding setS(int S) { return Coding.of(B, H, S, del); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="535" href="#"></a></td>
<td><pre>    Coding setL(int L) { return setH(256-L); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="536" href="#"></a></td>
<td><pre>    Coding setD(int del) { return Coding.of(B, H, S, del); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="537" href="#"></a></td>
<td><pre>    Coding getDeltaCoding() { return setD(del+1); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="538" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="539" href="#"></a></td>
<td><pre>    /** Return a coding suitable for representing summed, modulo-reduced values. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="540" href="#"></a></td>
<td><pre>    Coding getValueCoding() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="541" href="#"></a></td>
<td><pre>        if (isDelta())</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="542" href="#"></a></td>
<td><pre>            return Coding.of(B, H, 0, del-1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="543" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="544" href="#"></a></td>
<td><pre>            return this;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="545" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="546" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="547" href="#"></a></td>
<td><pre>    /** Reduce the given value to be within this coding's unsigned range,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="548" href="#"></a></td>
<td><pre>     *  by adding or subtracting a multiple of (max-min+1).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="549" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="550" href="#"></a></td>
<td><pre>    int reduceToUnsignedRange(long value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="551" href="#"></a></td>
<td><pre>        if (value == (int)value &amp;&amp; canRepresentUnsigned((int)value))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="552" href="#"></a></td>
<td><pre>            // already in unsigned range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="553" href="#"></a></td>
<td><pre>            return (int)value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="554" href="#"></a></td>
<td><pre>        int range = getRange();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="555" href="#"></a></td>
<td><pre>        assert(range &gt; 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="556" href="#"></a></td>
<td><pre>        value %= range;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="557" href="#"></a></td>
<td><pre>        if (value &lt; 0)  value += range;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="558" href="#"></a></td>
<td><pre>        assert(canRepresentUnsigned((int)value));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="559" href="#"></a></td>
<td><pre>        return (int)value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="560" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="561" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="562" href="#"></a></td>
<td><pre>    int reduceToSignedRange(int value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="563" href="#"></a></td>
<td><pre>        if (canRepresentSigned(value))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="564" href="#"></a></td>
<td><pre>            // already in signed range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="565" href="#"></a></td>
<td><pre>            return value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="566" href="#"></a></td>
<td><pre>        return reduceToSignedRange(value, min, max);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="567" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="568" href="#"></a></td>
<td><pre>    static int reduceToSignedRange(int value, int min, int max) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="569" href="#"></a></td>
<td><pre>        int range = (max-min+1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="570" href="#"></a></td>
<td><pre>        assert(range &gt; 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="571" href="#"></a></td>
<td><pre>        int value0 = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="572" href="#"></a></td>
<td><pre>        value -= min;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="573" href="#"></a></td>
<td><pre>        if (value &lt; 0 &amp;&amp; value0 &gt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="574" href="#"></a></td>
<td><pre>            // 32-bit overflow, but the next '%=' op needs to be unsigned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="575" href="#"></a></td>
<td><pre>            value -= range;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="576" href="#"></a></td>
<td><pre>            assert(value &gt;= 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="577" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="578" href="#"></a></td>
<td><pre>        value %= range;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="579" href="#"></a></td>
<td><pre>        if (value &lt; 0)  value += range;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="580" href="#"></a></td>
<td><pre>        value += min;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="581" href="#"></a></td>
<td><pre>        assert(min &lt;= value &amp;&amp; value &lt;= max);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="582" href="#"></a></td>
<td><pre>        return value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="583" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="584" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="585" href="#"></a></td>
<td><pre>    /** Does this coding support at least one negative value?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="586" href="#"></a></td>
<td><pre>        Includes codings that can do so via 32-bit wraparound.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="587" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="588" href="#"></a></td>
<td><pre>    boolean isSigned() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="589" href="#"></a></td>
<td><pre>        return min &lt; 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="590" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="591" href="#"></a></td>
<td><pre>    /** Does this coding code arrays by making successive differences? */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="592" href="#"></a></td>
<td><pre>    boolean isDelta() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="593" href="#"></a></td>
<td><pre>        return del != 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="594" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="595" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="596" href="#"></a></td>
<td><pre>    public int B() { return B; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="597" href="#"></a></td>
<td><pre>    public int H() { return H; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="598" href="#"></a></td>
<td><pre>    public int L() { return L; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="599" href="#"></a></td>
<td><pre>    public int S() { return S; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="600" href="#"></a></td>
<td><pre>    public int del() { return del; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="601" href="#"></a></td>
<td><pre>    public int min() { return min; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="602" href="#"></a></td>
<td><pre>    public int max() { return max; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="603" href="#"></a></td>
<td><pre>    public int umin() { return umin; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="604" href="#"></a></td>
<td><pre>    public int umax() { return umax; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="605" href="#"></a></td>
<td><pre>    public int byteMin(int b) { return byteMin[b-1]; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="606" href="#"></a></td>
<td><pre>    public int byteMax(int b) { return byteMax[b-1]; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="607" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="608" href="#"></a></td>
<td><pre>    public int compareTo(Coding that) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="609" href="#"></a></td>
<td><pre>        int dkey = this.del - that.del;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="610" href="#"></a></td>
<td><pre>        if (dkey == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="611" href="#"></a></td>
<td><pre>            dkey = this.B - that.B;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="612" href="#"></a></td>
<td><pre>        if (dkey == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="613" href="#"></a></td>
<td><pre>            dkey = this.H - that.H;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="614" href="#"></a></td>
<td><pre>        if (dkey == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="615" href="#"></a></td>
<td><pre>            dkey = this.S - that.S;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="616" href="#"></a></td>
<td><pre>        return dkey;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="617" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="618" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="619" href="#"></a></td>
<td><pre>    /** Heuristic measure of the difference between two codings. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="620" href="#"></a></td>
<td><pre>    public int distanceFrom(Coding that) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="621" href="#"></a></td>
<td><pre>        int diffdel = this.del - that.del;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="622" href="#"></a></td>
<td><pre>        if (diffdel &lt; 0)  diffdel = -diffdel;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="623" href="#"></a></td>
<td><pre>        int diffS = this.S - that.S;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="624" href="#"></a></td>
<td><pre>        if (diffS &lt; 0)  diffS = -diffS;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="625" href="#"></a></td>
<td><pre>        int diffB = this.B - that.B;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="626" href="#"></a></td>
<td><pre>        if (diffB &lt; 0)  diffB = -diffB;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="627" href="#"></a></td>
<td><pre>        int diffHL;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="628" href="#"></a></td>
<td><pre>        if (this.H == that.H) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="629" href="#"></a></td>
<td><pre>            diffHL = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="630" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="631" href="#"></a></td>
<td><pre>            // Distance in log space of H (&lt;=128) and L (&lt;128).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="632" href="#"></a></td>
<td><pre>            int thisHL = this.getHL();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="633" href="#"></a></td>
<td><pre>            int thatHL = that.getHL();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="634" href="#"></a></td>
<td><pre>            // Double the accuracy of the log:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="635" href="#"></a></td>
<td><pre>            thisHL *= thisHL;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="636" href="#"></a></td>
<td><pre>            thatHL *= thatHL;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="637" href="#"></a></td>
<td><pre>            if (thisHL &gt; thatHL)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="638" href="#"></a></td>
<td><pre>                diffHL = ceil_lg2(1+(thisHL-1)/thatHL);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="639" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="640" href="#"></a></td>
<td><pre>                diffHL = ceil_lg2(1+(thatHL-1)/thisHL);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="641" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="642" href="#"></a></td>
<td><pre>        int norm = 5*(diffdel + diffS + diffB) + diffHL;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="643" href="#"></a></td>
<td><pre>        assert(norm != 0 || this.compareTo(that) == 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="644" href="#"></a></td>
<td><pre>        return norm;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="645" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="646" href="#"></a></td>
<td><pre>    private int getHL() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="647" href="#"></a></td>
<td><pre>        // Follow H in log space by the multiplicative inverse of L.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="648" href="#"></a></td>
<td><pre>        if (H &lt;= 128)  return H;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="649" href="#"></a></td>
<td><pre>        if (L &gt;= 1)    return 128*128/L;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="650" href="#"></a></td>
<td><pre>        return 128*256;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="651" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="652" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="653" href="#"></a></td>
<td><pre>    /** ceiling(log[2](x)): {1-&gt;0, 2-&gt;1, 3-&gt;2, 4-&gt;2, ...} */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="654" href="#"></a></td>
<td><pre>    static int ceil_lg2(int x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="655" href="#"></a></td>
<td><pre>        assert(x-1 &gt;= 0);  // x in range (int.MIN_VALUE -&gt; 32)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="656" href="#"></a></td>
<td><pre>        x -= 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="657" href="#"></a></td>
<td><pre>        int lg = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="658" href="#"></a></td>
<td><pre>        while (x != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="659" href="#"></a></td>
<td><pre>            lg++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="660" href="#"></a></td>
<td><pre>            x &gt;&gt;= 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="661" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="662" href="#"></a></td>
<td><pre>        return lg;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="663" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="664" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="665" href="#"></a></td>
<td><pre>    static private final byte[] byteBitWidths = new byte[0x100];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="666" href="#"></a></td>
<td><pre>    static {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="667" href="#"></a></td>
<td><pre>        for (int b = 0; b &lt; byteBitWidths.length; b++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="668" href="#"></a></td>
<td><pre>            byteBitWidths[b] = (byte) ceil_lg2(b + 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="669" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="670" href="#"></a></td>
<td><pre>        for (int i = 10; i &gt;= 0; i = (i &lt;&lt; 1) - (i &gt;&gt; 3)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="671" href="#"></a></td>
<td><pre>            assert(bitWidth(i) == ceil_lg2(i + 1));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="672" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="673" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="674" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="675" href="#"></a></td>
<td><pre>    /** Number of significant bits in i, not counting sign bits.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="676" href="#"></a></td>
<td><pre>     *  For positive i, it is ceil_lg2(i + 1).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="677" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="678" href="#"></a></td>
<td><pre>    static int bitWidth(int i) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="679" href="#"></a></td>
<td><pre>        if (i &lt; 0)  i = ~i;  // change sign</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="680" href="#"></a></td>
<td><pre>        int w = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="681" href="#"></a></td>
<td><pre>        int lo = i;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="682" href="#"></a></td>
<td><pre>        if (lo &lt; byteBitWidths.length)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="683" href="#"></a></td>
<td><pre>            return byteBitWidths[lo];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="684" href="#"></a></td>
<td><pre>        int hi;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="685" href="#"></a></td>
<td><pre>        hi = (lo &gt;&gt;&gt; 16);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="686" href="#"></a></td>
<td><pre>        if (hi != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="687" href="#"></a></td>
<td><pre>            lo = hi;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="688" href="#"></a></td>
<td><pre>            w += 16;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="689" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="690" href="#"></a></td>
<td><pre>        hi = (lo &gt;&gt;&gt; 8);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="691" href="#"></a></td>
<td><pre>        if (hi != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="692" href="#"></a></td>
<td><pre>            lo = hi;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="693" href="#"></a></td>
<td><pre>            w += 8;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="694" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="695" href="#"></a></td>
<td><pre>        w += byteBitWidths[lo];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="696" href="#"></a></td>
<td><pre>        //assert(w == ceil_lg2(i + 1));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="697" href="#"></a></td>
<td><pre>        return w;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="698" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="699" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="700" href="#"></a></td>
<td><pre>    /** Create an array of successive differences.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="701" href="#"></a></td>
<td><pre>     *  If min==max, accept any and all 32-bit overflow.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="702" href="#"></a></td>
<td><pre>     *  Otherwise, avoid 32-bit overflow, and reduce all differences</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="703" href="#"></a></td>
<td><pre>     *  to a value in the given range, by adding or subtracting</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="704" href="#"></a></td>
<td><pre>     *  multiples of the range cardinality (max-min+1).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="705" href="#"></a></td>
<td><pre>     *  Also, the values are assumed to be in the range [0..(max-min)].</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="706" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="707" href="#"></a></td>
<td><pre>    static int[] makeDeltas(int[] values, int start, int end,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="708" href="#"></a></td>
<td><pre>                            int min, int max) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="709" href="#"></a></td>
<td><pre>        assert(max &gt;= min);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="710" href="#"></a></td>
<td><pre>        int count = end-start;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="711" href="#"></a></td>
<td><pre>        int[] deltas = new int[count];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="712" href="#"></a></td>
<td><pre>        int state = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="713" href="#"></a></td>
<td><pre>        if (min == max) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="714" href="#"></a></td>
<td><pre>            for (int i = 0; i &lt; count; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="715" href="#"></a></td>
<td><pre>                int value = values[start+i];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="716" href="#"></a></td>
<td><pre>                deltas[i] = value - state;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="717" href="#"></a></td>
<td><pre>                state = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="718" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="719" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="720" href="#"></a></td>
<td><pre>            for (int i = 0; i &lt; count; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="721" href="#"></a></td>
<td><pre>                int value = values[start+i];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="722" href="#"></a></td>
<td><pre>                assert(value &gt;= 0 &amp;&amp; value+min &lt;= max);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="723" href="#"></a></td>
<td><pre>                int delta = value - state;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="724" href="#"></a></td>
<td><pre>                assert(delta == (long)value - (long)state); // no overflow</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="725" href="#"></a></td>
<td><pre>                state = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="726" href="#"></a></td>
<td><pre>                // Reduce delta values to the required range.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="727" href="#"></a></td>
<td><pre>                delta = reduceToSignedRange(delta, min, max);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="728" href="#"></a></td>
<td><pre>                deltas[i] = delta;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="729" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="730" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="731" href="#"></a></td>
<td><pre>        return deltas;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="732" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="733" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="734" href="#"></a></td>
<td><pre>    boolean canRepresent(int minValue, int maxValue) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="735" href="#"></a></td>
<td><pre>        assert(minValue &lt;= maxValue);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="736" href="#"></a></td>
<td><pre>        if (del &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="737" href="#"></a></td>
<td><pre>            if (isSubrange()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="738" href="#"></a></td>
<td><pre>                // We will force the values to reduce to the right subrange.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="739" href="#"></a></td>
<td><pre>                return canRepresentUnsigned(maxValue)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="740" href="#"></a></td>
<td><pre>                    &amp;&amp; canRepresentUnsigned(minValue);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="741" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="742" href="#"></a></td>
<td><pre>                // Huge range; delta values must assume full 32-bit range.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="743" href="#"></a></td>
<td><pre>                return isFullRange();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="744" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="745" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="746" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="747" href="#"></a></td>
<td><pre>            // final values must be representable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="748" href="#"></a></td>
<td><pre>            return canRepresentSigned(maxValue)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="749" href="#"></a></td>
<td><pre>                &amp;&amp; canRepresentSigned(minValue);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="750" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="751" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="752" href="#"></a></td>
<td><pre>    boolean canRepresent(int[] values, int start, int end) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="753" href="#"></a></td>
<td><pre>        int len = end-start;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="754" href="#"></a></td>
<td><pre>        if (len == 0)       return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="755" href="#"></a></td>
<td><pre>        if (isFullRange())  return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="756" href="#"></a></td>
<td><pre>        // Calculate max, min:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="757" href="#"></a></td>
<td><pre>        int lmax = values[start];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="758" href="#"></a></td>
<td><pre>        int lmin = lmax;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="759" href="#"></a></td>
<td><pre>        for (int i = 1; i &lt; len; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="760" href="#"></a></td>
<td><pre>            int value = values[start+i];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="761" href="#"></a></td>
<td><pre>            if (lmax &lt; value)  lmax = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="762" href="#"></a></td>
<td><pre>            if (lmin &gt; value)  lmin = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="763" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="764" href="#"></a></td>
<td><pre>        return canRepresent(lmin, lmax);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="765" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="766" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="767" href="#"></a></td>
<td><pre>    public double getBitLength(int value) {  // implements BitMetric</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="768" href="#"></a></td>
<td><pre>        return (double) getLength(value) * 8;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="769" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="770" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="771" href="#"></a></td>
<td><pre>    /** How many bytes are in the coding of this value?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="772" href="#"></a></td>
<td><pre>     *  Returns Integer.MAX_VALUE if the value has no coding.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="773" href="#"></a></td>
<td><pre>     *  The coding must not be a delta coding, since there is no</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="774" href="#"></a></td>
<td><pre>     *  definite size for a single value apart from its context.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="775" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="776" href="#"></a></td>
<td><pre>    public int getLength(int value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="777" href="#"></a></td>
<td><pre>        if (isDelta() &amp;&amp; isSubrange()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="778" href="#"></a></td>
<td><pre>            if (!canRepresentUnsigned(value))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="779" href="#"></a></td>
<td><pre>                return Integer.MAX_VALUE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="780" href="#"></a></td>
<td><pre>            value = reduceToSignedRange(value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="781" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="782" href="#"></a></td>
<td><pre>        if (value &gt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="783" href="#"></a></td>
<td><pre>            for (int n = 0; n &lt; B; n++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="784" href="#"></a></td>
<td><pre>                if (value &lt;= byteMax[n])  return n+1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="785" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="786" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="787" href="#"></a></td>
<td><pre>            for (int n = 0; n &lt; B; n++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="788" href="#"></a></td>
<td><pre>                if (value &gt;= byteMin[n])  return n+1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="789" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="790" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="791" href="#"></a></td>
<td><pre>        return Integer.MAX_VALUE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="792" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="793" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="794" href="#"></a></td>
<td><pre>    public int getLength(int[] values, int start, int end) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="795" href="#"></a></td>
<td><pre>        int len = end-start;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="796" href="#"></a></td>
<td><pre>        if (B == 1)  return len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="797" href="#"></a></td>
<td><pre>        if (L == 0)  return len * B;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="798" href="#"></a></td>
<td><pre>        if (isDelta()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="799" href="#"></a></td>
<td><pre>            int[] deltas;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="800" href="#"></a></td>
<td><pre>            if (!isSubrange())</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="801" href="#"></a></td>
<td><pre>                deltas = makeDeltas(values, start, end, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="802" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="803" href="#"></a></td>
<td><pre>                deltas = makeDeltas(values, start, end, min, max);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="804" href="#"></a></td>
<td><pre>            //return Coding.of(B, H, S).getLength(deltas, 0, len);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="805" href="#"></a></td>
<td><pre>            values = deltas;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="806" href="#"></a></td>
<td><pre>            start = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="807" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="808" href="#"></a></td>
<td><pre>        int sum = len;  // at least 1 byte per</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="809" href="#"></a></td>
<td><pre>        // add extra bytes for extra-long values</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="810" href="#"></a></td>
<td><pre>        for (int n = 1; n &lt;= B; n++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="811" href="#"></a></td>
<td><pre>            // what is the coding interval [min..max] for n bytes?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="812" href="#"></a></td>
<td><pre>            int lmax = byteMax[n-1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="813" href="#"></a></td>
<td><pre>            int lmin = byteMin[n-1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="814" href="#"></a></td>
<td><pre>            int longer = 0;  // count of guys longer than n bytes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="815" href="#"></a></td>
<td><pre>            for (int i = 0; i &lt; len; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="816" href="#"></a></td>
<td><pre>                int value = values[start+i];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="817" href="#"></a></td>
<td><pre>                if (value &gt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="818" href="#"></a></td>
<td><pre>                    if (value &gt; lmax)  longer++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="819" href="#"></a></td>
<td><pre>                } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="820" href="#"></a></td>
<td><pre>                    if (value &lt; lmin)  longer++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="821" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="822" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="823" href="#"></a></td>
<td><pre>            if (longer == 0)  break;  // no more passes needed</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="824" href="#"></a></td>
<td><pre>            if (n == B)  return Integer.MAX_VALUE;  // cannot represent!</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="825" href="#"></a></td>
<td><pre>            sum += longer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="826" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="827" href="#"></a></td>
<td><pre>        return sum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="828" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="829" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="830" href="#"></a></td>
<td><pre>    public byte[] getMetaCoding(Coding dflt) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="831" href="#"></a></td>
<td><pre>        if (dflt == this)  return new byte[]{ (byte) _meta_default };</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="832" href="#"></a></td>
<td><pre>        int canonicalIndex = BandStructure.indexOf(this);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="833" href="#"></a></td>
<td><pre>        if (canonicalIndex &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="834" href="#"></a></td>
<td><pre>            return new byte[]{ (byte) canonicalIndex };</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="835" href="#"></a></td>
<td><pre>        return new byte[]{</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="836" href="#"></a></td>
<td><pre>            (byte)_meta_arb,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="837" href="#"></a></td>
<td><pre>            (byte)(del + 2*S + 8*(B-1)),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="838" href="#"></a></td>
<td><pre>            (byte)(H-1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="839" href="#"></a></td>
<td><pre>        };</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="840" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="841" href="#"></a></td>
<td><pre>    public static int parseMetaCoding(byte[] bytes, int pos, Coding dflt, CodingMethod res[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="842" href="#"></a></td>
<td><pre>        int op = bytes[pos++] &amp; 0xFF;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="843" href="#"></a></td>
<td><pre>        if (_meta_canon_min &lt;= op &amp;&amp; op &lt;= _meta_canon_max) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="844" href="#"></a></td>
<td><pre>            Coding c = BandStructure.codingForIndex(op);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="845" href="#"></a></td>
<td><pre>            assert(c != null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="846" href="#"></a></td>
<td><pre>            res[0] = c;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="847" href="#"></a></td>
<td><pre>            return pos;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="848" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="849" href="#"></a></td>
<td><pre>        if (op == _meta_arb) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="850" href="#"></a></td>
<td><pre>            int dsb = bytes[pos++] &amp; 0xFF;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="851" href="#"></a></td>
<td><pre>            int H_1 = bytes[pos++] &amp; 0xFF;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="852" href="#"></a></td>
<td><pre>            int del = dsb % 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="853" href="#"></a></td>
<td><pre>            int S = (dsb / 2) % 4;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="854" href="#"></a></td>
<td><pre>            int B = (dsb / 8)+1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="855" href="#"></a></td>
<td><pre>            int H = H_1+1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="856" href="#"></a></td>
<td><pre>            if (!((1 &lt;= B &amp;&amp; B &lt;= B_MAX) &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="857" href="#"></a></td>
<td><pre>                  (0 &lt;= S &amp;&amp; S &lt;= S_MAX) &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="858" href="#"></a></td>
<td><pre>                  (1 &lt;= H &amp;&amp; H &lt;= H_MAX) &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="859" href="#"></a></td>
<td><pre>                  (0 &lt;= del &amp;&amp; del &lt;= 1))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="860" href="#"></a></td>
<td><pre>                || (B == 1 &amp;&amp; H != 256)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="861" href="#"></a></td>
<td><pre>                || (B == 5 &amp;&amp; H == 256)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="862" href="#"></a></td>
<td><pre>                throw new RuntimeException(&quot;Bad arb. coding: (&quot;+B+&quot;,&quot;+H+&quot;,&quot;+S+&quot;,&quot;+del);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="863" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="864" href="#"></a></td>
<td><pre>            res[0] = Coding.of(B, H, S, del);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="865" href="#"></a></td>
<td><pre>            return pos;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="866" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="867" href="#"></a></td>
<td><pre>        return pos-1;  // backup</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="868" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="869" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="870" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="871" href="#"></a></td>
<td><pre>    public String keyString() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="872" href="#"></a></td>
<td><pre>        return &quot;(&quot;+B+&quot;,&quot;+H+&quot;,&quot;+S+&quot;,&quot;+del+&quot;)&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="873" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="874" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="875" href="#"></a></td>
<td><pre>    public String toString() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="876" href="#"></a></td>
<td><pre>        String str = &quot;Coding&quot;+keyString();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="877" href="#"></a></td>
<td><pre>        // If -ea, print out more informative strings!</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="878" href="#"></a></td>
<td><pre>        //assert((str = stringForDebug()) != null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="879" href="#"></a></td>
<td><pre>        return str;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="880" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="881" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="882" href="#"></a></td>
<td><pre>    static boolean verboseStringForDebug = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="883" href="#"></a></td>
<td><pre>    String stringForDebug() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="884" href="#"></a></td>
<td><pre>        String minS = (min == Integer.MIN_VALUE ? &quot;min&quot; : &quot;&quot;+min);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="885" href="#"></a></td>
<td><pre>        String maxS = (max == Integer.MAX_VALUE ? &quot;max&quot; : &quot;&quot;+max);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="886" href="#"></a></td>
<td><pre>        String str = keyString()+&quot; L=&quot;+L+&quot; r=[&quot;+minS+&quot;,&quot;+maxS+&quot;]&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="887" href="#"></a></td>
<td><pre>        if (isSubrange())</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="888" href="#"></a></td>
<td><pre>            str += &quot; subrange&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="889" href="#"></a></td>
<td><pre>        else if (!isFullRange())</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="890" href="#"></a></td>
<td><pre>            str += &quot; MIDRANGE&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="891" href="#"></a></td>
<td><pre>        if (verboseStringForDebug) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="892" href="#"></a></td>
<td><pre>            str += &quot; {&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="893" href="#"></a></td>
<td><pre>            int prev_range = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="894" href="#"></a></td>
<td><pre>            for (int n = 1; n &lt;= B; n++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="895" href="#"></a></td>
<td><pre>                int range_n = saturate32((long)byteMax[n-1] - byteMin[n-1] + 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="896" href="#"></a></td>
<td><pre>                assert(range_n == saturate32(codeRangeLong(B, H, n)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="897" href="#"></a></td>
<td><pre>                range_n -= prev_range;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="898" href="#"></a></td>
<td><pre>                prev_range = range_n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="899" href="#"></a></td>
<td><pre>                String rngS = (range_n == Integer.MAX_VALUE ? &quot;max&quot; : &quot;&quot;+range_n);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="900" href="#"></a></td>
<td><pre>                str += &quot; #&quot;+n+&quot;=&quot;+rngS;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="901" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="902" href="#"></a></td>
<td><pre>            str += &quot; }&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="903" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="904" href="#"></a></td>
<td><pre>        return str;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="905" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="906" href="#"></a></td>
<td><pre>}</pre></td>
</tr>
</table>
</body>
</html>
