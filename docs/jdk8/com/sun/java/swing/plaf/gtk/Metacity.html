<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.java.swing.plaf.gtk;

import sun.swing.SwingUtilities2;
import com.sun.java.swing.plaf.gtk.GTKConstants.ArrowType;
import com.sun.java.swing.plaf.gtk.GTKConstants.ShadowType;

import javax.swing.plaf.ColorUIResource;
import javax.swing.plaf.synth.*;

import java.awt.*;
import java.awt.geom.*;
import java.awt.image.*;
import java.io.*;
import java.net.*;
import java.security.*;
import java.util.*;

import javax.swing.*;
import javax.swing.border.*;

import javax.xml.parsers.*;
import org.xml.sax.SAXException;
import org.w3c.dom.*;

/**
 */
class Metacity implements SynthConstants {
    // Tutorial:
    // http://developer.gnome.org/doc/tutorials/metacity/metacity-themes.html

    // Themes:
    // http://art.gnome.org/theme_list.php?category=metacity

    static Metacity INSTANCE;

    private static final String[] themeNames = {
        getUserTheme(),
        &quot;blueprint&quot;,
        &quot;Bluecurve&quot;,
        &quot;Crux&quot;,
        &quot;SwingFallbackTheme&quot;
    };

    static {
        for (String themeName : themeNames) {
            if (themeName != null) {
            try {
                INSTANCE = new Metacity(themeName);
            } catch (FileNotFoundException ex) {
            } catch (IOException ex) {
                logError(themeName, ex);
            } catch (ParserConfigurationException ex) {
                logError(themeName, ex);
            } catch (SAXException ex) {
                logError(themeName, ex);
            }
            }
            if (INSTANCE != null) {
            break;
            }
        }
        if (INSTANCE == null) {
            throw new Error(&quot;Could not find any installed metacity theme, and fallback failed&quot;);
        }
    }

    private static boolean errorLogged = false;
    private static DocumentBuilder documentBuilder;
    private static Document xmlDoc;
    private static String userHome;

    private Node frame_style_set;
    private Map&lt;String, Object&gt; frameGeometry;
    private Map&lt;String, Map&lt;String, Object&gt;&gt; frameGeometries;

    private LayoutManager titlePaneLayout = new TitlePaneLayout();

    private ColorizeImageFilter imageFilter = new ColorizeImageFilter();
    private URL themeDir = null;
    private SynthContext context;
    private String themeName;

    private ArithmeticExpressionEvaluator aee = new ArithmeticExpressionEvaluator();
    private Map&lt;String, Integer&gt; variables;

    // Reusable clip shape object
    private RoundRectClipShape roundedClipShape;

    protected Metacity(String themeName) throws IOException, ParserConfigurationException, SAXException {
        this.themeName = themeName;
        themeDir = getThemeDir(themeName);
        if (themeDir != null) {
            URL themeURL = new URL(themeDir, &quot;metacity-theme-1.xml&quot;);
            xmlDoc = getXMLDoc(themeURL);
            if (xmlDoc == null) {
                throw new IOException(themeURL.toString());
            }
        } else {
            throw new FileNotFoundException(themeName);
        }

        // Initialize constants
        variables = new HashMap&lt;String, Integer&gt;();
        NodeList nodes = xmlDoc.getElementsByTagName(&quot;constant&quot;);
        int n = nodes.getLength();
        for (int i = 0; i &lt; n; i++) {
            Node node = nodes.item(i);
            String name = getStringAttr(node, &quot;name&quot;);
            if (name != null) {
                String value = getStringAttr(node, &quot;value&quot;);
                if (value != null) {
                    try {
                        variables.put(name, Integer.parseInt(value));
                    } catch (NumberFormatException ex) {
                        logError(themeName, ex);
                        // Ignore bad value
                    }
                }
            }
        }

        // Cache frame geometries
        frameGeometries = new HashMap&lt;String, Map&lt;String, Object&gt;&gt;();
        nodes = xmlDoc.getElementsByTagName(&quot;frame_geometry&quot;);
        n = nodes.getLength();
        for (int i = 0; i &lt; n; i++) {
            Node node = nodes.item(i);
            String name = getStringAttr(node, &quot;name&quot;);
            if (name != null) {
                HashMap&lt;String, Object&gt; gm = new HashMap&lt;String, Object&gt;();
                frameGeometries.put(name, gm);

                String parentGM = getStringAttr(node, &quot;parent&quot;);
                if (parentGM != null) {
                    gm.putAll(frameGeometries.get(parentGM));
                }

                gm.put(&quot;has_title&quot;,
                       Boolean.valueOf(getBooleanAttr(node, &quot;has_title&quot;,            true)));
                gm.put(&quot;rounded_top_left&quot;,
                       Boolean.valueOf(getBooleanAttr(node, &quot;rounded_top_left&quot;,     false)));
                gm.put(&quot;rounded_top_right&quot;,
                       Boolean.valueOf(getBooleanAttr(node, &quot;rounded_top_right&quot;,    false)));
                gm.put(&quot;rounded_bottom_left&quot;,
                       Boolean.valueOf(getBooleanAttr(node, &quot;rounded_bottom_left&quot;,  false)));
                gm.put(&quot;rounded_bottom_right&quot;,
                       Boolean.valueOf(getBooleanAttr(node, &quot;rounded_bottom_right&quot;, false)));

                NodeList childNodes = node.getChildNodes();
                int nc = childNodes.getLength();
                for (int j = 0; j &lt; nc; j++) {
                    Node child = childNodes.item(j);
                    if (child.getNodeType() == Node.ELEMENT_NODE) {
                        name = child.getNodeName();
                        Object value = null;
                        if (&quot;distance&quot;.equals(name)) {
                            value = Integer.valueOf(getIntAttr(child, &quot;value&quot;, 0));
                        } else if (&quot;border&quot;.equals(name)) {
                            value = new Insets(getIntAttr(child, &quot;top&quot;, 0),
                                               getIntAttr(child, &quot;left&quot;, 0),
                                               getIntAttr(child, &quot;bottom&quot;, 0),
                                               getIntAttr(child, &quot;right&quot;, 0));
                        } else if (&quot;aspect_ratio&quot;.equals(name)) {
                            value = new Float(getFloatAttr(child, &quot;value&quot;, 1.0F));
                        } else {
                            logError(themeName, &quot;Unknown Metacity frame geometry value type: &quot;+name);
                        }
                        String childName = getStringAttr(child, &quot;name&quot;);
                        if (childName != null &amp;&amp; value != null) {
                            gm.put(childName, value);
                        }
                    }
                }
            }
        }
        frameGeometry = frameGeometries.get(&quot;normal&quot;);
    }


    public static LayoutManager getTitlePaneLayout() {
        return INSTANCE.titlePaneLayout;
    }

    private Shape getRoundedClipShape(int x, int y, int w, int h,
                                      int arcw, int arch, int corners) {
        if (roundedClipShape == null) {
            roundedClipShape = new RoundRectClipShape();
        }
        roundedClipShape.setRoundedRect(x, y, w, h, arcw, arch, corners);

        return roundedClipShape;
    }

    void paintButtonBackground(SynthContext context, Graphics g, int x, int y, int w, int h) {
        updateFrameGeometry(context);

        this.context = context;
        JButton button = (JButton)context.getComponent();
        String buttonName = button.getName();
        int buttonState = context.getComponentState();

        JComponent titlePane = (JComponent)button.getParent();
        Container titlePaneParent = titlePane.getParent();

        JInternalFrame jif;
        if (titlePaneParent instanceof JInternalFrame) {
            jif = (JInternalFrame)titlePaneParent;
        } else if (titlePaneParent instanceof JInternalFrame.JDesktopIcon) {
            jif = ((JInternalFrame.JDesktopIcon)titlePaneParent).getInternalFrame();
        } else {
            return;
        }

        boolean active = jif.isSelected();
        button.setOpaque(false);

        String state = &quot;normal&quot;;
        if ((buttonState &amp; PRESSED) != 0) {
            state = &quot;pressed&quot;;
        } else if ((buttonState &amp; MOUSE_OVER) != 0) {
            state = &quot;prelight&quot;;
        }

        String function = null;
        String location = null;
        boolean left_corner  = false;
        boolean right_corner = false;


        if (buttonName == &quot;InternalFrameTitlePane.menuButton&quot;) {
            function = &quot;menu&quot;;
            location = &quot;left_left&quot;;
            left_corner = true;
        } else if (buttonName == &quot;InternalFrameTitlePane.iconifyButton&quot;) {
            function = &quot;minimize&quot;;
            int nButtons = ((jif.isIconifiable() ? 1 : 0) +
                            (jif.isMaximizable() ? 1 : 0) +
                            (jif.isClosable() ? 1 : 0));
            right_corner = (nButtons == 1);
            switch (nButtons) {
              case 1: location = &quot;right_right&quot;; break;
              case 2: location = &quot;right_middle&quot;; break;
              case 3: location = &quot;right_left&quot;; break;
            }
        } else if (buttonName == &quot;InternalFrameTitlePane.maximizeButton&quot;) {
            function = &quot;maximize&quot;;
            right_corner = !jif.isClosable();
            location = jif.isClosable() ? &quot;right_middle&quot; : &quot;right_right&quot;;
        } else if (buttonName == &quot;InternalFrameTitlePane.closeButton&quot;) {
            function = &quot;close&quot;;
            right_corner = true;
            location = &quot;right_right&quot;;
        }

        Node frame = getNode(frame_style_set, &quot;frame&quot;, new String[] {
            &quot;focus&quot;, (active ? &quot;yes&quot; : &quot;no&quot;),
            &quot;state&quot;, (jif.isMaximum() ? &quot;maximized&quot; : &quot;normal&quot;)
        });

        if (function != null &amp;&amp; frame != null) {
            Node frame_style = getNode(&quot;frame_style&quot;, new String[] {
                &quot;name&quot;, getStringAttr(frame, &quot;style&quot;)
            });
            if (frame_style != null) {
                Shape oldClip = g.getClip();
                if ((right_corner &amp;&amp; getBoolean(&quot;rounded_top_right&quot;, false)) ||
                    (left_corner  &amp;&amp; getBoolean(&quot;rounded_top_left&quot;, false))) {

                    Point buttonLoc = button.getLocation();
                    if (right_corner) {
                        g.setClip(getRoundedClipShape(0, 0, w, h,
                                                      12, 12, RoundRectClipShape.TOP_RIGHT));
                    } else {
                        g.setClip(getRoundedClipShape(0, 0, w, h,
                                                      11, 11, RoundRectClipShape.TOP_LEFT));
                    }

                    Rectangle clipBounds = oldClip.getBounds();
                    g.clipRect(clipBounds.x, clipBounds.y,
                               clipBounds.width, clipBounds.height);
                }
                drawButton(frame_style, location+&quot;_background&quot;, state, g, w, h, jif);
                drawButton(frame_style, function, state, g, w, h, jif);
                g.setClip(oldClip);
            }
        }
    }

    protected void drawButton(Node frame_style, String function, String state,
                            Graphics g, int w, int h, JInternalFrame jif) {
        Node buttonNode = getNode(frame_style, &quot;button&quot;,
                                  new String[] { &quot;function&quot;, function, &quot;state&quot;, state });
        if (buttonNode == null &amp;&amp; !state.equals(&quot;normal&quot;)) {
            buttonNode = getNode(frame_style, &quot;button&quot;,
                                 new String[] { &quot;function&quot;, function, &quot;state&quot;, &quot;normal&quot; });
        }
        if (buttonNode != null) {
            Node draw_ops;
            String draw_ops_name = getStringAttr(buttonNode, &quot;draw_ops&quot;);
            if (draw_ops_name != null) {
                draw_ops = getNode(&quot;draw_ops&quot;, new String[] { &quot;name&quot;, draw_ops_name });
            } else {
                draw_ops = getNode(buttonNode, &quot;draw_ops&quot;, null);
            }
            variables.put(&quot;width&quot;,  w);
            variables.put(&quot;height&quot;, h);
            draw(draw_ops, g, jif);
        }
    }

    void paintFrameBorder(SynthContext context, Graphics g, int x0, int y0, int width, int height) {
        updateFrameGeometry(context);

        this.context = context;
        JComponent comp = context.getComponent();
        JComponent titlePane = findChild(comp, &quot;InternalFrame.northPane&quot;);

        if (titlePane == null) {
            return;
        }

        JInternalFrame jif = null;
        if (comp instanceof JInternalFrame) {
            jif = (JInternalFrame)comp;
        } else if (comp instanceof JInternalFrame.JDesktopIcon) {
            jif = ((JInternalFrame.JDesktopIcon)comp).getInternalFrame();
        } else {
            assert false : &quot;component is not JInternalFrame or JInternalFrame.JDesktopIcon&quot;;
            return;
        }

        boolean active = jif.isSelected();
        Font oldFont = g.getFont();
        g.setFont(titlePane.getFont());
        g.translate(x0, y0);

        Rectangle titleRect = calculateTitleArea(jif);
        JComponent menuButton = findChild(titlePane, &quot;InternalFrameTitlePane.menuButton&quot;);

        Icon frameIcon = jif.getFrameIcon();
        variables.put(&quot;mini_icon_width&quot;,
                      (frameIcon != null) ? frameIcon.getIconWidth()  : 0);
        variables.put(&quot;mini_icon_height&quot;,
                      (frameIcon != null) ? frameIcon.getIconHeight() : 0);
        variables.put(&quot;title_width&quot;,  calculateTitleTextWidth(g, jif));
        FontMetrics fm = SwingUtilities2.getFontMetrics(jif, g);
        variables.put(&quot;title_height&quot;, fm.getAscent() + fm.getDescent());

        // These don't seem to apply here, but the Galaxy theme uses them. Not sure why.
        variables.put(&quot;icon_width&quot;,  32);
        variables.put(&quot;icon_height&quot;, 32);

        if (frame_style_set != null) {
            Node frame = getNode(frame_style_set, &quot;frame&quot;, new String[] {
                &quot;focus&quot;, (active ? &quot;yes&quot; : &quot;no&quot;),
                &quot;state&quot;, (jif.isMaximum() ? &quot;maximized&quot; : &quot;normal&quot;)
            });

            if (frame != null) {
                Node frame_style = getNode(&quot;frame_style&quot;, new String[] {
                    &quot;name&quot;, getStringAttr(frame, &quot;style&quot;)
                });
                if (frame_style != null) {
                    Shape oldClip = g.getClip();
                    boolean roundTopLeft     = getBoolean(&quot;rounded_top_left&quot;,     false);
                    boolean roundTopRight    = getBoolean(&quot;rounded_top_right&quot;,    false);
                    boolean roundBottomLeft  = getBoolean(&quot;rounded_bottom_left&quot;,  false);
                    boolean roundBottomRight = getBoolean(&quot;rounded_bottom_right&quot;, false);

                    if (roundTopLeft || roundTopRight || roundBottomLeft || roundBottomRight) {
                        jif.setOpaque(false);

                        g.setClip(getRoundedClipShape(0, 0, width, height, 12, 12,
                                        (roundTopLeft     ? RoundRectClipShape.TOP_LEFT     : 0) |
                                        (roundTopRight    ? RoundRectClipShape.TOP_RIGHT    : 0) |
                                        (roundBottomLeft  ? RoundRectClipShape.BOTTOM_LEFT  : 0) |
                                        (roundBottomRight ? RoundRectClipShape.BOTTOM_RIGHT : 0)));
                    }

                    Rectangle clipBounds = oldClip.getBounds();
                    g.clipRect(clipBounds.x, clipBounds.y,
                               clipBounds.width, clipBounds.height);

                    int titleHeight = titlePane.getHeight();

                    boolean minimized = jif.isIcon();
                    Insets insets = getBorderInsets(context, null);

                    int leftTitlebarEdge   = getInt(&quot;left_titlebar_edge&quot;);
                    int rightTitlebarEdge  = getInt(&quot;right_titlebar_edge&quot;);
                    int topTitlebarEdge    = getInt(&quot;top_titlebar_edge&quot;);
                    int bottomTitlebarEdge = getInt(&quot;bottom_titlebar_edge&quot;);

                    if (!minimized) {
                        drawPiece(frame_style, g, &quot;entire_background&quot;,
                                  0, 0, width, height, jif);
                    }
                    drawPiece(frame_style, g, &quot;titlebar&quot;,
                              0, 0, width, titleHeight, jif);
                    drawPiece(frame_style, g, &quot;titlebar_middle&quot;,
                              leftTitlebarEdge, topTitlebarEdge,
                              width - leftTitlebarEdge - rightTitlebarEdge,
                              titleHeight - topTitlebarEdge - bottomTitlebarEdge,
                              jif);
                    drawPiece(frame_style, g, &quot;left_titlebar_edge&quot;,
                              0, 0, leftTitlebarEdge, titleHeight, jif);
                    drawPiece(frame_style, g, &quot;right_titlebar_edge&quot;,
                              width - rightTitlebarEdge, 0,
                              rightTitlebarEdge, titleHeight, jif);
                    drawPiece(frame_style, g, &quot;top_titlebar_edge&quot;,
                              0, 0, width, topTitlebarEdge, jif);
                    drawPiece(frame_style, g, &quot;bottom_titlebar_edge&quot;,
                              0, titleHeight - bottomTitlebarEdge,
                              width, bottomTitlebarEdge, jif);
                    drawPiece(frame_style, g, &quot;title&quot;,
                              titleRect.x, titleRect.y, titleRect.width, titleRect.height, jif);
                    if (!minimized) {
                        drawPiece(frame_style, g, &quot;left_edge&quot;,
                                  0, titleHeight, insets.left, height-titleHeight, jif);
                        drawPiece(frame_style, g, &quot;right_edge&quot;,
                                  width-insets.right, titleHeight, insets.right, height-titleHeight, jif);
                        drawPiece(frame_style, g, &quot;bottom_edge&quot;,
                                  0, height - insets.bottom, width, insets.bottom, jif);
                        drawPiece(frame_style, g, &quot;overlay&quot;,
                                  0, 0, width, height, jif);
                    }
                    g.setClip(oldClip);
                }
            }
        }
        g.translate(-x0, -y0);
        g.setFont(oldFont);
    }



    private static class Privileged implements PrivilegedAction&lt;Object&gt; {
        private static int GET_THEME_DIR  = 0;
        private static int GET_USER_THEME = 1;
        private static int GET_IMAGE      = 2;
        private int type;
        private Object arg;

        public Object doPrivileged(int type, Object arg) {
            this.type = type;
            this.arg = arg;
            return AccessController.doPrivileged(this);
        }

        public Object run() {
            if (type == GET_THEME_DIR) {
                String sep = File.separator;
                String[] dirs = new String[] {
                    userHome + sep + &quot;.themes&quot;,
                    System.getProperty(&quot;swing.metacitythemedir&quot;),
                    &quot;/usr/X11R6/share/themes&quot;,
                    &quot;/usr/X11R6/share/gnome/themes&quot;,
                    &quot;/usr/local/share/themes&quot;,
                    &quot;/usr/local/share/gnome/themes&quot;,
                    &quot;/usr/share/themes&quot;,
                    &quot;/usr/gnome/share/themes&quot;,  // Debian/Redhat/Solaris
                    &quot;/opt/gnome2/share/themes&quot;  // SuSE
                };

                URL themeDir = null;
                for (int i = 0; i &lt; dirs.length; i++) {
                    // System property may not be set so skip null directories.
                    if (dirs[i] == null) {
                        continue;
                    }
                    File dir =
                        new File(dirs[i] + sep + arg + sep + &quot;metacity-1&quot;);
                    if (new File(dir, &quot;metacity-theme-1.xml&quot;).canRead()) {
                        try {
                            themeDir = dir.toURI().toURL();
                        } catch (MalformedURLException ex) {
                            themeDir = null;
                        }
                        break;
                    }
                }
                if (themeDir == null) {
                    String filename = &quot;resources/metacity/&quot; + arg +
                        &quot;/metacity-1/metacity-theme-1.xml&quot;;
                    URL url = getClass().getResource(filename);
                    if (url != null) {
                        String str = url.toString();
                        try {
                            themeDir = new URL(str.substring(0, str.lastIndexOf('/'))+&quot;/&quot;);
                        } catch (MalformedURLException ex) {
                            themeDir = null;
                        }
                    }
                }
                return themeDir;
            } else if (type == GET_USER_THEME) {
                try {
                    // Set userHome here because we need the privilege
                    userHome = System.getProperty(&quot;user.home&quot;);

                    String theme = System.getProperty(&quot;swing.metacitythemename&quot;);
                    if (theme != null) {
                        return theme;
                    }
                    // Note: this is a small file (&lt; 1024 bytes) so it's not worth
                    // starting an XML parser or even to use a buffered reader.
                    URL url = new URL(new File(userHome).toURI().toURL(),
                                      &quot;.gconf/apps/metacity/general/%25gconf.xml&quot;);
                    // Pending: verify character encoding spec for gconf
                    Reader reader = new InputStreamReader(url.openStream(), &quot;ISO-8859-1&quot;);
                    char[] buf = new char[1024];
                    StringBuffer strBuf = new StringBuffer();
                    int n;
                    while ((n = reader.read(buf)) &gt;= 0) {
                        strBuf.append(buf, 0, n);
                    }
                    reader.close();
                    String str = strBuf.toString();
                    if (str != null) {
                        String strLowerCase = str.toLowerCase();
                        int i = strLowerCase.indexOf(&quot;&lt;entry name=\&quot;theme\&quot;&quot;);
                        if (i &gt;= 0) {
                            i = strLowerCase.indexOf(&quot;&lt;stringvalue&gt;&quot;, i);
                            if (i &gt; 0) {
                                i += &quot;&lt;stringvalue&gt;&quot;.length();
                                int i2 = str.indexOf(&quot;&lt;&quot;, i);
                                return str.substring(i, i2);
                            }
                        }
                    }
                } catch (MalformedURLException ex) {
                    // OK to just ignore. We'll use a fallback theme.
                } catch (IOException ex) {
                    // OK to just ignore. We'll use a fallback theme.
                }
                return null;
            } else if (type == GET_IMAGE) {
                return new ImageIcon((URL)arg).getImage();
            } else {
                return null;
            }
        }
    }

    private static URL getThemeDir(String themeName) {
        return (URL)new Privileged().doPrivileged(Privileged.GET_THEME_DIR, themeName);
    }

    private static String getUserTheme() {
        return (String)new Privileged().doPrivileged(Privileged.GET_USER_THEME, null);
    }

    protected void tileImage(Graphics g, Image image, int x0, int y0, int w, int h, float[] alphas) {
        Graphics2D g2 = (Graphics2D)g;
        Composite oldComp = g2.getComposite();

        int sw = image.getWidth(null);
        int sh = image.getHeight(null);
        int y = y0;
        while (y &lt; y0 + h) {
            sh = Math.min(sh, y0 + h - y);
            int x = x0;
            while (x &lt; x0 + w) {
                float f = (alphas.length - 1.0F) * x / (x0 + w);
                int i = (int)f;
                f -= (int)f;
                float alpha = (1-f) * alphas[i];
                if (i+1 &lt; alphas.length) {
                    alpha += f * alphas[i+1];
                }
                g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha));
                int swm = Math.min(sw, x0 + w - x);
                g.drawImage(image, x, y, x+swm, y+sh, 0, 0, swm, sh, null);
                x += swm;
            }
            y += sh;
        }
        g2.setComposite(oldComp);
    }

    private HashMap&lt;String, Image&gt; images = new HashMap&lt;String, Image&gt;();

    protected Image getImage(String key, Color c) {
        Image image = images.get(key+&quot;-&quot;+c.getRGB());
        if (image == null) {
            image = imageFilter.colorize(getImage(key), c);
            if (image != null) {
                images.put(key+&quot;-&quot;+c.getRGB(), image);
            }
        }
        return image;
    }

    protected Image getImage(String key) {
        Image image = images.get(key);
        if (image == null) {
            if (themeDir != null) {
                try {
                    URL url = new URL(themeDir, key);
                    image = (Image)new Privileged().doPrivileged(Privileged.GET_IMAGE, url);
                } catch (MalformedURLException ex) {
                    //log(&quot;Bad image url: &quot;+ themeDir + &quot;/&quot; + key);
                }
            }
            if (image != null) {
                images.put(key, image);
            }
        }
        return image;
    }

    private class ColorizeImageFilter extends RGBImageFilter {
        double cr, cg, cb;

        public ColorizeImageFilter() {
            canFilterIndexColorModel = true;
        }

        public void setColor(Color color) {
            cr = color.getRed()   / 255.0;
            cg = color.getGreen() / 255.0;
            cb = color.getBlue()  / 255.0;
        }

        public Image colorize(Image fromImage, Color c) {
            setColor(c);
            ImageProducer producer = new FilteredImageSource(fromImage.getSource(), this);
            return new ImageIcon(context.getComponent().createImage(producer)).getImage();
        }

        public int filterRGB(int x, int y, int rgb) {
            // Assume all rgb values are shades of gray
            double grayLevel = 2 * (rgb &amp; 0xff) / 255.0;
            double r, g, b;

            if (grayLevel &lt;= 1.0) {
                r = cr * grayLevel;
                g = cg * grayLevel;
                b = cb * grayLevel;
            } else {
                grayLevel -= 1.0;
                r = cr + (1.0 - cr) * grayLevel;
                g = cg + (1.0 - cg) * grayLevel;
                b = cb + (1.0 - cb) * grayLevel;
            }

            return ((rgb &amp; 0xff000000) +
                    (((int)(r * 255)) &lt;&lt; 16) +
                    (((int)(g * 255)) &lt;&lt; 8) +
                    (int)(b * 255));
        }
    }

    protected static JComponent findChild(JComponent parent, String name) {
        int n = parent.getComponentCount();
        for (int i = 0; i &lt; n; i++) {
            JComponent c = (JComponent)parent.getComponent(i);
            if (name.equals(c.getName())) {
                return c;
            }
        }
        return null;
    }


    protected class TitlePaneLayout implements LayoutManager {
        public void addLayoutComponent(String name, Component c) {}
        public void removeLayoutComponent(Component c) {}
        public Dimension preferredLayoutSize(Container c)  {
            return minimumLayoutSize(c);
        }

        public Dimension minimumLayoutSize(Container c) {
            JComponent titlePane = (JComponent)c;
            Container titlePaneParent = titlePane.getParent();
            JInternalFrame frame;
            if (titlePaneParent instanceof JInternalFrame) {
                frame = (JInternalFrame)titlePaneParent;
            } else if (titlePaneParent instanceof JInternalFrame.JDesktopIcon) {
                frame = ((JInternalFrame.JDesktopIcon)titlePaneParent).getInternalFrame();
            } else {
                return null;
            }

            Dimension buttonDim = calculateButtonSize(titlePane);
            Insets title_border  = (Insets)getFrameGeometry().get(&quot;title_border&quot;);
            Insets button_border = (Insets)getFrameGeometry().get(&quot;button_border&quot;);

            // Calculate width.
            int width = getInt(&quot;left_titlebar_edge&quot;) + buttonDim.width + getInt(&quot;right_titlebar_edge&quot;);
            if (title_border != null) {
                width += title_border.left + title_border.right;
            }
            if (frame.isClosable()) {
                width += buttonDim.width;
            }
            if (frame.isMaximizable()) {
                width += buttonDim.width;
            }
            if (frame.isIconifiable()) {
                width += buttonDim.width;
            }
            FontMetrics fm = frame.getFontMetrics(titlePane.getFont());
            String frameTitle = frame.getTitle();
            int title_w = frameTitle != null ? SwingUtilities2.stringWidth(
                               frame, fm, frameTitle) : 0;
            int title_length = frameTitle != null ? frameTitle.length() : 0;

            // Leave room for three characters in the title.
            if (title_length &gt; 3) {
                int subtitle_w = SwingUtilities2.stringWidth(
                    frame, fm, frameTitle.substring(0, 3) + &quot;...&quot;);
                width += (title_w &lt; subtitle_w) ? title_w : subtitle_w;
            } else {
                width += title_w;
            }

            // Calculate height.
            int titleHeight = fm.getHeight() + getInt(&quot;title_vertical_pad&quot;);
            if (title_border != null) {
                titleHeight += title_border.top + title_border.bottom;
            }
            int buttonHeight = buttonDim.height;
            if (button_border != null) {
                buttonHeight += button_border.top + button_border.bottom;
            }
            int height = Math.max(buttonHeight, titleHeight);

            return new Dimension(width, height);
        }

        public void layoutContainer(Container c) {
            JComponent titlePane = (JComponent)c;
            Container titlePaneParent = titlePane.getParent();
            JInternalFrame frame;
            if (titlePaneParent instanceof JInternalFrame) {
                frame = (JInternalFrame)titlePaneParent;
            } else if (titlePaneParent instanceof JInternalFrame.JDesktopIcon) {
                frame = ((JInternalFrame.JDesktopIcon)titlePaneParent).getInternalFrame();
            } else {
                return;
            }
            Map gm = getFrameGeometry();

            int w = titlePane.getWidth();
            int h = titlePane.getHeight();

            JComponent menuButton     = findChild(titlePane, &quot;InternalFrameTitlePane.menuButton&quot;);
            JComponent minimizeButton = findChild(titlePane, &quot;InternalFrameTitlePane.iconifyButton&quot;);
            JComponent maximizeButton = findChild(titlePane, &quot;InternalFrameTitlePane.maximizeButton&quot;);
            JComponent closeButton    = findChild(titlePane, &quot;InternalFrameTitlePane.closeButton&quot;);

            Insets button_border = (Insets)gm.get(&quot;button_border&quot;);
            Dimension buttonDim = calculateButtonSize(titlePane);

            int y = (button_border != null) ? button_border.top : 0;
            if (titlePaneParent.getComponentOrientation().isLeftToRight()) {
                int x = getInt(&quot;left_titlebar_edge&quot;);

                menuButton.setBounds(x, y, buttonDim.width, buttonDim.height);

                x = w - buttonDim.width - getInt(&quot;right_titlebar_edge&quot;);
                if (button_border != null) {
                    x -= button_border.right;
                }

                if (frame.isClosable()) {
                    closeButton.setBounds(x, y, buttonDim.width, buttonDim.height);
                    x -= buttonDim.width;
                }

                if (frame.isMaximizable()) {
                    maximizeButton.setBounds(x, y, buttonDim.width, buttonDim.height);
                    x -= buttonDim.width;
                }

                if (frame.isIconifiable()) {
                    minimizeButton.setBounds(x, y, buttonDim.width, buttonDim.height);
                }
            } else {
                int x = w - buttonDim.width - getInt(&quot;right_titlebar_edge&quot;);

                menuButton.setBounds(x, y, buttonDim.width, buttonDim.height);

                x = getInt(&quot;left_titlebar_edge&quot;);
                if (button_border != null) {
                    x += button_border.left;
                }

                if (frame.isClosable()) {
                    closeButton.setBounds(x, y, buttonDim.width, buttonDim.height);
                    x += buttonDim.width;
                }

                if (frame.isMaximizable()) {
                    maximizeButton.setBounds(x, y, buttonDim.width, buttonDim.height);
                    x += buttonDim.width;
                }

                if (frame.isIconifiable()) {
                    minimizeButton.setBounds(x, y, buttonDim.width, buttonDim.height);
                }
            }
        }
    } // end TitlePaneLayout

    protected Map getFrameGeometry() {
        return frameGeometry;
    }

    protected void setFrameGeometry(JComponent titlePane, Map gm) {
        this.frameGeometry = gm;
        if (getInt(&quot;top_height&quot;) == 0 &amp;&amp; titlePane != null) {
            gm.put(&quot;top_height&quot;, Integer.valueOf(titlePane.getHeight()));
        }
    }

    protected int getInt(String key) {
        Integer i = (Integer)frameGeometry.get(key);
        if (i == null) {
            i = variables.get(key);
        }
        return (i != null) ? i.intValue() : 0;
    }

    protected boolean getBoolean(String key, boolean fallback) {
        Boolean b = (Boolean)frameGeometry.get(key);
        return (b != null) ? b.booleanValue() : fallback;
    }


    protected void drawArc(Node node, Graphics g) {
        NamedNodeMap attrs = node.getAttributes();
        Color color = parseColor(getStringAttr(attrs, &quot;color&quot;));
        int x = aee.evaluate(getStringAttr(attrs, &quot;x&quot;));
        int y = aee.evaluate(getStringAttr(attrs, &quot;y&quot;));
        int w = aee.evaluate(getStringAttr(attrs, &quot;width&quot;));
        int h = aee.evaluate(getStringAttr(attrs, &quot;height&quot;));
        int start_angle = aee.evaluate(getStringAttr(attrs, &quot;start_angle&quot;));
        int extent_angle = aee.evaluate(getStringAttr(attrs, &quot;extent_angle&quot;));
        boolean filled = getBooleanAttr(node, &quot;filled&quot;, false);
        if (getInt(&quot;width&quot;) == -1) {
            x -= w;
        }
        if (getInt(&quot;height&quot;) == -1) {
            y -= h;
        }
        g.setColor(color);
        if (filled) {
            g.fillArc(x, y, w, h, start_angle, extent_angle);
        } else {
            g.drawArc(x, y, w, h, start_angle, extent_angle);
        }
    }

    protected void drawLine(Node node, Graphics g) {
        NamedNodeMap attrs = node.getAttributes();
        Color color = parseColor(getStringAttr(attrs, &quot;color&quot;));
        int x1 = aee.evaluate(getStringAttr(attrs, &quot;x1&quot;));
        int y1 = aee.evaluate(getStringAttr(attrs, &quot;y1&quot;));
        int x2 = aee.evaluate(getStringAttr(attrs, &quot;x2&quot;));
        int y2 = aee.evaluate(getStringAttr(attrs, &quot;y2&quot;));
        int lineWidth = aee.evaluate(getStringAttr(attrs, &quot;width&quot;), 1);
        g.setColor(color);
        if (lineWidth != 1) {
            Graphics2D g2d = (Graphics2D)g;
            Stroke stroke = g2d.getStroke();
            g2d.setStroke(new BasicStroke((float)lineWidth));
            g2d.drawLine(x1, y1, x2, y2);
            g2d.setStroke(stroke);
        } else {
            g.drawLine(x1, y1, x2, y2);
        }
    }

    protected void drawRectangle(Node node, Graphics g) {
        NamedNodeMap attrs = node.getAttributes();
        Color color = parseColor(getStringAttr(attrs, &quot;color&quot;));
        boolean filled = getBooleanAttr(node, &quot;filled&quot;, false);
        int x = aee.evaluate(getStringAttr(attrs, &quot;x&quot;));
        int y = aee.evaluate(getStringAttr(attrs, &quot;y&quot;));
        int w = aee.evaluate(getStringAttr(attrs, &quot;width&quot;));
        int h = aee.evaluate(getStringAttr(attrs, &quot;height&quot;));
        g.setColor(color);
        if (getInt(&quot;width&quot;) == -1) {
            x -= w;
        }
        if (getInt(&quot;height&quot;) == -1) {
            y -= h;
        }
        if (filled) {
            g.fillRect(x, y, w, h);
        } else {
            g.drawRect(x, y, w, h);
        }
    }

    protected void drawTile(Node node, Graphics g, JInternalFrame jif) {
        NamedNodeMap attrs = node.getAttributes();
        int x0 = aee.evaluate(getStringAttr(attrs, &quot;x&quot;));
        int y0 = aee.evaluate(getStringAttr(attrs, &quot;y&quot;));
        int w = aee.evaluate(getStringAttr(attrs, &quot;width&quot;));
        int h = aee.evaluate(getStringAttr(attrs, &quot;height&quot;));
        int tw = aee.evaluate(getStringAttr(attrs, &quot;tile_width&quot;));
        int th = aee.evaluate(getStringAttr(attrs, &quot;tile_height&quot;));
        int width  = getInt(&quot;width&quot;);
        int height = getInt(&quot;height&quot;);
        if (width == -1) {
            x0 -= w;
        }
        if (height == -1) {
            y0 -= h;
        }
        Shape oldClip = g.getClip();
        if (g instanceof Graphics2D) {
            ((Graphics2D)g).clip(new Rectangle(x0, y0, w, h));
        }
        variables.put(&quot;width&quot;,  tw);
        variables.put(&quot;height&quot;, th);

        Node draw_ops = getNode(&quot;draw_ops&quot;, new String[] { &quot;name&quot;, getStringAttr(node, &quot;name&quot;) });

        int y = y0;
        while (y &lt; y0 + h) {
            int x = x0;
            while (x &lt; x0 + w) {
                g.translate(x, y);
                draw(draw_ops, g, jif);
                g.translate(-x, -y);
                x += tw;
            }
            y += th;
        }

        variables.put(&quot;width&quot;,  width);
        variables.put(&quot;height&quot;, height);
        g.setClip(oldClip);
    }

    protected void drawTint(Node node, Graphics g) {
        NamedNodeMap attrs = node.getAttributes();
        Color color = parseColor(getStringAttr(attrs, &quot;color&quot;));
        float alpha = Float.parseFloat(getStringAttr(attrs, &quot;alpha&quot;));
        int x = aee.evaluate(getStringAttr(attrs, &quot;x&quot;));
        int y = aee.evaluate(getStringAttr(attrs, &quot;y&quot;));
        int w = aee.evaluate(getStringAttr(attrs, &quot;width&quot;));
        int h = aee.evaluate(getStringAttr(attrs, &quot;height&quot;));
        if (getInt(&quot;width&quot;) == -1) {
            x -= w;
        }
        if (getInt(&quot;height&quot;) == -1) {
            y -= h;
        }
        if (g instanceof Graphics2D) {
            Graphics2D g2 = (Graphics2D)g;
            Composite oldComp = g2.getComposite();
            AlphaComposite ac = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha);
            g2.setComposite(ac);
            g2.setColor(color);
            g2.fillRect(x, y, w, h);
            g2.setComposite(oldComp);
        }
    }

    protected void drawTitle(Node node, Graphics g, JInternalFrame jif) {
        NamedNodeMap attrs = node.getAttributes();
        String colorStr = getStringAttr(attrs, &quot;color&quot;);
        int i = colorStr.indexOf(&quot;gtk:fg[&quot;);
        if (i &gt; 0) {
            colorStr = colorStr.substring(0, i) + &quot;gtk:text[&quot; + colorStr.substring(i+7);
        }
        Color color = parseColor(colorStr);
        int x = aee.evaluate(getStringAttr(attrs, &quot;x&quot;));
        int y = aee.evaluate(getStringAttr(attrs, &quot;y&quot;));

        String title = jif.getTitle();
        if (title != null) {
            FontMetrics fm = SwingUtilities2.getFontMetrics(jif, g);
            title = SwingUtilities2.clipStringIfNecessary(jif, fm, title,
                         calculateTitleArea(jif).width);
            g.setColor(color);
            SwingUtilities2.drawString(jif, g, title, x, y + fm.getAscent());
        }
    }

    protected Dimension calculateButtonSize(JComponent titlePane) {
        int buttonHeight = getInt(&quot;button_height&quot;);
        if (buttonHeight == 0) {
            buttonHeight = titlePane.getHeight();
            if (buttonHeight == 0) {
                buttonHeight = 13;
            } else {
                Insets button_border = (Insets)frameGeometry.get(&quot;button_border&quot;);
                if (button_border != null) {
                    buttonHeight -= (button_border.top + button_border.bottom);
                }
            }
        }
        int buttonWidth = getInt(&quot;button_width&quot;);
        if (buttonWidth == 0) {
            buttonWidth = buttonHeight;
            Float aspect_ratio = (Float)frameGeometry.get(&quot;aspect_ratio&quot;);
            if (aspect_ratio != null) {
                buttonWidth = (int)(buttonHeight / aspect_ratio.floatValue());
            }
        }
        return new Dimension(buttonWidth, buttonHeight);
    }

    protected Rectangle calculateTitleArea(JInternalFrame jif) {
        JComponent titlePane = findChild(jif, &quot;InternalFrame.northPane&quot;);
        Dimension buttonDim = calculateButtonSize(titlePane);
        Insets title_border = (Insets)frameGeometry.get(&quot;title_border&quot;);
        Insets button_border = (Insets)getFrameGeometry().get(&quot;button_border&quot;);

        Rectangle r = new Rectangle();
        r.x = getInt(&quot;left_titlebar_edge&quot;);
        r.y = 0;
        r.height = titlePane.getHeight();
        if (title_border != null) {
            r.x += title_border.left;
            r.y += title_border.top;
            r.height -= (title_border.top + title_border.bottom);
        }

        if (titlePane.getParent().getComponentOrientation().isLeftToRight()) {
            r.x += buttonDim.width;
            if (button_border != null) {
                r.x += button_border.left;
            }
            r.width = titlePane.getWidth() - r.x - getInt(&quot;right_titlebar_edge&quot;);
            if (jif.isClosable()) {
                r.width -= buttonDim.width;
            }
            if (jif.isMaximizable()) {
                r.width -= buttonDim.width;
            }
            if (jif.isIconifiable()) {
                r.width -= buttonDim.width;
            }
        } else {
            if (jif.isClosable()) {
                r.x += buttonDim.width;
            }
            if (jif.isMaximizable()) {
                r.x += buttonDim.width;
            }
            if (jif.isIconifiable()) {
                r.x += buttonDim.width;
            }
            r.width = titlePane.getWidth() - r.x - getInt(&quot;right_titlebar_edge&quot;)
                    - buttonDim.width;
            if (button_border != null) {
                r.x -= button_border.right;
            }
        }
        if (title_border != null) {
            r.width -= title_border.right;
        }
        return r;
    }


    protected int calculateTitleTextWidth(Graphics g, JInternalFrame jif) {
        String title = jif.getTitle();
        if (title != null) {
            Rectangle r = calculateTitleArea(jif);
            return Math.min(SwingUtilities2.stringWidth(jif,
                     SwingUtilities2.getFontMetrics(jif, g), title), r.width);
        }
        return 0;
    }

    protected void setClip(Node node, Graphics g) {
        NamedNodeMap attrs = node.getAttributes();
        int x = aee.evaluate(getStringAttr(attrs, &quot;x&quot;));
        int y = aee.evaluate(getStringAttr(attrs, &quot;y&quot;));
        int w = aee.evaluate(getStringAttr(attrs, &quot;width&quot;));
        int h = aee.evaluate(getStringAttr(attrs, &quot;height&quot;));
        if (getInt(&quot;width&quot;) == -1) {
            x -= w;
        }
        if (getInt(&quot;height&quot;) == -1) {
            y -= h;
        }
        if (g instanceof Graphics2D) {
            ((Graphics2D)g).clip(new Rectangle(x, y, w, h));
        }
    }

    protected void drawGTKArrow(Node node, Graphics g) {
        NamedNodeMap attrs = node.getAttributes();
        String arrow    = getStringAttr(attrs, &quot;arrow&quot;);
        String shadow   = getStringAttr(attrs, &quot;shadow&quot;);
        String stateStr = getStringAttr(attrs, &quot;state&quot;).toUpperCase();
        int x = aee.evaluate(getStringAttr(attrs, &quot;x&quot;));
        int y = aee.evaluate(getStringAttr(attrs, &quot;y&quot;));
        int w = aee.evaluate(getStringAttr(attrs, &quot;width&quot;));
        int h = aee.evaluate(getStringAttr(attrs, &quot;height&quot;));

        int state = -1;
        if (&quot;NORMAL&quot;.equals(stateStr)) {
            state = ENABLED;
        } else if (&quot;SELECTED&quot;.equals(stateStr)) {
            state = SELECTED;
        } else if (&quot;INSENSITIVE&quot;.equals(stateStr)) {
            state = DISABLED;
        } else if (&quot;PRELIGHT&quot;.equals(stateStr)) {
            state = MOUSE_OVER;
        }

        ShadowType shadowType = null;
        if (&quot;in&quot;.equals(shadow)) {
            shadowType = ShadowType.IN;
        } else if (&quot;out&quot;.equals(shadow)) {
            shadowType = ShadowType.OUT;
        } else if (&quot;etched_in&quot;.equals(shadow)) {
            shadowType = ShadowType.ETCHED_IN;
        } else if (&quot;etched_out&quot;.equals(shadow)) {
            shadowType = ShadowType.ETCHED_OUT;
        } else if (&quot;none&quot;.equals(shadow)) {
            shadowType = ShadowType.NONE;
        }

        ArrowType direction = null;
        if (&quot;up&quot;.equals(arrow)) {
            direction = ArrowType.UP;
        } else if (&quot;down&quot;.equals(arrow)) {
            direction = ArrowType.DOWN;
        } else if (&quot;left&quot;.equals(arrow)) {
            direction = ArrowType.LEFT;
        } else if (&quot;right&quot;.equals(arrow)) {
            direction = ArrowType.RIGHT;
        }

        GTKPainter.INSTANCE.paintMetacityElement(context, g, state,
                &quot;metacity-arrow&quot;, x, y, w, h, shadowType, direction);
    }

    protected void drawGTKBox(Node node, Graphics g) {
        NamedNodeMap attrs = node.getAttributes();
        String shadow   = getStringAttr(attrs, &quot;shadow&quot;);
        String stateStr = getStringAttr(attrs, &quot;state&quot;).toUpperCase();
        int x = aee.evaluate(getStringAttr(attrs, &quot;x&quot;));
        int y = aee.evaluate(getStringAttr(attrs, &quot;y&quot;));
        int w = aee.evaluate(getStringAttr(attrs, &quot;width&quot;));
        int h = aee.evaluate(getStringAttr(attrs, &quot;height&quot;));

        int state = -1;
        if (&quot;NORMAL&quot;.equals(stateStr)) {
            state = ENABLED;
        } else if (&quot;SELECTED&quot;.equals(stateStr)) {
            state = SELECTED;
        } else if (&quot;INSENSITIVE&quot;.equals(stateStr)) {
            state = DISABLED;
        } else if (&quot;PRELIGHT&quot;.equals(stateStr)) {
            state = MOUSE_OVER;
        }

        ShadowType shadowType = null;
        if (&quot;in&quot;.equals(shadow)) {
            shadowType = ShadowType.IN;
        } else if (&quot;out&quot;.equals(shadow)) {
            shadowType = ShadowType.OUT;
        } else if (&quot;etched_in&quot;.equals(shadow)) {
            shadowType = ShadowType.ETCHED_IN;
        } else if (&quot;etched_out&quot;.equals(shadow)) {
            shadowType = ShadowType.ETCHED_OUT;
        } else if (&quot;none&quot;.equals(shadow)) {
            shadowType = ShadowType.NONE;
        }
        GTKPainter.INSTANCE.paintMetacityElement(context, g, state,
                &quot;metacity-box&quot;, x, y, w, h, shadowType, null);
    }

    protected void drawGTKVLine(Node node, Graphics g) {
        NamedNodeMap attrs = node.getAttributes();
        String stateStr = getStringAttr(attrs, &quot;state&quot;).toUpperCase();

        int x  = aee.evaluate(getStringAttr(attrs, &quot;x&quot;));
        int y1 = aee.evaluate(getStringAttr(attrs, &quot;y1&quot;));
        int y2 = aee.evaluate(getStringAttr(attrs, &quot;y2&quot;));

        int state = -1;
        if (&quot;NORMAL&quot;.equals(stateStr)) {
            state = ENABLED;
        } else if (&quot;SELECTED&quot;.equals(stateStr)) {
            state = SELECTED;
        } else if (&quot;INSENSITIVE&quot;.equals(stateStr)) {
            state = DISABLED;
        } else if (&quot;PRELIGHT&quot;.equals(stateStr)) {
            state = MOUSE_OVER;
        }

        GTKPainter.INSTANCE.paintMetacityElement(context, g, state,
                &quot;metacity-vline&quot;, x, y1, 1, y2 - y1, null, null);
    }

    protected void drawGradient(Node node, Graphics g) {
        NamedNodeMap attrs = node.getAttributes();
        String type = getStringAttr(attrs, &quot;type&quot;);
        float alpha = getFloatAttr(node, &quot;alpha&quot;, -1F);
        int x = aee.evaluate(getStringAttr(attrs, &quot;x&quot;));
        int y = aee.evaluate(getStringAttr(attrs, &quot;y&quot;));
        int w = aee.evaluate(getStringAttr(attrs, &quot;width&quot;));
        int h = aee.evaluate(getStringAttr(attrs, &quot;height&quot;));
        if (getInt(&quot;width&quot;) == -1) {
            x -= w;
        }
        if (getInt(&quot;height&quot;) == -1) {
            y -= h;
        }

        // Get colors from child nodes
        Node[] colorNodes = getNodesByName(node, &quot;color&quot;);
        Color[] colors = new Color[colorNodes.length];
        for (int i = 0; i &lt; colorNodes.length; i++) {
            colors[i] = parseColor(getStringAttr(colorNodes[i], &quot;value&quot;));
        }

        boolean horizontal = (&quot;diagonal&quot;.equals(type) || &quot;horizontal&quot;.equals(type));
        boolean vertical   = (&quot;diagonal&quot;.equals(type) || &quot;vertical&quot;.equals(type));

        if (g instanceof Graphics2D) {
            Graphics2D g2 = (Graphics2D)g;
            Composite oldComp = g2.getComposite();
            if (alpha &gt;= 0F) {
                g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha));
            }
            int n = colors.length - 1;
            for (int i = 0; i &lt; n; i++) {
                g2.setPaint(new GradientPaint(x + (horizontal ? (i*w/n) : 0),
                                              y + (vertical   ? (i*h/n) : 0),
                                              colors[i],
                                              x + (horizontal ? ((i+1)*w/n) : 0),
                                              y + (vertical   ? ((i+1)*h/n) : 0),
                                              colors[i+1]));
                g2.fillRect(x + (horizontal ? (i*w/n) : 0),
                            y + (vertical   ? (i*h/n) : 0),
                            (horizontal ? (w/n) : w),
                            (vertical   ? (h/n) : h));
            }
            g2.setComposite(oldComp);
        }
    }

    protected void drawImage(Node node, Graphics g) {
        NamedNodeMap attrs = node.getAttributes();
        String filename = getStringAttr(attrs, &quot;filename&quot;);
        String colorizeStr = getStringAttr(attrs, &quot;colorize&quot;);
        Color colorize = (colorizeStr != null) ? parseColor(colorizeStr) : null;
        String alpha = getStringAttr(attrs, &quot;alpha&quot;);
        Image object = (colorize != null) ? getImage(filename, colorize) : getImage(filename);
        variables.put(&quot;object_width&quot;,  object.getWidth(null));
        variables.put(&quot;object_height&quot;, object.getHeight(null));
        String fill_type = getStringAttr(attrs, &quot;fill_type&quot;);
        int x = aee.evaluate(getStringAttr(attrs, &quot;x&quot;));
        int y = aee.evaluate(getStringAttr(attrs, &quot;y&quot;));
        int w = aee.evaluate(getStringAttr(attrs, &quot;width&quot;));
        int h = aee.evaluate(getStringAttr(attrs, &quot;height&quot;));
        if (getInt(&quot;width&quot;) == -1) {
            x -= w;
        }
        if (getInt(&quot;height&quot;) == -1) {
            y -= h;
        }

        if (alpha != null) {
            if (&quot;tile&quot;.equals(fill_type)) {
                StringTokenizer tokenizer = new StringTokenizer(alpha, &quot;:&quot;);
                float[] alphas = new float[tokenizer.countTokens()];
                for (int i = 0; i &lt; alphas.length; i++) {
                    alphas[i] = Float.parseFloat(tokenizer.nextToken());
                }
                tileImage(g, object, x, y, w, h, alphas);
            } else {
                float a = Float.parseFloat(alpha);
                if (g instanceof Graphics2D) {
                    Graphics2D g2 = (Graphics2D)g;
                    Composite oldComp = g2.getComposite();
                    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, a));
                    g2.drawImage(object, x, y, w, h, null);
                    g2.setComposite(oldComp);
                }
            }
        } else {
            g.drawImage(object, x, y, w, h, null);
        }
    }

    protected void drawIcon(Node node, Graphics g, JInternalFrame jif) {
        Icon icon = jif.getFrameIcon();
        if (icon == null) {
            return;
        }

        NamedNodeMap attrs = node.getAttributes();
        String alpha = getStringAttr(attrs, &quot;alpha&quot;);
        int x = aee.evaluate(getStringAttr(attrs, &quot;x&quot;));
        int y = aee.evaluate(getStringAttr(attrs, &quot;y&quot;));
        int w = aee.evaluate(getStringAttr(attrs, &quot;width&quot;));
        int h = aee.evaluate(getStringAttr(attrs, &quot;height&quot;));
        if (getInt(&quot;width&quot;) == -1) {
            x -= w;
        }
        if (getInt(&quot;height&quot;) == -1) {
            y -= h;
        }

        if (alpha != null) {
            float a = Float.parseFloat(alpha);
            if (g instanceof Graphics2D) {
                Graphics2D g2 = (Graphics2D)g;
                Composite oldComp = g2.getComposite();
                g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, a));
                icon.paintIcon(jif, g, x, y);
                g2.setComposite(oldComp);
            }
        } else {
            icon.paintIcon(jif, g, x, y);
        }
    }

    protected void drawInclude(Node node, Graphics g, JInternalFrame jif) {
        int oldWidth  = getInt(&quot;width&quot;);
        int oldHeight = getInt(&quot;height&quot;);

        NamedNodeMap attrs = node.getAttributes();
        int x = aee.evaluate(getStringAttr(attrs, &quot;x&quot;),       0);
        int y = aee.evaluate(getStringAttr(attrs, &quot;y&quot;),       0);
        int w = aee.evaluate(getStringAttr(attrs, &quot;width&quot;),  -1);
        int h = aee.evaluate(getStringAttr(attrs, &quot;height&quot;), -1);

        if (w != -1) {
            variables.put(&quot;width&quot;,  w);
        }
        if (h != -1) {
            variables.put(&quot;height&quot;, h);
        }

        Node draw_ops = getNode(&quot;draw_ops&quot;, new String[] {
            &quot;name&quot;, getStringAttr(node, &quot;name&quot;)
        });
        g.translate(x, y);
        draw(draw_ops, g, jif);
        g.translate(-x, -y);

        if (w != -1) {
            variables.put(&quot;width&quot;,  oldWidth);
        }
        if (h != -1) {
            variables.put(&quot;height&quot;, oldHeight);
        }
    }

    protected void draw(Node draw_ops, Graphics g, JInternalFrame jif) {
        if (draw_ops != null) {
            NodeList nodes = draw_ops.getChildNodes();
            if (nodes != null) {
                Shape oldClip = g.getClip();
                for (int i = 0; i &lt; nodes.getLength(); i++) {
                    Node child = nodes.item(i);
                    if (child.getNodeType() == Node.ELEMENT_NODE) {
                        try {
                            String name = child.getNodeName();
                            if (&quot;include&quot;.equals(name)) {
                                drawInclude(child, g, jif);
                            } else if (&quot;arc&quot;.equals(name)) {
                                drawArc(child, g);
                            } else if (&quot;clip&quot;.equals(name)) {
                                setClip(child, g);
                            } else if (&quot;gradient&quot;.equals(name)) {
                                drawGradient(child, g);
                            } else if (&quot;gtk_arrow&quot;.equals(name)) {
                                drawGTKArrow(child, g);
                            } else if (&quot;gtk_box&quot;.equals(name)) {
                                drawGTKBox(child, g);
                            } else if (&quot;gtk_vline&quot;.equals(name)) {
                                drawGTKVLine(child, g);
                            } else if (&quot;image&quot;.equals(name)) {
                                drawImage(child, g);
                            } else if (&quot;icon&quot;.equals(name)) {
                                drawIcon(child, g, jif);
                            } else if (&quot;line&quot;.equals(name)) {
                                drawLine(child, g);
                            } else if (&quot;rectangle&quot;.equals(name)) {
                                drawRectangle(child, g);
                            } else if (&quot;tint&quot;.equals(name)) {
                                drawTint(child, g);
                            } else if (&quot;tile&quot;.equals(name)) {
                                drawTile(child, g, jif);
                            } else if (&quot;title&quot;.equals(name)) {
                                drawTitle(child, g, jif);
                            } else {
                                System.err.println(&quot;Unknown Metacity drawing op: &quot;+child);
                            }
                        } catch (NumberFormatException ex) {
                            logError(themeName, ex);
                        }
                    }
                }
                g.setClip(oldClip);
            }
        }
    }

    protected void drawPiece(Node frame_style, Graphics g, String position, int x, int y,
                             int width, int height, JInternalFrame jif) {
        Node piece = getNode(frame_style, &quot;piece&quot;, new String[] { &quot;position&quot;, position });
        if (piece != null) {
            Node draw_ops;
            String draw_ops_name = getStringAttr(piece, &quot;draw_ops&quot;);
            if (draw_ops_name != null) {
                draw_ops = getNode(&quot;draw_ops&quot;, new String[] { &quot;name&quot;, draw_ops_name });
            } else {
                draw_ops = getNode(piece, &quot;draw_ops&quot;, null);
            }
            variables.put(&quot;width&quot;,  width);
            variables.put(&quot;height&quot;, height);
            g.translate(x, y);
            draw(draw_ops, g, jif);
            g.translate(-x, -y);
        }
    }


    Insets getBorderInsets(SynthContext context, Insets insets) {
        updateFrameGeometry(context);

        if (insets == null) {
            insets = new Insets(0, 0, 0, 0);
        }
        insets.top    = ((Insets)frameGeometry.get(&quot;title_border&quot;)).top;
        insets.bottom = getInt(&quot;bottom_height&quot;);
        insets.left   = getInt(&quot;left_width&quot;);
        insets.right  = getInt(&quot;right_width&quot;);
        return insets;
    }


    private void updateFrameGeometry(SynthContext context) {
        this.context = context;
        JComponent comp = context.getComponent();
        JComponent titlePane = findChild(comp, &quot;InternalFrame.northPane&quot;);

        JInternalFrame jif = null;
        if (comp instanceof JInternalFrame) {
            jif = (JInternalFrame)comp;
        } else if (comp instanceof JInternalFrame.JDesktopIcon) {
            jif = ((JInternalFrame.JDesktopIcon)comp).getInternalFrame();
        } else {
            assert false : &quot;component is not JInternalFrame or JInternalFrame.JDesktopIcon&quot;;
            return;
        }

        if (frame_style_set == null) {
            Node window = getNode(&quot;window&quot;, new String[]{&quot;type&quot;, &quot;normal&quot;});

            if (window != null) {
                frame_style_set = getNode(&quot;frame_style_set&quot;,
                        new String[] {&quot;name&quot;, getStringAttr(window, &quot;style_set&quot;)});
            }

            if (frame_style_set == null) {
                frame_style_set = getNode(&quot;frame_style_set&quot;, new String[] {&quot;name&quot;, &quot;normal&quot;});
            }
        }

        if (frame_style_set != null) {
            Node frame = getNode(frame_style_set, &quot;frame&quot;, new String[] {
                &quot;focus&quot;, (jif.isSelected() ? &quot;yes&quot; : &quot;no&quot;),
                &quot;state&quot;, (jif.isMaximum() ? &quot;maximized&quot; : &quot;normal&quot;)
            });

            if (frame != null) {
                Node frame_style = getNode(&quot;frame_style&quot;, new String[] {
                    &quot;name&quot;, getStringAttr(frame, &quot;style&quot;)
                });
                if (frame_style != null) {
                    Map gm = frameGeometries.get(getStringAttr(frame_style, &quot;geometry&quot;));

                    setFrameGeometry(titlePane, gm);
                }
            }
        }
    }


    protected static void logError(String themeName, Exception ex) {
        logError(themeName, ex.toString());
    }

    protected static void logError(String themeName, String msg) {
        if (!errorLogged) {
            System.err.println(&quot;Exception in Metacity for theme \&quot;&quot;+themeName+&quot;\&quot;: &quot;+msg);
            errorLogged = true;
        }
    }


    // XML Parsing


    protected static Document getXMLDoc(final URL xmlFile)
                                throws IOException,
                                       ParserConfigurationException,
                                       SAXException {
        if (documentBuilder == null) {
            documentBuilder =
                DocumentBuilderFactory.newInstance().newDocumentBuilder();
        }
        InputStream inputStream =
            AccessController.doPrivileged(new PrivilegedAction&lt;InputStream&gt;() {
                public InputStream run() {
                    try {
                        return new BufferedInputStream(xmlFile.openStream());
                    } catch (IOException ex) {
                        return null;
                    }
                }
            });

        Document doc = null;
        if (inputStream != null) {
            doc = documentBuilder.parse(inputStream);
        }
        return doc;
    }


    protected Node[] getNodesByName(Node parent, String name) {
        NodeList nodes = parent.getChildNodes(); // ElementNode
        int n = nodes.getLength();
        ArrayList&lt;Node&gt; list = new ArrayList&lt;Node&gt;();
        for (int i=0; i &lt; n; i++) {
            Node node = nodes.item(i);
            if (name.equals(node.getNodeName())) {
                list.add(node);
            }
        }
        return list.toArray(new Node[list.size()]);
    }



    protected Node getNode(String tagName, String[] attrs) {
        NodeList nodes = xmlDoc.getElementsByTagName(tagName);
        return (nodes != null) ? getNode(nodes, tagName, attrs) : null;
    }

    protected Node getNode(Node parent, String name, String[] attrs) {
        Node node = null;
        NodeList nodes = parent.getChildNodes();
        if (nodes != null) {
            node = getNode(nodes, name, attrs);
        }
        if (node == null) {
            String inheritFrom = getStringAttr(parent, &quot;parent&quot;);
            if (inheritFrom != null) {
                Node inheritFromNode = getNode(parent.getParentNode(),
                                               parent.getNodeName(),
                                               new String[] { &quot;name&quot;, inheritFrom });
                if (inheritFromNode != null) {
                    node = getNode(inheritFromNode, name, attrs);
                }
            }
        }
        return node;
    }

    protected Node getNode(NodeList nodes, String name, String[] attrs) {
        int n = nodes.getLength();
        for (int i=0; i &lt; n; i++) {
            Node node = nodes.item(i);
            if (name.equals(node.getNodeName())) {
                if (attrs != null) {
                    NamedNodeMap nodeAttrs = node.getAttributes();
                    if (nodeAttrs != null) {
                        boolean matches = true;
                        int nAttrs = attrs.length / 2;
                        for (int a = 0; a &lt; nAttrs; a++) {
                            String aName  = attrs[a * 2];
                            String aValue = attrs[a * 2 + 1];
                            Node attr = nodeAttrs.getNamedItem(aName);
                            if (attr == null ||
                                aValue != null &amp;&amp; !aValue.equals(attr.getNodeValue())) {
                                matches = false;
                                break;
                            }
                        }
                        if (matches) {
                            return node;
                        }
                    }
                } else {
                    return node;
                }
            }
        }
        return null;
    }

    protected String getStringAttr(Node node, String name) {
        String value = null;
        NamedNodeMap attrs = node.getAttributes();
        if (attrs != null) {
            value = getStringAttr(attrs, name);
            if (value == null) {
                String inheritFrom = getStringAttr(attrs, &quot;parent&quot;);
                if (inheritFrom != null) {
                    Node inheritFromNode = getNode(node.getParentNode(),
                                                   node.getNodeName(),
                                                   new String[] { &quot;name&quot;, inheritFrom });
                    if (inheritFromNode != null) {
                        value = getStringAttr(inheritFromNode, name);
                    }
                }
            }
        }
        return value;
    }

    protected String getStringAttr(NamedNodeMap attrs, String name) {
        Node item = attrs.getNamedItem(name);
        return (item != null) ? item.getNodeValue() : null;
    }

    protected boolean getBooleanAttr(Node node, String name, boolean fallback) {
        String str = getStringAttr(node, name);
        if (str != null) {
            return Boolean.valueOf(str).booleanValue();
        }
        return fallback;
    }

    protected int getIntAttr(Node node, String name, int fallback) {
        String str = getStringAttr(node, name);
        int value = fallback;
        if (str != null) {
            try {
                value = Integer.parseInt(str);
            } catch (NumberFormatException ex) {
                logError(themeName, ex);
            }
        }
        return value;
    }

    protected float getFloatAttr(Node node, String name, float fallback) {
        String str = getStringAttr(node, name);
        float value = fallback;
        if (str != null) {
            try {
                value = Float.parseFloat(str);
            } catch (NumberFormatException ex) {
                logError(themeName, ex);
            }
        }
        return value;
    }



    protected Color parseColor(String str) {
        StringTokenizer tokenizer = new StringTokenizer(str, &quot;/&quot;);
        int n = tokenizer.countTokens();
        if (n &gt; 1) {
            String function = tokenizer.nextToken();
            if (&quot;shade&quot;.equals(function)) {
                assert (n == 3);
                Color c = parseColor2(tokenizer.nextToken());
                float alpha = Float.parseFloat(tokenizer.nextToken());
                return GTKColorType.adjustColor(c, 1.0F, alpha, alpha);
            } else if (&quot;blend&quot;.equals(function)) {
                assert (n == 4);
                Color  bg = parseColor2(tokenizer.nextToken());
                Color  fg = parseColor2(tokenizer.nextToken());
                float alpha = Float.parseFloat(tokenizer.nextToken());
                if (alpha &gt; 1.0f) {
                    alpha = 1.0f / alpha;
                }

                return new Color((int)(bg.getRed() + ((fg.getRed() - bg.getRed()) * alpha)),
                                 (int)(bg.getRed() + ((fg.getRed() - bg.getRed()) * alpha)),
                                 (int)(bg.getRed() + ((fg.getRed() - bg.getRed()) * alpha)));
            } else {
                System.err.println(&quot;Unknown Metacity color function=&quot;+str);
                return null;
            }
        } else {
            return parseColor2(str);
        }
    }

    protected Color parseColor2(String str) {
        Color c = null;
        if (str.startsWith(&quot;gtk:&quot;)) {
            int i1 = str.indexOf('[');
            if (i1 &gt; 3) {
                String typeStr = str.substring(4, i1).toLowerCase();
                int i2 = str.indexOf(']');
                if (i2 &gt; i1+1) {
                    String stateStr = str.substring(i1+1, i2).toUpperCase();
                    int state = -1;
                    if (&quot;ACTIVE&quot;.equals(stateStr)) {
                        state = PRESSED;
                    } else if (&quot;INSENSITIVE&quot;.equals(stateStr)) {
                        state = DISABLED;
                    } else if (&quot;NORMAL&quot;.equals(stateStr)) {
                        state = ENABLED;
                    } else if (&quot;PRELIGHT&quot;.equals(stateStr)) {
                        state = MOUSE_OVER;
                    } else if (&quot;SELECTED&quot;.equals(stateStr)) {
                        state = SELECTED;
                    }
                    ColorType type = null;
                    if (&quot;fg&quot;.equals(typeStr)) {
                        type = GTKColorType.FOREGROUND;
                    } else if (&quot;bg&quot;.equals(typeStr)) {
                        type = GTKColorType.BACKGROUND;
                    } else if (&quot;base&quot;.equals(typeStr)) {
                        type = GTKColorType.TEXT_BACKGROUND;
                    } else if (&quot;text&quot;.equals(typeStr)) {
                        type = GTKColorType.TEXT_FOREGROUND;
                    } else if (&quot;dark&quot;.equals(typeStr)) {
                        type = GTKColorType.DARK;
                    } else if (&quot;light&quot;.equals(typeStr)) {
                        type = GTKColorType.LIGHT;
                    }
                    if (state &gt;= 0 &amp;&amp; type != null) {
                        c = ((GTKStyle)context.getStyle()).getGTKColor(context, state, type);
                    }
                }
            }
        }
        if (c == null) {
            c = parseColorString(str);
        }
        return c;
    }

    private static Color parseColorString(String str) {
        if (str.charAt(0) == '#') {
            str = str.substring(1);

            int i = str.length();

            if (i &lt; 3 || i &gt; 12 || (i % 3) != 0) {
                return null;
            }

            i /= 3;

            int r;
            int g;
            int b;

            try {
                r = Integer.parseInt(str.substring(0, i), 16);
                g = Integer.parseInt(str.substring(i, i * 2), 16);
                b = Integer.parseInt(str.substring(i * 2, i * 3), 16);
            } catch (NumberFormatException nfe) {
                return null;
            }

            if (i == 4) {
                return new ColorUIResource(r / 65535.0f, g / 65535.0f, b / 65535.0f);
            } else if (i == 1) {
                return new ColorUIResource(r / 15.0f, g / 15.0f, b / 15.0f);
            } else if (i == 2) {
                return new ColorUIResource(r, g, b);
            } else {
                return new ColorUIResource(r / 4095.0f, g / 4095.0f, b / 4095.0f);
            }
        } else {
            return XColors.lookupColor(str);
        }
    }

    class ArithmeticExpressionEvaluator {
        private PeekableStringTokenizer tokenizer;

        int evaluate(String expr) {
            tokenizer = new PeekableStringTokenizer(expr, &quot; \t+-*/%()&quot;, true);
            return Math.round(expression());
        }

        int evaluate(String expr, int fallback) {
            return (expr != null) ? evaluate(expr) : fallback;
        }

        public float expression() {
            float value = getTermValue();
            boolean done = false;
            while (!done &amp;&amp; tokenizer.hasMoreTokens()) {
                String next = tokenizer.peek();
                if (&quot;+&quot;.equals(next) ||
                    &quot;-&quot;.equals(next) ||
                    &quot;`max`&quot;.equals(next) ||
                    &quot;`min`&quot;.equals(next)) {
                    tokenizer.nextToken();
                    float value2 = getTermValue();
                    if (&quot;+&quot;.equals(next)) {
                        value += value2;
                    } else if (&quot;-&quot;.equals(next)) {
                        value -= value2;
                    } else if (&quot;`max`&quot;.equals(next)) {
                        value = Math.max(value, value2);
                    } else if (&quot;`min`&quot;.equals(next)) {
                        value = Math.min(value, value2);
                    }
                } else {
                    done = true;
                }
            }
            return value;
        }

        public float getTermValue() {
            float value = getFactorValue();
            boolean done = false;
            while (!done &amp;&amp; tokenizer.hasMoreTokens()) {
                String next = tokenizer.peek();
                if (&quot;*&quot;.equals(next) || &quot;/&quot;.equals(next) || &quot;%&quot;.equals(next)) {
                    tokenizer.nextToken();
                    float value2 = getFactorValue();
                    if (&quot;*&quot;.equals(next)) {
                        value *= value2;
                    } else if (&quot;/&quot;.equals(next)) {
                        value /= value2;
                    } else {
                        value %= value2;
                    }
                } else {
                    done = true;
                }
            }
            return value;
        }

        public float getFactorValue() {
            float value;
            if (&quot;(&quot;.equals(tokenizer.peek())) {
                tokenizer.nextToken();
                value = expression();
                tokenizer.nextToken(); // skip right paren
            } else {
                String token = tokenizer.nextToken();
                if (Character.isDigit(token.charAt(0))) {
                    value = Float.parseFloat(token);
                } else {
                    Integer i = variables.get(token);
                    if (i == null) {
                        i = (Integer)getFrameGeometry().get(token);
                    }
                    if (i == null) {
                        logError(themeName, &quot;Variable \&quot;&quot; + token + &quot;\&quot; not defined&quot;);
                        return 0;
                    }
                    value = (i != null) ? i.intValue() : 0F;
                }
            }
            return value;
        }


    }

    static class PeekableStringTokenizer extends StringTokenizer {
        String token = null;

        public PeekableStringTokenizer(String str, String delim,
                                       boolean returnDelims) {
            super(str, delim, returnDelims);
            peek();
        }

        public String peek() {
            if (token == null) {
                token = nextToken();
            }
            return token;
        }

        public boolean hasMoreTokens() {
            return (token != null || super.hasMoreTokens());
        }

        public String nextToken() {
            if (token != null) {
                String t = token;
                token = null;
                if (hasMoreTokens()) {
                    peek();
                }
                return t;
            } else {
                String token = super.nextToken();
                while ((token.equals(&quot; &quot;) || token.equals(&quot;\t&quot;))
                       &amp;&amp; hasMoreTokens()) {
                    token = super.nextToken();
                }
                return token;
            }
        }
    }


    static class RoundRectClipShape extends RectangularShape {
        static final int TOP_LEFT = 1;
        static final int TOP_RIGHT = 2;
        static final int BOTTOM_LEFT = 4;
        static final int BOTTOM_RIGHT = 8;

        int x;
        int y;
        int width;
        int height;
        int arcwidth;
        int archeight;
        int corners;

        public RoundRectClipShape() {
        }

        public RoundRectClipShape(int x, int y, int w, int h,
                                  int arcw, int arch, int corners) {
            setRoundedRect(x, y, w, h, arcw, arch, corners);
        }

        public void setRoundedRect(int x, int y, int w, int h,
                                   int arcw, int arch, int corners) {
            this.corners = corners;
            this.x = x;
            this.y = y;
            this.width = w;
            this.height = h;
            this.arcwidth = arcw;
            this.archeight = arch;
        }

        public double getX() {
            return (double)x;
        }

        public double getY() {
            return (double)y;
        }

        public double getWidth() {
            return (double)width;
        }

        public double getHeight() {
            return (double)height;
        }

        public double getArcWidth() {
            return (double)arcwidth;
        }

        public double getArcHeight() {
            return (double)archeight;
        }

        public boolean isEmpty() {
            return false;  // Not called
        }

        public Rectangle2D getBounds2D() {
            return null;  // Not called
        }

        public int getCornerFlags() {
            return corners;
        }

        public void setFrame(double x, double y, double w, double h) {
            // Not called
        }

        public boolean contains(double x, double y) {
            return false;  // Not called
        }

        private int classify(double coord, double left, double right, double arcsize) {
            return 0;  // Not called
        }

        public boolean intersects(double x, double y, double w, double h) {
            return false;  // Not called
        }

        public boolean contains(double x, double y, double w, double h) {
            return false;  // Not called
        }

        public PathIterator getPathIterator(AffineTransform at) {
            return new RoundishRectIterator(this, at);
        }


        static class RoundishRectIterator implements PathIterator {
            double x, y, w, h, aw, ah;
            AffineTransform affine;
            int index;

            double ctrlpts[][];
            int types[];

            private static final double angle = Math.PI / 4.0;
            private static final double a = 1.0 - Math.cos(angle);
            private static final double b = Math.tan(angle);
            private static final double c = Math.sqrt(1.0 + b * b) - 1 + a;
            private static final double cv = 4.0 / 3.0 * a * b / c;
            private static final double acv = (1.0 - cv) / 2.0;

            // For each array:
            //     4 values for each point {v0, v1, v2, v3}:
            //         point = (x + v0 * w + v1 * arcWidth,
            //                  y + v2 * h + v3 * arcHeight);
            private static final double CtrlPtTemplate[][] = {
                {  0.0,  0.0,  1.0,  0.0 },     /* BOTTOM LEFT corner */
                {  0.0,  0.0,  1.0, -0.5 },     /* BOTTOM LEFT arc start */
                {  0.0,  0.0,  1.0, -acv,       /* BOTTOM LEFT arc curve */
                   0.0,  acv,  1.0,  0.0,
                   0.0,  0.5,  1.0,  0.0 },
                {  1.0,  0.0,  1.0,  0.0 },     /* BOTTOM RIGHT corner */
                {  1.0, -0.5,  1.0,  0.0 },     /* BOTTOM RIGHT arc start */
                {  1.0, -acv,  1.0,  0.0,       /* BOTTOM RIGHT arc curve */
                   1.0,  0.0,  1.0, -acv,
                   1.0,  0.0,  1.0, -0.5 },
                {  1.0,  0.0,  0.0,  0.0 },     /* TOP RIGHT corner */
                {  1.0,  0.0,  0.0,  0.5 },     /* TOP RIGHT arc start */
                {  1.0,  0.0,  0.0,  acv,       /* TOP RIGHT arc curve */
                   1.0, -acv,  0.0,  0.0,
                   1.0, -0.5,  0.0,  0.0 },
                {  0.0,  0.0,  0.0,  0.0 },     /* TOP LEFT corner */
                {  0.0,  0.5,  0.0,  0.0 },     /* TOP LEFT arc start */
                {  0.0,  acv,  0.0,  0.0,       /* TOP LEFT arc curve */
                   0.0,  0.0,  0.0,  acv,
                   0.0,  0.0,  0.0,  0.5 },
                {},                             /* Closing path element */
            };
            private static final int CornerFlags[] = {
                RoundRectClipShape.BOTTOM_LEFT,
                RoundRectClipShape.BOTTOM_RIGHT,
                RoundRectClipShape.TOP_RIGHT,
                RoundRectClipShape.TOP_LEFT,
            };

            RoundishRectIterator(RoundRectClipShape rr, AffineTransform at) {
                this.x = rr.getX();
                this.y = rr.getY();
                this.w = rr.getWidth();
                this.h = rr.getHeight();
                this.aw = Math.min(w, Math.abs(rr.getArcWidth()));
                this.ah = Math.min(h, Math.abs(rr.getArcHeight()));
                this.affine = at;
                if (w &lt; 0 || h &lt; 0) {
                    // Don't draw anything...
                    ctrlpts = new double[0][];
                    types = new int[0];
                } else {
                    int corners = rr.getCornerFlags();
                    int numedges = 5;  // 4xCORNER_POINT, CLOSE
                    for (int i = 1; i &lt; 0x10; i &lt;&lt;= 1) {
                        // Add one for each corner that has a curve
                        if ((corners &amp; i) != 0) numedges++;
                    }
                    ctrlpts = new double[numedges][];
                    types = new int[numedges];
                    int j = 0;
                    for (int i = 0; i &lt; 4; i++) {
                        types[j] = SEG_LINETO;
                        if ((corners &amp; CornerFlags[i]) == 0) {
                            ctrlpts[j++] = CtrlPtTemplate[i*3+0];
                        } else {
                            ctrlpts[j++] = CtrlPtTemplate[i*3+1];
                            types[j] = SEG_CUBICTO;
                            ctrlpts[j++] = CtrlPtTemplate[i*3+2];
                        }
                    }
                    types[j] = SEG_CLOSE;
                    ctrlpts[j++] = CtrlPtTemplate[12];
                    types[0] = SEG_MOVETO;
                }
            }

            public int getWindingRule() {
                return WIND_NON_ZERO;
            }

            public boolean isDone() {
                return index &gt;= ctrlpts.length;
            }

            public void next() {
                index++;
            }

            public int currentSegment(float[] coords) {
                if (isDone()) {
                    throw new NoSuchElementException(&quot;roundrect iterator out of bounds&quot;);
                }
                double ctrls[] = ctrlpts[index];
                int nc = 0;
                for (int i = 0; i &lt; ctrls.length; i += 4) {
                    coords[nc++] = (float) (x + ctrls[i + 0] * w + ctrls[i + 1] * aw);
                    coords[nc++] = (float) (y + ctrls[i + 2] * h + ctrls[i + 3] * ah);
                }
                if (affine != null) {
                    affine.transform(coords, 0, coords, 0, nc / 2);
                }
                return types[index];
            }

            public int currentSegment(double[] coords) {
                if (isDone()) {
                    throw new NoSuchElementException(&quot;roundrect iterator out of bounds&quot;);
                }
                double ctrls[] = ctrlpts[index];
                int nc = 0;
                for (int i = 0; i &lt; ctrls.length; i += 4) {
                    coords[nc++] = x + ctrls[i + 0] * w + ctrls[i + 1] * aw;
                    coords[nc++] = y + ctrls[i + 2] * h + ctrls[i + 3] * ah;
                }
                if (affine != null) {
                    affine.transform(coords, 0, coords, 0, nc / 2);
                }
                return types[index];
            }
        }
    }
}
</pre>
</body>
</html>
