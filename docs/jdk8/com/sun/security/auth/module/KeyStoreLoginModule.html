<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.security.auth.module;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.*;
import java.security.cert.*;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.*;
import javax.security.auth.Destroyable;
import javax.security.auth.DestroyFailedException;
import javax.security.auth.Subject;
import javax.security.auth.x500.*;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.ConfirmationCallback;
import javax.security.auth.callback.NameCallback;
import javax.security.auth.callback.PasswordCallback;
import javax.security.auth.callback.TextOutputCallback;
import javax.security.auth.callback.UnsupportedCallbackException;
import javax.security.auth.login.FailedLoginException;
import javax.security.auth.login.LoginException;
import javax.security.auth.spi.LoginModule;

import sun.security.util.Password;

/**
 * Provides a JAAS login module that prompts for a key store alias and
 * populates the subject with the alias's principal and credentials. Stores
 * an &lt;code&gt;X500Principal&lt;/code&gt; for the subject distinguished name of the
 * first certificate in the alias's credentials in the subject's principals,
 * the alias's certificate path in the subject's public credentials, and a
 * &lt;code&gt;X500PrivateCredential&lt;/code&gt; whose certificate is the first
 * certificate in the alias's certificate path and whose private key is the
 * alias's private key in the subject's private credentials. &lt;p&gt;
 *
 * Recognizes the following options in the configuration file:
 * &lt;dl&gt;
 *
 * &lt;dt&gt; &lt;code&gt;keyStoreURL&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; A URL that specifies the location of the key store.  Defaults to
 *      a URL pointing to the .keystore file in the directory specified by the
 *      &lt;code&gt;user.home&lt;/code&gt; system property.  The input stream from this
 *      URL is passed to the &lt;code&gt;KeyStore.load&lt;/code&gt; method.
 *      &quot;NONE&quot; may be specified if a &lt;code&gt;null&lt;/code&gt; stream must be
 *      passed to the &lt;code&gt;KeyStore.load&lt;/code&gt; method.
 *      &quot;NONE&quot; should be specified if the KeyStore resides
 *      on a hardware token device, for example.&lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;keyStoreType&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; The key store type.  If not specified, defaults to the result of
 *      calling &lt;code&gt;KeyStore.getDefaultType()&lt;/code&gt;.
 *      If the type is &quot;PKCS11&quot;, then keyStoreURL must be &quot;NONE&quot;
 *      and privateKeyPasswordURL must not be specified.&lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;keyStoreProvider&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; The key store provider.  If not specified, uses the standard search
 *      order to find the provider. &lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;keyStoreAlias&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; The alias in the key store to login as.  Required when no callback
 *      handler is provided.  No default value. &lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;keyStorePasswordURL&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; A URL that specifies the location of the key store password.  Required
 *      when no callback handler is provided and
 *      &lt;code&gt;protected&lt;/code&gt; is false.
 *      No default value. &lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;privateKeyPasswordURL&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; A URL that specifies the location of the specific private key password
 *      needed to access the private key for this alias.
 *      The keystore password
 *      is used if this value is needed and not specified. &lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;protected&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; This value should be set to &quot;true&quot; if the KeyStore
 *      has a separate, protected authentication path
 *      (for example, a dedicated PIN-pad attached to a smart card).
 *      Defaults to &quot;false&quot;. If &quot;true&quot; keyStorePasswordURL and
 *      privateKeyPasswordURL must not be specified.&lt;/dd&gt;
 *
 * &lt;/dl&gt;
 */
@jdk.Exported
public class KeyStoreLoginModule implements LoginModule {

    private static final ResourceBundle rb = AccessController.doPrivileged(
            new PrivilegedAction&lt;ResourceBundle&gt;() {
                public ResourceBundle run() {
                    return ResourceBundle.getBundle(
                            &quot;sun.security.util.AuthResources&quot;);
                }
            }
    );

    /* -- Fields -- */

    private static final int UNINITIALIZED = 0;
    private static final int INITIALIZED = 1;
    private static final int AUTHENTICATED = 2;
    private static final int LOGGED_IN = 3;

    private static final int PROTECTED_PATH = 0;
    private static final int TOKEN = 1;
    private static final int NORMAL = 2;

    private static final String NONE = &quot;NONE&quot;;
    private static final String P11KEYSTORE = &quot;PKCS11&quot;;

    private static final TextOutputCallback bannerCallback =
                new TextOutputCallback
                        (TextOutputCallback.INFORMATION,
                        rb.getString(&quot;Please.enter.keystore.information&quot;));
    private final ConfirmationCallback confirmationCallback =
                new ConfirmationCallback
                        (ConfirmationCallback.INFORMATION,
                        ConfirmationCallback.OK_CANCEL_OPTION,
                        ConfirmationCallback.OK);

    private Subject subject;
    private CallbackHandler callbackHandler;
    private Map&lt;String, Object&gt; sharedState;
    private Map&lt;String, ?&gt; options;

    private char[] keyStorePassword;
    private char[] privateKeyPassword;
    private KeyStore keyStore;

    private String keyStoreURL;
    private String keyStoreType;
    private String keyStoreProvider;
    private String keyStoreAlias;
    private String keyStorePasswordURL;
    private String privateKeyPasswordURL;
    private boolean debug;
    private javax.security.auth.x500.X500Principal principal;
    private Certificate[] fromKeyStore;
    private java.security.cert.CertPath certP = null;
    private X500PrivateCredential privateCredential;
    private int status = UNINITIALIZED;
    private boolean nullStream = false;
    private boolean token = false;
    private boolean protectedPath = false;

    /* -- Methods -- */

    /**
     * Initialize this &lt;code&gt;LoginModule&lt;/code&gt;.
     *
     * &lt;p&gt;
     *
     * @param subject the &lt;code&gt;Subject&lt;/code&gt; to be authenticated. &lt;p&gt;
     *
     * @param callbackHandler a &lt;code&gt;CallbackHandler&lt;/code&gt; for communicating
     *                  with the end user (prompting for usernames and
     *                  passwords, for example),
     *                  which may be &lt;code&gt;null&lt;/code&gt;. &lt;p&gt;
     *
     * @param sharedState shared &lt;code&gt;LoginModule&lt;/code&gt; state. &lt;p&gt;
     *
     * @param options options specified in the login
     *                  &lt;code&gt;Configuration&lt;/code&gt; for this particular
     *                  &lt;code&gt;LoginModule&lt;/code&gt;.
     */
    // Unchecked warning from (Map&lt;String, Object&gt;)sharedState is safe
    // since javax.security.auth.login.LoginContext passes a raw HashMap.
    @SuppressWarnings(&quot;unchecked&quot;)
    public void initialize(Subject subject,
                           CallbackHandler callbackHandler,
                           Map&lt;String,?&gt; sharedState,
                           Map&lt;String,?&gt; options)
    {
        this.subject = subject;
        this.callbackHandler = callbackHandler;
        this.sharedState = (Map&lt;String, Object&gt;)sharedState;
        this.options = options;

        processOptions();
        status = INITIALIZED;
    }

    private void processOptions() {
        keyStoreURL = (String) options.get(&quot;keyStoreURL&quot;);
        if (keyStoreURL == null) {
            keyStoreURL =
                &quot;file:&quot; +
                System.getProperty(&quot;user.home&quot;).replace(
                    File.separatorChar, '/') +
                '/' + &quot;.keystore&quot;;
        } else if (NONE.equals(keyStoreURL)) {
            nullStream = true;
        }
        keyStoreType = (String) options.get(&quot;keyStoreType&quot;);
        if (keyStoreType == null) {
            keyStoreType = KeyStore.getDefaultType();
        }
        if (P11KEYSTORE.equalsIgnoreCase(keyStoreType)) {
            token = true;
        }

        keyStoreProvider = (String) options.get(&quot;keyStoreProvider&quot;);

        keyStoreAlias = (String) options.get(&quot;keyStoreAlias&quot;);

        keyStorePasswordURL = (String) options.get(&quot;keyStorePasswordURL&quot;);

        privateKeyPasswordURL = (String) options.get(&quot;privateKeyPasswordURL&quot;);

        protectedPath = &quot;true&quot;.equalsIgnoreCase((String)options.get
                                        (&quot;protected&quot;));

        debug = &quot;true&quot;.equalsIgnoreCase((String) options.get(&quot;debug&quot;));
        if (debug) {
            debugPrint(null);
            debugPrint(&quot;keyStoreURL=&quot; + keyStoreURL);
            debugPrint(&quot;keyStoreType=&quot; + keyStoreType);
            debugPrint(&quot;keyStoreProvider=&quot; + keyStoreProvider);
            debugPrint(&quot;keyStoreAlias=&quot; + keyStoreAlias);
            debugPrint(&quot;keyStorePasswordURL=&quot; + keyStorePasswordURL);
            debugPrint(&quot;privateKeyPasswordURL=&quot; + privateKeyPasswordURL);
            debugPrint(&quot;protectedPath=&quot; + protectedPath);
            debugPrint(null);
        }
    }

    /**
     * Authenticate the user.
     *
     * &lt;p&gt; Get the Keystore alias and relevant passwords.
     * Retrieve the alias's principal and credentials from the Keystore.
     *
     * &lt;p&gt;
     *
     * @exception FailedLoginException if the authentication fails. &lt;p&gt;
     *
     * @return true in all cases (this &lt;code&gt;LoginModule&lt;/code&gt;
     *          should not be ignored).
     */

    public boolean login() throws LoginException {
        switch (status) {
        case UNINITIALIZED:
        default:
            throw new LoginException(&quot;The login module is not initialized&quot;);
        case INITIALIZED:
        case AUTHENTICATED:

            if (token &amp;&amp; !nullStream) {
                throw new LoginException
                        (&quot;if keyStoreType is &quot; + P11KEYSTORE +
                        &quot; then keyStoreURL must be &quot; + NONE);
            }

            if (token &amp;&amp; privateKeyPasswordURL != null) {
                throw new LoginException
                        (&quot;if keyStoreType is &quot; + P11KEYSTORE +
                        &quot; then privateKeyPasswordURL must not be specified&quot;);
            }

            if (protectedPath &amp;&amp;
                (keyStorePasswordURL != null ||
                        privateKeyPasswordURL != null)) {
                throw new LoginException
                        (&quot;if protected is true then keyStorePasswordURL and &quot; +
                        &quot;privateKeyPasswordURL must not be specified&quot;);
            }

            // get relevant alias and password info

            if (protectedPath) {
                getAliasAndPasswords(PROTECTED_PATH);
            } else if (token) {
                getAliasAndPasswords(TOKEN);
            } else {
                getAliasAndPasswords(NORMAL);
            }

            // log into KeyStore to retrieve data,
            // then clear passwords

            try {
                getKeyStoreInfo();
            } finally {
                if (privateKeyPassword != null &amp;&amp;
                    privateKeyPassword != keyStorePassword) {
                    Arrays.fill(privateKeyPassword, '\0');
                    privateKeyPassword = null;
                }
                if (keyStorePassword != null) {
                    Arrays.fill(keyStorePassword, '\0');
                    keyStorePassword = null;
                }
            }
            status = AUTHENTICATED;
            return true;
        case LOGGED_IN:
            return true;
        }
    }

    /** Get the alias and passwords to use for looking up in the KeyStore. */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private void getAliasAndPasswords(int env) throws LoginException {
        if (callbackHandler == null) {

            // No callback handler - check for alias and password options

            switch (env) {
            case PROTECTED_PATH:
                checkAlias();
                break;
            case TOKEN:
                checkAlias();
                checkStorePass();
                break;
            case NORMAL:
                checkAlias();
                checkStorePass();
                checkKeyPass();
                break;
            }

        } else {

            // Callback handler available - prompt for alias and passwords

            NameCallback aliasCallback;
            if (keyStoreAlias == null || keyStoreAlias.length() == 0) {
                aliasCallback = new NameCallback(
                                        rb.getString(&quot;Keystore.alias.&quot;));
            } else {
                aliasCallback =
                    new NameCallback(rb.getString(&quot;Keystore.alias.&quot;),
                                     keyStoreAlias);
            }

            PasswordCallback storePassCallback = null;
            PasswordCallback keyPassCallback = null;

            switch (env) {
            case PROTECTED_PATH:
                break;
            case NORMAL:
                keyPassCallback = new PasswordCallback
                    (rb.getString(&quot;Private.key.password.optional.&quot;), false);
                // fall thru
            case TOKEN:
                storePassCallback = new PasswordCallback
                    (rb.getString(&quot;Keystore.password.&quot;), false);
                break;
            }
            prompt(aliasCallback, storePassCallback, keyPassCallback);
        }

        if (debug) {
            debugPrint(&quot;alias=&quot; + keyStoreAlias);
        }
    }

    private void checkAlias() throws LoginException {
        if (keyStoreAlias == null) {
            throw new LoginException
                (&quot;Need to specify an alias option to use &quot; +
                &quot;KeyStoreLoginModule non-interactively.&quot;);
        }
    }

    private void checkStorePass() throws LoginException {
        if (keyStorePasswordURL == null) {
            throw new LoginException
                (&quot;Need to specify keyStorePasswordURL option to use &quot; +
                &quot;KeyStoreLoginModule non-interactively.&quot;);
        }
        InputStream in = null;
        try {
            in = new URL(keyStorePasswordURL).openStream();
            keyStorePassword = Password.readPassword(in);
        } catch (IOException e) {
            LoginException le = new LoginException
                (&quot;Problem accessing keystore password \&quot;&quot; +
                keyStorePasswordURL + &quot;\&quot;&quot;);
            le.initCause(e);
            throw le;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ioe) {
                    LoginException le = new LoginException(
                        &quot;Problem closing the keystore password stream&quot;);
                    le.initCause(ioe);
                    throw le;
                }
            }
        }
    }

    private void checkKeyPass() throws LoginException {
        if (privateKeyPasswordURL == null) {
            privateKeyPassword = keyStorePassword;
        } else {
            InputStream in = null;
            try {
                in = new URL(privateKeyPasswordURL).openStream();
                privateKeyPassword = Password.readPassword(in);
            } catch (IOException e) {
                LoginException le = new LoginException
                        (&quot;Problem accessing private key password \&quot;&quot; +
                        privateKeyPasswordURL + &quot;\&quot;&quot;);
                le.initCause(e);
                throw le;
            } finally {
                if (in != null) {
                    try {
                        in.close();
                    } catch (IOException ioe) {
                        LoginException le = new LoginException(
                            &quot;Problem closing the private key password stream&quot;);
                        le.initCause(ioe);
                        throw le;
                    }
                }
            }
        }
    }

    private void prompt(NameCallback aliasCallback,
                        PasswordCallback storePassCallback,
                        PasswordCallback keyPassCallback)
                throws LoginException {

        if (storePassCallback == null) {

            // only prompt for alias

            try {
                callbackHandler.handle(
                    new Callback[] {
                        bannerCallback, aliasCallback, confirmationCallback
                    });
            } catch (IOException e) {
                LoginException le = new LoginException
                        (&quot;Problem retrieving keystore alias&quot;);
                le.initCause(e);
                throw le;
            } catch (UnsupportedCallbackException e) {
                throw new LoginException(
                    &quot;Error: &quot; + e.getCallback().toString() +
                    &quot; is not available to retrieve authentication &quot; +
                    &quot; information from the user&quot;);
            }

            int confirmationResult = confirmationCallback.getSelectedIndex();

            if (confirmationResult == ConfirmationCallback.CANCEL) {
                throw new LoginException(&quot;Login cancelled&quot;);
            }

            saveAlias(aliasCallback);

        } else if (keyPassCallback == null) {

            // prompt for alias and key store password

            try {
                callbackHandler.handle(
                    new Callback[] {
                        bannerCallback, aliasCallback,
                        storePassCallback, confirmationCallback
                    });
            } catch (IOException e) {
                LoginException le = new LoginException
                        (&quot;Problem retrieving keystore alias and password&quot;);
                le.initCause(e);
                throw le;
            } catch (UnsupportedCallbackException e) {
                throw new LoginException(
                    &quot;Error: &quot; + e.getCallback().toString() +
                    &quot; is not available to retrieve authentication &quot; +
                    &quot; information from the user&quot;);
            }

            int confirmationResult = confirmationCallback.getSelectedIndex();

            if (confirmationResult == ConfirmationCallback.CANCEL) {
                throw new LoginException(&quot;Login cancelled&quot;);
            }

            saveAlias(aliasCallback);
            saveStorePass(storePassCallback);

        } else {

            // prompt for alias, key store password, and key password

            try {
                callbackHandler.handle(
                    new Callback[] {
                        bannerCallback, aliasCallback,
                        storePassCallback, keyPassCallback,
                        confirmationCallback
                    });
            } catch (IOException e) {
                LoginException le = new LoginException
                        (&quot;Problem retrieving keystore alias and passwords&quot;);
                le.initCause(e);
                throw le;
            } catch (UnsupportedCallbackException e) {
                throw new LoginException(
                    &quot;Error: &quot; + e.getCallback().toString() +
                    &quot; is not available to retrieve authentication &quot; +
                    &quot; information from the user&quot;);
            }

            int confirmationResult = confirmationCallback.getSelectedIndex();

            if (confirmationResult == ConfirmationCallback.CANCEL) {
                throw new LoginException(&quot;Login cancelled&quot;);
            }

            saveAlias(aliasCallback);
            saveStorePass(storePassCallback);
            saveKeyPass(keyPassCallback);
        }
    }

    private void saveAlias(NameCallback cb) {
        keyStoreAlias = cb.getName();
    }

    private void saveStorePass(PasswordCallback c) {
        keyStorePassword = c.getPassword();
        if (keyStorePassword == null) {
            /* Treat a NULL password as an empty password */
            keyStorePassword = new char[0];
        }
        c.clearPassword();
    }

    private void saveKeyPass(PasswordCallback c) {
        privateKeyPassword = c.getPassword();
        if (privateKeyPassword == null || privateKeyPassword.length == 0) {
            /*
             * Use keystore password if no private key password is
             * specified.
             */
            privateKeyPassword = keyStorePassword;
        }
        c.clearPassword();
    }

    /** Get the credentials from the KeyStore. */
    private void getKeyStoreInfo() throws LoginException {

        /* Get KeyStore instance */
        try {
            if (keyStoreProvider == null) {
                keyStore = KeyStore.getInstance(keyStoreType);
            } else {
                keyStore =
                    KeyStore.getInstance(keyStoreType, keyStoreProvider);
            }
        } catch (KeyStoreException e) {
            LoginException le = new LoginException
                (&quot;The specified keystore type was not available&quot;);
            le.initCause(e);
            throw le;
        } catch (NoSuchProviderException e) {
            LoginException le = new LoginException
                (&quot;The specified keystore provider was not available&quot;);
            le.initCause(e);
            throw le;
        }

        /* Load KeyStore contents from file */
        InputStream in = null;
        try {
            if (nullStream) {
                // if using protected auth path, keyStorePassword will be null
                keyStore.load(null, keyStorePassword);
            } else {
                in = new URL(keyStoreURL).openStream();
                keyStore.load(in, keyStorePassword);
            }
        } catch (MalformedURLException e) {
            LoginException le = new LoginException
                                (&quot;Incorrect keyStoreURL option&quot;);
            le.initCause(e);
            throw le;
        } catch (GeneralSecurityException e) {
            LoginException le = new LoginException
                                (&quot;Error initializing keystore&quot;);
            le.initCause(e);
            throw le;
        } catch (IOException e) {
            LoginException le = new LoginException
                                (&quot;Error initializing keystore&quot;);
            le.initCause(e);
            throw le;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ioe) {
                    LoginException le = new LoginException
                                (&quot;Error initializing keystore&quot;);
                    le.initCause(ioe);
                    throw le;
                }
            }
        }

        /* Get certificate chain and create a certificate path */
        try {
            fromKeyStore =
                keyStore.getCertificateChain(keyStoreAlias);
            if (fromKeyStore == null
                || fromKeyStore.length == 0
                || !(fromKeyStore[0] instanceof X509Certificate))
            {
                throw new FailedLoginException(
                    &quot;Unable to find X.509 certificate chain in keystore&quot;);
            } else {
                LinkedList&lt;Certificate&gt; certList = new LinkedList&lt;&gt;();
                for (int i=0; i &lt; fromKeyStore.length; i++) {
                    certList.add(fromKeyStore[i]);
                }
                CertificateFactory certF=
                    CertificateFactory.getInstance(&quot;X.509&quot;);
                certP =
                    certF.generateCertPath(certList);
            }
        } catch (KeyStoreException e) {
            LoginException le = new LoginException(&quot;Error using keystore&quot;);
            le.initCause(e);
            throw le;
        } catch (CertificateException ce) {
            LoginException le = new LoginException
                (&quot;Error: X.509 Certificate type unavailable&quot;);
            le.initCause(ce);
            throw le;
        }

        /* Get principal and keys */
        try {
            X509Certificate certificate = (X509Certificate)fromKeyStore[0];
            principal = new javax.security.auth.x500.X500Principal
                (certificate.getSubjectDN().getName());

            // if token, privateKeyPassword will be null
            Key privateKey = keyStore.getKey(keyStoreAlias, privateKeyPassword);
            if (privateKey == null
                || !(privateKey instanceof PrivateKey))
            {
                throw new FailedLoginException(
                    &quot;Unable to recover key from keystore&quot;);
            }

            privateCredential = new X500PrivateCredential(
                certificate, (PrivateKey) privateKey, keyStoreAlias);
        } catch (KeyStoreException e) {
            LoginException le = new LoginException(&quot;Error using keystore&quot;);
            le.initCause(e);
            throw le;
        } catch (NoSuchAlgorithmException e) {
            LoginException le = new LoginException(&quot;Error using keystore&quot;);
            le.initCause(e);
            throw le;
        } catch (UnrecoverableKeyException e) {
            FailedLoginException fle = new FailedLoginException
                                (&quot;Unable to recover key from keystore&quot;);
            fle.initCause(e);
            throw fle;
        }
        if (debug) {
            debugPrint(&quot;principal=&quot; + principal +
                       &quot;\n certificate=&quot;
                       + privateCredential.getCertificate() +
                       &quot;\n alias =&quot; + privateCredential.getAlias());
        }
    }

    /**
     * Abstract method to commit the authentication process (phase 2).
     *
     * &lt;p&gt; This method is called if the LoginContext's
     * overall authentication succeeded
     * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules
     * succeeded).
     *
     * &lt;p&gt; If this LoginModule's own authentication attempt
     * succeeded (checked by retrieving the private state saved by the
     * &lt;code&gt;login&lt;/code&gt; method), then this method associates a
     * &lt;code&gt;X500Principal&lt;/code&gt; for the subject distinguished name of the
     * first certificate in the alias's credentials in the subject's
     * principals,the alias's certificate path in the subject's public
     * credentials, and a&lt;code&gt;X500PrivateCredential&lt;/code&gt; whose certificate
     * is the first  certificate in the alias's certificate path and whose
     * private key is the alias's private key in the subject's private
     * credentials.  If this LoginModule's own
     * authentication attempted failed, then this method removes
     * any state that was originally saved.
     *
     * &lt;p&gt;
     *
     * @exception LoginException if the commit fails
     *
     * @return true if this LoginModule's own login and commit
     *          attempts succeeded, or false otherwise.
     */

    public boolean commit() throws LoginException {
        switch (status) {
        case UNINITIALIZED:
        default:
            throw new LoginException(&quot;The login module is not initialized&quot;);
        case INITIALIZED:
            logoutInternal();
            throw new LoginException(&quot;Authentication failed&quot;);
        case AUTHENTICATED:
            if (commitInternal()) {
                return true;
            } else {
                logoutInternal();
                throw new LoginException(&quot;Unable to retrieve certificates&quot;);
            }
        case LOGGED_IN:
            return true;
        }
    }

    private boolean commitInternal() throws LoginException {
        /* If the subject is not readonly add to the principal and credentials
         * set; otherwise just return true
         */
        if (subject.isReadOnly()) {
            throw new LoginException (&quot;Subject is set readonly&quot;);
        } else {
            subject.getPrincipals().add(principal);
            subject.getPublicCredentials().add(certP);
            subject.getPrivateCredentials().add(privateCredential);
            status = LOGGED_IN;
            return true;
        }
    }

    /**
     * &lt;p&gt; This method is called if the LoginContext's
     * overall authentication failed.
     * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules
     * did not succeed).
     *
     * &lt;p&gt; If this LoginModule's own authentication attempt
     * succeeded (checked by retrieving the private state saved by the
     * &lt;code&gt;login&lt;/code&gt; and &lt;code&gt;commit&lt;/code&gt; methods),
     * then this method cleans up any state that was originally saved.
     *
     * &lt;p&gt; If the loaded KeyStore's provider extends
     * &lt;code&gt;java.security.AuthProvider&lt;/code&gt;,
     * then the provider's &lt;code&gt;logout&lt;/code&gt; method is invoked.
     *
     * &lt;p&gt;
     *
     * @exception LoginException if the abort fails.
     *
     * @return false if this LoginModule's own login and/or commit attempts
     *          failed, and true otherwise.
     */

    public boolean abort() throws LoginException {
        switch (status) {
        case UNINITIALIZED:
        default:
            return false;
        case INITIALIZED:
            return false;
        case AUTHENTICATED:
            logoutInternal();
            return true;
        case LOGGED_IN:
            logoutInternal();
            return true;
        }
    }
    /**
     * Logout a user.
     *
     * &lt;p&gt; This method removes the Principals, public credentials and the
     * private credentials that were added by the &lt;code&gt;commit&lt;/code&gt; method.
     *
     * &lt;p&gt; If the loaded KeyStore's provider extends
     * &lt;code&gt;java.security.AuthProvider&lt;/code&gt;,
     * then the provider's &lt;code&gt;logout&lt;/code&gt; method is invoked.
     *
     * &lt;p&gt;
     *
     * @exception LoginException if the logout fails.
     *
     * @return true in all cases since this &lt;code&gt;LoginModule&lt;/code&gt;
     *          should not be ignored.
     */

    public boolean logout() throws LoginException {
        if (debug)
            debugPrint(&quot;Entering logout &quot; + status);
        switch (status) {
        case UNINITIALIZED:
            throw new LoginException
                (&quot;The login module is not initialized&quot;);
        case INITIALIZED:
        case AUTHENTICATED:
        default:
           // impossible for LoginModule to be in AUTHENTICATED
           // state
           // assert status != AUTHENTICATED;
            return false;
        case LOGGED_IN:
            logoutInternal();
            return true;
        }
    }

    private void logoutInternal() throws LoginException {
        if (debug) {
            debugPrint(&quot;Entering logoutInternal&quot;);
        }

        // assumption is that KeyStore.load did a login -
        // perform explicit logout if possible
        LoginException logoutException = null;
        Provider provider = keyStore.getProvider();
        if (provider instanceof AuthProvider) {
            AuthProvider ap = (AuthProvider)provider;
            try {
                ap.logout();
                if (debug) {
                    debugPrint(&quot;logged out of KeyStore AuthProvider&quot;);
                }
            } catch (LoginException le) {
                // save but continue below
                logoutException = le;
            }
        }

        if (subject.isReadOnly()) {
            // attempt to destroy the private credential
            // even if the Subject is read-only
            principal = null;
            certP = null;
            status = INITIALIZED;
            // destroy the private credential
            Iterator&lt;Object&gt; it = subject.getPrivateCredentials().iterator();
            while (it.hasNext()) {
                Object obj = it.next();
                if (privateCredential.equals(obj)) {
                    privateCredential = null;
                    try {
                        ((Destroyable)obj).destroy();
                        if (debug)
                            debugPrint(&quot;Destroyed private credential, &quot; +
                                       obj.getClass().getName());
                        break;
                    } catch (DestroyFailedException dfe) {
                        LoginException le = new LoginException
                            (&quot;Unable to destroy private credential, &quot;
                             + obj.getClass().getName());
                        le.initCause(dfe);
                        throw le;
                    }
                }
            }

            // throw an exception because we can not remove
            // the principal and public credential from this
            // read-only Subject
            throw new LoginException
                (&quot;Unable to remove Principal (&quot;
                 + &quot;X500Principal &quot;
                 + &quot;) and public credential (certificatepath) &quot;
                 + &quot;from read-only Subject&quot;);
        }
        if (principal != null) {
            subject.getPrincipals().remove(principal);
            principal = null;
        }
        if (certP != null) {
            subject.getPublicCredentials().remove(certP);
            certP = null;
        }
        if (privateCredential != null) {
            subject.getPrivateCredentials().remove(privateCredential);
            privateCredential = null;
        }

        // throw pending logout exception if there is one
        if (logoutException != null) {
            throw logoutException;
        }
        status = INITIALIZED;
    }

    private void debugPrint(String message) {
        // we should switch to logging API
        if (message == null) {
            System.err.println();
        } else {
            System.err.println(&quot;Debug KeyStoreLoginModule: &quot; + message);
        }
    }
}
</pre>
</body>
</html>
