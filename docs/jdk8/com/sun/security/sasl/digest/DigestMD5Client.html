<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.security.sasl.digest;

import java.security.NoSuchAlgorithmException;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.StringTokenizer;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Arrays;

import java.util.logging.Level;

import javax.security.sasl.*;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.PasswordCallback;
import javax.security.auth.callback.NameCallback;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.UnsupportedCallbackException;

/**
  * An implementation of the DIGEST-MD5
  * (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2831.txt&quot;&gt;RFC 2831&lt;/a&gt;) SASL
  * (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2222.txt&quot;&gt;RFC 2222&lt;/a&gt;) mechanism.
  *
  * The DIGEST-MD5 SASL mechanism specifies two modes of authentication.
  * - Initial Authentication
  * - Subsequent Authentication - optional, (currently unsupported)
  *
  * Required callbacks:
  * - RealmChoiceCallback
  *    shows user list of realms server has offered; handler must choose one
  *    from list
  * - RealmCallback
  *    shows user the only realm server has offered or none; handler must
  *    enter realm to use
  * - NameCallback
  *    handler must enter username to use for authentication
  * - PasswordCallback
  *    handler must enter password for username to use for authentication
  *
  * Environment properties that affect behavior of implementation:
  *
  * javax.security.sasl.qop
  *    quality of protection; list of auth, auth-int, auth-conf; default is &quot;auth&quot;
  * javax.security.sasl.strength
  *    auth-conf strength; list of high, medium, low; default is highest
  *    available on platform [&quot;high,medium,low&quot;].
  *    high means des3 or rc4 (128); medium des or rc4-56; low is rc4-40;
  *    choice of cipher depends on its availablility on platform
  * javax.security.sasl.maxbuf
  *    max receive buffer size; default is 65536
  * javax.security.sasl.sendmaxbuffer
  *    max send buffer size; default is 65536; (min with server max recv size)
  *
  * com.sun.security.sasl.digest.cipher
  *    name a specific cipher to use; setting must be compatible with the
  *    setting of the javax.security.sasl.strength property.
  *
  * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc2222.txt&quot;&gt;RFC 2222&lt;/a&gt;
  * - Simple Authentication and Security Layer (SASL)
  * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc2831.txt&quot;&gt;RFC 2831&lt;/a&gt;
  * - Using Digest Authentication as a SASL Mechanism
  * @see &lt;a href=&quot;http://java.sun.com/products/jce&quot;&gt;Java(TM)
  * Cryptography Extension 1.2.1 (JCE)&lt;/a&gt;
  * @see &lt;a href=&quot;http://java.sun.com/products/jaas&quot;&gt;Java(TM)
  * Authentication and Authorization Service (JAAS)&lt;/a&gt;
  *
  * @author Jonathan Bruce
  * @author Rosanna Lee
  */
final class DigestMD5Client extends DigestMD5Base implements SaslClient {
    private static final String MY_CLASS_NAME = DigestMD5Client.class.getName();

    // Property for specifying cipher explicitly
    private static final String CIPHER_PROPERTY =
        &quot;com.sun.security.sasl.digest.cipher&quot;;

    /* Directives encountered in challenges sent by the server. */
    private static final String[] DIRECTIVE_KEY = {
        &quot;realm&quot;,      // &gt;= 0 times
        &quot;qop&quot;,        // atmost once; default is &quot;auth&quot;
        &quot;algorithm&quot;,  // exactly once
        &quot;nonce&quot;,      // exactly once
        &quot;maxbuf&quot;,     // atmost once; default is 65536
        &quot;charset&quot;,    // atmost once; default is ISO 8859-1
        &quot;cipher&quot;,     // exactly once if qop is &quot;auth-conf&quot;
        &quot;rspauth&quot;,    // exactly once in 2nd challenge
        &quot;stale&quot;,      // atmost once for in subsequent auth (not supported)
    };

    /* Indices into DIRECTIVE_KEY */
    private static final int REALM = 0;
    private static final int QOP = 1;
    private static final int ALGORITHM = 2;
    private static final int NONCE = 3;
    private static final int MAXBUF = 4;
    private static final int CHARSET = 5;
    private static final int CIPHER = 6;
    private static final int RESPONSE_AUTH = 7;
    private static final int STALE = 8;

    private int nonceCount; // number of times nonce has been used/seen

    /* User-supplied/generated information */
    private String specifiedCipher;  // cipher explicitly requested by user
    private byte[] cnonce;        // client generated nonce
    private String username;
    private char[] passwd;
    private byte[] authzidBytes;  // byte repr of authzid

    /**
      * Constructor for DIGEST-MD5 mechanism.
      *
      * @param authzid A non-null String representing the principal
      * for which authorization is being granted..
      * @param digestURI A non-null String representing detailing the
      * combined protocol and host being used for authentication.
      * @param props The possibly null properties to be used by the SASL
      * mechanism to configure the authentication exchange.
      * @param cbh The non-null CallbackHanlder object for callbacks
      * @throws SaslException if no authentication ID or password is supplied
      */
    DigestMD5Client(String authzid, String protocol, String serverName,
        Map&lt;String, ?&gt; props, CallbackHandler cbh) throws SaslException {

        super(props, MY_CLASS_NAME, 2, protocol + &quot;/&quot; + serverName, cbh);

        // authzID can only be encoded in UTF8 - RFC 2222
        if (authzid != null) {
            this.authzid = authzid;
            try {
                authzidBytes = authzid.getBytes(&quot;UTF8&quot;);

            } catch (UnsupportedEncodingException e) {
                throw new SaslException(
                    &quot;DIGEST-MD5: Error encoding authzid value into UTF-8&quot;, e);
            }
        }

        if (props != null) {
            specifiedCipher = (String)props.get(CIPHER_PROPERTY);

            logger.log(Level.FINE, &quot;DIGEST60:Explicitly specified cipher: {0}&quot;,
                specifiedCipher);
        }
   }

    /**
     * DIGEST-MD5 has no initial response
     *
     * @return false
     */
    public boolean hasInitialResponse() {
        return false;
    }

    /**
     * Process the challenge data.
     *
     * The server sends a digest-challenge which the client must reply to
     * in a digest-response. When the authentication is complete, the
     * completed field is set to true.
     *
     * @param challengeData A non-null byte array containing the challenge
     * data from the server.
     * @return A possibly null byte array containing the response to
     * be sent to the server.
     *
     * @throws SaslException If the platform does not have MD5 digest support
     * or if the server sends an invalid challenge.
     */
    public byte[] evaluateChallenge(byte[] challengeData) throws SaslException {

        if (challengeData.length &gt; MAX_CHALLENGE_LENGTH) {
            throw new SaslException(
                &quot;DIGEST-MD5: Invalid digest-challenge length. Got:  &quot; +
                challengeData.length + &quot; Expected &lt; &quot; + MAX_CHALLENGE_LENGTH);
        }

        /* Extract and process digest-challenge */
        byte[][] challengeVal;

        switch (step) {
        case 2:
            /* Process server's first challenge (from Step 1) */
            /* Get realm, qop, maxbuf, charset, algorithm, cipher, nonce
               directives */
            List&lt;byte[]&gt; realmChoices = new ArrayList&lt;byte[]&gt;(3);
            challengeVal = parseDirectives(challengeData, DIRECTIVE_KEY,
                realmChoices, REALM);

            try {
                processChallenge(challengeVal, realmChoices);
                checkQopSupport(challengeVal[QOP], challengeVal[CIPHER]);
                ++step;
                return generateClientResponse(challengeVal[CHARSET]);
            } catch (SaslException e) {
                step = 0;
                clearPassword();
                throw e; // rethrow
            } catch (IOException e) {
                step = 0;
                clearPassword();
                throw new SaslException(&quot;DIGEST-MD5: Error generating &quot; +
                    &quot;digest response-value&quot;, e);
            }

        case 3:
            try {
                /* Process server's step 3 (server response to digest response) */
                /* Get rspauth directive */
                challengeVal = parseDirectives(challengeData, DIRECTIVE_KEY,
                    null, REALM);
                validateResponseValue(challengeVal[RESPONSE_AUTH]);


                /* Initialize SecurityCtx implementation */
                if (integrity &amp;&amp; privacy) {
                    secCtx = new DigestPrivacy(true /* client */);
                } else if (integrity) {
                    secCtx = new DigestIntegrity(true /* client */);
                }

                return null; // Mechanism has completed.
            } finally {
                clearPassword();
                step = 0;  // Set to invalid state
                completed = true;
            }

        default:
            // No other possible state
            throw new SaslException(&quot;DIGEST-MD5: Client at illegal state&quot;);
        }
    }


   /**
    * Record information from the challengeVal array into variables/fields.
    * Check directive values that are multi-valued and ensure that mandatory
    * directives not missing from the digest-challenge.
    *
    * @throws SaslException if a sasl is a the mechanism cannot
    * correcly handle a callbacks or if a violation in the
    * digest challenge format is detected.
    */
    private void processChallenge(byte[][] challengeVal, List&lt;byte[]&gt; realmChoices)
        throws SaslException, UnsupportedEncodingException {

        /* CHARSET: optional atmost once */
        if (challengeVal[CHARSET] != null) {
            if (!&quot;utf-8&quot;.equals(new String(challengeVal[CHARSET], encoding))) {
                throw new SaslException(&quot;DIGEST-MD5: digest-challenge format &quot; +
                    &quot;violation. Unrecognised charset value: &quot; +
                    new String(challengeVal[CHARSET]));
            } else {
                encoding = &quot;UTF8&quot;;
                useUTF8 = true;
            }
        }

        /* ALGORITHM: required exactly once */
        if (challengeVal[ALGORITHM] == null) {
            throw new SaslException(&quot;DIGEST-MD5: Digest-challenge format &quot; +
                &quot;violation: algorithm directive missing&quot;);
        } else if (!&quot;md5-sess&quot;.equals(new String(challengeVal[ALGORITHM], encoding))) {
            throw new SaslException(&quot;DIGEST-MD5: Digest-challenge format &quot; +
                &quot;violation. Invalid value for 'algorithm' directive: &quot; +
                challengeVal[ALGORITHM]);
        }

        /* NONCE: required exactly once */
        if (challengeVal[NONCE] == null) {
            throw new SaslException(&quot;DIGEST-MD5: Digest-challenge format &quot; +
                &quot;violation: nonce directive missing&quot;);
        } else {
            nonce = challengeVal[NONCE];
        }

        try {
            /* REALM: optional, if multiple, stored in realmChoices */
            String[] realmTokens = null;

            if (challengeVal[REALM] != null) {
                if (realmChoices == null || realmChoices.size() &lt;= 1) {
                    // Only one realm specified
                    negotiatedRealm = new String(challengeVal[REALM], encoding);
                } else {
                    realmTokens = new String[realmChoices.size()];
                    for (int i = 0; i &lt; realmTokens.length; i++) {
                        realmTokens[i] =
                            new String(realmChoices.get(i), encoding);
                    }
                }
            }

            NameCallback ncb = authzid == null ?
                new NameCallback(&quot;DIGEST-MD5 authentication ID: &quot;) :
                new NameCallback(&quot;DIGEST-MD5 authentication ID: &quot;, authzid);
            PasswordCallback pcb =
                new PasswordCallback(&quot;DIGEST-MD5 password: &quot;, false);

            if (realmTokens == null) {
                // Server specified &lt;= 1 realm
                // If 0, RFC 2831: the client SHOULD solicit a realm from the user.
                RealmCallback tcb =
                    (negotiatedRealm == null? new RealmCallback(&quot;DIGEST-MD5 realm: &quot;) :
                        new RealmCallback(&quot;DIGEST-MD5 realm: &quot;, negotiatedRealm));

                cbh.handle(new Callback[] {tcb, ncb, pcb});

                /* Acquire realm from RealmCallback */
                negotiatedRealm = tcb.getText();
                if (negotiatedRealm == null) {
                    negotiatedRealm = &quot;&quot;;
                }
            } else {
                RealmChoiceCallback ccb = new RealmChoiceCallback(
                    &quot;DIGEST-MD5 realm: &quot;,
                    realmTokens,
                    0, false);
                cbh.handle(new Callback[] {ccb, ncb, pcb});

                // Acquire realm from RealmChoiceCallback
                int[] selected = ccb.getSelectedIndexes();
                if (selected == null
                        || selected[0] &lt; 0
                        || selected[0] &gt;= realmTokens.length) {
                    throw new SaslException(&quot;DIGEST-MD5: Invalid realm chosen&quot;);
                }
                negotiatedRealm = realmTokens[selected[0]];
            }

            passwd = pcb.getPassword();
            pcb.clearPassword();
            username = ncb.getName();

        } catch (SaslException se) {
            throw se;

        } catch (UnsupportedCallbackException e) {
            throw new SaslException(&quot;DIGEST-MD5: Cannot perform callback to &quot; +
                &quot;acquire realm, authentication ID or password&quot;, e);

        } catch (IOException e) {
            throw new SaslException(
                &quot;DIGEST-MD5: Error acquiring realm, authentication ID or password&quot;, e);
        }

        if (username == null || passwd == null) {
            throw new SaslException(
                &quot;DIGEST-MD5: authentication ID and password must be specified&quot;);
        }

        /* MAXBUF: optional atmost once */
        int srvMaxBufSize =
            (challengeVal[MAXBUF] == null) ? DEFAULT_MAXBUF
            : Integer.parseInt(new String(challengeVal[MAXBUF], encoding));
        sendMaxBufSize =
            (sendMaxBufSize == 0) ? srvMaxBufSize
            : Math.min(sendMaxBufSize, srvMaxBufSize);
    }

    /**
     * Parses the 'qop' directive. If 'auth-conf' is specified by
     * the client and offered as a QOP option by the server, then a check
     * is client-side supported ciphers is performed.
     *
     * @throws IOException
     */
    private void checkQopSupport(byte[] qopInChallenge, byte[] ciphersInChallenge)
        throws IOException {

        /* QOP: optional; if multiple, merged earlier */
        String qopOptions;

        if (qopInChallenge == null) {
            qopOptions = &quot;auth&quot;;
        } else {
            qopOptions = new String(qopInChallenge, encoding);
        }

        // process
        String[] serverQopTokens = new String[3];
        byte[] serverQop = parseQop(qopOptions, serverQopTokens,
            true /* ignore unrecognized tokens */);
        byte serverAllQop = combineMasks(serverQop);

        switch (findPreferredMask(serverAllQop, qop)) {
        case 0:
            throw new SaslException(&quot;DIGEST-MD5: No common protection &quot; +
                &quot;layer between client and server&quot;);

        case NO_PROTECTION:
            negotiatedQop = &quot;auth&quot;;
            // buffer sizes not applicable
            break;

        case INTEGRITY_ONLY_PROTECTION:
            negotiatedQop = &quot;auth-int&quot;;
            integrity = true;
            rawSendSize = sendMaxBufSize - 16;
            break;

        case PRIVACY_PROTECTION:
            negotiatedQop = &quot;auth-conf&quot;;
            privacy = integrity = true;
            rawSendSize = sendMaxBufSize - 26;
            checkStrengthSupport(ciphersInChallenge);
            break;
        }

        if (logger.isLoggable(Level.FINE)) {
            logger.log(Level.FINE, &quot;DIGEST61:Raw send size: {0}&quot;,
                new Integer(rawSendSize));
        }
     }

    /**
     * Processes the 'cipher' digest-challenge directive. This allows the
     * mechanism to check for client-side support against the list of
     * supported ciphers send by the server. If no match is found,
     * the mechanism aborts.
     *
     * @throws SaslException If an error is encountered in processing
     * the cipher digest-challenge directive or if no client-side
     * support is found.
     */
    private void checkStrengthSupport(byte[] ciphersInChallenge)
        throws IOException {

        /* CIPHER: required exactly once if qop=auth-conf */
        if (ciphersInChallenge == null) {
            throw new SaslException(&quot;DIGEST-MD5: server did not specify &quot; +
                &quot;cipher to use for 'auth-conf'&quot;);
        }

        // First determine ciphers that server supports
        String cipherOptions = new String(ciphersInChallenge, encoding);
        StringTokenizer parser = new StringTokenizer(cipherOptions, &quot;, \t\n&quot;);
        int tokenCount = parser.countTokens();
        String token = null;
        byte[] serverCiphers = { UNSET,
                                 UNSET,
                                 UNSET,
                                 UNSET,
                                 UNSET };
        String[] serverCipherStrs = new String[serverCiphers.length];

        // Parse ciphers in challenge; mark each that server supports
        for (int i = 0; i &lt; tokenCount; i++) {
            token = parser.nextToken();
            for (int j = 0; j &lt; CIPHER_TOKENS.length; j++) {
                if (token.equals(CIPHER_TOKENS[j])) {
                    serverCiphers[j] |= CIPHER_MASKS[j];
                    serverCipherStrs[j] = token; // keep for replay to server
                    logger.log(Level.FINE, &quot;DIGEST62:Server supports {0}&quot;, token);
                }
            }
        }

        // Determine which ciphers are available on client
        byte[] clntCiphers = getPlatformCiphers();

        // Take intersection of server and client supported ciphers
        byte inter = 0;
        for (int i = 0; i &lt; serverCiphers.length; i++) {
            serverCiphers[i] &amp;= clntCiphers[i];
            inter |= serverCiphers[i];
        }

        if (inter == UNSET) {
            throw new SaslException(
                &quot;DIGEST-MD5: Client supports none of these cipher suites: &quot; +
                cipherOptions);
        }

        // now have a clear picture of user / client; client / server
        // cipher options. Leverage strength array against what is
        // supported to choose a cipher.
        negotiatedCipher = findCipherAndStrength(serverCiphers, serverCipherStrs);

        if (negotiatedCipher == null) {
            throw new SaslException(&quot;DIGEST-MD5: Unable to negotiate &quot; +
                &quot;a strength level for 'auth-conf'&quot;);
        }
        logger.log(Level.FINE, &quot;DIGEST63:Cipher suite: {0}&quot;, negotiatedCipher);
    }

    /**
     * Steps through the ordered 'strength' array, and compares it with
     * the 'supportedCiphers' array. The cipher returned represents
     * the best possible cipher based on the strength preference and the
     * available ciphers on both the server and client environments.
     *
     * @param tokens The array of cipher tokens sent by server
     * @return The agreed cipher.
     */
    private String findCipherAndStrength(byte[] supportedCiphers,
        String[] tokens) {
        byte s;
        for (int i = 0; i &lt; strength.length; i++) {
            if ((s=strength[i]) != 0) {
                for (int j = 0; j &lt; supportedCiphers.length; j++) {

                    // If user explicitly requested cipher, then it
                    // must be the one we choose

                    if (s == supportedCiphers[j] &amp;&amp;
                        (specifiedCipher == null ||
                            specifiedCipher.equals(tokens[j]))) {
                        switch (s) {
                        case HIGH_STRENGTH:
                            negotiatedStrength = &quot;high&quot;;
                            break;
                        case MEDIUM_STRENGTH:
                            negotiatedStrength = &quot;medium&quot;;
                            break;
                        case LOW_STRENGTH:
                            negotiatedStrength = &quot;low&quot;;
                            break;
                        }

                        return tokens[j];
                    }
                }
            }
        }

        return null;  // none found
    }

    /**
     * Returns digest-response suitable for an initial authentication.
     *
     * The following are qdstr-val (quoted string values) as per RFC 2831,
     * which means that any embedded quotes must be escaped.
     *    realm-value
     *    nonce-value
     *    username-value
     *    cnonce-value
     *    authzid-value
     * @returns &lt;tt&gt;digest-response&lt;/tt&gt; in a byte array
     * @throws SaslException if there is an error generating the
     * response value or the cnonce value.
     */
    private byte[] generateClientResponse(byte[] charset) throws IOException {

        ByteArrayOutputStream digestResp = new ByteArrayOutputStream();

        if (useUTF8) {
            digestResp.write(&quot;charset=&quot;.getBytes(encoding));
            digestResp.write(charset);
            digestResp.write(',');
        }

        digestResp.write((&quot;username=\&quot;&quot; +
            quotedStringValue(username) + &quot;\&quot;,&quot;).getBytes(encoding));

        if (negotiatedRealm.length() &gt; 0) {
            digestResp.write((&quot;realm=\&quot;&quot; +
                quotedStringValue(negotiatedRealm) + &quot;\&quot;,&quot;).getBytes(encoding));
        }

        digestResp.write(&quot;nonce=\&quot;&quot;.getBytes(encoding));
        writeQuotedStringValue(digestResp, nonce);
        digestResp.write('&quot;');
        digestResp.write(',');

        nonceCount = getNonceCount(nonce);
        digestResp.write((&quot;nc=&quot; +
            nonceCountToHex(nonceCount) + &quot;,&quot;).getBytes(encoding));

        cnonce = generateNonce();
        digestResp.write(&quot;cnonce=\&quot;&quot;.getBytes(encoding));
        writeQuotedStringValue(digestResp, cnonce);
        digestResp.write(&quot;\&quot;,&quot;.getBytes(encoding));
        digestResp.write((&quot;digest-uri=\&quot;&quot; + digestUri + &quot;\&quot;,&quot;).getBytes(encoding));

        digestResp.write(&quot;maxbuf=&quot;.getBytes(encoding));
        digestResp.write(String.valueOf(recvMaxBufSize).getBytes(encoding));
        digestResp.write(',');

        try {
            digestResp.write(&quot;response=&quot;.getBytes(encoding));
            digestResp.write(generateResponseValue(&quot;AUTHENTICATE&quot;,
                digestUri, negotiatedQop, username,
                negotiatedRealm, passwd, nonce, cnonce,
                nonceCount, authzidBytes));
            digestResp.write(',');
        } catch (Exception e) {
            throw new SaslException(
                &quot;DIGEST-MD5: Error generating response value&quot;, e);
        }

        digestResp.write((&quot;qop=&quot; + negotiatedQop).getBytes(encoding));

        if (negotiatedCipher != null) {
            digestResp.write((&quot;,cipher=\&quot;&quot; + negotiatedCipher + &quot;\&quot;&quot;).getBytes(encoding));
        }

        if (authzidBytes != null) {
            digestResp.write(&quot;,authzid=\&quot;&quot;.getBytes(encoding));
            writeQuotedStringValue(digestResp, authzidBytes);
            digestResp.write(&quot;\&quot;&quot;.getBytes(encoding));
        }

        if (digestResp.size() &gt; MAX_RESPONSE_LENGTH) {
            throw new SaslException (&quot;DIGEST-MD5: digest-response size too &quot; +
                &quot;large. Length: &quot;  + digestResp.size());
        }
        return digestResp.toByteArray();
     }


    /**
     * From RFC 2831, Section 2.1.3: Step Three
     * [Server] sends a message formatted as follows:
     *     response-auth = &quot;rspauth&quot; &quot;=&quot; response-value
     * where response-value is calculated as above, using the values sent in
     * step two, except that if qop is &quot;auth&quot;, then A2 is
     *
     *  A2 = { &quot;:&quot;, digest-uri-value }
     *
     * And if qop is &quot;auth-int&quot; or &quot;auth-conf&quot; then A2 is
     *
     *  A2 = { &quot;:&quot;, digest-uri-value, &quot;:00000000000000000000000000000000&quot; }
     */
    private void validateResponseValue(byte[] fromServer) throws SaslException {
        if (fromServer == null) {
            throw new SaslException(&quot;DIGEST-MD5: Authenication failed. &quot; +
                &quot;Expecting 'rspauth' authentication success message&quot;);
        }

        try {
            byte[] expected = generateResponseValue(&quot;&quot;,
                digestUri, negotiatedQop, username, negotiatedRealm,
                passwd, nonce, cnonce,  nonceCount, authzidBytes);
            if (!Arrays.equals(expected, fromServer)) {
                /* Server's rspauth value does not match */
                throw new SaslException(
                    &quot;Server's rspauth value does not match what client expects&quot;);
            }
        } catch (NoSuchAlgorithmException e) {
            throw new SaslException(
                &quot;Problem generating response value for verification&quot;, e);
        } catch (IOException e) {
            throw new SaslException(
                &quot;Problem generating response value for verification&quot;, e);
        }
    }

    /**
     * Returns the number of requests (including current request)
     * that the client has sent in response to nonceValue.
     * This is 1 the first time nonceValue is seen.
     *
     * We don't cache nonce values seen, and we don't support subsequent
     * authentication, so the value is always 1.
     */
    private static int getNonceCount(byte[] nonceValue) {
        return 1;
    }

    private void clearPassword() {
        if (passwd != null) {
            for (int i = 0; i &lt; passwd.length; i++) {
                passwd[i] = 0;
            }
            passwd = null;
        }
    }
}
</pre>
</body>
</html>
