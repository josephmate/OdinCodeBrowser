<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.security.sasl.digest;

import java.security.NoSuchAlgorithmException;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.StringTokenizer;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Arrays;

import java.util.logging.Level;

import javax.security.sasl.*;
import javax.security.auth.callback.*;

/**
  * An implementation of the DIGEST-MD5 server SASL mechanism.
  * (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2831.txt&quot;&gt;RFC 2831&lt;/a&gt;)
  * &lt;p&gt;
  * The DIGEST-MD5 SASL mechanism specifies two modes of authentication.
  * &lt;ul&gt;&lt;li&gt;Initial Authentication
  * &lt;li&gt;Subsequent Authentication - optional, (currently not supported)
  * &lt;/ul&gt;
  *
  * Required callbacks:
  * - RealmCallback
  *      used as key by handler to fetch password
  * - NameCallback
  *      used as key by handler to fetch password
  * - PasswordCallback
  *      handler must enter password for username/realm supplied
  * - AuthorizeCallback
  *      handler must verify that authid/authzids are allowed and set
  *      authorized ID to be the canonicalized authzid (if applicable).
  *
  * Environment properties that affect the implementation:
  * javax.security.sasl.qop:
  *    specifies list of qops; default is &quot;auth&quot;; typically, caller should set
  *    this to &quot;auth, auth-int, auth-conf&quot;.
  * javax.security.sasl.strength
  *    specifies low/medium/high strength of encryption; default is all available
  *    ciphers [high,medium,low]; high means des3 or rc4 (128); medium des or
  *    rc4-56; low is rc4-40.
  * javax.security.sasl.maxbuf
  *    specifies max receive buf size; default is 65536
  * javax.security.sasl.sendmaxbuffer
  *    specifies max send buf size; default is 65536 (min of this and client's max
  *    recv size)
  *
  * com.sun.security.sasl.digest.utf8:
  *    &quot;true&quot; means to use UTF-8 charset; &quot;false&quot; to use ISO-8859-1 encoding;
  *    default is &quot;true&quot;.
  * com.sun.security.sasl.digest.realm:
  *    space-separated list of realms; default is server name (fqdn parameter)
  *
  * @author Rosanna Lee
  */

final class DigestMD5Server extends DigestMD5Base implements SaslServer {
    private static final String MY_CLASS_NAME = DigestMD5Server.class.getName();

    private static final String UTF8_DIRECTIVE = &quot;charset=utf-8,&quot;;
    private static final String ALGORITHM_DIRECTIVE = &quot;algorithm=md5-sess&quot;;

    /*
     * Always expect nonce count value to be 1 because we support only
     * initial authentication.
     */
    private static final int NONCE_COUNT_VALUE = 1;

    /* &quot;true&quot; means use UTF8; &quot;false&quot; ISO 8859-1; default is &quot;true&quot; */
    private static final String UTF8_PROPERTY =
        &quot;com.sun.security.sasl.digest.utf8&quot;;

    /* List of space-separated realms used for authentication */
    private static final String REALM_PROPERTY =
        &quot;com.sun.security.sasl.digest.realm&quot;;

    /* Directives encountered in responses sent by the client. */
    private static final String[] DIRECTIVE_KEY = {
        &quot;username&quot;,    // exactly once
        &quot;realm&quot;,       // exactly once if sent by server
        &quot;nonce&quot;,       // exactly once
        &quot;cnonce&quot;,      // exactly once
        &quot;nonce-count&quot;, // atmost once; default is 00000001
        &quot;qop&quot;,         // atmost once; default is &quot;auth&quot;
        &quot;digest-uri&quot;,  // atmost once; (default?)
        &quot;response&quot;,    // exactly once
        &quot;maxbuf&quot;,      // atmost once; default is 65536
        &quot;charset&quot;,     // atmost once; default is ISO-8859-1
        &quot;cipher&quot;,      // exactly once if qop is &quot;auth-conf&quot;
        &quot;authzid&quot;,     // atmost once; default is none
        &quot;auth-param&quot;,  // &gt;= 0 times (ignored)
    };

    /* Indices into DIRECTIVE_KEY */
    private static final int USERNAME = 0;
    private static final int REALM = 1;
    private static final int NONCE = 2;
    private static final int CNONCE = 3;
    private static final int NONCE_COUNT = 4;
    private static final int QOP = 5;
    private static final int DIGEST_URI = 6;
    private static final int RESPONSE = 7;
    private static final int MAXBUF = 8;
    private static final int CHARSET = 9;
    private static final int CIPHER = 10;
    private static final int AUTHZID = 11;
    private static final int AUTH_PARAM = 12;

    /* Server-generated/supplied information */
    private String specifiedQops;
    private byte[] myCiphers;
    private List&lt;String&gt; serverRealms;

    DigestMD5Server(String protocol, String serverName, Map&lt;String, ?&gt; props,
            CallbackHandler cbh) throws SaslException {
        super(props, MY_CLASS_NAME, 1,
                protocol + &quot;/&quot; + (serverName==null?&quot;*&quot;:serverName),
                cbh);

        serverRealms = new ArrayList&lt;String&gt;();

        useUTF8 = true;  // default

        if (props != null) {
            specifiedQops = (String) props.get(Sasl.QOP);
            if (&quot;false&quot;.equals((String) props.get(UTF8_PROPERTY))) {
                useUTF8 = false;
                logger.log(Level.FINE, &quot;DIGEST80:Server supports ISO-Latin-1&quot;);
            }

            String realms = (String) props.get(REALM_PROPERTY);
            if (realms != null) {
                StringTokenizer parser = new StringTokenizer(realms, &quot;, \t\n&quot;);
                int tokenCount = parser.countTokens();
                String token = null;
                for (int i = 0; i &lt; tokenCount; i++) {
                    token = parser.nextToken();
                    logger.log(Level.FINE, &quot;DIGEST81:Server supports realm {0}&quot;,
                        token);
                    serverRealms.add(token);
                }
            }
        }

        encoding = (useUTF8 ? &quot;UTF8&quot; : &quot;8859_1&quot;);

        // By default, use server name as realm
        if (serverRealms.isEmpty()) {
            if (serverName == null) {
                throw new SaslException(
                        &quot;A realm must be provided in props or serverName&quot;);
            } else {
                serverRealms.add(serverName);
            }
        }
    }

    public  byte[] evaluateResponse(byte[] response) throws SaslException {
        if (response.length &gt; MAX_RESPONSE_LENGTH) {
            throw new SaslException(
                &quot;DIGEST-MD5: Invalid digest response length. Got:  &quot; +
                response.length + &quot; Expected &lt; &quot; + MAX_RESPONSE_LENGTH);
        }

        byte[] challenge;
        switch (step) {
        case 1:
            if (response.length != 0) {
                throw new SaslException(
                    &quot;DIGEST-MD5 must not have an initial response&quot;);
            }

            /* Generate first challenge */
            String supportedCiphers = null;
            if ((allQop&amp;PRIVACY_PROTECTION) != 0) {
                myCiphers = getPlatformCiphers();
                StringBuffer buf = new StringBuffer();

                // myCipher[i] is a byte that indicates whether CIPHER_TOKENS[i]
                // is supported
                for (int i = 0; i &lt; CIPHER_TOKENS.length; i++) {
                    if (myCiphers[i] != 0) {
                        if (buf.length() &gt; 0) {
                            buf.append(',');
                        }
                        buf.append(CIPHER_TOKENS[i]);
                    }
                }
                supportedCiphers = buf.toString();
            }

            try {
                challenge = generateChallenge(serverRealms, specifiedQops,
                    supportedCiphers);

                step = 3;
                return challenge;
            } catch (UnsupportedEncodingException e) {
                throw new SaslException(
                    &quot;DIGEST-MD5: Error encoding challenge&quot;, e);
            } catch (IOException e) {
                throw new SaslException(
                    &quot;DIGEST-MD5: Error generating challenge&quot;, e);
            }

            // Step 2 is performed by client

        case 3:
            /* Validates client's response and generate challenge:
             *    response-auth = &quot;rspauth&quot; &quot;=&quot; response-value
             */
            try {
                byte[][] responseVal = parseDirectives(response, DIRECTIVE_KEY,
                    null, REALM);
                challenge = validateClientResponse(responseVal);
            } catch (SaslException e) {
                throw e;
            } catch (UnsupportedEncodingException e) {
                throw new SaslException(
                    &quot;DIGEST-MD5: Error validating client response&quot;, e);
            } finally {
                step = 0;  // Set to invalid state
            }

            completed = true;

            /* Initialize SecurityCtx implementation */
            if (integrity &amp;&amp; privacy) {
                secCtx = new DigestPrivacy(false /* not client */);
            } else if (integrity) {
                secCtx = new DigestIntegrity(false /* not client */);
            }

            return challenge;

        default:
            // No other possible state
            throw new SaslException(&quot;DIGEST-MD5: Server at illegal state&quot;);
        }
    }

    /**
     * Generates challenge to be sent to client.
     *  digest-challenge  =
     *    1#( realm | nonce | qop-options | stale | maxbuf | charset
     *               algorithm | cipher-opts | auth-param )
     *
     *        realm             = &quot;realm&quot; &quot;=&quot; &lt;&quot;&gt; realm-value &lt;&quot;&gt;
     *        realm-value       = qdstr-val
     *        nonce             = &quot;nonce&quot; &quot;=&quot; &lt;&quot;&gt; nonce-value &lt;&quot;&gt;
     *        nonce-value       = qdstr-val
     *        qop-options       = &quot;qop&quot; &quot;=&quot; &lt;&quot;&gt; qop-list &lt;&quot;&gt;
     *        qop-list          = 1#qop-value
     *        qop-value         = &quot;auth&quot; | &quot;auth-int&quot; | &quot;auth-conf&quot; |
     *                             token
     *        stale             = &quot;stale&quot; &quot;=&quot; &quot;true&quot;
     *        maxbuf            = &quot;maxbuf&quot; &quot;=&quot; maxbuf-value
     *        maxbuf-value      = 1*DIGIT
     *        charset           = &quot;charset&quot; &quot;=&quot; &quot;utf-8&quot;
     *        algorithm         = &quot;algorithm&quot; &quot;=&quot; &quot;md5-sess&quot;
     *        cipher-opts       = &quot;cipher&quot; &quot;=&quot; &lt;&quot;&gt; 1#cipher-value &lt;&quot;&gt;
     *        cipher-value      = &quot;3des&quot; | &quot;des&quot; | &quot;rc4-40&quot; | &quot;rc4&quot; |
     *                            &quot;rc4-56&quot; | token
     *        auth-param        = token &quot;=&quot; ( token | quoted-string )
     */
    private byte[] generateChallenge(List&lt;String&gt; realms, String qopStr,
        String cipherStr) throws UnsupportedEncodingException, IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();

        // Realms (&gt;= 0)
        for (int i = 0; realms != null &amp;&amp; i &lt; realms.size(); i++) {
            out.write(&quot;realm=\&quot;&quot;.getBytes(encoding));
            writeQuotedStringValue(out, realms.get(i).getBytes(encoding));
            out.write('&quot;');
            out.write(',');
        }

        // Nonce - required (1)
        out.write((&quot;nonce=\&quot;&quot;).getBytes(encoding));
        nonce = generateNonce();
        writeQuotedStringValue(out, nonce);
        out.write('&quot;');
        out.write(',');

        // QOP - optional (1) [default: auth]
        // qop=&quot;auth,auth-conf,auth-int&quot;
        if (qopStr != null) {
            out.write((&quot;qop=\&quot;&quot;).getBytes(encoding));
            // Check for quotes in case of non-standard qop options
            writeQuotedStringValue(out, qopStr.getBytes(encoding));
            out.write('&quot;');
            out.write(',');
        }

        // maxbuf - optional (1) [default: 65536]
        if (recvMaxBufSize != DEFAULT_MAXBUF) {
            out.write((&quot;maxbuf=\&quot;&quot; + recvMaxBufSize + &quot;\&quot;,&quot;).getBytes(encoding));
        }

        // charset - optional (1) [default: ISO 8859_1]
        if (useUTF8) {
            out.write(UTF8_DIRECTIVE.getBytes(encoding));
        }

        if (cipherStr != null) {
            out.write(&quot;cipher=\&quot;&quot;.getBytes(encoding));
            // Check for quotes in case of custom ciphers
            writeQuotedStringValue(out, cipherStr.getBytes(encoding));
            out.write('&quot;');
            out.write(',');
        }

        // algorithm - required (1)
        out.write(ALGORITHM_DIRECTIVE.getBytes(encoding));

        return out.toByteArray();
    }

    /**
     * Validates client's response.
     *   digest-response  = 1#( username | realm | nonce | cnonce |
     *                          nonce-count | qop | digest-uri | response |
     *                          maxbuf | charset | cipher | authzid |
     *                          auth-param )
     *
     *       username         = &quot;username&quot; &quot;=&quot; &lt;&quot;&gt; username-value &lt;&quot;&gt;
     *       username-value   = qdstr-val
     *       cnonce           = &quot;cnonce&quot; &quot;=&quot; &lt;&quot;&gt; cnonce-value &lt;&quot;&gt;
     *       cnonce-value     = qdstr-val
     *       nonce-count      = &quot;nc&quot; &quot;=&quot; nc-value
     *       nc-value         = 8LHEX
     *       qop              = &quot;qop&quot; &quot;=&quot; qop-value
     *       digest-uri       = &quot;digest-uri&quot; &quot;=&quot; &lt;&quot;&gt; digest-uri-value &lt;&quot;&gt;
     *       digest-uri-value  = serv-type &quot;/&quot; host [ &quot;/&quot; serv-name ]
     *       serv-type        = 1*ALPHA
     *       host             = 1*( ALPHA | DIGIT | &quot;-&quot; | &quot;.&quot; )
     *       serv-name        = host
     *       response         = &quot;response&quot; &quot;=&quot; response-value
     *       response-value   = 32LHEX
     *       LHEX             = &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; |
     *                          &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; |
     *                          &quot;8&quot; | &quot;9&quot; | &quot;a&quot; | &quot;b&quot; |
     *                          &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;
     *       cipher           = &quot;cipher&quot; &quot;=&quot; cipher-value
     *       authzid          = &quot;authzid&quot; &quot;=&quot; &lt;&quot;&gt; authzid-value &lt;&quot;&gt;
     *       authzid-value    = qdstr-val
     * sets:
     *   negotiatedQop
     *   negotiatedCipher
     *   negotiatedRealm
     *   negotiatedStrength
     *   digestUri (checked and set to clients to account for case diffs)
     *   sendMaxBufSize
     *   authzid (gotten from callback)
     * @return response-value ('rspauth') for client to validate
     */
    private byte[] validateClientResponse(byte[][] responseVal)
        throws SaslException, UnsupportedEncodingException {

        /* CHARSET: optional atmost once */
        if (responseVal[CHARSET] != null) {
            // The client should send this directive only if the server has
            // indicated it supports UTF-8.
            if (!useUTF8 ||
                !&quot;utf-8&quot;.equals(new String(responseVal[CHARSET], encoding))) {
                throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
                    &quot;violation. Incompatible charset value: &quot; +
                    new String(responseVal[CHARSET]));
            }
        }

        // maxbuf: atmost once
        int clntMaxBufSize =
            (responseVal[MAXBUF] == null) ? DEFAULT_MAXBUF
            : Integer.parseInt(new String(responseVal[MAXBUF], encoding));

        // Max send buf size is min of client's max recv buf size and
        // server's max send buf size
        sendMaxBufSize = ((sendMaxBufSize == 0) ? clntMaxBufSize :
            Math.min(sendMaxBufSize, clntMaxBufSize));

        /* username: exactly once */
        String username;
        if (responseVal[USERNAME] != null) {
            username = new String(responseVal[USERNAME], encoding);
            logger.log(Level.FINE, &quot;DIGEST82:Username: {0}&quot;, username);
        } else {
            throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
                &quot;violation. Missing username.&quot;);
        }

        /* realm: exactly once if sent by server */
        negotiatedRealm = ((responseVal[REALM] != null) ?
            new String(responseVal[REALM], encoding) : &quot;&quot;);
        logger.log(Level.FINE, &quot;DIGEST83:Client negotiated realm: {0}&quot;,
            negotiatedRealm);

        if (!serverRealms.contains(negotiatedRealm)) {
            // Server had sent at least one realm
            // Check that response is one of these
            throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
                &quot;violation. Nonexistent realm: &quot; + negotiatedRealm);
        }
        // Else, client specified realm was one of server's or server had none

        /* nonce: exactly once */
        if (responseVal[NONCE] == null) {
            throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
                &quot;violation. Missing nonce.&quot;);
        }
        byte[] nonceFromClient = responseVal[NONCE];
        if (!Arrays.equals(nonceFromClient, nonce)) {
            throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
                &quot;violation. Mismatched nonce.&quot;);
        }

        /* cnonce: exactly once */
        if (responseVal[CNONCE] == null) {
            throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
                &quot;violation. Missing cnonce.&quot;);
        }
        byte[] cnonce = responseVal[CNONCE];

        /* nonce-count: atmost once */
        if (responseVal[NONCE_COUNT] != null &amp;&amp;
            NONCE_COUNT_VALUE != Integer.parseInt(
                new String(responseVal[NONCE_COUNT], encoding), 16)) {
            throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
                &quot;violation. Nonce count does not match: &quot; +
                new String(responseVal[NONCE_COUNT]));
        }

        /* qop: atmost once; default is &quot;auth&quot; */
        negotiatedQop = ((responseVal[QOP] != null) ?
            new String(responseVal[QOP], encoding) : &quot;auth&quot;);

        logger.log(Level.FINE, &quot;DIGEST84:Client negotiated qop: {0}&quot;,
            negotiatedQop);

        // Check that QOP is one sent by server
        byte cQop;
        switch (negotiatedQop) {
            case &quot;auth&quot;:
                cQop = NO_PROTECTION;
                break;
            case &quot;auth-int&quot;:
                cQop = INTEGRITY_ONLY_PROTECTION;
                integrity = true;
                rawSendSize = sendMaxBufSize - 16;
                break;
            case &quot;auth-conf&quot;:
                cQop = PRIVACY_PROTECTION;
                integrity = privacy = true;
                rawSendSize = sendMaxBufSize - 26;
                break;
            default:
                throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
                    &quot;violation. Invalid QOP: &quot; + negotiatedQop);
        }
        if ((cQop&amp;allQop) == 0) {
            throw new SaslException(&quot;DIGEST-MD5: server does not support &quot; +
                &quot; qop: &quot; + negotiatedQop);
        }

        if (privacy) {
            negotiatedCipher = ((responseVal[CIPHER] != null) ?
                new String(responseVal[CIPHER], encoding) : null);
            if (negotiatedCipher == null) {
                throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
                    &quot;violation. No cipher specified.&quot;);
            }

            int foundCipher = -1;
            logger.log(Level.FINE, &quot;DIGEST85:Client negotiated cipher: {0}&quot;,
                negotiatedCipher);

            // Check that cipher is one that we offered
            for (int j = 0; j &lt; CIPHER_TOKENS.length; j++) {
                if (negotiatedCipher.equals(CIPHER_TOKENS[j]) &amp;&amp;
                    myCiphers[j] != 0) {
                    foundCipher = j;
                    break;
                }
            }
            if (foundCipher == -1) {
                throw new SaslException(&quot;DIGEST-MD5: server does not &quot; +
                    &quot;support cipher: &quot; + negotiatedCipher);
            }
            // Set negotiatedStrength
            if ((CIPHER_MASKS[foundCipher]&amp;HIGH_STRENGTH) != 0) {
                negotiatedStrength = &quot;high&quot;;
            } else if ((CIPHER_MASKS[foundCipher]&amp;MEDIUM_STRENGTH) != 0) {
                negotiatedStrength = &quot;medium&quot;;
            } else {
                // assume default low
                negotiatedStrength = &quot;low&quot;;
            }

            logger.log(Level.FINE, &quot;DIGEST86:Negotiated strength: {0}&quot;,
                negotiatedStrength);
        }

        // atmost once
        String digestUriFromResponse = ((responseVal[DIGEST_URI]) != null ?
            new String(responseVal[DIGEST_URI], encoding) : null);

        if (digestUriFromResponse != null) {
            logger.log(Level.FINE, &quot;DIGEST87:digest URI: {0}&quot;,
                digestUriFromResponse);
        }

        // serv-type &quot;/&quot; host [ &quot;/&quot; serv-name ]
        // e.g.: smtp/mail3.example.com/example.com
        // e.g.: ftp/ftp.example.com
        // e.g.: ldap/ldapserver.example.com

        // host should match one of service's configured service names
        // Check against digest URI that mech was created with

        if (uriMatches(digestUri, digestUriFromResponse)) {
            digestUri = digestUriFromResponse; // account for case-sensitive diffs
        } else {
            throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
                &quot;violation. Mismatched URI: &quot; + digestUriFromResponse +
                &quot;; expecting: &quot; + digestUri);
        }

        // response: exactly once
        byte[] responseFromClient = responseVal[RESPONSE];
        if (responseFromClient == null) {
            throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
                &quot; violation. Missing response.&quot;);
        }

        // authzid: atmost once
        byte[] authzidBytes;
        String authzidFromClient = ((authzidBytes=responseVal[AUTHZID]) != null?
            new String(authzidBytes, encoding) : username);

        if (authzidBytes != null) {
            logger.log(Level.FINE, &quot;DIGEST88:Authzid: {0}&quot;,
                new String(authzidBytes));
        }

        // Ignore auth-param

        // Get password need to generate verifying response
        char[] passwd;
        try {
            // Realm and Name callbacks are used to provide info
            RealmCallback rcb = new RealmCallback(&quot;DIGEST-MD5 realm: &quot;,
                negotiatedRealm);
            NameCallback ncb = new NameCallback(&quot;DIGEST-MD5 authentication ID: &quot;,
                username);

            // PasswordCallback is used to collect info
            PasswordCallback pcb =
                new PasswordCallback(&quot;DIGEST-MD5 password: &quot;, false);

            cbh.handle(new Callback[] {rcb, ncb, pcb});
            passwd = pcb.getPassword();
            pcb.clearPassword();

        } catch (UnsupportedCallbackException e) {
            throw new SaslException(
                &quot;DIGEST-MD5: Cannot perform callback to acquire password&quot;, e);

        } catch (IOException e) {
            throw new SaslException(
                &quot;DIGEST-MD5: IO error acquiring password&quot;, e);
        }

        if (passwd == null) {
            throw new SaslException(
                &quot;DIGEST-MD5: cannot acquire password for &quot; + username +
                &quot; in realm : &quot; + negotiatedRealm);
        }

        try {
            // Validate response value sent by client
            byte[] expectedResponse;

            try {
                expectedResponse = generateResponseValue(&quot;AUTHENTICATE&quot;,
                    digestUri, negotiatedQop, username, negotiatedRealm,
                    passwd, nonce /* use own nonce */,
                    cnonce, NONCE_COUNT_VALUE, authzidBytes);

            } catch (NoSuchAlgorithmException e) {
                throw new SaslException(
                    &quot;DIGEST-MD5: problem duplicating client response&quot;, e);
            } catch (IOException e) {
                throw new SaslException(
                    &quot;DIGEST-MD5: problem duplicating client response&quot;, e);
            }

            if (!Arrays.equals(responseFromClient, expectedResponse)) {
                throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
                    &quot;violation. Mismatched response.&quot;);
            }

            // Ensure that authzid mapping is OK
            try {
                AuthorizeCallback acb =
                    new AuthorizeCallback(username, authzidFromClient);
                cbh.handle(new Callback[]{acb});

                if (acb.isAuthorized()) {
                    authzid = acb.getAuthorizedID();
                } else {
                    throw new SaslException(&quot;DIGEST-MD5: &quot; + username +
                        &quot; is not authorized to act as &quot; + authzidFromClient);
                }
            } catch (SaslException e) {
                throw e;
            } catch (UnsupportedCallbackException e) {
                throw new SaslException(
                    &quot;DIGEST-MD5: Cannot perform callback to check authzid&quot;, e);
            } catch (IOException e) {
                throw new SaslException(
                    &quot;DIGEST-MD5: IO error checking authzid&quot;, e);
            }

            return generateResponseAuth(username, passwd, cnonce,
                NONCE_COUNT_VALUE, authzidBytes);
        } finally {
            // Clear password
            for (int i = 0; i &lt; passwd.length; i++) {
                passwd[i] = 0;
            }
        }
    }

    private static boolean uriMatches(String thisUri, String incomingUri) {
        // Full match
        if (thisUri.equalsIgnoreCase(incomingUri)) {
            return true;
        }
        // Unbound match
        if (thisUri.endsWith(&quot;/*&quot;)) {
            int protoAndSlash = thisUri.length() - 1;
            String thisProtoAndSlash = thisUri.substring(0, protoAndSlash);
            String incomingProtoAndSlash = incomingUri.substring(0, protoAndSlash);
            return thisProtoAndSlash.equalsIgnoreCase(incomingProtoAndSlash);
        }
        return false;
    }

    /**
     * Server sends a message formatted as follows:
     *    response-auth = &quot;rspauth&quot; &quot;=&quot; response-value
     *   where response-value is calculated as above, using the values sent in
     *   step two, except that if qop is &quot;auth&quot;, then A2 is
     *
     *       A2 = { &quot;:&quot;, digest-uri-value }
     *
     *   And if qop is &quot;auth-int&quot; or &quot;auth-conf&quot; then A2 is
     *
     *       A2 = { &quot;:&quot;, digest-uri-value, &quot;:00000000000000000000000000000000&quot; }
     *
     * Clears password afterwards.
     */
    private byte[] generateResponseAuth(String username, char[] passwd,
        byte[] cnonce, int nonceCount, byte[] authzidBytes) throws SaslException {

        // Construct response value

        try {
            byte[] responseValue = generateResponseValue(&quot;&quot;,
                digestUri, negotiatedQop, username, negotiatedRealm,
                passwd, nonce, cnonce, nonceCount, authzidBytes);

            byte[] challenge = new byte[responseValue.length + 8];
            System.arraycopy(&quot;rspauth=&quot;.getBytes(encoding), 0, challenge, 0, 8);
            System.arraycopy(responseValue, 0, challenge, 8,
                responseValue.length );

            return challenge;

        } catch (NoSuchAlgorithmException e) {
            throw new SaslException(&quot;DIGEST-MD5: problem generating response&quot;, e);
        } catch (IOException e) {
            throw new SaslException(&quot;DIGEST-MD5: problem generating response&quot;, e);
        }
    }

    public String getAuthorizationID() {
        if (completed) {
            return authzid;
        } else {
            throw new IllegalStateException(
                &quot;DIGEST-MD5 server negotiation not complete&quot;);
        }
    }
}
</pre>
</body>
</html>
