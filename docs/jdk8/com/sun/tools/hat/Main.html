<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * The Original Code is HAT. The Initial Developer of the
 * Original Code is Bill Foote, with contributions from others
 * at JavaSoft/Sun.
 */

package com.sun.tools.hat;

import java.io.IOException;
import java.io.File;

import com.sun.tools.hat.internal.model.Snapshot;
import com.sun.tools.hat.internal.model.ReachableExcludesImpl;
import com.sun.tools.hat.internal.server.QueryListener;

/**
 *
 * @author      Bill Foote
 */


public class Main {

    private static String VERSION_STRING = &quot;jhat version 2.0&quot;;

    private static void usage(String message) {
        if ( message != null ) {
            System.err.println(&quot;ERROR: &quot; + message);
        }
        System.err.println(&quot;Usage:  jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;&quot;);
        System.err.println();
        System.err.println(&quot;\t-J&lt;flag&gt;          Pass &lt;flag&gt; directly to the runtime system. For&quot;);
        System.err.println(&quot;\t\t\t  example, -J-mx512m to use a maximum heap size of 512MB&quot;);
        System.err.println(&quot;\t-stack false:     Turn off tracking object allocation call stack.&quot;);
        System.err.println(&quot;\t-refs false:      Turn off tracking of references to objects&quot;);
        System.err.println(&quot;\t-port &lt;port&gt;:     Set the port for the HTTP server.  Defaults to 7000&quot;);
        System.err.println(&quot;\t-exclude &lt;file&gt;:  Specify a file that lists data members that should&quot;);
        System.err.println(&quot;\t\t\t  be excluded from the reachableFrom query.&quot;);
        System.err.println(&quot;\t-baseline &lt;file&gt;: Specify a baseline object dump.  Objects in&quot;);
        System.err.println(&quot;\t\t\t  both heap dumps with the same ID and same class will&quot;);
        System.err.println(&quot;\t\t\t  be marked as not being \&quot;new\&quot;.&quot;);
        System.err.println(&quot;\t-debug &lt;int&gt;:     Set debug level.&quot;);
        System.err.println(&quot;\t\t\t    0:  No debug output&quot;);
        System.err.println(&quot;\t\t\t    1:  Debug hprof file parsing&quot;);
        System.err.println(&quot;\t\t\t    2:  Debug hprof file parsing, no server&quot;);
        System.err.println(&quot;\t-version          Report version number&quot;);
        System.err.println(&quot;\t-h|-help          Print this help and exit&quot;);
        System.err.println(&quot;\t&lt;file&gt;            The file to read&quot;);
        System.err.println();
        System.err.println(&quot;For a dump file that contains multiple heap dumps,&quot;);
        System.err.println(&quot;you may specify which dump in the file&quot;);
        System.err.println(&quot;by appending \&quot;#&lt;number&gt;\&quot; to the file name, i.e. \&quot;foo.hprof#3\&quot;.&quot;);
        System.err.println();
        System.err.println(&quot;All boolean options default to \&quot;true\&quot;&quot;);
        System.exit(1);
    }

    //
    // Convert s to a boolean.  If it's invalid, abort the program.
    //
    private static boolean booleanValue(String s) {
        if (&quot;true&quot;.equalsIgnoreCase(s)) {
            return true;
        } else if (&quot;false&quot;.equalsIgnoreCase(s)) {
            return false;
        } else {
            usage(&quot;Boolean value must be true or false&quot;);
            return false;       // Never happens
        }
    }

    public static void main(String[] args) {
        if (args.length &lt; 1) {
            usage(&quot;No arguments supplied&quot;);
        }

        boolean parseonly = false;
        int portNumber = 7000;
        boolean callStack = true;
        boolean calculateRefs = true;
        String baselineDump = null;
        String excludeFileName = null;
        int debugLevel = 0;
        for (int i = 0; ; i += 2) {
            if (i &gt; (args.length - 1)) {
                usage(&quot;Option parsing error&quot;);
            }
            if (&quot;-version&quot;.equals(args[i])) {
                System.out.print(VERSION_STRING);
                System.out.println(&quot; (java version &quot; + System.getProperty(&quot;java.version&quot;) + &quot;)&quot;);
                System.exit(0);
            }

            if (&quot;-h&quot;.equals(args[i]) || &quot;-help&quot;.equals(args[i])) {
                usage(null);
            }

            if (i == (args.length - 1)) {
                break;
            }
            String key = args[i];
            String value = args[i+1];
            if (&quot;-stack&quot;.equals(key)) {
                callStack = booleanValue(value);
            } else if (&quot;-refs&quot;.equals(key)) {
                calculateRefs = booleanValue(value);
            } else if (&quot;-port&quot;.equals(key)) {
                portNumber = Integer.parseInt(value, 10);
            } else if (&quot;-exclude&quot;.equals(key)) {
                excludeFileName = value;
            } else if (&quot;-baseline&quot;.equals(key)) {
                baselineDump = value;
            } else if (&quot;-debug&quot;.equals(key)) {
                debugLevel = Integer.parseInt(value, 10);
            } else if (&quot;-parseonly&quot;.equals(key)) {
                // Undocumented option. To be used for testing purpose only
                parseonly = booleanValue(value);
            }
        }
        String fileName = args[args.length - 1];
        Snapshot model = null;
        File excludeFile = null;
        if (excludeFileName != null) {
            excludeFile = new File(excludeFileName);
            if (!excludeFile.exists()) {
                System.out.println(&quot;Exclude file &quot; + excludeFile
                                    + &quot; does not exist.  Aborting.&quot;);
                System.exit(1);
            }
        }

        System.out.println(&quot;Reading from &quot; + fileName + &quot;...&quot;);
        try {
            model = com.sun.tools.hat.internal.parser.Reader.readFile(fileName, callStack, debugLevel);
        } catch (IOException ex) {
            ex.printStackTrace();
            System.exit(1);
        } catch (RuntimeException ex) {
            ex.printStackTrace();
            System.exit(1);
        }
        System.out.println(&quot;Snapshot read, resolving...&quot;);
        model.resolve(calculateRefs);
        System.out.println(&quot;Snapshot resolved.&quot;);

        if (excludeFile != null) {
            model.setReachableExcludes(new ReachableExcludesImpl(excludeFile));
        }

        if (baselineDump != null) {
            System.out.println(&quot;Reading baseline snapshot...&quot;);
            Snapshot baseline = null;
            try {
                baseline = com.sun.tools.hat.internal.parser.Reader.readFile(baselineDump, false,
                                                      debugLevel);
            } catch (IOException ex) {
                ex.printStackTrace();
                System.exit(1);
            } catch (RuntimeException ex) {
                ex.printStackTrace();
                System.exit(1);
            }
            baseline.resolve(false);
            System.out.println(&quot;Discovering new objects...&quot;);
            model.markNewRelativeTo(baseline);
            baseline = null;    // Guard against conservative GC
        }
        if ( debugLevel == 2 ) {
            System.out.println(&quot;No server, -debug 2 was used.&quot;);
            System.exit(0);
        }

        if (parseonly) {
            // do not start web server.
            System.out.println(&quot;-parseonly is true, exiting..&quot;);
            System.exit(0);
        }

        QueryListener listener = new QueryListener(portNumber);
        listener.setModel(model);
        Thread t = new Thread(listener, &quot;Query Listener&quot;);
        t.setPriority(Thread.NORM_PRIORITY+1);
        t.start();
        System.out.println(&quot;Started HTTP server on port &quot; + portNumber);
        System.out.println(&quot;Server is ready.&quot;);
    }
}
</pre>
</body>
</html>
