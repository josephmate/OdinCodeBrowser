<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.tools.jdi;

import java.util.List;
import java.util.ArrayList;

public class JNITypeParser {

    static final char SIGNATURE_ENDCLASS = ';';
    static final char SIGNATURE_FUNC = '(';
    static final char SIGNATURE_ENDFUNC = ')';

    private String signature;
    private List&lt;String&gt; typeNameList;
    private List&lt;String&gt; signatureList;
    private int currentIndex;

    JNITypeParser(String signature) {
        this.signature = signature;
    }

    static String typeNameToSignature(String signature) {
        StringBuffer buffer = new StringBuffer();
        int firstIndex = signature.indexOf('[');
        int index = firstIndex;
        while (index != -1) {
            buffer.append('[');
            index = signature.indexOf('[', index + 1);
        }

        if (firstIndex != -1) {
            signature = signature.substring(0, firstIndex);
        }

        if (signature.equals(&quot;boolean&quot;)) {
            buffer.append('Z');
        } else if (signature.equals(&quot;byte&quot;)) {
            buffer.append('B');
        } else if (signature.equals(&quot;char&quot;)) {
            buffer.append('C');
        } else if (signature.equals(&quot;short&quot;)) {
            buffer.append('S');
        } else if (signature.equals(&quot;int&quot;)) {
            buffer.append('I');
        } else if (signature.equals(&quot;long&quot;)) {
            buffer.append('J');
        } else if (signature.equals(&quot;float&quot;)) {
            buffer.append('F');
        } else if (signature.equals(&quot;double&quot;)) {
            buffer.append('D');
        } else {
            buffer.append('L');
            buffer.append(signature.replace('.', '/'));
            buffer.append(';');
        }

        return buffer.toString();
    }

    String typeName() {
        return typeNameList().get(typeNameList().size()-1);
    }

    List&lt;String&gt; argumentTypeNames() {
        return typeNameList().subList(0, typeNameList().size() - 1);
    }

    String signature() {
        return signatureList().get(signatureList().size()-1);
    }

    List&lt;String&gt; argumentSignatures() {
        return signatureList().subList(0, signatureList().size() - 1);
    }

    int dimensionCount() {
        int count = 0;
        String signature = signature();
        while (signature.charAt(count) == '[') {
            count++;
        }
        return count;
    }

    String componentSignature(int level) {
        return signature().substring(level);
    }

    private synchronized List&lt;String&gt; signatureList() {
        if (signatureList == null) {
            signatureList = new ArrayList&lt;String&gt;(10);
            String elem;

            currentIndex = 0;

            while(currentIndex &lt; signature.length()) {
                elem = nextSignature();
                signatureList.add(elem);
            }
            if (signatureList.size() == 0) {
                throw new IllegalArgumentException(&quot;Invalid JNI signature '&quot; +
                                                   signature + &quot;'&quot;);
            }
        }
        return signatureList;
    }

    private synchronized List&lt;String&gt; typeNameList() {
        if (typeNameList == null) {
            typeNameList = new ArrayList&lt;String&gt;(10);
            String elem;

            currentIndex = 0;

            while(currentIndex &lt; signature.length()) {
                elem = nextTypeName();
                typeNameList.add(elem);
            }
            if (typeNameList.size() == 0) {
                throw new IllegalArgumentException(&quot;Invalid JNI signature '&quot; +
                                                   signature + &quot;'&quot;);
            }
        }
        return typeNameList;
    }

    private String nextSignature() {
        char key = signature.charAt(currentIndex++);

        switch(key) {
            case (JDWP.Tag.ARRAY):
                return  key + nextSignature();

            case (JDWP.Tag.OBJECT):
                int endClass = signature.indexOf(SIGNATURE_ENDCLASS,
                                                 currentIndex);
                String retVal = signature.substring(currentIndex - 1,
                                                    endClass + 1);
                currentIndex = endClass + 1;
                return retVal;

            case (JDWP.Tag.VOID):
            case (JDWP.Tag.BOOLEAN):
            case (JDWP.Tag.BYTE):
            case (JDWP.Tag.CHAR):
            case (JDWP.Tag.SHORT):
            case (JDWP.Tag.INT):
            case (JDWP.Tag.LONG):
            case (JDWP.Tag.FLOAT):
            case (JDWP.Tag.DOUBLE):
                return String.valueOf(key);

            case SIGNATURE_ENDFUNC:
            case SIGNATURE_FUNC:
                return nextSignature();

            default:
                throw new IllegalArgumentException(
                    &quot;Invalid JNI signature character '&quot; + key + &quot;'&quot;);

        }
    }

    private String nextTypeName() {
        char key = signature.charAt(currentIndex++);

        switch(key) {
            case (JDWP.Tag.ARRAY):
                return  nextTypeName() + &quot;[]&quot;;

            case (JDWP.Tag.BYTE):
                return &quot;byte&quot;;

            case (JDWP.Tag.CHAR):
                return &quot;char&quot;;

            case (JDWP.Tag.OBJECT):
                int endClass = signature.indexOf(SIGNATURE_ENDCLASS,
                                                 currentIndex);
                String retVal = signature.substring(currentIndex,
                                                    endClass);
                retVal = retVal.replace('/','.');
                currentIndex = endClass + 1;
                return retVal;

            case (JDWP.Tag.FLOAT):
                return &quot;float&quot;;

            case (JDWP.Tag.DOUBLE):
                return &quot;double&quot;;

            case (JDWP.Tag.INT):
                return &quot;int&quot;;

            case (JDWP.Tag.LONG):
                return &quot;long&quot;;

            case (JDWP.Tag.SHORT):
                return &quot;short&quot;;

            case (JDWP.Tag.VOID):
                return &quot;void&quot;;

            case (JDWP.Tag.BOOLEAN):
                return &quot;boolean&quot;;

            case SIGNATURE_ENDFUNC:
            case SIGNATURE_FUNC:
                return nextTypeName();

            default:
                throw new IllegalArgumentException(
                    &quot;Invalid JNI signature character '&quot; + key + &quot;'&quot;);

        }
    }
}
</pre>
</body>
</html>
