<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1998, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This source code is provided to illustrate the usage of a given feature
 * or technique and has been deliberately simplified. Additional steps
 * required for a production-quality application, such as security checks,
 * input validation and proper error handling, might not be present in
 * this sample code.
 */


package com.sun.tools.example.debug.tty;

import com.sun.jdi.*;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.request.*;
import com.sun.tools.example.debug.expr.ExpressionParser;
import com.sun.tools.example.debug.expr.ParseException;

import java.text.*;
import java.util.*;
import java.io.*;

class Commands {

    abstract class AsyncExecution {
        abstract void action();

        AsyncExecution() {
            execute();
        }

        void execute() {
            /*
             * Save current thread and stack frame. (BugId 4296031)
             */
            final ThreadInfo threadInfo = ThreadInfo.getCurrentThreadInfo();
            final int stackFrame = threadInfo == null? 0 : threadInfo.getCurrentFrameIndex();
            Thread thread = new Thread(&quot;asynchronous jdb command&quot;) {
                    @Override
                    public void run() {
                        try {
                            action();
                        } catch (UnsupportedOperationException uoe) {
                            //(BugId 4453329)
                            MessageOutput.println(&quot;Operation is not supported on the target VM&quot;);
                        } catch (Exception e) {
                            MessageOutput.println(&quot;Internal exception during operation:&quot;,
                                                  e.getMessage());
                        } finally {
                            /*
                             * This was an asynchronous command.  Events may have been
                             * processed while it was running.  Restore the thread and
                             * stack frame the user was looking at.  (BugId 4296031)
                             */
                            if (threadInfo != null) {
                                ThreadInfo.setCurrentThreadInfo(threadInfo);
                                try {
                                    threadInfo.setCurrentFrameIndex(stackFrame);
                                } catch (IncompatibleThreadStateException e) {
                                    MessageOutput.println(&quot;Current thread isnt suspended.&quot;);
                                } catch (ArrayIndexOutOfBoundsException e) {
                                    MessageOutput.println(&quot;Requested stack frame is no longer active:&quot;,
                                                          new Object []{new Integer(stackFrame)});
                                }
                            }
                            MessageOutput.printPrompt();
                        }
                    }
                };
            thread.start();
        }
    }

    Commands() {
    }

    private Value evaluate(String expr) {
        Value result = null;
        ExpressionParser.GetFrame frameGetter = null;
        try {
            final ThreadInfo threadInfo = ThreadInfo.getCurrentThreadInfo();
            if ((threadInfo != null) &amp;&amp; (threadInfo.getCurrentFrame() != null)) {
                frameGetter = new ExpressionParser.GetFrame() {
                        @Override
                        public StackFrame get() throws IncompatibleThreadStateException {
                            return threadInfo.getCurrentFrame();
                        }
                    };
            }
            result = ExpressionParser.evaluate(expr, Env.vm(), frameGetter);
        } catch (InvocationException ie) {
            MessageOutput.println(&quot;Exception in expression:&quot;,
                                  ie.exception().referenceType().name());
        } catch (Exception ex) {
            String exMessage = ex.getMessage();
            if (exMessage == null) {
                MessageOutput.printException(exMessage, ex);
            } else {
                String s;
                try {
                    s = MessageOutput.format(exMessage);
                } catch (MissingResourceException mex) {
                    s = ex.toString();
                }
                MessageOutput.printDirectln(s);// Special case: use printDirectln()
            }
        }
        return result;
    }

    private String getStringValue() {
         Value val = null;
         String valStr = null;
         try {
              val = ExpressionParser.getMassagedValue();
              valStr = val.toString();
         } catch (ParseException e) {
              String msg = e.getMessage();
              if (msg == null) {
                  MessageOutput.printException(msg, e);
              } else {
                  String s;
                  try {
                      s = MessageOutput.format(msg);
                  } catch (MissingResourceException mex) {
                      s = e.toString();
                  }
                  MessageOutput.printDirectln(s);
              }
         }
         return valStr;
    }

    private ThreadInfo doGetThread(String idToken) {
        ThreadInfo threadInfo = ThreadInfo.getThreadInfo(idToken);
        if (threadInfo == null) {
            MessageOutput.println(&quot;is not a valid thread id&quot;, idToken);
        }
        return threadInfo;
    }

    String typedName(Method method) {
        StringBuffer buf = new StringBuffer();
        buf.append(method.name());
        buf.append(&quot;(&quot;);

        List&lt;String&gt; args = method.argumentTypeNames();
        int lastParam = args.size() - 1;
        // output param types except for the last
        for (int ii = 0; ii &lt; lastParam; ii++) {
            buf.append(args.get(ii));
            buf.append(&quot;, &quot;);
        }
        if (lastParam &gt;= 0) {
            // output the last param
            String lastStr = args.get(lastParam);
            if (method.isVarArgs()) {
                // lastParam is an array.  Replace the [] with ...
                buf.append(lastStr.substring(0, lastStr.length() - 2));
                buf.append(&quot;...&quot;);
            } else {
                buf.append(lastStr);
            }
        }
        buf.append(&quot;)&quot;);
        return buf.toString();
    }

    void commandConnectors(VirtualMachineManager vmm) {
        Collection&lt;Connector&gt; ccs = vmm.allConnectors();
        if (ccs.isEmpty()) {
            MessageOutput.println(&quot;Connectors available&quot;);
        }
        for (Connector cc : ccs) {
            String transportName =
                cc.transport() == null ? &quot;null&quot; : cc.transport().name();
            MessageOutput.println();
            MessageOutput.println(&quot;Connector and Transport name&quot;,
                                  new Object [] {cc.name(), transportName});
            MessageOutput.println(&quot;Connector description&quot;, cc.description());

            for (Connector.Argument aa : cc.defaultArguments().values()) {
                    MessageOutput.println();

                    boolean requiredArgument = aa.mustSpecify();
                    if (aa.value() == null || aa.value() == &quot;&quot;) {
                        //no current value and no default.
                        MessageOutput.println(requiredArgument ?
                                              &quot;Connector required argument nodefault&quot; :
                                              &quot;Connector argument nodefault&quot;, aa.name());
                    } else {
                        MessageOutput.println(requiredArgument ?
                                              &quot;Connector required argument default&quot; :
                                              &quot;Connector argument default&quot;,
                                              new Object [] {aa.name(), aa.value()});
                    }
                    MessageOutput.println(&quot;Connector description&quot;, aa.description());

                }
            }

    }

    void commandClasses() {
        StringBuffer classList = new StringBuffer();
        for (ReferenceType refType : Env.vm().allClasses()) {
            classList.append(refType.name());
            classList.append(&quot;\n&quot;);
        }
        MessageOutput.print(&quot;** classes list **&quot;, classList.toString());
    }

    void commandClass(StringTokenizer t) {

        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;No class specified.&quot;);
            return;
        }

        String idClass = t.nextToken();
        boolean showAll = false;

        if (t.hasMoreTokens()) {
            if (t.nextToken().toLowerCase().equals(&quot;all&quot;)) {
                showAll = true;
            } else {
                MessageOutput.println(&quot;Invalid option on class command&quot;);
                return;
            }
        }
        ReferenceType type = Env.getReferenceTypeFromToken(idClass);
        if (type == null) {
            MessageOutput.println(&quot;is not a valid id or class name&quot;, idClass);
            return;
        }
        if (type instanceof ClassType) {
            ClassType clazz = (ClassType)type;
            MessageOutput.println(&quot;Class:&quot;, clazz.name());

            ClassType superclass = clazz.superclass();
            while (superclass != null) {
                MessageOutput.println(&quot;extends:&quot;, superclass.name());
                superclass = showAll ? superclass.superclass() : null;
            }

            List&lt;InterfaceType&gt; interfaces =
                showAll ? clazz.allInterfaces() : clazz.interfaces();
            for (InterfaceType interfaze : interfaces) {
                MessageOutput.println(&quot;implements:&quot;, interfaze.name());
            }

            for (ClassType sub : clazz.subclasses()) {
                MessageOutput.println(&quot;subclass:&quot;, sub.name());
            }
            for (ReferenceType nest : clazz.nestedTypes()) {
                MessageOutput.println(&quot;nested:&quot;, nest.name());
            }
        } else if (type instanceof InterfaceType) {
            InterfaceType interfaze = (InterfaceType)type;
            MessageOutput.println(&quot;Interface:&quot;, interfaze.name());
            for (InterfaceType superinterface : interfaze.superinterfaces()) {
                MessageOutput.println(&quot;extends:&quot;, superinterface.name());
            }
            for (InterfaceType sub : interfaze.subinterfaces()) {
                MessageOutput.println(&quot;subinterface:&quot;, sub.name());
            }
            for (ClassType implementor : interfaze.implementors()) {
                MessageOutput.println(&quot;implementor:&quot;, implementor.name());
            }
            for (ReferenceType nest : interfaze.nestedTypes()) {
                MessageOutput.println(&quot;nested:&quot;, nest.name());
            }
        } else {  // array type
            ArrayType array = (ArrayType)type;
            MessageOutput.println(&quot;Array:&quot;, array.name());
        }
    }

    void commandMethods(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;No class specified.&quot;);
            return;
        }

        String idClass = t.nextToken();
        ReferenceType cls = Env.getReferenceTypeFromToken(idClass);
        if (cls != null) {
            StringBuffer methodsList = new StringBuffer();
            for (Method method : cls.allMethods()) {
                methodsList.append(method.declaringType().name());
                methodsList.append(&quot; &quot;);
                methodsList.append(typedName(method));
                methodsList.append('\n');
            }
            MessageOutput.print(&quot;** methods list **&quot;, methodsList.toString());
        } else {
            MessageOutput.println(&quot;is not a valid id or class name&quot;, idClass);
        }
    }

    void commandFields(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;No class specified.&quot;);
            return;
        }

        String idClass = t.nextToken();
        ReferenceType cls = Env.getReferenceTypeFromToken(idClass);
        if (cls != null) {
            List&lt;Field&gt; fields = cls.allFields();
            List&lt;Field&gt; visible = cls.visibleFields();
            StringBuffer fieldsList = new StringBuffer();
            for (Field field : fields) {
                String s;
                if (!visible.contains(field)) {
                    s = MessageOutput.format(&quot;list field typename and name hidden&quot;,
                                             new Object [] {field.typeName(),
                                                            field.name()});
                } else if (!field.declaringType().equals(cls)) {
                    s = MessageOutput.format(&quot;list field typename and name inherited&quot;,
                                             new Object [] {field.typeName(),
                                                            field.name(),
                                                            field.declaringType().name()});
                } else {
                    s = MessageOutput.format(&quot;list field typename and name&quot;,
                                             new Object [] {field.typeName(),
                                                            field.name()});
                }
                fieldsList.append(s);
            }
            MessageOutput.print(&quot;** fields list **&quot;, fieldsList.toString());
        } else {
            MessageOutput.println(&quot;is not a valid id or class name&quot;, idClass);
        }
    }

    private void printThreadGroup(ThreadGroupReference tg) {
        ThreadIterator threadIter = new ThreadIterator(tg);

        MessageOutput.println(&quot;Thread Group:&quot;, tg.name());
        int maxIdLength = 0;
        int maxNameLength = 0;
        while (threadIter.hasNext()) {
            ThreadReference thr = threadIter.next();
            maxIdLength = Math.max(maxIdLength,
                                   Env.description(thr).length());
            maxNameLength = Math.max(maxNameLength,
                                     thr.name().length());
        }

        threadIter = new ThreadIterator(tg);
        while (threadIter.hasNext()) {
            ThreadReference thr = threadIter.next();
            if (thr.threadGroup() == null) {
                continue;
            }
            // Note any thread group changes
            if (!thr.threadGroup().equals(tg)) {
                tg = thr.threadGroup();
                MessageOutput.println(&quot;Thread Group:&quot;, tg.name());
            }

            /*
             * Do a bit of filling with whitespace to get thread ID
             * and thread names to line up in the listing, and also
             * allow for proper localization.  This also works for
             * very long thread names, at the possible cost of lines
             * being wrapped by the display device.
             */
            StringBuffer idBuffer = new StringBuffer(Env.description(thr));
            for (int i = idBuffer.length(); i &lt; maxIdLength; i++) {
                idBuffer.append(&quot; &quot;);
            }
            StringBuffer nameBuffer = new StringBuffer(thr.name());
            for (int i = nameBuffer.length(); i &lt; maxNameLength; i++) {
                nameBuffer.append(&quot; &quot;);
            }

            /*
             * Select the output format to use based on thread status
             * and breakpoint.
             */
            String statusFormat;
            switch (thr.status()) {
            case ThreadReference.THREAD_STATUS_UNKNOWN:
                if (thr.isAtBreakpoint()) {
                    statusFormat = &quot;Thread description name unknownStatus BP&quot;;
                } else {
                    statusFormat = &quot;Thread description name unknownStatus&quot;;
                }
                break;
            case ThreadReference.THREAD_STATUS_ZOMBIE:
                if (thr.isAtBreakpoint()) {
                    statusFormat = &quot;Thread description name zombieStatus BP&quot;;
                } else {
                    statusFormat = &quot;Thread description name zombieStatus&quot;;
                }
                break;
            case ThreadReference.THREAD_STATUS_RUNNING:
                if (thr.isAtBreakpoint()) {
                    statusFormat = &quot;Thread description name runningStatus BP&quot;;
                } else {
                    statusFormat = &quot;Thread description name runningStatus&quot;;
                }
                break;
            case ThreadReference.THREAD_STATUS_SLEEPING:
                if (thr.isAtBreakpoint()) {
                    statusFormat = &quot;Thread description name sleepingStatus BP&quot;;
                } else {
                    statusFormat = &quot;Thread description name sleepingStatus&quot;;
                }
                break;
            case ThreadReference.THREAD_STATUS_MONITOR:
                if (thr.isAtBreakpoint()) {
                    statusFormat = &quot;Thread description name waitingStatus BP&quot;;
                } else {
                    statusFormat = &quot;Thread description name waitingStatus&quot;;
                }
                break;
            case ThreadReference.THREAD_STATUS_WAIT:
                if (thr.isAtBreakpoint()) {
                    statusFormat = &quot;Thread description name condWaitstatus BP&quot;;
                } else {
                    statusFormat = &quot;Thread description name condWaitstatus&quot;;
                }
                break;
            default:
                throw new InternalError(MessageOutput.format(&quot;Invalid thread status.&quot;));
            }
            MessageOutput.println(statusFormat,
                                  new Object [] {idBuffer.toString(),
                                                 nameBuffer.toString()});
        }
    }

    void commandThreads(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            printThreadGroup(ThreadInfo.group());
            return;
        }
        String name = t.nextToken();
        ThreadGroupReference tg = ThreadGroupIterator.find(name);
        if (tg == null) {
            MessageOutput.println(&quot;is not a valid threadgroup name&quot;, name);
        } else {
            printThreadGroup(tg);
        }
    }

    void commandThreadGroups() {
        ThreadGroupIterator it = new ThreadGroupIterator();
        int cnt = 0;
        while (it.hasNext()) {
            ThreadGroupReference tg = it.nextThreadGroup();
            ++cnt;
            MessageOutput.println(&quot;thread group number description name&quot;,
                                  new Object [] { new Integer (cnt),
                                                  Env.description(tg),
                                                  tg.name()});
        }
    }

    void commandThread(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;Thread number not specified.&quot;);
            return;
        }
        ThreadInfo threadInfo = doGetThread(t.nextToken());
        if (threadInfo != null) {
            ThreadInfo.setCurrentThreadInfo(threadInfo);
        }
    }

    void commandThreadGroup(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;Threadgroup name not specified.&quot;);
            return;
        }
        String name = t.nextToken();
        ThreadGroupReference tg = ThreadGroupIterator.find(name);
        if (tg == null) {
            MessageOutput.println(&quot;is not a valid threadgroup name&quot;, name);
        } else {
            ThreadInfo.setThreadGroup(tg);
        }
    }

    void commandRun(StringTokenizer t) {
        /*
         * The 'run' command makes little sense in a
         * that doesn't support restarts or multiple VMs. However,
         * this is an attempt to emulate the behavior of the old
         * JDB as much as possible. For new users and implementations
         * it is much more straightforward to launch immedidately
         * with the -launch option.
         */
        VMConnection connection = Env.connection();
        if (!connection.isLaunch()) {
            if (!t.hasMoreTokens()) {
                commandCont();
            } else {
                MessageOutput.println(&quot;run &lt;args&gt; command is valid only with launched VMs&quot;);
            }
            return;
        }
        if (connection.isOpen()) {
            MessageOutput.println(&quot;VM already running. use cont to continue after events.&quot;);
            return;
        }

        /*
         * Set the main class and any arguments. Note that this will work
         * only with the standard launcher, &quot;com.sun.jdi.CommandLineLauncher&quot;
         */
        String args;
        if (t.hasMoreTokens()) {
            args = t.nextToken(&quot;&quot;);
            boolean argsSet = connection.setConnectorArg(&quot;main&quot;, args);
            if (!argsSet) {
                MessageOutput.println(&quot;Unable to set main class and arguments&quot;);
                return;
            }
        } else {
            args = connection.connectorArg(&quot;main&quot;);
            if (args.length() == 0) {
                MessageOutput.println(&quot;Main class and arguments must be specified&quot;);
                return;
            }
        }
        MessageOutput.println(&quot;run&quot;, args);

        /*
         * Launch the VM.
         */
        connection.open();

    }

    void commandLoad(StringTokenizer t) {
        MessageOutput.println(&quot;The load command is no longer supported.&quot;);
    }

    private List&lt;ThreadReference&gt; allThreads(ThreadGroupReference group) {
        List&lt;ThreadReference&gt; list = new ArrayList&lt;ThreadReference&gt;();
        list.addAll(group.threads());
        for (ThreadGroupReference child : group.threadGroups()) {
            list.addAll(allThreads(child));
        }
        return list;
    }

    void commandSuspend(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            Env.vm().suspend();
            MessageOutput.println(&quot;All threads suspended.&quot;);
        } else {
            while (t.hasMoreTokens()) {
                ThreadInfo threadInfo = doGetThread(t.nextToken());
                if (threadInfo != null) {
                    threadInfo.getThread().suspend();
                }
            }
        }
    }

    void commandResume(StringTokenizer t) {
         if (!t.hasMoreTokens()) {
             ThreadInfo.invalidateAll();
             Env.vm().resume();
             MessageOutput.println(&quot;All threads resumed.&quot;);
         } else {
             while (t.hasMoreTokens()) {
                ThreadInfo threadInfo = doGetThread(t.nextToken());
                if (threadInfo != null) {
                    threadInfo.invalidate();
                    threadInfo.getThread().resume();
                }
            }
        }
    }

    void commandCont() {
        if (ThreadInfo.getCurrentThreadInfo() == null) {
            MessageOutput.println(&quot;Nothing suspended.&quot;);
            return;
        }
        ThreadInfo.invalidateAll();
        Env.vm().resume();
    }

    void clearPreviousStep(ThreadReference thread) {
        /*
         * A previous step may not have completed on this thread;
         * if so, it gets removed here.
         */
         EventRequestManager mgr = Env.vm().eventRequestManager();
         for (StepRequest request : mgr.stepRequests()) {
             if (request.thread().equals(thread)) {
                 mgr.deleteEventRequest(request);
                 break;
             }
         }
    }
    /* step
     *
     */
    void commandStep(StringTokenizer t) {
        ThreadInfo threadInfo = ThreadInfo.getCurrentThreadInfo();
        if (threadInfo == null) {
            MessageOutput.println(&quot;Nothing suspended.&quot;);
            return;
        }
        int depth;
        if (t.hasMoreTokens() &amp;&amp;
                  t.nextToken().toLowerCase().equals(&quot;up&quot;)) {
            depth = StepRequest.STEP_OUT;
        } else {
            depth = StepRequest.STEP_INTO;
        }

        clearPreviousStep(threadInfo.getThread());
        EventRequestManager reqMgr = Env.vm().eventRequestManager();
        StepRequest request = reqMgr.createStepRequest(threadInfo.getThread(),
                                                       StepRequest.STEP_LINE, depth);
        if (depth == StepRequest.STEP_INTO) {
            Env.addExcludes(request);
        }
        // We want just the next step event and no others
        request.addCountFilter(1);
        request.enable();
        ThreadInfo.invalidateAll();
        Env.vm().resume();
    }

    /* stepi
     * step instruction.
     */
    void commandStepi() {
        ThreadInfo threadInfo = ThreadInfo.getCurrentThreadInfo();
        if (threadInfo == null) {
            MessageOutput.println(&quot;Nothing suspended.&quot;);
            return;
        }
        clearPreviousStep(threadInfo.getThread());
        EventRequestManager reqMgr = Env.vm().eventRequestManager();
        StepRequest request = reqMgr.createStepRequest(threadInfo.getThread(),
                                                       StepRequest.STEP_MIN,
                                                       StepRequest.STEP_INTO);
        Env.addExcludes(request);
        // We want just the next step event and no others
        request.addCountFilter(1);
        request.enable();
        ThreadInfo.invalidateAll();
        Env.vm().resume();
    }

    void commandNext() {
        ThreadInfo threadInfo = ThreadInfo.getCurrentThreadInfo();
        if (threadInfo == null) {
            MessageOutput.println(&quot;Nothing suspended.&quot;);
            return;
        }
        clearPreviousStep(threadInfo.getThread());
        EventRequestManager reqMgr = Env.vm().eventRequestManager();
        StepRequest request = reqMgr.createStepRequest(threadInfo.getThread(),
                                                       StepRequest.STEP_LINE,
                                                       StepRequest.STEP_OVER);
        Env.addExcludes(request);
        // We want just the next step event and no others
        request.addCountFilter(1);
        request.enable();
        ThreadInfo.invalidateAll();
        Env.vm().resume();
    }

    void doKill(ThreadReference thread, StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;No exception object specified.&quot;);
            return;
        }
        String expr = t.nextToken(&quot;&quot;);
        Value val = evaluate(expr);
        if ((val != null) &amp;&amp; (val instanceof ObjectReference)) {
            try {
                thread.stop((ObjectReference)val);
                MessageOutput.println(&quot;killed&quot;, thread.toString());
            } catch (InvalidTypeException e) {
                MessageOutput.println(&quot;Invalid exception object&quot;);
            }
        } else {
            MessageOutput.println(&quot;Expression must evaluate to an object&quot;);
        }
    }

    void doKillThread(final ThreadReference threadToKill,
                      final StringTokenizer tokenizer) {
        new AsyncExecution() {
                @Override
                void action() {
                    doKill(threadToKill, tokenizer);
                }
            };
    }

    void commandKill(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;Usage: kill &lt;thread id&gt; &lt;throwable&gt;&quot;);
            return;
        }
        ThreadInfo threadInfo = doGetThread(t.nextToken());
        if (threadInfo != null) {
            MessageOutput.println(&quot;killing thread:&quot;, threadInfo.getThread().name());
            doKillThread(threadInfo.getThread(), t);
            return;
        }
    }

    void listCaughtExceptions() {
        boolean noExceptions = true;

        // Print a listing of the catch patterns currently in place
        for (EventRequestSpec spec : Env.specList.eventRequestSpecs()) {
            if (spec instanceof ExceptionSpec) {
                if (noExceptions) {
                    noExceptions = false;
                    MessageOutput.println(&quot;Exceptions caught:&quot;);
                }
                MessageOutput.println(&quot;tab&quot;, spec.toString());
            }
        }
        if (noExceptions) {
            MessageOutput.println(&quot;No exceptions caught.&quot;);
        }
    }

    private EventRequestSpec parseExceptionSpec(StringTokenizer t) {
        String notification = t.nextToken();
        boolean notifyCaught = false;
        boolean notifyUncaught = false;
        EventRequestSpec spec = null;
        String classPattern = null;

        if (notification.equals(&quot;uncaught&quot;)) {
            notifyCaught = false;
            notifyUncaught = true;
        } else if (notification.equals(&quot;caught&quot;)) {
            notifyCaught = true;
            notifyUncaught = false;
        } else if (notification.equals(&quot;all&quot;)) {
            notifyCaught = true;
            notifyUncaught = true;
        } else {
            /*
             * Handle the same as &quot;all&quot; for backward
             * compatibility with existing .jdbrc files.
             *
             * Insert an &quot;all&quot; and take the current token as the
             * intended classPattern
             *
             */
            notifyCaught = true;
            notifyUncaught = true;
            classPattern = notification;
        }
        if (classPattern == null &amp;&amp; t.hasMoreTokens()) {
            classPattern = t.nextToken();
        }
        if ((classPattern != null) &amp;&amp; (notifyCaught || notifyUncaught)) {
            try {
                spec = Env.specList.createExceptionCatch(classPattern,
                                                         notifyCaught,
                                                         notifyUncaught);
            } catch (ClassNotFoundException exc) {
                MessageOutput.println(&quot;is not a valid class name&quot;, classPattern);
            }
        }
        return spec;
    }

    void commandCatchException(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            listCaughtExceptions();
        } else {
            EventRequestSpec spec = parseExceptionSpec(t);
            if (spec != null) {
                resolveNow(spec);
            } else {
                MessageOutput.println(&quot;Usage: catch exception&quot;);
            }
        }
    }

    void commandIgnoreException(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            listCaughtExceptions();
        } else {
            EventRequestSpec spec = parseExceptionSpec(t);
            if (Env.specList.delete(spec)) {
                MessageOutput.println(&quot;Removed:&quot;, spec.toString());
            } else {
                if (spec != null) {
                    MessageOutput.println(&quot;Not found:&quot;, spec.toString());
                }
                MessageOutput.println(&quot;Usage: ignore exception&quot;);
            }
        }
    }

    void commandUp(StringTokenizer t) {
        ThreadInfo threadInfo = ThreadInfo.getCurrentThreadInfo();
        if (threadInfo == null) {
            MessageOutput.println(&quot;Current thread not set.&quot;);
            return;
        }

        int nLevels = 1;
        if (t.hasMoreTokens()) {
            String idToken = t.nextToken();
            int i;
            try {
                NumberFormat nf = NumberFormat.getNumberInstance();
                nf.setParseIntegerOnly(true);
                Number n = nf.parse(idToken);
                i = n.intValue();
            } catch (java.text.ParseException jtpe) {
                i = 0;
            }
            if (i &lt;= 0) {
                MessageOutput.println(&quot;Usage: up [n frames]&quot;);
                return;
            }
            nLevels = i;
        }

        try {
            threadInfo.up(nLevels);
        } catch (IncompatibleThreadStateException e) {
            MessageOutput.println(&quot;Current thread isnt suspended.&quot;);
        } catch (ArrayIndexOutOfBoundsException e) {
            MessageOutput.println(&quot;End of stack.&quot;);
        }
    }

    void commandDown(StringTokenizer t) {
        ThreadInfo threadInfo = ThreadInfo.getCurrentThreadInfo();
        if (threadInfo == null) {
            MessageOutput.println(&quot;Current thread not set.&quot;);
            return;
        }

        int nLevels = 1;
        if (t.hasMoreTokens()) {
            String idToken = t.nextToken();
            int i;
            try {
                NumberFormat nf = NumberFormat.getNumberInstance();
                nf.setParseIntegerOnly(true);
                Number n = nf.parse(idToken);
                i = n.intValue();
            } catch (java.text.ParseException jtpe) {
                i = 0;
            }
            if (i &lt;= 0) {
                MessageOutput.println(&quot;Usage: down [n frames]&quot;);
                return;
            }
            nLevels = i;
        }

        try {
            threadInfo.down(nLevels);
        } catch (IncompatibleThreadStateException e) {
            MessageOutput.println(&quot;Current thread isnt suspended.&quot;);
        } catch (ArrayIndexOutOfBoundsException e) {
            MessageOutput.println(&quot;End of stack.&quot;);
        }
    }

    private void dumpStack(ThreadInfo threadInfo, boolean showPC) {
        List&lt;StackFrame&gt; stack = null;
        try {
            stack = threadInfo.getStack();
        } catch (IncompatibleThreadStateException e) {
            MessageOutput.println(&quot;Current thread isnt suspended.&quot;);
            return;
        }
        if (stack == null) {
            MessageOutput.println(&quot;Thread is not running (no stack).&quot;);
        } else {
            int nFrames = stack.size();
            for (int i = threadInfo.getCurrentFrameIndex(); i &lt; nFrames; i++) {
                StackFrame frame = stack.get(i);
                dumpFrame (i, showPC, frame);
            }
        }
    }

    private void dumpFrame (int frameNumber, boolean showPC, StackFrame frame) {
        Location loc = frame.location();
        long pc = -1;
        if (showPC) {
            pc = loc.codeIndex();
        }
        Method meth = loc.method();

        long lineNumber = loc.lineNumber();
        String methodInfo = null;
        if (meth.isNative()) {
            methodInfo = MessageOutput.format(&quot;native method&quot;);
        } else if (lineNumber != -1) {
            try {
                methodInfo = loc.sourceName() +
                    MessageOutput.format(&quot;line number&quot;,
                                         new Object [] {new Long(lineNumber)});
            } catch (AbsentInformationException e) {
                methodInfo = MessageOutput.format(&quot;unknown&quot;);
            }
        }
        if (pc != -1) {
            MessageOutput.println(&quot;stack frame dump with pc&quot;,
                                  new Object [] {new Integer(frameNumber + 1),
                                                 meth.declaringType().name(),
                                                 meth.name(),
                                                 methodInfo,
                                                 new Long(pc)});
        } else {
            MessageOutput.println(&quot;stack frame dump&quot;,
                                  new Object [] {new Integer(frameNumber + 1),
                                                 meth.declaringType().name(),
                                                 meth.name(),
                                                 methodInfo});
        }
    }

    void commandWhere(StringTokenizer t, boolean showPC) {
        if (!t.hasMoreTokens()) {
            ThreadInfo threadInfo = ThreadInfo.getCurrentThreadInfo();
            if (threadInfo == null) {
                MessageOutput.println(&quot;No thread specified.&quot;);
                return;
            }
            dumpStack(threadInfo, showPC);
        } else {
            String token = t.nextToken();
            if (token.toLowerCase().equals(&quot;all&quot;)) {
                for (ThreadInfo threadInfo : ThreadInfo.threads()) {
                    MessageOutput.println(&quot;Thread:&quot;,
                                          threadInfo.getThread().name());
                    dumpStack(threadInfo, showPC);
                }
            } else {
                ThreadInfo threadInfo = doGetThread(token);
                if (threadInfo != null) {
                    ThreadInfo.setCurrentThreadInfo(threadInfo);
                    dumpStack(threadInfo, showPC);
                }
            }
        }
    }

    void commandInterrupt(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            ThreadInfo threadInfo = ThreadInfo.getCurrentThreadInfo();
            if (threadInfo == null) {
                MessageOutput.println(&quot;No thread specified.&quot;);
                return;
            }
            threadInfo.getThread().interrupt();
        } else {
            ThreadInfo threadInfo = doGetThread(t.nextToken());
            if (threadInfo != null) {
                threadInfo.getThread().interrupt();
            }
        }
    }

    void commandMemory() {
        MessageOutput.println(&quot;The memory command is no longer supported.&quot;);
    }

    void commandGC() {
        MessageOutput.println(&quot;The gc command is no longer necessary.&quot;);
    }

    /*
     * The next two methods are used by this class and by EventHandler
     * to print consistent locations and error messages.
     */
    static String locationString(Location loc) {
        return MessageOutput.format(&quot;locationString&quot;,
                                    new Object [] {loc.declaringType().name(),
                                                   loc.method().name(),
                                                   new Integer (loc.lineNumber()),
                                                   new Long (loc.codeIndex())});
    }

    void listBreakpoints() {
        boolean noBreakpoints = true;

        // Print set breakpoints
        for (EventRequestSpec spec : Env.specList.eventRequestSpecs()) {
            if (spec instanceof BreakpointSpec) {
                if (noBreakpoints) {
                    noBreakpoints = false;
                    MessageOutput.println(&quot;Breakpoints set:&quot;);
                }
                MessageOutput.println(&quot;tab&quot;, spec.toString());
            }
        }
        if (noBreakpoints) {
            MessageOutput.println(&quot;No breakpoints set.&quot;);
        }
    }


    private void printBreakpointCommandUsage(String atForm, String inForm) {
        MessageOutput.println(&quot;printbreakpointcommandusage&quot;,
                              new Object [] {atForm, inForm});
    }

    protected BreakpointSpec parseBreakpointSpec(StringTokenizer t,
                                             String atForm, String inForm) {
        BreakpointSpec breakpoint = null;
        try {
            String token = t.nextToken(&quot;:( \t\n\r&quot;);

            // We can't use hasMoreTokens here because it will cause any leading
            // paren to be lost.
            String rest;
            try {
                rest = t.nextToken(&quot;&quot;).trim();
            } catch (NoSuchElementException e) {
                rest = null;
            }

            if ((rest != null) &amp;&amp; rest.startsWith(&quot;:&quot;)) {
                t = new StringTokenizer(rest.substring(1));
                String classId = token;
                String lineToken = t.nextToken();

                NumberFormat nf = NumberFormat.getNumberInstance();
                nf.setParseIntegerOnly(true);
                Number n = nf.parse(lineToken);
                int lineNumber = n.intValue();

                if (t.hasMoreTokens()) {
                    printBreakpointCommandUsage(atForm, inForm);
                    return null;
                }
                try {
                    breakpoint = Env.specList.createBreakpoint(classId,
                                                               lineNumber);
                } catch (ClassNotFoundException exc) {
                    MessageOutput.println(&quot;is not a valid class name&quot;, classId);
                }
            } else {
                // Try stripping method from class.method token.
                int idot = token.lastIndexOf(&quot;.&quot;);
                if ( (idot &lt;= 0) ||                     /* No dot or dot in first char */
                     (idot &gt;= token.length() - 1) ) { /* dot in last char */
                    printBreakpointCommandUsage(atForm, inForm);
                    return null;
                }
                String methodName = token.substring(idot + 1);
                String classId = token.substring(0, idot);
                List&lt;String&gt; argumentList = null;
                if (rest != null) {
                    if (!rest.startsWith(&quot;(&quot;) || !rest.endsWith(&quot;)&quot;)) {
                        MessageOutput.println(&quot;Invalid method specification:&quot;,
                                              methodName + rest);
                        printBreakpointCommandUsage(atForm, inForm);
                        return null;
                    }
                    // Trim the parens
                    rest = rest.substring(1, rest.length() - 1);

                    argumentList = new ArrayList&lt;String&gt;();
                    t = new StringTokenizer(rest, &quot;,&quot;);
                    while (t.hasMoreTokens()) {
                        argumentList.add(t.nextToken());
                    }
                }
                try {
                    breakpoint = Env.specList.createBreakpoint(classId,
                                                               methodName,
                                                               argumentList);
                } catch (MalformedMemberNameException exc) {
                    MessageOutput.println(&quot;is not a valid method name&quot;, methodName);
                } catch (ClassNotFoundException exc) {
                    MessageOutput.println(&quot;is not a valid class name&quot;, classId);
                }
            }
        } catch (Exception e) {
            printBreakpointCommandUsage(atForm, inForm);
            return null;
        }
        return breakpoint;
    }

    private void resolveNow(EventRequestSpec spec) {
        boolean success = Env.specList.addEagerlyResolve(spec);
        if (success &amp;&amp; !spec.isResolved()) {
            MessageOutput.println(&quot;Deferring.&quot;, spec.toString());
        }
    }

    void commandStop(StringTokenizer t) {
        String atIn;
        byte suspendPolicy = EventRequest.SUSPEND_ALL;

        if (t.hasMoreTokens()) {
            atIn = t.nextToken();
            if (atIn.equals(&quot;go&quot;) &amp;&amp; t.hasMoreTokens()) {
                suspendPolicy = EventRequest.SUSPEND_NONE;
                atIn = t.nextToken();
            } else if (atIn.equals(&quot;thread&quot;) &amp;&amp; t.hasMoreTokens()) {
                suspendPolicy = EventRequest.SUSPEND_EVENT_THREAD;
                atIn = t.nextToken();
            }
        } else {
            listBreakpoints();
            return;
        }

        BreakpointSpec spec = parseBreakpointSpec(t, &quot;stop at&quot;, &quot;stop in&quot;);
        if (spec != null) {
            // Enforcement of &quot;at&quot; vs. &quot;in&quot;. The distinction is really
            // unnecessary and we should consider not checking for this
            // (and making &quot;at&quot; and &quot;in&quot; optional).
            if (atIn.equals(&quot;at&quot;) &amp;&amp; spec.isMethodBreakpoint()) {
                MessageOutput.println(&quot;Use stop at to set a breakpoint at a line number&quot;);
                printBreakpointCommandUsage(&quot;stop at&quot;, &quot;stop in&quot;);
                return;
            }
            spec.suspendPolicy = suspendPolicy;
            resolveNow(spec);
        }
    }

    void commandClear(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            listBreakpoints();
            return;
        }

        BreakpointSpec spec = parseBreakpointSpec(t, &quot;clear&quot;, &quot;clear&quot;);
        if (spec != null) {
            if (Env.specList.delete(spec)) {
                MessageOutput.println(&quot;Removed:&quot;, spec.toString());
            } else {
                MessageOutput.println(&quot;Not found:&quot;, spec.toString());
            }
        }
    }

    private List&lt;WatchpointSpec&gt; parseWatchpointSpec(StringTokenizer t) {
        List&lt;WatchpointSpec&gt; list = new ArrayList&lt;WatchpointSpec&gt;();
        boolean access = false;
        boolean modification = false;
        int suspendPolicy = EventRequest.SUSPEND_ALL;

        String fieldName = t.nextToken();
        if (fieldName.equals(&quot;go&quot;)) {
            suspendPolicy = EventRequest.SUSPEND_NONE;
            fieldName = t.nextToken();
        } else if (fieldName.equals(&quot;thread&quot;)) {
            suspendPolicy = EventRequest.SUSPEND_EVENT_THREAD;
            fieldName = t.nextToken();
        }
        if (fieldName.equals(&quot;access&quot;)) {
            access = true;
            fieldName = t.nextToken();
        } else if (fieldName.equals(&quot;all&quot;)) {
            access = true;
            modification = true;
            fieldName = t.nextToken();
        } else {
            modification = true;
        }
        int dot = fieldName.lastIndexOf('.');
        if (dot &lt; 0) {
            MessageOutput.println(&quot;Class containing field must be specified.&quot;);
            return list;
        }
        String className = fieldName.substring(0, dot);
        fieldName = fieldName.substring(dot+1);

        try {
            WatchpointSpec spec;
            if (access) {
                spec = Env.specList.createAccessWatchpoint(className,
                                                           fieldName);
                spec.suspendPolicy = suspendPolicy;
                list.add(spec);
            }
            if (modification) {
                spec = Env.specList.createModificationWatchpoint(className,
                                                                 fieldName);
                spec.suspendPolicy = suspendPolicy;
                list.add(spec);
            }
        } catch (MalformedMemberNameException exc) {
            MessageOutput.println(&quot;is not a valid field name&quot;, fieldName);
        } catch (ClassNotFoundException exc) {
            MessageOutput.println(&quot;is not a valid class name&quot;, className);
        }
        return list;
    }

    void commandWatch(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;Field to watch not specified&quot;);
            return;
        }

        for (WatchpointSpec spec : parseWatchpointSpec(t)) {
            resolveNow(spec);
        }
    }

    void commandUnwatch(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;Field to unwatch not specified&quot;);
            return;
        }

        for (WatchpointSpec spec : parseWatchpointSpec(t)) {
            if (Env.specList.delete(spec)) {
                MessageOutput.println(&quot;Removed:&quot;, spec.toString());
            } else {
                MessageOutput.println(&quot;Not found:&quot;, spec.toString());
            }
        }
    }

    void turnOnExitTrace(ThreadInfo threadInfo, int suspendPolicy) {
        EventRequestManager erm = Env.vm().eventRequestManager();
        MethodExitRequest exit = erm.createMethodExitRequest();
        if (threadInfo != null) {
            exit.addThreadFilter(threadInfo.getThread());
        }
        Env.addExcludes(exit);
        exit.setSuspendPolicy(suspendPolicy);
        exit.enable();

    }

    static String methodTraceCommand = null;

    void commandTrace(StringTokenizer t) {
        String modif;
        int suspendPolicy = EventRequest.SUSPEND_ALL;
        ThreadInfo threadInfo = null;
        String goStr = &quot; &quot;;

        /*
         * trace [go] methods [thread]
         * trace [go] method exit | exits [thread]
         */
        if (t.hasMoreTokens()) {
            modif = t.nextToken();
            if (modif.equals(&quot;go&quot;)) {
                suspendPolicy = EventRequest.SUSPEND_NONE;
                goStr = &quot; go &quot;;
                if (t.hasMoreTokens()) {
                    modif = t.nextToken();
                }
            } else if (modif.equals(&quot;thread&quot;)) {
                // this is undocumented as it doesn't work right.
                suspendPolicy = EventRequest.SUSPEND_EVENT_THREAD;
                if (t.hasMoreTokens()) {
                    modif = t.nextToken();
                }
            }

            if  (modif.equals(&quot;method&quot;)) {
                String traceCmd = null;

                if (t.hasMoreTokens()) {
                    String modif1 = t.nextToken();
                    if (modif1.equals(&quot;exits&quot;) || modif1.equals(&quot;exit&quot;)) {
                        if (t.hasMoreTokens()) {
                            threadInfo = doGetThread(t.nextToken());
                        }
                        if (modif1.equals(&quot;exit&quot;)) {
                            StackFrame frame;
                            try {
                                frame = ThreadInfo.getCurrentThreadInfo().getCurrentFrame();
                            } catch (IncompatibleThreadStateException ee) {
                                MessageOutput.println(&quot;Current thread isnt suspended.&quot;);
                                return;
                            }
                            Env.setAtExitMethod(frame.location().method());
                            traceCmd = MessageOutput.format(&quot;trace&quot; +
                                                    goStr + &quot;method exit &quot; +
                                                    &quot;in effect for&quot;,
                                                    Env.atExitMethod().toString());
                        } else {
                            traceCmd = MessageOutput.format(&quot;trace&quot; +
                                                   goStr + &quot;method exits &quot; +
                                                   &quot;in effect&quot;);
                        }
                        commandUntrace(new StringTokenizer(&quot;methods&quot;));
                        turnOnExitTrace(threadInfo, suspendPolicy);
                        methodTraceCommand = traceCmd;
                        return;
                    }
                } else {
                   MessageOutput.println(&quot;Can only trace&quot;);
                   return;
                }
            }
            if (modif.equals(&quot;methods&quot;)) {
                // Turn on method entry trace
                MethodEntryRequest entry;
                EventRequestManager erm = Env.vm().eventRequestManager();
                if (t.hasMoreTokens()) {
                    threadInfo = doGetThread(t.nextToken());
                }
                if (threadInfo != null) {
                    /*
                     * To keep things simple we want each 'trace' to cancel
                     * previous traces.  However in this case, we don't do that
                     * to preserve backward compatibility with pre JDK 6.0.
                     * IE, you can currently do
                     *   trace   methods 0x21
                     *   trace   methods 0x22
                     * and you will get xxx traced just on those two threads
                     * But this feature is kind of broken because if you then do
                     *   untrace  0x21
                     * it turns off both traces instead of just the one.
                     * Another bogosity is that if you do
                     *   trace methods
                     *   trace methods
                     * and you will get two traces.
                     */

                    entry = erm.createMethodEntryRequest();
                    entry.addThreadFilter(threadInfo.getThread());
                } else {
                    commandUntrace(new StringTokenizer(&quot;methods&quot;));
                    entry = erm.createMethodEntryRequest();
                }
                Env.addExcludes(entry);
                entry.setSuspendPolicy(suspendPolicy);
                entry.enable();
                turnOnExitTrace(threadInfo, suspendPolicy);
                methodTraceCommand = MessageOutput.format(&quot;trace&quot; + goStr +
                                                          &quot;methods in effect&quot;);

                return;
            }

            MessageOutput.println(&quot;Can only trace&quot;);
            return;
        }

        // trace all by itself.
        if (methodTraceCommand != null) {
            MessageOutput.printDirectln(methodTraceCommand);
        }

        // More trace lines can be added here.
    }

    void commandUntrace(StringTokenizer t) {
        // untrace
        // untrace methods

        String modif = null;
        EventRequestManager erm = Env.vm().eventRequestManager();
        if (t.hasMoreTokens()) {
            modif = t.nextToken();
        }
        if (modif == null || modif.equals(&quot;methods&quot;)) {
            erm.deleteEventRequests(erm.methodEntryRequests());
            erm.deleteEventRequests(erm.methodExitRequests());
            Env.setAtExitMethod(null);
            methodTraceCommand = null;
        }
    }

    void commandList(StringTokenizer t) {
        StackFrame frame = null;
        ThreadInfo threadInfo = ThreadInfo.getCurrentThreadInfo();
        if (threadInfo == null) {
            MessageOutput.println(&quot;No thread specified.&quot;);
            return;
        }
        try {
            frame = threadInfo.getCurrentFrame();
        } catch (IncompatibleThreadStateException e) {
            MessageOutput.println(&quot;Current thread isnt suspended.&quot;);
            return;
        }

        if (frame == null) {
            MessageOutput.println(&quot;No frames on the current call stack&quot;);
            return;
        }

        Location loc = frame.location();
        if (loc.method().isNative()) {
            MessageOutput.println(&quot;Current method is native&quot;);
            return;
        }

        String sourceFileName = null;
        try {
            sourceFileName = loc.sourceName();

            ReferenceType refType = loc.declaringType();
            int lineno = loc.lineNumber();

            if (t.hasMoreTokens()) {
                String id = t.nextToken();

                // See if token is a line number.
                try {
                    NumberFormat nf = NumberFormat.getNumberInstance();
                    nf.setParseIntegerOnly(true);
                    Number n = nf.parse(id);
                    lineno = n.intValue();
                } catch (java.text.ParseException jtpe) {
                    // It isn't -- see if it's a method name.
                        List&lt;Method&gt; meths = refType.methodsByName(id);
                        if (meths == null || meths.size() == 0) {
                            MessageOutput.println(&quot;is not a valid line number or method name for&quot;,
                                                  new Object [] {id, refType.name()});
                            return;
                        } else if (meths.size() &gt; 1) {
                            MessageOutput.println(&quot;is an ambiguous method name in&quot;,
                                                  new Object [] {id, refType.name()});
                            return;
                        }
                        loc = meths.get(0).location();
                        lineno = loc.lineNumber();
                }
            }
            int startLine = Math.max(lineno - 4, 1);
            int endLine = startLine + 9;
            if (lineno &lt; 0) {
                MessageOutput.println(&quot;Line number information not available for&quot;);
            } else if (Env.sourceLine(loc, lineno) == null) {
                MessageOutput.println(&quot;is an invalid line number for&quot;,
                                      new Object [] {new Integer (lineno),
                                                     refType.name()});
            } else {
                for (int i = startLine; i &lt;= endLine; i++) {
                    String sourceLine = Env.sourceLine(loc, i);
                    if (sourceLine == null) {
                        break;
                    }
                    if (i == lineno) {
                        MessageOutput.println(&quot;source line number current line and line&quot;,
                                              new Object [] {new Integer (i),
                                                             sourceLine});
                    } else {
                        MessageOutput.println(&quot;source line number and line&quot;,
                                              new Object [] {new Integer (i),
                                                             sourceLine});
                    }
                }
            }
        } catch (AbsentInformationException e) {
            MessageOutput.println(&quot;No source information available for:&quot;, loc.toString());
        } catch(FileNotFoundException exc) {
            MessageOutput.println(&quot;Source file not found:&quot;, sourceFileName);
        } catch(IOException exc) {
            MessageOutput.println(&quot;I/O exception occurred:&quot;, exc.toString());
        }
    }

    void commandLines(StringTokenizer t) { // Undocumented command: useful for testing
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;Specify class and method&quot;);
        } else {
            String idClass = t.nextToken();
            String idMethod = t.hasMoreTokens() ? t.nextToken() : null;
            try {
                ReferenceType refType = Env.getReferenceTypeFromToken(idClass);
                if (refType != null) {
                    List&lt;Location&gt; lines = null;
                    if (idMethod == null) {
                        lines = refType.allLineLocations();
                    } else {
                        for (Method method : refType.allMethods()) {
                            if (method.name().equals(idMethod)) {
                                lines = method.allLineLocations();
                            }
                        }
                        if (lines == null) {
                            MessageOutput.println(&quot;is not a valid method name&quot;, idMethod);
                        }
                    }
                    for (Location line : lines) {
                        MessageOutput.printDirectln(line.toString());// Special case: use printDirectln()
                    }
                } else {
                    MessageOutput.println(&quot;is not a valid id or class name&quot;, idClass);
                }
            } catch (AbsentInformationException e) {
                MessageOutput.println(&quot;Line number information not available for&quot;, idClass);
            }
        }
    }

    void commandClasspath(StringTokenizer t) {
        if (Env.vm() instanceof PathSearchingVirtualMachine) {
            PathSearchingVirtualMachine vm = (PathSearchingVirtualMachine)Env.vm();
            MessageOutput.println(&quot;base directory:&quot;, vm.baseDirectory());
            MessageOutput.println(&quot;classpath:&quot;, vm.classPath().toString());
            MessageOutput.println(&quot;bootclasspath:&quot;, vm.bootClassPath().toString());
        } else {
            MessageOutput.println(&quot;The VM does not use paths&quot;);
        }
    }

    /* Get or set the source file path list. */
    void commandUse(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            MessageOutput.printDirectln(Env.getSourcePath());// Special case: use printDirectln()
        } else {
            /*
             * Take the remainder of the command line, minus
             * leading or trailing whitespace.  Embedded
             * whitespace is fine.
             */
            Env.setSourcePath(t.nextToken(&quot;&quot;).trim());
        }
    }

    /* Print a stack variable */
    private void printVar(LocalVariable var, Value value) {
        MessageOutput.println(&quot;expr is value&quot;,
                              new Object [] {var.name(),
                                             value == null ? &quot;null&quot; : value.toString()});
    }

    /* Print all local variables in current stack frame. */
    void commandLocals() {
        StackFrame frame;
        ThreadInfo threadInfo = ThreadInfo.getCurrentThreadInfo();
        if (threadInfo == null) {
            MessageOutput.println(&quot;No default thread specified:&quot;);
            return;
        }
        try {
            frame = threadInfo.getCurrentFrame();
            if (frame == null) {
                throw new AbsentInformationException();
            }
            List&lt;LocalVariable&gt; vars = frame.visibleVariables();

            if (vars.size() == 0) {
                MessageOutput.println(&quot;No local variables&quot;);
                return;
            }
            Map&lt;LocalVariable, Value&gt; values = frame.getValues(vars);

            MessageOutput.println(&quot;Method arguments:&quot;);
            for (LocalVariable var : vars) {
                if (var.isArgument()) {
                    Value val = values.get(var);
                    printVar(var, val);
                }
            }
            MessageOutput.println(&quot;Local variables:&quot;);
            for (LocalVariable var : vars) {
                if (!var.isArgument()) {
                    Value val = values.get(var);
                    printVar(var, val);
                }
            }
        } catch (AbsentInformationException aie) {
            MessageOutput.println(&quot;Local variable information not available.&quot;);
        } catch (IncompatibleThreadStateException exc) {
            MessageOutput.println(&quot;Current thread isnt suspended.&quot;);
        }
    }

    private void dump(ObjectReference obj, ReferenceType refType,
                      ReferenceType refTypeBase) {
        for (Field field : refType.fields()) {
            StringBuffer o = new StringBuffer();
            o.append(&quot;    &quot;);
            if (!refType.equals(refTypeBase)) {
                o.append(refType.name());
                o.append(&quot;.&quot;);
            }
            o.append(field.name());
            o.append(MessageOutput.format(&quot;colon space&quot;));
            o.append(obj.getValue(field));
            MessageOutput.printDirectln(o.toString()); // Special case: use printDirectln()
        }
        if (refType instanceof ClassType) {
            ClassType sup = ((ClassType)refType).superclass();
            if (sup != null) {
                dump(obj, sup, refTypeBase);
            }
        } else if (refType instanceof InterfaceType) {
            for (InterfaceType sup : ((InterfaceType)refType).superinterfaces()) {
                dump(obj, sup, refTypeBase);
            }
        } else {
            /* else refType is an instanceof ArrayType */
            if (obj instanceof ArrayReference) {
                for (Iterator&lt;Value&gt; it = ((ArrayReference)obj).getValues().iterator();
                     it.hasNext(); ) {
                    MessageOutput.printDirect(it.next().toString());// Special case: use printDirect()
                    if (it.hasNext()) {
                        MessageOutput.printDirect(&quot;, &quot;);// Special case: use printDirect()
                    }
                }
                MessageOutput.println();
            }
        }
    }

    /* Print a specified reference.
     */
    void doPrint(StringTokenizer t, boolean dumpObject) {
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;No objects specified.&quot;);
            return;
        }

        while (t.hasMoreTokens()) {
            String expr = t.nextToken(&quot;&quot;);
            Value val = evaluate(expr);
            if (val == null) {
                MessageOutput.println(&quot;expr is null&quot;, expr.toString());
            } else if (dumpObject &amp;&amp; (val instanceof ObjectReference) &amp;&amp;
                       !(val instanceof StringReference)) {
                ObjectReference obj = (ObjectReference)val;
                ReferenceType refType = obj.referenceType();
                MessageOutput.println(&quot;expr is value&quot;,
                                      new Object [] {expr.toString(),
                                                     MessageOutput.format(&quot;grouping begin character&quot;)});
                dump(obj, refType, refType);
                MessageOutput.println(&quot;grouping end character&quot;);
            } else {
                  String strVal = getStringValue();
                  if (strVal != null) {
                     MessageOutput.println(&quot;expr is value&quot;, new Object [] {expr.toString(),
                                                                      strVal});
                   }
            }
        }
    }

    void commandPrint(final StringTokenizer t, final boolean dumpObject) {
        new AsyncExecution() {
                @Override
                void action() {
                    doPrint(t, dumpObject);
                }
            };
    }

    void commandSet(final StringTokenizer t) {
        String all = t.nextToken(&quot;&quot;);

        /*
         * Bare bones error checking.
         */
        if (all.indexOf('=') == -1) {
            MessageOutput.println(&quot;Invalid assignment syntax&quot;);
            MessageOutput.printPrompt();
            return;
        }

        /*
         * The set command is really just syntactic sugar. Pass it on to the
         * print command.
         */
        commandPrint(new StringTokenizer(all), false);
    }

    void doLock(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;No object specified.&quot;);
            return;
        }

        String expr = t.nextToken(&quot;&quot;);
        Value val = evaluate(expr);

        try {
            if ((val != null) &amp;&amp; (val instanceof ObjectReference)) {
                ObjectReference object = (ObjectReference)val;
                String strVal = getStringValue();
                if (strVal != null) {
                    MessageOutput.println(&quot;Monitor information for expr&quot;,
                                      new Object [] {expr.trim(),
                                                     strVal});
                }
                ThreadReference owner = object.owningThread();
                if (owner == null) {
                    MessageOutput.println(&quot;Not owned&quot;);
                } else {
                    MessageOutput.println(&quot;Owned by:&quot;,
                                          new Object [] {owner.name(),
                                                         new Integer (object.entryCount())});
                }
                List&lt;ThreadReference&gt; waiters = object.waitingThreads();
                if (waiters.size() == 0) {
                    MessageOutput.println(&quot;No waiters&quot;);
                } else {
                    for (ThreadReference waiter : waiters) {
                        MessageOutput.println(&quot;Waiting thread:&quot;, waiter.name());
                    }
                }
            } else {
                MessageOutput.println(&quot;Expression must evaluate to an object&quot;);
            }
        } catch (IncompatibleThreadStateException e) {
            MessageOutput.println(&quot;Threads must be suspended&quot;);
        }
    }

    void commandLock(final StringTokenizer t) {
        new AsyncExecution() {
                @Override
                void action() {
                    doLock(t);
                }
            };
    }

    private void printThreadLockInfo(ThreadInfo threadInfo) {
        ThreadReference thread = threadInfo.getThread();
        try {
            MessageOutput.println(&quot;Monitor information for thread&quot;, thread.name());
            List&lt;ObjectReference&gt; owned = thread.ownedMonitors();
            if (owned.size() == 0) {
                MessageOutput.println(&quot;No monitors owned&quot;);
            } else {
                for (ObjectReference monitor : owned) {
                    MessageOutput.println(&quot;Owned monitor:&quot;, monitor.toString());
                }
            }
            ObjectReference waiting = thread.currentContendedMonitor();
            if (waiting == null) {
                MessageOutput.println(&quot;Not waiting for a monitor&quot;);
            } else {
                MessageOutput.println(&quot;Waiting for monitor:&quot;, waiting.toString());
            }
        } catch (IncompatibleThreadStateException e) {
            MessageOutput.println(&quot;Threads must be suspended&quot;);
        }
    }

    void commandThreadlocks(final StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            ThreadInfo threadInfo = ThreadInfo.getCurrentThreadInfo();
            if (threadInfo == null) {
                MessageOutput.println(&quot;Current thread not set.&quot;);
            } else {
                printThreadLockInfo(threadInfo);
            }
            return;
        }
        String token = t.nextToken();
        if (token.toLowerCase().equals(&quot;all&quot;)) {
            for (ThreadInfo threadInfo : ThreadInfo.threads()) {
                printThreadLockInfo(threadInfo);
            }
        } else {
            ThreadInfo threadInfo = doGetThread(token);
            if (threadInfo != null) {
                ThreadInfo.setCurrentThreadInfo(threadInfo);
                printThreadLockInfo(threadInfo);
            }
        }
    }

    void doDisableGC(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;No object specified.&quot;);
            return;
        }

        String expr = t.nextToken(&quot;&quot;);
        Value val = evaluate(expr);
        if ((val != null) &amp;&amp; (val instanceof ObjectReference)) {
            ObjectReference object = (ObjectReference)val;
            object.disableCollection();
            String strVal = getStringValue();
            if (strVal != null) {
                 MessageOutput.println(&quot;GC Disabled for&quot;, strVal);
            }
        } else {
            MessageOutput.println(&quot;Expression must evaluate to an object&quot;);
        }
    }

    void commandDisableGC(final StringTokenizer t) {
        new AsyncExecution() {
                @Override
                void action() {
                    doDisableGC(t);
                }
            };
    }

    void doEnableGC(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;No object specified.&quot;);
            return;
        }

        String expr = t.nextToken(&quot;&quot;);
        Value val = evaluate(expr);
        if ((val != null) &amp;&amp; (val instanceof ObjectReference)) {
            ObjectReference object = (ObjectReference)val;
            object.enableCollection();
            String strVal = getStringValue();
            if (strVal != null) {
                 MessageOutput.println(&quot;GC Enabled for&quot;, strVal);
            }
        } else {
            MessageOutput.println(&quot;Expression must evaluate to an object&quot;);
        }
    }

    void commandEnableGC(final StringTokenizer t) {
        new AsyncExecution() {
                @Override
                void action() {
                    doEnableGC(t);
                }
            };
    }

    void doSave(StringTokenizer t) {// Undocumented command: useful for testing.
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;No save index specified.&quot;);
            return;
        }

        String key = t.nextToken();

        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;No expression specified.&quot;);
            return;
        }
        String expr = t.nextToken(&quot;&quot;);
        Value val = evaluate(expr);
        if (val != null) {
            Env.setSavedValue(key, val);
            String strVal = getStringValue();
            if (strVal != null) {
                 MessageOutput.println(&quot;saved&quot;, strVal);
            }
        } else {
            MessageOutput.println(&quot;Expression cannot be void&quot;);
        }
    }

    void commandSave(final StringTokenizer t) { // Undocumented command: useful for testing.
        if (!t.hasMoreTokens()) {
            Set&lt;String&gt; keys = Env.getSaveKeys();
            if (keys.isEmpty()) {
                MessageOutput.println(&quot;No saved values&quot;);
                return;
            }
            for (String key : keys) {
                Value value = Env.getSavedValue(key);
                if ((value instanceof ObjectReference) &amp;&amp;
                    ((ObjectReference)value).isCollected()) {
                    MessageOutput.println(&quot;expr is value &lt;collected&gt;&quot;,
                                          new Object [] {key, value.toString()});
                } else {
                    if (value == null){
                        MessageOutput.println(&quot;expr is null&quot;, key);
                    } else {
                        MessageOutput.println(&quot;expr is value&quot;,
                                              new Object [] {key, value.toString()});
                    }
                }
            }
        } else {
            new AsyncExecution() {
                    @Override
                    void action() {
                        doSave(t);
                    }
                };
        }

    }

   void commandBytecodes(final StringTokenizer t) { // Undocumented command: useful for testing.
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;No class specified.&quot;);
            return;
        }
        String className = t.nextToken();

        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;No method specified.&quot;);
            return;
        }
        // Overloading is not handled here.
        String methodName = t.nextToken();

        List&lt;ReferenceType&gt; classes = Env.vm().classesByName(className);
        // TO DO: handle multiple classes found
        if (classes.size() == 0) {
            if (className.indexOf('.') &lt; 0) {
                MessageOutput.println(&quot;not found (try the full name)&quot;, className);
            } else {
                MessageOutput.println(&quot;not found&quot;, className);
            }
            return;
        }

        ReferenceType rt = classes.get(0);
        if (!(rt instanceof ClassType)) {
            MessageOutput.println(&quot;not a class&quot;, className);
            return;
        }

        byte[] bytecodes = null;
        for (Method method : rt.methodsByName(methodName)) {
            if (!method.isAbstract()) {
                bytecodes = method.bytecodes();
                break;
            }
        }

        StringBuffer line = new StringBuffer(80);
        line.append(&quot;0000: &quot;);
        for (int i = 0; i &lt; bytecodes.length; i++) {
            if ((i &gt; 0) &amp;&amp; (i % 16 == 0)) {
                MessageOutput.printDirectln(line.toString());// Special case: use printDirectln()
                line.setLength(0);
                line.append(String.valueOf(i));
                line.append(&quot;: &quot;);
                int len = line.length();
                for (int j = 0; j &lt; 6 - len; j++) {
                    line.insert(0, '0');
                }
            }
            int val = 0xff &amp; bytecodes[i];
            String str = Integer.toHexString(val);
            if (str.length() == 1) {
                line.append('0');
            }
            line.append(str);
            line.append(' ');
        }
        if (line.length() &gt; 6) {
            MessageOutput.printDirectln(line.toString());// Special case: use printDirectln()
        }
    }

    void commandExclude(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            MessageOutput.printDirectln(Env.excludesString());// Special case: use printDirectln()
        } else {
            String rest = t.nextToken(&quot;&quot;);
            if (rest.equals(&quot;none&quot;)) {
                rest = &quot;&quot;;
            }
            Env.setExcludes(rest);
        }
    }

    void commandRedefine(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;Specify classes to redefine&quot;);
        } else {
            String className = t.nextToken();
            List&lt;ReferenceType&gt; classes = Env.vm().classesByName(className);
            if (classes.size() == 0) {
                MessageOutput.println(&quot;No class named&quot;, className);
                return;
            }
            if (classes.size() &gt; 1) {
                MessageOutput.println(&quot;More than one class named&quot;, className);
                return;
            }
            Env.setSourcePath(Env.getSourcePath());
            ReferenceType refType = classes.get(0);
            if (!t.hasMoreTokens()) {
                MessageOutput.println(&quot;Specify file name for class&quot;, className);
                return;
            }
            String fileName = t.nextToken();
            File phyl = new File(fileName);
            byte[] bytes = new byte[(int)phyl.length()];
            try {
                InputStream in = new FileInputStream(phyl);
                in.read(bytes);
                in.close();
            } catch (Exception exc) {
                MessageOutput.println(&quot;Error reading file&quot;,
                             new Object [] {fileName, exc.toString()});
                return;
            }
            Map&lt;ReferenceType, byte[]&gt; map
                = new HashMap&lt;ReferenceType, byte[]&gt;();
            map.put(refType, bytes);
            try {
                Env.vm().redefineClasses(map);
            } catch (Throwable exc) {
                MessageOutput.println(&quot;Error redefining class to file&quot;,
                             new Object [] {className,
                                            fileName,
                                            exc});
            }
        }
    }

    void commandPopFrames(StringTokenizer t, boolean reenter) {
        ThreadInfo threadInfo;

        if (t.hasMoreTokens()) {
            String token = t.nextToken();
            threadInfo = doGetThread(token);
            if (threadInfo == null) {
                return;
            }
        } else {
            threadInfo = ThreadInfo.getCurrentThreadInfo();
            if (threadInfo == null) {
                MessageOutput.println(&quot;No thread specified.&quot;);
                return;
            }
        }

        try {
            StackFrame frame = threadInfo.getCurrentFrame();
            threadInfo.getThread().popFrames(frame);
            threadInfo = ThreadInfo.getCurrentThreadInfo();
            ThreadInfo.setCurrentThreadInfo(threadInfo);
            if (reenter) {
                commandStepi();
            }
        } catch (Throwable exc) {
            MessageOutput.println(&quot;Error popping frame&quot;, exc.toString());
        }
    }

    void commandExtension(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            MessageOutput.println(&quot;No class specified.&quot;);
            return;
        }

        String idClass = t.nextToken();
        ReferenceType cls = Env.getReferenceTypeFromToken(idClass);
        String extension = null;
        if (cls != null) {
            try {
                extension = cls.sourceDebugExtension();
                MessageOutput.println(&quot;sourcedebugextension&quot;, extension);
            } catch (AbsentInformationException e) {
                MessageOutput.println(&quot;No sourcedebugextension specified&quot;);
            }
        } else {
            MessageOutput.println(&quot;is not a valid id or class name&quot;, idClass);
        }
    }

    void commandVersion(String debuggerName,
                        VirtualMachineManager vmm) {
        MessageOutput.println(&quot;minus version&quot;,
                              new Object [] { debuggerName,
                                              new Integer(vmm.majorInterfaceVersion()),
                                              new Integer(vmm.minorInterfaceVersion()),
                                                  System.getProperty(&quot;java.version&quot;)});
        if (Env.connection() != null) {
            try {
                MessageOutput.printDirectln(Env.vm().description());// Special case: use printDirectln()
            } catch (VMNotConnectedException e) {
                MessageOutput.println(&quot;No VM connected&quot;);
            }
        }
    }
}
</pre>
</body>
</html>
