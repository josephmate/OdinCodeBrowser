<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1998, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This source code is provided to illustrate the usage of a given feature
 * or technique and has been deliberately simplified. Additional steps
 * required for a production-quality application, such as security checks,
 * input validation and proper error handling, might not be present in
 * this sample code.
 */


package com.sun.tools.example.debug.gui;

import java.io.*;
import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;

import com.sun.jdi.*;
import com.sun.tools.example.debug.bdi.*;

public class GUI extends JPanel {

    private static final long serialVersionUID = 3292463234530679091L;
    private CommandTool cmdTool;
    private ApplicationTool appTool;
    //###HACK##
    //### There is currently dirty code in Environment that
    //### accesses this directly.
    //private SourceTool srcTool;
    public static SourceTool srcTool;

    private SourceTreeTool sourceTreeTool;
    private ClassTreeTool classTreeTool;
    private ThreadTreeTool threadTreeTool;
    private StackTraceTool stackTool;
    private MonitorTool monitorTool;

    public static final String progname = &quot;javadt&quot;;
    public static final String version = &quot;1.0Beta&quot;;  //### FIX ME.
    public static final String windowBanner = &quot;Java(tm) platform Debug Tool&quot;;

    private Font fixedFont = new Font(&quot;monospaced&quot;, Font.PLAIN, 10);

    private GUI(Environment env) {
        setLayout(new BorderLayout());

        setBorder(new EmptyBorder(5, 5, 5, 5));

        add(new JDBToolBar(env), BorderLayout.NORTH);

        srcTool = new SourceTool(env);
        srcTool.setPreferredSize(new java.awt.Dimension(500, 300));
        srcTool.setTextFont(fixedFont);

        stackTool = new StackTraceTool(env);
        stackTool.setPreferredSize(new java.awt.Dimension(500, 100));

        monitorTool = new MonitorTool(env);
        monitorTool.setPreferredSize(new java.awt.Dimension(500, 50));

        JSplitPane right = new JSplitPane(JSplitPane.VERTICAL_SPLIT, srcTool,
            new JSplitPane(JSplitPane.VERTICAL_SPLIT, stackTool, monitorTool));

        sourceTreeTool = new SourceTreeTool(env);
        sourceTreeTool.setPreferredSize(new java.awt.Dimension(200, 450));

        classTreeTool = new ClassTreeTool(env);
        classTreeTool.setPreferredSize(new java.awt.Dimension(200, 450));

        threadTreeTool = new ThreadTreeTool(env);
        threadTreeTool.setPreferredSize(new java.awt.Dimension(200, 450));

        JTabbedPane treePane = new JTabbedPane(SwingConstants.BOTTOM);
        treePane.addTab(&quot;Source&quot;, null, sourceTreeTool);
        treePane.addTab(&quot;Classes&quot;, null, classTreeTool);
        treePane.addTab(&quot;Threads&quot;, null, threadTreeTool);

        JSplitPane centerTop = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, treePane, right);

        cmdTool = new CommandTool(env);
        cmdTool.setPreferredSize(new java.awt.Dimension(700, 150));

        appTool = new ApplicationTool(env);
        appTool.setPreferredSize(new java.awt.Dimension(700, 200));

        JSplitPane centerBottom = new JSplitPane(JSplitPane.VERTICAL_SPLIT, cmdTool, appTool);
        //        centerBottom.setPreferredSize(new java.awt.Dimension(700, 350));

        JSplitPane center = new JSplitPane(JSplitPane.VERTICAL_SPLIT, centerTop, centerBottom);

        add(center, BorderLayout.CENTER);


    }

    private static void usage() {
        String separator = File.pathSeparator;
        System.out.println(&quot;Usage: &quot; + progname + &quot; &lt;options&gt; &lt;class&gt; &lt;arguments&gt;&quot;);
        System.out.println();
        System.out.println(&quot;where options include:&quot;);
        System.out.println(&quot;    -help             print out this message and exit&quot;);
        System.out.println(&quot;    -sourcepath &lt;directories separated by \&quot;&quot; +
                           separator + &quot;\&quot;&gt;&quot;);
        System.out.println(&quot;                      list directories in which to look for source files&quot;);
        System.out.println(&quot;    -remote &lt;hostname&gt;:&lt;port-number&gt;&quot;);
        System.out.println(&quot;                      host machine and port number of interpreter to attach to&quot;);
        System.out.println(&quot;    -dbgtrace [flags] print info for debugging &quot; + progname);
        System.out.println();
        System.out.println(&quot;options forwarded to debuggee process:&quot;);
        System.out.println(&quot;    -v -verbose[:class|gc|jni]&quot;);
        System.out.println(&quot;                      turn on verbose mode&quot;);
        System.out.println(&quot;    -D&lt;name&gt;=&lt;value&gt;  set a system property&quot;);
        System.out.println(&quot;    -classpath &lt;directories separated by \&quot;&quot; +
                           separator + &quot;\&quot;&gt;&quot;);
        System.out.println(&quot;                      list directories in which to look for classes&quot;);
        System.out.println(&quot;    -X&lt;option&gt;        non-standard debuggee VM option&quot;);
        System.out.println();
        System.out.println(&quot;&lt;class&gt; is the name of the class to begin debugging&quot;);
        System.out.println(&quot;&lt;arguments&gt; are the arguments passed to the main() method of &lt;class&gt;&quot;);
        System.out.println();
        System.out.println(&quot;For command help type 'help' at &quot; + progname + &quot; prompt&quot;);
    }

    public static void main(String argv[]) {
        String clsName = &quot;&quot;;
        String progArgs = &quot;&quot;;
        String javaArgs = &quot;&quot;;
        final Environment env = new Environment();

        JPanel mainPanel = new GUI(env);

        ContextManager context = env.getContextManager();
        ExecutionManager runtime = env.getExecutionManager();

        for (int i = 0; i &lt; argv.length; i++) {
            String token = argv[i];
            if (token.equals(&quot;-dbgtrace&quot;)) {
            if ((i == argv.length - 1) ||
                ! Character.isDigit(argv[i+1].charAt(0))) {
                runtime.setTraceMode(VirtualMachine.TRACE_ALL);
            } else {
                String flagStr = argv[++i];
                runtime.setTraceMode(Integer.decode(flagStr).intValue());
            }
        } else if (token.equals(&quot;-X&quot;)) {
                System.out.println(
                       &quot;Use 'java -X' to see the available non-standard options&quot;);
                System.out.println();
                usage();
                System.exit(1);
            } else if (
                   // Standard VM options passed on
                   token.equals(&quot;-v&quot;) || token.startsWith(&quot;-v:&quot;) ||  // -v[:...]
                   token.startsWith(&quot;-verbose&quot;) ||                  // -verbose[:...]
                   token.startsWith(&quot;-D&quot;) ||
                   // NonStandard options passed on
                   token.startsWith(&quot;-X&quot;) ||
                   // Old-style options
                   // (These should remain in place as long as the standard VM accepts them)
                   token.equals(&quot;-noasyncgc&quot;) || token.equals(&quot;-prof&quot;) ||
                   token.equals(&quot;-verify&quot;) || token.equals(&quot;-noverify&quot;) ||
                   token.equals(&quot;-verifyremote&quot;) ||
                   token.equals(&quot;-verbosegc&quot;) ||
                   token.startsWith(&quot;-ms&quot;) || token.startsWith(&quot;-mx&quot;) ||
                   token.startsWith(&quot;-ss&quot;) || token.startsWith(&quot;-oss&quot;) ) {
                javaArgs += token + &quot; &quot;;
            } else if (token.equals(&quot;-sourcepath&quot;)) {
                if (i == (argv.length - 1)) {
                    System.out.println(&quot;No sourcepath specified.&quot;);
                    usage();
                    System.exit(1);
                }
                env.getSourceManager().setSourcePath(new SearchPath(argv[++i]));
            } else if (token.equals(&quot;-classpath&quot;)) {
                if (i == (argv.length - 1)) {
                    System.out.println(&quot;No classpath specified.&quot;);
                    usage();
                    System.exit(1);
                }
                env.getClassManager().setClassPath(new SearchPath(argv[++i]));
            } else if (token.equals(&quot;-remote&quot;)) {
                if (i == (argv.length - 1)) {
                    System.out.println(&quot;No remote specified.&quot;);
                    usage();
                    System.exit(1);
                }
                env.getContextManager().setRemotePort(argv[++i]);
            } else if (token.equals(&quot;-help&quot;)) {
                usage();
                System.exit(0);
            } else if (token.equals(&quot;-version&quot;)) {
                System.out.println(progname + &quot; version &quot; + version);
                System.exit(0);
            } else if (token.startsWith(&quot;-&quot;)) {
                System.out.println(&quot;invalid option: &quot; + token);
                usage();
                System.exit(1);
            } else {
                // Everything from here is part of the command line
                clsName = token;
                for (i++; i &lt; argv.length; i++) {
                    progArgs += argv[i] + &quot; &quot;;
                }
                break;
            }
        }

        context.setMainClassName(clsName);
        context.setProgramArguments(progArgs);
        context.setVmArguments(javaArgs);

        // Force Cross Platform L&amp;F
        try {
            UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());
            // If you want the System L&amp;F instead, comment out the above line and
            // uncomment the following:
            // UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (Exception exc) {
            System.err.println(&quot;Error loading L&amp;F: &quot; + exc);
        }

        JFrame frame = new JFrame();
        frame.setBackground(Color.lightGray);
        frame.setTitle(windowBanner);
        frame.setJMenuBar(new JDBMenuBar(env));
        frame.setContentPane(mainPanel);

        frame.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                env.terminate();
            }
        });

        frame.pack();
        frame.setVisible(true);

    }

}
</pre>
</body>
</html>
