<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This source code is provided to illustrate the usage of a given feature
 * or technique and has been deliberately simplified. Additional steps
 * required for a production-quality application, such as security checks,
 * input validation and proper error handling, might not be present in
 * this sample code.
 */


package com.sun.tools.example.debug.gui;

import java.io.*;
import java.util.*;

import com.sun.jdi.*;
import com.sun.tools.example.debug.bdi.*;

public class CommandInterpreter {

    boolean echo;

    Environment env;

    private ContextManager context;
    private ExecutionManager runtime;
    private ClassManager classManager;
    private SourceManager sourceManager;

    private OutputSink out; //### Hack!  Should be local in each method used.
    private String lastCommand = &quot;help&quot;;

    public CommandInterpreter(Environment env) {
        this(env, true);
    }

    public CommandInterpreter(Environment env, boolean echo) {
        this.env = env;
        this.echo = echo;
        this.runtime = env.getExecutionManager();
        this.context = env.getContextManager();
        this.classManager = env.getClassManager();
        this.sourceManager = env.getSourceManager();
    }

    private ThreadReference[] threads = null;

    /*
     * The numbering of threads is relative to the current set of threads,
     * and may be affected by the creation and termination of new threads.
     * Commands issued using such thread ids will only give reliable behavior
     * relative to what was shown earlier in 'list' commands if the VM is interrupted.
     * We need a better scheme.
     */

    private ThreadReference[] threads() throws NoSessionException {
        if (threads == null) {
            ThreadIterator ti = new ThreadIterator(getDefaultThreadGroup());
            List&lt;ThreadReference&gt; tlist = new ArrayList&lt;ThreadReference&gt;();
            while (ti.hasNext()) {
                tlist.add(ti.nextThread());
            }
            threads = tlist.toArray(new ThreadReference[tlist.size()]);
        }
        return threads;
    }

    private ThreadReference findThread(String idToken) throws NoSessionException {
        String id;
        ThreadReference thread = null;
        if (idToken.startsWith(&quot;t@&quot;)) {
            id = idToken.substring(2);
        } else {
            id = idToken;
        }
        try {
            ThreadReference[] threads = threads();
            long threadID = Long.parseLong(id, 16);
            for (ThreadReference thread2 : threads) {
                if (thread2.uniqueID() == threadID) {
                    thread = thread2;
                    break;
                }
            }
            if (thread == null) {
                //env.failure(&quot;No thread for id \&quot;&quot; + idToken + &quot;\&quot;&quot;);
                env.failure(&quot;\&quot;&quot; + idToken + &quot;\&quot; is not a valid thread id.&quot;);
            }
        } catch (NumberFormatException e) {
            env.error(&quot;Thread id \&quot;&quot; + idToken + &quot;\&quot; is ill-formed.&quot;);
            thread = null;
        }
        return thread;
    }

    private ThreadIterator allThreads() throws NoSessionException {
        threads = null;
        //### Why not use runtime.allThreads().iterator() ?
        return new ThreadIterator(runtime.topLevelThreadGroups());
    }

    private ThreadIterator currentThreadGroupThreads() throws NoSessionException {
        threads = null;
        return new ThreadIterator(getDefaultThreadGroup());
    }

    private ThreadGroupIterator allThreadGroups() throws NoSessionException {
        threads = null;
        return new ThreadGroupIterator(runtime.topLevelThreadGroups());
    }

    private ThreadGroupReference defaultThreadGroup;

    private ThreadGroupReference getDefaultThreadGroup() throws NoSessionException {
        if (defaultThreadGroup == null) {
            defaultThreadGroup = runtime.systemThreadGroup();
        }
        return defaultThreadGroup;
    }

    private void setDefaultThreadGroup(ThreadGroupReference tg) {
        defaultThreadGroup = tg;
    }

    /*
     * Command handlers.
     */

    // Command: classes

    private void commandClasses() throws NoSessionException {
        OutputSink out = env.getOutputSink();
        //out.println(&quot;** classes list **&quot;);
        for (ReferenceType refType : runtime.allClasses()) {
            out.println(refType.name());
        }
        out.show();
    }


    // Command: methods

    private void commandMethods(StringTokenizer t) throws NoSessionException {
        if (!t.hasMoreTokens()) {
            env.error(&quot;No class specified.&quot;);
            return;
        }
        String idClass = t.nextToken();
        ReferenceType cls = findClass(idClass);
        if (cls != null) {
            List&lt;Method&gt; methods = cls.allMethods();
            OutputSink out = env.getOutputSink();
            for (int i = 0; i &lt; methods.size(); i++) {
                Method method = methods.get(i);
                out.print(method.declaringType().name() + &quot; &quot; +
                            method.name() + &quot;(&quot;);
                Iterator&lt;String&gt; it = method.argumentTypeNames().iterator();
                if (it.hasNext()) {
                    while (true) {
                        out.print(it.next());
                        if (!it.hasNext()) {
                            break;
                        }
                        out.print(&quot;, &quot;);
                    }
                }
                out.println(&quot;)&quot;);
            }
            out.show();
        } else {
            //### Should validate class name syntax.
            env.failure(&quot;\&quot;&quot; + idClass + &quot;\&quot; is not a valid id or class name.&quot;);
        }
    }

    private ReferenceType findClass(String pattern) throws NoSessionException {
        List&lt;ReferenceType&gt; results = runtime.findClassesMatchingPattern(pattern);
        if (results.size() &gt; 0) {
            //### Should handle multiple results sensibly.
            return results.get(0);
        }
        return null;
    }

    // Command: threads

    private void commandThreads(StringTokenizer t) throws NoSessionException {
        if (!t.hasMoreTokens()) {
            OutputSink out = env.getOutputSink();
            printThreadGroup(out, getDefaultThreadGroup(), 0);
            out.show();
            return;
        }
        String name = t.nextToken();
        ThreadGroupReference tg = findThreadGroup(name);
        if (tg == null) {
            env.failure(name + &quot; is not a valid threadgroup name.&quot;);
        } else {
            OutputSink out = env.getOutputSink();
            printThreadGroup(out, tg, 0);
            out.show();
        }
    }

    private ThreadGroupReference findThreadGroup(String name) throws NoSessionException {
        //### Issue: Uniqueness of thread group names is not enforced.
        ThreadGroupIterator tgi = allThreadGroups();
        while (tgi.hasNext()) {
            ThreadGroupReference tg = tgi.nextThreadGroup();
            if (tg.name().equals(name)) {
                return tg;
            }
        }
        return null;
    }

    private int printThreadGroup(OutputSink out, ThreadGroupReference tg, int iThread) {
        out.println(&quot;Group &quot; + tg.name() + &quot;:&quot;);
        List&lt;ThreadReference&gt; tlist = tg.threads();
        int maxId = 0;
        int maxName = 0;
        for (int i = 0 ; i &lt; tlist.size() ; i++) {
            ThreadReference thr = tlist.get(i);
            int len = Utils.description(thr).length();
            if (len &gt; maxId) {
                maxId = len;
            }
            String name = thr.name();
            int iDot = name.lastIndexOf('.');
            if (iDot &gt;= 0 &amp;&amp; name.length() &gt; iDot) {
                name = name.substring(iDot + 1);
            }
            if (name.length() &gt; maxName) {
                maxName = name.length();
        }
        }
        String maxNumString = String.valueOf(iThread + tlist.size());
        int maxNumDigits = maxNumString.length();
        for (int i = 0 ; i &lt; tlist.size() ; i++) {
            ThreadReference thr = tlist.get(i);
            char buf[] = new char[80];
            for (int j = 0; j &lt; 79; j++) {
                buf[j] = ' ';
            }
            buf[79] = '\0';
            StringBuffer sbOut = new StringBuffer();
            sbOut.append(buf);

            // Right-justify the thread number at start of output string
            String numString = String.valueOf(iThread + i + 1);
            sbOut.insert(maxNumDigits - numString.length(),
                         numString);
            sbOut.insert(maxNumDigits, &quot;.&quot;);

            int iBuf = maxNumDigits + 2;
            sbOut.insert(iBuf, Utils.description(thr));
            iBuf += maxId + 1;
            String name = thr.name();
            int iDot = name.lastIndexOf('.');
            if (iDot &gt;= 0 &amp;&amp; name.length() &gt; iDot) {
                name = name.substring(iDot + 1);
            }
            sbOut.insert(iBuf, name);
            iBuf += maxName + 1;
            sbOut.insert(iBuf, Utils.getStatus(thr));
            sbOut.setLength(79);
            out.println(sbOut.toString());
        }
        for (ThreadGroupReference tg0 : tg.threadGroups()) {
            if (!tg.equals(tg0)) {  // TODO ref mgt
                iThread += printThreadGroup(out, tg0, iThread + tlist.size());
            }
        }
        return tlist.size();
    }

    // Command: threadgroups

    private void commandThreadGroups() throws NoSessionException {
        ThreadGroupIterator it = allThreadGroups();
        int cnt = 0;
        OutputSink out = env.getOutputSink();
        while (it.hasNext()) {
            ThreadGroupReference tg = it.nextThreadGroup();
            ++cnt;
            out.println(&quot;&quot; + cnt + &quot;. &quot; + Utils.description(tg) + &quot; &quot; + tg.name());
        }
        out.show();
    }

    // Command: thread

    private void commandThread(StringTokenizer t) throws NoSessionException {
        if (!t.hasMoreTokens()) {
            env.error(&quot;Thread number not specified.&quot;);
            return;
        }
        ThreadReference thread = findThread(t.nextToken());
        if (thread != null) {
            //### Should notify user.
            context.setCurrentThread(thread);
        }
    }

    // Command: threadgroup

    private void commandThreadGroup(StringTokenizer t) throws NoSessionException {
        if (!t.hasMoreTokens()) {
            env.error(&quot;Threadgroup name not specified.&quot;);
            return;
        }
        String name = t.nextToken();
        ThreadGroupReference tg = findThreadGroup(name);
        if (tg == null) {
            env.failure(name + &quot; is not a valid threadgroup name.&quot;);
        } else {
            //### Should notify user.
            setDefaultThreadGroup(tg);
        }
    }

    // Command: run

    private void commandRun(StringTokenizer t) throws NoSessionException {
        if (doLoad(false, t)) {
            env.notice(&quot;Running ...&quot;);
        }
    }

    // Command: load

    private void commandLoad(StringTokenizer t) throws NoSessionException {
        if (doLoad(true, t)) {}
    }

    private boolean doLoad(boolean suspended,
                           StringTokenizer t) throws NoSessionException {

        String clname;

        if (!t.hasMoreTokens()) {
            clname = context.getMainClassName();
            if (!clname.equals(&quot;&quot;)) {
                // Run from prevously-set class name.
                try {
                    String vmArgs = context.getVmArguments();
                    runtime.run(suspended,
                                vmArgs,
                                clname,
                                context.getProgramArguments());
                    return true;
                } catch (VMLaunchFailureException e) {
                    env.failure(&quot;Attempt to launch main class \&quot;&quot; + clname + &quot;\&quot; failed.&quot;);
                }
            } else {
                env.failure(&quot;No main class specified and no current default defined.&quot;);
            }
        } else {
            clname = t.nextToken();
            StringBuffer sbuf = new StringBuffer();
            // Allow VM arguments to be specified here?
            while (t.hasMoreTokens()) {
                String tok = t.nextToken();
                sbuf.append(tok);
                if (t.hasMoreTokens()) {
                    sbuf.append(' ');
                }
            }
            String args = sbuf.toString();
            try {
                String vmArgs = context.getVmArguments();
                runtime.run(suspended, vmArgs, clname, args);
                context.setMainClassName(clname);
                //context.setVmArguments(vmArgs);
                context.setProgramArguments(args);
                return true;
            } catch (VMLaunchFailureException e) {
                env.failure(&quot;Attempt to launch main class \&quot;&quot; + clname + &quot;\&quot; failed.&quot;);
            }
        }
        return false;
    }

    // Command: connect

    private void commandConnect(StringTokenizer t) {
        try {
            LaunchTool.queryAndLaunchVM(runtime);
        } catch (VMLaunchFailureException e) {
            env.failure(&quot;Attempt to connect failed.&quot;);
        }
    }

    // Command: attach

    private void commandAttach(StringTokenizer t) {
        String portName;
        if (!t.hasMoreTokens()) {
            portName = context.getRemotePort();
            if (!portName.equals(&quot;&quot;)) {
                try {
                    runtime.attach(portName);
                } catch (VMLaunchFailureException e) {
                    env.failure(&quot;Attempt to attach to port \&quot;&quot; + portName + &quot;\&quot; failed.&quot;);
                }
            } else {
                env.failure(&quot;No port specified and no current default defined.&quot;);
            }
        } else {
            portName = t.nextToken();
            try {
                runtime.attach(portName);
            } catch (VMLaunchFailureException e) {
                env.failure(&quot;Attempt to attach to port \&quot;&quot; + portName + &quot;\&quot; failed.&quot;);
            }
            context.setRemotePort(portName);
        }
    }

    // Command: detach

    private void commandDetach(StringTokenizer t) throws NoSessionException {
        runtime.detach();
    }

    // Command: interrupt

    private void commandInterrupt(StringTokenizer t) throws NoSessionException {
        runtime.interrupt();
    }

    // Command: suspend

    private void commandSuspend(StringTokenizer t) throws NoSessionException {
        if (!t.hasMoreTokens()) {
            // Suspend all threads in the current thread group.
            //### Issue: help message says default is all threads.
            //### Behavior here agrees with 'jdb', however.
            ThreadIterator ti = currentThreadGroupThreads();
            while (ti.hasNext()) {
                // TODO - don't suspend debugger threads
                ti.nextThread().suspend();
            }
            env.notice(&quot;All (non-system) threads suspended.&quot;);
        } else {
            while (t.hasMoreTokens()) {
                ThreadReference thread = findThread(t.nextToken());
                if (thread != null) {
                    //thread.suspend();
                    runtime.suspendThread(thread);
                }
            }
        }
    }

    // Command: resume

    private void commandResume(StringTokenizer t) throws NoSessionException {
         if (!t.hasMoreTokens()) {
            // Suspend all threads in the current thread group.
            //### Issue: help message says default is all threads.
            //### Behavior here agrees with 'jdb', however.
            ThreadIterator ti = currentThreadGroupThreads();
            while (ti.hasNext()) {
                // TODO - don't suspend debugger threads
                ti.nextThread().resume();
            }
            env.notice(&quot;All threads resumed.&quot;);
         } else {
             while (t.hasMoreTokens()) {
                ThreadReference thread = findThread(t.nextToken());
                if (thread != null) {
                    //thread.resume();
                    runtime.resumeThread(thread);
                }
             }
         }
    }

    // Command: cont

    private void commandCont() throws NoSessionException {
        try {
            runtime.go();
        } catch (VMNotInterruptedException e) {
            //### failure?
            env.notice(&quot;Target VM is already running.&quot;);
        }
    }

    // Command: step

    private void commandStep(StringTokenizer t) throws NoSessionException{
        ThreadReference current = context.getCurrentThread();
        if (current == null) {
            env.failure(&quot;No current thread.&quot;);
            return;
        }
        try {
            if (t.hasMoreTokens() &amp;&amp;
                t.nextToken().toLowerCase().equals(&quot;up&quot;)) {
                runtime.stepOut(current);
            } else {
                runtime.stepIntoLine(current);
            }
        } catch (AbsentInformationException e) {
            env.failure(&quot;No linenumber information available -- &quot; +
                            &quot;Try \&quot;stepi\&quot; to step by instructions.&quot;);
        }
    }

    // Command: stepi

    private void commandStepi() throws NoSessionException {
        ThreadReference current = context.getCurrentThread();
        if (current == null) {
            env.failure(&quot;No current thread.&quot;);
            return;
        }
        runtime.stepIntoInstruction(current);
    }

    // Command: next

    private void commandNext() throws NoSessionException {
        ThreadReference current = context.getCurrentThread();
        if (current == null) {
            env.failure(&quot;No current thread.&quot;);
            return;
        }
        try {
            runtime.stepOverLine(current);
        } catch (AbsentInformationException e) {
            env.failure(&quot;No linenumber information available -- &quot; +
                            &quot;Try \&quot;nexti\&quot; to step by instructions.&quot;);
        }
    }

    // Command: nexti  (NEW)

    private void commandNexti() throws NoSessionException {
        ThreadReference current = context.getCurrentThread();
        if (current == null) {
            env.failure(&quot;No current thread.&quot;);
            return;
        }
        runtime.stepOverInstruction(current);
    }

    // Command: kill

    private void commandKill(StringTokenizer t) throws NoSessionException {
        //### Should change the way in which thread ids and threadgroup names
        //### are distinguished.
         if (!t.hasMoreTokens()) {
            env.error(&quot;Usage: kill &lt;threadgroup name&gt; or &lt;thread id&gt;&quot;);
            return;
        }
        while (t.hasMoreTokens()) {
            String idToken = t.nextToken();
            ThreadReference thread = findThread(idToken);
            if (thread != null) {
                runtime.stopThread(thread);
                env.notice(&quot;Thread &quot; + thread.name() + &quot; killed.&quot;);
                return;
            } else {
                /* Check for threadgroup name, NOT skipping &quot;system&quot;. */
                //### Should skip &quot;system&quot;?  Classic 'jdb' does this.
                //### Should deal with possible non-uniqueness of threadgroup names.
                ThreadGroupIterator itg = allThreadGroups();
                while (itg.hasNext()) {
                    ThreadGroupReference tg = itg.nextThreadGroup();
                    if (tg.name().equals(idToken)) {
                        ThreadIterator it = new ThreadIterator(tg);
                        while (it.hasNext()) {
                            runtime.stopThread(it.nextThread());
                        }
                        env.notice(&quot;Threadgroup &quot; + tg.name() + &quot;killed.&quot;);
                        return;
                    }
                }
                env.failure(&quot;\&quot;&quot; + idToken +
                            &quot;\&quot; is not a valid threadgroup or id.&quot;);
            }
        }
    }


    /*************
    // TODO
    private void commandCatchException(StringTokenizer t) throws NoSessionException {}
    // TODO
    private void commandIgnoreException(StringTokenizer t) throws NoSessionException {}
    *************/

    // Command: up

    //### Print current frame after command?

    int readCount(StringTokenizer t) {
        int cnt = 1;
        if (t.hasMoreTokens()) {
            String idToken = t.nextToken();
            try {
                cnt = Integer.valueOf(idToken).intValue();
            } catch (NumberFormatException e) {
                cnt = -1;
            }
        }
        return cnt;
    }

    void commandUp(StringTokenizer t) throws NoSessionException {
        ThreadReference current = context.getCurrentThread();
        if (current == null) {
            env.failure(&quot;No current thread.&quot;);
            return;
        }
        int nLevels = readCount(t);
        if (nLevels &lt;= 0) {
            env.error(&quot;usage: up [n frames]&quot;);
            return;
        }
        try {
            int delta = context.moveCurrentFrameIndex(current, -nLevels);
            if (delta == 0) {
                env.notice(&quot;Already at top of stack.&quot;);
            } else if (-delta &lt; nLevels) {
                env.notice(&quot;Moved up &quot; + delta + &quot; frames to top of stack.&quot;);
            }
        } catch (VMNotInterruptedException e) {
            env.failure(&quot;Target VM must be in interrupted state.&quot;);
        }
    }

    private void commandDown(StringTokenizer t) throws NoSessionException {
        ThreadReference current = context.getCurrentThread();
        if (current == null) {
            env.failure(&quot;No current thread.&quot;);
            return;
        }
        int nLevels = readCount(t);
        if (nLevels &lt;= 0) {
            env.error(&quot;usage: down [n frames]&quot;);
            return;
        }
        try {
            int delta = context.moveCurrentFrameIndex(current, nLevels);
            if (delta == 0) {
                env.notice(&quot;Already at bottom of stack.&quot;);
            } else if (delta &lt; nLevels) {
                env.notice(&quot;Moved down &quot; + delta + &quot; frames to bottom of stack.&quot;);
            }
        } catch (VMNotInterruptedException e) {
            env.failure(&quot;Target VM must be in interrupted state.&quot;);
        }
    }

    // Command: frame

    private void commandFrame(StringTokenizer t) throws NoSessionException {
        ThreadReference current = context.getCurrentThread();
        if (current == null) {
            env.failure(&quot;No current thread.&quot;);
            return;
        }
        if (!t.hasMoreTokens()) {
            env.error(&quot;usage: frame &lt;frame-index&gt;&quot;);
            return;
        }
        String idToken = t.nextToken();
        int n;
        try {
            n = Integer.valueOf(idToken).intValue();
        } catch (NumberFormatException e) {
            n = 0;
        }
        if (n &lt;= 0) {
            env.error(&quot;use positive frame index&quot;);
            return;
        }
        try {
            int delta = context.setCurrentFrameIndex(current, n);
            if (delta == 0) {
                env.notice(&quot;Frame unchanged.&quot;);
            } else if (delta &lt; 0) {
                env.notice(&quot;Moved up &quot; + -delta + &quot; frames.&quot;);
            } else {
                env.notice(&quot;Moved down &quot; + delta + &quot; frames.&quot;);
            }
        } catch (VMNotInterruptedException e) {
            env.failure(&quot;Target VM must be in interrupted state.&quot;);
        }
    }

    // Command: where

    //### Should we insist that VM be interrupted here?
    //### There is an inconsistency between the 'where' command
    //### and 'up' and 'down' in this respect.

    private void commandWhere(StringTokenizer t, boolean showPC)
                                                throws NoSessionException {
        ThreadReference current = context.getCurrentThread();
        if (!t.hasMoreTokens()) {
            if (current == null) {
                env.error(&quot;No thread specified.&quot;);
                return;
            }
            dumpStack(current, showPC);
        } else {
            String token = t.nextToken();
            if (token.toLowerCase().equals(&quot;all&quot;)) {
                ThreadIterator it = allThreads();
                while (it.hasNext()) {
                    ThreadReference thread = it.next();
                    out.println(thread.name() + &quot;: &quot;);
                    dumpStack(thread, showPC);
                }
            } else {
                ThreadReference thread = findThread(t.nextToken());
                //### Do we want to set current thread here?
                //### Should notify user of change.
                if (thread != null) {
                    context.setCurrentThread(thread);
                }
                dumpStack(thread, showPC);
            }
        }
    }

    private void dumpStack(ThreadReference thread, boolean showPC) {
        //### Check for these.
        //env.failure(&quot;Thread no longer exists.&quot;);
        //env.failure(&quot;Target VM must be in interrupted state.&quot;);
        //env.failure(&quot;Current thread isn't suspended.&quot;);
        //### Should handle extremely long stack traces sensibly for user.
        List&lt;StackFrame&gt; stack = null;
        try {
            stack = thread.frames();
        } catch (IncompatibleThreadStateException e) {
            env.failure(&quot;Thread is not suspended.&quot;);
        }
        //### Fix this!
        //### Previously mishandled cases where thread was not current.
        //### Now, prints all of the stack regardless of current frame.
        int frameIndex = 0;
        //int frameIndex = context.getCurrentFrameIndex();
        if (stack == null) {
            env.failure(&quot;Thread is not running (no stack).&quot;);
        } else {
            OutputSink out = env.getOutputSink();
            int nFrames = stack.size();
            for (int i = frameIndex; i &lt; nFrames; i++) {
                StackFrame frame = stack.get(i);
                Location loc = frame.location();
                Method meth = loc.method();
                out.print(&quot;  [&quot; + (i + 1) + &quot;] &quot;);
                out.print(meth.declaringType().name());
                out.print('.');
                out.print(meth.name());
                out.print(&quot; (&quot;);
                if (meth.isNative()) {
                    out.print(&quot;native method&quot;);
                } else if (loc.lineNumber() != -1) {
                    try {
                        out.print(loc.sourceName());
                    } catch (AbsentInformationException e) {
                        out.print(&quot;&lt;unknown&gt;&quot;);
                    }
                    out.print(':');
                    out.print(loc.lineNumber());
                }
                out.print(')');
                if (showPC) {
                    long pc = loc.codeIndex();
                    if (pc != -1) {
                        out.print(&quot;, pc = &quot; + pc);
                    }
                }
                out.println();
            }
            out.show();
        }
    }

    private void listEventRequests() throws NoSessionException {
        // Print set breakpoints
        List&lt;EventRequestSpec&gt; specs = runtime.eventRequestSpecs();
        if (specs.isEmpty()) {
            env.notice(&quot;No breakpoints/watchpoints/exceptions set.&quot;);
        } else {
            OutputSink out = env.getOutputSink();
            out.println(&quot;Current breakpoints/watchpoints/exceptions set:&quot;);
            for (EventRequestSpec bp : specs) {
                out.println(&quot;\t&quot; + bp);
            }
            out.show();
        }
    }

    private BreakpointSpec parseBreakpointSpec(String bptSpec) {
        StringTokenizer t = new StringTokenizer(bptSpec);
        BreakpointSpec bpSpec = null;
//        try {
            String token = t.nextToken(&quot;@:( \t\n\r&quot;);
            // We can't use hasMoreTokens here because it will cause any leading
            // paren to be lost.
            String rest;
            try {
                rest = t.nextToken(&quot;&quot;).trim();
            } catch (NoSuchElementException e) {
                rest = null;
            }
            if ((rest != null) &amp;&amp; rest.startsWith(&quot;@&quot;)) {
                t = new StringTokenizer(rest.substring(1));
                String sourceName = token;
                String lineToken = t.nextToken();
                int lineNumber = Integer.valueOf(lineToken).intValue();
                if (t.hasMoreTokens()) {
                    return null;
                }
                bpSpec = runtime.createSourceLineBreakpoint(sourceName,
                                                            lineNumber);
            } else if ((rest != null) &amp;&amp; rest.startsWith(&quot;:&quot;)) {
                t = new StringTokenizer(rest.substring(1));
                String classId = token;
                String lineToken = t.nextToken();
                int lineNumber = Integer.valueOf(lineToken).intValue();
                if (t.hasMoreTokens()) {
                    return null;
                }
                bpSpec = runtime.createClassLineBreakpoint(classId, lineNumber);
            } else {
                // Try stripping method from class.method token.
                int idot = token.lastIndexOf(&quot;.&quot;);
                if ( (idot &lt;= 0) ||        /* No dot or dot in first char */
                     (idot &gt;= token.length() - 1) ) { /* dot in last char */
                    return null;
                }
                String methodName = token.substring(idot + 1);
                String classId = token.substring(0, idot);
                List&lt;String&gt; argumentList = null;
                if (rest != null) {
                    if (!rest.startsWith(&quot;(&quot;) || !rest.endsWith(&quot;)&quot;)) {
                        //### Should throw exception with error message
                        //out.println(&quot;Invalid method specification: &quot;
                        //            + methodName + rest);
                        return null;
                    }
                    // Trim the parens
                    //### What about spaces in arglist?
                    rest = rest.substring(1, rest.length() - 1);
                    argumentList = new ArrayList&lt;String&gt;();
                    t = new StringTokenizer(rest, &quot;,&quot;);
                    while (t.hasMoreTokens()) {
                        argumentList.add(t.nextToken());
                    }
                }
                bpSpec = runtime.createMethodBreakpoint(classId,
                                                       methodName,
                                                       argumentList);
            }
//        } catch (Exception e) {
//            env.error(&quot;Exception attempting to create breakpoint: &quot; + e);
//            return null;
//        }
        return bpSpec;
    }

    private void commandStop(StringTokenizer t) throws NoSessionException {
        String token;

        if (!t.hasMoreTokens()) {
            listEventRequests();
        } else {
            token = t.nextToken();
            // Ignore optional &quot;at&quot; or &quot;in&quot; token.
            // Allowed for backward compatibility.
            if (token.equals(&quot;at&quot;) || token.equals(&quot;in&quot;)) {
                if (t.hasMoreTokens()) {
                    token = t.nextToken();
                } else {
                    env.error(&quot;Missing breakpoint specification.&quot;);
                    return;
                }
            }
            BreakpointSpec bpSpec = parseBreakpointSpec(token);
            if (bpSpec != null) {
                //### Add sanity-checks for deferred breakpoint.
                runtime.install(bpSpec);
            } else {
                env.error(&quot;Ill-formed breakpoint specification.&quot;);
            }
        }
    }

    private void commandClear(StringTokenizer t) throws NoSessionException {
        if (!t.hasMoreTokens()) {
            // Print set breakpoints
            listEventRequests();
            return;
        }
        //### need 'clear all'
        BreakpointSpec bpSpec = parseBreakpointSpec(t.nextToken());
        if (bpSpec != null) {
            List&lt;EventRequestSpec&gt; specs = runtime.eventRequestSpecs();

            if (specs.isEmpty()) {
                env.notice(&quot;No breakpoints set.&quot;);
            } else {
                List&lt;EventRequestSpec&gt; toDelete = new ArrayList&lt;EventRequestSpec&gt;();
                for (EventRequestSpec spec : specs) {
                    if (spec.equals(bpSpec)) {
                        toDelete.add(spec);
                    }
                }
                // The request used for matching should be found
                if (toDelete.size() &lt;= 1) {
                    env.notice(&quot;No matching breakpoint set.&quot;);
                }
                for (EventRequestSpec spec : toDelete) {
                    runtime.delete(spec);
                }
            }
        } else {
            env.error(&quot;Ill-formed breakpoint specification.&quot;);
        }
    }

    // Command: list

    private void commandList(StringTokenizer t) throws NoSessionException {
        ThreadReference current = context.getCurrentThread();
        if (current == null) {
            env.error(&quot;No thread specified.&quot;);
            return;
        }
        Location loc;
        try {
            StackFrame frame = context.getCurrentFrame(current);
            if (frame == null) {
                env.failure(&quot;Thread has not yet begun execution.&quot;);
                return;
            }
            loc = frame.location();
        } catch (VMNotInterruptedException e) {
            env.failure(&quot;Target VM must be in interrupted state.&quot;);
            return;
        }
        SourceModel source = sourceManager.sourceForLocation(loc);
        if (source == null) {
            if (loc.method().isNative()) {
                env.failure(&quot;Current method is native.&quot;);
                return;
            }
            env.failure(&quot;No source available for &quot; + Utils.locationString(loc) + &quot;.&quot;);
            return;
        }
        ReferenceType refType = loc.declaringType();
        int lineno = loc.lineNumber();
        if (t.hasMoreTokens()) {
            String id = t.nextToken();
            // See if token is a line number.
            try {
                lineno = Integer.valueOf(id).intValue();
            } catch (NumberFormatException nfe) {
                // It isn't -- see if it's a method name.
                List&lt;Method&gt; meths = refType.methodsByName(id);
                if (meths == null || meths.size() == 0) {
                    env.failure(id +
                                &quot; is not a valid line number or &quot; +
                                &quot;method name for class &quot; +
                                refType.name());
                    return;
                } else if (meths.size() &gt; 1) {
                    env.failure(id +
                                &quot; is an ambiguous method name in&quot; +
                                refType.name());
                    return;
                }
                loc = meths.get(0).location();
                lineno = loc.lineNumber();
            }
        }
        int startLine = (lineno &gt; 4) ? lineno - 4 : 1;
        int endLine = startLine + 9;
        String sourceLine = source.sourceLine(lineno);
        if (sourceLine == null) {
            env.failure(&quot;&quot; +
                        lineno +
                        &quot; is an invalid line number for &quot; +
                        refType.name());
        } else {
            OutputSink out = env.getOutputSink();
            for (int i = startLine; i &lt;= endLine; i++) {
                sourceLine = source.sourceLine(i);
                if (sourceLine == null) {
                    break;
                }
                out.print(i);
                out.print(&quot;\t&quot;);
                if (i == lineno) {
                    out.print(&quot;=&gt; &quot;);
                } else {
                    out.print(&quot;   &quot;);
                }
                out.println(sourceLine);
            }
            out.show();
        }
    }

    // Command: use
    // Get or set the source file path list.

    private void commandUse(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            out.println(sourceManager.getSourcePath().asString());
        } else {
            //### Should throw exception for invalid path.
            //### E.g., vetoable property change.
            sourceManager.setSourcePath(new SearchPath(t.nextToken()));
        }
    }

    // Command: sourcepath
    // Get or set the source file path list.  (Alternate to 'use'.)

    private void commandSourcepath(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            out.println(sourceManager.getSourcePath().asString());
        } else {
            //### Should throw exception for invalid path.
            //### E.g., vetoable property change.
            sourceManager.setSourcePath(new SearchPath(t.nextToken()));
        }
    }

    // Command: classpath
    // Get or set the class file path list.

    private void commandClasspath(StringTokenizer t) {
        if (!t.hasMoreTokens()) {
            out.println(classManager.getClassPath().asString());
        } else {
            //### Should throw exception for invalid path.
            //### E.g., vetoable property change.
            classManager.setClassPath(new SearchPath(t.nextToken()));
        }
    }

    // Command: view
    // Display source for source file or class.

    private void commandView(StringTokenizer t) throws NoSessionException {
        if (!t.hasMoreTokens()) {
            env.error(&quot;Argument required&quot;);
        } else {
            String name = t.nextToken();
            if (name.endsWith(&quot;.java&quot;) ||
                name.indexOf(File.separatorChar) &gt;= 0) {
                env.viewSource(name);
            } else {
                //### JDI crashes taking line number for class.
                /*****
                ReferenceType cls = findClass(name);
                if (cls != null) {
                    env.viewLocation(cls.location());
                } else {
                    env.failure(&quot;No such class&quot;);
                }
                *****/
                String fileName = name.replace('.', File.separatorChar) + &quot;.java&quot;;
                env.viewSource(fileName);
            }
        }
    }

    // Command: locals
    // Print all local variables in current stack frame.

    private void commandLocals() throws NoSessionException {
        ThreadReference current = context.getCurrentThread();
        if (current == null) {
            env.failure(&quot;No default thread specified: &quot; +
                        &quot;use the \&quot;thread\&quot; command first.&quot;);
            return;
        }
        StackFrame frame;
        try {
            frame = context.getCurrentFrame(current);
            if (frame == null) {
                env.failure(&quot;Thread has not yet created any stack frames.&quot;);
                return;
            }
        } catch (VMNotInterruptedException e) {
            env.failure(&quot;Target VM must be in interrupted state.&quot;);
            return;
        }

        List&lt;LocalVariable&gt; vars;
        try {
            vars = frame.visibleVariables();
            if (vars == null || vars.size() == 0) {
                env.failure(&quot;No local variables&quot;);
                return;
            }
        } catch (AbsentInformationException e) {
            env.failure(&quot;Local variable information not available.&quot; +
                        &quot; Compile with -g to generate variable information&quot;);
            return;
        }

        OutputSink out = env.getOutputSink();
        out.println(&quot;Method arguments:&quot;);
        for (LocalVariable var : vars) {
            if (var.isArgument()) {
                printVar(out, var, frame);
            }
        }
        out.println(&quot;Local variables:&quot;);
        for (LocalVariable var : vars) {
            if (!var.isArgument()) {
                printVar(out, var, frame);
            }
        }
        out.show();
        return;
    }

    /**
     * Command: monitor
     * Monitor an expression
     */
    private void commandMonitor(StringTokenizer t) throws NoSessionException {
        if (!t.hasMoreTokens()) {
            env.error(&quot;Argument required&quot;);
        } else {
            env.getMonitorListModel().add(t.nextToken(&quot;&quot;));
        }
    }

    /**
     * Command: unmonitor
     * Unmonitor an expression
     */
    private void commandUnmonitor(StringTokenizer t) throws NoSessionException {
        if (!t.hasMoreTokens()) {
            env.error(&quot;Argument required&quot;);
        } else {
            env.getMonitorListModel().remove(t.nextToken(&quot;&quot;));
        }
    }

    // Print a stack variable.

    private void printVar(OutputSink out, LocalVariable var, StackFrame frame) {
        out.print(&quot;  &quot; + var.name());
        if (var.isVisible(frame)) {
            Value val = frame.getValue(var);
            out.println(&quot; = &quot; + val.toString());
        } else {
            out.println(&quot; is not in scope&quot;);
        }
    }

    // Command: print
    // Evaluate an expression.

    private void commandPrint(StringTokenizer t, boolean dumpObject) throws NoSessionException {
        if (!t.hasMoreTokens()) {
            //### Probably confused if expresion contains whitespace.
            env.error(&quot;No expression specified.&quot;);
            return;
        }
        ThreadReference current = context.getCurrentThread();
        if (current == null) {
            env.failure(&quot;No default thread specified: &quot; +
                        &quot;use the \&quot;thread\&quot; command first.&quot;);
            return;
        }
        StackFrame frame;
        try {
            frame = context.getCurrentFrame(current);
            if (frame == null) {
                env.failure(&quot;Thread has not yet created any stack frames.&quot;);
                return;
            }
        } catch (VMNotInterruptedException e) {
            env.failure(&quot;Target VM must be in interrupted state.&quot;);
            return;
        }
        while (t.hasMoreTokens()) {
            String expr = t.nextToken(&quot;&quot;);
            Value val = null;
            try {
                val = runtime.evaluate(frame, expr);
            } catch(Exception e) {
                env.error(&quot;Exception: &quot; + e);
                //### Fix this!
            }
            if (val == null) {
                return;  // Error message already printed
            }
            OutputSink out = env.getOutputSink();
            if (dumpObject &amp;&amp; (val instanceof ObjectReference) &amp;&amp;
                                 !(val instanceof StringReference)) {
                ObjectReference obj = (ObjectReference)val;
                ReferenceType refType = obj.referenceType();
                out.println(expr + &quot; = &quot; + val.toString() + &quot; {&quot;);
                dump(out, obj, refType, refType);
                out.println(&quot;}&quot;);
            } else {
                out.println(expr + &quot; = &quot; + val.toString());
            }
            out.show();
        }
    }

    private void dump(OutputSink out,
                      ObjectReference obj, ReferenceType refType,
                      ReferenceType refTypeBase) {
        for (Field field : refType.fields()) {
            out.print(&quot;    &quot;);
            if (!refType.equals(refTypeBase)) {
                out.print(refType.name() + &quot;.&quot;);
            }
            out.print(field.name() + &quot;: &quot;);
            Object o = obj.getValue(field);
            out.println((o == null) ? &quot;null&quot; : o.toString()); // Bug ID 4374471
        }
        if (refType instanceof ClassType) {
            ClassType sup = ((ClassType)refType).superclass();
            if (sup != null) {
                dump(out, obj, sup, refTypeBase);
            }
        } else if (refType instanceof InterfaceType) {
            for (InterfaceType sup : ((InterfaceType)refType).superinterfaces()) {
                dump(out, obj, sup, refTypeBase);
            }
        }
    }

    /*
     * Display help message.
     */

    private void help() {
        out.println(&quot;** command list **&quot;);
        out.println(&quot;threads [threadgroup]     -- list threads&quot;);
        out.println(&quot;thread &lt;thread id&gt;        -- set default thread&quot;);
        out.println(&quot;suspend [thread id(s)]    -- suspend threads (default: all)&quot;);
        out.println(&quot;resume [thread id(s)]     -- resume threads (default: all)&quot;);
        out.println(&quot;where [thread id] | all   -- dump a thread's stack&quot;);
        out.println(&quot;wherei [thread id] | all  -- dump a thread's stack, with pc info&quot;);
        out.println(&quot;threadgroups              -- list threadgroups&quot;);
        out.println(&quot;threadgroup &lt;name&gt;        -- set current threadgroup\n&quot;);
//      out.println(&quot;print &lt;expression&gt;        -- print value of expression&quot;);
        out.println(&quot;dump &lt;expression&gt;         -- print all object information\n&quot;);
//      out.println(&quot;eval &lt;expression&gt;         -- evaluate expression (same as print)&quot;);
        out.println(&quot;locals                    -- print all local variables in current stack frame\n&quot;);
        out.println(&quot;classes                   -- list currently known classes&quot;);
        out.println(&quot;methods &lt;class id&gt;        -- list a class's methods\n&quot;);
        out.println(&quot;stop [in] &lt;class id&gt;.&lt;method&gt;[(argument_type,...)] -- set a breakpoint in a method&quot;);
        out.println(&quot;stop [at] &lt;class id&gt;:&lt;line&gt; -- set a breakpoint at a line&quot;);
        out.println(&quot;up [n frames]             -- move up a thread's stack&quot;);
        out.println(&quot;down [n frames]           -- move down a thread's stack&quot;);
        out.println(&quot;frame &lt;frame-id&gt;           -- to a frame&quot;);
        out.println(&quot;clear &lt;class id&gt;.&lt;method&gt;[(argument_type,...)]   -- clear a breakpoint in a method&quot;);
        out.println(&quot;clear &lt;class id&gt;:&lt;line&gt;   -- clear a breakpoint at a line&quot;);
        out.println(&quot;clear                     -- list breakpoints&quot;);
        out.println(&quot;step                      -- execute current line&quot;);
        out.println(&quot;step up                   -- execute until the current method returns to its caller&quot;);
        out.println(&quot;stepi                     -- execute current instruction&quot;);
        out.println(&quot;next                      -- step one line (step OVER calls)&quot;);
        out.println(&quot;nexti                     -- step one instruction (step OVER calls)&quot;);
        out.println(&quot;cont                      -- continue execution from breakpoint\n&quot;);
//      out.println(&quot;catch &lt;class id&gt;          -- break for the specified exception&quot;);
//      out.println(&quot;ignore &lt;class id&gt;         -- ignore when the specified exception\n&quot;);
        out.println(&quot;view classname|filename   -- display source file&quot;);
        out.println(&quot;list [line number|method] -- print source code context at line or method&quot;);
        out.println(&quot;use &lt;source file path&gt;    -- display or change the source path\n&quot;);
//### new
        out.println(&quot;sourcepath &lt;source file path&gt;    -- display or change the source path\n&quot;);
//### new
        out.println(&quot;classpath &lt;class file path&gt;    -- display or change the class path\n&quot;);
        out.println(&quot;monitor &lt;expression&gt;      -- evaluate an expression each time the program stops\n&quot;);
        out.println(&quot;unmonitor &lt;monitor#&gt;      -- delete a monitor\n&quot;);
        out.println(&quot;read &lt;filename&gt;           -- read and execute a command file\n&quot;);
//      out.println(&quot;memory                    -- report memory usage&quot;);
//      out.println(&quot;gc                        -- free unused objects\n&quot;);
        out.println(&quot;run &lt;class&gt; [args]        -- start execution of a Java class&quot;);
        out.println(&quot;run                       -- re-execute last class run&quot;);
        out.println(&quot;load &lt;class&gt; [args]       -- start execution of a Java class, initially suspended&quot;);
        out.println(&quot;load                      -- re-execute last class run, initially suspended&quot;);
        out.println(&quot;attach &lt;portname&gt;         -- debug existing process\n&quot;);
        out.println(&quot;detach                    -- detach from debuggee process\n&quot;);
        out.println(&quot;kill &lt;thread(group)&gt;      -- kill a thread or threadgroup\n&quot;);
        out.println(&quot;!!                        -- repeat last command&quot;);
        out.println(&quot;help (or ?)               -- list commands&quot;);
        out.println(&quot;exit (or quit)            -- exit debugger&quot;);
    }

    /*
     * Execute a command.
     */

    public void executeCommand(String command) {
        //### Treatment of 'out' here is dirty...
        out = env.getOutputSink();
        if (echo) {
            out.println(&quot;&gt;&gt;&gt; &quot; + command);
        }
        StringTokenizer t = new StringTokenizer(command);
        try {
            String cmd;
            if (t.hasMoreTokens()) {
                cmd = t.nextToken().toLowerCase();
                lastCommand = cmd;
            } else {
                cmd = lastCommand;
            }
            if (cmd.equals(&quot;print&quot;)) {
                commandPrint(t, false);
            } else if (cmd.equals(&quot;eval&quot;)) {
                commandPrint(t, false);
            } else if (cmd.equals(&quot;dump&quot;)) {
                commandPrint(t, true);
            } else if (cmd.equals(&quot;locals&quot;)) {
                commandLocals();
            } else if (cmd.equals(&quot;classes&quot;)) {
                commandClasses();
            } else if (cmd.equals(&quot;methods&quot;)) {
                commandMethods(t);
            } else if (cmd.equals(&quot;threads&quot;)) {
                commandThreads(t);
            } else if (cmd.equals(&quot;thread&quot;)) {
                commandThread(t);
            } else if (cmd.equals(&quot;suspend&quot;)) {
                commandSuspend(t);
            } else if (cmd.equals(&quot;resume&quot;)) {
                commandResume(t);
            } else if (cmd.equals(&quot;cont&quot;)) {
                commandCont();
            } else if (cmd.equals(&quot;threadgroups&quot;)) {
                commandThreadGroups();
            } else if (cmd.equals(&quot;threadgroup&quot;)) {
                commandThreadGroup(t);
            } else if (cmd.equals(&quot;run&quot;)) {
                commandRun(t);
            } else if (cmd.equals(&quot;load&quot;)) {
                commandLoad(t);
            } else if (cmd.equals(&quot;connect&quot;)) {
                commandConnect(t);
            } else if (cmd.equals(&quot;attach&quot;)) {
                commandAttach(t);
            } else if (cmd.equals(&quot;detach&quot;)) {
                commandDetach(t);
            } else if (cmd.equals(&quot;interrupt&quot;)) {
                commandInterrupt(t);
//### Not implemented.
//          } else if (cmd.equals(&quot;catch&quot;)) {
//              commandCatchException(t);
//### Not implemented.
//          } else if (cmd.equals(&quot;ignore&quot;)) {
//              commandIgnoreException(t);
            } else if (cmd.equals(&quot;step&quot;)) {
                commandStep(t);
            } else if (cmd.equals(&quot;stepi&quot;)) {
                commandStepi();
            } else if (cmd.equals(&quot;next&quot;)) {
                commandNext();
            } else if (cmd.equals(&quot;nexti&quot;)) {
                commandNexti();
            } else if (cmd.equals(&quot;kill&quot;)) {
                commandKill(t);
            } else if (cmd.equals(&quot;where&quot;)) {
                commandWhere(t, false);
            } else if (cmd.equals(&quot;wherei&quot;)) {
                commandWhere(t, true);
            } else if (cmd.equals(&quot;up&quot;)) {
                commandUp(t);
            } else if (cmd.equals(&quot;down&quot;)) {
                commandDown(t);
            } else if (cmd.equals(&quot;frame&quot;)) {
                commandFrame(t);
            } else if (cmd.equals(&quot;stop&quot;)) {
                commandStop(t);
            } else if (cmd.equals(&quot;clear&quot;)) {
                commandClear(t);
            } else if (cmd.equals(&quot;list&quot;)) {
                commandList(t);
            } else if (cmd.equals(&quot;use&quot;)) {
                commandUse(t);
            } else if (cmd.equals(&quot;sourcepath&quot;)) {
                commandSourcepath(t);
            } else if (cmd.equals(&quot;classpath&quot;)) {
                commandClasspath(t);
            } else if (cmd.equals(&quot;monitor&quot;)) {
                commandMonitor(t);
            } else if (cmd.equals(&quot;unmonitor&quot;)) {
                commandUnmonitor(t);
            } else if (cmd.equals(&quot;view&quot;)) {
                commandView(t);
//          } else if (cmd.equals(&quot;read&quot;)) {
//              readCommand(t);
            } else if (cmd.equals(&quot;help&quot;) || cmd.equals(&quot;?&quot;)) {
                help();
            } else if (cmd.equals(&quot;quit&quot;) || cmd.equals(&quot;exit&quot;)) {
                try {
                    runtime.detach();
                } catch (NoSessionException e) {
                    // ignore
                }
                env.terminate();
            } else {
                //### Dubious repeat-count feature inherited from 'jdb'
                if (t.hasMoreTokens()) {
                    try {
                        int repeat = Integer.parseInt(cmd);
                        String subcom = t.nextToken(&quot;&quot;);
                        while (repeat-- &gt; 0) {
                            executeCommand(subcom);
                        }
                        return;
                    } catch (NumberFormatException exc) {
                    }
                }
                out.println(&quot;huh? Try help...&quot;);
                out.flush();
            }
        } catch (NoSessionException e) {
            out.println(&quot;There is no currently attached VM session.&quot;);
            out.flush();
        } catch (Exception e) {
            out.println(&quot;Internal exception: &quot; + e.toString());
            out.flush();
            System.out.println(&quot;JDB internal exception: &quot; + e.toString());
            e.printStackTrace();
        }
        out.show();
    }
}
</pre>
</body>
</html>
