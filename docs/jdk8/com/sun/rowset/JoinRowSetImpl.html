<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.rowset;

import java.sql.*;
import javax.sql.*;
import javax.naming.*;
import java.io.*;
import java.math.*;
import java.util.*;

import javax.sql.rowset.*;
import javax.sql.rowset.spi.SyncProvider;
import javax.sql.rowset.spi.SyncProviderException;

/**
 * The standard implementation of the &lt;code&gt;JoinRowSet&lt;/code&gt;
 * interface providing an SQL &lt;code&gt;JOIN&lt;/code&gt; between &lt;code&gt;RowSet&lt;/code&gt;
 * objects.
 * &lt;P&gt;
 * The implementation provides an ANSI-style &lt;code&gt;JOIN&lt;/code&gt; providing an
 * inner join between two tables. Any unmatched rows in either table of the
 * join are  discarded.
 * &lt;p&gt;
 * Typically, a &lt;code&gt;JoinRowSet&lt;/code&gt; implementation is leveraged by
 * &lt;code&gt;RowSet&lt;/code&gt; instances that are in a disconnected environment and
 * thus do not have the luxury of an open connection to the data source to
 * establish logical relationships between themselves. In other words, it is
 * largely &lt;code&gt;CachedRowSet&lt;/code&gt; objects and implementations derived from
 * the &lt;code&gt;CachedRowSet&lt;/code&gt; interface that will use the &lt;code&gt;JoinRowSetImpl&lt;/code&gt;
 * implementation.
 *
 * @author Amit Handa, Jonathan Bruce
 */
public class JoinRowSetImpl extends WebRowSetImpl implements JoinRowSet {
    /**
     * A &lt;code&gt;Vector&lt;/code&gt; object that contains the &lt;code&gt;RowSet&lt;/code&gt; objects
     * that have been added to this &lt;code&gt;JoinRowSet&lt;/code&gt; object.
     */
    private Vector&lt;CachedRowSetImpl&gt; vecRowSetsInJOIN;

    /**
     * The &lt;code&gt;CachedRowSet&lt;/code&gt; object that encapsulates this
     * &lt;code&gt;JoinRowSet&lt;/code&gt; object.
     * When &lt;code&gt;RowSet&lt;/code&gt; objects are added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, they are also added to &lt;i&gt;crsInternal&lt;/i&gt; to form the same kind of
     * SQL &lt;code&gt;JOIN&lt;/code&gt;.  As a result, methods for making updates to this
     * &lt;code&gt;JoinRowSet&lt;/code&gt; object can use &lt;i&gt;crsInternal&lt;/i&gt; methods in their
     * implementations.
     */
    private CachedRowSetImpl crsInternal;

    /**
     * A &lt;code&gt;Vector&lt;/code&gt; object containing the types of join that have been set
     * for this &lt;code&gt;JoinRowSet&lt;/code&gt; object.
     * The last join type set forms the basis of succeeding joins.
     */
    private Vector&lt;Integer&gt; vecJoinType;

    /**
     * A &lt;code&gt;Vector&lt;/code&gt; object containing the names of all the tables entering
     * the join.
     */
    private Vector&lt;String&gt; vecTableNames;

    /**
     * An &lt;code&gt;int&lt;/code&gt; that indicates the column index of the match column.
     */
    private int iMatchKey;

    /**
     * A &lt;code&gt;String&lt;/code&gt; object that stores the name of the match column.
     */
    private String strMatchKey ;

    /**
     * An array of &lt;code&gt;boolean&lt;/code&gt; values indicating the types of joins supported
     * by this &lt;code&gt;JoinRowSet&lt;/code&gt; implementation.
     */
    boolean[] supportedJOINs;

    /**
     * The &lt;code&gt;WebRowSet&lt;/code&gt; object that encapsulates this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object. This &lt;code&gt;WebRowSet&lt;/code&gt; object allows this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object to leverage the properties and methods of a &lt;code&gt;WebRowSet&lt;/code&gt;
     * object.
     */
    private WebRowSet wrs;


    /**
     * Constructor for &lt;code&gt;JoinRowSetImpl&lt;/code&gt; class. Configures various internal data
     * structures to provide mechanisms required for &lt;code&gt;JoinRowSet&lt;/code&gt; interface
     * implementation.
     *
     * @throws SQLException if an error occurs in instantiating an instance of
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt;
     */
    public JoinRowSetImpl() throws SQLException {

        vecRowSetsInJOIN = new Vector&lt;CachedRowSetImpl&gt;();
        crsInternal = new CachedRowSetImpl();
        vecJoinType = new Vector&lt;Integer&gt;();
        vecTableNames = new Vector&lt;String&gt;();
        iMatchKey = -1;
        strMatchKey = null;
        supportedJOINs =
              new boolean[] {false, true, false, false, false};
       try {
           resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();
        } catch(IOException ioe) {
            throw new RuntimeException(ioe);
        }

    }

    /**
     * Adds the given &lt;code&gt;RowSet&lt;/code&gt; object to this
     * &lt;code&gt;JoinRowSet&lt;/code&gt; object.  If this
     * rowset is the first to be added to the &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, it forms the basis for the &lt;code&gt;JOIN&lt;/code&gt;
     * relationships to be formed.
     * &lt;p&gt;
     * This method should be used when the given &lt;code&gt;RowSet&lt;/code&gt; object
     * already has a match column set.
     *
     * @param rowset the &lt;code&gt;RowSet&lt;/code&gt; object that implements the
     *         &lt;code&gt;Joinable&lt;/code&gt; interface and is to be added
     *         to this &lt;code&gt;JoinRowSet&lt;/code&gt; object
     * @throws SQLException if an empty &lt;code&gt;RowSet&lt;/code&gt; is added to the to the
     *         &lt;code&gt;JoinRowSet&lt;/code&gt;; if a match column is not set; or if an
     *         additional &lt;code&gt;RowSet&lt;/code&gt; violates the active &lt;code&gt;JOIN&lt;/code&gt;
     * @see CachedRowSet#setMatchColumn
     */
    public void addRowSet(Joinable rowset) throws SQLException {
        boolean boolColId, boolColName;

        boolColId = false;
        boolColName = false;
        CachedRowSetImpl cRowset;

        if(!(rowset instanceof RowSet)) {
            throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.notinstance&quot;).toString());
        }

        if(rowset instanceof JdbcRowSetImpl ) {
            cRowset = new CachedRowSetImpl();
            cRowset.populate((RowSet)rowset);
            if(cRowset.size() == 0){
                throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.emptyrowset&quot;).toString());
            }


            try {
                int matchColumnCount = 0;
                for(int i=0; i&lt; rowset.getMatchColumnIndexes().length; i++) {
                    if(rowset.getMatchColumnIndexes()[i] != -1)
                        ++ matchColumnCount;
                    else
                        break;
                }
                int[] pCol = new int[matchColumnCount];
                for(int i=0; i&lt;matchColumnCount; i++)
                   pCol[i] = rowset.getMatchColumnIndexes()[i];
                cRowset.setMatchColumn(pCol);
            } catch(SQLException sqle) {

            }

        } else {
             cRowset = (CachedRowSetImpl)rowset;
             if(cRowset.size() == 0){
                 throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.emptyrowset&quot;).toString());
             }
        }

        // Either column id or column name will be set
        // If both not set throw exception.

        try {
             iMatchKey = (cRowset.getMatchColumnIndexes())[0];
        } catch(SQLException sqle) {
           //if not set catch the exception but do nothing now.
             boolColId = true;
        }

        try {
             strMatchKey = (cRowset.getMatchColumnNames())[0];
        } catch(SQLException sqle) {
           //if not set catch the exception but do nothing now.
           boolColName = true;
        }

        if(boolColId &amp;&amp; boolColName) {
           // neither setter methods have been used to set
           throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.matchnotset&quot;).toString());
        } else {
           //if(boolColId || boolColName)
           // either of the setter methods have been set.
           if(boolColId){
              //
              ArrayList&lt;Integer&gt; indices = new ArrayList&lt;&gt;();
              for(int i=0;i&lt;cRowset.getMatchColumnNames().length;i++) {
                  if( (strMatchKey = (cRowset.getMatchColumnNames())[i]) != null) {
                      iMatchKey = cRowset.findColumn(strMatchKey);
                      indices.add(iMatchKey);
                  }
                  else
                      break;
              }
              int[] indexes = new int[indices.size()];
              for(int i=0; i&lt;indices.size();i++)
                  indexes[i] = indices.get(i);
              cRowset.setMatchColumn(indexes);
              // Set the match column here because join will be
              // based on columnId,
              // (nested for loop in initJOIN() checks for equality
              //  based on columnIndex)
           } else {
              //do nothing, iMatchKey is set.
           }
           // Now both iMatchKey and strMatchKey have been set pointing
           // to the same column
        }

        // Till first rowset setJoinType may not be set because
        // default type is JoinRowSet.INNER_JOIN which should
        // be set and for subsequent additions of rowset, if not set
        // keep on adding join type as JoinRowSet.INNER_JOIN
        // to vecJoinType.

        initJOIN(cRowset);
    }

    /**
     * Adds the given &lt;code&gt;RowSet&lt;/code&gt; object to the &lt;code&gt;JOIN&lt;/code&gt; relation
     * and sets the designated column as the match column.
     * If the given &lt;code&gt;RowSet&lt;/code&gt;
     * object is the first to be added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, it forms the basis of the &lt;code&gt;JOIN&lt;/code&gt; relationship to be formed
     * when other &lt;code&gt;RowSet&lt;/code&gt; objects are added .
     * &lt;P&gt;
     * This method should be used when the given &lt;code&gt;RowSet&lt;/code&gt; object
     * does not already have a match column set.
     *
     * @param rowset a &lt;code&gt;RowSet&lt;/code&gt; object to be added to
     *         the &lt;code&gt;JOIN&lt;/code&gt; relation; must implement the &lt;code&gt;Joinable&lt;/code&gt;
     *         interface
     * @param columnIdx an &lt;code&gt;int&lt;/code&gt; giving the index of the column to be set as
     *         the match column
     * @throws SQLException if (1) an empty &lt;code&gt;RowSet&lt;/code&gt; object is added to this
     *         &lt;code&gt;JoinRowSet&lt;/code&gt; object, (2) a match column has not been set,
     *         or (3) the &lt;code&gt;RowSet&lt;/code&gt; object being added violates the active
     *         &lt;code&gt;JOIN&lt;/code&gt;
     * @see CachedRowSet#unsetMatchColumn
     */
    public void addRowSet(RowSet rowset, int columnIdx) throws SQLException {
        //passing the rowset as well as the columnIdx to form the joinrowset.

        ((CachedRowSetImpl)rowset).setMatchColumn(columnIdx);

        addRowSet((Joinable)rowset);
    }

    /**
     * Adds the given &lt;code&gt;RowSet&lt;/code&gt; object to the &lt;code&gt;JOIN&lt;/code&gt; relationship
     * and sets the designated column as the match column. If the given
     * &lt;code&gt;RowSet&lt;/code&gt;
     * object is the first to be added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, it forms the basis of the &lt;code&gt;JOIN&lt;/code&gt; relationship to be formed
     * when other &lt;code&gt;RowSet&lt;/code&gt; objects are added .
     * &lt;P&gt;
     * This method should be used when the given &lt;code&gt;RowSet&lt;/code&gt; object
     * does not already have a match column set.
     *
     * @param rowset a &lt;code&gt;RowSet&lt;/code&gt; object to be added to
     *         the &lt;code&gt;JOIN&lt;/code&gt; relation
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the name of the column
     *        to be set as the match column; must implement the &lt;code&gt;Joinable&lt;/code&gt;
     *        interface
     * @throws SQLException if (1) an empty &lt;code&gt;RowSet&lt;/code&gt; object is added to this
     *         &lt;code&gt;JoinRowSet&lt;/code&gt; object, (2) a match column has not been set,
     *         or (3) the &lt;code&gt;RowSet&lt;/code&gt; object being added violates the active
     *         &lt;code&gt;JOIN&lt;/code&gt;
     */
    public void addRowSet(RowSet rowset, String columnName) throws SQLException {
        //passing the rowset as well as the columnIdx to form the joinrowset.
        ((CachedRowSetImpl)rowset).setMatchColumn(columnName);
        addRowSet((Joinable)rowset);
    }

    /**
     * Adds the given &lt;code&gt;RowSet&lt;/code&gt; objects to the &lt;code&gt;JOIN&lt;/code&gt; relationship
     * and sets the designated columns as the match columns. If the first
     * &lt;code&gt;RowSet&lt;/code&gt; object in the array of &lt;code&gt;RowSet&lt;/code&gt; objects
     * is the first to be added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, it forms the basis of the &lt;code&gt;JOIN&lt;/code&gt; relationship to be formed
     * when other &lt;code&gt;RowSet&lt;/code&gt; objects are added.
     * &lt;P&gt;
     * The first &lt;code&gt;int&lt;/code&gt;
     * in &lt;i&gt;columnIdx&lt;/i&gt; is used to set the match column for the first
     * &lt;code&gt;RowSet&lt;/code&gt; object in &lt;i&gt;rowset&lt;/i&gt;, the second &lt;code&gt;int&lt;/code&gt;
     * in &lt;i&gt;columnIdx&lt;/i&gt; is used to set the match column for the second
     * &lt;code&gt;RowSet&lt;/code&gt; object in &lt;i&gt;rowset&lt;/i&gt;, and so on.
     * &lt;P&gt;
     * This method should be used when the given &lt;code&gt;RowSet&lt;/code&gt; objects
     * do not already have match columns set.
     *
     * @param rowset an array of &lt;code&gt;RowSet&lt;/code&gt; objects to be added to
     *         the &lt;code&gt;JOIN&lt;/code&gt; relation; each &lt;code&gt;RowSet&lt;/code&gt; object must
     *         implement the &lt;code&gt;Joinable&lt;/code&gt; interface
     * @param columnIdx an array of &lt;code&gt;int&lt;/code&gt; values designating the columns
     *        to be set as the
     *        match columns for the &lt;code&gt;RowSet&lt;/code&gt; objects in &lt;i&gt;rowset&lt;/i&gt;
     * @throws SQLException if the number of &lt;code&gt;RowSet&lt;/code&gt; objects in
     *         &lt;i&gt;rowset&lt;/i&gt; is not equal to the number of &lt;code&gt;int&lt;/code&gt; values
     *         in &lt;i&gt;columnIdx&lt;/i&gt;
     */
    public void addRowSet(RowSet[] rowset,
                          int[] columnIdx) throws SQLException {
    //validate if length of rowset array is same as length of int array.
     if(rowset.length != columnIdx.length) {
        throw new SQLException
             (resBundle.handleGetObject(&quot;joinrowsetimpl.numnotequal&quot;).toString());
     } else {
        for(int i=0; i&lt; rowset.length; i++) {
           ((CachedRowSetImpl)rowset[i]).setMatchColumn(columnIdx[i]);
           addRowSet((Joinable)rowset[i]);
        } //end for
     } //end if

   }


    /**
     * Adds the given &lt;code&gt;RowSet&lt;/code&gt; objects to the &lt;code&gt;JOIN&lt;/code&gt; relationship
     * and sets the designated columns as the match columns. If the first
     * &lt;code&gt;RowSet&lt;/code&gt; object in the array of &lt;code&gt;RowSet&lt;/code&gt; objects
     * is the first to be added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, it forms the basis of the &lt;code&gt;JOIN&lt;/code&gt; relationship to be formed
     * when other &lt;code&gt;RowSet&lt;/code&gt; objects are added.
     * &lt;P&gt;
     * The first &lt;code&gt;String&lt;/code&gt; object
     * in &lt;i&gt;columnName&lt;/i&gt; is used to set the match column for the first
     * &lt;code&gt;RowSet&lt;/code&gt; object in &lt;i&gt;rowset&lt;/i&gt;, the second &lt;code&gt;String&lt;/code&gt;
     * object in &lt;i&gt;columnName&lt;/i&gt; is used to set the match column for the second
     * &lt;code&gt;RowSet&lt;/code&gt; object in &lt;i&gt;rowset&lt;/i&gt;, and so on.
     * &lt;P&gt;
     * This method should be used when the given &lt;code&gt;RowSet&lt;/code&gt; objects
     * do not already have match columns set.
     *
     * @param rowset an array of &lt;code&gt;RowSet&lt;/code&gt; objects to be added to
     *         the &lt;code&gt;JOIN&lt;/code&gt; relation; each &lt;code&gt;RowSet&lt;/code&gt; object must
     *         implement the &lt;code&gt;Joinable&lt;/code&gt; interface
     * @param columnName an array of &lt;code&gt;String&lt;/code&gt; objects designating the columns
     *        to be set as the
     *        match columns for the &lt;code&gt;RowSet&lt;/code&gt; objects in &lt;i&gt;rowset&lt;/i&gt;
     * @throws SQLException if the number of &lt;code&gt;RowSet&lt;/code&gt; objects in
     *         &lt;i&gt;rowset&lt;/i&gt; is not equal to the number of &lt;code&gt;String&lt;/code&gt; objects
     *         in &lt;i&gt;columnName&lt;/i&gt;, an empty &lt;code&gt;JdbcRowSet&lt;/code&gt; is added to the
     *         &lt;code&gt;JoinRowSet&lt;/code&gt;, if a match column is not set,
     *         or one or the &lt;code&gt;RowSet&lt;/code&gt; objects in &lt;i&gt;rowset&lt;/i&gt; violates the
     *         active &lt;code&gt;JOIN&lt;/code&gt;
     */
    public void addRowSet(RowSet[] rowset,
                          String[] columnName) throws SQLException {
    //validate if length of rowset array is same as length of int array.

     if(rowset.length != columnName.length) {
        throw new SQLException
                 (resBundle.handleGetObject(&quot;joinrowsetimpl.numnotequal&quot;).toString());
     } else {
        for(int i=0; i&lt; rowset.length; i++) {
           ((CachedRowSetImpl)rowset[i]).setMatchColumn(columnName[i]);
           addRowSet((Joinable)rowset[i]);
        } //end for
     } //end if

    }

    /**
     * Returns a Collection of the &lt;code&gt;RowSet&lt;/code&gt; object instances
     * currently residing with the instance of the &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object instance. This should return the 'n' number of RowSet contained
     * within the JOIN and maintain any updates that have occoured while in
     * this union.
     *
     * @return A &lt;code&gt;Collection&lt;/code&gt; of the added &lt;code&gt;RowSet&lt;/code&gt;
     * object instances
     * @throws SQLException if an error occours generating a collection
     * of the originating RowSets contained within the JOIN.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    public Collection getRowSets() throws SQLException {
        return vecRowSetsInJOIN;
    }

    /**
     * Returns a string array of the RowSet names currently residing
     * with the &lt;code&gt;JoinRowSet&lt;/code&gt; object instance.
     *
     * @return a string array of the RowSet names
     * @throws SQLException if an error occours retrieving the RowSet names
     * @see CachedRowSet#setTableName
     */
    public String[] getRowSetNames() throws SQLException {
        Object [] arr = vecTableNames.toArray();
        String []strArr = new String[arr.length];

        for( int i = 0;i &lt; arr.length; i++) {
           strArr[i] = arr[i].toString();
        }

        return strArr;
    }

    /**
     * Creates a separate &lt;code&gt;CachedRowSet&lt;/code&gt; object that contains the data
     * in this &lt;code&gt;JoinRowSet&lt;/code&gt; object.
     * &lt;P&gt;
     * If any updates or modifications have been applied to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, the &lt;code&gt;CachedRowSet&lt;/code&gt; object returned by this method will
     * not be able to persist
     * the changes back to the originating rows and tables in the
     * data source because the data may be from different tables. The
     * &lt;code&gt;CachedRowSet&lt;/code&gt; instance returned should not
     * contain modification data, such as whether a row has been updated or what the
     * original values are.  Also, the &lt;code&gt;CachedRowSet&lt;/code&gt; object should clear
     * its  properties pertaining to
     * its originating SQL statement. An application should reset the
     * SQL statement using the &lt;code&gt;RowSet.setCommand&lt;/code&gt; method.
     * &lt;p&gt;
     * To persist changes back to the data source, the &lt;code&gt;JoinRowSet&lt;/code&gt; object
     * calls the method &lt;code&gt;acceptChanges&lt;/code&gt;. Implementations
     * can leverage the internal data and update tracking in their
     * implementations to interact with the &lt;code&gt;SyncProvider&lt;/code&gt; to persist any
     * changes.
     *
     * @return a &lt;code&gt;CachedRowSet&lt;/code&gt; object containing the contents of this
     *         &lt;code&gt;JoinRowSet&lt;/code&gt; object
     * @throws SQLException if an error occurs assembling the &lt;code&gt;CachedRowSet&lt;/code&gt;
     *         object
     * @see javax.sql.RowSet
     * @see javax.sql.rowset.CachedRowSet
     * @see javax.sql.rowset.spi.SyncProvider
     */
    public CachedRowSet toCachedRowSet() throws SQLException {
        return crsInternal;
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;JoinRowSet&lt;/code&gt; object supports
     * an SQL &lt;code&gt;CROSS_JOIN&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; if it does not.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the CROSS_JOIN is supported; &lt;code&gt;false&lt;/code&gt;
     *         otherwise
     */
    public boolean supportsCrossJoin() {
        return supportedJOINs[JoinRowSet.CROSS_JOIN];
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;JoinRowSet&lt;/code&gt; object supports
     * an SQL &lt;code&gt;INNER_JOIN&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; if it does not.
     *
     * @return true is the INNER_JOIN is supported; false otherwise
     */
    public boolean supportsInnerJoin() {
        return supportedJOINs[JoinRowSet.INNER_JOIN];
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;JoinRowSet&lt;/code&gt; object supports
     * an SQL &lt;code&gt;LEFT_OUTER_JOIN&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; if it does not.
     *
     * @return true is the LEFT_OUTER_JOIN is supported; false otherwise
     */
    public boolean supportsLeftOuterJoin() {
        return supportedJOINs[JoinRowSet.LEFT_OUTER_JOIN];
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;JoinRowSet&lt;/code&gt; object supports
     * an SQL &lt;code&gt;RIGHT_OUTER_JOIN&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; if it does not.
     *
     * @return true is the RIGHT_OUTER_JOIN is supported; false otherwise
     */
    public boolean supportsRightOuterJoin() {
        return supportedJOINs[JoinRowSet.RIGHT_OUTER_JOIN];
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;JoinRowSet&lt;/code&gt; object supports
     * an SQL &lt;code&gt;FULL_JOIN&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; if it does not.
     *
     * @return true is the FULL_JOIN is supported; false otherwise
     */
    public boolean supportsFullJoin() {
        return supportedJOINs[JoinRowSet.FULL_JOIN];

    }

    /**
     * Sets the type of SQL &lt;code&gt;JOIN&lt;/code&gt; that this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object will use. This method
     * allows an application to adjust the type of &lt;code&gt;JOIN&lt;/code&gt; imposed
     * on tables contained within this &lt;code&gt;JoinRowSet&lt;/code&gt; object and to do it
     * on the fly. The last &lt;code&gt;JOIN&lt;/code&gt; type set determines the type of
     * &lt;code&gt;JOIN&lt;/code&gt; to be performed.
     * &lt;P&gt;
     * Implementations should throw an &lt;code&gt;SQLException&lt;/code&gt; if they do
     * not support the given &lt;code&gt;JOIN&lt;/code&gt; type.
     *
     * @param type one of the standard &lt;code&gt;JoinRowSet&lt;/code&gt; constants
     *        indicating the type of &lt;code&gt;JOIN&lt;/code&gt;.  Must be one of the
     *        following:
     *            &lt;code&gt;JoinRowSet.CROSS_JOIN&lt;/code&gt;
     *            &lt;code&gt;JoinRowSet.INNER_JOIN&lt;/code&gt;
     *            &lt;code&gt;JoinRowSet.LEFT_OUTER_JOIN&lt;/code&gt;
     *            &lt;code&gt;JoinRowSet.RIGHT_OUTER_JOIN&lt;/code&gt;, or
     *            &lt;code&gt;JoinRowSet.FULL_JOIN&lt;/code&gt;
     * @throws SQLException if an unsupported &lt;code&gt;JOIN&lt;/code&gt; type is set
     */
    public void setJoinType(int type) throws SQLException {
        // The join which governs the join of two rowsets is the last
        // join set, using setJoinType

       if (type &gt;= JoinRowSet.CROSS_JOIN &amp;&amp; type &lt;= JoinRowSet.FULL_JOIN) {
           if (type != JoinRowSet.INNER_JOIN) {
               // This 'if' will be removed after all joins are implemented.
               throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.notsupported&quot;).toString());
           } else {
              Integer Intgr = Integer.valueOf(JoinRowSet.INNER_JOIN);
              vecJoinType.add(Intgr);
           }
       } else {
          throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.notdefined&quot;).toString());
       }  //end if
    }


    /**
     * This checks for a match column for
     * whether it exists or not.
     *
     * @param &lt;code&gt;CachedRowSet&lt;/code&gt; object whose match column needs to be checked.
     * @throws SQLException if MatchColumn is not set.
     */
    private boolean checkforMatchColumn(Joinable rs) throws SQLException {
        int[] i = rs.getMatchColumnIndexes();
        if (i.length &lt;= 0) {
            return false;
        }
        return true;
    }

    /**
     * Internal initialization of &lt;code&gt;JoinRowSet&lt;/code&gt;.
     */
    private void initJOIN(CachedRowSet rowset) throws SQLException {
        try {

            CachedRowSetImpl cRowset = (CachedRowSetImpl)rowset;
            // Create a new CachedRowSet object local to this function.
            CachedRowSetImpl crsTemp = new CachedRowSetImpl();
            RowSetMetaDataImpl rsmd = new RowSetMetaDataImpl();

            /* The following 'if block' seems to be always going true.
               commenting this out for present

            if (!supportedJOINs[1]) {
                throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.notsupported&quot;).toString());
            }

            */

            if (vecRowSetsInJOIN.isEmpty() ) {

                // implies first cRowset to be added to the Join
                // simply add this as a CachedRowSet.
                // Also add it to the class variable of type vector
                // do not need to check &quot;type&quot; of Join but it should be set.
                crsInternal = (CachedRowSetImpl)rowset.createCopy();
                crsInternal.setMetaData((RowSetMetaDataImpl)cRowset.getMetaData());
                // metadata will also set the MatchColumn.

                vecRowSetsInJOIN.add(cRowset);

            } else {
                // At this point we are ready to add another rowset to 'this' object
                // Check the size of vecJoinType and vecRowSetsInJoin

                // If nothing is being set, internally call setJoinType()
                // to set to JoinRowSet.INNER_JOIN.

                // For two rowsets one (valid) entry should be there in vecJoinType
                // For three rowsets two (valid) entries should be there in vecJoinType

                // Maintain vecRowSetsInJoin = vecJoinType + 1


                if( (vecRowSetsInJOIN.size() - vecJoinType.size() ) == 2 ) {
                   // we are going to add next rowset and setJoinType has not been set
                   // recently, so set it to setJoinType() to JoinRowSet.INNER_JOIN.
                   // the default join type

                        setJoinType(JoinRowSet.INNER_JOIN);
                } else if( (vecRowSetsInJOIN.size() - vecJoinType.size() ) == 1  ) {
                   // do nothing setjoinType() has been set by programmer
                }

                // Add the table names to the class variable of type vector.
                vecTableNames.add(crsInternal.getTableName());
                vecTableNames.add(cRowset.getTableName());
                // Now we have two rowsets crsInternal and cRowset which need
                // to be INNER JOIN'ED to form a new rowset
                // Compare table1.MatchColumn1.value1 == { table2.MatchColumn2.value1
                //                              ... upto table2.MatchColumn2.valueN }
                //     ...
                // Compare table1.MatchColumn1.valueM == { table2.MatchColumn2.value1
                //                              ... upto table2.MatchColumn2.valueN }
                //
                // Assuming first rowset has M rows and second N rows.

                int rowCount2 = cRowset.size();
                int rowCount1 = crsInternal.size();

                // total columns in the new CachedRowSet will be sum of both -1
                // (common column)
                int matchColumnCount = 0;
                for(int i=0; i&lt; crsInternal.getMatchColumnIndexes().length; i++) {
                    if(crsInternal.getMatchColumnIndexes()[i] != -1)
                        ++ matchColumnCount;
                    else
                        break;
                }

                rsmd.setColumnCount
                    (crsInternal.getMetaData().getColumnCount() +
                     cRowset.getMetaData().getColumnCount() - matchColumnCount);

                crsTemp.setMetaData(rsmd);
                crsInternal.beforeFirst();
                cRowset.beforeFirst();
                for (int i = 1 ; i &lt;= rowCount1 ; i++) {
                  if(crsInternal.isAfterLast() ) {
                    break;
                  }
                  if(crsInternal.next()) {
                    cRowset.beforeFirst();
                    for(int j = 1 ; j &lt;= rowCount2 ; j++) {
                         if( cRowset.isAfterLast()) {
                            break;
                         }
                         if(cRowset.next()) {
                             boolean match = true;
                             for(int k=0; k&lt;matchColumnCount; k++) {
                                 if (!crsInternal.getObject( crsInternal.getMatchColumnIndexes()[k]).equals
                                         (cRowset.getObject(cRowset.getMatchColumnIndexes()[k]))) {
                                     match = false;
                                     break;
                                 }
                             }
                             if (match) {

                                int p;
                                int colc = 0;   // reset this variable everytime you loop
                                // re create a JoinRowSet in crsTemp object
                                crsTemp.moveToInsertRow();

                                // create a new rowset crsTemp with data from first rowset
                            for( p=1;
                                p&lt;=crsInternal.getMetaData().getColumnCount();p++) {

                                match = false;
                                for(int k=0; k&lt;matchColumnCount; k++) {
                                 if (p == crsInternal.getMatchColumnIndexes()[k] ) {
                                     match = true;
                                     break;
                                 }
                                }
                                    if ( !match ) {

                                    crsTemp.updateObject(++colc, crsInternal.getObject(p));
                                    // column type also needs to be passed.

                                    rsmd.setColumnName
                                        (colc, crsInternal.getMetaData().getColumnName(p));
                                    rsmd.setTableName(colc, crsInternal.getTableName());

                                    rsmd.setColumnType(p, crsInternal.getMetaData().getColumnType(p));
                                    rsmd.setAutoIncrement(p, crsInternal.getMetaData().isAutoIncrement(p));
                                    rsmd.setCaseSensitive(p, crsInternal.getMetaData().isCaseSensitive(p));
                                    rsmd.setCatalogName(p, crsInternal.getMetaData().getCatalogName(p));
                                    rsmd.setColumnDisplaySize(p, crsInternal.getMetaData().getColumnDisplaySize(p));
                                    rsmd.setColumnLabel(p, crsInternal.getMetaData().getColumnLabel(p));
                                    rsmd.setColumnType(p, crsInternal.getMetaData().getColumnType(p));
                                    rsmd.setColumnTypeName(p, crsInternal.getMetaData().getColumnTypeName(p));
                                    rsmd.setCurrency(p,crsInternal.getMetaData().isCurrency(p) );
                                    rsmd.setNullable(p, crsInternal.getMetaData().isNullable(p));
                                    rsmd.setPrecision(p, crsInternal.getMetaData().getPrecision(p));
                                    rsmd.setScale(p, crsInternal.getMetaData().getScale(p));
                                    rsmd.setSchemaName(p, crsInternal.getMetaData().getSchemaName(p));
                                    rsmd.setSearchable(p, crsInternal.getMetaData().isSearchable(p));
                                    rsmd.setSigned(p, crsInternal.getMetaData().isSigned(p));

                                } else {
                                    // will happen only once, for that  merged column pass
                                    // the types as OBJECT, if types not equal

                                    crsTemp.updateObject(++colc, crsInternal.getObject(p));

                                    rsmd.setColumnName(colc, crsInternal.getMetaData().getColumnName(p));
                                    rsmd.setTableName
                                        (colc, crsInternal.getTableName()+
                                         &quot;#&quot;+
                                         cRowset.getTableName());


                                    rsmd.setColumnType(p, crsInternal.getMetaData().getColumnType(p));
                                    rsmd.setAutoIncrement(p, crsInternal.getMetaData().isAutoIncrement(p));
                                    rsmd.setCaseSensitive(p, crsInternal.getMetaData().isCaseSensitive(p));
                                    rsmd.setCatalogName(p, crsInternal.getMetaData().getCatalogName(p));
                                    rsmd.setColumnDisplaySize(p, crsInternal.getMetaData().getColumnDisplaySize(p));
                                    rsmd.setColumnLabel(p, crsInternal.getMetaData().getColumnLabel(p));
                                    rsmd.setColumnType(p, crsInternal.getMetaData().getColumnType(p));
                                    rsmd.setColumnTypeName(p, crsInternal.getMetaData().getColumnTypeName(p));
                                    rsmd.setCurrency(p,crsInternal.getMetaData().isCurrency(p) );
                                    rsmd.setNullable(p, crsInternal.getMetaData().isNullable(p));
                                    rsmd.setPrecision(p, crsInternal.getMetaData().getPrecision(p));
                                    rsmd.setScale(p, crsInternal.getMetaData().getScale(p));
                                    rsmd.setSchemaName(p, crsInternal.getMetaData().getSchemaName(p));
                                    rsmd.setSearchable(p, crsInternal.getMetaData().isSearchable(p));
                                    rsmd.setSigned(p, crsInternal.getMetaData().isSigned(p));

                                    //don't do ++colc in the above statement
                                } //end if
                            } //end for


                            // append the rowset crsTemp, with data from second rowset
                            for(int q=1;
                                q&lt;= cRowset.getMetaData().getColumnCount();q++) {

                                match = false;
                                for(int k=0; k&lt;matchColumnCount; k++) {
                                 if (q == cRowset.getMatchColumnIndexes()[k] ) {
                                     match = true;
                                     break;
                                 }
                                }
                                    if ( !match ) {

                                    crsTemp.updateObject(++colc, cRowset.getObject(q));

                                    rsmd.setColumnName
                                        (colc, cRowset.getMetaData().getColumnName(q));
                                    rsmd.setTableName(colc, cRowset.getTableName());

                                    /**
                                      * This will happen for a special case scenario. The value of 'p'
                                      * will always be one more than the number of columns in the first
                                      * rowset in the join. So, for a value of 'q' which is the number of
                                      * columns in the second rowset that participates in the join.
                                      * So decrement value of 'p' by 1 else `p+q-1` will be out of range.
                                      **/

                                    //if((p+q-1) &gt; ((crsInternal.getMetaData().getColumnCount()) +
                                      //            (cRowset.getMetaData().getColumnCount())     - 1)) {
                                      // --p;
                                    //}
                                    rsmd.setColumnType(p+q-1, cRowset.getMetaData().getColumnType(q));
                                    rsmd.setAutoIncrement(p+q-1, cRowset.getMetaData().isAutoIncrement(q));
                                    rsmd.setCaseSensitive(p+q-1, cRowset.getMetaData().isCaseSensitive(q));
                                    rsmd.setCatalogName(p+q-1, cRowset.getMetaData().getCatalogName(q));
                                    rsmd.setColumnDisplaySize(p+q-1, cRowset.getMetaData().getColumnDisplaySize(q));
                                    rsmd.setColumnLabel(p+q-1, cRowset.getMetaData().getColumnLabel(q));
                                    rsmd.setColumnType(p+q-1, cRowset.getMetaData().getColumnType(q));
                                    rsmd.setColumnTypeName(p+q-1, cRowset.getMetaData().getColumnTypeName(q));
                                    rsmd.setCurrency(p+q-1,cRowset.getMetaData().isCurrency(q) );
                                    rsmd.setNullable(p+q-1, cRowset.getMetaData().isNullable(q));
                                    rsmd.setPrecision(p+q-1, cRowset.getMetaData().getPrecision(q));
                                    rsmd.setScale(p+q-1, cRowset.getMetaData().getScale(q));
                                    rsmd.setSchemaName(p+q-1, cRowset.getMetaData().getSchemaName(q));
                                    rsmd.setSearchable(p+q-1, cRowset.getMetaData().isSearchable(q));
                                    rsmd.setSigned(p+q-1, cRowset.getMetaData().isSigned(q));
                                }
                                else {
                                    --p;
                                }
                            }
                            crsTemp.insertRow();
                            crsTemp.moveToCurrentRow();

                        } else {
                            // since not equa12
                            // so do nothing
                        } //end if
                         // bool1 = cRowset.next();
                         }

                    } // end inner for
                     //bool2 = crsInternal.next();
                   }

                } //end outer for
                crsTemp.setMetaData(rsmd);
                crsTemp.setOriginal();

                // Now the join is done.
               // Make crsInternal = crsTemp, to be ready for next merge, if at all.

                int[] pCol = new int[matchColumnCount];
                for(int i=0; i&lt;matchColumnCount; i++)
                   pCol[i] = crsInternal.getMatchColumnIndexes()[i];

                crsInternal = (CachedRowSetImpl)crsTemp.createCopy();

                // Because we add the first rowset as crsInternal to the
                // merged rowset, so pCol will point to the Match column.
                // until reset, am not sure we should set this or not(?)
                // if this is not set next inner join won't happen
                // if we explicitly do not set a set MatchColumn of
                // the new crsInternal.

                crsInternal.setMatchColumn(pCol);
                // Add the merged rowset to the class variable of type vector.
                crsInternal.setMetaData(rsmd);
                vecRowSetsInJOIN.add(cRowset);
            } //end if
        } catch(SQLException sqle) {
            // %%% Exception should not dump here:
            sqle.printStackTrace();
            throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.initerror&quot;).toString() + sqle);
        } catch (Exception e) {
            e.printStackTrace();
            throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.genericerr&quot;).toString() + e);
        }
    }

    /**
     * Return a SQL-like description of the &lt;code&gt;WHERE&lt;/code&gt; clause being used
     * in a &lt;code&gt;JoinRowSet&lt;/code&gt; object instance. An implementation can describe
     * the &lt;code&gt;WHERE&lt;/code&gt; clause of the SQL &lt;code&gt;JOIN&lt;/code&gt; by supplying a &lt;code&gt;SQL&lt;/code&gt;
     * strings description of &lt;code&gt;JOIN&lt;/code&gt; or provide a textual description to assist
     * applications using a &lt;code&gt;JoinRowSet&lt;/code&gt;.
     *
     * @return whereClause a textual or SQL descripition of the logical
     * &lt;code&gt;WHERE&lt;/code&gt; cluase used in the &lt;code&gt;JoinRowSet&lt;/code&gt; instance
     * @throws SQLException if an error occurs in generating a representation
     * of the &lt;code&gt;WHERE&lt;/code&gt; clause.
     */
    public String getWhereClause() throws SQLException {

       String strWhereClause = &quot;Select &quot;;
       String whereClause;
       String tabName= &quot;&quot;;
       String strTabName = &quot;&quot;;
       int sz,cols;
       int j;
       CachedRowSetImpl crs;

       // get all the column(s) names from each rowset.
       // append them with their tablenames i.e. tableName.columnName
       // Select tableName1.columnName1,..., tableNameX.columnNameY
       // from tableName1,...tableNameX where
       // tableName1.(rowset1.getMatchColumnName()) ==
       // tableName2.(rowset2.getMatchColumnName()) + &quot;and&quot; +
       // tableNameX.(rowsetX.getMatchColumnName()) ==
       // tableNameZ.(rowsetZ.getMatchColumnName()));

       sz = vecRowSetsInJOIN.size();
       for(int i=0;i&lt;sz; i++) {
          crs = vecRowSetsInJOIN.get(i);
          cols = crs.getMetaData().getColumnCount();
          tabName = tabName.concat(crs.getTableName());
          strTabName = strTabName.concat(tabName+&quot;, &quot;);
          j = 1;
          while(j&lt;cols) {

            strWhereClause = strWhereClause.concat
                (tabName+&quot;.&quot;+crs.getMetaData().getColumnName(j++));
            strWhereClause = strWhereClause.concat(&quot;, &quot;);
          } //end while
        } //end for


        // now remove the last &quot;,&quot;
        strWhereClause = strWhereClause.substring
             (0, strWhereClause.lastIndexOf(&quot;,&quot;));

        // Add from clause
        strWhereClause = strWhereClause.concat(&quot; from &quot;);

        // Add the table names.
        strWhereClause = strWhereClause.concat(strTabName);

        //Remove the last &quot;,&quot;
        strWhereClause = strWhereClause.substring
             (0, strWhereClause.lastIndexOf(&quot;,&quot;));

        // Add the where clause
        strWhereClause = strWhereClause.concat(&quot; where &quot;);

        // Get the match columns
        // rowset1.getMatchColumnName() == rowset2.getMatchColumnName()
         for(int i=0;i&lt;sz; i++) {
             strWhereClause = strWhereClause.concat(
               vecRowSetsInJOIN.get(i).getMatchColumnNames()[0]);
             if(i%2!=0) {
               strWhereClause = strWhereClause.concat(&quot;=&quot;);
             }  else {
               strWhereClause = strWhereClause.concat(&quot; and&quot;);
             }
          strWhereClause = strWhereClause.concat(&quot; &quot;);
         }

        return strWhereClause;
    }


    /**
     * Moves the cursor down one row from its current position and
     * returns &lt;code&gt;true&lt;/code&gt; if the new cursor position is a
     * valid row.
     * The cursor for a new &lt;code&gt;ResultSet&lt;/code&gt; object is initially
     * positioned before the first row. The first call to the method
     * &lt;code&gt;next&lt;/code&gt; moves the cursor to the first row, making it
     * the current row; the second call makes the second row the
     * current row, and so on.
     *
     * &lt;P&gt;If an input stream from the previous row is open, it is
     * implicitly closed. The &lt;code&gt;ResultSet&lt;/code&gt; object's warning
     * chain is cleared when a new row is read.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the new current row is valid;
     *         &lt;code&gt;false&lt;/code&gt; if there are no more rows
     * @throws SQLException if an error occurs or
     *            the cursor is not positioned in the rowset, before
     *            the first row, or after the last row
     */
    public boolean next() throws SQLException {
        return crsInternal.next();
    }


    /**
     * Releases the current contents of this rowset, discarding  outstanding
     * updates.  The rowset contains no rows after the method
     * &lt;code&gt;release&lt;/code&gt; is called. This method sends a
     * &lt;code&gt;RowSetChangedEvent&lt;/code&gt; object to all registered listeners prior
     * to returning.
     *
     * @throws SQLException if an error occurs
     */
    public void close() throws SQLException {
        crsInternal.close();
    }


    /**
     * Reports whether the last column read was SQL &lt;code&gt;NULL&lt;/code&gt;.
     * Note that you must first call the method &lt;code&gt;getXXX&lt;/code&gt;
     * on a column to try to read its value and then call the method
     * &lt;code&gt;wasNull&lt;/code&gt; to determine whether the value was
     * SQL &lt;code&gt;NULL&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the value in the last column read
     *         was SQL &lt;code&gt;NULL&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise
     * @throws SQLException if an error occurs
     */
    public boolean wasNull() throws SQLException {
        return crsInternal.wasNull();
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;String&lt;/code&gt; object.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds or
     *            the cursor is not on a valid row
     */
    public String getString(int columnIndex) throws SQLException {
        return crsInternal.getString(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;boolean&lt;/code&gt; value.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;false&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public boolean getBoolean(int columnIndex) throws SQLException {
        return crsInternal.getBoolean(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;byte&lt;/code&gt; value.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public byte getByte(int columnIndex) throws SQLException {
        return crsInternal.getByte(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
             * &lt;code&gt;short&lt;/code&gt; value.
             *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public short getShort(int columnIndex) throws SQLException {
        return crsInternal.getShort(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;short&lt;/code&gt; value.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public int getInt(int columnIndex) throws SQLException {
        return crsInternal.getInt(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;long&lt;/code&gt; value.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public long getLong(int columnIndex) throws SQLException {
        return crsInternal.getLong(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;float&lt;/code&gt; value.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public float getFloat(int columnIndex) throws SQLException {
        return crsInternal.getFloat(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;double&lt;/code&gt; value.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public double getDouble(int columnIndex) throws SQLException {
        return crsInternal.getDouble(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
     * &lt;P&gt;
     * This method is deprecated; use the version of &lt;code&gt;getBigDecimal&lt;/code&gt;
     * that does not take a scale parameter and returns a value with full
     * precision.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @param scale the number of digits to the right of the decimal point in the
     *        value returned
     * @return the column value with the specified number of digits to the right
     *         of the decimal point; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     * @deprecated
     */
    @Deprecated
    public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
        return crsInternal.getBigDecimal(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;byte array&lt;/code&gt; value.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or the the value to be
     *            retrieved is not binary
     */
    public byte[] getBytes(int columnIndex) throws SQLException {
        return crsInternal.getBytes(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.sql.Date&lt;/code&gt; object.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public java.sql.Date getDate(int columnIndex) throws SQLException {
        return crsInternal.getDate(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.sql.Time&lt;/code&gt; object.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public java.sql.Time getTime(int columnIndex) throws SQLException {
        return crsInternal.getTime(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public java.sql.Timestamp getTimestamp(int columnIndex) throws SQLException {
        return crsInternal.getTimestamp(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public java.io.InputStream getAsciiStream(int columnIndex) throws SQLException {
        return crsInternal.getAsciiStream(columnIndex);
    }

    /**
     * A column value can be retrieved as a stream of Unicode characters
     * and then read in chunks from the stream.  This method is particularly
     * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
     * do any necessary conversion from the database format into Unicode.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
     * read prior to getting the value of any other column. The next
     * call to a get method implicitly closes the stream. . Also, a
     * stream may return 0 for available() whether there is data
     * available or not.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @return a Java input stream that delivers the database column value
     * as a stream of two byte Unicode characters.  If the value is SQL NULL
     * then the result is null.
     * @throws SQLException if an error occurs
     * @deprecated
     */
    @Deprecated
    public java.io.InputStream getUnicodeStream(int columnIndex) throws SQLException {
        return crsInternal.getUnicodeStream(columnIndex);
    }

    /**
     * A column value can be retrieved as a stream of uninterpreted bytes
     * and then read in chunks from the stream.  This method is particularly
     * suitable for retrieving large LONGVARBINARY values.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
     * read prior to getting the value of any other column. The next
     * call to a get method implicitly closes the stream. Also, a
     * stream may return 0 for available() whether there is data
     * available or not.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return a Java input stream that delivers the database column value
     * as a stream of uninterpreted bytes.  If the value is SQL NULL
     * then the result is null.
     * @throws SQLException if an error occurs
     */
    public java.io.InputStream getBinaryStream(int columnIndex) throws SQLException {
        return crsInternal.getBinaryStream(columnIndex);
    }

    // ColumnName methods

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;String&lt;/code&gt; object.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public String getString(String columnName) throws SQLException {
        return crsInternal.getString(columnName);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;boolean&lt;/code&gt; value.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;false&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public boolean getBoolean(String columnName) throws SQLException {
        return crsInternal.getBoolean(columnName);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;byte&lt;/code&gt; value.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public byte getByte(String columnName) throws SQLException {
        return crsInternal.getByte(columnName);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;short&lt;/code&gt; value.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public short getShort(String columnName) throws SQLException {
        return crsInternal.getShort(columnName);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as an &lt;code&gt;int&lt;/code&gt; value.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public int getInt(String columnName) throws SQLException {
        return crsInternal.getInt(columnName);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;long&lt;/code&gt; value.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public long getLong(String columnName) throws SQLException {
        return crsInternal.getLong(columnName);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;float&lt;/code&gt; value.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public float getFloat(String columnName) throws SQLException {
        return crsInternal.getFloat(columnName);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;double&lt;/code&gt; value.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public double getDouble(String columnName) throws SQLException {
        return crsInternal.getDouble(columnName);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @param scale the number of digits to the right of the decimal point
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     * @deprecated use the method &lt;code&gt;getBigDecimal(String columnName)&lt;/code&gt;
     *             instead
     */
    @Deprecated
    public BigDecimal getBigDecimal(String columnName, int scale) throws SQLException {
        return crsInternal.getBigDecimal(columnName);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a byte array.
     * The bytes represent the raw values returned by the driver.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public byte[] getBytes(String columnName) throws SQLException {
        return crsInternal.getBytes(columnName);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.sql.Date&lt;/code&gt; object.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public java.sql.Date getDate(String columnName) throws SQLException {
        return crsInternal.getDate(columnName);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.sql.Time&lt;/code&gt; object.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public java.sql.Time getTime(String columnName) throws SQLException {
        return crsInternal.getTime(columnName);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public java.sql.Timestamp getTimestamp(String columnName) throws SQLException {
        return crsInternal.getTimestamp(columnName);
    }

    /**
     * This method is not supported, and it will throw an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if it is called.
     * &lt;P&gt;
     * A column value can be retrieved as a stream of ASCII characters
     * and then read in chunks from the stream.  This method is particularly
     * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
     * do any necessary conversion from the database format into ASCII format.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
     * be read prior to getting the value of any other column. The
     * next call to a &lt;code&gt;getXXX&lt;/code&gt; method implicitly closes the stream.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return a Java input stream that delivers the database column value
     *         as a stream of one-byte ASCII characters.  If the value is SQL
     *         &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
     * @throws UnsupportedOperationException if this method is called
     */
    public java.io.InputStream getAsciiStream(String columnName) throws SQLException {
        return crsInternal.getAsciiStream(columnName);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
     * A column value can be retrieved as a stream of Unicode characters
     * and then read in chunks from the stream.  This method is particularly
     * suitable for retrieving large &lt;code&gt;LONGVARCHAR&lt;/code&gt; values.
     * The JDBC driver will do any necessary conversion from the database
     * format into Unicode.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
     * be read prior to getting the value of any other column. The
     * next call to a &lt;code&gt;getXXX&lt;/code&gt; method implicitly closes the stream.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return a Java input stream that delivers the database column value
     *         as a stream of two-byte Unicode characters.  If the value is
     *         SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     * @deprecated use the method &lt;code&gt;getCharacterStream&lt;/code&gt; instead
     */
    @Deprecated
    public java.io.InputStream getUnicodeStream(String columnName) throws SQLException {
        return crsInternal.getUnicodeStream(columnName);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
     * A column value can be retrieved as a stream of uninterpreted bytes
     * and then read in chunks from the stream.  This method is particularly
     * suitable for retrieving large &lt;code&gt;LONGVARBINARY&lt;/code&gt; values.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
     * be read prior to getting the value of any other column. The
     * next call to a get method implicitly closes the stream.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return a Java input stream that delivers the database column value
     *         as a stream of uninterpreted bytes.  If the value is SQL
     *         &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public java.io.InputStream getBinaryStream(String columnName) throws SQLException {
        return crsInternal.getBinaryStream(columnName);
    }

    /* The first warning reported by calls on this &lt;code&gt;JoinRowSetImpl&lt;/code&gt;
     * object is returned. Subsequent &lt;code&gt;JoinRowSetImpl&lt;/code&gt; warnings will
     * be chained to this &lt;code&gt;SQLWarning&lt;/code&gt;.
     *
     * &lt;P&gt;The warning chain is automatically cleared each time a new
     * row is read.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This warning chain only covers warnings caused
     * by &lt;code&gt;ResultSet&lt;/code&gt; methods.  Any warning caused by statement
     * methods (such as reading OUT parameters) will be chained on the
     * &lt;code&gt;Statement&lt;/code&gt; object.
     *
     * @return the first SQLWarning or null
     * @throws UnsupportedOperationException if this method is called
     */
    public SQLWarning getWarnings() {
        return crsInternal.getWarnings();
    }

    /**
     * Throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if called.
     * &lt;P&gt;
     * After a call to this method, the &lt;code&gt;getWarnings&lt;/code&gt; method
     * returns &lt;code&gt;null&lt;/code&gt; until a new warning is reported for this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
     *
     * @throws UnsupportedOperationException if this method is called
     */
     public void clearWarnings() {
        crsInternal.clearWarnings();
    }

    /**
     * Retrieves the name of the SQL cursor used by this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
     *
     * &lt;P&gt;In SQL, a result table is retrieved through a cursor that is
     * named. The current row of a result can be updated or deleted
     * using a positioned update/delete statement that references the
     * cursor name. To insure that the cursor has the proper isolation
     * level to support an update operation, the cursor's &lt;code&gt;SELECT&lt;/code&gt;
     * statement should be of the form 'select for update'. If the 'for update'
     * clause is omitted, positioned updates may fail.
     *
     * &lt;P&gt;JDBC supports this SQL feature by providing the name of the
     * SQL cursor used by a &lt;code&gt;ResultSet&lt;/code&gt; object. The current row
     * of a result set is also the current row of this SQL cursor.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; If positioned updates are not supported, an
     * &lt;code&gt;SQLException&lt;/code&gt; is thrown.
     *
     * @return the SQL cursor name for this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's
     *         cursor
     * @throws SQLException if an error occurs
     */
    public String getCursorName() throws SQLException {
        return crsInternal.getCursorName();
    }

    /**
     * Retrieves the &lt;code&gt;ResultSetMetaData&lt;/code&gt; object that contains
     * information about this &lt;code&gt;CachedRowsSet&lt;/code&gt; object. The
     * information includes the number of columns, the data type for each
     * column, and other properties for each column.
     *
     * @return the &lt;code&gt;ResultSetMetaData&lt;/code&gt; object that describes this
     *         &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's columns
     * @throws SQLException if an error occurs
     */
    public ResultSetMetaData getMetaData() throws SQLException {
        return crsInternal.getMetaData();
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as an
     * &lt;code&gt;Object&lt;/code&gt; value.
     * &lt;P&gt;
     * The type of the &lt;code&gt;Object&lt;/code&gt; will be the default
     * Java object type corresponding to the column's SQL type,
     * following the mapping for built-in types specified in the JDBC
     * specification.
     * &lt;P&gt;
     * This method may also be used to read datatabase-specific
     * abstract data types.
     * &lt;P&gt;
     * This implementation of the method &lt;code&gt;getObject&lt;/code&gt; extends its
     * behavior so that it gets the attributes of an SQL structured type as
     * as an array of &lt;code&gt;Object&lt;/code&gt; values.  This method also custom
     * maps SQL user-defined types to classes in the Java programming language.
     * When the specified column contains
     * a structured or distinct value, the behavior of this method is as
     * if it were a call to the method &lt;code&gt;getObject(columnIndex,
     * this.getStatement().getConnection().getTypeMap())&lt;/code&gt;.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return a &lt;code&gt;java.lang.Object&lt;/code&gt; holding the column value;
     *         if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or there is a problem getting
     *            the &lt;code&gt;Class&lt;/code&gt; object for a custom mapping
     * @since 1.2
     */
    public Object getObject(int columnIndex) throws SQLException {
        return crsInternal.getObject(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as an
     * &lt;code&gt;Object&lt;/code&gt; value.
     * &lt;P&gt;
     * The type of the &lt;code&gt;Object&lt;/code&gt; will be the default
     * Java object type corresponding to the column's SQL type,
     * following the mapping for built-in types specified in the JDBC
     * specification.
     * &lt;P&gt;
     * This method may also be used to read datatabase-specific
     * abstract data types.
     * &lt;P&gt;
     * This implementation of the method &lt;code&gt;getObject&lt;/code&gt; extends its
     * behavior so that it gets the attributes of an SQL structured type as
     * as an array of &lt;code&gt;Object&lt;/code&gt; values.  This method also custom
     * maps SQL user-defined types to classes
     * in the Java programming language. When the specified column contains
     * a structured or distinct value, the behavior of this method is as
     * if it were a call to the method &lt;code&gt;getObject(columnIndex,
     * this.getStatement().getConnection().getTypeMap())&lt;/code&gt;.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *         is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *         and equal to or less than the number of columns in the rowset
     * @param map a &lt;code&gt;java.util.Map&lt;/code&gt; object showing the mapping
     *         from SQL type names to classes in the Java programming
     *         language
     * @return a &lt;code&gt;java.lang.Object&lt;/code&gt; holding the column value;
     *         if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is
     *         &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name does not match
     *         one of this rowset's column names, (2) the cursor is not
     *         on a valid row, or (3) there is a problem getting
     *         the &lt;code&gt;Class&lt;/code&gt; object for a custom mapping
     */
    public Object getObject(int columnIndex,
                            java.util.Map&lt;String,Class&lt;?&gt;&gt; map)
    throws SQLException {
        return crsInternal.getObject(columnIndex, map);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as an
     * &lt;code&gt;Object&lt;/code&gt; value.
     * &lt;P&gt;
     * The type of the &lt;code&gt;Object&lt;/code&gt; will be the default
     * Java object type corresponding to the column's SQL type,
     * following the mapping for built-in types specified in the JDBC
     * specification.
     * &lt;P&gt;
     * This method may also be used to read datatabase-specific
     * abstract data types.
     * &lt;P&gt;
     * This implementation of the method &lt;code&gt;getObject&lt;/code&gt; extends its
     * behavior so that it gets the attributes of an SQL structured type as
     * as an array of &lt;code&gt;Object&lt;/code&gt; values.  This method also custom
     * maps SQL user-defined types to classes
     * in the Java programming language. When the specified column contains
     * a structured or distinct value, the behavior of this method is as
     * if it were a call to the method &lt;code&gt;getObject(columnIndex,
     * this.getStatement().getConnection().getTypeMap())&lt;/code&gt;.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @return a &lt;code&gt;java.lang.Object&lt;/code&gt; holding the column value;
     *        if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is
     *        &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name does not match
     *        one of this rowset's column names, (2) the cursor is not
     *        on a valid row, or (3) there is a problem getting
     *        the &lt;code&gt;Class&lt;/code&gt; object for a custom mapping
     */
    public Object getObject(String columnName) throws SQLException {
        return crsInternal.getObject(columnName);
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as an &lt;code&gt;Object&lt;/code&gt; in
     * the Java programming lanugage, using the given
     * &lt;code&gt;java.util.Map&lt;/code&gt; object to custom map the value if
     * appropriate.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param map a &lt;code&gt;java.util.Map&lt;/code&gt; object showing the mapping
     *            from SQL type names to classes in the Java programming
     *            language
     * @return an &lt;code&gt;Object&lt;/code&gt; representing the SQL value
     * @throws SQLException if the given column index is out of bounds or
     *            the cursor is not on one of this rowset's rows or its
     *            insert row
     */
    public Object getObject(String columnName,
                            java.util.Map&lt;String,Class&lt;?&gt;&gt; map)
        throws SQLException {
        return crsInternal.getObject(columnName, map);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.io.Reader&lt;/code&gt; object.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
     * be read prior to getting the value of any other column. The
     * next call to a &lt;code&gt;getXXX&lt;/code&gt; method implicitly closes the stream.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return a Java character stream that delivers the database column value
     *         as a &lt;code&gt;java.io.Reader&lt;/code&gt; object.  If the value is
     *         SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or there is a type mismatch
     */
    public java.io.Reader getCharacterStream(int columnIndex) throws SQLException {
        return crsInternal.getCharacterStream(columnIndex);
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.io.Reader&lt;/code&gt; object.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
     * be read prior to getting the value of any other column. The
     * next call to a &lt;code&gt;getXXX&lt;/code&gt; method implicitly closes the stream.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return a Java input stream that delivers the database column value
     *         as a stream of two-byte Unicode characters.  If the value is
     *         SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or there is a type mismatch
     */
    public java.io.Reader getCharacterStream(String columnName) throws SQLException {
        return crsInternal.getCharacterStream(columnName);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return a &lt;code&gt;java.math.BigDecimal&lt;/code&gt; value with full precision;
     *         if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
       return crsInternal.getBigDecimal(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @return a &lt;code&gt;java.math.BigDecimal&lt;/code&gt; value with full precision;
     *         if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public BigDecimal getBigDecimal(String columnName) throws SQLException {
       return crsInternal.getBigDecimal(columnName);
    }

    /**
     * Returns the number of rows in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
     *
     * @return number of rows in the rowset
     */
    public int size() {
        return crsInternal.size();
    }

    /**
     * Indicates whether the cursor is before the first row in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is before the first row;
     *         &lt;code&gt;false&lt;/code&gt; otherwise or if the rowset contains no rows
     * @throws SQLException if an error occurs
     */
    public boolean isBeforeFirst() throws SQLException {
        return crsInternal.isBeforeFirst();
    }

    /**
     * Indicates whether the cursor is after the last row in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is after the last row;
     *         &lt;code&gt;false&lt;/code&gt; otherwise or if the rowset contains no rows
     * @throws SQLException if an error occurs
     */
    public boolean isAfterLast() throws SQLException {
        return crsInternal.isAfterLast();
    }

    /**
     * Indicates whether the cursor is on the first row in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on the first row;
     *         &lt;code&gt;false&lt;/code&gt; otherwise or if the rowset contains no rows
     * @throws SQLException if an error occurs
     */
    public boolean isFirst() throws SQLException {
        return crsInternal.isFirst();
    }

    /**
     * Indicates whether the cursor is on the last row in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
     * &lt;P&gt;
     * Note: Calling the method &lt;code&gt;isLast&lt;/code&gt; may be expensive
     * because the JDBC driver might need to fetch ahead one row in order
     * to determine whether the current row is the last row in this rowset.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on the last row;
     *         &lt;code&gt;false&lt;/code&gt; otherwise or if this rowset contains no rows
     * @throws SQLException if an error occurs
     */
    public boolean isLast() throws SQLException {
        return crsInternal.isLast();
    }

    /**
     * Moves this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's cursor to the front of
     * the rowset, just before the first row. This method has no effect if
     * this rowset contains no rows.
     *
     * @throws SQLException if an error occurs or the type of this rowset
     *            is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
     */
    public void beforeFirst() throws SQLException {
        crsInternal.beforeFirst();
    }

    /**
     * Moves this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's cursor to the end of
     * the rowset, just after the last row. This method has no effect if
     * this rowset contains no rows.
     *
     * @throws SQLException if an error occurs
     */
    public void afterLast() throws SQLException {
        crsInternal.afterLast();
    }

    /**
     * Moves this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's cursor to the first row
     * and returns &lt;code&gt;true&lt;/code&gt; if the operation was successful.  This
     * method also notifies registered listeners that the cursor has moved.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on a valid row;
     *         &lt;code&gt;false&lt;/code&gt; otherwise or if there are no rows in this
     *         &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @throws SQLException if the type of this rowset
     *            is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
     */
    public boolean first() throws SQLException {
        return crsInternal.first();
    }


    /**
     * Moves this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's cursor to the last row
     * and returns &lt;code&gt;true&lt;/code&gt; if the operation was successful.  This
     * method also notifies registered listeners that the cursor has moved.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on a valid row;
     *         &lt;code&gt;false&lt;/code&gt; otherwise or if there are no rows in this
     *         &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @throws SQLException if the type of this rowset
     *            is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
     */
    public boolean last() throws SQLException {
        return crsInternal.last();
    }

    /**
     * Returns the number of the current row in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt;
     * object. The first row is number 1, the second number 2, and so on.
     *
     * @return the number of the current row;  &lt;code&gt;0&lt;/code&gt; if there is no
     *         current row
     * @throws SQLException if an error occurs
     */
    public int getRow() throws SQLException {
        return crsInternal.getRow();
    }

    /**
     * Moves this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's cursor to the row number
     * specified.
     *
     * &lt;p&gt;If the number is positive, the cursor moves to an absolute row with
     * respect to the beginning of the rowset.  The first row is row 1, the second
     * is row 2, and so on.  For example, the following command, in which
     * &lt;code&gt;crs&lt;/code&gt; is a &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object, moves the cursor
     * to the fourth row, starting from the beginning of the rowset.
     * &lt;PRE&gt;&lt;code&gt;
     *
     *    crs.absolute(4);
     *
     * &lt;/code&gt; &lt;/PRE&gt;
     * &lt;P&gt;
     * If the number is negative, the cursor moves to an absolute row position
     * with respect to the end of the rowset.  For example, calling
     * &lt;code&gt;absolute(-1)&lt;/code&gt; positions the cursor on the last row,
     * &lt;code&gt;absolute(-2)&lt;/code&gt; moves it on the next-to-last row, and so on.
     * If the &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object &lt;code&gt;crs&lt;/code&gt; has five rows,
     * the following command moves the cursor to the fourth-to-last row, which
     * in the case of a  rowset with five rows, is also the second row, counting
     * from the beginning.
     * &lt;PRE&gt;&lt;code&gt;
     *
     *    crs.absolute(-4);
     *
     * &lt;/code&gt; &lt;/PRE&gt;
     *
     * If the number specified is larger than the number of rows, the cursor
     * will move to the position after the last row. If the number specified
     * would move the cursor one or more rows before the first row, the cursor
     * moves to the position before the first row.
     * &lt;P&gt;
     * Note: Calling &lt;code&gt;absolute(1)&lt;/code&gt; is the same as calling the
     * method &lt;code&gt;first()&lt;/code&gt;.  Calling &lt;code&gt;absolute(-1)&lt;/code&gt; is the
     * same as calling &lt;code&gt;last()&lt;/code&gt;.
     *
     * @param row a positive number to indicate the row, starting row numbering from
     *        the first row, which is &lt;code&gt;1&lt;/code&gt;; a negative number to indicate
     *        the row, starting row numbering from the last row, which is
     *        &lt;code&gt;-1&lt;/code&gt;; must not be &lt;code&gt;0&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on the rowset; &lt;code&gt;false&lt;/code&gt;
     *         otherwise
     * @throws SQLException if the given cursor position is &lt;code&gt;0&lt;/code&gt; or the
     *            type of this rowset is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
     */
    public boolean absolute(int row) throws SQLException {
        return crsInternal.absolute(row);
    }

    /**
     * Moves the cursor the specified number of rows from the current
     * position, with a positive number moving it forward and a
     * negative number moving it backward.
     * &lt;P&gt;
     * If the number is positive, the cursor moves the specified number of
     * rows toward the end of the rowset, starting at the current row.
     * For example, the following command, in which
     * &lt;code&gt;crs&lt;/code&gt; is a &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with 100 rows,
     * moves the cursor forward four rows from the current row.  If the
     * current row is 50, the cursor would move to row 54.
     * &lt;PRE&gt;&lt;code&gt;
     *
     *    crs.relative(4);
     *
     * &lt;/code&gt; &lt;/PRE&gt;
     * &lt;P&gt;
     * If the number is negative, the cursor moves back toward the beginning
     * the specified number of rows, starting at the current row.
     * For example, calling the method
     * &lt;code&gt;absolute(-1)&lt;/code&gt; positions the cursor on the last row,
     * &lt;code&gt;absolute(-2)&lt;/code&gt; moves it on the next-to-last row, and so on.
     * If the &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object &lt;code&gt;crs&lt;/code&gt; has five rows,
     * the following command moves the cursor to the fourth-to-last row, which
     * in the case of a  rowset with five rows, is also the second row
     * from the beginning.
     * &lt;PRE&gt;&lt;code&gt;
     *
     *    crs.absolute(-4);
     *
     * &lt;/code&gt; &lt;/PRE&gt;
     *
     * If the number specified is larger than the number of rows, the cursor
     * will move to the position after the last row. If the number specified
     * would move the cursor one or more rows before the first row, the cursor
     * moves to the position before the first row. In both cases, this method
     * throws an &lt;code&gt;SQLException&lt;/code&gt;.
     * &lt;P&gt;
     * Note: Calling &lt;code&gt;absolute(1)&lt;/code&gt; is the same as calling the
     * method &lt;code&gt;first()&lt;/code&gt;.  Calling &lt;code&gt;absolute(-1)&lt;/code&gt; is the
     * same as calling &lt;code&gt;last()&lt;/code&gt;.  Calling &lt;code&gt;relative(0)&lt;/code&gt;
     * is valid, but it does not change the cursor position.
     *
     * @param rows an &lt;code&gt;int&lt;/code&gt; indicating the number of rows to move
     *             the cursor, starting at the current row; a positive number
     *             moves the cursor forward; a negative number moves the cursor
     *             backward; must not move the cursor past the valid
     *             rows
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on a row in this
     *         &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object; &lt;code&gt;false&lt;/code&gt;
     *         otherwise
     * @throws SQLException if there are no rows in this rowset, the cursor is
     *         positioned either before the first row or after the last row, or
     *         the rowset is type &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
     */
    public boolean relative(int rows) throws SQLException {
        return crsInternal.relative(rows);
    }

    /**
     * Moves this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's cursor to the
     * previous row and returns &lt;code&gt;true&lt;/code&gt; if the cursor is on
     * a valid row or &lt;code&gt;false&lt;/code&gt; if it is not.
     * This method also notifies all listeners registered with this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object that its cursor has moved.
     * &lt;P&gt;
     * Note: calling the method &lt;code&gt;previous()&lt;/code&gt; is not the same
     * as calling the method &lt;code&gt;relative(-1)&lt;/code&gt;.  This is true
     * because it is possible to call &lt;code&gt;previous()&lt;/code&gt; from the insert
     * row, from after the last row, or from the current row, whereas
     * &lt;code&gt;relative&lt;/code&gt; may only be called from the current row.
     * &lt;P&gt;
     * The method &lt;code&gt;previous&lt;/code&gt; may used in a &lt;code&gt;while&lt;/code&gt;
     * loop to iterate through a rowset starting after the last row
     * and moving toward the beginning. The loop ends when &lt;code&gt;previous&lt;/code&gt;
     * returns &lt;code&gt;false&lt;/code&gt;, meaning that there are no more rows.
     * For example, the following code fragment retrieves all the data in
     * the &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object &lt;code&gt;crs&lt;/code&gt;, which has
     * three columns.  Note that the cursor must initially be positioned
     * after the last row so that the first call to the method
     * &lt;code&gt;previous&lt;/code&gt; places the cursor on the last line.
     * &lt;PRE&gt; &lt;code&gt;
     *
     *     crs.afterLast();
     *     while (previous()) {
     *         String name = crs.getString(1);
     *         int age = crs.getInt(2);
     *         short ssn = crs.getShort(3);
     *         System.out.println(name + &quot;   &quot; + age + &quot;   &quot; + ssn);
     *     }
     *
     * &lt;/code&gt; &lt;/PRE&gt;
     * This method throws an &lt;code&gt;SQLException&lt;/code&gt; if the cursor is not
     * on a row in the rowset, before the first row, or after the last row.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on a valid row;
     *         &lt;code&gt;false&lt;/code&gt; if it is before the first row or after the
     *         last row
     * @throws SQLException if the cursor is not on a valid position or the
     *           type of this rowset is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
     */
    public boolean previous() throws SQLException {
        return crsInternal.previous();
    }

    /**
     * Returns the index of the column whose name is &lt;i&gt;columnName&lt;/i&gt;.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the name of the
     *        column for which the index will be returned; the name must
     *        match the SQL name of a column in this &lt;code&gt;JoinRowSet&lt;/code&gt;
     *        object, ignoring case
     * @throws SQLException if the given column name does not match one of the
     *         column names for this &lt;code&gt;JoinRowSet&lt;/code&gt; object
     */
    public int findColumn(String columnName) throws SQLException {
        return crsInternal.findColumn(columnName);
    }

    /**
     * Indicates whether the current row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt;
     * object has been updated.  The value returned
     * depends on whether this rowset can detect updates: &lt;code&gt;false&lt;/code&gt;
     * will always be returned if it does not detect updates.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the row has been visibly updated
     *         by the owner or another and updates are detected;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @throws SQLException if the cursor is on the insert row or not
     *            on a valid row
     *
     * @see DatabaseMetaData#updatesAreDetected
     */
    public boolean rowUpdated() throws SQLException {
        return crsInternal.rowUpdated();
    }

    /**
     * Indicates whether the designated column of the current row of
     * this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object has been updated. The
     * value returned depends on whether this rowset can detcted updates:
     * &lt;code&gt;false&lt;/code&gt; will always be returned if it does not detect updates.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the column updated
     *          &lt;code&gt;false&lt;/code&gt; otherwse
     * @throws SQLException if the cursor is on the insert row or not
     *          on a valid row
     * @see DatabaseMetaData#updatesAreDetected
     */
    public boolean columnUpdated(int indexColumn) throws SQLException {
        return crsInternal.columnUpdated(indexColumn);
    }

    /**
     * Indicates whether the current row has been inserted.  The value returned
     * depends on whether or not the rowset can detect visible inserts.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if a row has been inserted and inserts are detected;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @throws SQLException if the cursor is on the insert row or not
     *            not on a valid row
     *
     * @see DatabaseMetaData#insertsAreDetected
     */
    public boolean rowInserted() throws SQLException {
        return crsInternal.rowInserted();
    }

    /**
     * Indicates whether the current row has been deleted.  A deleted row
     * may leave a visible &quot;hole&quot; in a rowset.  This method can be used to
     * detect such holes if the rowset can detect deletions. This method
     * will always return &lt;code&gt;false&lt;/code&gt; if this rowset cannot detect
     * deletions.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if (1)the current row is blank, indicating that
     *         the row has been deleted, and (2)deletions are detected;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @throws SQLException if the cursor is on a valid row in this rowset
     * @see DatabaseMetaData#deletesAreDetected
     */
    public boolean rowDeleted() throws SQLException {
        return crsInternal.rowDeleted();
    }

    /**
     * Sets the designated nullable column in the current row or the
     * insert row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with
     * &lt;code&gt;null&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset; however, another method must be called to complete
     * the update process. If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to mark the row as updated
     * and to notify listeners that the row has changed.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called to insert the new row into this rowset and to notify
     * listeners that a row has changed.
     * &lt;P&gt;
     * In order to propagate updates in this rowset to the underlying
     * data source, an application must call the method acceptChanges
     * after it calls either &lt;code&gt;updateRow&lt;/code&gt; or &lt;code&gt;insertRow&lt;/code&gt;.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateNull(int columnIndex) throws SQLException {
        crsInternal.updateNull(columnIndex);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;boolean&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBoolean(int columnIndex, boolean x) throws SQLException {
        crsInternal.updateBoolean(columnIndex, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;byte&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateByte(int columnIndex, byte x) throws SQLException {
        crsInternal.updateByte(columnIndex, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;short&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateShort(int columnIndex, short x) throws SQLException {
        crsInternal.updateShort(columnIndex, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;int&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateInt(int columnIndex, int x) throws SQLException {
        crsInternal.updateInt(columnIndex, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;long&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateLong(int columnIndex, long x) throws SQLException {
        crsInternal.updateLong(columnIndex, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;float&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateFloat(int columnIndex, float x) throws SQLException {
        crsInternal.updateFloat(columnIndex, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;double&lt;/code&gt; value.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateDouble(int columnIndex, double x) throws SQLException {
        crsInternal.updateDouble(columnIndex, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
        crsInternal.updateBigDecimal(columnIndex, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;String&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to mark the row as updated.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called to insert the new row into this rowset and mark it
     * as inserted. Both of these methods must be called before the
     * cursor moves to another row.
     * &lt;P&gt;
     * The method &lt;code&gt;acceptChanges&lt;/code&gt; must be called if the
     * updated values are to be written back to the underlying database.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateString(int columnIndex, String x) throws SQLException {
        crsInternal.updateString(columnIndex, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;byte&lt;/code&gt; array.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBytes(int columnIndex, byte x[]) throws SQLException {
        crsInternal.updateBytes(columnIndex, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Date&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, (3) the type of the designated column is not
     *            an SQL &lt;code&gt;DATE&lt;/code&gt; or &lt;code&gt;TIMESTAMP&lt;/code&gt;, or
     *            (4) this rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateDate(int columnIndex, java.sql.Date x) throws SQLException {
        crsInternal.updateDate(columnIndex, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Time&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, (3) the type of the designated column is not
     *            an SQL &lt;code&gt;TIME&lt;/code&gt; or &lt;code&gt;TIMESTAMP&lt;/code&gt;, or
     *            (4) this rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateTime(int columnIndex, java.sql.Time x) throws SQLException {
        crsInternal.updateTime(columnIndex, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Timestamp&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, (3) the type of the designated column is not
     *            an SQL &lt;code&gt;DATE&lt;/code&gt;, &lt;code&gt;TIME&lt;/code&gt;, or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateTimestamp(int columnIndex, java.sql.Timestamp x) throws SQLException {
        crsInternal.updateTimestamp(columnIndex, x);
    }

    /*
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * ASCII stream value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @param length the number of one-byte ASCII characters in the stream
     * @throws UnsupportedOperationException if this method is invoked
     */
    public void updateAsciiStream(int columnIndex, java.io.InputStream x, int length) throws SQLException {
        crsInternal.updateAsciiStream(columnIndex, x, length);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value; must be a &lt;code&gt;java.io.InputStream&lt;/code&gt;
     *          containing &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;, or
     *          &lt;code&gt;LONGVARBINARY&lt;/code&gt; data
     * @param length the length of the stream in bytes
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, (3) the data in the stream is not binary, or
     *            (4) this rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBinaryStream(int columnIndex, java.io.InputStream x, int length) throws SQLException {
        crsInternal.updateBinaryStream(columnIndex, x, length);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.io.Reader&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value; must be a &lt;code&gt;java.io.Reader&lt;/code&gt;
     *          containing &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;,
     *          &lt;code&gt;LONGVARBINARY&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;,
     *          or &lt;code&gt;LONGVARCHAR&lt;/code&gt; data
     * @param length the length of the stream in characters
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, (3) the data in the stream is not a binary or
     *            character type, or (4) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateCharacterStream(int columnIndex, java.io.Reader x, int length) throws SQLException {
        crsInternal.updateCharacterStream(columnIndex, x, length);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Object&lt;/code&gt; value.  The &lt;code&gt;scale&lt;/code&gt; parameter indicates
     * the number of digits to the right of the decimal point and is ignored
     * if the new column value is not a type that will be mapped to an SQL
     * &lt;code&gt;DECIMAL&lt;/code&gt; or &lt;code&gt;NUMERIC&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @param scale the number of digits to the right of the decimal point (for
     *              &lt;code&gt;DECIMAL&lt;/code&gt; and &lt;code&gt;NUMERIC&lt;/code&gt; types only)
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateObject(int columnIndex, Object x, int scale) throws SQLException {
        crsInternal.updateObject(columnIndex, x, scale);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Object&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateObject(int columnIndex, Object x) throws SQLException {
        crsInternal.updateObject(columnIndex, x);
    }

    // columnName updates

    /**
     * Sets the designated nullable column in the current row or the
     * insert row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with
     * &lt;code&gt;null&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateNull(String columnName) throws SQLException {
        crsInternal.updateNull(columnName);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;boolean&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBoolean(String columnName, boolean x) throws SQLException {
        crsInternal.updateBoolean(columnName, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;byte&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateByte(String columnName, byte x) throws SQLException {
        crsInternal.updateByte(columnName, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;short&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateShort(String columnName, short x) throws SQLException {
        crsInternal.updateShort(columnName, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;int&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateInt(String columnName, int x) throws SQLException {
        crsInternal.updateInt(columnName, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;long&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateLong(String columnName, long x) throws SQLException {
        crsInternal.updateLong(columnName, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;float&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateFloat(String columnName, float x) throws SQLException {
        crsInternal.updateFloat(columnName, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;double&lt;/code&gt; value.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateDouble(String columnName, double x) throws SQLException {
        crsInternal.updateDouble(columnName, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBigDecimal(String columnName, BigDecimal x) throws SQLException {
        crsInternal.updateBigDecimal(columnName, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;String&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateString(String columnName, String x) throws SQLException {
        crsInternal.updateString(columnName, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;byte&lt;/code&gt; array.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBytes(String columnName, byte x[]) throws SQLException {
        crsInternal.updateBytes(columnName, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Date&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, (3) the type
     *            of the designated column is not an SQL &lt;code&gt;DATE&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateDate(String columnName, java.sql.Date x) throws SQLException {
        crsInternal.updateDate(columnName, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Time&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, (3) the type
     *            of the designated column is not an SQL &lt;code&gt;TIME&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateTime(String columnName, java.sql.Time x) throws SQLException {
        crsInternal.updateTime(columnName, x);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Timestamp&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if the given column index is out of bounds or
     *            the cursor is not on one of this rowset's rows or its
     *            insert row
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, (3) the type
     *            of the designated column is not an SQL &lt;code&gt;DATE&lt;/code&gt;,
     *            &lt;code&gt;TIME&lt;/code&gt;, or &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateTimestamp(String columnName, java.sql.Timestamp x) throws SQLException {
        crsInternal.updateTimestamp(columnName, x);
    }

    /**
     * Unsupported; throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;
     * if called.
     * &lt;P&gt;
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * ASCII stream value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @param length the number of one-byte ASCII characters in the stream
     * @throws UnsupportedOperationException if this method is invoked
     */
    public void updateAsciiStream(String columnName, java.io.InputStream x, int length) throws SQLException {
        crsInternal.updateAsciiStream(columnName, x, length);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value; must be a &lt;code&gt;java.io.InputStream&lt;/code&gt;
     *          containing &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;, or
     *          &lt;code&gt;LONGVARBINARY&lt;/code&gt; data
     * @param length the length of the stream in bytes
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, (3) the data
     *            in the stream is not binary, or (4) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBinaryStream(String columnName, java.io.InputStream x, int length) throws SQLException {
        crsInternal.updateBinaryStream(columnName, x, length);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.io.Reader&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value; must be a &lt;code&gt;java.io.Reader&lt;/code&gt;
     *          containing &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;,
     *          &lt;code&gt;LONGVARBINARY&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;,
     *          or &lt;code&gt;LONGVARCHAR&lt;/code&gt; data
     * @param length the length of the stream in characters
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, (3) the data
     *            in the stream is not a binary or character type, or (4) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateCharacterStream(String columnName, java.io.Reader x, int length) throws SQLException {
        crsInternal.updateCharacterStream(columnName, x, length);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Object&lt;/code&gt; value.  The &lt;code&gt;scale&lt;/code&gt; parameter
     * indicates the number of digits to the right of the decimal point
     * and is ignored if the new column value is not a type that will be
     *  mapped to an SQL &lt;code&gt;DECIMAL&lt;/code&gt; or &lt;code&gt;NUMERIC&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @param scale the number of digits to the right of the decimal point (for
     *              &lt;code&gt;DECIMAL&lt;/code&gt; and &lt;code&gt;NUMERIC&lt;/code&gt; types only)
     * @throws SQLException if the given column index is out of bounds or
     *            the cursor is not on one of this rowset's rows or its
     *            insert row
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateObject(String columnName, Object x, int scale) throws SQLException {
        crsInternal.updateObject(columnName, x, scale);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Object&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateObject(String columnName, Object x) throws SQLException {
        crsInternal.updateObject(columnName, x);
    }

    /**
     * Inserts the contents of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's insert
     * row into this rowset immediately following the current row.
     * If the current row is the
     * position after the last row or before the first row, the new row will
     * be inserted at the end of the rowset.  This method also notifies
     * listeners registered with this rowset that the row has changed.
     * &lt;P&gt;
     * The cursor must be on the insert row when this method is called.
     *
     * @throws SQLException if (1) the cursor is not on the insert row,
     *            (2) one or more of the non-nullable columns in the insert
     *            row has not been given a value, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void insertRow() throws SQLException {
        crsInternal.insertRow();
    }

    /**
     * Marks the current row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as
     * updated and notifies listeners registered with this rowset that the
     * row has changed.
     * &lt;P&gt;
     * This method  cannot be called when the cursor is on the insert row, and
     * it should be called before the cursor moves to another row.  If it is
     * called after the cursor moves to another row, this method has no effect,
     * and the updates made before the cursor moved will be lost.
     *
     * @throws SQLException if the cursor is on the insert row or this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateRow() throws SQLException {
        crsInternal.updateRow();
    }

    /**
     * Deletes the current row from this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object and
     * notifies listeners registered with this rowset that a row has changed.
     * This method cannot be called when the cursor is on the insert row.
     * &lt;P&gt;
     * This method marks the current row as deleted, but it does not delete
     * the row from the underlying data source.  The method
     * &lt;code&gt;acceptChanges&lt;/code&gt; must be called to delete the row in
     * the data source.
     *
     * @throws SQLException if (1) this method is called when the cursor
     *            is on the insert row, before the first row, or after the
     *            last row or (2) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void deleteRow() throws SQLException {
        crsInternal.deleteRow();
    }

    /**
     * Sets the current row with its original value and marks the row as
     * not updated, thus undoing any changes made to the row since the
     * last call to the methods &lt;code&gt;updateRow&lt;/code&gt; or &lt;code&gt;deleteRow&lt;/code&gt;.
     * This method should be called only when the cursor is on a row in
     * this rowset.
     *
     * @throws SQLException if the cursor is on the insert row, before the
     *            first row, or after the last row
     */
    public void refreshRow() throws SQLException {
        crsInternal.refreshRow();
    }

    /**
     * Rolls back any updates made to the current row of this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object and notifies listeners that
     * a row has changed.  To have an effect, this method
     * must be called after an &lt;code&gt;updateXXX&lt;/code&gt; method has been
     * called and before the method &lt;code&gt;updateRow&lt;/code&gt; has been called.
     * If no updates have been made or the method &lt;code&gt;updateRow&lt;/code&gt;
     * has already been called, this method has no effect.
     * &lt;P&gt;
     * After &lt;code&gt;updateRow&lt;/code&gt; is called it is the
     * &lt;code&gt;cancelRowUpdates&lt;/code&gt; has no affect on the newly
     * inserted values. The method &lt;code&gt;cancelRowInsert&lt;/code&gt; can
     * be used to remove any rows inserted into the RowSet.
     *
     * @throws SQLException if the cursor is on the insert row, before the
     *            first row, or after the last row
     */
    public void cancelRowUpdates() throws SQLException {
        crsInternal.cancelRowUpdates();
    }

    /**
     * Moves the cursor for this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * to the insert row.  The current row in the rowset is remembered
     * while the cursor is on the insert row.
     * &lt;P&gt;
     * The insert row is a special row associated with an updatable
     * rowset.  It is essentially a buffer where a new row may
     * be constructed by calling the appropriate &lt;code&gt;updateXXX&lt;/code&gt;
     * methods to assign a value to each column in the row.  A complete
     * row must be constructed; that is, every column that is not nullable
     * must be assigned a value.  In order for the new row to become part
     * of this rowset, the method &lt;code&gt;insertRow&lt;/code&gt; must be called
     * before the cursor is moved back to the rowset.
     * &lt;P&gt;
     * Only certain methods may be invoked while the cursor is on the insert
     * row; many methods throw an exception if they are called while the
     * cursor is there.  In addition to the &lt;code&gt;updateXXX&lt;/code&gt;
     * and &lt;code&gt;insertRow&lt;/code&gt; methods, only the &lt;code&gt;getXXX&lt;/code&gt; methods
     * may be called when the cursor is on the insert row.  A &lt;code&gt;getXXX&lt;/code&gt;
     * method should be called on a column only after an &lt;code&gt;updateXXX&lt;/code&gt;
     * method has been called on that column; otherwise, the value returned is
     * undetermined.
     *
     * @throws SQLException if this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void moveToInsertRow() throws SQLException {
        crsInternal.moveToInsertRow();
    }

    /**
     * Moves the cursor for this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object to
     * the current row.  The current row is the row the cursor was on
     * when the method &lt;code&gt;moveToInsertRow&lt;/code&gt; was called.
     * &lt;P&gt;
     * Calling this method has no effect unless it is called while the
     * cursor is on the insert row.
     *
     * @throws SQLException if an error occurs
     */
    public void moveToCurrentRow() throws SQLException {
        crsInternal.moveToCurrentRow();
    }

    /**
     * Returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @return &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if an error occurs
     */
    public Statement getStatement() throws SQLException {
        return crsInternal.getStatement();
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Ref&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @return a &lt;code&gt;Ref&lt;/code&gt; object representing an SQL&lt;code&gt; REF&lt;/code&gt; value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) the designated column does not store an
     *            SQL &lt;code&gt;REF&lt;/code&gt; value
     */
    public Ref getRef(int columnIndex) throws SQLException {
        return crsInternal.getRef(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Blob&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @return a &lt;code&gt;Blob&lt;/code&gt; object representing an SQL &lt;code&gt;BLOB&lt;/code&gt; value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) the designated column does not store an
     *            SQL &lt;code&gt;BLOB&lt;/code&gt; value
     */
    public Blob getBlob(int columnIndex) throws SQLException {
        return crsInternal.getBlob(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Clob&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @return a &lt;code&gt;Clob&lt;/code&gt; object representing an SQL &lt;code&gt;CLOB&lt;/code&gt; value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) the designated column does not store an
     *            SQL &lt;code&gt;CLOB&lt;/code&gt; value
     */
    public Clob getClob(int columnIndex) throws SQLException {
        return crsInternal.getClob(columnIndex);
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as an &lt;code&gt;Array&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @return an &lt;code&gt;Array&lt;/code&gt; object representing an SQL
     *         &lt;code&gt;ARRAY&lt;/code&gt; value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) the designated column does not store an
     *            SQL &lt;code&gt;ARRAY&lt;/code&gt; value
     */
     public Array getArray(int columnIndex) throws SQLException {
        return crsInternal.getArray(columnIndex);
    }

    // ColumnName

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Ref&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @return a &lt;code&gt;Ref&lt;/code&gt; object representing an SQL&lt;code&gt; REF&lt;/code&gt; value
     * @throws SQLException  if (1) the given column name is not the name
     *         of a column in this rowset, (2) the cursor is not on one of
     *         this rowset's rows or its insert row, or (3) the column value
     *         is not an SQL &lt;code&gt;REF&lt;/code&gt; value
     */
    public Ref getRef(String columnName) throws SQLException {
        return crsInternal.getRef(columnName);
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Blob&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @return a &lt;code&gt;Blob&lt;/code&gt; object representing an SQL
     *        &lt;code&gt;BLOB&lt;/code&gt; value
     * @throws SQLException if (1) the given column name is not the name of
     *        a column in this rowset, (2) the cursor is not on one of
     *        this rowset's rows or its insert row, or (3) the designated
     *        column does not store an SQL &lt;code&gt;BLOB&lt;/code&gt; value
     */
    public Blob getBlob(String columnName) throws SQLException {
        return crsInternal.getBlob(columnName);
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Clob&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @return a &lt;code&gt;Clob&lt;/code&gt; object representing an SQL
     *         &lt;code&gt;CLOB&lt;/code&gt; value
     * @throws SQLException if (1) the given column name is not the name of
     *            a column in this rowset, (2) the cursor is not on one of
     *            this rowset's rows or its insert row, or (3) the designated
     *            column does not store an SQL &lt;code&gt;CLOB&lt;/code&gt; value
     */
    public Clob getClob(String columnName) throws SQLException {
        return crsInternal.getClob(columnName);
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as an &lt;code&gt;Array&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @return an &lt;code&gt;Array&lt;/code&gt; object representing an SQL
     *        &lt;code&gt;ARRAY&lt;/code&gt; value
     * @throws SQLException if (1) the given column name is not the name of
     *        a column in this rowset, (2) the cursor is not on one of
     *        this rowset's rows or its insert row, or (3) the designated
     *        column does not store an SQL &lt;code&gt;ARRAY&lt;/code&gt; value
     */
    public Array getArray(String columnName) throws SQLException {
        return crsInternal.getArray(columnName);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.sql.Date&lt;/code&gt;
     * object, using the given &lt;code&gt;Calendar&lt;/code&gt; object to construct an
     * appropriate millisecond value for the date.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
     *            constructing the date
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name is not the name of
     *            a column in this rowset, (2) the cursor is not on one of
     *            this rowset's rows or its insert row, or (3) the designated
     *            column does not store an SQL &lt;code&gt;DATE&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
     */
    public java.sql.Date getDate(int columnIndex, Calendar cal) throws SQLException {
        return crsInternal.getDate(columnIndex, cal);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.sql.Date&lt;/code&gt;
     * object, using the given &lt;code&gt;Calendar&lt;/code&gt; object to construct an
     * appropriate millisecond value for the date.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
     *            constructing the date
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name is not the name of
     *            a column in this rowset, (2) the cursor is not on one of
     *            this rowset's rows or its insert row, or (3) the designated
     *            column does not store an SQL &lt;code&gt;DATE&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
     */
    public java.sql.Date getDate(String columnName, Calendar cal) throws SQLException {
        return crsInternal.getDate(columnName, cal);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.sql.Time&lt;/code&gt;
     * object, using the given &lt;code&gt;Calendar&lt;/code&gt; object to construct an
     * appropriate millisecond value for the date.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
     *            constructing the date
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name is not the name of
     *            a column in this rowset, (2) the cursor is not on one of
     *            this rowset's rows or its insert row, or (3) the designated
     *            column does not store an SQL &lt;code&gt;TIME&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
     */
    public java.sql.Time getTime(int columnIndex, Calendar cal) throws SQLException {
        return crsInternal.getTime(columnIndex, cal);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.sql.Time&lt;/code&gt;
     * object, using the given &lt;code&gt;Calendar&lt;/code&gt; object to construct an
     * appropriate millisecond value for the date.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
     *            constructing the date
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name is not the name of
     *            a column in this rowset, (2) the cursor is not on one of
     *            this rowset's rows or its insert row, or (3) the designated
     *            column does not store an SQL &lt;code&gt;TIME&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
     */
    public java.sql.Time getTime(String columnName, Calendar cal) throws SQLException {
        return crsInternal.getTime(columnName, cal);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.sql.Timestamp&lt;/code&gt;
     * object, using the given &lt;code&gt;Calendar&lt;/code&gt; object to construct an
     * appropriate millisecond value for the date.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
     *            constructing the date
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name is not the name of
     *            a column in this rowset, (2) the cursor is not on one of
     *            this rowset's rows or its insert row, or (3) the designated
     *            column does not store an SQL &lt;code&gt;TIME&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
     */
    public java.sql.Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {
        return crsInternal.getTimestamp(columnIndex, cal);
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object, using the given
     * &lt;code&gt;Calendar&lt;/code&gt; object to construct an appropriate
     * millisecond value for the date.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
     *            constructing the date
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name is not the name of
     *            a column in this rowset, (2) the cursor is not on one of
     *            this rowset's rows or its insert row, or (3) the designated
     *            column does not store an SQL &lt;code&gt;DATE&lt;/code&gt;,
     *            &lt;code&gt;TIME&lt;/code&gt;, or &lt;code&gt;TIMESTAMP&lt;/code&gt; value
     */
    public java.sql.Timestamp getTimestamp(String columnName, Calendar cal) throws SQLException {
        return crsInternal.getTimestamp(columnName, cal);
    }

   /**
    * Sets the metadata for this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
    * with the given &lt;code&gt;RowSetMetaData&lt;/code&gt; object.
    *
    * @param md a &lt;code&gt;RowSetMetaData&lt;/code&gt; object instance containing
    *            metadata about the columsn in the rowset
    * @throws SQLException if invalid meta data is supplied to the
    *            rowset
    */
    public void setMetaData(RowSetMetaData md) throws SQLException {
        crsInternal.setMetaData(md);
    }

    public ResultSet getOriginal() throws SQLException {
        return crsInternal.getOriginal();
    }

   /**
    * Returns a result set containing the original value of the rowset.
    * The cursor is positioned before the first row in the result set.
    * Only rows contained in the result set returned by getOriginal()
    * are said to have an original value.
    *
    * @return the original result set of the rowset
    * @throws SQLException if an error occurs produce the
    *           &lt;code&gt;ResultSet&lt;/code&gt; object
    */
    public ResultSet getOriginalRow() throws SQLException {
        return crsInternal.getOriginalRow();
    }

   /**
    * Returns a result set containing the original value of the current
    * row only.
    *
    * @throws SQLException if there is no current row
    * @see #setOriginalRow
    */
    public void setOriginalRow() throws SQLException {
        crsInternal.setOriginalRow();
    }

   /**
    * Returns the columns that make a key to uniquely identify a
    * row in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
    *
    * @return an array of column number that constites a primary
    *           key for this rowset. This array should be empty
    *           if no columns is representitive of a primary key
    * @throws SQLException if the rowset is empty or no columns
    *           are designated as primary keys
    * @see #setKeyColumns
    */
    public int[] getKeyColumns() throws SQLException {
        return crsInternal.getKeyColumns();
    }

    /**
     * Sets this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's
     * &lt;code&gt;keyCols&lt;/code&gt; field with the given array of column
     * numbers, which forms a key for uniquely identifying a row
     * in this rowset.
     *
     * @param cols an array of &lt;code&gt;int&lt;/code&gt; indicating the
     *        columns that form a primary key for this
     *        &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object; every
     *        element in the array must be greater than
     *        &lt;code&gt;0&lt;/code&gt; and less than or equal to the number
     *        of columns in this rowset
     * @throws SQLException if any of the numbers in the
     *            given array is not valid for this rowset
     * @see #getKeyColumns
     */
    public void setKeyColumns(int[] cols) throws SQLException {
        crsInternal.setKeyColumns(cols);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Ref&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param ref the &lt;code&gt;java.sql.Ref&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateRef(int columnIndex, java.sql.Ref ref) throws SQLException {
        crsInternal.updateRef(columnIndex, ref);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Ref&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the name of the column
     *        to be updated; must match one of the column names in this
     *        &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @param ref the &lt;code&gt;java.sql.Ref&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column name is not valid,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateRef(String columnName, java.sql.Ref ref) throws SQLException {
        crsInternal.updateRef(columnName, ref);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Clob&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param c the &lt;code&gt;java.sql.Clob&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateClob(int columnIndex, Clob c) throws SQLException {
        crsInternal.updateClob(columnIndex, c);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Clob&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the name of the column
     *        to be updated; must match one of the column names in this
     *        &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @param c the &lt;code&gt;java.sql.Clob&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column name is not valid,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateClob(String columnName, Clob c) throws SQLException {
        crsInternal.updateClob(columnName, c);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Blob&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param b the &lt;code&gt;java.sql.Blob&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBlob(int columnIndex, Blob b) throws SQLException {
         crsInternal.updateBlob(columnIndex, b);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Blob&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the name of the column
     *        to be updated; must match one of the column names in this
     *        &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @param b the &lt;code&gt;java.sql.Blob&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column name is not valid,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBlob(String columnName, Blob b) throws SQLException {
         crsInternal.updateBlob(columnName, b);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Array&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param a the &lt;code&gt;java.sql.Array&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateArray(int columnIndex, Array a) throws SQLException {
         crsInternal.updateArray(columnIndex, a);
    }

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Array&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the name of the column
     *        to be updated; must match one of the column names in this
     *        &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @param a the &lt;code&gt;java.sql.Array&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column name is not valid,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateArray(String columnName, Array a) throws SQLException {
         crsInternal.updateArray(columnName, a);
    }

    /**
     * Populates this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with data.
     * This form of the method uses the rowset's user, password, and url or
     * data source name properties to create a database
     * connection.  If properties that are needed
     * have not been set, this method will throw an exception.
     * &lt;P&gt;
     * Another form of this method uses an existing JDBC &lt;code&gt;Connection&lt;/code&gt;
     * object instead of creating a new one; therefore, it ignores the
     * properties used for establishing a new connection.
     * &lt;P&gt;
     * The query specified by the command property is executed to create a
     * &lt;code&gt;ResultSet&lt;/code&gt; object from which to retrieve data.
     * The current contents of the rowset are discarded, and the
     * rowset's metadata is also (re)set.  If there are outstanding updates,
     * they are also ignored.
     * &lt;P&gt;
     * The method &lt;code&gt;execute&lt;/code&gt; closes any database connections that it
     * creates.
     *
     * @throws SQLException if an error occurs or the
     *                         necessary properties have not been set
     */
    public void execute() throws SQLException {
        crsInternal.execute();
    }

    /**
     * Populates this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with data,
     * using the given connection to produce the result set from
     * which data will be read.  A second form of this method,
     * which takes no arguments, uses the values from this rowset's
     * user, password, and either url or data source properties to
     * create a new database connection. The form of &lt;code&gt;execute&lt;/code&gt;
     * that is given a connection ignores these properties.
     *
     *  @param conn A standard JDBC &lt;code&gt;Connection&lt;/code&gt; object with valid
     *           properties that the &lt;code&gt;JoinRowSet&lt;/code&gt; implementation
     *           can pass to a synchronization provider to establish a
     *           connection to the datasource
     * @throws SQLException if an invalid &lt;code&gt;Connection&lt;/code&gt; is supplied
     *           or an error occurs in establishing the connection to the
     *           data soure
     * @see java.sql.Connection
     */
    public void execute(Connection conn) throws SQLException {
        crsInternal.execute(conn);
    }

    /**
     * Provide interface coverage for getURL(int) in ResultSet-&gt;RowSet
     */
    public java.net.URL getURL(int columnIndex) throws SQLException {
        return crsInternal.getURL(columnIndex);
    }

    /**
     * Provide interface coverage for getURL(String) in ResultSet-&gt;RowSet
     */
    public java.net.URL getURL(String columnName) throws SQLException {
        return crsInternal.getURL(columnName);
    }

   /**
    * Creates a new &lt;code&gt;WebRowSet&lt;/code&gt; object, populates it with the
    * data in the given &lt;code&gt;ResultSet&lt;/code&gt; object, and writes it
    * to the given &lt;code&gt;java.io.Writer&lt;/code&gt; object in XML format.
    *
    * @throws SQLException if an error occurs writing out the rowset
    *          contents to XML
    */
    public void writeXml(ResultSet rs, java.io.Writer writer)
        throws SQLException {
             wrs = new WebRowSetImpl();
             wrs.populate(rs);
             wrs.writeXml(writer);
    }

    /**
     * Writes this &lt;code&gt;JoinRowSet&lt;/code&gt; object to the given
     * &lt;code&gt;java.io.Writer&lt;/code&gt; object in XML format. In
     * addition to the rowset's data, its properties and metadata
     * are also included.
     *
     * @throws SQLException if an error occurs writing out the rowset
     *          contents to XML
     */
    public void writeXml(java.io.Writer writer) throws SQLException {
        createWebRowSet().writeXml(writer);
}

    /**
     * Reads this &lt;code&gt;JoinRowSet&lt;/code&gt; object in its XML format.
     *
     * @throws SQLException if a database access error occurs
     */
    public void readXml(java.io.Reader reader) throws SQLException {
        wrs = new WebRowSetImpl();
        wrs.readXml(reader);
        crsInternal = (CachedRowSetImpl)wrs;
    }

    // Stream based methods
    /**
     * Reads a stream based XML input to populate an &lt;code&gt;WebRowSet&lt;/code&gt;
     *
     * @throws SQLException if a data source access occurs
     * @throws IOException if a IO exception occurs
     */
    public void readXml(java.io.InputStream iStream) throws SQLException, IOException {
         wrs = new WebRowSetImpl();
         wrs.readXml(iStream);
         crsInternal = (CachedRowSetImpl)wrs;
    }

    /**
     * Creates an an output stream of the internal state and contents of a
     * &lt;code&gt;WebRowSet&lt;/code&gt; for XML proceessing
     *
     * @throws SQLException if a datasource access occurs
     * @throws IOException if an IO exception occurs
     */
    public void writeXml(java.io.OutputStream oStream) throws SQLException, IOException {
         createWebRowSet().writeXml(oStream);
    }

    /**
     * Creates a new &lt;code&gt;WebRowSet&lt;/code&gt; object, populates it with
     * the contents of the &lt;code&gt;ResultSet&lt;/code&gt; and creates an output
     * streams the internal state and contents of the rowset for XML processing.
     *
     * @throws SQLException if a datasource access occurs
     * @throws IOException if an IO exception occurs
     */
    public void writeXml(ResultSet rs, java.io.OutputStream oStream) throws SQLException, IOException {
             wrs = new WebRowSetImpl();
             wrs.populate(rs);
             wrs.writeXml(oStream);
    }

    /**
     * %%% Javadoc comments to be added here
     */
    private WebRowSet createWebRowSet() throws SQLException {
       if(wrs != null) {
           // check if it has already been initialized.
           return wrs;
       } else {
         wrs = new WebRowSetImpl();
          crsInternal.beforeFirst();
          wrs.populate(crsInternal);
          return wrs;
       }
    }

    /**
     * Returns the last set SQL &lt;code&gt;JOIN&lt;/code&gt; type in this JoinRowSetImpl
     * object
     *
     * @return joinType One of the standard JoinRowSet static field JOIN types
     * @throws SQLException if an error occurs determining the current join type
     */
    public int getJoinType() throws SQLException {
        if (vecJoinType == null) {
            // Default JoinRowSet type
            this.setJoinType(JoinRowSet.INNER_JOIN);
        }
        Integer i = vecJoinType.get(vecJoinType.size()-1);
        return i.intValue();
    }

    /**
    * The listener will be notified whenever an event occurs on this &lt;code&gt;JoinRowSet&lt;/code&gt;
    * object.
    * &lt;P&gt;
    * A listener might, for example, be a table or graph that needs to
    * be updated in order to accurately reflect the current state of
    * the &lt;code&gt;RowSet&lt;/code&gt; object.
    * &lt;p&gt;
    * &lt;b&gt;Note&lt;/b&gt;: if the &lt;code&gt;RowSetListener&lt;/code&gt; object is
    * &lt;code&gt;null&lt;/code&gt;, this method silently discards the &lt;code&gt;null&lt;/code&gt;
    * value and does not add a null reference to the set of listeners.
    * &lt;p&gt;
    * &lt;b&gt;Note&lt;/b&gt;: if the listener is already set, and the new &lt;code&gt;RowSetListerner&lt;/code&gt;
    * instance is added to the set of listeners already registered to receive
    * event notifications from this &lt;code&gt;RowSet&lt;/code&gt;.
    *
    * @param listener an object that has implemented the
    *     &lt;code&gt;javax.sql.RowSetListener&lt;/code&gt; interface and wants to be notified
    *     of any events that occur on this &lt;code&gt;JoinRowSet&lt;/code&gt; object; May be
    *     null.
    * @see #removeRowSetListener
    */
    public void addRowSetListener(RowSetListener listener) {
        crsInternal.addRowSetListener(listener);
    }

    /**
    * Removes the designated object from this &lt;code&gt;JoinRowSet&lt;/code&gt; object's list of listeners.
    * If the given argument is not a registered listener, this method
    * does nothing.
    *
    *  &lt;b&gt;Note&lt;/b&gt;: if the &lt;code&gt;RowSetListener&lt;/code&gt; object is
    * &lt;code&gt;null&lt;/code&gt;, this method silently discards the &lt;code&gt;null&lt;/code&gt;
    * value.
    *
    * @param listener a &lt;code&gt;RowSetListener&lt;/code&gt; object that is on the list
    *        of listeners for this &lt;code&gt;JoinRowSet&lt;/code&gt; object
    * @see #addRowSetListener
    */
     public void removeRowSetListener(RowSetListener listener) {
        crsInternal.removeRowSetListener(listener);
    }

    /**
     * Converts this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object to a collection
     * of tables. The sample implementation utilitizes the &lt;code&gt;TreeMap&lt;/code&gt;
     * collection type.
     * This class guarantees that the map will be in ascending key order,
     * sorted according to the natural order for the key's class.
     *
     * @return a &lt;code&gt;Collection&lt;/code&gt; object consisting of tables,
     *         each of which is a copy of a row in this
     *         &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @throws SQLException if an error occurs in generating the collection
     * @see #toCollection(int)
     * @see #toCollection(String)
     * @see java.util.TreeMap
     */
     public Collection&lt;?&gt; toCollection() throws SQLException {
        return crsInternal.toCollection();
    }

    /**
     * Returns the specified column of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * as a &lt;code&gt;Collection&lt;/code&gt; object.  This method makes a copy of the
     * column's data and utilitizes the &lt;code&gt;Vector&lt;/code&gt; to establish the
     * collection. The &lt;code&gt;Vector&lt;/code&gt; class implements a growable array
     * objects allowing the individual components to be accessed using an
     * an integer index similar to that of an array.
     *
     * @return a &lt;code&gt;Collection&lt;/code&gt; object that contains the value(s)
     *         stored in the specified column of this
     *         &lt;code&gt;JoinRowSetImpl&lt;/code&gt;
     *         object
     * @throws SQLException if an error occurs generated the collection; or
     *          an invalid column is provided.
     * @see #toCollection()
     * @see #toCollection(String)
     * @see java.util.Vector
     */
    public Collection&lt;?&gt; toCollection(int column) throws SQLException {
        return crsInternal.toCollection(column);
    }

    /**
     * Returns the specified column of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * as a &lt;code&gt;Collection&lt;/code&gt; object.  This method makes a copy of the
     * column's data and utilitizes the &lt;code&gt;Vector&lt;/code&gt; to establish the
     * collection. The &lt;code&gt;Vector&lt;/code&gt; class implements a growable array
     * objects allowing the individual components to be accessed using an
     * an integer index similar to that of an array.
     *
     * @return a &lt;code&gt;Collection&lt;/code&gt; object that contains the value(s)
     *         stored in the specified column of this
     *         &lt;code&gt;JoinRowSetImpl&lt;/code&gt;
     *         object
     * @throws SQLException if an error occurs generated the collection; or
     *          an invalid column is provided.
     * @see #toCollection()
     * @see #toCollection(int)
     * @see java.util.Vector
     */
    public Collection&lt;?&gt; toCollection(String column) throws SQLException {
        return crsInternal.toCollection(column);
    }

    /**
     * Creates a &lt;code&gt;RowSet&lt;/code&gt; object that is a copy of
     * this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's table structure
     * and the constraints only.
     * There will be no data in the object being returned.
     * Updates made on a copy are not visible to the original rowset.
     * &lt;P&gt;
     * This helps in getting the underlying XML schema which can
     * be used as the basis for populating a &lt;code&gt;WebRowSet&lt;/code&gt;.
     *
     * @return a new &lt;code&gt;CachedRowSet&lt;/code&gt; object that is a copy
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's schema and
     * retains all the constraints on the original rowset but contains
     * no data
     * @throws SQLException if an error occurs in generating the copy
     * of the &lt;code&gt;CachedRowSet&lt;/code&gt; object
     * @see #createShared
     * @see #createCopy
     * @see #createCopyNoConstraints
     * @see javax.sql.RowSetEvent
     * @see javax.sql.RowSetListener
     */
     public CachedRowSet createCopySchema() throws SQLException {
         return crsInternal.createCopySchema();
     }

     /**
      * {@inheritDoc}
      */
     public void setSyncProvider(String providerStr) throws SQLException {
         crsInternal.setSyncProvider(providerStr);
     }

     /**
      * {@inheritDoc}
      */
     public void acceptChanges() throws SyncProviderException {
         crsInternal.acceptChanges();
     }

     /**
      * {@inheritDoc}
      */
     public SyncProvider getSyncProvider() throws SQLException {
        return crsInternal.getSyncProvider();
     }

    /**
     * This method re populates the resBundle
     * during the deserialization process
     *
     */
     private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        // Default state initialization happens here
        ois.defaultReadObject();
        // Initialization of transient Res Bundle happens here .
        try {
           resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();
        } catch(IOException ioe) {
            throw new RuntimeException(ioe);
        }

     }

     static final long serialVersionUID = -5590501621560008453L;
}
</pre>
</body>
</html>
