<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2002, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jmx.snmp.IPAcl;

import static com.sun.jmx.defaults.JmxProperties.SNMP_LOGGER;

import java.util.logging.Level;
import java.util.Vector;
import java.util.Enumeration;
import java.io.Serializable;
import java.net.UnknownHostException;
import java.net.InetAddress;

import java.security.Principal;
import java.security.acl.Group;


/**
 * This class is used to represent a subnet mask (a group of hosts matching the same
 * IP mask).
 *
 * @see java.security.acl.Group
 */

class NetMaskImpl extends PrincipalImpl implements Group, Serializable {
    private static final long serialVersionUID = -7332541893877932896L;

    protected byte[] subnet = null;
    protected int prefix = -1;
    /**
     * Constructs an empty group.
     * @exception UnknownHostException Not implemented
     */
    public NetMaskImpl () throws UnknownHostException {
    }

    private byte[] extractSubNet(byte[] b) {
        int addrLength = b.length;
        byte[] subnet = null;
        if (SNMP_LOGGER.isLoggable(Level.FINEST)) {
            SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(),
                &quot;extractSubNet&quot;, &quot;BINARY ARRAY :&quot;);
            StringBuffer buff = new StringBuffer();
            for(int i =0; i &lt; addrLength; i++) {
                buff.append((b[i] &amp;0xFF) +&quot;:&quot;);
            }
            SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(),
                &quot;extractSubNet&quot;, buff.toString());
        }

        // 8 is a byte size. Common to any InetAddress (V4 or V6).
        int fullyCoveredByte = prefix / 8;
        if(fullyCoveredByte == addrLength) {
            if (SNMP_LOGGER.isLoggable(Level.FINEST)) {
                SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(), &quot;extractSubNet&quot;,
                   &quot;The mask is the complete address, strange...&quot; + addrLength);
            }
            subnet = b;
            return subnet;
        }
        if(fullyCoveredByte &gt; addrLength) {
            if (SNMP_LOGGER.isLoggable(Level.FINEST)) {
                SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(), &quot;extractSubNet&quot;,
                   &quot;The number of covered byte is longer than the address. BUG&quot;);
            }
            throw new IllegalArgumentException(&quot;The number of covered byte is longer than the address.&quot;);
        }
        int partialyCoveredIndex = fullyCoveredByte;
        if (SNMP_LOGGER.isLoggable(Level.FINEST)) {
            SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(), &quot;extractSubNet&quot;,
               &quot;Partially covered index : &quot; + partialyCoveredIndex);
        }
        byte toDeal = b[partialyCoveredIndex];
        if (SNMP_LOGGER.isLoggable(Level.FINEST)) {
            SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(), &quot;extractSubNet&quot;,
               &quot;Partially covered byte : &quot; + toDeal);
        }

        // 8 is a byte size. Common to any InetAddress (V4 or V6).
        int nbbits = prefix % 8;
        int subnetSize = 0;

        if(nbbits == 0)
        subnetSize = partialyCoveredIndex;
        else
        subnetSize = partialyCoveredIndex + 1;

        if (SNMP_LOGGER.isLoggable(Level.FINEST)) {
            SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(), &quot;extractSubNet&quot;,
               &quot;Remains : &quot; + nbbits);
        }

        byte mask = 0;
        for(int i = 0; i &lt; nbbits; i++) {
            mask |= (1 &lt;&lt; (7 - i));
        }
        if (SNMP_LOGGER.isLoggable(Level.FINEST)) {
            SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(), &quot;extractSubNet&quot;,
               &quot;Mask value : &quot; + (mask &amp; 0xFF));
        }

        byte maskedValue = (byte) ((int)toDeal &amp; (int)mask);

        if (SNMP_LOGGER.isLoggable(Level.FINEST)) {
            SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(), &quot;extractSubNet&quot;,
               &quot;Masked byte : &quot;  + (maskedValue &amp;0xFF));
        }
        subnet = new byte[subnetSize];
        if (SNMP_LOGGER.isLoggable(Level.FINEST)) {
            SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(), &quot;extractSubNet&quot;,
               &quot;Resulting subnet : &quot;);
        }
        for(int i = 0; i &lt; partialyCoveredIndex; i++) {
            subnet[i] = b[i];

            if (SNMP_LOGGER.isLoggable(Level.FINEST)) {
                SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(), &quot;extractSubNet&quot;,
                   (subnet[i] &amp; 0xFF) +&quot;:&quot;);
            }
        }

        if(nbbits != 0) {
            subnet[partialyCoveredIndex] = maskedValue;
            if (SNMP_LOGGER.isLoggable(Level.FINEST)) {
                SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(), &quot;extractSubNet&quot;,
                    &quot;Last subnet byte : &quot; + (subnet[partialyCoveredIndex] &amp;0xFF));
            }
        }
        return subnet;
    }

  /**
   * Constructs a group using the specified subnet mask.
   * THIS ALGORITHM IS V4 and V6 compatible.
   *
   * @exception UnknownHostException if the subnet mask cann't be built.
   */
  public NetMaskImpl (String a, int prefix) throws UnknownHostException {
        super(a);
        this.prefix = prefix;
        subnet = extractSubNet(getAddress().getAddress());
  }

  /**
   * Adds the specified member to the group.
   *
   * @param p the principal to add to this group.
   * @return true if the member was successfully added, false if the
   *      principal was already a member.
   */
  public boolean addMember(Principal p) {
        // we don't need to add members because the ip address is a subnet mask
        return true;
  }

  public int hashCode() {
        return super.hashCode();
  }

  /**
   * Compares this group to the specified object. Returns true if the object
   * passed in matches the group represented.
   *
   * @param p the object to compare with.
   * @return true if the object passed in matches the subnet mask,
   *    false otherwise.
   */
    public boolean equals (Object p) {
        if (p instanceof PrincipalImpl || p instanceof NetMaskImpl){
            PrincipalImpl received = (PrincipalImpl) p;
            InetAddress addr = received.getAddress();
            if (SNMP_LOGGER.isLoggable(Level.FINEST)) {
                SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(), &quot;equals&quot;,
                    &quot;Received Address : &quot; + addr);
            }
            byte[] recAddr = addr.getAddress();
            for(int i = 0; i &lt; subnet.length; i++) {
                if (SNMP_LOGGER.isLoggable(Level.FINEST)) {
                    SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(), &quot;equals&quot;,
                        &quot;(recAddr[i]) : &quot; + (recAddr[i] &amp; 0xFF));
                    SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(), &quot;equals&quot;,
                        &quot;(recAddr[i] &amp; subnet[i]) : &quot; +
                         ((recAddr[i] &amp; (int)subnet[i]) &amp;0xFF) +
                         &quot; subnet[i] : &quot; + (subnet[i] &amp;0xFF));
                }
                if((recAddr[i] &amp; subnet[i]) != subnet[i]) {
                    if (SNMP_LOGGER.isLoggable(Level.FINEST)) {
                        SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(), &quot;equals&quot;,
                            &quot;FALSE&quot;);
                    }
                    return false;
                }
            }
            if (SNMP_LOGGER.isLoggable(Level.FINEST)) {
                SNMP_LOGGER.logp(Level.FINEST, NetMaskImpl.class.getName(), &quot;equals&quot;,
                    &quot;TRUE&quot;);
            }
            return true;
        } else
            return false;
    }
  /**
   * Returns true if the passed principal is a member of the group.
   *
   * @param p the principal whose membership is to be checked.
   * @return true if the principal is a member of this group, false otherwise.
   */
  public boolean isMember(Principal p) {
        if ((p.hashCode() &amp; super.hashCode()) == p.hashCode()) return true;
        else return false;
  }

  /**
   * Returns an enumeration which contains the subnet mask.
   *
   * @return an enumeration which contains the subnet mask.
   */
  public Enumeration&lt;? extends Principal&gt; members(){
        Vector&lt;Principal&gt; v = new Vector&lt;Principal&gt;(1);
        v.addElement(this);
        return v.elements();
  }

  /**
   * Removes the specified member from the group. (Not implemented)
   *
   * @param p the principal to remove from this group.
   * @return allways return true.
   */
  public boolean removeMember(Principal p) {
        return true;
  }

  /**
   * Prints a string representation of this group.
   *
   * @return  a string representation of this group.
   */
  public String toString() {
        return (&quot;NetMaskImpl :&quot;+ super.getAddress().toString() + &quot;/&quot; + prefix);
  }

}
</pre>
</body>
</html>
