<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package com.sun.jmx.snmp.daemon;



// java import
//
import java.io.ObjectInputStream;
import java.io.IOException;
import java.net.InetAddress;
import java.util.logging.Level;
import java.util.Vector;
import java.util.NoSuchElementException;

// jmx import
//
import javax.management.MBeanServer;
import javax.management.MBeanRegistration;
import javax.management.ObjectName;
import javax.management.NotificationListener;
import javax.management.NotificationFilter;
import javax.management.NotificationBroadcaster;
import javax.management.NotificationBroadcasterSupport;
import javax.management.MBeanNotificationInfo;
import javax.management.AttributeChangeNotification;
import javax.management.ListenerNotFoundException;

import static com.sun.jmx.defaults.JmxProperties.SNMP_ADAPTOR_LOGGER;

// JSR 160 import
//
// XXX Revisit:
//   used to import com.sun.jmx.snmp.MBeanServerForwarder
// Now using JSR 160 instead. =&gt; this is an additional
// dependency to JSR 160.
//
import javax.management.remote.MBeanServerForwarder;

/**
 * Defines generic behavior for the server part of a connector or an adaptor.
 * Most connectors or adaptors extend &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;
 * and inherit this behavior. Connectors or adaptors that do not fit into
 * this model do not extend &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
 * &lt;p&gt;
 * A &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is an active object, it listens for
 * client requests  and processes them in its own thread. When necessary, a
 * &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; creates other threads to process multiple
 * requests concurrently.
 * &lt;p&gt;
 * A &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; object can be stopped by calling the
 * &lt;CODE&gt;stop&lt;/CODE&gt; method. When it is stopped, the
 * &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; no longer listens to client requests and
 * no longer holds any thread or communication resources.
 * It can be started again by calling the &lt;CODE&gt;start&lt;/CODE&gt; method.
 * &lt;p&gt;
 * A &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; has a &lt;CODE&gt;State&lt;/CODE&gt; attribute
 * which reflects its  activity.
 * &lt;p&gt;
 * &lt;TABLE&gt;
 * &lt;TR&gt;&lt;TH&gt;CommunicatorServer&lt;/TH&gt;      &lt;TH&gt;State&lt;/TH&gt;&lt;/TR&gt;
 * &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;stopped&lt;/CODE&gt;&lt;/TD&gt;    &lt;TD&gt;&lt;CODE&gt;OFFLINE&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
 * &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;starting&lt;/CODE&gt;&lt;/TD&gt;    &lt;TD&gt;&lt;CODE&gt;STARTING&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
 * &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;running&lt;/CODE&gt;&lt;/TD&gt;     &lt;TD&gt;&lt;CODE&gt;ONLINE&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
 * &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;stopping&lt;/CODE&gt;&lt;/TD&gt;     &lt;TD&gt;&lt;CODE&gt;STOPPING&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
 * &lt;/TABLE&gt;
 * &lt;p&gt;
 * The &lt;CODE&gt;STARTING&lt;/CODE&gt; state marks the transition
 * from &lt;CODE&gt;OFFLINE&lt;/CODE&gt; to &lt;CODE&gt;ONLINE&lt;/CODE&gt;.
 * &lt;p&gt;
 * The &lt;CODE&gt;STOPPING&lt;/CODE&gt; state marks the transition from
 * &lt;CODE&gt;ONLINE&lt;/CODE&gt; to &lt;CODE&gt;OFFLINE&lt;/CODE&gt;. This occurs when the
 * &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is finishing or interrupting active
 * requests.
 * &lt;p&gt;
 * When a &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is unregistered from the MBeanServer,
 * it is stopped automatically.
 * &lt;p&gt;
 * When the value of the &lt;CODE&gt;State&lt;/CODE&gt; attribute changes the
 * &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; sends a
 * &lt;tt&gt;{@link javax.management.AttributeChangeNotification}&lt;/tt&gt; to the
 * registered listeners, if any.
 *
 * &lt;p&gt;&lt;b&gt;This API is a Sun Microsystems internal API  and is subject
 * to change without notice.&lt;/b&gt;&lt;/p&gt;
 */

public abstract class CommunicatorServer
    implements Runnable, MBeanRegistration, NotificationBroadcaster,
               CommunicatorServerMBean {

    //
    // States of a CommunicatorServer
    //

    /**
     * Represents an &lt;CODE&gt;ONLINE&lt;/CODE&gt; state.
     */
    public static final int ONLINE = 0 ;

    /**
     * Represents an &lt;CODE&gt;OFFLINE&lt;/CODE&gt; state.
     */
    public static final int OFFLINE = 1 ;

    /**
     * Represents a &lt;CODE&gt;STOPPING&lt;/CODE&gt; state.
     */
    public static final int STOPPING = 2 ;

    /**
     * Represents a &lt;CODE&gt;STARTING&lt;/CODE&gt; state.
     */
    public static final int STARTING = 3 ;

    //
    // Types of connectors.
    //

    /**
     * Indicates that it is an RMI connector type.
     */
    //public static final int RMI_TYPE = 1 ;

    /**
     * Indicates that it is an HTTP connector type.
     */
    //public static final int HTTP_TYPE = 2 ;

    /**
     * Indicates that it is an HTML connector type.
     */
    //public static final int HTML_TYPE = 3 ;

    /**
     * Indicates that it is an SNMP connector type.
     */
    public static final int SNMP_TYPE = 4 ;

    /**
     * Indicates that it is an HTTPS connector type.
     */
    //public static final int HTTPS_TYPE = 5 ;

    //
    // Package variables
    //

    /**
     * The state of the connector server.
     */
     transient volatile int state = OFFLINE ;

    /**
     * The object name of the connector server.
     * @serial
     */
    ObjectName objectName ;

    MBeanServer topMBS;
    MBeanServer bottomMBS;

    /**
     */
    transient String dbgTag = null ;

    /**
     * The maximum number of clients that the CommunicatorServer can
     * process concurrently.
     * @serial
     */
    int maxActiveClientCount = 1 ;

    /**
     */
    transient int servedClientCount = 0 ;

    /**
     * The host name used by this CommunicatorServer.
     * @serial
     */
    String host = null ;

    /**
     * The port number used by this CommunicatorServer.
     * @serial
     */
    int port = -1 ;


    //
    // Private fields
    //

    /* This object controls access to the &quot;state&quot; and &quot;interrupted&quot; variables.
       If held at the same time as the lock on &quot;this&quot;, the &quot;this&quot; lock must
       be taken first.  */
    private transient Object stateLock = new Object();

    private transient Vector&lt;ClientHandler&gt;
            clientHandlerVector = new Vector&lt;&gt;() ;

    private transient Thread mainThread = null ;

    private volatile boolean stopRequested = false ;
    private boolean interrupted = false;
    private transient Exception startException = null;

    // Notifs count, broadcaster and info
    private transient long notifCount = 0;
    private transient NotificationBroadcasterSupport notifBroadcaster =
        new NotificationBroadcasterSupport();
    private transient MBeanNotificationInfo[] notifInfos = null;


    /**
     * Instantiates a &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
     *
     * @param connectorType Indicates the connector type. Possible values are:
     * SNMP_TYPE.
     *
     * @exception &lt;CODE&gt;java.lang.IllegalArgumentException&lt;/CODE&gt;
     *            This connector type is not correct.
     */
    public CommunicatorServer(int connectorType)
        throws IllegalArgumentException {
        switch (connectorType) {
        case SNMP_TYPE :
            //No op. int Type deciding debugging removed.
            break;
        default:
            throw new IllegalArgumentException(&quot;Invalid connector Type&quot;) ;
        }
        dbgTag = makeDebugTag() ;
    }

    protected Thread createMainThread() {
        return new Thread (this, makeThreadName());
    }

    /**
     * Starts this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
     * &lt;p&gt;
     * Has no effect if this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is
     * &lt;CODE&gt;ONLINE&lt;/CODE&gt; or &lt;CODE&gt;STOPPING&lt;/CODE&gt;.
     * @param timeout Time in ms to wait for the connector to start.
     *        If &lt;code&gt;timeout&lt;/code&gt; is positive, wait for at most
     *        the specified time. An infinite timeout can be specified
     *        by passing a &lt;code&gt;timeout&lt;/code&gt; value equals
     *        &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;. In that case the method
     *        will wait until the connector starts or fails to start.
     *        If timeout is negative or zero, returns as soon as possible
     *        without waiting.
     * @exception CommunicationException if the connectors fails to start.
     * @exception InterruptedException if the thread is interrupted or the
     *            timeout expires.
     */
    public void start(long timeout)
        throws CommunicationException, InterruptedException {
        boolean start;

        synchronized (stateLock) {
            if (state == STOPPING) {
                // Fix for bug 4352451:
                //     &quot;java.net.BindException: Address in use&quot;.
                waitState(OFFLINE, 60000);
            }
            start = (state == OFFLINE);
            if (start) {
                changeState(STARTING);
                stopRequested = false;
                interrupted = false;
                startException = null;
            }
        }

        if (!start) {
            if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                    &quot;start&quot;,&quot;Connector is not OFFLINE&quot;);
            }
            return;
        }

        if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
            SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                &quot;start&quot;,&quot;--&gt; Start connector &quot;);
        }

        mainThread = createMainThread();

        mainThread.start() ;

        if (timeout &gt; 0) waitForStart(timeout);
    }

    /**
     * Starts this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
     * &lt;p&gt;
     * Has no effect if this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is
     * &lt;CODE&gt;ONLINE&lt;/CODE&gt; or &lt;CODE&gt;STOPPING&lt;/CODE&gt;.
     */
    @Override
    public void start() {
        try {
            start(0);
        } catch (InterruptedException x) {
            // cannot happen because of `0'
            if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                    &quot;start&quot;,&quot;interrupted&quot;, x);
            }
        }
    }

    /**
     * Stops this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
     * &lt;p&gt;
     * Has no effect if this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is
     * &lt;CODE&gt;OFFLINE&lt;/CODE&gt; or  &lt;CODE&gt;STOPPING&lt;/CODE&gt;.
     */
    @Override
    public void stop() {
        synchronized (stateLock) {
            if (state == OFFLINE || state == STOPPING) {
                if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                    SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                        &quot;stop&quot;,&quot;Connector is not ONLINE&quot;);
                }
                return;
            }
            changeState(STOPPING);
            //
            // Stop the connector thread
            //
            if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                    &quot;stop&quot;,&quot;Interrupt main thread&quot;);
            }
            stopRequested = true ;
            if (!interrupted) {
                interrupted = true;
                mainThread.interrupt();
            }
        }

        //
        // Call terminate on each active client handler
        //
        if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
            SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                &quot;stop&quot;,&quot;terminateAllClient&quot;);
        }
        terminateAllClient() ;

        // ----------------------
        // changeState
        // ----------------------
        synchronized (stateLock) {
            if (state == STARTING)
                changeState(OFFLINE);
        }
    }

    /**
     * Tests whether the &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is active.
     *
     * @return True if connector is &lt;CODE&gt;ONLINE&lt;/CODE&gt;; false otherwise.
     */
    @Override
    public boolean isActive() {
        synchronized (stateLock) {
            return (state == ONLINE);
        }
    }

    /**
     * &lt;p&gt;Waits until either the State attribute of this MBean equals the
     * specified &lt;VAR&gt;wantedState&lt;/VAR&gt; parameter,
     * or the specified  &lt;VAR&gt;timeOut&lt;/VAR&gt; has elapsed.
     * The method &lt;CODE&gt;waitState&lt;/CODE&gt; returns with a boolean value
     * indicating whether the specified &lt;VAR&gt;wantedState&lt;/VAR&gt; parameter
     * equals the value of this MBean's State attribute at the time the method
     * terminates.&lt;/p&gt;
     *
     * &lt;p&gt;Two special cases for the &lt;VAR&gt;timeOut&lt;/VAR&gt; parameter value are:&lt;/p&gt;
     * &lt;UL&gt;&lt;LI&gt; if &lt;VAR&gt;timeOut&lt;/VAR&gt; is negative then &lt;CODE&gt;waitState&lt;/CODE&gt;
     *     returns immediately (i.e. does not wait at all),&lt;/LI&gt;
     * &lt;LI&gt; if &lt;VAR&gt;timeOut&lt;/VAR&gt; equals zero then &lt;CODE&gt;waitState&lt;/CODE&gt;
     *     waits untill the value of this MBean's State attribute
     *     is the same as the &lt;VAR&gt;wantedState&lt;/VAR&gt; parameter (i.e. will wait
     *     indefinitely if this condition is never met).&lt;/LI&gt;&lt;/UL&gt;
     *
     * @param wantedState The value of this MBean's State attribute to wait
     *        for. &lt;VAR&gt;wantedState&lt;/VAR&gt; can be one of:
     * &lt;ul&gt;
     * &lt;li&gt;&lt;CODE&gt;CommunicatorServer.OFFLINE&lt;/CODE&gt;,&lt;/li&gt;
     * &lt;li&gt;&lt;CODE&gt;CommunicatorServer.ONLINE&lt;/CODE&gt;,&lt;/li&gt;
     * &lt;li&gt;&lt;CODE&gt;CommunicatorServer.STARTING&lt;/CODE&gt;,&lt;/li&gt;
     * &lt;li&gt;&lt;CODE&gt;CommunicatorServer.STOPPING&lt;/CODE&gt;.&lt;/li&gt;
     * &lt;/ul&gt;
     * @param timeOut The maximum time to wait for, in milliseconds,
     *        if positive.
     * Infinite time out if 0, or no waiting at all if negative.
     *
     * @return true if the value of this MBean's State attribute is the
     *      same as the &lt;VAR&gt;wantedState&lt;/VAR&gt; parameter; false otherwise.
     */
    @Override
    public boolean waitState(int wantedState, long timeOut) {
        if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
            SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                &quot;waitState&quot;, wantedState + &quot;(0on,1off,2st) TO=&quot; + timeOut +
                  &quot; ; current state = &quot; + getStateString());
        }

        long endTime = 0;
        if (timeOut &gt; 0)
            endTime = System.currentTimeMillis() + timeOut;

        synchronized (stateLock) {
            while (state != wantedState) {
                if (timeOut &lt; 0) {
                    if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                        SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                            &quot;waitState&quot;, &quot;timeOut &lt; 0, return without wait&quot;);
                    }
                    return false;
                } else {
                    try {
                        if (timeOut &gt; 0) {
                            long toWait = endTime - System.currentTimeMillis();
                            if (toWait &lt;= 0) {
                                if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                                    SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                                        &quot;waitState&quot;, &quot;timed out&quot;);
                                }
                                return false;
                            }
                            stateLock.wait(toWait);
                        } else {  // timeOut == 0
                            stateLock.wait();
                        }
                    } catch (InterruptedException e) {
                        if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                            SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                                &quot;waitState&quot;, &quot;wait interrupted&quot;);
                        }
                        return (state == wantedState);
                    }
                }
            }
            if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                    &quot;waitState&quot;,&quot;returning in desired state&quot;);
            }
            return true;
        }
    }

    /**
     * &lt;p&gt;Waits until the communicator is started or timeout expires.
     *
     * @param timeout Time in ms to wait for the connector to start.
     *        If &lt;code&gt;timeout&lt;/code&gt; is positive, wait for at most
     *        the specified time. An infinite timeout can be specified
     *        by passing a &lt;code&gt;timeout&lt;/code&gt; value equals
     *        &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;. In that case the method
     *        will wait until the connector starts or fails to start.
     *        If timeout is negative or zero, returns as soon as possible
     *        without waiting.
     *
     * @exception CommunicationException if the connectors fails to start.
     * @exception InterruptedException if the thread is interrupted or the
     *            timeout expires.
     *
     */
    private void waitForStart(long timeout)
        throws CommunicationException, InterruptedException {
        if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
            SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                &quot;waitForStart&quot;, &quot;Timeout=&quot; + timeout +
                 &quot; ; current state = &quot; + getStateString());
        }

        final long startTime = System.currentTimeMillis();

        synchronized (stateLock) {
            while (state == STARTING) {
                // Time elapsed since startTime...
                //
                final long elapsed = System.currentTimeMillis() - startTime;

                // wait for timeout - elapsed.
                // A timeout of Long.MAX_VALUE is equivalent to something
                // like 292271023 years - which is pretty close to
                // forever as far as we are concerned ;-)
                //
                final long remainingTime = timeout-elapsed;

                // If remainingTime is negative, the timeout has elapsed.
                //
                if (remainingTime &lt; 0) {
                    if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                        SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                            &quot;waitForStart&quot;, &quot;timeout &lt; 0, return without wait&quot;);
                    }
                    throw new InterruptedException(&quot;Timeout expired&quot;);
                }

                // We're going to wait until someone notifies on the
                // the stateLock object, or until the timeout expires,
                // or until the thread is interrupted.
                //
                try {
                    stateLock.wait(remainingTime);
                } catch (InterruptedException e) {
                    if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                        SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                            &quot;waitForStart&quot;, &quot;wait interrupted&quot;);
                    }

                    // If we are now ONLINE, then no need to rethrow the
                    // exception... we're simply going to exit the while
                    // loop. Otherwise, throw the InterruptedException.
                    //
                    if (state != ONLINE) throw e;
                }
            }

            // We're no longer in STARTING state
            //
            if (state == ONLINE) {
                // OK, we're started, everything went fine, just return
                //
                if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                    SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                        &quot;waitForStart&quot;, &quot;started&quot;);
                }
                return;
            } else if (startException instanceof CommunicationException) {
                // There was some exception during the starting phase.
                // Cast and throw...
                //
                throw (CommunicationException)startException;
            } else if (startException instanceof InterruptedException) {
                // There was some exception during the starting phase.
                // Cast and throw...
                //
                throw (InterruptedException)startException;
            } else if (startException != null) {
                // There was some exception during the starting phase.
                // Wrap and throw...
                //
                throw new CommunicationException(startException,
                                                 &quot;Failed to start: &quot;+
                                                 startException);
            } else {
                // We're not ONLINE, and there's no exception...
                // Something went wrong but we don't know what...
                //
                throw new CommunicationException(&quot;Failed to start: state is &quot;+
                                                 getStringForState(state));
            }
        }
    }

    /**
     * Gets the state of this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; as an integer.
     *
     * @return &lt;CODE&gt;ONLINE&lt;/CODE&gt;, &lt;CODE&gt;OFFLINE&lt;/CODE&gt;,
     *         &lt;CODE&gt;STARTING&lt;/CODE&gt; or &lt;CODE&gt;STOPPING&lt;/CODE&gt;.
     */
    @Override
    public int getState() {
        synchronized (stateLock) {
            return state ;
        }
    }

    /**
     * Gets the state of this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; as a string.
     *
     * @return One of the strings &quot;ONLINE&quot;, &quot;OFFLINE&quot;, &quot;STARTING&quot; or
     *         &quot;STOPPING&quot;.
     */
    @Override
    public String getStateString() {
        return getStringForState(state) ;
    }

    /**
     * Gets the host name used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
     *
     * @return The host name used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
     */
    @Override
    public String getHost() {
        try {
            host = InetAddress.getLocalHost().getHostName();
        } catch (Exception e) {
            host = &quot;Unknown host&quot;;
        }
        return host ;
    }

    /**
     * Gets the port number used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
     *
     * @return The port number used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
     */
    @Override
    public int getPort() {
        synchronized (stateLock) {
            return port ;
        }
    }

    /**
     * Sets the port number used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
     *
     * @param port The port number used by this
     *             &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
     *
     * @exception java.lang.IllegalStateException This method has been invoked
     * while the communicator was ONLINE or STARTING.
     */
    @Override
    public void setPort(int port) throws java.lang.IllegalStateException {
        synchronized (stateLock) {
            if ((state == ONLINE) || (state == STARTING))
                throw new IllegalStateException(&quot;Stop server before &quot; +
                                                &quot;carrying out this operation&quot;);
            this.port = port;
            dbgTag = makeDebugTag();
        }
    }

    /**
     * Gets the protocol being used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
     * @return The protocol as a string.
     */
    @Override
    public abstract String getProtocol();

    /**
     * Gets the number of clients that have been processed by this
     * &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;  since its creation.
     *
     * @return The number of clients handled by this
     *         &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;
     *         since its creation. This counter is not reset by the
     *         &lt;CODE&gt;stop&lt;/CODE&gt; method.
     */
    int getServedClientCount() {
        return servedClientCount ;
    }

    /**
     * Gets the number of clients currently being processed by this
     * &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
     *
     * @return The number of clients currently being processed by this
     *         &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
     */
    int getActiveClientCount() {
        int result = clientHandlerVector.size() ;
        return result ;
    }

    /**
     * Gets the maximum number of clients that this
     * &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; can  process concurrently.
     *
     * @return The maximum number of clients that this
     *         &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; can
     *         process concurrently.
     */
    int getMaxActiveClientCount() {
        return maxActiveClientCount ;
    }

    /**
     * Sets the maximum number of clients this
     * &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; can process concurrently.
     *
     * @param c The number of clients.
     *
     * @exception java.lang.IllegalStateException This method has been invoked
     * while the communicator was ONLINE or STARTING.
     */
    void setMaxActiveClientCount(int c)
        throws java.lang.IllegalStateException {
        synchronized (stateLock) {
            if ((state == ONLINE) || (state == STARTING)) {
                throw new IllegalStateException(
                          &quot;Stop server before carrying out this operation&quot;);
            }
            maxActiveClientCount = c ;
        }
    }

    /**
     * For SNMP Runtime internal use only.
     */
    void notifyClientHandlerCreated(ClientHandler h) {
        clientHandlerVector.addElement(h) ;
    }

    /**
     * For SNMP Runtime internal use only.
     */
    synchronized void notifyClientHandlerDeleted(ClientHandler h) {
        clientHandlerVector.removeElement(h);
        notifyAll();
    }

    /**
     * The number of times the communicator server will attempt
     * to bind before giving up.
     **/
    protected int getBindTries() {
        return 50;
    }

    /**
     * The delay, in ms, during which the communicator server will sleep before
     * attempting to bind again.
     **/
    protected long getBindSleepTime() {
        return 100;
    }

    /**
     * For SNMP Runtime internal use only.
     * &lt;p&gt;
     * The &lt;CODE&gt;run&lt;/CODE&gt; method executed by this connector's main thread.
     */
    @Override
    public void run() {

        // Fix jaw.00667.B
        // It seems that the init of &quot;i&quot; and &quot;success&quot;
        // need to be done outside the &quot;try&quot; clause...
        // A bug in Java 2 production release ?
        //
        int i = 0;
        boolean success = false;

        // ----------------------
        // Bind
        // ----------------------
        try {
            // Fix for bug 4352451: &quot;java.net.BindException: Address in use&quot;.
            //
            final int  bindRetries = getBindTries();
            final long sleepTime   = getBindSleepTime();
            while (i &lt; bindRetries &amp;&amp; !success) {
                try {
                    // Try socket connection.
                    //
                    doBind();
                    success = true;
                } catch (CommunicationException ce) {
                    i++;
                    try {
                        Thread.sleep(sleepTime);
                    } catch (InterruptedException ie) {
                        throw ie;
                    }
                }
            }
            // Retry last time to get correct exception.
            //
            if (!success) {
                // Try socket connection.
                //
                doBind();
            }

        } catch(Exception x) {
            if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINEST)) {
                SNMP_ADAPTOR_LOGGER.logp(Level.FINEST, dbgTag,
                    &quot;run&quot;, &quot;Got unexpected exception&quot;, x);
            }
            synchronized(stateLock) {
                startException = x;
                changeState(OFFLINE);
            }
            if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                    &quot;run&quot;,&quot;State is OFFLINE&quot;);
            }
            doError(x);
            return;
        }

        try {
            // ----------------------
            // State change
            // ----------------------
            changeState(ONLINE) ;
            if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                    &quot;run&quot;,&quot;State is ONLINE&quot;);
            }

            // ----------------------
            // Main loop
            // ----------------------
            while (!stopRequested) {
                servedClientCount++;
                doReceive() ;
                waitIfTooManyClients() ;
                doProcess() ;
            }
            if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                    &quot;run&quot;,&quot;Stop has been requested&quot;);
            }

        } catch(InterruptedException x) {
            if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINEST)) {
                SNMP_ADAPTOR_LOGGER.logp(Level.FINEST, dbgTag,
                    &quot;run&quot;,&quot;Interrupt caught&quot;);
            }
            changeState(STOPPING);
        } catch(Exception x) {
            if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINEST)) {
                SNMP_ADAPTOR_LOGGER.logp(Level.FINEST, dbgTag,
                    &quot;run&quot;,&quot;Got unexpected exception&quot;, x);
            }
            changeState(STOPPING);
        } finally {
            synchronized (stateLock) {
                interrupted = true;
                Thread.interrupted();
            }

            // ----------------------
            // unBind
            // ----------------------
            try {
                doUnbind() ;
                waitClientTermination() ;
                changeState(OFFLINE);
                if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                    SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                        &quot;run&quot;,&quot;State is OFFLINE&quot;);
                }
            } catch(Exception x) {
                if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINEST)) {
                    SNMP_ADAPTOR_LOGGER.logp(Level.FINEST, dbgTag,
                        &quot;run&quot;,&quot;Got unexpected exception&quot;, x);
                }
                changeState(OFFLINE);
            }

        }
    }

    /**
     */
    protected abstract void doError(Exception e) throws CommunicationException;

    //
    // To be defined by the subclass.
    //
    // Each method below is called by run() and must be subclassed.
    // If the method sends an exception (Communication or Interrupt), this
    // will end up the run() method and switch the connector offline.
    //
    // If it is a CommunicationException, run() will call
    //       Debug.printException().
    //
    // All these methods should propagate the InterruptedException to inform
    // run() that the connector must be switch OFFLINE.
    //
    //
    //
    // doBind() should do all what is needed before calling doReceive().
    // If doBind() throws an exception, doUnbind() is not to be called
    // and run() ends up.
    //

    /**
     */
    protected abstract void doBind()
        throws CommunicationException, InterruptedException ;

    /**
     * &lt;CODE&gt;doReceive()&lt;/CODE&gt; should block until a client is available.
     * If this method throws an exception, &lt;CODE&gt;doProcess()&lt;/CODE&gt; is not
     * called but &lt;CODE&gt;doUnbind()&lt;/CODE&gt; is called then &lt;CODE&gt;run()&lt;/CODE&gt;
     * stops.
     */
    protected abstract void doReceive()
        throws CommunicationException, InterruptedException ;

    /**
     * &lt;CODE&gt;doProcess()&lt;/CODE&gt; is called after &lt;CODE&gt;doReceive()&lt;/CODE&gt;:
     * it should process the requests of the incoming client.
     * If it throws an exception, &lt;CODE&gt;doUnbind()&lt;/CODE&gt; is called and
     * &lt;CODE&gt;run()&lt;/CODE&gt; stops.
     */
    protected abstract void doProcess()
        throws CommunicationException, InterruptedException ;

    /**
     * &lt;CODE&gt;doUnbind()&lt;/CODE&gt; is called whenever the connector goes
     * &lt;CODE&gt;OFFLINE&lt;/CODE&gt;, except if &lt;CODE&gt;doBind()&lt;/CODE&gt; has thrown an
     * exception.
     */
    protected abstract void doUnbind()
        throws CommunicationException, InterruptedException ;

    /**
     * Get the &lt;code&gt;MBeanServer&lt;/code&gt; object to which incoming requests are
     * sent.  This is either the MBean server in which this connector is
     * registered, or an &lt;code&gt;MBeanServerForwarder&lt;/code&gt; leading to that
     * server.
     */
    public synchronized MBeanServer getMBeanServer() {
        return topMBS;
    }

    /**
     * Set the &lt;code&gt;MBeanServer&lt;/code&gt; object to which incoming
     * requests are sent.  This must be either the MBean server in
     * which this connector is registered, or an
     * &lt;code&gt;MBeanServerForwarder&lt;/code&gt; leading to that server.  An
     * &lt;code&gt;MBeanServerForwarder&lt;/code&gt; &lt;code&gt;mbsf&lt;/code&gt; leads to an
     * MBean server &lt;code&gt;mbs&lt;/code&gt; if
     * &lt;code&gt;mbsf.getMBeanServer()&lt;/code&gt; is either &lt;code&gt;mbs&lt;/code&gt;
     * or an &lt;code&gt;MBeanServerForwarder&lt;/code&gt; leading to
     * &lt;code&gt;mbs&lt;/code&gt;.
     *
     * @exception IllegalArgumentException if &lt;code&gt;newMBS&lt;/code&gt; is neither
     * the MBean server in which this connector is registered nor an
     * &lt;code&gt;MBeanServerForwarder&lt;/code&gt; leading to that server.
     *
     * @exception IllegalStateException This method has been invoked
     * while the communicator was ONLINE or STARTING.
     */
    public synchronized void setMBeanServer(MBeanServer newMBS)
            throws IllegalArgumentException, IllegalStateException {
        synchronized (stateLock) {
            if (state == ONLINE || state == STARTING)
                throw new IllegalStateException(&quot;Stop server before &quot; +
                                                &quot;carrying out this operation&quot;);
        }
        final String error =
            &quot;MBeanServer argument must be MBean server where this &quot; +
            &quot;server is registered, or an MBeanServerForwarder &quot; +
            &quot;leading to that server&quot;;
        Vector&lt;MBeanServer&gt; seenMBS = new Vector&lt;&gt;();
        for (MBeanServer mbs = newMBS;
             mbs != bottomMBS;
             mbs = ((MBeanServerForwarder) mbs).getMBeanServer()) {
            if (!(mbs instanceof MBeanServerForwarder))
                throw new IllegalArgumentException(error);
            if (seenMBS.contains(mbs))
                throw new IllegalArgumentException(&quot;MBeanServerForwarder &quot; +
                                                   &quot;loop&quot;);
            seenMBS.addElement(mbs);
        }
        topMBS = newMBS;
    }

    //
    // To be called by the subclass if needed
    //
    /**
     * For internal use only.
     */
    ObjectName getObjectName() {
        return objectName ;
    }

    /**
     * For internal use only.
     */
    void changeState(int newState) {
        int oldState;
        synchronized (stateLock) {
            if (state == newState)
                return;
            oldState = state;
            state = newState;
            stateLock.notifyAll();
        }
        sendStateChangeNotification(oldState, newState);
    }

    /**
     * Returns the string used in debug traces.
     */
    String makeDebugTag() {
        return &quot;CommunicatorServer[&quot;+ getProtocol() + &quot;:&quot; + getPort() + &quot;]&quot; ;
    }

    /**
     * Returns the string used to name the connector thread.
     */
    String makeThreadName() {
        String result ;

        if (objectName == null)
            result = &quot;CommunicatorServer&quot; ;
        else
            result = objectName.toString() ;

        return result ;
    }

    /**
     * This method blocks if there are too many active clients.
     * Call to &lt;CODE&gt;wait()&lt;/CODE&gt; is terminated when a client handler
     * thread calls &lt;CODE&gt;notifyClientHandlerDeleted(this)&lt;/CODE&gt; ;
     */
    private synchronized void waitIfTooManyClients()
        throws InterruptedException {
        while (getActiveClientCount() &gt;= maxActiveClientCount) {
            if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                    &quot;waitIfTooManyClients&quot;,&quot;Waiting for a client to terminate&quot;);
            }
            wait();
        }
    }

    /**
     * This method blocks until there is no more active client.
     */
    private void waitClientTermination() {
        int s = clientHandlerVector.size() ;
        if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
            if (s &gt;= 1) {
                SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                &quot;waitClientTermination&quot;,&quot;waiting for &quot; +
                      s + &quot; clients to terminate&quot;);
            }
        }

        // The ClientHandler will remove themselves from the
        // clientHandlerVector at the end of their run() method, by
        // calling notifyClientHandlerDeleted().
        // Since the clientHandlerVector is modified by the ClientHandler
        // threads we must avoid using Enumeration or Iterator to loop
        // over this array. We must also take care of NoSuchElementException
        // which could be thrown if the last ClientHandler removes itself
        // between the call to clientHandlerVector.isEmpty() and the call
        // to clientHandlerVector.firstElement().
        // What we *MUST NOT DO* is locking the clientHandlerVector, because
        // this would most probably cause a deadlock.
        //
        while (! clientHandlerVector.isEmpty()) {
            try {
                clientHandlerVector.firstElement().join();
            } catch (NoSuchElementException x) {
                if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                    SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                        &quot;waitClientTermination&quot;,&quot;No elements left&quot;,  x);
                }
            }
        }

        if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
            if (s &gt;= 1) {
                SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                    &quot;waitClientTermination&quot;,&quot;Ok, let's go...&quot;);
            }
        }
    }

    /**
     * Call &lt;CODE&gt;interrupt()&lt;/CODE&gt; on each pending client.
     */
    private void terminateAllClient() {
        final int s = clientHandlerVector.size() ;
        if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
            if (s &gt;= 1) {
                SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                    &quot;terminateAllClient&quot;,&quot;Interrupting &quot; + s + &quot; clients&quot;);
            }
        }

        // The ClientHandler will remove themselves from the
        // clientHandlerVector at the end of their run() method, by
        // calling notifyClientHandlerDeleted().
        // Since the clientHandlerVector is modified by the ClientHandler
        // threads we must avoid using Enumeration or Iterator to loop
        // over this array.
        // We cannot use the same logic here than in waitClientTermination()
        // because there is no guarantee that calling interrupt() on the
        // ClientHandler will actually terminate the ClientHandler.
        // Since we do not want to wait for the actual ClientHandler
        // termination, we cannot simply loop over the array until it is
        // empty (this might result in calling interrupt() endlessly on
        // the same client handler. So what we do is simply take a snapshot
        // copy of the vector and loop over the copy.
        // What we *MUST NOT DO* is locking the clientHandlerVector, because
        // this would most probably cause a deadlock.
        //
        final  ClientHandler[] handlers =
                clientHandlerVector.toArray(new ClientHandler[0]);
         for (ClientHandler h : handlers) {
             try {
                 h.interrupt() ;
             } catch (Exception x) {
                 if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINER)) {
                     SNMP_ADAPTOR_LOGGER.logp(Level.FINER, dbgTag,
                             &quot;terminateAllClient&quot;,
                             &quot;Failed to interrupt pending request. &quot; +
                             &quot;Ignore the exception.&quot;, x);
                 }
            }
        }
    }

    /**
     * Controls the way the CommunicatorServer service is deserialized.
     */
    private void readObject(ObjectInputStream stream)
        throws IOException, ClassNotFoundException {

        // Call the default deserialization of the object.
        //
        stream.defaultReadObject();

        // Call the specific initialization for the CommunicatorServer service.
        // This is for transient structures to be initialized to specific
        // default values.
        //
        stateLock = new Object();
        state = OFFLINE;
        stopRequested = false;
        servedClientCount = 0;
        clientHandlerVector = new Vector&lt;&gt;();
        mainThread = null;
        notifCount = 0;
        notifInfos = null;
        notifBroadcaster = new NotificationBroadcasterSupport();
        dbgTag = makeDebugTag();
    }


    //
    // NotificationBroadcaster
    //

    /**
     * Adds a listener for the notifications emitted by this
     * CommunicatorServer.
     * There is only one type of notifications sent by the CommunicatorServer:
     * they are &lt;tt&gt;{@link javax.management.AttributeChangeNotification}&lt;/tt&gt;,
     * sent when the &lt;tt&gt;State&lt;/tt&gt; attribute of this CommunicatorServer
     * changes.
     *
     * @param listener The listener object which will handle the emitted
     *        notifications.
     * @param filter The filter object. If filter is null, no filtering
     *        will be performed before handling notifications.
     * @param handback An object which will be sent back unchanged to the
     *        listener when a notification is emitted.
     *
     * @exception IllegalArgumentException Listener parameter is null.
     */
    @Override
    public void addNotificationListener(NotificationListener listener,
                                        NotificationFilter filter,
                                        Object handback)
        throws java.lang.IllegalArgumentException {

        if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINEST)) {
            SNMP_ADAPTOR_LOGGER.logp(Level.FINEST, dbgTag,
                &quot;addNotificationListener&quot;,&quot;Adding listener &quot;+ listener +
                  &quot; with filter &quot;+ filter + &quot; and handback &quot;+ handback);
        }
        notifBroadcaster.addNotificationListener(listener, filter, handback);
    }

    /**
     * Removes the specified listener from this CommunicatorServer.
     * Note that if the listener has been registered with different
     * handback objects or notification filters, all entries corresponding
     * to the listener will be removed.
     *
     * @param listener The listener object to be removed.
     *
     * @exception ListenerNotFoundException The listener is not registered.
     */
    @Override
    public void removeNotificationListener(NotificationListener listener)
        throws ListenerNotFoundException {

        if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINEST)) {
            SNMP_ADAPTOR_LOGGER.logp(Level.FINEST, dbgTag,
                &quot;removeNotificationListener&quot;,&quot;Removing listener &quot;+ listener);
        }
        notifBroadcaster.removeNotificationListener(listener);
    }

    /**
     * Returns an array of MBeanNotificationInfo objects describing
     * the notification types sent by this CommunicatorServer.
     * There is only one type of notifications sent by the CommunicatorServer:
     * it is &lt;tt&gt;{@link javax.management.AttributeChangeNotification}&lt;/tt&gt;,
     * sent when the &lt;tt&gt;State&lt;/tt&gt; attribute of this CommunicatorServer
     * changes.
     */
    @Override
    public MBeanNotificationInfo[] getNotificationInfo() {

        // Initialize notifInfos on first call to getNotificationInfo()
        //
        if (notifInfos == null) {
            notifInfos = new MBeanNotificationInfo[1];
            String[] notifTypes = {
                AttributeChangeNotification.ATTRIBUTE_CHANGE};
            notifInfos[0] = new MBeanNotificationInfo( notifTypes,
                     AttributeChangeNotification.class.getName(),
                     &quot;Sent to notify that the value of the State attribute &quot;+
                     &quot;of this CommunicatorServer instance has changed.&quot;);
        }

        return notifInfos.clone();
    }

    /**
     *
     */
    private void sendStateChangeNotification(int oldState, int newState) {

        String oldStateString = getStringForState(oldState);
        String newStateString = getStringForState(newState);
        String message = new StringBuffer().append(dbgTag)
            .append(&quot; The value of attribute State has changed from &quot;)
            .append(oldState).append(&quot; (&quot;).append(oldStateString)
            .append(&quot;) to &quot;).append(newState).append(&quot; (&quot;)
            .append(newStateString).append(&quot;).&quot;).toString();

        notifCount++;
        AttributeChangeNotification notif =
            new AttributeChangeNotification(this,    // source
                         notifCount,                 // sequence number
                         System.currentTimeMillis(), // time stamp
                         message,                    // message
                         &quot;State&quot;,                    // attribute name
                         &quot;int&quot;,                      // attribute type
                         new Integer(oldState),      // old value
                         new Integer(newState) );    // new value
        if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINEST)) {
            SNMP_ADAPTOR_LOGGER.logp(Level.FINEST, dbgTag,
                &quot;sendStateChangeNotification&quot;,&quot;Sending AttributeChangeNotification #&quot;
                    + notifCount + &quot; with message: &quot;+ message);
        }
        notifBroadcaster.sendNotification(notif);
    }

    /**
     *
     */
    private static String getStringForState(int s) {
        switch (s) {
        case ONLINE:   return &quot;ONLINE&quot;;
        case STARTING: return &quot;STARTING&quot;;
        case OFFLINE:  return &quot;OFFLINE&quot;;
        case STOPPING: return &quot;STOPPING&quot;;
        default:       return &quot;UNDEFINED&quot;;
        }
    }


    //
    // MBeanRegistration
    //

    /**
     * Preregister method of connector.
     *
     *@param server The &lt;CODE&gt;MBeanServer&lt;/CODE&gt; in which the MBean will
     *       be registered.
     *@param name The object name of the MBean.
     *
     *@return  The name of the MBean registered.
     *
     *@exception java.langException This exception should be caught by
     *           the &lt;CODE&gt;MBeanServer&lt;/CODE&gt; and re-thrown
     *           as an &lt;CODE&gt;MBeanRegistrationException&lt;/CODE&gt;.
     */
    @Override
    public ObjectName preRegister(MBeanServer server, ObjectName name)
            throws java.lang.Exception {
        objectName = name;
        synchronized (this) {
            if (bottomMBS != null) {
                throw new IllegalArgumentException(&quot;connector already &quot; +
                                                   &quot;registered in an MBean &quot; +
                                                   &quot;server&quot;);
            }
            topMBS = bottomMBS = server;
        }
        dbgTag = makeDebugTag();
        return name;
    }

    /**
     *
     *@param registrationDone Indicates whether or not the MBean has been
     *       successfully registered in the &lt;CODE&gt;MBeanServer&lt;/CODE&gt;.
     *       The value false means that the registration phase has failed.
     */
    @Override
    public void postRegister(Boolean registrationDone) {
        if (!registrationDone.booleanValue()) {
            synchronized (this) {
                topMBS = bottomMBS = null;
            }
        }
    }

    /**
     * Stop the connector.
     *
     * @exception java.langException This exception should be caught by
     *            the &lt;CODE&gt;MBeanServer&lt;/CODE&gt; and re-thrown
     *            as an &lt;CODE&gt;MBeanRegistrationException&lt;/CODE&gt;.
     */
    @Override
    public void preDeregister() throws java.lang.Exception {
        synchronized (this) {
            topMBS = bottomMBS = null;
        }
        objectName = null ;
        final int cstate = getState();
        if ((cstate == ONLINE) || ( cstate == STARTING)) {
            stop() ;
        }
    }

    /**
     * Do nothing.
     */
    @Override
    public void postDeregister(){
    }

}
</pre>
</body>
</html>
