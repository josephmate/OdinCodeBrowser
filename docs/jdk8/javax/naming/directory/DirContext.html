<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.naming.directory;

import javax.naming.*;

/**
 * The directory service interface, containing
 * methods for examining and updating attributes
 * associated with objects, and for searching the directory.
 *
 * &lt;h1&gt;Names&lt;/h1&gt;
 * Each name passed as an argument to a &lt;tt&gt;DirContext&lt;/tt&gt; method is relative
 * to that context.  The empty name is used to name the context itself.
 * The name parameter may never be null.
 * &lt;p&gt;
 * Most of the methods have overloaded versions with one taking a
 * &lt;code&gt;Name&lt;/code&gt; parameter and one taking a &lt;code&gt;String&lt;/code&gt;.
 * These overloaded versions are equivalent in that if
 * the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; parameters are just
 * different representations of the same name, then the overloaded
 * versions of the same methods behave the same.
 * In the method descriptions below, only one version is documented.
 * The second version instead has a link to the first:  the same
 * documentation applies to both.
 * &lt;p&gt;
 * See &lt;tt&gt;Context&lt;/tt&gt; for a discussion on the interpretation of the
 * name argument to the &lt;tt&gt;Context&lt;/tt&gt; methods. These same rules
 * apply to the name argument to the &lt;tt&gt;DirContext&lt;/tt&gt; methods.
 *
 * &lt;h1&gt;Attribute Models&lt;/h1&gt;
 * There are two basic models of what attributes should be
 * associated with.  First, attributes may be directly associated with a
 * DirContext object.
 * In this model, an attribute operation on the named object is
 * roughly equivalent
 * to a lookup on the name (which returns the DirContext object),
 * followed by the attribute operation invoked on the DirContext object
 * in which the caller supplies an empty name. The attributes can be viewed
 * as being stored along with the object (note that this does not imply that
 * the implementation must do so).
 * &lt;p&gt;
 * The second model is that attributes are associated with a
 * name (typically an atomic name) in a DirContext.
 * In this model, an attribute operation on the named object is
 * roughly equivalent to a lookup on the name of the parent DirContext of the
 * named object, followed by the attribute operation invoked on the parent
 * in which the caller supplies the terminal atomic name.
 * The attributes can be viewed as being stored in the parent DirContext
 * (again, this does not imply that the implementation must do so).
 * Objects that are not DirContexts can have attributes, as long as
 * their parents are DirContexts.
 * &lt;p&gt;
 * JNDI support both of these models.
 * It is up to the individual service providers to decide where to
 * &quot;store&quot; attributes.
 * JNDI clients are safest when they do not make assumptions about
 * whether an object's attributes are stored as part of the object, or stored
 * within the parent object and associated with the object's name.
 *
 * &lt;h1&gt;Attribute Type Names&lt;/h1&gt;
 * In the &lt;tt&gt;getAttributes()&lt;/tt&gt; and &lt;tt&gt;search()&lt;/tt&gt; methods,
 * you can supply the attributes to return by supplying a list of
 * attribute names (strings).
 * The attributes that you get back might not have the same names as the
 * attribute names you have specified. This is because some directories
 * support features that cause them to return other attributes.  Such
 * features include attribute subclassing, attribute name synonyms, and
 * attribute language codes.
 * &lt;p&gt;
 * In attribute subclassing, attributes are defined in a class hierarchy.
 * In some directories, for example, the &quot;name&quot; attribute might be the
 * superclass of all name-related attributes, including &quot;commonName&quot; and
 * &quot;surName&quot;.  Asking for the &quot;name&quot; attribute might return both the
 * &quot;commonName&quot; and &quot;surName&quot; attributes.
 * &lt;p&gt;
 * With attribute type synonyms, a directory can assign multiple names to
 * the same attribute. For example, &quot;cn&quot; and &quot;commonName&quot; might both
 * refer to the same attribute. Asking for &quot;cn&quot; might return the
 * &quot;commonName&quot; attribute.
 * &lt;p&gt;
 * Some directories support the language codes for attributes.
 * Asking such a directory for the &quot;description&quot; attribute, for example,
 * might return all of the following attributes:
 * &lt;ul&gt;
 * &lt;li&gt;description
 * &lt;li&gt;description;lang-en
 * &lt;li&gt;description;lang-de
 * &lt;li&gt;description;lang-fr
 * &lt;/ul&gt;
 *
 *
 *&lt;h1&gt;Operational Attributes&lt;/h1&gt;
 *&lt;p&gt;
 * Some directories have the notion of &quot;operational attributes&quot; which are
 * attributes associated with a directory object for administrative
 * purposes. An example of operational attributes is the access control
 * list for an object.
 * &lt;p&gt;
 * In the &lt;tt&gt;getAttributes()&lt;/tt&gt; and &lt;tt&gt;search()&lt;/tt&gt; methods,
 * you can specify that all attributes associated with the requested objects
 * be returned by supply &lt;tt&gt;null&lt;/tt&gt; as the list of attributes to return.
 * The attributes returned do &lt;em&gt;not&lt;/em&gt; include operational attributes.
 * In order to retrieve operational attributes, you must name them explicitly.
 *
 *
 * &lt;h1&gt;Named Context&lt;/h1&gt;
 * &lt;p&gt;
 * There are certain methods in which the name must resolve to a context
 * (for example, when searching a single level context). The documentation
 * of such methods
 * use the term &lt;em&gt;named context&lt;/em&gt; to describe their name parameter.
 * For these methods, if the named object is not a DirContext,
 * &lt;code&gt;NotContextException&lt;/code&gt; is thrown.
 * Aside from these methods, there is no requirement that the
 * &lt;em&gt;named object&lt;/em&gt; be a DirContext.
 *
 *&lt;h1&gt;Parameters&lt;/h1&gt;
 *&lt;p&gt;
 * An &lt;tt&gt;Attributes&lt;/tt&gt;, &lt;tt&gt;SearchControls&lt;/tt&gt;, or array object
 * passed as a parameter to any method will not be modified by the
 * service provider.  The service provider may keep a reference to it
 * for the duration of the operation, including any enumeration of the
 * method's results and the processing of any referrals generated.
 * The caller should not modify the object during this time.
 * An &lt;tt&gt;Attributes&lt;/tt&gt; object returned by any method is owned by
 * the caller.  The caller may subsequently modify it; the service
 * provider will not.
 *
 *&lt;h1&gt;Exceptions&lt;/h1&gt;
 *&lt;p&gt;
 * All the methods in this interface can throw a NamingException or
 * any of its subclasses. See NamingException and their subclasses
 * for details on each exception.
 *
 * @author Rosanna Lee
 * @author Scott Seligman
 * @author R. Vasudevan
 *
 * @see javax.naming.Context
 * @since 1.3
 */

public interface DirContext extends Context {

    /**
     * Retrieves all of the attributes associated with a named object.
     * See the class description regarding attribute models, attribute
     * type names, and operational attributes.
     *
     * @param name
     *          the name of the object from which to retrieve attributes
     * @return  the set of attributes associated with &lt;code&gt;name&lt;/code&gt;.
     *          Returns an empty attribute set if name has no attributes;
     *          never null.
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #getAttributes(String)
     * @see #getAttributes(Name, String[])
     */
    public Attributes getAttributes(Name name) throws NamingException;

    /**
     * Retrieves all of the attributes associated with a named object.
     * See {@link #getAttributes(Name)} for details.
     *
     * @param name
     *          the name of the object from which to retrieve attributes
     * @return  the set of attributes associated with &lt;code&gt;name&lt;/code&gt;
     *
     * @throws  NamingException if a naming exception is encountered
     */
    public Attributes getAttributes(String name) throws NamingException;

    /**
     * Retrieves selected attributes associated with a named object.
     * See the class description regarding attribute models, attribute
     * type names, and operational attributes.
     *
     * &lt;p&gt; If the object does not have an attribute
     * specified, the directory will ignore the nonexistent attribute
     * and return those requested attributes that the object does have.
     *
     * &lt;p&gt; A directory might return more attributes than was requested
     * (see &lt;strong&gt;Attribute Type Names&lt;/strong&gt; in the class description),
     * but is not allowed to return arbitrary, unrelated attributes.
     *
     * &lt;p&gt; See also &lt;strong&gt;Operational Attributes&lt;/strong&gt; in the class
     * description.
     *
     * @param name
     *          the name of the object from which to retrieve attributes
     * @param attrIds
     *          the identifiers of the attributes to retrieve.
     *          null indicates that all attributes should be retrieved;
     *          an empty array indicates that none should be retrieved.
     * @return  the requested attributes; never null
     *
     * @throws  NamingException if a naming exception is encountered
     */
    public Attributes getAttributes(Name name, String[] attrIds)
            throws NamingException;

    /**
     * Retrieves selected attributes associated with a named object.
     * See {@link #getAttributes(Name, String[])} for details.
     *
     * @param name
     *          The name of the object from which to retrieve attributes
     * @param attrIds
     *          the identifiers of the attributes to retrieve.
     *          null indicates that all attributes should be retrieved;
     *          an empty array indicates that none should be retrieved.
     * @return  the requested attributes; never null
     *
     * @throws  NamingException if a naming exception is encountered
     */
    public Attributes getAttributes(String name, String[] attrIds)
            throws NamingException;

    /**
     * This constant specifies to add an attribute with the specified values.
     * &lt;p&gt;
     * If attribute does not exist,
     * create the attribute.  The resulting attribute has a union of the
     * specified value set and the prior value set.
     * Adding an attribute with no value will throw
     * &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; if the attribute must have
     * at least  one value.  For a single-valued attribute where that attribute
     * already exists, throws &lt;code&gt;AttributeInUseException&lt;/code&gt;.
     * If attempting to add more than one value to a single-valued attribute,
     * throws &lt;code&gt;InvalidAttributeValueException&lt;/code&gt;.
     * &lt;p&gt;
     * The value of this constant is &lt;tt&gt;1&lt;/tt&gt;.
     *
     * @see ModificationItem
     * @see #modifyAttributes
     */
    public final static int ADD_ATTRIBUTE = 1;

    /**
     * This constant specifies to replace an attribute with specified values.
     *&lt;p&gt;
     * If attribute already exists,
     * replaces all existing values with new specified values.  If the
     * attribute does not exist, creates it.  If no value is specified,
     * deletes all the values of the attribute.
     * Removal of the last value will remove the attribute if the attribute
     * is required to have at least one value.  If
     * attempting to add more than one value to a single-valued attribute,
     * throws &lt;code&gt;InvalidAttributeValueException&lt;/code&gt;.
     * &lt;p&gt;
     * The value of this constant is &lt;tt&gt;2&lt;/tt&gt;.
     *
     * @see ModificationItem
     * @see #modifyAttributes
     */
    public final static int REPLACE_ATTRIBUTE = 2;

    /**
     * This constant specifies to delete
     * the specified attribute values from the attribute.
     *&lt;p&gt;
     * The resulting attribute has the set difference of its prior value set
     * and the specified value set.
     * If no values are specified, deletes the entire attribute.
     * If the attribute does not exist, or if some or all members of the
     * specified value set do not exist, this absence may be ignored
     * and the operation succeeds, or a NamingException may be thrown to
     * indicate the absence.
     * Removal of the last value will remove the attribute if the
     * attribute is required to have at least one value.
     * &lt;p&gt;
     * The value of this constant is &lt;tt&gt;3&lt;/tt&gt;.
     *
     * @see ModificationItem
     * @see #modifyAttributes
     */
    public final static int REMOVE_ATTRIBUTE = 3;

    /**
     * Modifies the attributes associated with a named object.
     * The order of the modifications is not specified.  Where
     * possible, the modifications are performed atomically.
     *
     * @param name
     *          the name of the object whose attributes will be updated
     * @param mod_op
     *          the modification operation, one of:
     *                  &lt;code&gt;ADD_ATTRIBUTE&lt;/code&gt;,
     *                  &lt;code&gt;REPLACE_ATTRIBUTE&lt;/code&gt;,
     *                  &lt;code&gt;REMOVE_ATTRIBUTE&lt;/code&gt;.
     * @param attrs
     *          the attributes to be used for the modification; may not be null
     *
     * @throws  AttributeModificationException if the modification cannot
     *          be completed successfully
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #modifyAttributes(Name, ModificationItem[])
     */
    public void modifyAttributes(Name name, int mod_op, Attributes attrs)
            throws NamingException;

    /**
     * Modifies the attributes associated with a named object.
     * See {@link #modifyAttributes(Name, int, Attributes)} for details.
     *
     * @param name
     *          the name of the object whose attributes will be updated
     * @param mod_op
     *          the modification operation, one of:
     *                  &lt;code&gt;ADD_ATTRIBUTE&lt;/code&gt;,
     *                  &lt;code&gt;REPLACE_ATTRIBUTE&lt;/code&gt;,
     *                  &lt;code&gt;REMOVE_ATTRIBUTE&lt;/code&gt;.
     * @param attrs
     *          the attributes to be used for the modification; may not be null
     *
     * @throws  AttributeModificationException if the modification cannot
     *          be completed successfully
     * @throws  NamingException if a naming exception is encountered
     */
    public void modifyAttributes(String name, int mod_op, Attributes attrs)
            throws NamingException;

    /**
     * Modifies the attributes associated with a named object using
     * an ordered list of modifications.
     * The modifications are performed
     * in the order specified.  Each modification specifies a
     * modification operation code and an attribute on which to
     * operate.  Where possible, the modifications are
     * performed atomically.
     *
     * @param name
     *          the name of the object whose attributes will be updated
     * @param mods
     *          an ordered sequence of modifications to be performed;
     *          may not be null
     *
     * @throws  AttributeModificationException if the modifications
     *          cannot be completed successfully
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #modifyAttributes(Name, int, Attributes)
     * @see ModificationItem
     */
    public void modifyAttributes(Name name, ModificationItem[] mods)
            throws NamingException;

    /**
     * Modifies the attributes associated with a named object using
     * an ordered list of modifications.
     * See {@link #modifyAttributes(Name, ModificationItem[])} for details.
     *
     * @param name
     *          the name of the object whose attributes will be updated
     * @param mods
     *          an ordered sequence of modifications to be performed;
     *          may not be null
     *
     * @throws  AttributeModificationException if the modifications
     *          cannot be completed successfully
     * @throws  NamingException if a naming exception is encountered
     */
    public void modifyAttributes(String name, ModificationItem[] mods)
            throws NamingException;

    /**
     * Binds a name to an object, along with associated attributes.
     * If &lt;tt&gt;attrs&lt;/tt&gt; is null, the resulting binding will have
     * the attributes associated with &lt;tt&gt;obj&lt;/tt&gt; if &lt;tt&gt;obj&lt;/tt&gt; is a
     * &lt;tt&gt;DirContext&lt;/tt&gt;, and no attributes otherwise.
     * If &lt;tt&gt;attrs&lt;/tt&gt; is non-null, the resulting binding will have
     * &lt;tt&gt;attrs&lt;/tt&gt; as its attributes; any attributes associated with
     * &lt;tt&gt;obj&lt;/tt&gt; are ignored.
     *
     * @param name
     *          the name to bind; may not be empty
     * @param obj
     *          the object to bind; possibly null
     * @param attrs
     *          the attributes to associate with the binding
     *
     * @throws  NameAlreadyBoundException if name is already bound
     * @throws  InvalidAttributesException if some &quot;mandatory&quot; attributes
     *          of the binding are not supplied
     * @throws  NamingException if a naming exception is encountered
     *
     * @see Context#bind(Name, Object)
     * @see #rebind(Name, Object, Attributes)
     */
    public void bind(Name name, Object obj, Attributes attrs)
            throws NamingException;

    /**
     * Binds a name to an object, along with associated attributes.
     * See {@link #bind(Name, Object, Attributes)} for details.
     *
     * @param name
     *          the name to bind; may not be empty
     * @param obj
     *          the object to bind; possibly null
     * @param attrs
     *          the attributes to associate with the binding
     *
     * @throws  NameAlreadyBoundException if name is already bound
     * @throws  InvalidAttributesException if some &quot;mandatory&quot; attributes
     *          of the binding are not supplied
     * @throws  NamingException if a naming exception is encountered
     */
    public void bind(String name, Object obj, Attributes attrs)
            throws NamingException;

    /**
     * Binds a name to an object, along with associated attributes,
     * overwriting any existing binding.
     * If &lt;tt&gt;attrs&lt;/tt&gt; is null and &lt;tt&gt;obj&lt;/tt&gt; is a &lt;tt&gt;DirContext&lt;/tt&gt;,
     * the attributes from &lt;tt&gt;obj&lt;/tt&gt; are used.
     * If &lt;tt&gt;attrs&lt;/tt&gt; is null and &lt;tt&gt;obj&lt;/tt&gt; is not a &lt;tt&gt;DirContext&lt;/tt&gt;,
     * any existing attributes associated with the object already bound
     * in the directory remain unchanged.
     * If &lt;tt&gt;attrs&lt;/tt&gt; is non-null, any existing attributes associated with
     * the object already bound in the directory are removed and &lt;tt&gt;attrs&lt;/tt&gt;
     * is associated with the named object.  If &lt;tt&gt;obj&lt;/tt&gt; is a
     * &lt;tt&gt;DirContext&lt;/tt&gt; and &lt;tt&gt;attrs&lt;/tt&gt; is non-null, the attributes
     * of &lt;tt&gt;obj&lt;/tt&gt; are ignored.
     *
     * @param name
     *          the name to bind; may not be empty
     * @param obj
     *          the object to bind; possibly null
     * @param attrs
     *          the attributes to associate with the binding
     *
     * @throws  InvalidAttributesException if some &quot;mandatory&quot; attributes
     *          of the binding are not supplied
     * @throws  NamingException if a naming exception is encountered
     *
     * @see Context#bind(Name, Object)
     * @see #bind(Name, Object, Attributes)
     */
    public void rebind(Name name, Object obj, Attributes attrs)
            throws NamingException;

    /**
     * Binds a name to an object, along with associated attributes,
     * overwriting any existing binding.
     * See {@link #rebind(Name, Object, Attributes)} for details.
     *
     * @param name
     *          the name to bind; may not be empty
     * @param obj
     *          the object to bind; possibly null
     * @param attrs
     *          the attributes to associate with the binding
     *
     * @throws  InvalidAttributesException if some &quot;mandatory&quot; attributes
     *          of the binding are not supplied
     * @throws  NamingException if a naming exception is encountered
     */
    public void rebind(String name, Object obj, Attributes attrs)
            throws NamingException;

    /**
     * Creates and binds a new context, along with associated attributes.
     * This method creates a new subcontext with the given name, binds it in
     * the target context (that named by all but terminal atomic
     * component of the name), and associates the supplied attributes
     * with the newly created object.
     * All intermediate and target contexts must already exist.
     * If &lt;tt&gt;attrs&lt;/tt&gt; is null, this method is equivalent to
     * &lt;tt&gt;Context.createSubcontext()&lt;/tt&gt;.
     *
     * @param name
     *          the name of the context to create; may not be empty
     * @param attrs
     *          the attributes to associate with the newly created context
     * @return  the newly created context
     *
     * @throws  NameAlreadyBoundException if the name is already bound
     * @throws  InvalidAttributesException if &lt;code&gt;attrs&lt;/code&gt; does not
     *          contain all the mandatory attributes required for creation
     * @throws  NamingException if a naming exception is encountered
     *
     * @see Context#createSubcontext(Name)
     */
    public DirContext createSubcontext(Name name, Attributes attrs)
            throws NamingException;

    /**
     * Creates and binds a new context, along with associated attributes.
     * See {@link #createSubcontext(Name, Attributes)} for details.
     *
     * @param name
     *          the name of the context to create; may not be empty
     * @param attrs
     *          the attributes to associate with the newly created context
     * @return  the newly created context
     *
     * @throws  NameAlreadyBoundException if the name is already bound
     * @throws  InvalidAttributesException if &lt;code&gt;attrs&lt;/code&gt; does not
     *          contain all the mandatory attributes required for creation
     * @throws  NamingException if a naming exception is encountered
     */
    public DirContext createSubcontext(String name, Attributes attrs)
            throws NamingException;

// -------------------- schema operations

    /**
     * Retrieves the schema associated with the named object.
     * The schema describes rules regarding the structure of the namespace
     * and the attributes stored within it.  The schema
     * specifies what types of objects can be added to the directory and where
     * they can be added; what mandatory and optional attributes an object
     * can have. The range of support for schemas is directory-specific.
     *
     * &lt;p&gt; This method returns the root of the schema information tree
     * that is applicable to the named object. Several named objects
     * (or even an entire directory) might share the same schema.
     *
     * &lt;p&gt; Issues such as structure and contents of the schema tree,
     * permission to modify to the contents of the schema
     * tree, and the effect of such modifications on the directory
     * are dependent on the underlying directory.
     *
     * @param name
     *          the name of the object whose schema is to be retrieved
     * @return  the schema associated with the context; never null
     * @throws  OperationNotSupportedException if schema not supported
     * @throws  NamingException if a naming exception is encountered
     */
    public DirContext getSchema(Name name) throws NamingException;

    /**
     * Retrieves the schema associated with the named object.
     * See {@link #getSchema(Name)} for details.
     *
     * @param name
     *          the name of the object whose schema is to be retrieved
     * @return  the schema associated with the context; never null
     * @throws  OperationNotSupportedException if schema not supported
     * @throws  NamingException if a naming exception is encountered
     */
    public DirContext getSchema(String name) throws NamingException;

    /**
     * Retrieves a context containing the schema objects of the
     * named object's class definitions.
     *&lt;p&gt;
     * One category of information found in directory schemas is
     * &lt;em&gt;class definitions&lt;/em&gt;.  An &quot;object class&quot; definition
     * specifies the object's &lt;em&gt;type&lt;/em&gt; and what attributes (mandatory
     * and optional) the object must/can have. Note that the term
     * &quot;object class&quot; being referred to here is in the directory sense
     * rather than in the Java sense.
     * For example, if the named object is a directory object of
     * &quot;Person&quot; class, &lt;tt&gt;getSchemaClassDefinition()&lt;/tt&gt; would return a
     * &lt;tt&gt;DirContext&lt;/tt&gt; representing the (directory's) object class
     * definition of &quot;Person&quot;.
     *&lt;p&gt;
     * The information that can be retrieved from an object class definition
     * is directory-dependent.
     *&lt;p&gt;
     * Prior to JNDI 1.2, this method
     * returned a single schema object representing the class definition of
     * the named object.
     * Since JNDI 1.2, this method returns a &lt;tt&gt;DirContext&lt;/tt&gt; containing
     * all of the named object's class definitions.
     *
     * @param name
     *          the name of the object whose object class
     *          definition is to be retrieved
     * @return  the &lt;tt&gt;DirContext&lt;/tt&gt; containing the named
     *          object's class definitions; never null
     *
     * @throws  OperationNotSupportedException if schema not supported
     * @throws  NamingException if a naming exception is encountered
     */
    public DirContext getSchemaClassDefinition(Name name)
            throws NamingException;

    /**
     * Retrieves a context containing the schema objects of the
     * named object's class definitions.
     * See {@link #getSchemaClassDefinition(Name)} for details.
     *
     * @param name
     *          the name of the object whose object class
     *          definition is to be retrieved
     * @return  the &lt;tt&gt;DirContext&lt;/tt&gt; containing the named
     *          object's class definitions; never null
     *
     * @throws  OperationNotSupportedException if schema not supported
     * @throws  NamingException if a naming exception is encountered
     */
    public DirContext getSchemaClassDefinition(String name)
            throws NamingException;

// -------------------- search operations

    /**
     * Searches in a single context for objects that contain a
     * specified set of attributes, and retrieves selected attributes.
     * The search is performed using the default
     * &lt;code&gt;SearchControls&lt;/code&gt; settings.
     * &lt;p&gt;
     * For an object to be selected, each attribute in
     * &lt;code&gt;matchingAttributes&lt;/code&gt; must match some attribute of the
     * object.  If &lt;code&gt;matchingAttributes&lt;/code&gt; is empty or
     * null, all objects in the target context are returned.
     *&lt;p&gt;
     * An attribute &lt;em&gt;A&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; in
     * &lt;code&gt;matchingAttributes&lt;/code&gt; is considered to match an
     * attribute &lt;em&gt;A&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt; of an object if
     * &lt;em&gt;A&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;em&gt;A&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt; have the same
     * identifier, and each value of &lt;em&gt;A&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; is equal
     * to some value of &lt;em&gt;A&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;.  This implies that the
     * order of values is not significant, and that
     * &lt;em&gt;A&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt; may contain &quot;extra&quot; values not found in
     * &lt;em&gt;A&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; without affecting the comparison.  It
     * also implies that if &lt;em&gt;A&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; has no values, then
     * testing for a match is equivalent to testing for the presence
     * of an attribute &lt;em&gt;A&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt; with the same
     * identifier.
     *&lt;p&gt;
     * The precise definition of &quot;equality&quot; used in comparing attribute values
     * is defined by the underlying directory service.  It might use the
     * &lt;code&gt;Object.equals&lt;/code&gt; method, for example, or might use a schema
     * to specify a different equality operation.
     * For matching based on operations other than equality (such as
     * substring comparison) use the version of the &lt;code&gt;search&lt;/code&gt;
     * method that takes a filter argument.
     * &lt;p&gt;
     * When changes are made to this &lt;tt&gt;DirContext&lt;/tt&gt;,
     * the effect on enumerations returned by prior calls to this method
     * is undefined.
     *&lt;p&gt;
     * If the object does not have the attribute
     * specified, the directory will ignore the nonexistent attribute
     * and return the requested attributes that the object does have.
     *&lt;p&gt;
     * A directory might return more attributes than was requested
     * (see &lt;strong&gt;Attribute Type Names&lt;/strong&gt; in the class description),
     * but is not allowed to return arbitrary, unrelated attributes.
     *&lt;p&gt;
     * See also &lt;strong&gt;Operational Attributes&lt;/strong&gt; in the class
     * description.
     *
     * @param name
     *          the name of the context to search
     * @param matchingAttributes
     *          the attributes to search for.  If empty or null,
     *          all objects in the target context are returned.
     * @param attributesToReturn
     *          the attributes to return.  null indicates that
     *          all attributes are to be returned;
     *          an empty array indicates that none are to be returned.
     * @return
     *          a non-null enumeration of &lt;tt&gt;SearchResult&lt;/tt&gt; objects.
     *          Each &lt;tt&gt;SearchResult&lt;/tt&gt; contains the attributes
     *          identified by &lt;code&gt;attributesToReturn&lt;/code&gt;
     *          and the name of the corresponding object, named relative
     *          to the context named by &lt;code&gt;name&lt;/code&gt;.
     * @throws  NamingException if a naming exception is encountered
     *
     * @see SearchControls
     * @see SearchResult
     * @see #search(Name, String, Object[], SearchControls)
     */
    public NamingEnumeration&lt;SearchResult&gt;
        search(Name name,
               Attributes matchingAttributes,
               String[] attributesToReturn)
        throws NamingException;

    /**
     * Searches in a single context for objects that contain a
     * specified set of attributes, and retrieves selected attributes.
     * See {@link #search(Name, Attributes, String[])} for details.
     *
     * @param name
     *          the name of the context to search
     * @param matchingAttributes
     *          the attributes to search for
     * @param attributesToReturn
     *          the attributes to return
     * @return  a non-null enumeration of &lt;tt&gt;SearchResult&lt;/tt&gt; objects
     * @throws  NamingException if a naming exception is encountered
     */
    public NamingEnumeration&lt;SearchResult&gt;
        search(String name,
               Attributes matchingAttributes,
               String[] attributesToReturn)
        throws NamingException;

    /**
     * Searches in a single context for objects that contain a
     * specified set of attributes.
     * This method returns all the attributes of such objects.
     * It is equivalent to supplying null as
     * the &lt;tt&gt;atributesToReturn&lt;/tt&gt; parameter to the method
     * &lt;code&gt;search(Name, Attributes, String[])&lt;/code&gt;.
     * &lt;br&gt;
     * See {@link #search(Name, Attributes, String[])} for a full description.
     *
     * @param name
     *          the name of the context to search
     * @param matchingAttributes
     *          the attributes to search for
     * @return  an enumeration of &lt;tt&gt;SearchResult&lt;/tt&gt; objects
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #search(Name, Attributes, String[])
     */
    public NamingEnumeration&lt;SearchResult&gt;
        search(Name name, Attributes matchingAttributes)
        throws NamingException;

    /**
     * Searches in a single context for objects that contain a
     * specified set of attributes.
     * See {@link #search(Name, Attributes)} for details.
     *
     * @param name
     *          the name of the context to search
     * @param matchingAttributes
     *          the attributes to search for
     * @return  an enumeration of &lt;tt&gt;SearchResult&lt;/tt&gt; objects
     * @throws  NamingException if a naming exception is encountered
     */
    public NamingEnumeration&lt;SearchResult&gt;
        search(String name, Attributes matchingAttributes)
        throws NamingException;

    /**
     * Searches in the named context or object for entries that satisfy the
     * given search filter.  Performs the search as specified by
     * the search controls.
     * &lt;p&gt;
     * The format and interpretation of &lt;code&gt;filter&lt;/code&gt; follows RFC 2254
     * with the
     * following interpretations for &lt;code&gt;attr&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;
     * mentioned in the RFC.
     * &lt;p&gt;
     * &lt;code&gt;attr&lt;/code&gt; is the attribute's identifier.
     * &lt;p&gt;
     * &lt;code&gt;value&lt;/code&gt; is the string representation the attribute's value.
     * The translation of this string representation into the attribute's value
     * is directory-specific.
     * &lt;p&gt;
     * For the assertion &quot;someCount=127&quot;, for example, &lt;code&gt;attr&lt;/code&gt;
     * is &quot;someCount&quot; and &lt;code&gt;value&lt;/code&gt; is &quot;127&quot;.
     * The provider determines, based on the attribute ID (&quot;someCount&quot;)
     * (and possibly its schema), that the attribute's value is an integer.
     * It then parses the string &quot;127&quot; appropriately.
     *&lt;p&gt;
     * Any non-ASCII characters in the filter string should be
     * represented by the appropriate Java (Unicode) characters, and
     * not encoded as UTF-8 octets.  Alternately, the
     * &quot;backslash-hexcode&quot; notation described in RFC 2254 may be used.
     *&lt;p&gt;
     * If the directory does not support a string representation of
     * some or all of its attributes, the form of &lt;code&gt;search&lt;/code&gt; that
     * accepts filter arguments in the form of Objects can be used instead.
     * The service provider for such a directory would then translate
     * the filter arguments to its service-specific representation
     * for filter evaluation.
     * See &lt;code&gt;search(Name, String, Object[], SearchControls)&lt;/code&gt;.
     * &lt;p&gt;
     * RFC 2254 defines certain operators for the filter, including substring
     * matches, equality, approximate match, greater than, less than.  These
     * operators are mapped to operators with corresponding semantics in the
     * underlying directory. For example, for the equals operator, suppose
     * the directory has a matching rule defining &quot;equality&quot; of the
     * attributes in the filter. This rule would be used for checking
     * equality of the attributes specified in the filter with the attributes
     * of objects in the directory. Similarly, if the directory has a
     * matching rule for ordering, this rule would be used for
     * making &quot;greater than&quot; and &quot;less than&quot; comparisons.
     *&lt;p&gt;
     * Not all of the operators defined in RFC 2254 are applicable to all
     * attributes.  When an operator is not applicable, the exception
     * &lt;code&gt;InvalidSearchFilterException&lt;/code&gt; is thrown.
     * &lt;p&gt;
     * The result is returned in an enumeration of &lt;tt&gt;SearchResult&lt;/tt&gt;s.
     * Each &lt;tt&gt;SearchResult&lt;/tt&gt; contains the name of the object
     * and other information about the object (see SearchResult).
     * The name is either relative to the target context of the search
     * (which is named by the &lt;code&gt;name&lt;/code&gt; parameter), or
     * it is a URL string. If the target context is included in
     * the enumeration (as is possible when
     * &lt;code&gt;cons&lt;/code&gt; specifies a search scope of
     * &lt;code&gt;SearchControls.OBJECT_SCOPE&lt;/code&gt; or
     * &lt;code&gt;SearchControls.SUBSTREE_SCOPE&lt;/code&gt;), its name is the empty
     * string. The &lt;tt&gt;SearchResult&lt;/tt&gt; may also contain attributes of the
     * matching object if the &lt;tt&gt;cons&lt;/tt&gt; argument specified that attributes
     * be returned.
     *&lt;p&gt;
     * If the object does not have a requested attribute, that
     * nonexistent attribute will be ignored.  Those requested
     * attributes that the object does have will be returned.
     *&lt;p&gt;
     * A directory might return more attributes than were requested
     * (see &lt;strong&gt;Attribute Type Names&lt;/strong&gt; in the class description)
     * but is not allowed to return arbitrary, unrelated attributes.
     *&lt;p&gt;
     * See also &lt;strong&gt;Operational Attributes&lt;/strong&gt; in the class
     * description.
     *
     * @param name
     *          the name of the context or object to search
     * @param filter
     *          the filter expression to use for the search; may not be null
     * @param cons
     *          the search controls that control the search.  If null,
     *          the default search controls are used (equivalent
     *          to &lt;tt&gt;(new SearchControls())&lt;/tt&gt;).
     * @return  an enumeration of &lt;tt&gt;SearchResult&lt;/tt&gt;s of
     *          the objects that satisfy the filter; never null
     *
     * @throws  InvalidSearchFilterException if the search filter specified is
     *          not supported or understood by the underlying directory
     * @throws  InvalidSearchControlsException if the search controls
     *          contain invalid settings
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #search(Name, String, Object[], SearchControls)
     * @see SearchControls
     * @see SearchResult
     */
    public NamingEnumeration&lt;SearchResult&gt;
        search(Name name,
               String filter,
               SearchControls cons)
        throws NamingException;

    /**
     * Searches in the named context or object for entries that satisfy the
     * given search filter.  Performs the search as specified by
     * the search controls.
     * See {@link #search(Name, String, SearchControls)} for details.
     *
     * @param name
     *          the name of the context or object to search
     * @param filter
     *          the filter expression to use for the search; may not be null
     * @param cons
     *          the search controls that control the search.  If null,
     *          the default search controls are used (equivalent
     *          to &lt;tt&gt;(new SearchControls())&lt;/tt&gt;).
     *
     * @return  an enumeration of &lt;tt&gt;SearchResult&lt;/tt&gt;s for
     *          the objects that satisfy the filter.
     * @throws  InvalidSearchFilterException if the search filter specified is
     *          not supported or understood by the underlying directory
     * @throws  InvalidSearchControlsException if the search controls
     *          contain invalid settings
     * @throws  NamingException if a naming exception is encountered
     */
    public NamingEnumeration&lt;SearchResult&gt;
        search(String name,
               String filter,
               SearchControls cons)
        throws NamingException;

    /**
     * Searches in the named context or object for entries that satisfy the
     * given search filter.  Performs the search as specified by
     * the search controls.
     *&lt;p&gt;
     * The interpretation of &lt;code&gt;filterExpr&lt;/code&gt; is based on RFC
     * 2254.  It may additionally contain variables of the form
     * &lt;code&gt;{i}&lt;/code&gt; -- where &lt;code&gt;i&lt;/code&gt; is an integer -- that
     * refer to objects in the &lt;code&gt;filterArgs&lt;/code&gt; array.  The
     * interpretation of &lt;code&gt;filterExpr&lt;/code&gt; is otherwise
     * identical to that of the &lt;code&gt;filter&lt;/code&gt; parameter of the
     * method &lt;code&gt;search(Name, String, SearchControls)&lt;/code&gt;.
     *&lt;p&gt;
     * When a variable &lt;code&gt;{i}&lt;/code&gt; appears in a search filter, it
     * indicates that the filter argument &lt;code&gt;filterArgs[i]&lt;/code&gt;
     * is to be used in that place.  Such variables may be used
     * wherever an &lt;em&gt;attr&lt;/em&gt;, &lt;em&gt;value&lt;/em&gt;, or
     * &lt;em&gt;matchingrule&lt;/em&gt; production appears in the filter grammar
     * of RFC 2254, section 4.  When a string-valued filter argument
     * is substituted for a variable, the filter is interpreted as if
     * the string were given in place of the variable, with any
     * characters having special significance within filters (such as
     * &lt;code&gt;'*'&lt;/code&gt;) having been escaped according to the rules of
     * RFC 2254.
     *&lt;p&gt;
     * For directories that do not use a string representation for
     * some or all of their attributes, the filter argument
     * corresponding to an attribute value may be of a type other than
     * String.  Directories that support unstructured binary-valued
     * attributes, for example, should accept byte arrays as filter
     * arguments.  The interpretation (if any) of filter arguments of
     * any other type is determined by the service provider for that
     * directory, which maps the filter operations onto operations with
     * corresponding semantics in the underlying directory.
     *&lt;p&gt;
     * This method returns an enumeration of the results.
     * Each element in the enumeration contains the name of the object
     * and other information about the object (see &lt;code&gt;SearchResult&lt;/code&gt;).
     * The name is either relative to the target context of the search
     * (which is named by the &lt;code&gt;name&lt;/code&gt; parameter), or
     * it is a URL string. If the target context is included in
     * the enumeration (as is possible when
     * &lt;code&gt;cons&lt;/code&gt; specifies a search scope of
     * &lt;code&gt;SearchControls.OBJECT_SCOPE&lt;/code&gt; or
     * &lt;code&gt;SearchControls.SUBSTREE_SCOPE&lt;/code&gt;),
     * its name is the empty string.
     *&lt;p&gt;
     * The &lt;tt&gt;SearchResult&lt;/tt&gt; may also contain attributes of the matching
     * object if the &lt;tt&gt;cons&lt;/tt&gt; argument specifies that attributes be
     * returned.
     *&lt;p&gt;
     * If the object does not have a requested attribute, that
     * nonexistent attribute will be ignored.  Those requested
     * attributes that the object does have will be returned.
     *&lt;p&gt;
     * A directory might return more attributes than were requested
     * (see &lt;strong&gt;Attribute Type Names&lt;/strong&gt; in the class description)
     * but is not allowed to return arbitrary, unrelated attributes.
     *&lt;p&gt;
     * If a search filter with invalid variable substitutions is provided
     * to this method, the result is undefined.
     * When changes are made to this DirContext,
     * the effect on enumerations returned by prior calls to this method
     * is undefined.
     *&lt;p&gt;
     * See also &lt;strong&gt;Operational Attributes&lt;/strong&gt; in the class
     * description.
     *
     * @param name
     *          the name of the context or object to search
     * @param filterExpr
     *          the filter expression to use for the search.
     *          The expression may contain variables of the
     *          form &quot;&lt;code&gt;{i}&lt;/code&gt;&quot; where &lt;code&gt;i&lt;/code&gt;
     *          is a nonnegative integer.  May not be null.
     * @param filterArgs
     *          the array of arguments to substitute for the variables
     *          in &lt;code&gt;filterExpr&lt;/code&gt;.  The value of
     *          &lt;code&gt;filterArgs[i]&lt;/code&gt; will replace each
     *          occurrence of &quot;&lt;code&gt;{i}&lt;/code&gt;&quot;.
     *          If null, equivalent to an empty array.
     * @param cons
     *          the search controls that control the search.  If null,
     *          the default search controls are used (equivalent
     *          to &lt;tt&gt;(new SearchControls())&lt;/tt&gt;).
     * @return  an enumeration of &lt;tt&gt;SearchResult&lt;/tt&gt;s of the objects
     *          that satisfy the filter; never null
     *
     * @throws  ArrayIndexOutOfBoundsException if &lt;tt&gt;filterExpr&lt;/tt&gt; contains
     *          &lt;code&gt;{i}&lt;/code&gt; expressions where &lt;code&gt;i&lt;/code&gt; is outside
     *          the bounds of the array &lt;code&gt;filterArgs&lt;/code&gt;
     * @throws  InvalidSearchControlsException if &lt;tt&gt;cons&lt;/tt&gt; contains
     *          invalid settings
     * @throws  InvalidSearchFilterException if &lt;tt&gt;filterExpr&lt;/tt&gt; with
     *          &lt;tt&gt;filterArgs&lt;/tt&gt; represents an invalid search filter
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #search(Name, Attributes, String[])
     * @see java.text.MessageFormat
     */
    public NamingEnumeration&lt;SearchResult&gt;
        search(Name name,
               String filterExpr,
               Object[] filterArgs,
               SearchControls cons)
        throws NamingException;

    /**
     * Searches in the named context or object for entries that satisfy the
     * given search filter.  Performs the search as specified by
     * the search controls.
     * See {@link #search(Name, String, Object[], SearchControls)} for details.
     *
     * @param name
     *          the name of the context or object to search
     * @param filterExpr
     *          the filter expression to use for the search.
     *          The expression may contain variables of the
     *          form &quot;&lt;code&gt;{i}&lt;/code&gt;&quot; where &lt;code&gt;i&lt;/code&gt;
     *          is a nonnegative integer.  May not be null.
     * @param filterArgs
     *          the array of arguments to substitute for the variables
     *          in &lt;code&gt;filterExpr&lt;/code&gt;.  The value of
     *          &lt;code&gt;filterArgs[i]&lt;/code&gt; will replace each
     *          occurrence of &quot;&lt;code&gt;{i}&lt;/code&gt;&quot;.
     *          If null, equivalent to an empty array.
     * @param cons
     *          the search controls that control the search.  If null,
     *          the default search controls are used (equivalent
     *          to &lt;tt&gt;(new SearchControls())&lt;/tt&gt;).
     * @return  an enumeration of &lt;tt&gt;SearchResult&lt;/tt&gt;s of the objects
     *          that satisfy the filter; never null
     *
     * @throws  ArrayIndexOutOfBoundsException if &lt;tt&gt;filterExpr&lt;/tt&gt; contains
     *          &lt;code&gt;{i}&lt;/code&gt; expressions where &lt;code&gt;i&lt;/code&gt; is outside
     *          the bounds of the array &lt;code&gt;filterArgs&lt;/code&gt;
     * @throws  InvalidSearchControlsException if &lt;tt&gt;cons&lt;/tt&gt; contains
     *          invalid settings
     * @throws  InvalidSearchFilterException if &lt;tt&gt;filterExpr&lt;/tt&gt; with
     *          &lt;tt&gt;filterArgs&lt;/tt&gt; represents an invalid search filter
     * @throws  NamingException if a naming exception is encountered
     */
    public NamingEnumeration&lt;SearchResult&gt;
        search(String name,
               String filterExpr,
               Object[] filterArgs,
               SearchControls cons)
        throws NamingException;
}
</pre>
</body>
</html>
