<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.naming;

import java.util.Hashtable;

/**
 * This interface represents a naming context, which
 * consists of a set of name-to-object bindings.
 * It contains methods for examining and updating these bindings.
 *
 * &lt;h1&gt;Names&lt;/h1&gt;
 * Each name passed as an argument to a &lt;tt&gt;Context&lt;/tt&gt; method is relative
 * to that context.  The empty name is used to name the context itself.
 * A name parameter may never be null.
 * &lt;p&gt;
 * Most of the methods have overloaded versions with one taking a
 * &lt;code&gt;Name&lt;/code&gt; parameter and one taking a &lt;code&gt;String&lt;/code&gt;.
 * These overloaded versions are equivalent in that if
 * the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; parameters are just
 * different representations of the same name, then the overloaded
 * versions of the same methods behave the same.
 * In the method descriptions below, only one version is fully documented.
 * The second version instead has a link to the first:  the same
 * documentation applies to both.
 * &lt;p&gt;
 * For systems that support federation, &lt;tt&gt;String&lt;/tt&gt; name arguments to
 * &lt;tt&gt;Context&lt;/tt&gt; methods are composite names. Name arguments that are
 * instances of &lt;tt&gt;CompositeName&lt;/tt&gt; are treated as composite names,
 * while &lt;tt&gt;Name&lt;/tt&gt; arguments that are not instances of
 * &lt;tt&gt;CompositeName&lt;/tt&gt; are treated as compound names (which might be
 * instances of &lt;tt&gt;CompoundName&lt;/tt&gt; or other implementations of compound
 * names). This allows the results of &lt;tt&gt;NameParser.parse()&lt;/tt&gt; to be used as
 * arguments to the &lt;tt&gt;Context&lt;/tt&gt; methods.
 * Prior to JNDI 1.2, all name arguments were treated as composite names.
 *&lt;p&gt;
 * Furthermore, for systems that support federation, all names returned
 * in a &lt;tt&gt;NamingEnumeration&lt;/tt&gt;
 * from &lt;tt&gt;list()&lt;/tt&gt; and &lt;tt&gt;listBindings()&lt;/tt&gt; are composite names
 * represented as strings.
 * See &lt;tt&gt;CompositeName&lt;/tt&gt; for the string syntax of names.
 *&lt;p&gt;
 * For systems that do not support federation, the name arguments (in
 * either &lt;tt&gt;Name&lt;/tt&gt; or &lt;tt&gt;String&lt;/tt&gt; forms) and the names returned in
 * &lt;tt&gt;NamingEnumeration&lt;/tt&gt; may be names in their own namespace rather than
 * names in a composite namespace, at the discretion of the service
 * provider.
 *
 *&lt;h1&gt;Exceptions&lt;/h1&gt;
 * All the methods in this interface can throw a &lt;tt&gt;NamingException&lt;/tt&gt; or
 * any of its subclasses. See &lt;tt&gt;NamingException&lt;/tt&gt; and their subclasses
 * for details on each exception.
 *
 *&lt;h1&gt;Concurrent Access&lt;/h1&gt;
 * A Context instance is not guaranteed to be synchronized against
 * concurrent access by multiple threads.  Threads that need to access
 * a single Context instance concurrently should synchronize amongst
 * themselves and provide the necessary locking.  Multiple threads
 * each manipulating a different Context instance need not
 * synchronize.  Note that the {@link #lookup(Name) &lt;tt&gt;lookup&lt;/tt&gt;}
 * method, when passed an empty name, will return a new Context instance
 * representing the same naming context.
 *&lt;p&gt;
 * For purposes of concurrency control,
 * a Context operation that returns a &lt;tt&gt;NamingEnumeration&lt;/tt&gt; is
 * not considered to have completed while the enumeration is still in
 * use, or while any referrals generated by that operation are still
 * being followed.
 *
 *
 *&lt;h1&gt;Parameters&lt;/h1&gt;
 * A &lt;tt&gt;Name&lt;/tt&gt; parameter passed to any method of the
 * &lt;tt&gt;Context&lt;/tt&gt; interface or one of its subinterfaces
 * will not be modified by the service provider.
 * The service provider may keep a reference to it
 * for the duration of the operation, including any enumeration of the
 * method's results and the processing of any referrals generated.
 * The caller should not modify the object during this time.
 * A &lt;tt&gt;Name&lt;/tt&gt; returned by any such method is owned by the caller.
 * The caller may subsequently modify it; the service provider may not.
 *
 *
 *&lt;h1&gt;Environment Properties&lt;/h1&gt;
 *&lt;p&gt;
 * JNDI applications need a way to communicate various preferences
 * and properties that define the environment in which naming and
 * directory services are accessed. For example, a context might
 * require specification of security credentials in order to access
 * the service. Another context might require that server configuration
 * information be supplied. These are referred to as the &lt;em&gt;environment&lt;/em&gt;
 * of a context. The &lt;tt&gt;Context&lt;/tt&gt; interface provides methods for
 * retrieving and updating this environment.
 *&lt;p&gt;
 * The environment is inherited from the parent context as
 * context methods proceed from one context to the next. Changes to
 * the environment of one context do not directly affect those
 * of other contexts.
 *&lt;p&gt;
 * It is implementation-dependent when environment properties are used
 * and/or verified for validity.  For example, some of the
 * security-related properties are used by service providers to &quot;log in&quot;
 * to the directory.  This login process might occur at the time the
 * context is created, or the first time a method is invoked on the
 * context.  When, and whether this occurs at all, is
 * implementation-dependent.  When environment properties are added or
 * removed from the context, verifying the validity of the changes is again
 * implementation-dependent. For example, verification of some properties
 * might occur at the time the change is made, or at the time the next
 * operation is performed on the context, or not at all.
 *&lt;p&gt;
 * Any object with a reference to a context may examine that context's
 * environment.  Sensitive information such as clear-text
 * passwords should not be stored there unless the implementation is
 * known to protect it.
 *
 *&lt;p&gt;
 *&lt;a name=RESOURCEFILES&gt;&lt;/a&gt;
 *&lt;h1&gt;Resource Files&lt;/h1&gt;
 *&lt;p&gt;
 * To simplify the task of setting up the environment
 * required by a JNDI application,
 * application components and service providers may be distributed
 * along with &lt;em&gt;resource files.&lt;/em&gt;
 * A JNDI resource file is a file in the properties file format (see
 * {@link java.util.Properties#load &lt;tt&gt;java.util.Properties&lt;/tt&gt;}),
 * containing a list of key/value pairs.
 * The key is the name of the property (e.g. &quot;java.naming.factory.object&quot;)
 * and the value is a string in the format defined
 * for that property.  Here is an example of a JNDI resource file:
 *
 * &lt;blockquote&gt;{@code
 * java.naming.factory.object=com.sun.jndi.ldap.AttrsToCorba:com.wiz.from.Person
 * java.naming.factory.state=com.sun.jndi.ldap.CorbaToAttrs:com.wiz.from.Person
 * java.naming.factory.control=com.sun.jndi.ldap.ResponseControlFactory
 * }&lt;/blockquote&gt;
 *
 * The JNDI class library reads the resource files and makes the property
 * values freely available.  Thus JNDI resource files should be considered
 * to be &quot;world readable&quot;, and sensitive information such as clear-text
 * passwords should not be stored there.
 *&lt;p&gt;
 * There are two kinds of JNDI resource files:
 * &lt;em&gt;provider&lt;/em&gt; and &lt;em&gt;application&lt;/em&gt;.
 *
 * &lt;h2&gt;Provider Resource Files&lt;/h2&gt;
 *
 * Each service provider has an optional resource that lists properties
 * specific to that provider.  The name of this resource is:
 * &lt;blockquote&gt;
 * [&lt;em&gt;prefix&lt;/em&gt;/]&lt;tt&gt;jndiprovider.properties&lt;/tt&gt;
 * &lt;/blockquote&gt;
 * where &lt;em&gt;prefix&lt;/em&gt; is
 * the package name of the provider's context implementation(s),
 * with each period (&quot;.&quot;) converted to a slash (&quot;/&quot;).
 *
 * For example, suppose a service provider defines a context
 * implementation with class name &lt;tt&gt;com.sun.jndi.ldap.LdapCtx&lt;/tt&gt;.
 * The provider resource for this provider is named
 * &lt;tt&gt;com/sun/jndi/ldap/jndiprovider.properties&lt;/tt&gt;.  If the class is
 * not in a package, the resource's name is simply
 * &lt;tt&gt;jndiprovider.properties&lt;/tt&gt;.
 *
 * &lt;p&gt;
 * &lt;a name=LISTPROPS&gt;&lt;/a&gt;
 * Certain methods in the JNDI class library make use of the standard
 * JNDI properties that specify lists of JNDI factories:
 * &lt;ul&gt;
 * &lt;li&gt;java.naming.factory.object
 * &lt;li&gt;java.naming.factory.state
 * &lt;li&gt;java.naming.factory.control
 * &lt;li&gt;java.naming.factory.url.pkgs
 * &lt;/ul&gt;
 * The JNDI library will consult the provider resource file
 * when determining the values of these properties.
 * Properties other than these may be set in the provider
 * resource file at the discretion of the service provider.
 * The service provider's documentation should clearly state which
 * properties are allowed; other properties in the file will be ignored.
 *
 * &lt;h2&gt;Application Resource Files&lt;/h2&gt;
 *
 * When an application is deployed, it will generally have several
 * codebase directories and JARs in its classpath.  Similarly, when an
 * applet is deployed, it will have a codebase and archives specifying
 * where to find the applet's classes.  JNDI locates (using
 * {@link ClassLoader#getResources &lt;tt&gt;ClassLoader.getResources()&lt;/tt&gt;})
 * all &lt;em&gt;application resource files&lt;/em&gt; named &lt;tt&gt;jndi.properties&lt;/tt&gt;
 * in the classpath.
 * In addition, if the file &lt;i&gt;java.home&lt;/i&gt;&lt;tt&gt;/lib/jndi.properties&lt;/tt&gt;
 * exists and is readable,
 * JNDI treats it as an additional application resource file.
 * (&lt;i&gt;java.home&lt;/i&gt; indicates the
 * directory named by the &lt;tt&gt;java.home&lt;/tt&gt; system property.)
 * All of the properties contained in these files are placed
 * into the environment of the initial context.  This environment
 * is then inherited by other contexts.
 *
 * &lt;p&gt;
 * For each property found in more than one application resource file,
 * JNDI uses the first value found or, in a few cases where it makes
 * sense to do so, it concatenates all of the values (details are given
 * below).
 * For example, if the &quot;java.naming.factory.object&quot; property is found in
 * three &lt;tt&gt;jndi.properties&lt;/tt&gt; resource files, the
 * list of object factories is a concatenation of the property
 * values from all three files.
 * Using this scheme, each deployable component is responsible for
 * listing the factories that it exports.  JNDI automatically
 * collects and uses all of these export lists when searching for factory
 * classes.
 *
 * &lt;h2&gt;Search Algorithm for Properties&lt;/h2&gt;
 *
 * When JNDI constructs an initial context, the context's environment
 * is initialized with properties defined in the environment parameter
 * passed to the constructor, the system properties, the applet parameters,
 * and the application resource files.  See
 * &lt;a href=InitialContext.html#ENVIRONMENT&gt;&lt;tt&gt;InitialContext&lt;/tt&gt;&lt;/a&gt;
 * for details.
 * This initial environment is then inherited by other context instances.
 *
 * &lt;p&gt;
 * When the JNDI class library needs to determine
 * the value of a property, it does so by merging
 * the values from the following two sources, in order:
 * &lt;ol&gt;
 * &lt;li&gt;The environment of the context being operated on.
 * &lt;li&gt;The provider resource file (&lt;tt&gt;jndiprovider.properties&lt;/tt&gt;)
 * for the context being operated on.
 * &lt;/ol&gt;
 * For each property found in both of these two sources,
 * JNDI determines the property's value as follows.  If the property is
 * one of the standard JNDI properties that specify a list of JNDI
 * factories (listed &lt;a href=#LISTPROPS&gt;above&lt;/a&gt;), the values are
 * concatenated into a single colon-separated list.  For other
 * properties, only the first value found is used.
 *
 * &lt;p&gt;
 * When a service provider needs to determine the value of a property,
 * it will generally take that value directly from the environment.
 * A service provider may define provider-specific properties
 * to be placed in its own provider resource file.  In that
 * case it should merge values as described in the previous paragraph.
 *
 * &lt;p&gt;
 * In this way, each service provider developer can specify a list of
 * factories to use with that service provider. These can be modified by
 * the application resources specified by the deployer of the application
 * or applet, which in turn can be modified by the user.
 *
 * @author Rosanna Lee
 * @author Scott Seligman
 * @author R. Vasudevan
 *
 * @since 1.3
 */

public interface Context {

    /**
     * Retrieves the named object.
     * If &lt;tt&gt;name&lt;/tt&gt; is empty, returns a new instance of this context
     * (which represents the same naming context as this context, but its
     * environment may be modified independently and it may be accessed
     * concurrently).
     *
     * @param name
     *          the name of the object to look up
     * @return  the object bound to &lt;tt&gt;name&lt;/tt&gt;
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #lookup(String)
     * @see #lookupLink(Name)
     */
    public Object lookup(Name name) throws NamingException;

    /**
     * Retrieves the named object.
     * See {@link #lookup(Name)} for details.
     * @param name
     *          the name of the object to look up
     * @return  the object bound to &lt;tt&gt;name&lt;/tt&gt;
     * @throws  NamingException if a naming exception is encountered
     */
    public Object lookup(String name) throws NamingException;

    /**
     * Binds a name to an object.
     * All intermediate contexts and the target context (that named by all
     * but terminal atomic component of the name) must already exist.
     *
     * @param name
     *          the name to bind; may not be empty
     * @param obj
     *          the object to bind; possibly null
     * @throws  NameAlreadyBoundException if name is already bound
     * @throws  javax.naming.directory.InvalidAttributesException
     *          if object did not supply all mandatory attributes
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #bind(String, Object)
     * @see #rebind(Name, Object)
     * @see javax.naming.directory.DirContext#bind(Name, Object,
     *          javax.naming.directory.Attributes)
     */
    public void bind(Name name, Object obj) throws NamingException;

    /**
     * Binds a name to an object.
     * See {@link #bind(Name, Object)} for details.
     *
     * @param name
     *          the name to bind; may not be empty
     * @param obj
     *          the object to bind; possibly null
     * @throws  NameAlreadyBoundException if name is already bound
     * @throws  javax.naming.directory.InvalidAttributesException
     *          if object did not supply all mandatory attributes
     * @throws  NamingException if a naming exception is encountered
     */
    public void bind(String name, Object obj) throws NamingException;

    /**
     * Binds a name to an object, overwriting any existing binding.
     * All intermediate contexts and the target context (that named by all
     * but terminal atomic component of the name) must already exist.
     *
     * &lt;p&gt; If the object is a &lt;tt&gt;DirContext&lt;/tt&gt;, any existing attributes
     * associated with the name are replaced with those of the object.
     * Otherwise, any existing attributes associated with the name remain
     * unchanged.
     *
     * @param name
     *          the name to bind; may not be empty
     * @param obj
     *          the object to bind; possibly null
     * @throws  javax.naming.directory.InvalidAttributesException
     *          if object did not supply all mandatory attributes
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #rebind(String, Object)
     * @see #bind(Name, Object)
     * @see javax.naming.directory.DirContext#rebind(Name, Object,
     *          javax.naming.directory.Attributes)
     * @see javax.naming.directory.DirContext
     */
    public void rebind(Name name, Object obj) throws NamingException;

    /**
     * Binds a name to an object, overwriting any existing binding.
     * See {@link #rebind(Name, Object)} for details.
     *
     * @param name
     *          the name to bind; may not be empty
     * @param obj
     *          the object to bind; possibly null
     * @throws  javax.naming.directory.InvalidAttributesException
     *          if object did not supply all mandatory attributes
     * @throws  NamingException if a naming exception is encountered
     */
    public void rebind(String name, Object obj) throws NamingException;

    /**
     * Unbinds the named object.
     * Removes the terminal atomic name in &lt;code&gt;name&lt;/code&gt;
     * from the target context--that named by all but the terminal
     * atomic part of &lt;code&gt;name&lt;/code&gt;.
     *
     * &lt;p&gt; This method is idempotent.
     * It succeeds even if the terminal atomic name
     * is not bound in the target context, but throws
     * &lt;tt&gt;NameNotFoundException&lt;/tt&gt;
     * if any of the intermediate contexts do not exist.
     *
     * &lt;p&gt; Any attributes associated with the name are removed.
     * Intermediate contexts are not changed.
     *
     * @param name
     *          the name to unbind; may not be empty
     * @throws  NameNotFoundException if an intermediate context does not exist
     * @throws  NamingException if a naming exception is encountered
     * @see #unbind(String)
     */
    public void unbind(Name name) throws NamingException;

    /**
     * Unbinds the named object.
     * See {@link #unbind(Name)} for details.
     *
     * @param name
     *          the name to unbind; may not be empty
     * @throws  NameNotFoundException if an intermediate context does not exist
     * @throws  NamingException if a naming exception is encountered
     */
    public void unbind(String name) throws NamingException;

    /**
     * Binds a new name to the object bound to an old name, and unbinds
     * the old name.  Both names are relative to this context.
     * Any attributes associated with the old name become associated
     * with the new name.
     * Intermediate contexts of the old name are not changed.
     *
     * @param oldName
     *          the name of the existing binding; may not be empty
     * @param newName
     *          the name of the new binding; may not be empty
     * @throws  NameAlreadyBoundException if &lt;tt&gt;newName&lt;/tt&gt; is already bound
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #rename(String, String)
     * @see #bind(Name, Object)
     * @see #rebind(Name, Object)
     */
    public void rename(Name oldName, Name newName) throws NamingException;

    /**
     * Binds a new name to the object bound to an old name, and unbinds
     * the old name.
     * See {@link #rename(Name, Name)} for details.
     *
     * @param oldName
     *          the name of the existing binding; may not be empty
     * @param newName
     *          the name of the new binding; may not be empty
     * @throws  NameAlreadyBoundException if &lt;tt&gt;newName&lt;/tt&gt; is already bound
     * @throws  NamingException if a naming exception is encountered
     */
    public void rename(String oldName, String newName) throws NamingException;

    /**
     * Enumerates the names bound in the named context, along with the
     * class names of objects bound to them.
     * The contents of any subcontexts are not included.
     *
     * &lt;p&gt; If a binding is added to or removed from this context,
     * its effect on an enumeration previously returned is undefined.
     *
     * @param name
     *          the name of the context to list
     * @return  an enumeration of the names and class names of the
     *          bindings in this context.  Each element of the
     *          enumeration is of type &lt;tt&gt;NameClassPair&lt;/tt&gt;.
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #list(String)
     * @see #listBindings(Name)
     * @see NameClassPair
     */
    public NamingEnumeration&lt;NameClassPair&gt; list(Name name)
        throws NamingException;

    /**
     * Enumerates the names bound in the named context, along with the
     * class names of objects bound to them.
     * See {@link #list(Name)} for details.
     *
     * @param name
     *          the name of the context to list
     * @return  an enumeration of the names and class names of the
     *          bindings in this context.  Each element of the
     *          enumeration is of type &lt;tt&gt;NameClassPair&lt;/tt&gt;.
     * @throws  NamingException if a naming exception is encountered
     */
    public NamingEnumeration&lt;NameClassPair&gt; list(String name)
        throws NamingException;

    /**
     * Enumerates the names bound in the named context, along with the
     * objects bound to them.
     * The contents of any subcontexts are not included.
     *
     * &lt;p&gt; If a binding is added to or removed from this context,
     * its effect on an enumeration previously returned is undefined.
     *
     * @param name
     *          the name of the context to list
     * @return  an enumeration of the bindings in this context.
     *          Each element of the enumeration is of type
     *          &lt;tt&gt;Binding&lt;/tt&gt;.
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #listBindings(String)
     * @see #list(Name)
     * @see Binding
      */
    public NamingEnumeration&lt;Binding&gt; listBindings(Name name)
        throws NamingException;

    /**
     * Enumerates the names bound in the named context, along with the
     * objects bound to them.
     * See {@link #listBindings(Name)} for details.
     *
     * @param name
     *          the name of the context to list
     * @return  an enumeration of the bindings in this context.
     *          Each element of the enumeration is of type
     *          &lt;tt&gt;Binding&lt;/tt&gt;.
     * @throws  NamingException if a naming exception is encountered
     */
    public NamingEnumeration&lt;Binding&gt; listBindings(String name)
        throws NamingException;

    /**
     * Destroys the named context and removes it from the namespace.
     * Any attributes associated with the name are also removed.
     * Intermediate contexts are not destroyed.
     *
     * &lt;p&gt; This method is idempotent.
     * It succeeds even if the terminal atomic name
     * is not bound in the target context, but throws
     * &lt;tt&gt;NameNotFoundException&lt;/tt&gt;
     * if any of the intermediate contexts do not exist.
     *
     * &lt;p&gt; In a federated naming system, a context from one naming system
     * may be bound to a name in another.  One can subsequently
     * look up and perform operations on the foreign context using a
     * composite name.  However, an attempt destroy the context using
     * this composite name will fail with
     * &lt;tt&gt;NotContextException&lt;/tt&gt;, because the foreign context is not
     * a &quot;subcontext&quot; of the context in which it is bound.
     * Instead, use &lt;tt&gt;unbind()&lt;/tt&gt; to remove the
     * binding of the foreign context.  Destroying the foreign context
     * requires that the &lt;tt&gt;destroySubcontext()&lt;/tt&gt; be performed
     * on a context from the foreign context's &quot;native&quot; naming system.
     *
     * @param name
     *          the name of the context to be destroyed; may not be empty
     * @throws  NameNotFoundException if an intermediate context does not exist
     * @throws  NotContextException if the name is bound but does not name a
     *          context, or does not name a context of the appropriate type
     * @throws  ContextNotEmptyException if the named context is not empty
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #destroySubcontext(String)
     */
    public void destroySubcontext(Name name) throws NamingException;

    /**
     * Destroys the named context and removes it from the namespace.
     * See {@link #destroySubcontext(Name)} for details.
     *
     * @param name
     *          the name of the context to be destroyed; may not be empty
     * @throws  NameNotFoundException if an intermediate context does not exist
     * @throws  NotContextException if the name is bound but does not name a
     *          context, or does not name a context of the appropriate type
     * @throws  ContextNotEmptyException if the named context is not empty
     * @throws  NamingException if a naming exception is encountered
     */
    public void destroySubcontext(String name) throws NamingException;

    /**
     * Creates and binds a new context.
     * Creates a new context with the given name and binds it in
     * the target context (that named by all but terminal atomic
     * component of the name).  All intermediate contexts and the
     * target context must already exist.
     *
     * @param name
     *          the name of the context to create; may not be empty
     * @return  the newly created context
     *
     * @throws  NameAlreadyBoundException if name is already bound
     * @throws  javax.naming.directory.InvalidAttributesException
     *          if creation of the subcontext requires specification of
     *          mandatory attributes
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #createSubcontext(String)
     * @see javax.naming.directory.DirContext#createSubcontext
     */
    public Context createSubcontext(Name name) throws NamingException;

    /**
     * Creates and binds a new context.
     * See {@link #createSubcontext(Name)} for details.
     *
     * @param name
     *          the name of the context to create; may not be empty
     * @return  the newly created context
     *
     * @throws  NameAlreadyBoundException if name is already bound
     * @throws  javax.naming.directory.InvalidAttributesException
     *          if creation of the subcontext requires specification of
     *          mandatory attributes
     * @throws  NamingException if a naming exception is encountered
     */
    public Context createSubcontext(String name) throws NamingException;

    /**
     * Retrieves the named object, following links except
     * for the terminal atomic component of the name.
     * If the object bound to &lt;tt&gt;name&lt;/tt&gt; is not a link,
     * returns the object itself.
     *
     * @param name
     *          the name of the object to look up
     * @return  the object bound to &lt;tt&gt;name&lt;/tt&gt;, not following the
     *          terminal link (if any).
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #lookupLink(String)
     */
    public Object lookupLink(Name name) throws NamingException;

    /**
     * Retrieves the named object, following links except
     * for the terminal atomic component of the name.
     * See {@link #lookupLink(Name)} for details.
     *
     * @param name
     *          the name of the object to look up
     * @return  the object bound to &lt;tt&gt;name&lt;/tt&gt;, not following the
     *          terminal link (if any)
     * @throws  NamingException if a naming exception is encountered
     */
    public Object lookupLink(String name) throws NamingException;

    /**
     * Retrieves the parser associated with the named context.
     * In a federation of namespaces, different naming systems will
     * parse names differently.  This method allows an application
     * to get a parser for parsing names into their atomic components
     * using the naming convention of a particular naming system.
     * Within any single naming system, &lt;tt&gt;NameParser&lt;/tt&gt; objects
     * returned by this method must be equal (using the &lt;tt&gt;equals()&lt;/tt&gt;
     * test).
     *
     * @param name
     *          the name of the context from which to get the parser
     * @return  a name parser that can parse compound names into their atomic
     *          components
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #getNameParser(String)
     * @see CompoundName
     */
    public NameParser getNameParser(Name name) throws NamingException;

    /**
     * Retrieves the parser associated with the named context.
     * See {@link #getNameParser(Name)} for details.
     *
     * @param name
     *          the name of the context from which to get the parser
     * @return  a name parser that can parse compound names into their atomic
     *          components
     * @throws  NamingException if a naming exception is encountered
     */
    public NameParser getNameParser(String name) throws NamingException;

    /**
     * Composes the name of this context with a name relative to
     * this context.
     * Given a name (&lt;code&gt;name&lt;/code&gt;) relative to this context, and
     * the name (&lt;code&gt;prefix&lt;/code&gt;) of this context relative to one
     * of its ancestors, this method returns the composition of the
     * two names using the syntax appropriate for the naming
     * system(s) involved.  That is, if &lt;code&gt;name&lt;/code&gt; names an
     * object relative to this context, the result is the name of the
     * same object, but relative to the ancestor context.  None of the
     * names may be null.
     * &lt;p&gt;
     * For example, if this context is named &quot;wiz.com&quot; relative
     * to the initial context, then
     * &lt;pre&gt;
     *  composeName(&quot;east&quot;, &quot;wiz.com&quot;)  &lt;/pre&gt;
     * might return &lt;code&gt;&quot;east.wiz.com&quot;&lt;/code&gt;.
     * If instead this context is named &quot;org/research&quot;, then
     * &lt;pre&gt;
     *  composeName(&quot;user/jane&quot;, &quot;org/research&quot;)        &lt;/pre&gt;
     * might return &lt;code&gt;&quot;org/research/user/jane&quot;&lt;/code&gt; while
     * &lt;pre&gt;
     *  composeName(&quot;user/jane&quot;, &quot;research&quot;)    &lt;/pre&gt;
     * returns &lt;code&gt;&quot;research/user/jane&quot;&lt;/code&gt;.
     *
     * @param name
     *          a name relative to this context
     * @param prefix
     *          the name of this context relative to one of its ancestors
     * @return  the composition of &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #composeName(String, String)
     */
    public Name composeName(Name name, Name prefix)
        throws NamingException;

    /**
     * Composes the name of this context with a name relative to
     * this context.
     * See {@link #composeName(Name, Name)} for details.
     *
     * @param name
     *          a name relative to this context
     * @param prefix
     *          the name of this context relative to one of its ancestors
     * @return  the composition of &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;
     * @throws  NamingException if a naming exception is encountered
     */
    public String composeName(String name, String prefix)
            throws NamingException;

    /**
     * Adds a new environment property to the environment of this
     * context.  If the property already exists, its value is overwritten.
     * See class description for more details on environment properties.
     *
     * @param propName
     *          the name of the environment property to add; may not be null
     * @param propVal
     *          the value of the property to add; may not be null
     * @return  the previous value of the property, or null if the property was
     *          not in the environment before
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #getEnvironment()
     * @see #removeFromEnvironment(String)
     */
    public Object addToEnvironment(String propName, Object propVal)
        throws NamingException;

    /**
     * Removes an environment property from the environment of this
     * context.  See class description for more details on environment
     * properties.
     *
     * @param propName
     *          the name of the environment property to remove; may not be null
     * @return  the previous value of the property, or null if the property was
     *          not in the environment
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #getEnvironment()
     * @see #addToEnvironment(String, Object)
     */
    public Object removeFromEnvironment(String propName)
        throws NamingException;

    /**
     * Retrieves the environment in effect for this context.
     * See class description for more details on environment properties.
     *
     * &lt;p&gt; The caller should not make any changes to the object returned:
     * their effect on the context is undefined.
     * The environment of this context may be changed using
     * &lt;tt&gt;addToEnvironment()&lt;/tt&gt; and &lt;tt&gt;removeFromEnvironment()&lt;/tt&gt;.
     *
     * @return  the environment of this context; never null
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    public Hashtable&lt;?,?&gt; getEnvironment() throws NamingException;

    /**
     * Closes this context.
     * This method releases this context's resources immediately, instead of
     * waiting for them to be released automatically by the garbage collector.
     *
     * &lt;p&gt; This method is idempotent:  invoking it on a context that has
     * already been closed has no effect.  Invoking any other method
     * on a closed context is not allowed, and results in undefined behaviour.
     *
     * @throws  NamingException if a naming exception is encountered
     */
    public void close() throws NamingException;

    /**
     * Retrieves the full name of this context within its own namespace.
     *
     * &lt;p&gt; Many naming services have a notion of a &quot;full name&quot; for objects
     * in their respective namespaces.  For example, an LDAP entry has
     * a distinguished name, and a DNS record has a fully qualified name.
     * This method allows the client application to retrieve this name.
     * The string returned by this method is not a JNDI composite name
     * and should not be passed directly to context methods.
     * In naming systems for which the notion of full name does not
     * make sense, &lt;tt&gt;OperationNotSupportedException&lt;/tt&gt; is thrown.
     *
     * @return  this context's name in its own namespace; never null
     * @throws  OperationNotSupportedException if the naming system does
     *          not have the notion of a full name
     * @throws  NamingException if a naming exception is encountered
     *
     * @since 1.3
     */
    public String getNameInNamespace() throws NamingException;

// public static final:  JLS says recommended style is to omit these modifiers
// because they are the default

    /**
     * Constant that holds the name of the environment property
     * for specifying the initial context factory to use. The value
     * of the property should be the fully qualified class name
     * of the factory class that will create an initial context.
     * This property may be specified in the environment parameter
     * passed to the initial context constructor, an applet parameter,
     * a system property, or an application resource file.
     * If it is not specified in any of these sources,
     * &lt;tt&gt;NoInitialContextException&lt;/tt&gt; is thrown when an initial
     * context is required to complete an operation.
     *
     * &lt;p&gt; The value of this constant is &quot;java.naming.factory.initial&quot;.
     *
     * @see InitialContext
     * @see javax.naming.directory.InitialDirContext
     * @see javax.naming.spi.NamingManager#getInitialContext
     * @see javax.naming.spi.InitialContextFactory
     * @see NoInitialContextException
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     * @see #APPLET
     */
    String INITIAL_CONTEXT_FACTORY = &quot;java.naming.factory.initial&quot;;

    /**
     * Constant that holds the name of the environment property
     * for specifying the list of object factories to use. The value
     * of the property should be a colon-separated list of the fully
     * qualified class names of factory classes that will create an object
     * given information about the object.
     * This property may be specified in the environment, an applet
     * parameter, a system property, or one or more resource files.
     *
     * &lt;p&gt; The value of this constant is &quot;java.naming.factory.object&quot;.
     *
     * @see javax.naming.spi.NamingManager#getObjectInstance
     * @see javax.naming.spi.ObjectFactory
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     * @see #APPLET
     */
    String OBJECT_FACTORIES = &quot;java.naming.factory.object&quot;;

    /**
     * Constant that holds the name of the environment property
     * for specifying the list of state factories to use. The value
     * of the property should be a colon-separated list of the fully
     * qualified class names of state factory classes that will be used
     * to get an object's state given the object itself.
     * This property may be specified in the environment, an applet
     * parameter, a system property, or one or more resource files.
     *
     * &lt;p&gt; The value of this constant is &quot;java.naming.factory.state&quot;.
     *
     * @see javax.naming.spi.NamingManager#getStateToBind
     * @see javax.naming.spi.StateFactory
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     * @see #APPLET
     * @since 1.3
     */
    String STATE_FACTORIES = &quot;java.naming.factory.state&quot;;

    /**
     * Constant that holds the name of the environment property
     * for specifying the list of package prefixes to use when
     * loading in URL context factories. The value
     * of the property should be a colon-separated list of package
     * prefixes for the class name of the factory class that will create
     * a URL context factory.
     * This property may be specified in the environment,
     * an applet parameter, a system property, or one or more
     * resource files.
     * The prefix &lt;tt&gt;com.sun.jndi.url&lt;/tt&gt; is always appended to
     * the possibly empty list of package prefixes.
     *
     * &lt;p&gt; The value of this constant is &quot;java.naming.factory.url.pkgs&quot;.
     *
     * @see javax.naming.spi.NamingManager#getObjectInstance
     * @see javax.naming.spi.NamingManager#getURLContext
     * @see javax.naming.spi.ObjectFactory
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     * @see #APPLET
      */
    String URL_PKG_PREFIXES = &quot;java.naming.factory.url.pkgs&quot;;

    /**
     * Constant that holds the name of the environment property
     * for specifying configuration information for the service provider
     * to use. The value of the property should contain a URL string
     * (e.g. &quot;ldap://somehost:389&quot;).
     * This property may be specified in the environment,
     * an applet parameter, a system property, or a resource file.
     * If it is not specified in any of these sources,
     * the default configuration is determined by the service provider.
     *
     * &lt;p&gt; The value of this constant is &quot;java.naming.provider.url&quot;.
     *
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     * @see #APPLET
     */
    String PROVIDER_URL = &quot;java.naming.provider.url&quot;;

    /**
     * Constant that holds the name of the environment property
     * for specifying the DNS host and domain names to use for the
     * JNDI URL context (for example, &quot;dns://somehost/wiz.com&quot;).
     * This property may be specified in the environment,
     * an applet parameter, a system property, or a resource file.
     * If it is not specified in any of these sources
     * and the program attempts to use a JNDI URL containing a DNS name,
     * a &lt;tt&gt;ConfigurationException&lt;/tt&gt; will be thrown.
     *
     * &lt;p&gt; The value of this constant is &quot;java.naming.dns.url&quot;.
     *
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String DNS_URL = &quot;java.naming.dns.url&quot;;

    /**
     * Constant that holds the name of the environment property for
     * specifying the authoritativeness of the service requested.
     * If the value of the property is the string &quot;true&quot;, it means
     * that the access is to the most authoritative source (i.e. bypass
     * any cache or replicas). If the value is anything else,
     * the source need not be (but may be) authoritative.
     * If unspecified, the value defaults to &quot;false&quot;.
     *
     * &lt;p&gt; The value of this constant is &quot;java.naming.authoritative&quot;.
     *
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String AUTHORITATIVE = &quot;java.naming.authoritative&quot;;

    /**
     * Constant that holds the name of the environment property for
     * specifying the batch size to use when returning data via the
     * service's protocol. This is a hint to the provider to return
     * the results of operations in batches of the specified size, so
     * the provider can optimize its performance and usage of resources.
     * The value of the property is the string representation of an
     * integer.
     * If unspecified, the batch size is determined by the service
     * provider.
     *
     * &lt;p&gt; The value of this constant is &quot;java.naming.batchsize&quot;.
     *
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String BATCHSIZE = &quot;java.naming.batchsize&quot;;

    /**
     * Constant that holds the name of the environment property for
     * specifying how referrals encountered by the service provider
     * are to be processed. The value of the property is one of the
     * following strings:
     * &lt;dl&gt;
     * &lt;dt&gt;&quot;follow&quot;
     * &lt;dd&gt;follow referrals automatically
     * &lt;dt&gt;&quot;ignore&quot;
     * &lt;dd&gt;ignore referrals
     * &lt;dt&gt;&quot;throw&quot;
     * &lt;dd&gt;throw &lt;tt&gt;ReferralException&lt;/tt&gt; when a referral is encountered.
     * &lt;/dl&gt;
     * If this property is not specified, the default is
     * determined by the provider.
     *
     * &lt;p&gt; The value of this constant is &quot;java.naming.referral&quot;.
     *
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String REFERRAL = &quot;java.naming.referral&quot;;

    /**
     * Constant that holds the name of the environment property for
     * specifying the security protocol to use.
     * Its value is a string determined by the service provider
     * (e.g. &quot;ssl&quot;).
     * If this property is unspecified,
     * the behaviour is determined by the service provider.
     *
     * &lt;p&gt; The value of this constant is &quot;java.naming.security.protocol&quot;.
     *
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String SECURITY_PROTOCOL = &quot;java.naming.security.protocol&quot;;

    /**
     * Constant that holds the name of the environment property for
     * specifying the security level to use.
     * Its value is one of the following strings:
     * &quot;none&quot;, &quot;simple&quot;, &quot;strong&quot;.
     * If this property is unspecified,
     * the behaviour is determined by the service provider.
     *
     * &lt;p&gt; The value of this constant is &quot;java.naming.security.authentication&quot;.
     *
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String SECURITY_AUTHENTICATION = &quot;java.naming.security.authentication&quot;;

    /**
     * Constant that holds the name of the environment property for
     * specifying the identity of the principal for authenticating
     * the caller to the service. The format of the principal
     * depends on the authentication scheme.
     * If this property is unspecified,
     * the behaviour is determined by the service provider.
     *
     * &lt;p&gt; The value of this constant is &quot;java.naming.security.principal&quot;.
     *
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String SECURITY_PRINCIPAL = &quot;java.naming.security.principal&quot;;

    /**
     * Constant that holds the name of the environment property for
     * specifying the credentials of the principal for authenticating
     * the caller to the service. The value of the property depends
     * on the authentication scheme. For example, it could be a hashed
     * password, clear-text password, key, certificate, and so on.
     * If this property is unspecified,
     * the behaviour is determined by the service provider.
     *
     * &lt;p&gt; The value of this constant is &quot;java.naming.security.credentials&quot;.
     *
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */

    String SECURITY_CREDENTIALS = &quot;java.naming.security.credentials&quot;;
    /**
     * Constant that holds the name of the environment property for
     * specifying the preferred language to use with the service.
     * The value of the property is a colon-separated list of language
     * tags as defined in RFC 1766.
     * If this property is unspecified,
     * the language preference is determined by the service provider.
     *
     * &lt;p&gt; The value of this constant is &quot;java.naming.language&quot;.
     *
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String LANGUAGE = &quot;java.naming.language&quot;;

    /**
     * Constant that holds the name of the environment property for
     * specifying an applet for the initial context constructor to use
     * when searching for other properties.
     * The value of this property is the
     * &lt;tt&gt;java.applet.Applet&lt;/tt&gt; instance that is being executed.
     * This property may be specified in the environment parameter
     * passed to the initial context constructor.
     * When this property is set, each property that the initial context
     * constructor looks for in the system properties is first looked for
     * in the applet's parameter list.
     * If this property is unspecified, the initial context constructor
     * will search for properties only in the environment parameter
     * passed to it, the system properties, and application resource files.
     *
     * &lt;p&gt; The value of this constant is &quot;java.naming.applet&quot;.
     *
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     * @see InitialContext
     *
     * @since 1.3
     */
    String APPLET = &quot;java.naming.applet&quot;;
};
</pre>
</body>
</html>
