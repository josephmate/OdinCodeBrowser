<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.sound.midi;

import java.util.List;

 /**
 * &lt;code&gt;MidiDevice&lt;/code&gt; is the base interface for all MIDI devices.
 * Common devices include synthesizers, sequencers, MIDI input ports, and MIDI
 * output ports.
 *
 * &lt;p&gt;A &lt;code&gt;MidiDevice&lt;/code&gt; can be a transmitter or a receiver of
 * MIDI events, or both. Therefore, it can provide {@link Transmitter}
 * or {@link Receiver} instances (or both). Typically, MIDI IN ports
 * provide transmitters, MIDI OUT ports and synthesizers provide
 * receivers. A Sequencer typically provides transmitters for playback
 * and receivers for recording.
 *
 * &lt;p&gt;A &lt;code&gt;MidiDevice&lt;/code&gt; can be opened and closed explicitly as
 * well as implicitly. Explicit opening is accomplished by calling
 * {@link #open}, explicit closing is done by calling {@link
 * #close} on the &lt;code&gt;MidiDevice&lt;/code&gt; instance.
 * If an application opens a &lt;code&gt;MidiDevice&lt;/code&gt;
 * explicitly, it has to close it explicitly to free system resources
 * and enable the application to exit cleanly. Implicit opening is
 * done by calling {@link javax.sound.midi.MidiSystem#getReceiver
 * MidiSystem.getReceiver} and {@link
 * javax.sound.midi.MidiSystem#getTransmitter
 * MidiSystem.getTransmitter}. The &lt;code&gt;MidiDevice&lt;/code&gt; used by
 * &lt;code&gt;MidiSystem.getReceiver&lt;/code&gt; and
 * &lt;code&gt;MidiSystem.getTransmitter&lt;/code&gt; is implementation-dependant
 * unless the properties &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt;
 * and &lt;code&gt;javax.sound.midi.Transmitter&lt;/code&gt; are used (see the
 * description of properties to select default providers in
 * {@link javax.sound.midi.MidiSystem}). A &lt;code&gt;MidiDevice&lt;/code&gt;
 * that was opened implicitly, is closed implicitly by closing the
 * &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; that resulted in
 * opening it. If more than one implicitly opening
 * &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; were obtained by
 * the application, the device is closed after the last
 * &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; has been
 * closed. On the other hand, calling &lt;code&gt;getReceiver&lt;/code&gt; or
 * &lt;code&gt;getTransmitter&lt;/code&gt; on the device instance directly does
 * not open the device implicitly. Closing these
 * &lt;code&gt;Transmitter&lt;/code&gt;s and &lt;code&gt;Receiver&lt;/code&gt;s does not close
 * the device implicitly. To use a device with &lt;code&gt;Receiver&lt;/code&gt;s
 * or &lt;code&gt;Transmitter&lt;/code&gt;s obtained this way, the device has to
 * be opened and closed explicitly.
 *
 * &lt;p&gt;If implicit and explicit opening and closing are mixed on the
 * same &lt;code&gt;MidiDevice&lt;/code&gt; instance, the following rules apply:
 *
 * &lt;ul&gt;
 * &lt;li&gt;After an explicit open (either before or after implicit
 * opens), the device will not be closed by implicit closing. The only
 * way to close an explicitly opened device is an explicit close.&lt;/li&gt;
 *
 * &lt;li&gt;An explicit close always closes the device, even if it also has
 * been opened implicitly. A subsequent implicit close has no further
 * effect.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * To detect if a MidiDevice represents a hardware MIDI port, the
 * following programming technique can be used:
 *
 * &lt;pre&gt;{@code
 * MidiDevice device = ...;
 * if ( ! (device instanceof Sequencer) &amp;&amp; ! (device instanceof Synthesizer)) {
 *   // we're now sure that device represents a MIDI port
 *   // ...
 * }
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;
 * A &lt;code&gt;MidiDevice&lt;/code&gt; includes a &lt;code&gt;{@link MidiDevice.Info}&lt;/code&gt; object
 * to provide manufacturer information and so on.
 *
 * @see Synthesizer
 * @see Sequencer
 * @see Receiver
 * @see Transmitter
 *
 * @author Kara Kytle
 * @author Florian Bomers
 */

public interface MidiDevice extends AutoCloseable {


    /**
     * Obtains information about the device, including its Java class and
     * &lt;code&gt;Strings&lt;/code&gt; containing its name, vendor, and description.
     *
     * @return device info
     */
    public Info getDeviceInfo();


    /**
     * Opens the device, indicating that it should now acquire any
     * system resources it requires and become operational.
     *
     * &lt;p&gt;An application opening a device explicitly with this call
     * has to close the device by calling {@link #close}. This is
     * necessary to release system resources and allow applications to
     * exit cleanly.
     *
     * &lt;p&gt;
     * Note that some devices, once closed, cannot be reopened.  Attempts
     * to reopen such a device will always result in a MidiUnavailableException.
     *
     * @throws MidiUnavailableException thrown if the device cannot be
     * opened due to resource restrictions.
     * @throws SecurityException thrown if the device cannot be
     * opened due to security restrictions.
     *
     * @see #close
     * @see #isOpen
     */
    public void open() throws MidiUnavailableException;


    /**
     * Closes the device, indicating that the device should now release
     * any system resources it is using.
     *
     * &lt;p&gt;All &lt;code&gt;Receiver&lt;/code&gt; and &lt;code&gt;Transmitter&lt;/code&gt; instances
     * open from this device are closed. This includes instances retrieved
     * via &lt;code&gt;MidiSystem&lt;/code&gt;.
     *
     * @see #open
     * @see #isOpen
     */
    public void close();


    /**
     * Reports whether the device is open.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the device is open, otherwise
     * &lt;code&gt;false&lt;/code&gt;
     * @see #open
     * @see #close
     */
    public boolean isOpen();


    /**
     * Obtains the current time-stamp of the device, in microseconds.
     * If a device supports time-stamps, it should start counting at
     * 0 when the device is opened and continue incrementing its
     * time-stamp in microseconds until the device is closed.
     * If it does not support time-stamps, it should always return
     * -1.
     * @return the current time-stamp of the device in microseconds,
     * or -1 if time-stamping is not supported by the device.
     */
    public long getMicrosecondPosition();


    /**
     * Obtains the maximum number of MIDI IN connections available on this
     * MIDI device for receiving MIDI data.
     * @return maximum number of MIDI IN connections,
     * or -1 if an unlimited number of connections is available.
     */
    public int getMaxReceivers();


    /**
     * Obtains the maximum number of MIDI OUT connections available on this
     * MIDI device for transmitting MIDI data.
     * @return maximum number of MIDI OUT connections,
     * or -1 if an unlimited number of connections is available.
     */
    public int getMaxTransmitters();


    /**
     * Obtains a MIDI IN receiver through which the MIDI device may receive
     * MIDI data.  The returned receiver must be closed when the application
     * has finished using it.
     *
     * &lt;p&gt;Usually the returned receiver implements
     * the {@code MidiDeviceReceiver} interface.
     *
     * &lt;p&gt;Obtaining a &lt;code&gt;Receiver&lt;/code&gt; with this method does not
     * open the device. To be able to use the device, it has to be
     * opened explicitly by calling {@link #open}. Also, closing the
     * &lt;code&gt;Receiver&lt;/code&gt; does not close the device. It has to be
     * closed explicitly by calling {@link #close}.
     *
     * @return a receiver for the device.
     * @throws MidiUnavailableException thrown if a receiver is not available
     * due to resource restrictions
     * @see Receiver#close()
     */
    public Receiver getReceiver() throws MidiUnavailableException;


    /**
     * Returns all currently active, non-closed receivers
     * connected with this MidiDevice.
     * A receiver can be removed
     * from the device by closing it.
     *
     * &lt;p&gt;Usually the returned receivers implement
     * the {@code MidiDeviceReceiver} interface.
     *
     * @return an unmodifiable list of the open receivers
     * @since 1.5
     */
    List&lt;Receiver&gt; getReceivers();


    /**
     * Obtains a MIDI OUT connection from which the MIDI device will transmit
     * MIDI data  The returned transmitter must be closed when the application
     * has finished using it.
     *
     * &lt;p&gt;Usually the returned transmitter implements
     * the {@code MidiDeviceTransmitter} interface.
     *
     * &lt;p&gt;Obtaining a &lt;code&gt;Transmitter&lt;/code&gt; with this method does not
     * open the device. To be able to use the device, it has to be
     * opened explicitly by calling {@link #open}. Also, closing the
     * &lt;code&gt;Transmitter&lt;/code&gt; does not close the device. It has to be
     * closed explicitly by calling {@link #close}.
     *
     * @return a MIDI OUT transmitter for the device.
     * @throws MidiUnavailableException thrown if a transmitter is not available
     * due to resource restrictions
     * @see Transmitter#close()
     */
    public Transmitter getTransmitter() throws MidiUnavailableException;


    /**
     * Returns all currently active, non-closed transmitters
     * connected with this MidiDevice.
     * A transmitter can be removed
     * from the device by closing it.
     *
     * &lt;p&gt;Usually the returned transmitters implement
     * the {@code MidiDeviceTransmitter} interface.
     *
     * @return an unmodifiable list of the open transmitters
     * @since 1.5
     */
    List&lt;Transmitter&gt; getTransmitters();



    /**
     * A &lt;code&gt;MidiDevice.Info&lt;/code&gt; object contains assorted
     * data about a &lt;code&gt;{@link MidiDevice}&lt;/code&gt;, including its
     * name, the company who created it, and descriptive text.
     *
     * @see MidiDevice#getDeviceInfo
     */
    public static class Info {

        /**
         * The device's name.
         */
        private String name;

        /**
         * The name of the company who provides the device.
         */
        private String vendor;

        /**
         * A description of the device.
         */
        private String description;

        /**
         * Device version.
         */
        private String version;


        /**
         * Constructs a device info object.
         *
         * @param name the name of the device
         * @param vendor the name of the company who provides the device
         * @param description a description of the device
         * @param version version information for the device
         */
        protected Info(String name, String vendor, String description, String version) {

            this.name = name;
            this.vendor = vendor;
            this.description = description;
            this.version = version;
        }


        /**
         * Reports whether two objects are equal.
         * Returns &lt;code&gt;true&lt;/code&gt; if the objects are identical.
         * @param obj the reference object with which to compare this
         * object
         * @return &lt;code&gt;true&lt;/code&gt; if this object is the same as the
         * &lt;code&gt;obj&lt;/code&gt; argument; &lt;code&gt;false&lt;/code&gt; otherwise
         */
        public final boolean equals(Object obj) {
            return super.equals(obj);
        }


        /**
         * Finalizes the hashcode method.
         */
        public final int hashCode() {
            return super.hashCode();
        }


        /**
         * Obtains the name of the device.
         *
         * @return a string containing the device's name
         */
        public final String getName() {
            return name;
        }


        /**
         * Obtains the name of the company who supplies the device.
         * @return device the vendor's name
         */
        public final String getVendor() {
            return vendor;
        }


        /**
         * Obtains the description of the device.
         * @return a description of the device
         */
        public final String getDescription() {
            return description;
        }


        /**
         * Obtains the version of the device.
         * @return textual version information for the device.
         */
        public final String getVersion() {
            return version;
        }


        /**
         * Provides a string representation of the device information.

         * @return a description of the info object
         */
        public final String toString() {
            return name;
        }
    } // class Info


}
</pre>
</body>
</html>
