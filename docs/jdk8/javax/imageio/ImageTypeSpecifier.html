<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.imageio;

import java.awt.Point;
import java.awt.Transparency;
import java.awt.image.BandedSampleModel;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.color.ColorSpace;
import java.awt.image.IndexColorModel;
import java.awt.image.ComponentColorModel;
import java.awt.image.DataBuffer;
import java.awt.image.DirectColorModel;
import java.awt.image.MultiPixelPackedSampleModel;
import java.awt.image.PixelInterleavedSampleModel;
import java.awt.image.SinglePixelPackedSampleModel;
import java.awt.image.Raster;
import java.awt.image.RenderedImage;
import java.awt.image.SampleModel;
import java.awt.image.WritableRaster;
import java.util.Hashtable;

/**
 * A class that allows the format of an image (in particular, its
 * &lt;code&gt;SampleModel&lt;/code&gt; and &lt;code&gt;ColorModel&lt;/code&gt;) to be
 * specified in a convenient manner.
 *
 */
public class ImageTypeSpecifier {

    /**
     * The &lt;code&gt;ColorModel&lt;/code&gt; to be used as a prototype.
     */
    protected ColorModel colorModel;

    /**
     * A &lt;code&gt;SampleModel&lt;/code&gt; to be used as a prototype.
     */
    protected SampleModel sampleModel;

    /**
     * Cached specifiers for all of the standard
     * &lt;code&gt;BufferedImage&lt;/code&gt; types.
     */
    private static ImageTypeSpecifier[] BISpecifier;
    private static ColorSpace sRGB;
    // Initialize the standard specifiers
    static {
        sRGB = ColorSpace.getInstance(ColorSpace.CS_sRGB);

        BISpecifier =
            new ImageTypeSpecifier[BufferedImage.TYPE_BYTE_INDEXED + 1];
    }

    /**
     * A constructor to be used by inner subclasses only.
     */
    private ImageTypeSpecifier() {}

    /**
     * Constructs an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; directly
     * from a &lt;code&gt;ColorModel&lt;/code&gt; and a &lt;code&gt;SampleModel&lt;/code&gt;.
     * It is the caller's responsibility to supply compatible
     * parameters.
     *
     * @param colorModel a &lt;code&gt;ColorModel&lt;/code&gt;.
     * @param sampleModel a &lt;code&gt;SampleModel&lt;/code&gt;.
     *
     * @exception IllegalArgumentException if either parameter is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;sampleModel&lt;/code&gt;
     * is not compatible with &lt;code&gt;colorModel&lt;/code&gt;.
     */
    public ImageTypeSpecifier(ColorModel colorModel, SampleModel sampleModel) {
        if (colorModel == null) {
            throw new IllegalArgumentException(&quot;colorModel == null!&quot;);
        }
        if (sampleModel == null) {
            throw new IllegalArgumentException(&quot;sampleModel == null!&quot;);
        }
        if (!colorModel.isCompatibleSampleModel(sampleModel)) {
            throw new IllegalArgumentException
                (&quot;sampleModel is incompatible with colorModel!&quot;);
        }
        this.colorModel = colorModel;
        this.sampleModel = sampleModel;
    }

    /**
     * Constructs an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; from a
     * &lt;code&gt;RenderedImage&lt;/code&gt;.  If a &lt;code&gt;BufferedImage&lt;/code&gt; is
     * being used, one of the factory methods
     * &lt;code&gt;createFromRenderedImage&lt;/code&gt; or
     * &lt;code&gt;createFromBufferedImageType&lt;/code&gt; should be used instead in
     * order to get a more accurate result.
     *
     * @param image a &lt;code&gt;RenderedImage&lt;/code&gt;.
     *
     * @exception IllegalArgumentException if the argument is
     * &lt;code&gt;null&lt;/code&gt;.
     */
    public ImageTypeSpecifier(RenderedImage image) {
        if (image == null) {
            throw new IllegalArgumentException(&quot;image == null!&quot;);
        }
        colorModel = image.getColorModel();
        sampleModel = image.getSampleModel();
    }

    // Packed

    static class Packed extends ImageTypeSpecifier {
        ColorSpace colorSpace;
        int redMask;
        int greenMask;
        int blueMask;
        int alphaMask;
        int transferType;
        boolean isAlphaPremultiplied;

        public Packed(ColorSpace colorSpace,
                      int redMask,
                      int greenMask,
                      int blueMask,
                      int alphaMask, // 0 if no alpha
                      int transferType,
                      boolean isAlphaPremultiplied) {
            if (colorSpace == null) {
                throw new IllegalArgumentException(&quot;colorSpace == null!&quot;);
            }
            if (colorSpace.getType() != ColorSpace.TYPE_RGB) {
                throw new IllegalArgumentException
                    (&quot;colorSpace is not of type TYPE_RGB!&quot;);
            }
            if (transferType != DataBuffer.TYPE_BYTE &amp;&amp;
                transferType != DataBuffer.TYPE_USHORT &amp;&amp;
                transferType != DataBuffer.TYPE_INT) {
                throw new IllegalArgumentException
                    (&quot;Bad value for transferType!&quot;);
            }
            if (redMask == 0 &amp;&amp; greenMask == 0 &amp;&amp;
                blueMask == 0 &amp;&amp; alphaMask == 0) {
                throw new IllegalArgumentException
                    (&quot;No mask has at least 1 bit set!&quot;);
            }
            this.colorSpace = colorSpace;
            this.redMask = redMask;
            this.greenMask = greenMask;
            this.blueMask = blueMask;
            this.alphaMask = alphaMask;
            this.transferType = transferType;
            this.isAlphaPremultiplied = isAlphaPremultiplied;

            int bits = 32;
            this.colorModel =
                new DirectColorModel(colorSpace,
                                     bits,
                                     redMask, greenMask, blueMask,
                                     alphaMask, isAlphaPremultiplied,
                                     transferType);
            this.sampleModel = colorModel.createCompatibleSampleModel(1, 1);
        }
    }

    /**
     * Returns a specifier for a packed image format that will use a
     * &lt;code&gt;DirectColorModel&lt;/code&gt; and a packed
     * &lt;code&gt;SampleModel&lt;/code&gt; to store each pixel packed into in a
     * single byte, short, or int.
     *
     * @param colorSpace the desired &lt;code&gt;ColorSpace&lt;/code&gt;.
     * @param redMask a contiguous mask indicated the position of the
     * red channel.
     * @param greenMask a contiguous mask indicated the position of the
     * green channel.
     * @param blueMask a contiguous mask indicated the position of the
     * blue channel.
     * @param alphaMask a contiguous mask indicated the position of the
     * alpha channel.
     * @param transferType the desired &lt;code&gt;SampleModel&lt;/code&gt; transfer type.
     * @param isAlphaPremultiplied &lt;code&gt;true&lt;/code&gt; if the color channels
     * will be premultipled by the alpha channel.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if &lt;code&gt;colorSpace&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;colorSpace&lt;/code&gt;
     * is not of type &lt;code&gt;TYPE_RGB&lt;/code&gt;.
     * @exception IllegalArgumentException if no mask has at least 1
     * bit set.
     * @exception IllegalArgumentException if
     * &lt;code&gt;transferType&lt;/code&gt; if not one of
     * &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;, or
     * &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;.
     */
    public static ImageTypeSpecifier
        createPacked(ColorSpace colorSpace,
                     int redMask,
                     int greenMask,
                     int blueMask,
                     int alphaMask, // 0 if no alpha
                     int transferType,
                     boolean isAlphaPremultiplied) {
        return new ImageTypeSpecifier.Packed(colorSpace,
                                             redMask,
                                             greenMask,
                                             blueMask,
                                             alphaMask, // 0 if no alpha
                                             transferType,
                                             isAlphaPremultiplied);
    }

    static ColorModel createComponentCM(ColorSpace colorSpace,
                                        int numBands,
                                        int dataType,
                                        boolean hasAlpha,
                                        boolean isAlphaPremultiplied) {
        int transparency =
            hasAlpha ? Transparency.TRANSLUCENT : Transparency.OPAQUE;

        int[] numBits = new int[numBands];
        int bits = DataBuffer.getDataTypeSize(dataType);

        for (int i = 0; i &lt; numBands; i++) {
            numBits[i] = bits;
        }

        return new ComponentColorModel(colorSpace,
                                       numBits,
                                       hasAlpha,
                                       isAlphaPremultiplied,
                                       transparency,
                                       dataType);
    }

    // Interleaved

    static class Interleaved extends ImageTypeSpecifier {
        ColorSpace colorSpace;
        int[] bandOffsets;
        int dataType;
        boolean hasAlpha;
        boolean isAlphaPremultiplied;

        public Interleaved(ColorSpace colorSpace,
                           int[] bandOffsets,
                           int dataType,
                           boolean hasAlpha,
                           boolean isAlphaPremultiplied) {
            if (colorSpace == null) {
                throw new IllegalArgumentException(&quot;colorSpace == null!&quot;);
            }
            if (bandOffsets == null) {
                throw new IllegalArgumentException(&quot;bandOffsets == null!&quot;);
            }
            int numBands = colorSpace.getNumComponents() +
                (hasAlpha ? 1 : 0);
            if (bandOffsets.length != numBands) {
                throw new IllegalArgumentException
                    (&quot;bandOffsets.length is wrong!&quot;);
            }
            if (dataType != DataBuffer.TYPE_BYTE &amp;&amp;
                dataType != DataBuffer.TYPE_SHORT &amp;&amp;
                dataType != DataBuffer.TYPE_USHORT &amp;&amp;
                dataType != DataBuffer.TYPE_INT &amp;&amp;
                dataType != DataBuffer.TYPE_FLOAT &amp;&amp;
                dataType != DataBuffer.TYPE_DOUBLE) {
                throw new IllegalArgumentException
                    (&quot;Bad value for dataType!&quot;);
            }
            this.colorSpace = colorSpace;
            this.bandOffsets = (int[])bandOffsets.clone();
            this.dataType = dataType;
            this.hasAlpha = hasAlpha;
            this.isAlphaPremultiplied = isAlphaPremultiplied;

            this.colorModel =
                ImageTypeSpecifier.createComponentCM(colorSpace,
                                                     bandOffsets.length,
                                                     dataType,
                                                     hasAlpha,
                                                     isAlphaPremultiplied);

            int minBandOffset = bandOffsets[0];
            int maxBandOffset = minBandOffset;
            for (int i = 0; i &lt; bandOffsets.length; i++) {
                int offset = bandOffsets[i];
                minBandOffset = Math.min(offset, minBandOffset);
                maxBandOffset = Math.max(offset, maxBandOffset);
            }
            int pixelStride = maxBandOffset - minBandOffset + 1;

            int w = 1;
            int h = 1;
            this.sampleModel =
                new PixelInterleavedSampleModel(dataType,
                                                w, h,
                                                pixelStride,
                                                w*pixelStride,
                                                bandOffsets);
        }

        public boolean equals(Object o) {
            if ((o == null) ||
                !(o instanceof ImageTypeSpecifier.Interleaved)) {
                return false;
            }

            ImageTypeSpecifier.Interleaved that =
                (ImageTypeSpecifier.Interleaved)o;

            if ((!(this.colorSpace.equals(that.colorSpace))) ||
                (this.dataType != that.dataType) ||
                (this.hasAlpha != that.hasAlpha) ||
                (this.isAlphaPremultiplied != that.isAlphaPremultiplied) ||
                (this.bandOffsets.length != that.bandOffsets.length)) {
                return false;
            }

            for (int i = 0; i &lt; bandOffsets.length; i++) {
                if (this.bandOffsets[i] != that.bandOffsets[i]) {
                    return false;
                }
            }

            return true;
        }

        public int hashCode() {
            return (super.hashCode() +
                    (4 * bandOffsets.length) +
                    (25 * dataType) +
                    (hasAlpha ? 17 : 18));
        }
    }

    /**
     * Returns a specifier for an interleaved image format that will
     * use a &lt;code&gt;ComponentColorModel&lt;/code&gt; and a
     * &lt;code&gt;PixelInterleavedSampleModel&lt;/code&gt; to store each pixel
     * component in a separate byte, short, or int.
     *
     * @param colorSpace the desired &lt;code&gt;ColorSpace&lt;/code&gt;.
     * @param bandOffsets an array of &lt;code&gt;int&lt;/code&gt;s indicating the
     * offsets for each band.
     * @param dataType the desired data type, as one of the enumerations
     * from the &lt;code&gt;DataBuffer&lt;/code&gt; class.
     * @param hasAlpha &lt;code&gt;true&lt;/code&gt; if an alpha channel is desired.
     * @param isAlphaPremultiplied &lt;code&gt;true&lt;/code&gt; if the color channels
     * will be premultipled by the alpha channel.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if &lt;code&gt;colorSpace&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;bandOffsets&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is
     * not one of the legal &lt;code&gt;DataBuffer.TYPE_*&lt;/code&gt; constants.
     * @exception IllegalArgumentException if
     * &lt;code&gt;bandOffsets.length&lt;/code&gt; does not equal the number of
     * color space components, plus 1 if &lt;code&gt;hasAlpha&lt;/code&gt; is
     * &lt;code&gt;true&lt;/code&gt;.
     */
    public static ImageTypeSpecifier
        createInterleaved(ColorSpace colorSpace,
                          int[] bandOffsets,
                          int dataType,
                          boolean hasAlpha,
                          boolean isAlphaPremultiplied) {
        return new ImageTypeSpecifier.Interleaved(colorSpace,
                                                  bandOffsets,
                                                  dataType,
                                                  hasAlpha,
                                                  isAlphaPremultiplied);
    }

    // Banded

    static class Banded extends ImageTypeSpecifier {
        ColorSpace colorSpace;
        int[] bankIndices;
        int[] bandOffsets;
        int dataType;
        boolean hasAlpha;
        boolean isAlphaPremultiplied;

        public Banded(ColorSpace colorSpace,
                      int[] bankIndices,
                      int[] bandOffsets,
                      int dataType,
                      boolean hasAlpha,
                      boolean isAlphaPremultiplied) {
            if (colorSpace == null) {
                throw new IllegalArgumentException(&quot;colorSpace == null!&quot;);
            }
            if (bankIndices == null) {
                throw new IllegalArgumentException(&quot;bankIndices == null!&quot;);
            }
            if (bandOffsets == null) {
                throw new IllegalArgumentException(&quot;bandOffsets == null!&quot;);
            }
            if (bankIndices.length != bandOffsets.length) {
                throw new IllegalArgumentException
                    (&quot;bankIndices.length != bandOffsets.length!&quot;);
            }
            if (dataType != DataBuffer.TYPE_BYTE &amp;&amp;
                dataType != DataBuffer.TYPE_SHORT &amp;&amp;
                dataType != DataBuffer.TYPE_USHORT &amp;&amp;
                dataType != DataBuffer.TYPE_INT &amp;&amp;
                dataType != DataBuffer.TYPE_FLOAT &amp;&amp;
                dataType != DataBuffer.TYPE_DOUBLE) {
                throw new IllegalArgumentException
                    (&quot;Bad value for dataType!&quot;);
            }
            int numBands = colorSpace.getNumComponents() +
                (hasAlpha ? 1 : 0);
            if (bandOffsets.length != numBands) {
                throw new IllegalArgumentException
                    (&quot;bandOffsets.length is wrong!&quot;);
            }

            this.colorSpace = colorSpace;
            this.bankIndices = (int[])bankIndices.clone();
            this.bandOffsets = (int[])bandOffsets.clone();
            this.dataType = dataType;
            this.hasAlpha = hasAlpha;
            this.isAlphaPremultiplied = isAlphaPremultiplied;

            this.colorModel =
                ImageTypeSpecifier.createComponentCM(colorSpace,
                                                     bankIndices.length,
                                                     dataType,
                                                     hasAlpha,
                                                     isAlphaPremultiplied);

            int w = 1;
            int h = 1;
            this.sampleModel = new BandedSampleModel(dataType,
                                                     w, h,
                                                     w,
                                                     bankIndices,
                                                     bandOffsets);
        }

        public boolean equals(Object o) {
            if ((o == null) ||
                !(o instanceof ImageTypeSpecifier.Banded)) {
                return false;
            }

            ImageTypeSpecifier.Banded that =
                (ImageTypeSpecifier.Banded)o;

            if ((!(this.colorSpace.equals(that.colorSpace))) ||
                (this.dataType != that.dataType) ||
                (this.hasAlpha != that.hasAlpha) ||
                (this.isAlphaPremultiplied != that.isAlphaPremultiplied) ||
                (this.bankIndices.length != that.bankIndices.length) ||
                (this.bandOffsets.length != that.bandOffsets.length)) {
                return false;
            }

            for (int i = 0; i &lt; bankIndices.length; i++) {
                if (this.bankIndices[i] != that.bankIndices[i]) {
                    return false;
                }
            }

            for (int i = 0; i &lt; bandOffsets.length; i++) {
                if (this.bandOffsets[i] != that.bandOffsets[i]) {
                    return false;
                }
            }

            return true;
        }

        public int hashCode() {
            return (super.hashCode() +
                    (3 * bandOffsets.length) +
                    (7 * bankIndices.length) +
                    (21 * dataType) +
                    (hasAlpha ? 19 : 29));
        }
    }

    /**
     * Returns a specifier for a banded image format that will use a
     * &lt;code&gt;ComponentColorModel&lt;/code&gt; and a
     * &lt;code&gt;BandedSampleModel&lt;/code&gt; to store each channel in a
     * separate array.
     *
     * @param colorSpace the desired &lt;code&gt;ColorSpace&lt;/code&gt;.
     * @param bankIndices an array of &lt;code&gt;int&lt;/code&gt;s indicating the
     * bank in which each band will be stored.
     * @param bandOffsets an array of &lt;code&gt;int&lt;/code&gt;s indicating the
     * starting offset of each band within its bank.
     * @param dataType the desired data type, as one of the enumerations
     * from the &lt;code&gt;DataBuffer&lt;/code&gt; class.
     * @param hasAlpha &lt;code&gt;true&lt;/code&gt; if an alpha channel is desired.
     * @param isAlphaPremultiplied &lt;code&gt;true&lt;/code&gt; if the color channels
     * will be premultipled by the alpha channel.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if &lt;code&gt;colorSpace&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;bankIndices&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;bandOffsets&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if the lengths of
     * &lt;code&gt;bankIndices&lt;/code&gt; and &lt;code&gt;bandOffsets&lt;/code&gt; differ.
     * @exception IllegalArgumentException if
     * &lt;code&gt;bandOffsets.length&lt;/code&gt; does not equal the number of
     * color space components, plus 1 if &lt;code&gt;hasAlpha&lt;/code&gt; is
     * &lt;code&gt;true&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is
     * not one of the legal &lt;code&gt;DataBuffer.TYPE_*&lt;/code&gt; constants.
     */
    public static ImageTypeSpecifier
        createBanded(ColorSpace colorSpace,
                     int[] bankIndices,
                     int[] bandOffsets,
                     int dataType,
                     boolean hasAlpha,
                     boolean isAlphaPremultiplied) {
        return new ImageTypeSpecifier.Banded(colorSpace,
                                             bankIndices,
                                             bandOffsets,
                                             dataType,
                                             hasAlpha,
                                             isAlphaPremultiplied);
    }

    // Grayscale

    static class Grayscale extends ImageTypeSpecifier {
        int bits;
        int dataType;
        boolean isSigned;
        boolean hasAlpha;
        boolean isAlphaPremultiplied;

        public Grayscale(int bits,
                         int dataType,
                         boolean isSigned,
                         boolean hasAlpha,
                         boolean isAlphaPremultiplied)
        {
            if (bits != 1 &amp;&amp; bits != 2 &amp;&amp; bits != 4 &amp;&amp;
                bits != 8 &amp;&amp; bits != 16)
            {
                throw new IllegalArgumentException(&quot;Bad value for bits!&quot;);
            }
            if (dataType != DataBuffer.TYPE_BYTE &amp;&amp;
                dataType != DataBuffer.TYPE_SHORT &amp;&amp;
                dataType != DataBuffer.TYPE_USHORT)
            {
                throw new IllegalArgumentException
                    (&quot;Bad value for dataType!&quot;);
            }
            if (bits &gt; 8 &amp;&amp; dataType == DataBuffer.TYPE_BYTE) {
                throw new IllegalArgumentException
                    (&quot;Too many bits for dataType!&quot;);
            }

            this.bits = bits;
            this.dataType = dataType;
            this.isSigned = isSigned;
            this.hasAlpha = hasAlpha;
            this.isAlphaPremultiplied = isAlphaPremultiplied;

            ColorSpace colorSpace = ColorSpace.getInstance(ColorSpace.CS_GRAY);

            if ((bits == 8 &amp;&amp; dataType == DataBuffer.TYPE_BYTE) ||
                (bits == 16 &amp;&amp;
                 (dataType == DataBuffer.TYPE_SHORT ||
                  dataType == DataBuffer.TYPE_USHORT))) {
                // Use component color model &amp; sample model

                int numBands = hasAlpha ? 2 : 1;
                int transparency =
                    hasAlpha ? Transparency.TRANSLUCENT : Transparency.OPAQUE;


                int[] nBits = new int[numBands];
                nBits[0] = bits;
                if (numBands == 2) {
                    nBits[1] = bits;
                }
                this.colorModel =
                    new ComponentColorModel(colorSpace,
                                            nBits,
                                            hasAlpha,
                                            isAlphaPremultiplied,
                                            transparency,
                                            dataType);

                int[] bandOffsets = new int[numBands];
                bandOffsets[0] = 0;
                if (numBands == 2) {
                    bandOffsets[1] = 1;
                }

                int w = 1;
                int h = 1;
                this.sampleModel =
                    new PixelInterleavedSampleModel(dataType,
                                                    w, h,
                                                    numBands, w*numBands,
                                                    bandOffsets);
            } else {
                int numEntries = 1 &lt;&lt; bits;
                byte[] arr = new byte[numEntries];
                for (int i = 0; i &lt; numEntries; i++) {
                    arr[i] = (byte)(i*255/(numEntries - 1));
                }
                this.colorModel =
                    new IndexColorModel(bits, numEntries, arr, arr, arr);

                this.sampleModel =
                    new MultiPixelPackedSampleModel(dataType, 1, 1, bits);
            }
        }
    }

    /**
     * Returns a specifier for a grayscale image format that will pack
     * pixels of the given bit depth into array elements of
     * the specified data type.
     *
     * @param bits the number of bits per gray value (1, 2, 4, 8, or 16).
     * @param dataType the desired data type, as one of the enumerations
     * from the &lt;code&gt;DataBuffer&lt;/code&gt; class.
     * @param isSigned &lt;code&gt;true&lt;/code&gt; if negative values are to
     * be represented.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is
     * not one of 1, 2, 4, 8, or 16.
     * @exception IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is
     * not one of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     * &lt;code&gt;DataBuffer.TYPE_SHORT&lt;/code&gt;, or
     * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is
     * larger than the bit size of the given &lt;code&gt;dataType&lt;/code&gt;.
     */
    public static ImageTypeSpecifier
        createGrayscale(int bits,
                        int dataType,
                        boolean isSigned) {
        return new ImageTypeSpecifier.Grayscale(bits,
                                                dataType,
                                                isSigned,
                                                false,
                                                false);
    }

    /**
     * Returns a specifier for a grayscale plus alpha image format
     * that will pack pixels of the given bit depth into array
     * elements of the specified data type.
     *
     * @param bits the number of bits per gray value (1, 2, 4, 8, or 16).
     * @param dataType the desired data type, as one of the enumerations
     * from the &lt;code&gt;DataBuffer&lt;/code&gt; class.
     * @param isSigned &lt;code&gt;true&lt;/code&gt; if negative values are to
     * be represented.
     * @param isAlphaPremultiplied &lt;code&gt;true&lt;/code&gt; if the luminance channel
     * will be premultipled by the alpha channel.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is
     * not one of 1, 2, 4, 8, or 16.
     * @exception IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is
     * not one of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     * &lt;code&gt;DataBuffer.TYPE_SHORT&lt;/code&gt;, or
     * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is
     * larger than the bit size of the given &lt;code&gt;dataType&lt;/code&gt;.
     */
    public static ImageTypeSpecifier
        createGrayscale(int bits,
                        int dataType,
                        boolean isSigned,
                        boolean isAlphaPremultiplied) {
        return new ImageTypeSpecifier.Grayscale(bits,
                                                dataType,
                                                isSigned,
                                                true,
                                                isAlphaPremultiplied);
    }

    // Indexed

    static class Indexed extends ImageTypeSpecifier {
        byte[] redLUT;
        byte[] greenLUT;
        byte[] blueLUT;
        byte[] alphaLUT = null;
        int bits;
        int dataType;

        public Indexed(byte[] redLUT,
                       byte[] greenLUT,
                       byte[] blueLUT,
                       byte[] alphaLUT,
                       int bits,
                       int dataType) {
            if (redLUT == null || greenLUT == null || blueLUT == null) {
                throw new IllegalArgumentException(&quot;LUT is null!&quot;);
            }
            if (bits != 1 &amp;&amp; bits != 2 &amp;&amp; bits != 4 &amp;&amp;
                bits != 8 &amp;&amp; bits != 16) {
                throw new IllegalArgumentException(&quot;Bad value for bits!&quot;);
            }
            if (dataType != DataBuffer.TYPE_BYTE &amp;&amp;
                dataType != DataBuffer.TYPE_SHORT &amp;&amp;
                dataType != DataBuffer.TYPE_USHORT &amp;&amp;
                dataType != DataBuffer.TYPE_INT) {
                throw new IllegalArgumentException
                    (&quot;Bad value for dataType!&quot;);
            }
            if ((bits &gt; 8 &amp;&amp; dataType == DataBuffer.TYPE_BYTE) ||
                (bits &gt; 16 &amp;&amp; dataType != DataBuffer.TYPE_INT)) {
                throw new IllegalArgumentException
                    (&quot;Too many bits for dataType!&quot;);
            }

            int len = 1 &lt;&lt; bits;
            if (redLUT.length != len ||
                greenLUT.length != len ||
                blueLUT.length != len ||
                (alphaLUT != null &amp;&amp; alphaLUT.length != len)) {
                throw new IllegalArgumentException(&quot;LUT has improper length!&quot;);
            }
            this.redLUT = (byte[])redLUT.clone();
            this.greenLUT = (byte[])greenLUT.clone();
            this.blueLUT = (byte[])blueLUT.clone();
            if (alphaLUT != null) {
                this.alphaLUT = (byte[])alphaLUT.clone();
            }
            this.bits = bits;
            this.dataType = dataType;

            if (alphaLUT == null) {
                this.colorModel = new IndexColorModel(bits,
                                                      redLUT.length,
                                                      redLUT,
                                                      greenLUT,
                                                      blueLUT);
            } else {
                this.colorModel = new IndexColorModel(bits,
                                                      redLUT.length,
                                                      redLUT,
                                                      greenLUT,
                                                      blueLUT,
                                                      alphaLUT);
            }

            if ((bits == 8 &amp;&amp; dataType == DataBuffer.TYPE_BYTE) ||
                (bits == 16 &amp;&amp;
                 (dataType == DataBuffer.TYPE_SHORT ||
                  dataType == DataBuffer.TYPE_USHORT))) {
                int[] bandOffsets = { 0 };
                this.sampleModel =
                    new PixelInterleavedSampleModel(dataType,
                                                    1, 1, 1, 1,
                                                    bandOffsets);
            } else {
                this.sampleModel =
                    new MultiPixelPackedSampleModel(dataType, 1, 1, bits);
            }
        }
    }

    /**
     * Returns a specifier for an indexed-color image format that will pack
     * index values of the given bit depth into array elements of
     * the specified data type.
     *
     * @param redLUT an array of &lt;code&gt;byte&lt;/code&gt;s containing
     * the red values for each index.
     * @param greenLUT an array of &lt;code&gt;byte&lt;/code&gt;s containing * the
     *  green values for each index.
     * @param blueLUT an array of &lt;code&gt;byte&lt;/code&gt;s containing the
     * blue values for each index.
     * @param alphaLUT an array of &lt;code&gt;byte&lt;/code&gt;s containing the
     * alpha values for each index, or &lt;code&gt;null&lt;/code&gt; to create a
     * fully opaque LUT.
     * @param bits the number of bits in each index.
     * @param dataType the desired output type, as one of the enumerations
     * from the &lt;code&gt;DataBuffer&lt;/code&gt; class.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if &lt;code&gt;redLUT&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;greenLUT&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;blueLUT&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is
     * not one of 1, 2, 4, 8, or 16.
     * @exception IllegalArgumentException if the
     * non-&lt;code&gt;null&lt;/code&gt; LUT parameters do not have lengths of
     * exactly {@code 1 &lt;&lt; bits}.
     * @exception IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is
     * not one of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     * &lt;code&gt;DataBuffer.TYPE_SHORT&lt;/code&gt;,
     * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;,
     * or &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is
     * larger than the bit size of the given &lt;code&gt;dataType&lt;/code&gt;.
     */
    public static ImageTypeSpecifier
        createIndexed(byte[] redLUT,
                      byte[] greenLUT,
                      byte[] blueLUT,
                      byte[] alphaLUT,
                      int bits,
                      int dataType) {
        return new ImageTypeSpecifier.Indexed(redLUT,
                                              greenLUT,
                                              blueLUT,
                                              alphaLUT,
                                              bits,
                                              dataType);
    }

    /**
     * Returns an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; that encodes
     * one of the standard &lt;code&gt;BufferedImage&lt;/code&gt; types
     * (other than &lt;code&gt;TYPE_CUSTOM&lt;/code&gt;).
     *
     * @param bufferedImageType an int representing one of the standard
     * &lt;code&gt;BufferedImage&lt;/code&gt; types.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if
     * &lt;code&gt;bufferedImageType&lt;/code&gt; is not one of the standard
     * types, or is equal to &lt;code&gt;TYPE_CUSTOM&lt;/code&gt;.
     *
     * @see java.awt.image.BufferedImage
     * @see java.awt.image.BufferedImage#TYPE_INT_RGB
     * @see java.awt.image.BufferedImage#TYPE_INT_ARGB
     * @see java.awt.image.BufferedImage#TYPE_INT_ARGB_PRE
     * @see java.awt.image.BufferedImage#TYPE_INT_BGR
     * @see java.awt.image.BufferedImage#TYPE_3BYTE_BGR
     * @see java.awt.image.BufferedImage#TYPE_4BYTE_ABGR
     * @see java.awt.image.BufferedImage#TYPE_4BYTE_ABGR_PRE
     * @see java.awt.image.BufferedImage#TYPE_USHORT_565_RGB
     * @see java.awt.image.BufferedImage#TYPE_USHORT_555_RGB
     * @see java.awt.image.BufferedImage#TYPE_BYTE_GRAY
     * @see java.awt.image.BufferedImage#TYPE_USHORT_GRAY
     * @see java.awt.image.BufferedImage#TYPE_BYTE_BINARY
     * @see java.awt.image.BufferedImage#TYPE_BYTE_INDEXED
     */
    public static
        ImageTypeSpecifier createFromBufferedImageType(int bufferedImageType) {
        if (bufferedImageType &gt;= BufferedImage.TYPE_INT_RGB &amp;&amp;
            bufferedImageType &lt;= BufferedImage.TYPE_BYTE_INDEXED) {
            return getSpecifier(bufferedImageType);
        } else if (bufferedImageType == BufferedImage.TYPE_CUSTOM) {
            throw new IllegalArgumentException(&quot;Cannot create from TYPE_CUSTOM!&quot;);
        } else {
            throw new IllegalArgumentException(&quot;Invalid BufferedImage type!&quot;);
        }
    }

    /**
     * Returns an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; that encodes the
     * layout of a &lt;code&gt;RenderedImage&lt;/code&gt; (which may be a
     * &lt;code&gt;BufferedImage&lt;/code&gt;).
     *
     * @param image a &lt;code&gt;RenderedImage&lt;/code&gt;.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if &lt;code&gt;image&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     */
    public static
        ImageTypeSpecifier createFromRenderedImage(RenderedImage image) {
        if (image == null) {
            throw new IllegalArgumentException(&quot;image == null!&quot;);
        }

        if (image instanceof BufferedImage) {
            int bufferedImageType = ((BufferedImage)image).getType();
            if (bufferedImageType != BufferedImage.TYPE_CUSTOM) {
                return getSpecifier(bufferedImageType);
            }
        }

        return new ImageTypeSpecifier(image);
    }

    /**
     * Returns an int containing one of the enumerated constant values
     * describing image formats from &lt;code&gt;BufferedImage&lt;/code&gt;.
     *
     * @return an &lt;code&gt;int&lt;/code&gt; representing a
     * &lt;code&gt;BufferedImage&lt;/code&gt; type.
     *
     * @see java.awt.image.BufferedImage
     * @see java.awt.image.BufferedImage#TYPE_CUSTOM
     * @see java.awt.image.BufferedImage#TYPE_INT_RGB
     * @see java.awt.image.BufferedImage#TYPE_INT_ARGB
     * @see java.awt.image.BufferedImage#TYPE_INT_ARGB_PRE
     * @see java.awt.image.BufferedImage#TYPE_INT_BGR
     * @see java.awt.image.BufferedImage#TYPE_3BYTE_BGR
     * @see java.awt.image.BufferedImage#TYPE_4BYTE_ABGR
     * @see java.awt.image.BufferedImage#TYPE_4BYTE_ABGR_PRE
     * @see java.awt.image.BufferedImage#TYPE_USHORT_565_RGB
     * @see java.awt.image.BufferedImage#TYPE_USHORT_555_RGB
     * @see java.awt.image.BufferedImage#TYPE_BYTE_GRAY
     * @see java.awt.image.BufferedImage#TYPE_USHORT_GRAY
     * @see java.awt.image.BufferedImage#TYPE_BYTE_BINARY
     * @see java.awt.image.BufferedImage#TYPE_BYTE_INDEXED
     */
    public int getBufferedImageType() {
        BufferedImage bi = createBufferedImage(1, 1);
        return bi.getType();
    }

    /**
     * Return the number of color components
     * specified by this object.  This is the same value as returned by
     * &lt;code&gt;ColorModel.getNumComponents&lt;/code&gt;
     *
     * @return the number of components in the image.
     */
    public int getNumComponents() {
        return colorModel.getNumComponents();
    }

    /**
     * Return the number of bands
     * specified by this object.  This is the same value as returned by
     * &lt;code&gt;SampleModel.getNumBands&lt;/code&gt;
     *
     * @return the number of bands in the image.
     */
    public int getNumBands() {
        return sampleModel.getNumBands();
    }

    /**
     * Return the number of bits used to represent samples of the given band.
     *
     * @param band the index of the band to be queried, as an
     * int.
     *
     * @return an int specifying a number of bits.
     *
     * @exception IllegalArgumentException if &lt;code&gt;band&lt;/code&gt; is
     * negative or greater than the largest band index.
     */
    public int getBitsPerBand(int band) {
        if (band &lt; 0 | band &gt;= getNumBands()) {
            throw new IllegalArgumentException(&quot;band out of range!&quot;);
        }
        return sampleModel.getSampleSize(band);
    }

    /**
     * Returns a &lt;code&gt;SampleModel&lt;/code&gt; based on the settings
     * encapsulated within this object.  The width and height of the
     * &lt;code&gt;SampleModel&lt;/code&gt; will be set to arbitrary values.
     *
     * @return a &lt;code&gt;SampleModel&lt;/code&gt; with arbitrary dimensions.
     */
    public SampleModel getSampleModel() {
        return sampleModel;
    }

    /**
     * Returns a &lt;code&gt;SampleModel&lt;/code&gt; based on the settings
     * encapsulated within this object.  The width and height of the
     * &lt;code&gt;SampleModel&lt;/code&gt; will be set to the supplied values.
     *
     * @param width the desired width of the returned &lt;code&gt;SampleModel&lt;/code&gt;.
     * @param height the desired height of the returned
     * &lt;code&gt;SampleModel&lt;/code&gt;.
     *
     * @return a &lt;code&gt;SampleModel&lt;/code&gt; with the given dimensions.
     *
     * @exception IllegalArgumentException if either &lt;code&gt;width&lt;/code&gt; or
     * &lt;code&gt;height&lt;/code&gt; are negative or zero.
     * @exception IllegalArgumentException if the product of
     * &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; is greater than
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;
     */
    public SampleModel getSampleModel(int width, int height) {
        if ((long)width*height &gt; Integer.MAX_VALUE) {
            throw new IllegalArgumentException
                (&quot;width*height &gt; Integer.MAX_VALUE!&quot;);
        }
        return sampleModel.createCompatibleSampleModel(width, height);
    }

    /**
     * Returns the &lt;code&gt;ColorModel&lt;/code&gt; specified by this object.
     *
     * @return a &lt;code&gt;ColorModel&lt;/code&gt;.
     */
    public ColorModel getColorModel() {
        return colorModel;
    }

    /**
     * Creates a &lt;code&gt;BufferedImage&lt;/code&gt; with a given width and
     * height according to the specification embodied in this object.
     *
     * @param width the desired width of the returned
     * &lt;code&gt;BufferedImage&lt;/code&gt;.
     * @param height the desired height of the returned
     * &lt;code&gt;BufferedImage&lt;/code&gt;.
     *
     * @return a new &lt;code&gt;BufferedImage&lt;/code&gt;
     *
     * @exception IllegalArgumentException if either &lt;code&gt;width&lt;/code&gt; or
     * &lt;code&gt;height&lt;/code&gt; are negative or zero.
     * @exception IllegalArgumentException if the product of
     * &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; is greater than
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, or if the number of array
     * elements needed to store the image is greater than
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.
     */
    public BufferedImage createBufferedImage(int width, int height) {
        try {
            SampleModel sampleModel = getSampleModel(width, height);
            WritableRaster raster =
                Raster.createWritableRaster(sampleModel,
                                            new Point(0, 0));
            return new BufferedImage(colorModel, raster,
                                     colorModel.isAlphaPremultiplied(),
                                     new Hashtable());
        } catch (NegativeArraySizeException e) {
            // Exception most likely thrown from a DataBuffer constructor
            throw new IllegalArgumentException
                (&quot;Array size &gt; Integer.MAX_VALUE!&quot;);
        }
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;Object&lt;/code&gt; is
     * an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; and has a
     * &lt;code&gt;SampleModel&lt;/code&gt; and &lt;code&gt;ColorModel&lt;/code&gt; that are
     * equal to those of this object.
     *
     * @param o the &lt;code&gt;Object&lt;/code&gt; to be compared for equality.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the given object is an equivalent
     * &lt;code&gt;ImageTypeSpecifier&lt;/code&gt;.
     */
    public boolean equals(Object o) {
        if ((o == null) || !(o instanceof ImageTypeSpecifier)) {
            return false;
        }

        ImageTypeSpecifier that = (ImageTypeSpecifier)o;
        return (colorModel.equals(that.colorModel)) &amp;&amp;
            (sampleModel.equals(that.sampleModel));
    }

    /**
     * Returns the hash code for this ImageTypeSpecifier.
     *
     * @return a hash code for this ImageTypeSpecifier
     */
    public int hashCode() {
        return (9 * colorModel.hashCode()) + (14 * sampleModel.hashCode());
    }

    private static ImageTypeSpecifier getSpecifier(int type) {
        if (BISpecifier[type] == null) {
            BISpecifier[type] = createSpecifier(type);
        }
        return BISpecifier[type];
    }

    private static ImageTypeSpecifier createSpecifier(int type) {
        switch(type) {
          case BufferedImage.TYPE_INT_RGB:
              return createPacked(sRGB,
                                  0x00ff0000,
                                  0x0000ff00,
                                  0x000000ff,
                                  0x0,
                                  DataBuffer.TYPE_INT,
                                  false);

          case BufferedImage.TYPE_INT_ARGB:
              return createPacked(sRGB,
                                  0x00ff0000,
                                  0x0000ff00,
                                  0x000000ff,
                                  0xff000000,
                                  DataBuffer.TYPE_INT,
                                  false);

          case BufferedImage.TYPE_INT_ARGB_PRE:
              return createPacked(sRGB,
                                  0x00ff0000,
                                  0x0000ff00,
                                  0x000000ff,
                                  0xff000000,
                                  DataBuffer.TYPE_INT,
                                  true);

          case BufferedImage.TYPE_INT_BGR:
              return createPacked(sRGB,
                                  0x000000ff,
                                  0x0000ff00,
                                  0x00ff0000,
                                  0x0,
                                  DataBuffer.TYPE_INT,
                                  false);

          case BufferedImage.TYPE_3BYTE_BGR:
              return createInterleaved(sRGB,
                                       new int[] { 2, 1, 0 },
                                       DataBuffer.TYPE_BYTE,
                                       false,
                                       false);

          case BufferedImage.TYPE_4BYTE_ABGR:
              return createInterleaved(sRGB,
                                       new int[] { 3, 2, 1, 0 },
                                       DataBuffer.TYPE_BYTE,
                                       true,
                                       false);

          case BufferedImage.TYPE_4BYTE_ABGR_PRE:
              return createInterleaved(sRGB,
                                       new int[] { 3, 2, 1, 0 },
                                       DataBuffer.TYPE_BYTE,
                                       true,
                                       true);

          case BufferedImage.TYPE_USHORT_565_RGB:
              return createPacked(sRGB,
                                  0xF800,
                                  0x07E0,
                                  0x001F,
                                  0x0,
                                  DataBuffer.TYPE_USHORT,
                                  false);

          case BufferedImage.TYPE_USHORT_555_RGB:
              return createPacked(sRGB,
                                  0x7C00,
                                  0x03E0,
                                  0x001F,
                                  0x0,
                                  DataBuffer.TYPE_USHORT,
                                  false);

          case BufferedImage.TYPE_BYTE_GRAY:
            return createGrayscale(8,
                                   DataBuffer.TYPE_BYTE,
                                   false);

          case BufferedImage.TYPE_USHORT_GRAY:
            return createGrayscale(16,
                                   DataBuffer.TYPE_USHORT,
                                   false);

          case BufferedImage.TYPE_BYTE_BINARY:
              return createGrayscale(1,
                                     DataBuffer.TYPE_BYTE,
                                     false);

          case BufferedImage.TYPE_BYTE_INDEXED:
          {

              BufferedImage bi =
                  new BufferedImage(1, 1, BufferedImage.TYPE_BYTE_INDEXED);
              IndexColorModel icm = (IndexColorModel)bi.getColorModel();
              int mapSize = icm.getMapSize();
              byte[] redLUT = new byte[mapSize];
              byte[] greenLUT = new byte[mapSize];
              byte[] blueLUT = new byte[mapSize];
              byte[] alphaLUT = new byte[mapSize];

              icm.getReds(redLUT);
              icm.getGreens(greenLUT);
              icm.getBlues(blueLUT);
              icm.getAlphas(alphaLUT);

              return createIndexed(redLUT, greenLUT, blueLUT, alphaLUT,
                                   8,
                                   DataBuffer.TYPE_BYTE);
          }
          default:
              throw new IllegalArgumentException(&quot;Invalid BufferedImage type!&quot;);
        }
    }

}
</pre>
</body>
</html>
