<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.imageio;

import java.awt.Dimension;
import java.util.Locale;

/**
 * A class describing how a stream is to be encoded.  Instances of
 * this class or its subclasses are used to supply prescriptive
 * &quot;how-to&quot; information to instances of &lt;code&gt;ImageWriter&lt;/code&gt;.
 *
 * &lt;p&gt; A plug-in for a specific image format may define a subclass of
 * this class, and return objects of that class from the
 * &lt;code&gt;getDefaultWriteParam&lt;/code&gt; method of its
 * &lt;code&gt;ImageWriter&lt;/code&gt; implementation.  For example, the built-in
 * JPEG writer plug-in will return instances of
 * &lt;code&gt;javax.imageio.plugins.jpeg.JPEGImageWriteParam&lt;/code&gt;.
 *
 * &lt;p&gt; The region of the image to be written is determined by first
 * intersecting the actual bounds of the image with the rectangle
 * specified by &lt;code&gt;IIOParam.setSourceRegion&lt;/code&gt;, if any.  If the
 * resulting rectangle has a width or height of zero, the writer will
 * throw an &lt;code&gt;IIOException&lt;/code&gt;. If the intersection is
 * non-empty, writing will commence with the first subsampled pixel
 * and include additional pixels within the intersected bounds
 * according to the horizontal and vertical subsampling factors
 * specified by {@link IIOParam#setSourceSubsampling
 * IIOParam.setSourceSubsampling}.
 *
 * &lt;p&gt; Individual features such as tiling, progressive encoding, and
 * compression may be set in one of four modes.
 * &lt;code&gt;MODE_DISABLED&lt;/code&gt; disables the features;
 * &lt;code&gt;MODE_DEFAULT&lt;/code&gt; enables the feature with
 * writer-controlled parameter values; &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;
 * enables the feature and allows the use of a &lt;code&gt;set&lt;/code&gt; method
 * to provide additional parameters; and
 * &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; copies relevant parameter
 * values from the stream and image metadata objects passed to the
 * writer.  The default for all features is
 * &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.  Non-standard features
 * supplied in subclasses are encouraged, but not required to use a
 * similar scheme.
 *
 * &lt;p&gt; Plug-in writers may extend the functionality of
 * &lt;code&gt;ImageWriteParam&lt;/code&gt; by providing a subclass that implements
 * additional, plug-in specific interfaces.  It is up to the plug-in
 * to document what interfaces are available and how they are to be
 * used.  Writers will silently ignore any extended features of an
 * &lt;code&gt;ImageWriteParam&lt;/code&gt; subclass of which they are not aware.
 * Also, they may ignore any optional features that they normally
 * disable when creating their own &lt;code&gt;ImageWriteParam&lt;/code&gt;
 * instances via &lt;code&gt;getDefaultWriteParam&lt;/code&gt;.
 *
 * &lt;p&gt; Note that unless a query method exists for a capability, it must
 * be supported by all &lt;code&gt;ImageWriter&lt;/code&gt; implementations
 * (&lt;i&gt;e.g.&lt;/i&gt; progressive encoding is optional, but subsampling must be
 * supported).
 *
 *
 * @see ImageReadParam
 */
public class ImageWriteParam extends IIOParam {

    /**
     * A constant value that may be passed into methods such as
     * &lt;code&gt;setTilingMode&lt;/code&gt;, &lt;code&gt;setProgressiveMode&lt;/code&gt;,
     * and &lt;code&gt;setCompressionMode&lt;/code&gt; to disable a feature for
     * future writes.  That is, when this mode is set the stream will
     * &lt;b&gt;not&lt;/b&gt; be tiled, progressive, or compressed, and the
     * relevant accessor methods will throw an
     * &lt;code&gt;IllegalStateException&lt;/code&gt;.
     *
     * @see #MODE_EXPLICIT
     * @see #MODE_COPY_FROM_METADATA
     * @see #MODE_DEFAULT
     * @see #setProgressiveMode
     * @see #getProgressiveMode
     * @see #setTilingMode
     * @see #getTilingMode
     * @see #setCompressionMode
     * @see #getCompressionMode
     */
    public static final int MODE_DISABLED = 0;

    /**
     * A constant value that may be passed into methods such as
     * &lt;code&gt;setTilingMode&lt;/code&gt;,
     * &lt;code&gt;setProgressiveMode&lt;/code&gt;, and
     * &lt;code&gt;setCompressionMode&lt;/code&gt; to enable that feature for
     * future writes.  That is, when this mode is enabled the stream
     * will be tiled, progressive, or compressed according to a
     * sensible default chosen internally by the writer in a plug-in
     * dependent way, and the relevant accessor methods will
     * throw an &lt;code&gt;IllegalStateException&lt;/code&gt;.
     *
     * @see #MODE_DISABLED
     * @see #MODE_EXPLICIT
     * @see #MODE_COPY_FROM_METADATA
     * @see #setProgressiveMode
     * @see #getProgressiveMode
     * @see #setTilingMode
     * @see #getTilingMode
     * @see #setCompressionMode
     * @see #getCompressionMode
     */
    public static final int MODE_DEFAULT = 1;

    /**
     * A constant value that may be passed into methods such as
     * &lt;code&gt;setTilingMode&lt;/code&gt; or &lt;code&gt;setCompressionMode&lt;/code&gt;
     * to enable a feature for future writes. That is, when this mode
     * is set the stream will be tiled or compressed according to
     * additional information supplied to the corresponding
     * &lt;code&gt;set&lt;/code&gt; methods in this class and retrievable from the
     * corresponding &lt;code&gt;get&lt;/code&gt; methods.  Note that this mode is
     * not supported for progressive output.
     *
     * @see #MODE_DISABLED
     * @see #MODE_COPY_FROM_METADATA
     * @see #MODE_DEFAULT
     * @see #setProgressiveMode
     * @see #getProgressiveMode
     * @see #setTilingMode
     * @see #getTilingMode
     * @see #setCompressionMode
     * @see #getCompressionMode
     */
    public static final int MODE_EXPLICIT = 2;

    /**
     * A constant value that may be passed into methods such as
     * &lt;code&gt;setTilingMode&lt;/code&gt;, &lt;code&gt;setProgressiveMode&lt;/code&gt;, or
     * &lt;code&gt;setCompressionMode&lt;/code&gt; to enable that feature for
     * future writes.  That is, when this mode is enabled the stream
     * will be tiled, progressive, or compressed based on the contents
     * of stream and/or image metadata passed into the write
     * operation, and any relevant accessor methods will throw an
     * &lt;code&gt;IllegalStateException&lt;/code&gt;.
     *
     * &lt;p&gt; This is the default mode for all features, so that a read
     * including metadata followed by a write including metadata will
     * preserve as much information as possible.
     *
     * @see #MODE_DISABLED
     * @see #MODE_EXPLICIT
     * @see #MODE_DEFAULT
     * @see #setProgressiveMode
     * @see #getProgressiveMode
     * @see #setTilingMode
     * @see #getTilingMode
     * @see #setCompressionMode
     * @see #getCompressionMode
     */
    public static final int MODE_COPY_FROM_METADATA = 3;

    // If more modes are added, this should be updated.
    private static final int MAX_MODE = MODE_COPY_FROM_METADATA;

    /**
     * A &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if this
     * &lt;code&gt;ImageWriteParam&lt;/code&gt; allows tile width and tile height
     * parameters to be set.  By default, the value is
     * &lt;code&gt;false&lt;/code&gt;.  Subclasses must set the value manually.
     *
     * &lt;p&gt; Subclasses that do not support writing tiles should ensure
     * that this value is set to &lt;code&gt;false&lt;/code&gt;.
     */
    protected boolean canWriteTiles = false;

    /**
     * The mode controlling tiling settings, which Must be
     * set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values.  The default
     * is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.
     *
     * &lt;p&gt; Subclasses that do not writing tiles may ignore this value.
     *
     * @see #MODE_DISABLED
     * @see #MODE_EXPLICIT
     * @see #MODE_COPY_FROM_METADATA
     * @see #MODE_DEFAULT
     * @see #setTilingMode
     * @see #getTilingMode
     */
    protected int tilingMode = MODE_COPY_FROM_METADATA;

    /**
     * An array of preferred tile size range pairs.  The default value
     * is &lt;code&gt;null&lt;/code&gt;, which indicates that there are no
     * preferred sizes.  If the value is non-&lt;code&gt;null&lt;/code&gt;, it
     * must have an even length of at least two.
     *
     * &lt;p&gt; Subclasses that do not support writing tiles may ignore
     * this value.
     *
     * @see #getPreferredTileSizes
     */
    protected Dimension[] preferredTileSizes = null;

    /**
     * A &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if tiling
     * parameters have been specified.
     *
     * &lt;p&gt; Subclasses that do not support writing tiles may ignore
     * this value.
     */
    protected boolean tilingSet = false;

    /**
     * The width of each tile if tiling has been set, or 0 otherwise.
     *
     * &lt;p&gt; Subclasses that do not support tiling may ignore this
     * value.
     */
    protected int tileWidth = 0;

    /**
     * The height of each tile if tiling has been set, or 0 otherwise.
     * The initial value is &lt;code&gt;0&lt;/code&gt;.
     *
     * &lt;p&gt; Subclasses that do not support tiling may ignore this
     * value.
     */
    protected int tileHeight = 0;

    /**
     * A &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if this
     * &lt;code&gt;ImageWriteParam&lt;/code&gt; allows tiling grid offset
     * parameters to be set.  By default, the value is
     * &lt;code&gt;false&lt;/code&gt;.  Subclasses must set the value manually.
     *
     * &lt;p&gt; Subclasses that do not support writing tiles, or that
     * support writing but not offsetting tiles must ensure that this
     * value is set to &lt;code&gt;false&lt;/code&gt;.
     */
    protected boolean canOffsetTiles = false;

    /**
     * The amount by which the tile grid origin should be offset
     * horizontally from the image origin if tiling has been set,
     * or 0 otherwise.  The initial value is &lt;code&gt;0&lt;/code&gt;.
     *
     * &lt;p&gt; Subclasses that do not support offsetting tiles may ignore
     * this value.
     */
    protected int tileGridXOffset = 0;

    /**
     * The amount by which the tile grid origin should be offset
     * vertically from the image origin if tiling has been set,
     * or 0 otherwise.  The initial value is &lt;code&gt;0&lt;/code&gt;.
     *
     * &lt;p&gt; Subclasses that do not support offsetting tiles may ignore
     * this value.
     */
    protected int tileGridYOffset = 0;

    /**
     * A &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if this
     * &lt;code&gt;ImageWriteParam&lt;/code&gt; allows images to be written as a
     * progressive sequence of increasing quality passes.  By default,
     * the value is &lt;code&gt;false&lt;/code&gt;.  Subclasses must set the value
     * manually.
     *
     * &lt;p&gt; Subclasses that do not support progressive encoding must
     * ensure that this value is set to &lt;code&gt;false&lt;/code&gt;.
     */
    protected boolean canWriteProgressive = false;

    /**
     * The mode controlling progressive encoding, which must be set to
     * one of the four &lt;code&gt;MODE_*&lt;/code&gt; values, except
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  The default is
     * &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.
     *
     * &lt;p&gt; Subclasses that do not support progressive encoding may
     * ignore this value.
     *
     * @see #MODE_DISABLED
     * @see #MODE_EXPLICIT
     * @see #MODE_COPY_FROM_METADATA
     * @see #MODE_DEFAULT
     * @see #setProgressiveMode
     * @see #getProgressiveMode
     */
    protected int progressiveMode = MODE_COPY_FROM_METADATA;

    /**
     * A &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if this writer
     * can write images using compression. By default, the value is
     * &lt;code&gt;false&lt;/code&gt;.  Subclasses must set the value manually.
     *
     * &lt;p&gt; Subclasses that do not support compression must ensure that
     * this value is set to &lt;code&gt;false&lt;/code&gt;.
     */
    protected boolean canWriteCompressed = false;

    /**
     * The mode controlling compression settings, which must be set to
     * one of the four &lt;code&gt;MODE_*&lt;/code&gt; values.  The default is
     * &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.
     *
     * &lt;p&gt; Subclasses that do not support compression may ignore this
     * value.
     *
     * @see #MODE_DISABLED
     * @see #MODE_EXPLICIT
     * @see #MODE_COPY_FROM_METADATA
     * @see #MODE_DEFAULT
     * @see #setCompressionMode
     * @see #getCompressionMode
     */
    protected int compressionMode = MODE_COPY_FROM_METADATA;

    /**
     * An array of &lt;code&gt;String&lt;/code&gt;s containing the names of the
     * available compression types.  Subclasses must set the value
     * manually.
     *
     * &lt;p&gt; Subclasses that do not support compression may ignore this
     * value.
     */
    protected String[] compressionTypes = null;

    /**
     * A &lt;code&gt;String&lt;/code&gt; containing the name of the current
     * compression type, or &lt;code&gt;null&lt;/code&gt; if none is set.
     *
     * &lt;p&gt; Subclasses that do not support compression may ignore this
     * value.
     */
    protected String compressionType = null;

    /**
     * A &lt;code&gt;float&lt;/code&gt; containing the current compression quality
     * setting.  The initial value is &lt;code&gt;1.0F&lt;/code&gt;.
     *
     * &lt;p&gt; Subclasses that do not support compression may ignore this
     * value.
     */
    protected float compressionQuality = 1.0F;

    /**
     * A &lt;code&gt;Locale&lt;/code&gt; to be used to localize compression type
     * names and quality descriptions, or &lt;code&gt;null&lt;/code&gt; to use a
     * default &lt;code&gt;Locale&lt;/code&gt;.  Subclasses must set the value
     * manually.
     */
    protected Locale locale = null;

    /**
     * Constructs an empty &lt;code&gt;ImageWriteParam&lt;/code&gt;.  It is up to
     * the subclass to set up the instance variables properly.
     */
    protected ImageWriteParam() {}

    /**
     * Constructs an &lt;code&gt;ImageWriteParam&lt;/code&gt; set to use a
     * given &lt;code&gt;Locale&lt;/code&gt;.
     *
     * @param locale a &lt;code&gt;Locale&lt;/code&gt; to be used to localize
     * compression type names and quality descriptions, or
     * &lt;code&gt;null&lt;/code&gt;.
     */
    public ImageWriteParam(Locale locale) {
        this.locale = locale;
    }

    // Return a deep copy of the array
    private static Dimension[] clonePreferredTileSizes(Dimension[] sizes) {
        if (sizes == null) {
            return null;
        }
        Dimension[] temp = new Dimension[sizes.length];
        for (int i = 0; i &lt; sizes.length; i++) {
            temp[i] = new Dimension(sizes[i]);
        }
        return temp;
    }

    /**
     * Returns the currently set &lt;code&gt;Locale&lt;/code&gt;, or
     * &lt;code&gt;null&lt;/code&gt; if only a default &lt;code&gt;Locale&lt;/code&gt; is
     * supported.
     *
     * @return the current &lt;code&gt;Locale&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;.
     */
    public Locale getLocale() {
        return locale;
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the writer can perform tiling
     * while writing.  If this method returns &lt;code&gt;false&lt;/code&gt;, then
     * &lt;code&gt;setTiling&lt;/code&gt; will throw an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the writer supports tiling.
     *
     * @see #canOffsetTiles()
     * @see #setTiling(int, int, int, int)
     */
    public boolean canWriteTiles() {
        return canWriteTiles;
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the writer can perform tiling with
     * non-zero grid offsets while writing.  If this method returns
     * &lt;code&gt;false&lt;/code&gt;, then &lt;code&gt;setTiling&lt;/code&gt; will throw an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if the grid offset
     * arguments are not both zero.  If &lt;code&gt;canWriteTiles&lt;/code&gt;
     * returns &lt;code&gt;false&lt;/code&gt;, this method will return
     * &lt;code&gt;false&lt;/code&gt; as well.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the writer supports non-zero tile
     * offsets.
     *
     * @see #canWriteTiles()
     * @see #setTiling(int, int, int, int)
     */
    public boolean canOffsetTiles() {
        return canOffsetTiles;
    }

    /**
     * Determines whether the image will be tiled in the output
     * stream and, if it will, how the tiling parameters will be
     * determined.  The modes are interpreted as follows:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;&lt;code&gt;MODE_DISABLED&lt;/code&gt; - The image will not be tiled.
     * &lt;code&gt;setTiling&lt;/code&gt; will throw an
     * &lt;code&gt;IllegalStateException&lt;/code&gt;.
     *
     * &lt;li&gt;&lt;code&gt;MODE_DEFAULT&lt;/code&gt; - The image will be tiled using
     * default parameters.  &lt;code&gt;setTiling&lt;/code&gt; will throw an
     * &lt;code&gt;IllegalStateException&lt;/code&gt;.
     *
     * &lt;li&gt;&lt;code&gt;MODE_EXPLICIT&lt;/code&gt; - The image will be tiled
     * according to parameters given in the {@link #setTiling setTiling}
     * method.  Any previously set tiling parameters are discarded.
     *
     * &lt;li&gt;&lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; - The image will
     * conform to the metadata object passed in to a write.
     * &lt;code&gt;setTiling&lt;/code&gt; will throw an
     * &lt;code&gt;IllegalStateException&lt;/code&gt;.
     *
     * &lt;/ul&gt;
     *
     * @param mode The mode to use for tiling.
     *
     * @exception UnsupportedOperationException if
     * &lt;code&gt;canWriteTiles&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;mode&lt;/code&gt; is not
     * one of the modes listed above.
     *
     * @see #setTiling
     * @see #getTilingMode
     */
    public void setTilingMode(int mode) {
        if (canWriteTiles() == false) {
            throw new UnsupportedOperationException(&quot;Tiling not supported!&quot;);
        }
        if (mode &lt; MODE_DISABLED || mode &gt; MAX_MODE) {
            throw new IllegalArgumentException(&quot;Illegal value for mode!&quot;);
        }
        this.tilingMode = mode;
        if (mode == MODE_EXPLICIT) {
            unsetTiling();
        }
    }

    /**
     * Returns the current tiling mode, if tiling is supported.
     * Otherwise throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     *
     * @return the current tiling mode.
     *
     * @exception UnsupportedOperationException if
     * &lt;code&gt;canWriteTiles&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.
     *
     * @see #setTilingMode
     */
    public int getTilingMode() {
        if (!canWriteTiles()) {
            throw new UnsupportedOperationException(&quot;Tiling not supported&quot;);
        }
        return tilingMode;
    }

    /**
     * Returns an array of &lt;code&gt;Dimension&lt;/code&gt;s indicating the
     * legal size ranges for tiles as they will be encoded in the
     * output file or stream.  The returned array is a copy.
     *
     * &lt;p&gt; The information is returned as a set of pairs; the first
     * element of a pair contains an (inclusive) minimum width and
     * height, and the second element contains an (inclusive) maximum
     * width and height.  Together, each pair defines a valid range of
     * sizes.  To specify a fixed size, use the same width and height
     * for both elements.  To specify an arbitrary range, a value of
     * &lt;code&gt;null&lt;/code&gt; is used in place of an actual array of
     * &lt;code&gt;Dimension&lt;/code&gt;s.
     *
     * &lt;p&gt; If no array is specified on the constructor, but tiling is
     * allowed, then this method returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if the plug-in does
     * not support tiling.
     *
     * @return an array of &lt;code&gt;Dimension&lt;/code&gt;s with an even length
     * of at least two, or &lt;code&gt;null&lt;/code&gt;.
     */
    public Dimension[] getPreferredTileSizes() {
        if (!canWriteTiles()) {
            throw new UnsupportedOperationException(&quot;Tiling not supported&quot;);
        }
        return clonePreferredTileSizes(preferredTileSizes);
    }

    /**
     * Specifies that the image should be tiled in the output stream.
     * The &lt;code&gt;tileWidth&lt;/code&gt; and &lt;code&gt;tileHeight&lt;/code&gt;
     * parameters specify the width and height of the tiles in the
     * file.  If the tile width or height is greater than the width or
     * height of the image, the image is not tiled in that dimension.
     *
     * &lt;p&gt; If &lt;code&gt;canOffsetTiles&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;,
     * then the &lt;code&gt;tileGridXOffset&lt;/code&gt; and
     * &lt;code&gt;tileGridYOffset&lt;/code&gt; parameters must be zero.
     *
     * @param tileWidth the width of each tile.
     * @param tileHeight the height of each tile.
     * @param tileGridXOffset the horizontal offset of the tile grid.
     * @param tileGridYOffset the vertical offset of the tile grid.
     *
     * @exception UnsupportedOperationException if the plug-in does not
     * support tiling.
     * @exception IllegalStateException if the tiling mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception UnsupportedOperationException if the plug-in does not
     * support grid offsets, and the grid offsets are not both zero.
     * @exception IllegalArgumentException if the tile size is not
     * within one of the allowable ranges returned by
     * &lt;code&gt;getPreferredTileSizes&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;tileWidth&lt;/code&gt;
     * or &lt;code&gt;tileHeight&lt;/code&gt; is less than or equal to 0.
     *
     * @see #canWriteTiles
     * @see #canOffsetTiles
     * @see #getTileWidth()
     * @see #getTileHeight()
     * @see #getTileGridXOffset()
     * @see #getTileGridYOffset()
     */
    public void setTiling(int tileWidth,
                          int tileHeight,
                          int tileGridXOffset,
                          int tileGridYOffset) {
        if (!canWriteTiles()) {
            throw new UnsupportedOperationException(&quot;Tiling not supported!&quot;);
        }
        if (getTilingMode() != MODE_EXPLICIT) {
            throw new IllegalStateException(&quot;Tiling mode not MODE_EXPLICIT!&quot;);
        }
        if (tileWidth &lt;= 0 || tileHeight &lt;= 0) {
            throw new IllegalArgumentException
                (&quot;tile dimensions are non-positive!&quot;);
        }
        boolean tilesOffset = (tileGridXOffset != 0) || (tileGridYOffset != 0);
        if (!canOffsetTiles() &amp;&amp; tilesOffset) {
            throw new UnsupportedOperationException(&quot;Can't offset tiles!&quot;);
        }
        if (preferredTileSizes != null) {
            boolean ok = true;
            for (int i = 0; i &lt; preferredTileSizes.length; i += 2) {
                Dimension min = preferredTileSizes[i];
                Dimension max = preferredTileSizes[i+1];
                if ((tileWidth &lt; min.width) ||
                    (tileWidth &gt; max.width) ||
                    (tileHeight &lt; min.height) ||
                    (tileHeight &gt; max.height)) {
                    ok = false;
                    break;
                }
            }
            if (!ok) {
                throw new IllegalArgumentException(&quot;Illegal tile size!&quot;);
            }
        }

        this.tilingSet = true;
        this.tileWidth = tileWidth;
        this.tileHeight = tileHeight;
        this.tileGridXOffset = tileGridXOffset;
        this.tileGridYOffset = tileGridYOffset;
    }

    /**
     * Removes any previous tile grid parameters specified by calls to
     * &lt;code&gt;setTiling&lt;/code&gt;.
     *
     * &lt;p&gt; The default implementation sets the instance variables
     * &lt;code&gt;tileWidth&lt;/code&gt;, &lt;code&gt;tileHeight&lt;/code&gt;,
     * &lt;code&gt;tileGridXOffset&lt;/code&gt;, and
     * &lt;code&gt;tileGridYOffset&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if the plug-in does not
     * support tiling.
     * @exception IllegalStateException if the tiling mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     *
     * @see #setTiling(int, int, int, int)
     */
    public void unsetTiling() {
        if (!canWriteTiles()) {
            throw new UnsupportedOperationException(&quot;Tiling not supported!&quot;);
        }
        if (getTilingMode() != MODE_EXPLICIT) {
            throw new IllegalStateException(&quot;Tiling mode not MODE_EXPLICIT!&quot;);
        }
        this.tilingSet = false;
        this.tileWidth = 0;
        this.tileHeight = 0;
        this.tileGridXOffset = 0;
        this.tileGridYOffset = 0;
    }

    /**
     * Returns the width of each tile in an image as it will be
     * written to the output stream.  If tiling parameters have not
     * been set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * @return the tile width to be used for encoding.
     *
     * @exception UnsupportedOperationException if the plug-in does not
     * support tiling.
     * @exception IllegalStateException if the tiling mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the tiling parameters have
     * not been set.
     *
     * @see #setTiling(int, int, int, int)
     * @see #getTileHeight()
     */
    public int getTileWidth() {
        if (!canWriteTiles()) {
            throw new UnsupportedOperationException(&quot;Tiling not supported!&quot;);
        }
        if (getTilingMode() != MODE_EXPLICIT) {
            throw new IllegalStateException(&quot;Tiling mode not MODE_EXPLICIT!&quot;);
        }
        if (!tilingSet) {
            throw new IllegalStateException(&quot;Tiling parameters not set!&quot;);
        }
        return tileWidth;
    }

    /**
     * Returns the height of each tile in an image as it will be written to
     * the output stream.  If tiling parameters have not
     * been set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * @return the tile height to be used for encoding.
     *
     * @exception UnsupportedOperationException if the plug-in does not
     * support tiling.
     * @exception IllegalStateException if the tiling mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the tiling parameters have
     * not been set.
     *
     * @see #setTiling(int, int, int, int)
     * @see #getTileWidth()
     */
    public int getTileHeight() {
        if (!canWriteTiles()) {
            throw new UnsupportedOperationException(&quot;Tiling not supported!&quot;);
        }
        if (getTilingMode() != MODE_EXPLICIT) {
            throw new IllegalStateException(&quot;Tiling mode not MODE_EXPLICIT!&quot;);
        }
        if (!tilingSet) {
            throw new IllegalStateException(&quot;Tiling parameters not set!&quot;);
        }
        return tileHeight;
    }

    /**
     * Returns the horizontal tile grid offset of an image as it will
     * be written to the output stream.  If tiling parameters have not
     * been set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * @return the tile grid X offset to be used for encoding.
     *
     * @exception UnsupportedOperationException if the plug-in does not
     * support tiling.
     * @exception IllegalStateException if the tiling mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the tiling parameters have
     * not been set.
     *
     * @see #setTiling(int, int, int, int)
     * @see #getTileGridYOffset()
     */
    public int getTileGridXOffset() {
        if (!canWriteTiles()) {
            throw new UnsupportedOperationException(&quot;Tiling not supported!&quot;);
        }
        if (getTilingMode() != MODE_EXPLICIT) {
            throw new IllegalStateException(&quot;Tiling mode not MODE_EXPLICIT!&quot;);
        }
        if (!tilingSet) {
            throw new IllegalStateException(&quot;Tiling parameters not set!&quot;);
        }
        return tileGridXOffset;
    }

    /**
     * Returns the vertical tile grid offset of an image as it will
     * be written to the output stream.  If tiling parameters have not
     * been set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * @return the tile grid Y offset to be used for encoding.
     *
     * @exception UnsupportedOperationException if the plug-in does not
     * support tiling.
     * @exception IllegalStateException if the tiling mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the tiling parameters have
     * not been set.
     *
     * @see #setTiling(int, int, int, int)
     * @see #getTileGridXOffset()
     */
    public int getTileGridYOffset() {
        if (!canWriteTiles()) {
            throw new UnsupportedOperationException(&quot;Tiling not supported!&quot;);
        }
        if (getTilingMode() != MODE_EXPLICIT) {
            throw new IllegalStateException(&quot;Tiling mode not MODE_EXPLICIT!&quot;);
        }
        if (!tilingSet) {
            throw new IllegalStateException(&quot;Tiling parameters not set!&quot;);
        }
        return tileGridYOffset;
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the writer can write out images
     * as a series of passes of progressively increasing quality.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the writer supports progressive
     * encoding.
     *
     * @see #setProgressiveMode
     * @see #getProgressiveMode
     */
    public boolean canWriteProgressive() {
        return canWriteProgressive;
    }

    /**
     * Specifies that the writer is to write the image out in a
     * progressive mode such that the stream will contain a series of
     * scans of increasing quality.  If progressive encoding is not
     * supported, an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will
     * be thrown.
     *
     * &lt;p&gt;  The mode argument determines how
     * the progression parameters are chosen, and must be either
     * &lt;code&gt;MODE_DISABLED&lt;/code&gt;,
     * &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;, or
     * &lt;code&gt;MODE_DEFAULT&lt;/code&gt;.  Otherwise an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; The modes are interpreted as follows:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;&lt;code&gt;MODE_DISABLED&lt;/code&gt; - No progression.  Use this to
     *   turn off progression.
     *
     *   &lt;li&gt;&lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; - The output image
     *   will use whatever progression parameters are found in the
     *   metadata objects passed into the writer.
     *
     *   &lt;li&gt;&lt;code&gt;MODE_DEFAULT&lt;/code&gt; - The image will be written
     *   progressively, with parameters chosen by the writer.
     * &lt;/ul&gt;
     *
     * &lt;p&gt; The default is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.
     *
     * @param mode The mode for setting progression in the output
     * stream.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support progressive encoding.
     * @exception IllegalArgumentException if &lt;code&gt;mode&lt;/code&gt; is not
     * one of the modes listed above.
     *
     * @see #getProgressiveMode
     */
    public void setProgressiveMode(int mode) {
        if (!canWriteProgressive()) {
            throw new UnsupportedOperationException(
                &quot;Progressive output not supported&quot;);
        }
        if (mode &lt; MODE_DISABLED || mode &gt; MAX_MODE) {
            throw new IllegalArgumentException(&quot;Illegal value for mode!&quot;);
        }
        if (mode == MODE_EXPLICIT) {
            throw new IllegalArgumentException(
                &quot;MODE_EXPLICIT not supported for progressive output&quot;);
        }
        this.progressiveMode = mode;
    }

    /**
     * Returns the current mode for writing the stream in a
     * progressive manner.
     *
     * @return the current mode for progressive encoding.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support progressive encoding.
     *
     * @see #setProgressiveMode
     */
    public int getProgressiveMode() {
        if (!canWriteProgressive()) {
            throw new UnsupportedOperationException
                (&quot;Progressive output not supported&quot;);
        }
        return progressiveMode;
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this writer supports compression.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the writer supports compression.
     */
    public boolean canWriteCompressed() {
        return canWriteCompressed;
    }

    /**
     * Specifies whether compression is to be performed, and if so how
     * compression parameters are to be determined.  The &lt;code&gt;mode&lt;/code&gt;
     * argument must be one of the four modes, interpreted as follows:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;&lt;code&gt;MODE_DISABLED&lt;/code&gt; - If the mode is set to
     *   &lt;code&gt;MODE_DISABLED&lt;/code&gt;, methods that query or modify the
     *   compression type or parameters will throw an
     *   &lt;code&gt;IllegalStateException&lt;/code&gt; (if compression is
     *   normally supported by the plug-in). Some writers, such as JPEG,
     *   do not normally offer uncompressed output. In this case, attempting
     *   to set the mode to &lt;code&gt;MODE_DISABLED&lt;/code&gt; will throw an
     *   &lt;code&gt;UnsupportedOperationException&lt;/code&gt; and the mode will not be
     *   changed.
     *
     *   &lt;li&gt;&lt;code&gt;MODE_EXPLICIT&lt;/code&gt; - Compress using the
     *   compression type and quality settings specified in this
     *   &lt;code&gt;ImageWriteParam&lt;/code&gt;.  Any previously set compression
     *   parameters are discarded.
     *
     *   &lt;li&gt;&lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; - Use whatever
     *   compression parameters are specified in metadata objects
     *   passed in to the writer.
     *
     *   &lt;li&gt;&lt;code&gt;MODE_DEFAULT&lt;/code&gt; - Use default compression
     *   parameters.
     * &lt;/ul&gt;
     *
     * &lt;p&gt; The default is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.
     *
     * @param mode The mode for setting compression in the output
     * stream.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression, or does not support the requested mode.
     * @exception IllegalArgumentException if &lt;code&gt;mode&lt;/code&gt; is not
     * one of the modes listed above.
     *
     * @see #getCompressionMode
     */
    public void setCompressionMode(int mode) {
        if (!canWriteCompressed()) {
            throw new UnsupportedOperationException(
                &quot;Compression not supported.&quot;);
        }
        if (mode &lt; MODE_DISABLED || mode &gt; MAX_MODE) {
            throw new IllegalArgumentException(&quot;Illegal value for mode!&quot;);
        }
        this.compressionMode = mode;
        if (mode == MODE_EXPLICIT) {
            unsetCompression();
        }
    }

    /**
     * Returns the current compression mode, if compression is
     * supported.
     *
     * @return the current compression mode.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     *
     * @see #setCompressionMode
     */
    public int getCompressionMode() {
        if (!canWriteCompressed()) {
            throw new UnsupportedOperationException(
                &quot;Compression not supported.&quot;);
        }
        return compressionMode;
    }

    /**
     * Returns a list of available compression types, as an array or
     * &lt;code&gt;String&lt;/code&gt;s, or &lt;code&gt;null&lt;/code&gt; if a compression
     * type may not be chosen using these interfaces.  The array
     * returned is a copy.
     *
     * &lt;p&gt; If the writer only offers a single, mandatory form of
     * compression, it is not necessary to provide any named
     * compression types.  Named compression types should only be
     * used where the user is able to make a meaningful choice
     * between different schemes.
     *
     * &lt;p&gt; The default implementation checks if compression is
     * supported and throws an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if not.  Otherwise,
     * it returns a clone of the &lt;code&gt;compressionTypes&lt;/code&gt;
     * instance variable if it is non-&lt;code&gt;null&lt;/code&gt;, or else
     * returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @return an array of &lt;code&gt;String&lt;/code&gt;s containing the
     * (non-localized) names of available compression types, or
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     */
    public String[] getCompressionTypes() {
        if (!canWriteCompressed()) {
            throw new UnsupportedOperationException(
                &quot;Compression not supported&quot;);
        }
        if (compressionTypes == null) {
            return null;
        }
        return (String[])compressionTypes.clone();
    }

    /**
     * Sets the compression type to one of the values indicated by
     * &lt;code&gt;getCompressionTypes&lt;/code&gt;.  If a value of
     * &lt;code&gt;null&lt;/code&gt; is passed in, any previous setting is
     * removed.
     *
     * &lt;p&gt; The default implementation checks whether compression is
     * supported and the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, it calls
     * &lt;code&gt;getCompressionTypes&lt;/code&gt; and checks if
     * &lt;code&gt;compressionType&lt;/code&gt; is one of the legal values.  If it
     * is, the &lt;code&gt;compressionType&lt;/code&gt; instance variable is set.
     * If &lt;code&gt;compressionType&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the
     * instance variable is set without performing any checking.
     *
     * @param compressionType one of the &lt;code&gt;String&lt;/code&gt;s returned
     * by &lt;code&gt;getCompressionTypes&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; to
     * remove any previous setting.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception UnsupportedOperationException if there are no
     * settable compression types.
     * @exception IllegalArgumentException if
     * &lt;code&gt;compressionType&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt; but is not
     * one of the values returned by &lt;code&gt;getCompressionTypes&lt;/code&gt;.
     *
     * @see #getCompressionTypes
     * @see #getCompressionType
     * @see #unsetCompression
     */
    public void setCompressionType(String compressionType) {
        if (!canWriteCompressed()) {
            throw new UnsupportedOperationException(
                &quot;Compression not supported&quot;);
        }
        if (getCompressionMode() != MODE_EXPLICIT) {
            throw new IllegalStateException
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
        String[] legalTypes = getCompressionTypes();
        if (legalTypes == null) {
            throw new UnsupportedOperationException(
                &quot;No settable compression types&quot;);
        }
        if (compressionType != null) {
            boolean found = false;
            if (legalTypes != null) {
                for (int i = 0; i &lt; legalTypes.length; i++) {
                    if (compressionType.equals(legalTypes[i])) {
                        found = true;
                        break;
                    }
                }
            }
            if (!found) {
                throw new IllegalArgumentException(&quot;Unknown compression type!&quot;);
            }
        }
        this.compressionType = compressionType;
    }

    /**
     * Returns the currently set compression type, or
     * &lt;code&gt;null&lt;/code&gt; if none has been set.  The type is returned
     * as a &lt;code&gt;String&lt;/code&gt; from among those returned by
     * &lt;code&gt;getCompressionTypes&lt;/code&gt;.
     * If no compression type has been set, &lt;code&gt;null&lt;/code&gt; is
     * returned.
     *
     * &lt;p&gt; The default implementation checks whether compression is
     * supported and the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, it returns the value of the
     * &lt;code&gt;compressionType&lt;/code&gt; instance variable.
     *
     * @return the current compression type as a &lt;code&gt;String&lt;/code&gt;,
     * or &lt;code&gt;null&lt;/code&gt; if no type is set.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     *
     * @see #setCompressionType
     */
    public String getCompressionType() {
        if (!canWriteCompressed()) {
            throw new UnsupportedOperationException(
                &quot;Compression not supported.&quot;);
        }
        if (getCompressionMode() != MODE_EXPLICIT) {
            throw new IllegalStateException
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
        return compressionType;
    }

    /**
     * Removes any previous compression type and quality settings.
     *
     * &lt;p&gt; The default implementation sets the instance variable
     * &lt;code&gt;compressionType&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt;, and the
     * instance variable &lt;code&gt;compressionQuality&lt;/code&gt; to
     * &lt;code&gt;1.0F&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if the plug-in does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     *
     * @see #setCompressionType
     * @see #setCompressionQuality
     */
    public void unsetCompression() {
        if (!canWriteCompressed()) {
            throw new UnsupportedOperationException(
                &quot;Compression not supported&quot;);
        }
        if (getCompressionMode() != MODE_EXPLICIT) {
            throw new IllegalStateException
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
        this.compressionType = null;
        this.compressionQuality = 1.0F;
    }

    /**
     * Returns a localized version of the name of the current
     * compression type, using the &lt;code&gt;Locale&lt;/code&gt; returned by
     * &lt;code&gt;getLocale&lt;/code&gt;.
     *
     * &lt;p&gt; The default implementation checks whether compression is
     * supported and the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, if
     * &lt;code&gt;compressionType&lt;/code&gt; is &lt;code&gt;non-null&lt;/code&gt; the value
     * of &lt;code&gt;getCompressionType&lt;/code&gt; is returned as a
     * convenience.
     *
     * @return a &lt;code&gt;String&lt;/code&gt; containing a localized version of
     * the name of the current compression type.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if no compression type is set.
     */
    public String getLocalizedCompressionTypeName() {
        if (!canWriteCompressed()) {
            throw new UnsupportedOperationException(
                &quot;Compression not supported.&quot;);
        }
        if (getCompressionMode() != MODE_EXPLICIT) {
            throw new IllegalStateException
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
        if (getCompressionType() == null) {
            throw new IllegalStateException(&quot;No compression type set!&quot;);
        }
        return getCompressionType();
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the current compression type
     * provides lossless compression.  If a plug-in provides only
     * one mandatory compression type, then this method may be
     * called without calling &lt;code&gt;setCompressionType&lt;/code&gt; first.
     *
     * &lt;p&gt; If there are multiple compression types but none has
     * been set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; The default implementation checks whether compression is
     * supported and the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, if
     * &lt;code&gt;getCompressionTypes()&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or
     * &lt;code&gt;getCompressionType()&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;
     * &lt;code&gt;true&lt;/code&gt; is returned as a convenience.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the current compression type is
     * lossless.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the set of legal
     * compression types is non-&lt;code&gt;null&lt;/code&gt; and the current
     * compression type is &lt;code&gt;null&lt;/code&gt;.
     */
    public boolean isCompressionLossless() {
        if (!canWriteCompressed()) {
            throw new UnsupportedOperationException(
                &quot;Compression not supported&quot;);
        }
        if (getCompressionMode() != MODE_EXPLICIT) {
            throw new IllegalStateException
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
        if ((getCompressionTypes() != null) &amp;&amp;
            (getCompressionType() == null)) {
            throw new IllegalStateException(&quot;No compression type set!&quot;);
        }
        return true;
    }

    /**
     * Sets the compression quality to a value between &lt;code&gt;0&lt;/code&gt;
     * and &lt;code&gt;1&lt;/code&gt;.  Only a single compression quality setting
     * is supported by default; writers can provide extended versions
     * of &lt;code&gt;ImageWriteParam&lt;/code&gt; that offer more control.  For
     * lossy compression schemes, the compression quality should
     * control the tradeoff between file size and image quality (for
     * example, by choosing quantization tables when writing JPEG
     * images).  For lossless schemes, the compression quality may be
     * used to control the tradeoff between file size and time taken
     * to perform the compression (for example, by optimizing row
     * filters and setting the ZLIB compression level when writing
     * PNG images).
     *
     * &lt;p&gt; A compression quality setting of 0.0 is most generically
     * interpreted as &quot;high compression is important,&quot; while a setting of
     * 1.0 is most generically interpreted as &quot;high image quality is
     * important.&quot;
     *
     * &lt;p&gt; If there are multiple compression types but none has been
     * set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; The default implementation checks that compression is
     * supported, and that the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, if
     * &lt;code&gt;getCompressionTypes()&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt; or
     * &lt;code&gt;compressionType&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt; it sets
     * the &lt;code&gt;compressionQuality&lt;/code&gt; instance variable.
     *
     * @param quality a &lt;code&gt;float&lt;/code&gt; between &lt;code&gt;0&lt;/code&gt;and
     * &lt;code&gt;1&lt;/code&gt; indicating the desired quality level.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the set of legal
     * compression types is non-&lt;code&gt;null&lt;/code&gt; and the current
     * compression type is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;quality&lt;/code&gt; is
     * not between &lt;code&gt;0&lt;/code&gt;and &lt;code&gt;1&lt;/code&gt;, inclusive.
     *
     * @see #getCompressionQuality
     */
    public void setCompressionQuality(float quality) {
        if (!canWriteCompressed()) {
            throw new UnsupportedOperationException(
                &quot;Compression not supported&quot;);
        }
        if (getCompressionMode() != MODE_EXPLICIT) {
            throw new IllegalStateException
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
        if (getCompressionTypes() != null &amp;&amp; getCompressionType() == null) {
            throw new IllegalStateException(&quot;No compression type set!&quot;);
        }
        if (quality &lt; 0.0F || quality &gt; 1.0F) {
            throw new IllegalArgumentException(&quot;Quality out-of-bounds!&quot;);
        }
        this.compressionQuality = quality;
    }

    /**
     * Returns the current compression quality setting.
     *
     * &lt;p&gt; If there are multiple compression types but none has been
     * set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; The default implementation checks that compression is
     * supported and that the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, if
     * &lt;code&gt;getCompressionTypes()&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or
     * &lt;code&gt;getCompressionType()&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, it
     * returns the value of the &lt;code&gt;compressionQuality&lt;/code&gt;
     * instance variable.
     *
     * @return the current compression quality setting.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the set of legal
     * compression types is non-&lt;code&gt;null&lt;/code&gt; and the current
     * compression type is &lt;code&gt;null&lt;/code&gt;.
     *
     * @see #setCompressionQuality
     */
    public float getCompressionQuality() {
        if (!canWriteCompressed()) {
            throw new UnsupportedOperationException(
                &quot;Compression not supported.&quot;);
        }
        if (getCompressionMode() != MODE_EXPLICIT) {
            throw new IllegalStateException
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
        if ((getCompressionTypes() != null) &amp;&amp;
            (getCompressionType() == null)) {
            throw new IllegalStateException(&quot;No compression type set!&quot;);
        }
        return compressionQuality;
    }


    /**
     * Returns a &lt;code&gt;float&lt;/code&gt; indicating an estimate of the
     * number of bits of output data for each bit of input image data
     * at the given quality level.  The value will typically lie
     * between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;, with smaller values
     * indicating more compression.  A special value of
     * &lt;code&gt;-1.0F&lt;/code&gt; is used to indicate that no estimate is
     * available.
     *
     * &lt;p&gt; If there are multiple compression types but none has been set,
     * an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; The default implementation checks that compression is
     * supported and the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, if
     * &lt;code&gt;getCompressionTypes()&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or
     * &lt;code&gt;getCompressionType()&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, and
     * &lt;code&gt;quality&lt;/code&gt; is within bounds, it returns
     * &lt;code&gt;-1.0&lt;/code&gt;.
     *
     * @param quality the quality setting whose bit rate is to be
     * queried.
     *
     * @return an estimate of the compressed bit rate, or
     * &lt;code&gt;-1.0F&lt;/code&gt; if no estimate is available.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the set of legal
     * compression types is non-&lt;code&gt;null&lt;/code&gt; and the current
     * compression type is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;quality&lt;/code&gt; is
     * not between &lt;code&gt;0&lt;/code&gt;and &lt;code&gt;1&lt;/code&gt;, inclusive.
     */
    public float getBitRate(float quality) {
        if (!canWriteCompressed()) {
            throw new UnsupportedOperationException(
                &quot;Compression not supported.&quot;);
        }
        if (getCompressionMode() != MODE_EXPLICIT) {
            throw new IllegalStateException
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
        if ((getCompressionTypes() != null) &amp;&amp;
            (getCompressionType() == null)) {
            throw new IllegalStateException(&quot;No compression type set!&quot;);
        }
        if (quality &lt; 0.0F || quality &gt; 1.0F) {
            throw new IllegalArgumentException(&quot;Quality out-of-bounds!&quot;);
        }
        return -1.0F;
    }

    /**
     * Returns an array of &lt;code&gt;String&lt;/code&gt;s that may be used along
     * with &lt;code&gt;getCompressionQualityValues&lt;/code&gt; as part of a user
     * interface for setting or displaying the compression quality
     * level.  The &lt;code&gt;String&lt;/code&gt; with index &lt;code&gt;i&lt;/code&gt;
     * provides a description of the range of quality levels between
     * &lt;code&gt;getCompressionQualityValues[i]&lt;/code&gt; and
     * &lt;code&gt;getCompressionQualityValues[i + 1]&lt;/code&gt;.  Note that the
     * length of the array returned from
     * &lt;code&gt;getCompressionQualityValues&lt;/code&gt; will always be one
     * greater than that returned from
     * &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt;.
     *
     * &lt;p&gt; As an example, the strings &quot;Good&quot;, &quot;Better&quot;, and &quot;Best&quot;
     * could be associated with the ranges &lt;code&gt;[0, .33)&lt;/code&gt;,
     * &lt;code&gt;[.33, .66)&lt;/code&gt;, and &lt;code&gt;[.66, 1.0]&lt;/code&gt;.  In this
     * case, &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt; would
     * return &lt;code&gt;{ &quot;Good&quot;, &quot;Better&quot;, &quot;Best&quot; }&lt;/code&gt; and
     * &lt;code&gt;getCompressionQualityValues&lt;/code&gt; would return
     * &lt;code&gt;{ 0.0F, .33F, .66F, 1.0F }&lt;/code&gt;.
     *
     * &lt;p&gt; If no descriptions are available, &lt;code&gt;null&lt;/code&gt; is
     * returned.  If &lt;code&gt;null&lt;/code&gt; is returned from
     * &lt;code&gt;getCompressionQualityValues&lt;/code&gt;, this method must also
     * return &lt;code&gt;null&lt;/code&gt;.
     *
     * &lt;p&gt; The descriptions should be localized for the
     * &lt;code&gt;Locale&lt;/code&gt; returned by &lt;code&gt;getLocale&lt;/code&gt;, if it
     * is non-&lt;code&gt;null&lt;/code&gt;.
     *
     * &lt;p&gt; If there are multiple compression types but none has been set,
     * an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; The default implementation checks that compression is
     * supported and that the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, if
     * &lt;code&gt;getCompressionTypes()&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or
     * &lt;code&gt;getCompressionType()&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, it
     * returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @return an array of &lt;code&gt;String&lt;/code&gt;s containing localized
     * descriptions of the compression quality levels.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the set of legal
     * compression types is non-&lt;code&gt;null&lt;/code&gt; and the current
     * compression type is &lt;code&gt;null&lt;/code&gt;.
     *
     * @see #getCompressionQualityValues
     */
    public String[] getCompressionQualityDescriptions() {
        if (!canWriteCompressed()) {
            throw new UnsupportedOperationException(
                &quot;Compression not supported.&quot;);
        }
        if (getCompressionMode() != MODE_EXPLICIT) {
            throw new IllegalStateException
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
        if ((getCompressionTypes() != null) &amp;&amp;
            (getCompressionType() == null)) {
            throw new IllegalStateException(&quot;No compression type set!&quot;);
        }
        return null;
    }

    /**
     * Returns an array of &lt;code&gt;float&lt;/code&gt;s that may be used along
     * with &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt; as part of a user
     * interface for setting or displaying the compression quality
     * level.  See {@link #getCompressionQualityDescriptions
     * getCompressionQualityDescriptions} for more information.
     *
     * &lt;p&gt; If no descriptions are available, &lt;code&gt;null&lt;/code&gt; is
     * returned.  If &lt;code&gt;null&lt;/code&gt; is returned from
     * &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt;, this method
     * must also return &lt;code&gt;null&lt;/code&gt;.
     *
     * &lt;p&gt; If there are multiple compression types but none has been set,
     * an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; The default implementation checks that compression is
     * supported and that the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, if
     * &lt;code&gt;getCompressionTypes()&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or
     * &lt;code&gt;getCompressionType()&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, it
     * returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @return an array of &lt;code&gt;float&lt;/code&gt;s indicating the
     * boundaries between the compression quality levels as described
     * by the &lt;code&gt;String&lt;/code&gt;s from
     * &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the set of legal
     * compression types is non-&lt;code&gt;null&lt;/code&gt; and the current
     * compression type is &lt;code&gt;null&lt;/code&gt;.
     *
     * @see #getCompressionQualityDescriptions
     */
    public float[] getCompressionQualityValues() {
        if (!canWriteCompressed()) {
            throw new UnsupportedOperationException(
                &quot;Compression not supported.&quot;);
        }
        if (getCompressionMode() != MODE_EXPLICIT) {
            throw new IllegalStateException
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
        if ((getCompressionTypes() != null) &amp;&amp;
            (getCompressionType() == null)) {
            throw new IllegalStateException(&quot;No compression type set!&quot;);
        }
        return null;
    }
}
</pre>
</body>
</html>
