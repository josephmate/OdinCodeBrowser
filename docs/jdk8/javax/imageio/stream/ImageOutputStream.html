<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.imageio.stream;

import java.io.DataOutput;
import java.io.IOException;

/**
 * A seekable output stream interface for use by
 * &lt;code&gt;ImageWriter&lt;/code&gt;s.  Various output destinations, such as
 * &lt;code&gt;OutputStream&lt;/code&gt;s and &lt;code&gt;File&lt;/code&gt;s, as well as
 * future fast I/O destinations may be &quot;wrapped&quot; by a suitable
 * implementation of this interface for use by the Image I/O API.
 *
 * &lt;p&gt; Unlike a standard &lt;code&gt;OutputStream&lt;/code&gt;, ImageOutputStream
 * extends its counterpart, &lt;code&gt;ImageInputStream&lt;/code&gt;.  Thus it is
 * possible to read from the stream as it is being written.  The same
 * seek and flush positions apply to both reading and writing, although
 * the semantics for dealing with a non-zero bit offset before a byte-aligned
 * write are necessarily different from the semantics for dealing with
 * a non-zero bit offset before a byte-aligned read.  When reading bytes,
 * any bit offset is set to 0 before the read; when writing bytes, a
 * non-zero bit offset causes the remaining bits in the byte to be written
 * as 0s.  The byte-aligned write then starts at the next byte position.
 *
 * @see ImageInputStream
 *
 */
public interface ImageOutputStream extends ImageInputStream, DataOutput {

    /**
     * Writes a single byte to the stream at the current position.
     * The 24 high-order bits of &lt;code&gt;b&lt;/code&gt; are ignored.
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.  Implementers can use the
     * {@link ImageOutputStreamImpl#flushBits flushBits}
     * method of {@link ImageOutputStreamImpl ImageOutputStreamImpl}
     * to guarantee this.
     *
     * @param b an &lt;code&gt;int&lt;/code&gt; whose lower 8 bits are to be
     * written.
     *
     * @exception IOException if an I/O error occurs.
     */
    void write(int b) throws IOException;

    /**
     * Writes a sequence of bytes to the stream at the current
     * position.  If &lt;code&gt;b.length&lt;/code&gt; is 0, nothing is written.
     * The byte &lt;code&gt;b[0]&lt;/code&gt; is written first, then the byte
     * &lt;code&gt;b[1]&lt;/code&gt;, and so on.
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param b an array of &lt;code&gt;byte&lt;/code&gt;s to be written.
     *
     * @exception NullPointerException if &lt;code&gt;b&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an I/O error occurs.
     */
    void write(byte b[]) throws IOException;

    /**
     * Writes a sequence of bytes to the stream at the current
     * position.  If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written.
     * The byte &lt;code&gt;b[off]&lt;/code&gt; is written first, then the byte
     * &lt;code&gt;b[off + 1]&lt;/code&gt;, and so on.
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.  Implementers can use the
     * {@link ImageOutputStreamImpl#flushBits flushBits}
     * method of {@link ImageOutputStreamImpl ImageOutputStreamImpl}
     * to guarantee this.
     *
     * @param b an array of &lt;code&gt;byte&lt;/code&gt;s to be written.
     * @param off the start offset in the data.
     * @param len the number of &lt;code&gt;byte&lt;/code&gt;s to write.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;b.length&lt;/code&gt;.
     * @exception NullPointerException if &lt;code&gt;b&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an I/O error occurs.
     */
    void write(byte b[], int off, int len) throws IOException;

    /**
     * Writes a &lt;code&gt;boolean&lt;/code&gt; value to the stream.  If
     * &lt;code&gt;v&lt;/code&gt; is true, the value &lt;code&gt;(byte)1&lt;/code&gt; is
     * written; if &lt;code&gt;v&lt;/code&gt; is false, the value
     * &lt;code&gt;(byte)0&lt;/code&gt; is written.
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param v the &lt;code&gt;boolean&lt;/code&gt; to be written.
     *
     * @exception IOException if an I/O error occurs.
     */
    void writeBoolean(boolean v) throws IOException;

    /**
     * Writes the 8 low-order bits of &lt;code&gt;v&lt;/code&gt; to the
     * stream. The 24 high-order bits of &lt;code&gt;v&lt;/code&gt; are ignored.
     * (This means that &lt;code&gt;writeByte&lt;/code&gt; does exactly the same
     * thing as &lt;code&gt;write&lt;/code&gt; for an integer argument.)
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param v an &lt;code&gt;int&lt;/code&gt; containing the byte value to be
     * written.
     *
     * @exception IOException if an I/O error occurs.
     */
    void writeByte(int v) throws IOException;

    /**
     * Writes the 16 low-order bits of &lt;code&gt;v&lt;/code&gt; to the
     * stream. The 16 high-order bits of &lt;code&gt;v&lt;/code&gt; are ignored.
     * If the stream uses network byte order, the bytes written, in
     * order, will be:
     *
     * &lt;pre&gt;
     * (byte)((v &amp;gt;&amp;gt; 8) &amp;amp; 0xff)
     * (byte)(v &amp;amp; 0xff)
     * &lt;/pre&gt;
     *
     * Otherwise, the bytes written will be:
     *
     * &lt;pre&gt;
     * (byte)(v &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 8) &amp;amp; 0xff)
     * &lt;/pre&gt;
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param v an &lt;code&gt;int&lt;/code&gt; containing the short value to be
     * written.
     *
     * @exception IOException if an I/O error occurs.
     */
    void writeShort(int v) throws IOException;

    /**
     * This method is a synonym for {@link #writeShort writeShort}.
     *
     * @param v an &lt;code&gt;int&lt;/code&gt; containing the char (unsigned
     * short) value to be written.
     *
     * @exception IOException if an I/O error occurs.
     *
     * @see #writeShort(int)
     */
    void writeChar(int v) throws IOException;

    /**
     * Writes the 32 bits of &lt;code&gt;v&lt;/code&gt; to the stream.  If the
     * stream uses network byte order, the bytes written, in order,
     * will be:
     *
     * &lt;pre&gt;
     * (byte)((v &amp;gt;&amp;gt; 24) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 16) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 8) &amp;amp; 0xff)
     * (byte)(v &amp;amp; 0xff)
     * &lt;/pre&gt;
     *
     * Otheriwse, the bytes written will be:
     *
     * &lt;pre&gt;
     * (byte)(v &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 8) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 16) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 24) &amp;amp; 0xff)
     * &lt;/pre&gt;
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param v an &lt;code&gt;int&lt;/code&gt; containing the value to be
     * written.
     *
     * @exception IOException if an I/O error occurs.
     */
    void writeInt(int v) throws IOException;

    /**
     * Writes the 64 bits of &lt;code&gt;v&lt;/code&gt; to the stream.  If the
     * stream uses network byte order, the bytes written, in order,
     * will be:
     *
     * &lt;pre&gt;
     * (byte)((v &amp;gt;&amp;gt; 56) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 48) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 40) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 32) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 24) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 16) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 8) &amp;amp; 0xff)
     * (byte)(v &amp;amp; 0xff)
     * &lt;/pre&gt;
     *
     * Otherwise, the bytes written will be:
     *
     * &lt;pre&gt;
     * (byte)(v &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 8) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 16) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 24) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 32) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 40) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 48) &amp;amp; 0xff)
     * (byte)((v &amp;gt;&amp;gt; 56) &amp;amp; 0xff)
     * &lt;/pre&gt;
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param v a &lt;code&gt;long&lt;/code&gt; containing the value to be
     * written.
     *
     * @exception IOException if an I/O error occurs.
     */
    void writeLong(long v) throws IOException;

    /**
     * Writes a &lt;code&gt;float&lt;/code&gt; value, which is comprised of four
     * bytes, to the output stream. It does this as if it first
     * converts this &lt;code&gt;float&lt;/code&gt; value to an &lt;code&gt;int&lt;/code&gt;
     * in exactly the manner of the &lt;code&gt;Float.floatToIntBits&lt;/code&gt;
     * method and then writes the int value in exactly the manner of
     * the &lt;code&gt;writeInt&lt;/code&gt; method.
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param v a &lt;code&gt;float&lt;/code&gt; containing the value to be
     * written.
     *
     * @exception IOException if an I/O error occurs.
     */
    void writeFloat(float v) throws IOException;

    /**
     * Writes a &lt;code&gt;double&lt;/code&gt; value, which is comprised of four
     * bytes, to the output stream. It does this as if it first
     * converts this &lt;code&gt;double&lt;/code&gt; value to an &lt;code&gt;long&lt;/code&gt;
     * in exactly the manner of the
     * &lt;code&gt;Double.doubleToLongBits&lt;/code&gt; method and then writes the
     * long value in exactly the manner of the &lt;code&gt;writeLong&lt;/code&gt;
     * method.
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param v a &lt;code&gt;double&lt;/code&gt; containing the value to be
     * written.
     *
     * @exception IOException if an I/O error occurs.
     */
    void writeDouble(double v) throws IOException;

    /**
     * Writes a string to the output stream. For every character in
     * the string &lt;code&gt;s&lt;/code&gt;, taken in order, one byte is written
     * to the output stream. If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a
     * &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; If &lt;code&gt;s.length&lt;/code&gt; is zero, then no bytes are
     * written. Otherwise, the character &lt;code&gt;s[0]&lt;/code&gt; is written
     * first, then &lt;code&gt;s[1]&lt;/code&gt;, and so on; the last character
     * written is &lt;code&gt;s[s.length-1]&lt;/code&gt;. For each character, one
     * byte is written, the low-order byte, in exactly the manner of
     * the &lt;code&gt;writeByte&lt;/code&gt; method. The high-order eight bits of
     * each character in the string are ignored.
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param s a &lt;code&gt;String&lt;/code&gt; containing the value to be
     * written.
     *
     * @exception NullPointerException if &lt;code&gt;s&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an I/O error occurs.
     */
    void writeBytes(String s) throws IOException;

    /**
     * Writes a string to the output stream. For every character in
     * the string &lt;code&gt;s&lt;/code&gt;, taken in order, two bytes are
     * written to the output stream, ordered according to the current
     * byte order setting.  If network byte order is being used, the
     * high-order byte is written first; the order is reversed
     * otherwise.  If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a
     * &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; If &lt;code&gt;s.length&lt;/code&gt; is zero, then no bytes are
     * written. Otherwise, the character &lt;code&gt;s[0]&lt;/code&gt; is written
     * first, then &lt;code&gt;s[1]&lt;/code&gt;, and so on; the last character
     * written is &lt;code&gt;s[s.length-1]&lt;/code&gt;.
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param s a &lt;code&gt;String&lt;/code&gt; containing the value to be
     * written.
     *
     * @exception NullPointerException if &lt;code&gt;s&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an I/O error occurs.
     */
    void writeChars(String s) throws IOException;

    /**
     * Writes two bytes of length information to the output stream in
     * network byte order, followed by the
     * &lt;a href=&quot;../../../java/io/DataInput.html#modified-utf-8&quot;&gt;modified
     * UTF-8&lt;/a&gt;
     * representation of every character in the string &lt;code&gt;s&lt;/code&gt;.
     * If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a
     * &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.  Each character in
     * the string &lt;code&gt;s&lt;/code&gt; is converted to a group of one, two,
     * or three bytes, depending on the value of the character.
     *
     * &lt;p&gt; If a character &lt;code&gt;c&lt;/code&gt; is in the range
     * &lt;code&gt;&amp;#92;u0001&lt;/code&gt; through &lt;code&gt;&amp;#92;u007f&lt;/code&gt;, it is
     * represented by one byte:
     *
     * &lt;p&gt;&lt;pre&gt;
     * (byte)c
     * &lt;/pre&gt;
     *
     * &lt;p&gt; If a character &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;&amp;#92;u0000&lt;/code&gt; or
     * is in the range &lt;code&gt;&amp;#92;u0080&lt;/code&gt; through
     * &lt;code&gt;&amp;#92;u07ff&lt;/code&gt;, then it is represented by two bytes,
     * to be written in the order shown:
     *
     * &lt;p&gt; &lt;pre&gt;&lt;code&gt;
     * (byte)(0xc0 | (0x1f &amp;amp; (c &amp;gt;&amp;gt; 6)))
     * (byte)(0x80 | (0x3f &amp;amp; c))
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;p&gt; If a character &lt;code&gt;c&lt;/code&gt; is in the range
     * &lt;code&gt;&amp;#92;u0800&lt;/code&gt; through &lt;code&gt;uffff&lt;/code&gt;, then it is
     * represented by three bytes, to be written in the order shown:
     *
     * &lt;p&gt; &lt;pre&gt;&lt;code&gt;
     * (byte)(0xe0 | (0x0f &amp;amp; (c &amp;gt;&amp;gt; 12)))
     * (byte)(0x80 | (0x3f &amp;amp; (c &amp;gt;&amp;gt; 6)))
     * (byte)(0x80 | (0x3f &amp;amp; c))
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;p&gt; First, the total number of bytes needed to represent all
     * the characters of &lt;code&gt;s&lt;/code&gt; is calculated. If this number
     * is larger than &lt;code&gt;65535&lt;/code&gt;, then a
     * &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown. Otherwise, this
     * length is written to the output stream in exactly the manner of
     * the &lt;code&gt;writeShort&lt;/code&gt; method; after this, the one-, two-,
     * or three-byte representation of each character in the string
     * &lt;code&gt;s&lt;/code&gt; is written.
     *
     * &lt;p&gt; The current byte order setting is ignored.
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method should not be used in
     * the  implementation of image formats that use standard UTF-8,
     * because  the modified UTF-8 used here is incompatible with
     * standard UTF-8.
     *
     * @param s a &lt;code&gt;String&lt;/code&gt; containing the value to be
     * written.
     *
     * @exception NullPointerException if &lt;code&gt;s&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception java.io.UTFDataFormatException if the modified UTF-8
     * representation of &lt;code&gt;s&lt;/code&gt; requires more than 65536 bytes.
     * @exception IOException if an I/O error occurs.
     */
    void writeUTF(String s) throws IOException;

    /**
     * Writes a sequence of shorts to the stream at the current
     * position.  If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written.
     * The short &lt;code&gt;s[off]&lt;/code&gt; is written first, then the short
     * &lt;code&gt;s[off + 1]&lt;/code&gt;, and so on.  The byte order of the
     * stream is used to determine the order in which the individual
     * bytes are written.
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param s an array of &lt;code&gt;short&lt;/code&gt;s to be written.
     * @param off the start offset in the data.
     * @param len the number of &lt;code&gt;short&lt;/code&gt;s to write.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;s.length&lt;/code&gt;.
     * @exception NullPointerException if &lt;code&gt;s&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an I/O error occurs.
     */
    void writeShorts(short[] s, int off, int len) throws IOException;

    /**
     * Writes a sequence of chars to the stream at the current
     * position.  If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written.
     * The char &lt;code&gt;c[off]&lt;/code&gt; is written first, then the char
     * &lt;code&gt;c[off + 1]&lt;/code&gt;, and so on.  The byte order of the
     * stream is used to determine the order in which the individual
     * bytes are written.
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param c an array of &lt;code&gt;char&lt;/code&gt;s to be written.
     * @param off the start offset in the data.
     * @param len the number of &lt;code&gt;char&lt;/code&gt;s to write.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;c.length&lt;/code&gt;.
     * @exception NullPointerException if &lt;code&gt;c&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an I/O error occurs.
     */
    void writeChars(char[] c, int off, int len) throws IOException;

    /**
     * Writes a sequence of ints to the stream at the current
     * position.  If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written.
     * The int &lt;code&gt;i[off]&lt;/code&gt; is written first, then the int
     * &lt;code&gt;i[off + 1]&lt;/code&gt;, and so on.  The byte order of the
     * stream is used to determine the order in which the individual
     * bytes are written.
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param i an array of &lt;code&gt;int&lt;/code&gt;s to be written.
     * @param off the start offset in the data.
     * @param len the number of &lt;code&gt;int&lt;/code&gt;s to write.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;i.length&lt;/code&gt;.
     * @exception NullPointerException if &lt;code&gt;i&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an I/O error occurs.
     */
    void writeInts(int[] i, int off, int len) throws IOException;

    /**
     * Writes a sequence of longs to the stream at the current
     * position.  If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written.
     * The long &lt;code&gt;l[off]&lt;/code&gt; is written first, then the long
     * &lt;code&gt;l[off + 1]&lt;/code&gt;, and so on.  The byte order of the
     * stream is used to determine the order in which the individual
     * bytes are written.
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param l an array of &lt;code&gt;long&lt;/code&gt;s to be written.
     * @param off the start offset in the data.
     * @param len the number of &lt;code&gt;long&lt;/code&gt;s to write.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;l.length&lt;/code&gt;.
     * @exception NullPointerException if &lt;code&gt;l&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an I/O error occurs.
     */
    void writeLongs(long[] l, int off, int len) throws IOException;

    /**
     * Writes a sequence of floats to the stream at the current
     * position.  If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written.
     * The float &lt;code&gt;f[off]&lt;/code&gt; is written first, then the float
     * &lt;code&gt;f[off + 1]&lt;/code&gt;, and so on.  The byte order of the
     * stream is used to determine the order in which the individual
     * bytes are written.
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param f an array of &lt;code&gt;float&lt;/code&gt;s to be written.
     * @param off the start offset in the data.
     * @param len the number of &lt;code&gt;float&lt;/code&gt;s to write.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;f.length&lt;/code&gt;.
     * @exception NullPointerException if &lt;code&gt;f&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an I/O error occurs.
     */
    void writeFloats(float[] f, int off, int len) throws IOException;

    /**
     * Writes a sequence of doubles to the stream at the current
     * position.  If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written.
     * The double &lt;code&gt;d[off]&lt;/code&gt; is written first, then the double
     * &lt;code&gt;d[off + 1]&lt;/code&gt;, and so on.  The byte order of the
     * stream is used to determine the order in which the individual
     * bytes are written.
     *
     * &lt;p&gt; If the bit offset within the stream is non-zero, the
     * remainder of the current byte is padded with 0s
     * and written out first.  The bit offset will be 0 after the
     * write.
     *
     * @param d an array of &lt;code&gt;doubles&lt;/code&gt;s to be written.
     * @param off the start offset in the data.
     * @param len the number of &lt;code&gt;double&lt;/code&gt;s to write.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;d.length&lt;/code&gt;.
     * @exception NullPointerException if &lt;code&gt;d&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an I/O error occurs.
     */
    void writeDoubles(double[] d, int off, int len) throws IOException;

    /**
     * Writes a single bit, given by the least significant bit of the
     * argument, to the stream at the current bit offset within the
     * current byte position.  The upper 31 bits of the argument are
     * ignored.  The given bit replaces the previous bit at that
     * position.  The bit offset is advanced by one and reduced modulo
     * 8.
     *
     * &lt;p&gt; If any bits of a particular byte have never been set
     * at the time the byte is flushed to the destination, those
     * bits will be set to 0 automatically.
     *
     * @param bit an &lt;code&gt;int&lt;/code&gt; whose least significant bit
     * is to be written to the stream.
     *
     * @exception IOException if an I/O error occurs.
     */
    void writeBit(int bit) throws IOException;

    /**
     * Writes a sequence of bits, given by the &lt;code&gt;numBits&lt;/code&gt;
     * least significant bits of the &lt;code&gt;bits&lt;/code&gt; argument in
     * left-to-right order, to the stream at the current bit offset
     * within the current byte position.  The upper &lt;code&gt;64 -
     * numBits&lt;/code&gt; bits of the argument are ignored.  The bit
     * offset is advanced by &lt;code&gt;numBits&lt;/code&gt; and reduced modulo
     * 8.  Note that a bit offset of 0 always indicates the
     * most-significant bit of the byte, and bytes of bits are written
     * out in sequence as they are encountered.  Thus bit writes are
     * always effectively in network byte order.  The actual stream
     * byte order setting is ignored.
     *
     * &lt;p&gt; Bit data may be accumulated in memory indefinitely, until
     * &lt;code&gt;flushBefore&lt;/code&gt; is called.  At that time, all bit data
     * prior to the flushed position will be written.
     *
     * &lt;p&gt; If any bits of a particular byte have never been set
     * at the time the byte is flushed to the destination, those
     * bits will be set to 0 automatically.
     *
     * @param bits a &lt;code&gt;long&lt;/code&gt; containing the bits to be
     * written, starting with the bit in position &lt;code&gt;numBits -
     * 1&lt;/code&gt; down to the least significant bit.
     *
     * @param numBits an &lt;code&gt;int&lt;/code&gt; between 0 and 64, inclusive.
     *
     * @exception IllegalArgumentException if &lt;code&gt;numBits&lt;/code&gt; is
     * not between 0 and 64, inclusive.
     * @exception IOException if an I/O error occurs.
     */
    void writeBits(long bits, int numBits) throws IOException;

    /**
     * Flushes all data prior to the given position to the underlying
     * destination, such as an &lt;code&gt;OutputStream&lt;/code&gt; or
     * &lt;code&gt;File&lt;/code&gt;.  Attempting to seek to the flushed portion
     * of the stream will result in an
     * &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;.
     *
     * @param pos a &lt;code&gt;long&lt;/code&gt; containing the length of the
     * stream prefix that may be flushed to the destination.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;pos&lt;/code&gt; lies
     * in the flushed portion of the stream or past the current stream
     * position.
     * @exception IOException if an I/O error occurs.
     */
    void flushBefore(long pos) throws IOException;
}
</pre>
</body>
</html>
