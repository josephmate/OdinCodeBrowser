<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.imageio.stream;

import java.io.Closeable;
import java.io.DataInput;
import java.io.IOException;
import java.nio.ByteOrder;

/**
 * A seekable input stream interface for use by
 * &lt;code&gt;ImageReader&lt;/code&gt;s.  Various input sources, such as
 * &lt;code&gt;InputStream&lt;/code&gt;s and &lt;code&gt;File&lt;/code&gt;s,
 * as well as future fast I/O sources may be &quot;wrapped&quot; by a suitable
 * implementation of this interface for use by the Image I/O API.
 *
 * @see ImageInputStreamImpl
 * @see FileImageInputStream
 * @see FileCacheImageInputStream
 * @see MemoryCacheImageInputStream
 *
 */
public interface ImageInputStream extends DataInput, Closeable {

    /**
     * Sets the desired byte order for future reads of data values
     * from this stream.  For example, the sequence of bytes '0x01
     * 0x02 0x03 0x04' if read as a 4-byte integer would have the
     * value '0x01020304' using network byte order and the value
     * '0x04030201' under the reverse byte order.
     *
     * &lt;p&gt; The enumeration class &lt;code&gt;java.nio.ByteOrder&lt;/code&gt; is
     * used to specify the byte order.  A value of
     * &lt;code&gt;ByteOrder.BIG_ENDIAN&lt;/code&gt; specifies so-called
     * big-endian or network byte order, in which the high-order byte
     * comes first.  Motorola and Sparc processors store data in this
     * format, while Intel processors store data in the reverse
     * &lt;code&gt;ByteOrder.LITTLE_ENDIAN&lt;/code&gt; order.
     *
     * &lt;p&gt; The byte order has no effect on the results returned from
     * the &lt;code&gt;readBits&lt;/code&gt; method (or the value written by
     * &lt;code&gt;ImageOutputStream.writeBits&lt;/code&gt;).
     *
     * @param byteOrder one of &lt;code&gt;ByteOrder.BIG_ENDIAN&lt;/code&gt; or
     * &lt;code&gt;java.nio.ByteOrder.LITTLE_ENDIAN&lt;/code&gt;, indicating whether
     * network byte order or its reverse will be used for future
     * reads.
     *
     * @see java.nio.ByteOrder
     * @see #getByteOrder
     * @see #readBits(int)
     */
    void setByteOrder(ByteOrder byteOrder);

    /**
     * Returns the byte order with which data values will be read from
     * this stream as an instance of the
     * &lt;code&gt;java.nio.ByteOrder&lt;/code&gt; enumeration.
     *
     * @return one of &lt;code&gt;ByteOrder.BIG_ENDIAN&lt;/code&gt; or
     * &lt;code&gt;ByteOrder.LITTLE_ENDIAN&lt;/code&gt;, indicating which byte
     * order is being used.
     *
     * @see java.nio.ByteOrder
     * @see #setByteOrder
     */
    ByteOrder getByteOrder();

    /**
     * Reads a single byte from the stream and returns it as an
     * integer between 0 and 255.  If the end of the stream is
     * reached, -1 is returned.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @return a byte value from the stream, as an int, or -1 to
     * indicate EOF.
     *
     * @exception IOException if an I/O error occurs.
     */
    int read() throws IOException;

    /**
     * Reads up to &lt;code&gt;b.length&lt;/code&gt; bytes from the stream, and
     * stores them into &lt;code&gt;b&lt;/code&gt; starting at index 0.  The
     * number of bytes read is returned.  If no bytes can be read
     * because the end of the stream has been reached, -1 is returned.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @param b an array of bytes to be written to.
     *
     * @return the number of bytes actually read, or &lt;code&gt;-1&lt;/code&gt;
     * to indicate EOF.
     *
     * @exception NullPointerException if &lt;code&gt;b&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception IOException if an I/O error occurs.
     */
    int read(byte[] b) throws IOException;

    /**
     * Reads up to &lt;code&gt;len&lt;/code&gt; bytes from the stream, and stores
     * them into &lt;code&gt;b&lt;/code&gt; starting at index &lt;code&gt;off&lt;/code&gt;.
     * The number of bytes read is returned.  If no bytes can be read
     * because the end of the stream has been reached, &lt;code&gt;-1&lt;/code&gt;
     * is returned.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @param b an array of bytes to be written to.
     * @param off the starting position within &lt;code&gt;b&lt;/code&gt; to write to.
     * @param len the maximum number of &lt;code&gt;byte&lt;/code&gt;s to read.
     *
     * @return the number of bytes actually read, or &lt;code&gt;-1&lt;/code&gt;
     * to indicate EOF.
     *
     * @exception NullPointerException if &lt;code&gt;b&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;b.length&lt;/code&gt;.
     * @exception IOException if an I/O error occurs.
     */
    int read(byte[] b, int off, int len) throws IOException;

    /**
     * Reads up to &lt;code&gt;len&lt;/code&gt; bytes from the stream, and
     * modifies the supplied &lt;code&gt;IIOByteBuffer&lt;/code&gt; to indicate
     * the byte array, offset, and length where the data may be found.
     * The caller should not attempt to modify the data found in the
     * &lt;code&gt;IIOByteBuffer&lt;/code&gt;.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @param buf an IIOByteBuffer object to be modified.
     * @param len the maximum number of &lt;code&gt;byte&lt;/code&gt;s to read.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;len&lt;/code&gt; is
     * negative.
     * @exception NullPointerException if &lt;code&gt;buf&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception IOException if an I/O error occurs.
     */
    void readBytes(IIOByteBuffer buf, int len) throws IOException;

    /**
     * Reads a byte from the stream and returns a &lt;code&gt;boolean&lt;/code&gt;
     * value of &lt;code&gt;true&lt;/code&gt; if it is nonzero, &lt;code&gt;false&lt;/code&gt;
     * if it is zero.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @return a boolean value from the stream.
     *
     * @exception java.io.EOFException if the end of the stream is reached.
     * @exception IOException if an I/O error occurs.
     */
    boolean readBoolean() throws IOException;

    /**
     * Reads a byte from the stream and returns it as a
     * &lt;code&gt;byte&lt;/code&gt; value.  Byte values between &lt;code&gt;0x00&lt;/code&gt;
     * and &lt;code&gt;0x7f&lt;/code&gt; represent integer values between
     * &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;127&lt;/code&gt;.  Values between
     * &lt;code&gt;0x80&lt;/code&gt; and &lt;code&gt;0xff&lt;/code&gt; represent negative
     * values from &lt;code&gt;-128&lt;/code&gt; to &lt;code&gt;/1&lt;/code&gt;.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @return a signed byte value from the stream.
     *
     * @exception java.io.EOFException if the end of the stream is reached.
     * @exception IOException if an I/O error occurs.
     */
    byte readByte() throws IOException;

    /**
     * Reads a byte from the stream, and (conceptually) converts it to
     * an int, masks it with &lt;code&gt;0xff&lt;/code&gt; in order to strip off
     * any sign-extension bits, and returns it as a &lt;code&gt;byte&lt;/code&gt;
     * value.
     *
     * &lt;p&gt; Thus, byte values between &lt;code&gt;0x00&lt;/code&gt; and
     * &lt;code&gt;0x7f&lt;/code&gt; are simply returned as integer values between
     * &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;127&lt;/code&gt;.  Values between
     * &lt;code&gt;0x80&lt;/code&gt; and &lt;code&gt;0xff&lt;/code&gt;, which normally
     * represent negative &lt;code&gt;byte&lt;/code&gt;values, will be mapped into
     * positive integers between &lt;code&gt;128&lt;/code&gt; and
     * &lt;code&gt;255&lt;/code&gt;.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @return an unsigned byte value from the stream.
     *
     * @exception java.io.EOFException if the end of the stream is reached.
     * @exception IOException if an I/O error occurs.
     */
    int readUnsignedByte() throws IOException;

    /**
     * Reads two bytes from the stream, and (conceptually)
     * concatenates them according to the current byte order, and
     * returns the result as a &lt;code&gt;short&lt;/code&gt; value.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @return a signed short value from the stream.
     *
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     *
     * @see #getByteOrder
     */
    short readShort() throws IOException;

    /**
     * Reads two bytes from the stream, and (conceptually)
     * concatenates them according to the current byte order, converts
     * the resulting value to an &lt;code&gt;int&lt;/code&gt;, masks it with
     * &lt;code&gt;0xffff&lt;/code&gt; in order to strip off any sign-extension
     * buts, and returns the result as an unsigned &lt;code&gt;int&lt;/code&gt;
     * value.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @return an unsigned short value from the stream, as an int.
     *
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     *
     * @see #getByteOrder
     */
    int readUnsignedShort() throws IOException;

    /**
     * Equivalent to &lt;code&gt;readUnsignedShort&lt;/code&gt;, except that the
     * result is returned using the &lt;code&gt;char&lt;/code&gt; datatype.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @return an unsigned char value from the stream.
     *
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     *
     * @see #readUnsignedShort
     */
    char readChar() throws IOException;

    /**
     * Reads 4 bytes from the stream, and (conceptually) concatenates
     * them according to the current byte order and returns the result
     * as an &lt;code&gt;int&lt;/code&gt;.
     *
     * &lt;p&gt; The bit offset within the stream is ignored and treated as
     * though it were zero.
     *
     * @return a signed int value from the stream.
     *
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     *
     * @see #getByteOrder
     */
    int readInt() throws IOException;

    /**
     * Reads 4 bytes from the stream, and (conceptually) concatenates
     * them according to the current byte order, converts the result
     * to a long, masks it with &lt;code&gt;0xffffffffL&lt;/code&gt; in order to
     * strip off any sign-extension bits, and returns the result as an
     * unsigned &lt;code&gt;long&lt;/code&gt; value.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @return an unsigned int value from the stream, as a long.
     *
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     *
     * @see #getByteOrder
     */
    long readUnsignedInt() throws IOException;

    /**
     * Reads 8 bytes from the stream, and (conceptually) concatenates
     * them according to the current byte order and returns the result
     * as a &lt;code&gt;long&lt;/code&gt;.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @return a signed long value from the stream.
     *
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     *
     * @see #getByteOrder
     */
    long readLong() throws IOException;

    /**
     * Reads 4 bytes from the stream, and (conceptually) concatenates
     * them according to the current byte order and returns the result
     * as a &lt;code&gt;float&lt;/code&gt;.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @return a float value from the stream.
     *
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     *
     * @see #getByteOrder
     */
    float readFloat() throws IOException;

    /**
     * Reads 8 bytes from the stream, and (conceptually) concatenates
     * them according to the current byte order and returns the result
     * as a &lt;code&gt;double&lt;/code&gt;.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @return a double value from the stream.
     *
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     *
     * @see #getByteOrder
     */
    double readDouble() throws IOException;

    /**
     * Reads the next line of text from the input stream.  It reads
     * successive bytes, converting each byte separately into a
     * character, until it encounters a line terminator or end of
     * file; the characters read are then returned as a
     * &lt;code&gt;String&lt;/code&gt;. Note that because this method processes
     * bytes, it does not support input of the full Unicode character
     * set.
     *
     * &lt;p&gt; If end of file is encountered before even one byte can be
     * read, then &lt;code&gt;null&lt;/code&gt; is returned. Otherwise, each byte
     * that is read is converted to type &lt;code&gt;char&lt;/code&gt; by
     * zero-extension. If the character &lt;code&gt;'\n'&lt;/code&gt; is
     * encountered, it is discarded and reading ceases. If the
     * character &lt;code&gt;'\r'&lt;/code&gt; is encountered, it is discarded
     * and, if the following byte converts &amp;#32;to the character
     * &lt;code&gt;'\n'&lt;/code&gt;, then that is discarded also; reading then
     * ceases. If end of file is encountered before either of the
     * characters &lt;code&gt;'\n'&lt;/code&gt; and &lt;code&gt;'\r'&lt;/code&gt; is
     * encountered, reading ceases. Once reading has ceased, a
     * &lt;code&gt;String&lt;/code&gt; is returned that contains all the
     * characters read and not discarded, taken in order.  Note that
     * every character in this string will have a value less than
     * &lt;code&gt;&amp;#92;u0100&lt;/code&gt;, that is, &lt;code&gt;(char)256&lt;/code&gt;.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @return a String containing a line of text from the stream.
     *
     * @exception IOException if an I/O error occurs.
     */
    String readLine() throws IOException;

    /**
     * Reads in a string that has been encoded using a
     * &lt;a href=&quot;../../../java/io/DataInput.html#modified-utf-8&quot;&gt;modified
     * UTF-8&lt;/a&gt;
     * format.  The general contract of &lt;code&gt;readUTF&lt;/code&gt; is that
     * it reads a representation of a Unicode character string encoded
     * in modified UTF-8 format; this string of characters is
     * then returned as a &lt;code&gt;String&lt;/code&gt;.
     *
     * &lt;p&gt; First, two bytes are read and used to construct an unsigned
     * 16-bit integer in the manner of the
     * &lt;code&gt;readUnsignedShort&lt;/code&gt; method, using network byte order
     * (regardless of the current byte order setting). This integer
     * value is called the &lt;i&gt;UTF length&lt;/i&gt; and specifies the number
     * of additional bytes to be read. These bytes are then converted
     * to characters by considering them in groups. The length of each
     * group is computed from the value of the first byte of the
     * group. The byte following a group, if any, is the first byte of
     * the next group.
     *
     * &lt;p&gt; If the first byte of a group matches the bit pattern
     * &lt;code&gt;0xxxxxxx&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; means &quot;may be
     * &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;&quot;), then the group consists of
     * just that byte. The byte is zero-extended to form a character.
     *
     * &lt;p&gt; If the first byte of a group matches the bit pattern
     * &lt;code&gt;110xxxxx&lt;/code&gt;, then the group consists of that byte
     * &lt;code&gt;a&lt;/code&gt; and a second byte &lt;code&gt;b&lt;/code&gt;. If there is no
     * byte &lt;code&gt;b&lt;/code&gt; (because byte &lt;code&gt;a&lt;/code&gt; was the last
     * of the bytes to be read), or if byte &lt;code&gt;b&lt;/code&gt; does not
     * match the bit pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a
     * &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown. Otherwise, the
     * group is converted to the character:
     *
     * &lt;p&gt; &lt;pre&gt;&lt;code&gt;
     * (char)(((a&amp;amp; 0x1F) &amp;lt;&amp;lt; 6) | (b &amp;amp; 0x3F))
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * If the first byte of a group matches the bit pattern
     * &lt;code&gt;1110xxxx&lt;/code&gt;, then the group consists of that byte
     * &lt;code&gt;a&lt;/code&gt; and two more bytes &lt;code&gt;b&lt;/code&gt; and
     * &lt;code&gt;c&lt;/code&gt;.  If there is no byte &lt;code&gt;c&lt;/code&gt; (because
     * byte &lt;code&gt;a&lt;/code&gt; was one of the last two of the bytes to be
     * read), or either byte &lt;code&gt;b&lt;/code&gt; or byte &lt;code&gt;c&lt;/code&gt;
     * does not match the bit pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a
     * &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown. Otherwise, the
     * group is converted to the character:
     *
     * &lt;p&gt; &lt;pre&gt;&lt;code&gt;
     * (char)(((a &amp;amp; 0x0F) &amp;lt;&amp;lt; 12) | ((b &amp;amp; 0x3F) &amp;lt;&amp;lt; 6) | (c &amp;amp; 0x3F))
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * If the first byte of a group matches the pattern
     * &lt;code&gt;1111xxxx&lt;/code&gt; or the pattern &lt;code&gt;10xxxxxx&lt;/code&gt;,
     * then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; If end of file is encountered at any time during this
     * entire process, then an &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; After every group has been converted to a character by this
     * process, the characters are gathered, in the same order in
     * which their corresponding groups were read from the input
     * stream, to form a &lt;code&gt;String&lt;/code&gt;, which is returned.
     *
     * &lt;p&gt; The current byte order setting is ignored.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method should not be used in
     * the  implementation of image formats that use standard UTF-8,
     * because  the modified UTF-8 used here is incompatible with
     * standard UTF-8.
     *
     * @return a String read from the stream.
     *
     * @exception  java.io.EOFException  if this stream reaches the end
     * before reading all the bytes.
     * @exception  java.io.UTFDataFormatException if the bytes do not represent
     * a valid modified UTF-8 encoding of a string.
     * @exception IOException if an I/O error occurs.
     */
    String readUTF() throws IOException;

    /**
     * Reads &lt;code&gt;len&lt;/code&gt; bytes from the stream, and stores them
     * into &lt;code&gt;b&lt;/code&gt; starting at index &lt;code&gt;off&lt;/code&gt;.
     * If the end of the stream is reached, an &lt;code&gt;java.io.EOFException&lt;/code&gt;
     * will be thrown.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @param b an array of bytes to be written to.
     * @param off the starting position within &lt;code&gt;b&lt;/code&gt; to write to.
     * @param len the maximum number of &lt;code&gt;byte&lt;/code&gt;s to read.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;b.length&lt;/code&gt;.
     * @exception NullPointerException if &lt;code&gt;b&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     */
    void readFully(byte[] b, int off, int len) throws IOException;

    /**
     * Reads &lt;code&gt;b.length&lt;/code&gt; bytes from the stream, and stores them
     * into &lt;code&gt;b&lt;/code&gt; starting at index &lt;code&gt;0&lt;/code&gt;.
     * If the end of the stream is reached, an &lt;code&gt;java.io.EOFException&lt;/code&gt;
     * will be thrown.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @param b an array of &lt;code&gt;byte&lt;/code&gt;s.
     *
     * @exception NullPointerException if &lt;code&gt;b&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     */
    void readFully(byte[] b) throws IOException;

    /**
     * Reads &lt;code&gt;len&lt;/code&gt; shorts (signed 16-bit integers) from the
     * stream according to the current byte order, and
     * stores them into &lt;code&gt;s&lt;/code&gt; starting at index
     * &lt;code&gt;off&lt;/code&gt;.  If the end of the stream is reached, an
     * &lt;code&gt;java.io.EOFException&lt;/code&gt; will be thrown.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @param s an array of shorts to be written to.
     * @param off the starting position within &lt;code&gt;s&lt;/code&gt; to write to.
     * @param len the maximum number of &lt;code&gt;short&lt;/code&gt;s to read.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;s.length&lt;/code&gt;.
     * @exception NullPointerException if &lt;code&gt;s&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     */
    void readFully(short[] s, int off, int len) throws IOException;

    /**
     * Reads &lt;code&gt;len&lt;/code&gt; chars (unsigned 16-bit integers) from the
     * stream according to the current byte order, and
     * stores them into &lt;code&gt;c&lt;/code&gt; starting at index
     * &lt;code&gt;off&lt;/code&gt;.  If the end of the stream is reached, an
     * &lt;code&gt;java.io.EOFException&lt;/code&gt; will be thrown.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @param c an array of chars to be written to.
     * @param off the starting position within &lt;code&gt;c&lt;/code&gt; to write to.
     * @param len the maximum number of &lt;code&gt;char&lt;/code&gt;s to read.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;c.length&lt;/code&gt;.
     * @exception NullPointerException if &lt;code&gt;c&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     */
    void readFully(char[] c, int off, int len) throws IOException;

    /**
     * Reads &lt;code&gt;len&lt;/code&gt; ints (signed 32-bit integers) from the
     * stream according to the current byte order, and
     * stores them into &lt;code&gt;i&lt;/code&gt; starting at index
     * &lt;code&gt;off&lt;/code&gt;.  If the end of the stream is reached, an
     * &lt;code&gt;java.io.EOFException&lt;/code&gt; will be thrown.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @param i an array of ints to be written to.
     * @param off the starting position within &lt;code&gt;i&lt;/code&gt; to write to.
     * @param len the maximum number of &lt;code&gt;int&lt;/code&gt;s to read.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;i.length&lt;/code&gt;.
     * @exception NullPointerException if &lt;code&gt;i&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     */
    void readFully(int[] i, int off, int len) throws IOException;

    /**
     * Reads &lt;code&gt;len&lt;/code&gt; longs (signed 64-bit integers) from the
     * stream according to the current byte order, and
     * stores them into &lt;code&gt;l&lt;/code&gt; starting at index
     * &lt;code&gt;off&lt;/code&gt;.  If the end of the stream is reached, an
     * &lt;code&gt;java.io.EOFException&lt;/code&gt; will be thrown.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @param l an array of longs to be written to.
     * @param off the starting position within &lt;code&gt;l&lt;/code&gt; to write to.
     * @param len the maximum number of &lt;code&gt;long&lt;/code&gt;s to read.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;l.length&lt;/code&gt;.
     * @exception NullPointerException if &lt;code&gt;l&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     */
    void readFully(long[] l, int off, int len) throws IOException;

    /**
     * Reads &lt;code&gt;len&lt;/code&gt; floats (32-bit IEEE single-precision
     * floats) from the stream according to the current byte order,
     * and stores them into &lt;code&gt;f&lt;/code&gt; starting at
     * index &lt;code&gt;off&lt;/code&gt;.  If the end of the stream is reached,
     * an &lt;code&gt;java.io.EOFException&lt;/code&gt; will be thrown.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @param f an array of floats to be written to.
     * @param off the starting position within &lt;code&gt;f&lt;/code&gt; to write to.
     * @param len the maximum number of &lt;code&gt;float&lt;/code&gt;s to read.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;f.length&lt;/code&gt;.
     * @exception NullPointerException if &lt;code&gt;f&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     */
    void readFully(float[] f, int off, int len) throws IOException;

    /**
     * Reads &lt;code&gt;len&lt;/code&gt; doubles (64-bit IEEE double-precision
     * floats) from the stream according to the current byte order,
     * and stores them into &lt;code&gt;d&lt;/code&gt; starting at
     * index &lt;code&gt;off&lt;/code&gt;.  If the end of the stream is reached,
     * an &lt;code&gt;java.io.EOFException&lt;/code&gt; will be thrown.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @param d an array of doubles to be written to.
     * @param off the starting position within &lt;code&gt;d&lt;/code&gt; to write to.
     * @param len the maximum number of &lt;code&gt;double&lt;/code&gt;s to read.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;d.length&lt;/code&gt;.
     * @exception NullPointerException if &lt;code&gt;d&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bytes.
     * @exception IOException if an I/O error occurs.
     */
    void readFully(double[] d, int off, int len) throws IOException;

    /**
     * Returns the current byte position of the stream.  The next read
     * will take place starting at this offset.
     *
     * @return a long containing the position of the stream.
     *
     * @exception IOException if an I/O error occurs.
     */
    long getStreamPosition() throws IOException;

    /**
     * Returns the current bit offset, as an integer between 0 and 7,
     * inclusive.  The bit offset is updated implicitly by calls to
     * the &lt;code&gt;readBits&lt;/code&gt; method.  A value of 0 indicates the
     * most-significant bit, and a value of 7 indicates the least
     * significant bit, of the byte being read.
     *
     * &lt;p&gt; The bit offset is set to 0 when a stream is first
     * opened, and is reset to 0 by calls to &lt;code&gt;seek&lt;/code&gt;,
     * &lt;code&gt;skipBytes&lt;/code&gt;, or any &lt;code&gt;read&lt;/code&gt; or
     * &lt;code&gt;readFully&lt;/code&gt; method.
     *
     * @return an &lt;code&gt;int&lt;/code&gt; containing the bit offset between
     * 0 and 7, inclusive.
     *
     * @exception IOException if an I/O error occurs.
     *
     * @see #setBitOffset
     */
    int getBitOffset() throws IOException;

    /**
     * Sets the bit offset to an integer between 0 and 7, inclusive.
     * The byte offset within the stream, as returned by
     * &lt;code&gt;getStreamPosition&lt;/code&gt;, is left unchanged.
     * A value of 0 indicates the
     * most-significant bit, and a value of 7 indicates the least
     * significant bit, of the byte being read.
     *
     * @param bitOffset the desired offset, as an &lt;code&gt;int&lt;/code&gt;
     * between 0 and 7, inclusive.
     *
     * @exception IllegalArgumentException if &lt;code&gt;bitOffset&lt;/code&gt;
     * is not between 0 and 7, inclusive.
     * @exception IOException if an I/O error occurs.
     *
     * @see #getBitOffset
     */
    void setBitOffset(int bitOffset) throws IOException;

    /**
     * Reads a single bit from the stream and returns it as an
     * &lt;code&gt;int&lt;/code&gt; with the value &lt;code&gt;0&lt;/code&gt; or
     * &lt;code&gt;1&lt;/code&gt;.  The bit offset is advanced by one and reduced
     * modulo 8.
     *
     * @return an &lt;code&gt;int&lt;/code&gt; containing the value &lt;code&gt;0&lt;/code&gt;
     * or &lt;code&gt;1&lt;/code&gt;.
     *
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bits.
     * @exception IOException if an I/O error occurs.
     */
    int readBit() throws IOException;

    /**
     * Reads a bitstring from the stream and returns it as a
     * &lt;code&gt;long&lt;/code&gt;, with the first bit read becoming the most
     * significant bit of the output.  The read starts within the byte
     * indicated by &lt;code&gt;getStreamPosition&lt;/code&gt;, at the bit given
     * by &lt;code&gt;getBitOffset&lt;/code&gt;.  The bit offset is advanced by
     * &lt;code&gt;numBits&lt;/code&gt; and reduced modulo 8.
     *
     * &lt;p&gt; The byte order of the stream has no effect on this
     * method.  The return value of this method is constructed as
     * though the bits were read one at a time, and shifted into
     * the right side of the return value, as shown by the following
     * pseudo-code:
     *
     * &lt;pre&gt;{@code
     * long accum = 0L;
     * for (int i = 0; i &lt; numBits; i++) {
     *   accum &lt;&lt;= 1; // Shift left one bit to make room
     *   accum |= readBit();
     * }
     * }&lt;/pre&gt;
     *
     * Note that the result of &lt;code&gt;readBits(32)&lt;/code&gt; may thus not
     * be equal to that of &lt;code&gt;readInt()&lt;/code&gt; if a reverse network
     * byte order is being used (i.e., &lt;code&gt;getByteOrder() ==
     * false&lt;/code&gt;).
     *
     * &lt;p&gt; If the end of the stream is encountered before all the bits
     * have been read, an &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.
     *
     * @param numBits the number of bits to read, as an &lt;code&gt;int&lt;/code&gt;
     * between 0 and 64, inclusive.
     * @return the bitstring, as a &lt;code&gt;long&lt;/code&gt; with the last bit
     * read stored in the least significant bit.
     *
     * @exception IllegalArgumentException if &lt;code&gt;numBits&lt;/code&gt;
     * is not between 0 and 64, inclusive.
     * @exception java.io.EOFException if the stream reaches the end before
     * reading all the bits.
     * @exception IOException if an I/O error occurs.
     */
    long readBits(int numBits) throws IOException;

    /**
     * Returns the total length of the stream, if known.  Otherwise,
     * &lt;code&gt;-1&lt;/code&gt; is returned.
     *
     * @return a &lt;code&gt;long&lt;/code&gt; containing the length of the
     * stream, if known, or else &lt;code&gt;-1&lt;/code&gt;.
     *
     * @exception IOException if an I/O error occurs.
     */
    long length() throws IOException;

    /**
     * Moves the stream position forward by a given number of bytes.  It
     * is possible that this method will only be able to skip forward
     * by a smaller number of bytes than requested, for example if the
     * end of the stream is reached.  In all cases, the actual number
     * of bytes skipped is returned.  The bit offset is set to zero
     * prior to advancing the position.
     *
     * @param n an &lt;code&gt;int&lt;/code&gt; containing the number of bytes to
     * be skipped.
     *
     * @return an &lt;code&gt;int&lt;/code&gt; representing the number of bytes skipped.
     *
     * @exception IOException if an I/O error occurs.
     */
    int skipBytes(int n) throws IOException;

    /**
     * Moves the stream position forward by a given number of bytes.
     * This method is identical to &lt;code&gt;skipBytes(int)&lt;/code&gt; except
     * that it allows for a larger skip distance.
     *
     * @param n a &lt;code&gt;long&lt;/code&gt; containing the number of bytes to
     * be skipped.
     *
     * @return a &lt;code&gt;long&lt;/code&gt; representing the number of bytes
     * skipped.
     *
     * @exception IOException if an I/O error occurs.
     */
    long skipBytes(long n) throws IOException;

    /**
     * Sets the current stream position to the desired location.  The
     * next read will occur at this location.  The bit offset is set
     * to 0.
     *
     * &lt;p&gt; An &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; will be thrown if
     * &lt;code&gt;pos&lt;/code&gt; is smaller than the flushed position (as
     * returned by &lt;code&gt;getflushedPosition&lt;/code&gt;).
     *
     * &lt;p&gt; It is legal to seek past the end of the file; an
     * &lt;code&gt;java.io.EOFException&lt;/code&gt; will be thrown only if a read is
     * performed.
     *
     * @param pos a &lt;code&gt;long&lt;/code&gt; containing the desired file
     * pointer position.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;pos&lt;/code&gt; is smaller
     * than the flushed position.
     * @exception IOException if any other I/O error occurs.
     */
    void seek(long pos) throws IOException;

    /**
     * Marks a position in the stream to be returned to by a
     * subsequent call to &lt;code&gt;reset&lt;/code&gt;.  Unlike a standard
     * &lt;code&gt;InputStream&lt;/code&gt;, all &lt;code&gt;ImageInputStream&lt;/code&gt;s
     * support marking.  Additionally, calls to &lt;code&gt;mark&lt;/code&gt; and
     * &lt;code&gt;reset&lt;/code&gt; may be nested arbitrarily.
     *
     * &lt;p&gt; Unlike the &lt;code&gt;mark&lt;/code&gt; methods declared by the
     * &lt;code&gt;Reader&lt;/code&gt; and &lt;code&gt;InputStream&lt;/code&gt; interfaces, no
     * &lt;code&gt;readLimit&lt;/code&gt; parameter is used.  An arbitrary amount
     * of data may be read following the call to &lt;code&gt;mark&lt;/code&gt;.
     *
     * &lt;p&gt; The bit position used by the &lt;code&gt;readBits&lt;/code&gt; method
     * is saved and restored by each pair of calls to
     * &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt;.
     *
     * &lt;p&gt; Note that it is valid for an &lt;code&gt;ImageReader&lt;/code&gt; to call
     * &lt;code&gt;flushBefore&lt;/code&gt; as part of a read operation.
     * Therefore, if an application calls &lt;code&gt;mark&lt;/code&gt; prior to
     * passing that stream to an &lt;code&gt;ImageReader&lt;/code&gt;, the application
     * should not assume that the marked position will remain valid after
     * the read operation has completed.
     */
    void mark();

    /**
     * Returns the stream pointer to its previous position, including
     * the bit offset, at the time of the most recent unmatched call
     * to &lt;code&gt;mark&lt;/code&gt;.
     *
     * &lt;p&gt; Calls to &lt;code&gt;reset&lt;/code&gt; without a corresponding call
     * to &lt;code&gt;mark&lt;/code&gt; have no effect.
     *
     * &lt;p&gt; An &lt;code&gt;IOException&lt;/code&gt; will be thrown if the previous
     * marked position lies in the discarded portion of the stream.
     *
     * @exception IOException if an I/O error occurs.
     */
    void reset() throws IOException;

    /**
     * Discards the initial portion of the stream prior to the
     * indicated position.  Attempting to seek to an offset within the
     * flushed portion of the stream will result in an
     * &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;.
     *
     * &lt;p&gt; Calling &lt;code&gt;flushBefore&lt;/code&gt; may allow classes
     * implementing this interface to free up resources such as memory
     * or disk space that are being used to store data from the
     * stream.
     *
     * @param pos a &lt;code&gt;long&lt;/code&gt; containing the length of the
     * stream prefix that may be flushed.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;pos&lt;/code&gt; lies
     * in the flushed portion of the stream or past the current stream
     * position.
     * @exception IOException if an I/O error occurs.
     */
    void flushBefore(long pos) throws IOException;

    /**
     * Discards the initial position of the stream prior to the current
     * stream position.  Equivalent to
     * &lt;code&gt;flushBefore(getStreamPosition())&lt;/code&gt;.
     *
     * @exception IOException if an I/O error occurs.
     */
    void flush() throws IOException;

    /**
     * Returns the earliest position in the stream to which seeking
     * may be performed.  The returned value will be the maximum of
     * all values passed into previous calls to
     * &lt;code&gt;flushBefore&lt;/code&gt;.
     *
     * @return the earliest legal position for seeking, as a
     * &lt;code&gt;long&lt;/code&gt;.
     */
    long getFlushedPosition();

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;ImageInputStream&lt;/code&gt;
     * caches data itself in order to allow seeking backwards.
     * Applications may consult this in order to decide how frequently,
     * or whether, to flush in order to conserve cache resources.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;ImageInputStream&lt;/code&gt;
     * caches data.
     *
     * @see #isCachedMemory
     * @see #isCachedFile
     */
    boolean isCached();

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;ImageInputStream&lt;/code&gt;
     * caches data itself in order to allow seeking backwards, and
     * the cache is kept in main memory.  Applications may consult
     * this in order to decide how frequently, or whether, to flush
     * in order to conserve cache resources.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;ImageInputStream&lt;/code&gt;
     * caches data in main memory.
     *
     * @see #isCached
     * @see #isCachedFile
     */
    boolean isCachedMemory();

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;ImageInputStream&lt;/code&gt;
     * caches data itself in order to allow seeking backwards, and
     * the cache is kept in a temporary file.  Applications may consult
     * this in order to decide how frequently, or whether, to flush
     * in order to conserve cache resources.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;ImageInputStream&lt;/code&gt;
     * caches data in a temporary file.
     *
     * @see #isCached
     * @see #isCachedMemory
     */
    boolean isCachedFile();

    /**
     * Closes the stream.  Attempts to access a stream that has been
     * closed may result in &lt;code&gt;IOException&lt;/code&gt;s or incorrect
     * behavior.  Calling this method may allow classes implementing
     * this interface to release resources associated with the stream
     * such as memory, disk space, or file descriptors.
     *
     * @exception IOException if an I/O error occurs.
     */
    void close() throws IOException;
}
</pre>
</body>
</html>
