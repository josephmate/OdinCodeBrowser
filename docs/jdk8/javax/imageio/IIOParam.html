<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.imageio;

import java.awt.Point;
import java.awt.Rectangle;

/**
 * A superclass of all classes describing how streams should be
 * decoded or encoded.  This class contains all the variables and
 * methods that are shared by &lt;code&gt;ImageReadParam&lt;/code&gt; and
 * &lt;code&gt;ImageWriteParam&lt;/code&gt;.
 *
 * &lt;p&gt; This class provides mechanisms to specify a source region and a
 * destination region.  When reading, the source is the stream and
 * the in-memory image is the destination.  When writing, these are
 * reversed.  In the case of writing, destination regions may be used
 * only with a writer that supports pixel replacement.
 * &lt;p&gt;
 * Decimation subsampling may be specified for both readers
 * and writers, using a movable subsampling grid.
 * &lt;p&gt;
 * Subsets of the source and destination bands may be selected.
 *
 */
public abstract class IIOParam {

    /**
     * The source region, on &lt;code&gt;null&lt;/code&gt; if none is set.
     */
    protected Rectangle sourceRegion = null;

    /**
     * The decimation subsampling to be applied in the horizontal
     * direction.  By default, the value is &lt;code&gt;1&lt;/code&gt;.
     * The value must not be negative or 0.
     */
    protected int sourceXSubsampling = 1;

    /**
     * The decimation subsampling to be applied in the vertical
     * direction.  By default, the value is &lt;code&gt;1&lt;/code&gt;.
     * The value must not be negative or 0.
     */
    protected int sourceYSubsampling = 1;

    /**
     * A horizontal offset to be applied to the subsampling grid before
     * subsampling.  The first pixel to be used will be offset this
     * amount from the origin of the region, or of the image if no
     * region is specified.
     */
    protected int subsamplingXOffset = 0;

    /**
     * A vertical offset to be applied to the subsampling grid before
     * subsampling.  The first pixel to be used will be offset this
     * amount from the origin of the region, or of the image if no
     * region is specified.
     */
    protected int subsamplingYOffset = 0;

    /**
     * An array of &lt;code&gt;int&lt;/code&gt;s indicating which source bands
     * will be used, or &lt;code&gt;null&lt;/code&gt;.  If &lt;code&gt;null&lt;/code&gt;, the
     * set of source bands to be used is as described in the comment
     * for the &lt;code&gt;setSourceBands&lt;/code&gt; method.  No value should
     * be allowed to be negative.
     */
    protected int[] sourceBands = null;

    /**
     * An &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; to be used to generate a
     * destination image when reading, or to set the output color type
     * when writing.  If non has been set the value will be
     * &lt;code&gt;null&lt;/code&gt;.  By default, the value is &lt;code&gt;null&lt;/code&gt;.
     */
    protected ImageTypeSpecifier destinationType = null;

    /**
     * The offset in the destination where the upper-left decoded
     * pixel should be placed.  By default, the value is (0, 0).
     */
    protected Point destinationOffset = new Point(0, 0);

    /**
     * The default &lt;code&gt;IIOParamController&lt;/code&gt; that will be
     * used to provide settings for this &lt;code&gt;IIOParam&lt;/code&gt;
     * object when the &lt;code&gt;activateController&lt;/code&gt; method
     * is called.  This default should be set by subclasses
     * that choose to provide their own default controller,
     * usually a GUI, for setting parameters.
     *
     * @see IIOParamController
     * @see #getDefaultController
     * @see #activateController
     */
    protected IIOParamController defaultController = null;

    /**
     * The &lt;code&gt;IIOParamController&lt;/code&gt; that will be
     * used to provide settings for this &lt;code&gt;IIOParam&lt;/code&gt;
     * object when the &lt;code&gt;activateController&lt;/code&gt; method
     * is called.  This value overrides any default controller,
     * even when null.
     *
     * @see IIOParamController
     * @see #setController(IIOParamController)
     * @see #hasController()
     * @see #activateController()
     */
    protected IIOParamController controller = null;

    /**
     * Protected constructor may be called only by subclasses.
     */
    protected IIOParam() {
        controller = defaultController;
    }

    /**
     * Sets the source region of interest.  The region of interest is
     * described as a rectangle, with the upper-left corner of the
     * source image as pixel (0, 0) and increasing values down and to
     * the right.  The actual number of pixels used will depend on
     * the subsampling factors set by &lt;code&gt;setSourceSubsampling&lt;/code&gt;.
     * If subsampling has been set such that this number is zero,
     * an &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
     *
     * &lt;p&gt; The source region of interest specified by this method will
     * be clipped as needed to fit within the source bounds, as well
     * as the destination offsets, width, and height at the time of
     * actual I/O.
     *
     * &lt;p&gt; A value of &lt;code&gt;null&lt;/code&gt; for &lt;code&gt;sourceRegion&lt;/code&gt;
     * will remove any region specification, causing the entire image
     * to be used.
     *
     * @param sourceRegion a &lt;code&gt;Rectangle&lt;/code&gt; specifying the
     * source region of interest, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception IllegalArgumentException if
     * &lt;code&gt;sourceRegion&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt; and either
     * &lt;code&gt;sourceRegion.x&lt;/code&gt; or &lt;code&gt;sourceRegion.y&lt;/code&gt; is
     * negative.
     * @exception IllegalArgumentException if
     * &lt;code&gt;sourceRegion&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt; and either
     * &lt;code&gt;sourceRegion.width&lt;/code&gt; or
     * &lt;code&gt;sourceRegion.height&lt;/code&gt; is negative or 0.
     * @exception IllegalStateException if subsampling is such that
     * this region will have a subsampled width or height of zero.
     *
     * @see #getSourceRegion
     * @see #setSourceSubsampling
     * @see ImageReadParam#setDestinationOffset
     * @see ImageReadParam#getDestinationOffset
     */
    public void setSourceRegion(Rectangle sourceRegion) {
        if (sourceRegion == null) {
            this.sourceRegion = null;
            return;
        }

        if (sourceRegion.x &lt; 0) {
            throw new IllegalArgumentException(&quot;sourceRegion.x &lt; 0!&quot;);
        }
        if (sourceRegion.y &lt; 0){
            throw new IllegalArgumentException(&quot;sourceRegion.y &lt; 0!&quot;);
        }
        if (sourceRegion.width &lt;= 0) {
            throw new IllegalArgumentException(&quot;sourceRegion.width &lt;= 0!&quot;);
        }
        if (sourceRegion.height &lt;= 0) {
            throw new IllegalArgumentException(&quot;sourceRegion.height &lt;= 0!&quot;);
        }

        // Throw an IllegalStateException if region falls between subsamples
        if (sourceRegion.width &lt;= subsamplingXOffset) {
            throw new IllegalStateException
                (&quot;sourceRegion.width &lt;= subsamplingXOffset!&quot;);
        }
        if (sourceRegion.height &lt;= subsamplingYOffset) {
            throw new IllegalStateException
                (&quot;sourceRegion.height &lt;= subsamplingYOffset!&quot;);
        }

        this.sourceRegion = (Rectangle)sourceRegion.clone();
    }

    /**
     * Returns the source region to be used.  The returned value is
     * that set by the most recent call to
     * &lt;code&gt;setSourceRegion&lt;/code&gt;, and will be &lt;code&gt;null&lt;/code&gt; if
     * there is no region set.
     *
     * @return the source region of interest as a
     * &lt;code&gt;Rectangle&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @see #setSourceRegion
     */
    public Rectangle getSourceRegion() {
        if (sourceRegion == null) {
            return null;
        }
        return (Rectangle)sourceRegion.clone();
    }

    /**
     * Specifies a decimation subsampling to apply on I/O.  The
     * &lt;code&gt;sourceXSubsampling&lt;/code&gt; and
     * &lt;code&gt;sourceYSubsampling&lt;/code&gt; parameters specify the
     * subsampling period (&lt;i&gt;i.e.&lt;/i&gt;, the number of rows and columns
     * to advance after every source pixel).  Specifically, a period of
     * 1 will use every row or column; a period of 2 will use every
     * other row or column.  The &lt;code&gt;subsamplingXOffset&lt;/code&gt; and
     * &lt;code&gt;subsamplingYOffset&lt;/code&gt; parameters specify an offset
     * from the region (or image) origin for the first subsampled pixel.
     * Adjusting the origin of the subsample grid is useful for avoiding
     * seams when subsampling a very large source image into destination
     * regions that will be assembled into a complete subsampled image.
     * Most users will want to simply leave these parameters at 0.
     *
     * &lt;p&gt; The number of pixels and scanlines to be used are calculated
     * as follows.
     * &lt;p&gt;
     * The number of subsampled pixels in a scanline is given by
     * &lt;p&gt;
     * &lt;code&gt;truncate[(width - subsamplingXOffset + sourceXSubsampling - 1)
     * / sourceXSubsampling]&lt;/code&gt;.
     * &lt;p&gt;
     * If the region is such that this width is zero, an
     * &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     * &lt;p&gt;
     * The number of scanlines to be used can be computed similarly.
     *
     * &lt;p&gt;The ability to set the subsampling grid to start somewhere
     * other than the source region origin is useful if the
     * region is being used to create subsampled tiles of a large image,
     * where the tile width and height are not multiples of the
     * subsampling periods.  If the subsampling grid does not remain
     * consistent from tile to tile, there will be artifacts at the tile
     * boundaries.  By adjusting the subsampling grid offset for each
     * tile to compensate, these artifacts can be avoided.  The tradeoff
     * is that in order to avoid these artifacts, the tiles are not all
     * the same size.  The grid offset to use in this case is given by:
     * &lt;br&gt;
     * grid offset = [period - (region offset modulo period)] modulo period)
     *
     * &lt;p&gt; If either &lt;code&gt;sourceXSubsampling&lt;/code&gt; or
     * &lt;code&gt;sourceYSubsampling&lt;/code&gt; is 0 or negative, an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.
     *
     * &lt;p&gt; If either &lt;code&gt;subsamplingXOffset&lt;/code&gt; or
     * &lt;code&gt;subsamplingYOffset&lt;/code&gt; is negative or greater than or
     * equal to the corresponding period, an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.
     *
     * &lt;p&gt; There is no &lt;code&gt;unsetSourceSubsampling&lt;/code&gt; method;
     * simply call &lt;code&gt;setSourceSubsampling(1, 1, 0, 0)&lt;/code&gt; to
     * restore default values.
     *
     * @param sourceXSubsampling the number of columns to advance
     * between pixels.
     * @param sourceYSubsampling the number of rows to advance between
     * pixels.
     * @param subsamplingXOffset the horizontal offset of the first subsample
     * within the region, or within the image if no region is set.
     * @param subsamplingYOffset the horizontal offset of the first subsample
     * within the region, or within the image if no region is set.
     * @exception IllegalArgumentException if either period is
     * negative or 0, or if either grid offset is negative or greater than
     * the corresponding period.
     * @exception IllegalStateException if the source region is such that
     * the subsampled output would contain no pixels.
     */
    public void setSourceSubsampling(int sourceXSubsampling,
                                     int sourceYSubsampling,
                                     int subsamplingXOffset,
                                     int subsamplingYOffset) {
        if (sourceXSubsampling &lt;= 0) {
            throw new IllegalArgumentException(&quot;sourceXSubsampling &lt;= 0!&quot;);
        }
        if (sourceYSubsampling &lt;= 0) {
            throw new IllegalArgumentException(&quot;sourceYSubsampling &lt;= 0!&quot;);
        }
        if (subsamplingXOffset &lt; 0 ||
            subsamplingXOffset &gt;= sourceXSubsampling) {
            throw new IllegalArgumentException
                (&quot;subsamplingXOffset out of range!&quot;);
        }
        if (subsamplingYOffset &lt; 0 ||
            subsamplingYOffset &gt;= sourceYSubsampling) {
            throw new IllegalArgumentException
                (&quot;subsamplingYOffset out of range!&quot;);
        }

        // Throw an IllegalStateException if region falls between subsamples
        if (sourceRegion != null) {
            if (subsamplingXOffset &gt;= sourceRegion.width ||
                subsamplingYOffset &gt;= sourceRegion.height) {
                throw new IllegalStateException(&quot;region contains no pixels!&quot;);
            }
        }

        this.sourceXSubsampling = sourceXSubsampling;
        this.sourceYSubsampling = sourceYSubsampling;
        this.subsamplingXOffset = subsamplingXOffset;
        this.subsamplingYOffset = subsamplingYOffset;
    }

    /**
     * Returns the number of source columns to advance for each pixel.
     *
     * &lt;p&gt;If &lt;code&gt;setSourceSubsampling&lt;/code&gt; has not been called, 1
     * is returned (which is the correct value).
     *
     * @return the source subsampling X period.
     *
     * @see #setSourceSubsampling
     * @see #getSourceYSubsampling
     */
    public int getSourceXSubsampling() {
        return sourceXSubsampling;
    }

    /**
     * Returns the number of rows to advance for each pixel.
     *
     * &lt;p&gt;If &lt;code&gt;setSourceSubsampling&lt;/code&gt; has not been called, 1
     * is returned (which is the correct value).
     *
     * @return the source subsampling Y period.
     *
     * @see #setSourceSubsampling
     * @see #getSourceXSubsampling
     */
    public int getSourceYSubsampling() {
        return sourceYSubsampling;
    }

    /**
     * Returns the horizontal offset of the subsampling grid.
     *
     * &lt;p&gt;If &lt;code&gt;setSourceSubsampling&lt;/code&gt; has not been called, 0
     * is returned (which is the correct value).
     *
     * @return the source subsampling grid X offset.
     *
     * @see #setSourceSubsampling
     * @see #getSubsamplingYOffset
     */
    public int getSubsamplingXOffset() {
        return subsamplingXOffset;
    }

    /**
     * Returns the vertical offset of the subsampling grid.
     *
     * &lt;p&gt;If &lt;code&gt;setSourceSubsampling&lt;/code&gt; has not been called, 0
     * is returned (which is the correct value).
     *
     * @return the source subsampling grid Y offset.
     *
     * @see #setSourceSubsampling
     * @see #getSubsamplingXOffset
     */
    public int getSubsamplingYOffset() {
        return subsamplingYOffset;
    }

    /**
     * Sets the indices of the source bands to be used.  Duplicate
     * indices are not allowed.
     *
     * &lt;p&gt; A &lt;code&gt;null&lt;/code&gt; value indicates that all source bands
     * will be used.
     *
     * &lt;p&gt; At the time of reading, an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown by the
     * reader or writer if a value larger than the largest available
     * source band index has been specified or if the number of source
     * bands and destination bands to be used differ.  The
     * &lt;code&gt;ImageReader.checkReadParamBandSettings&lt;/code&gt; method may
     * be used to automate this test.
     *
     * &lt;p&gt; Semantically, a copy is made of the array; changes to the
     * array contents subsequent to this call have no effect on
     * this &lt;code&gt;IIOParam&lt;/code&gt;.
     *
     * @param sourceBands an array of integer band indices to be
     * used.
     *
     * @exception IllegalArgumentException if &lt;code&gt;sourceBands&lt;/code&gt;
     * contains a negative or duplicate value.
     *
     * @see #getSourceBands
     * @see ImageReadParam#setDestinationBands
     * @see ImageReader#checkReadParamBandSettings
     */
    public void setSourceBands(int[] sourceBands) {
        if (sourceBands == null) {
            this.sourceBands = null;
        } else {
            int numBands = sourceBands.length;
            for (int i = 0; i &lt; numBands; i++) {
                int band = sourceBands[i];
                if (band &lt; 0) {
                    throw new IllegalArgumentException(&quot;Band value &lt; 0!&quot;);
                }
                for (int j = i + 1; j &lt; numBands; j++) {
                    if (band == sourceBands[j]) {
                        throw new IllegalArgumentException(&quot;Duplicate band value!&quot;);
                    }
                }

            }
            this.sourceBands = (int[])(sourceBands.clone());
        }
    }

    /**
     * Returns the set of of source bands to be used. The returned
     * value is that set by the most recent call to
     * &lt;code&gt;setSourceBands&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if there have
     * been no calls to &lt;code&gt;setSourceBands&lt;/code&gt;.
     *
     * &lt;p&gt; Semantically, the array returned is a copy; changes to
     * array contents subsequent to this call have no effect on this
     * &lt;code&gt;IIOParam&lt;/code&gt;.
     *
     * @return the set of source bands to be used, or
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @see #setSourceBands
     */
    public int[] getSourceBands() {
        if (sourceBands == null) {
            return null;
        }
        return (int[])(sourceBands.clone());
    }

    /**
     * Sets the desired image type for the destination image, using an
     * &lt;code&gt;ImageTypeSpecifier&lt;/code&gt;.
     *
     * &lt;p&gt; When reading, if the layout of the destination has been set
     * using this method, each call to an &lt;code&gt;ImageReader&lt;/code&gt;
     * &lt;code&gt;read&lt;/code&gt; method will return a new
     * &lt;code&gt;BufferedImage&lt;/code&gt; using the format specified by the
     * supplied type specifier.  As a side effect, any destination
     * &lt;code&gt;BufferedImage&lt;/code&gt; set by
     * &lt;code&gt;ImageReadParam.setDestination(BufferedImage)&lt;/code&gt; will
     * no longer be set as the destination.  In other words, this
     * method may be thought of as calling
     * &lt;code&gt;setDestination((BufferedImage)null)&lt;/code&gt;.
     *
     * &lt;p&gt; When writing, the destination type maybe used to determine
     * the color type of the image.  The &lt;code&gt;SampleModel&lt;/code&gt;
     * information will be ignored, and may be &lt;code&gt;null&lt;/code&gt;.  For
     * example, a 4-banded image could represent either CMYK or RGBA
     * data.  If a destination type is set, its
     * &lt;code&gt;ColorModel&lt;/code&gt; will override any
     * &lt;code&gt;ColorModel&lt;/code&gt; on the image itself.  This is crucial
     * when &lt;code&gt;setSourceBands&lt;/code&gt; is used since the image's
     * &lt;code&gt;ColorModel&lt;/code&gt; will refer to the entire image rather
     * than to the subset of bands being written.
     *
     * @param destinationType the &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; to
     * be used to determine the destination layout and color type.
     *
     * @see #getDestinationType
     */
    public void setDestinationType(ImageTypeSpecifier destinationType) {
        this.destinationType = destinationType;
    }

    /**
     * Returns the type of image to be returned by the read, if one
     * was set by a call to
     * &lt;code&gt;setDestination(ImageTypeSpecifier)&lt;/code&gt;, as an
     * &lt;code&gt;ImageTypeSpecifier&lt;/code&gt;.  If none was set,
     * &lt;code&gt;null&lt;/code&gt; is returned.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; describing the
     * destination type, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @see #setDestinationType
     */
    public ImageTypeSpecifier getDestinationType() {
        return destinationType;
    }

    /**
     * Specifies the offset in the destination image at which future
     * decoded pixels are to be placed, when reading, or where a
     * region will be written, when writing.
     *
     * &lt;p&gt; When reading, the region to be written within the
     * destination &lt;code&gt;BufferedImage&lt;/code&gt; will start at this
     * offset and have a width and height determined by the source
     * region of interest, the subsampling parameters, and the
     * destination bounds.
     *
     * &lt;p&gt; Normal writes are not affected by this method, only writes
     * performed using &lt;code&gt;ImageWriter.replacePixels&lt;/code&gt;.  For
     * such writes, the offset specified is within the output stream
     * image whose pixels are being modified.
     *
     * &lt;p&gt; There is no &lt;code&gt;unsetDestinationOffset&lt;/code&gt; method;
     * simply call &lt;code&gt;setDestinationOffset(new Point(0, 0))&lt;/code&gt; to
     * restore default values.
     *
     * @param destinationOffset the offset in the destination, as a
     * &lt;code&gt;Point&lt;/code&gt;.
     *
     * @exception IllegalArgumentException if
     * &lt;code&gt;destinationOffset&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     *
     * @see #getDestinationOffset
     * @see ImageWriter#replacePixels
     */
    public void setDestinationOffset(Point destinationOffset) {
        if (destinationOffset == null) {
            throw new IllegalArgumentException(&quot;destinationOffset == null!&quot;);
        }
        this.destinationOffset = (Point)destinationOffset.clone();
    }

    /**
     * Returns the offset in the destination image at which pixels are
     * to be placed.
     *
     * &lt;p&gt; If &lt;code&gt;setDestinationOffsets&lt;/code&gt; has not been called,
     * a &lt;code&gt;Point&lt;/code&gt; with zero X and Y values is returned
     * (which is the correct value).
     *
     * @return the destination offset as a &lt;code&gt;Point&lt;/code&gt;.
     *
     * @see #setDestinationOffset
     */
    public Point getDestinationOffset() {
        return (Point)destinationOffset.clone();
    }

    /**
     * Sets the &lt;code&gt;IIOParamController&lt;/code&gt; to be used
     * to provide settings for this &lt;code&gt;IIOParam&lt;/code&gt;
     * object when the &lt;code&gt;activateController&lt;/code&gt; method
     * is called, overriding any default controller.  If the
     * argument is &lt;code&gt;null&lt;/code&gt;, no controller will be
     * used, including any default.  To restore the default, use
     * &lt;code&gt;setController(getDefaultController())&lt;/code&gt;.
     *
     * @param controller An appropriate
     * &lt;code&gt;IIOParamController&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @see IIOParamController
     * @see #getController
     * @see #getDefaultController
     * @see #hasController
     * @see #activateController()
     */
    public void setController(IIOParamController controller) {
        this.controller = controller;
    }

    /**
     * Returns whatever &lt;code&gt;IIOParamController&lt;/code&gt; is currently
     * installed.  This could be the default if there is one,
     * &lt;code&gt;null&lt;/code&gt;, or the argument of the most recent call
     * to &lt;code&gt;setController&lt;/code&gt;.
     *
     * @return the currently installed
     * &lt;code&gt;IIOParamController&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @see IIOParamController
     * @see #setController
     * @see #getDefaultController
     * @see #hasController
     * @see #activateController()
     */
    public IIOParamController getController() {
        return controller;
    }

    /**
     * Returns the default &lt;code&gt;IIOParamController&lt;/code&gt;, if there
     * is one, regardless of the currently installed controller.  If
     * there is no default controller, returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @return the default &lt;code&gt;IIOParamController&lt;/code&gt;, or
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @see IIOParamController
     * @see #setController(IIOParamController)
     * @see #getController
     * @see #hasController
     * @see #activateController()
     */
    public IIOParamController getDefaultController() {
        return defaultController;
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if there is a controller installed
     * for this &lt;code&gt;IIOParam&lt;/code&gt; object.  This will return
     * &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;getController&lt;/code&gt; would not
     * return &lt;code&gt;null&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if a controller is installed.
     *
     * @see IIOParamController
     * @see #setController(IIOParamController)
     * @see #getController
     * @see #getDefaultController
     * @see #activateController()
     */
    public boolean hasController() {
        return (controller != null);
    }

    /**
     * Activates the installed &lt;code&gt;IIOParamController&lt;/code&gt; for
     * this &lt;code&gt;IIOParam&lt;/code&gt; object and returns the resulting
     * value.  When this method returns &lt;code&gt;true&lt;/code&gt;, all values
     * for this &lt;code&gt;IIOParam&lt;/code&gt; object will be ready for the
     * next read or write operation.  If &lt;code&gt;false&lt;/code&gt; is
     * returned, no settings in this object will have been disturbed
     * (&lt;i&gt;i.e.&lt;/i&gt;, the user canceled the operation).
     *
     * &lt;p&gt; Ordinarily, the controller will be a GUI providing a user
     * interface for a subclass of &lt;code&gt;IIOParam&lt;/code&gt; for a
     * particular plug-in.  Controllers need not be GUIs, however.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the controller completed normally.
     *
     * @exception IllegalStateException if there is no controller
     * currently installed.
     *
     * @see IIOParamController
     * @see #setController(IIOParamController)
     * @see #getController
     * @see #getDefaultController
     * @see #hasController
     */
    public boolean activateController() {
        if (!hasController()) {
            throw new IllegalStateException(&quot;hasController() == false!&quot;);
        }
        return getController().activate(this);
    }
}
</pre>
</body>
</html>
