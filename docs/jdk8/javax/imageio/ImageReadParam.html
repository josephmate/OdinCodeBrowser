<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.imageio;

import java.awt.Dimension;
import java.awt.image.BufferedImage;

/**
 * A class describing how a stream is to be decoded.  Instances of
 * this class or its subclasses are used to supply prescriptive
 * &quot;how-to&quot; information to instances of &lt;code&gt;ImageReader&lt;/code&gt;.
 *
 * &lt;p&gt; An image encoded as part of a file or stream may be thought of
 * extending out in multiple dimensions: the spatial dimensions of
 * width and height, a number of bands, and a number of progressive
 * decoding passes.  This class allows a contiguous (hyper)rectangular
 * subarea of the image in all of these dimensions to be selected for
 * decoding.  Additionally, the spatial dimensions may be subsampled
 * discontinuously.  Finally, color and format conversions may be
 * specified by controlling the &lt;code&gt;ColorModel&lt;/code&gt; and
 * &lt;code&gt;SampleModel&lt;/code&gt; of the destination image, either by
 * providing a &lt;code&gt;BufferedImage&lt;/code&gt; or by using an
 * &lt;code&gt;ImageTypeSpecifier&lt;/code&gt;.
 *
 * &lt;p&gt; An &lt;code&gt;ImageReadParam&lt;/code&gt; object is used to specify how an
 * image, or a set of images, will be converted on input from
 * a stream in the context of the Java Image I/O framework.  A plug-in for a
 * specific image format will return instances of
 * &lt;code&gt;ImageReadParam&lt;/code&gt; from the
 * &lt;code&gt;getDefaultReadParam&lt;/code&gt; method of its
 * &lt;code&gt;ImageReader&lt;/code&gt; implementation.
 *
 * &lt;p&gt; The state maintained by an instance of
 * &lt;code&gt;ImageReadParam&lt;/code&gt; is independent of any particular image
 * being decoded.  When actual decoding takes place, the values set in
 * the read param are combined with the actual properties of the image
 * being decoded from the stream and the destination
 * &lt;code&gt;BufferedImage&lt;/code&gt; that will receive the decoded pixel
 * data.  For example, the source region set using
 * &lt;code&gt;setSourceRegion&lt;/code&gt; will first be intersected with the
 * actual valid source area.  The result will be translated by the
 * value returned by &lt;code&gt;getDestinationOffset&lt;/code&gt;, and the
 * resulting rectangle intersected with the actual valid destination
 * area to yield the destination area that will be written.
 *
 * &lt;p&gt; The parameters specified by an &lt;code&gt;ImageReadParam&lt;/code&gt; are
 * applied to an image as follows.  First, if a rendering size has
 * been set by &lt;code&gt;setSourceRenderSize&lt;/code&gt;, the entire decoded
 * image is rendered at the size given by
 * &lt;code&gt;getSourceRenderSize&lt;/code&gt;.  Otherwise, the image has its
 * natural size given by &lt;code&gt;ImageReader.getWidth&lt;/code&gt; and
 * &lt;code&gt;ImageReader.getHeight&lt;/code&gt;.
 *
 * &lt;p&gt; Next, the image is clipped against the source region
 * specified by &lt;code&gt;getSourceXOffset&lt;/code&gt;, &lt;code&gt;getSourceYOffset&lt;/code&gt;,
 * &lt;code&gt;getSourceWidth&lt;/code&gt;, and &lt;code&gt;getSourceHeight&lt;/code&gt;.
 *
 * &lt;p&gt; The resulting region is then subsampled according to the
 * factors given in {@link IIOParam#setSourceSubsampling
 * IIOParam.setSourceSubsampling}.  The first pixel,
 * the number of pixels per row, and the number of rows all depend
 * on the subsampling settings.
 * Call the minimum X and Y coordinates of the resulting rectangle
 * (&lt;code&gt;minX&lt;/code&gt;, &lt;code&gt;minY&lt;/code&gt;), its width &lt;code&gt;w&lt;/code&gt;
 * and its height &lt;code&gt;h&lt;/code&gt;.
 *
 * &lt;p&gt; This rectangle is offset by
 * (&lt;code&gt;getDestinationOffset().x&lt;/code&gt;,
 * &lt;code&gt;getDestinationOffset().y&lt;/code&gt;) and clipped against the
 * destination bounds.  If no destination image has been set, the
 * destination is defined to have a width of
 * &lt;code&gt;getDestinationOffset().x&lt;/code&gt; + &lt;code&gt;w&lt;/code&gt;, and a
 * height of &lt;code&gt;getDestinationOffset().y&lt;/code&gt; + &lt;code&gt;h&lt;/code&gt; so
 * that all pixels of the source region may be written to the
 * destination.
 *
 * &lt;p&gt; Pixels that land, after subsampling, within the destination
 * image, and that are written in one of the progressive passes
 * specified by &lt;code&gt;getSourceMinProgressivePass&lt;/code&gt; and
 * &lt;code&gt;getSourceNumProgressivePasses&lt;/code&gt; are passed along to the
 * next step.
 *
 * &lt;p&gt; Finally, the source samples of each pixel are mapped into
 * destination bands according to the algorithm described in the
 * comment for &lt;code&gt;setDestinationBands&lt;/code&gt;.
 *
 * &lt;p&gt; Plug-in writers may extend the functionality of
 * &lt;code&gt;ImageReadParam&lt;/code&gt; by providing a subclass that implements
 * additional, plug-in specific interfaces.  It is up to the plug-in
 * to document what interfaces are available and how they are to be
 * used.  Readers will silently ignore any extended features of an
 * &lt;code&gt;ImageReadParam&lt;/code&gt; subclass of which they are not aware.
 * Also, they may ignore any optional features that they normally
 * disable when creating their own &lt;code&gt;ImageReadParam&lt;/code&gt;
 * instances via &lt;code&gt;getDefaultReadParam&lt;/code&gt;.
 *
 * &lt;p&gt; Note that unless a query method exists for a capability, it must
 * be supported by all &lt;code&gt;ImageReader&lt;/code&gt; implementations
 * (&lt;i&gt;e.g.&lt;/i&gt; source render size is optional, but subsampling must be
 * supported).
 *
 *
 * @see ImageReader
 * @see ImageWriter
 * @see ImageWriteParam
 */
public class ImageReadParam extends IIOParam {

    /**
     * &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;ImageReadParam&lt;/code&gt; allows
     * the source rendering dimensions to be set.  By default, the
     * value is &lt;code&gt;false&lt;/code&gt;.  Subclasses must set this value
     * manually.
     *
     * &lt;p&gt; &lt;code&gt;ImageReader&lt;/code&gt;s that do not support setting of
     * the source render size should set this value to
     * &lt;code&gt;false&lt;/code&gt;.
     */
    protected boolean canSetSourceRenderSize = false;

    /**
     * The desired rendering width and height of the source, if
     * &lt;code&gt;canSetSourceRenderSize&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, or
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * &lt;p&gt; &lt;code&gt;ImageReader&lt;/code&gt;s that do not support setting of
     * the source render size may ignore this value.
     */
    protected Dimension sourceRenderSize = null;

    /**
     * The current destination &lt;code&gt;BufferedImage&lt;/code&gt;, or
     * &lt;code&gt;null&lt;/code&gt; if none has been set.  By default, the value
     * is &lt;code&gt;null&lt;/code&gt;.
     */
    protected BufferedImage destination = null;

    /**
     * The set of destination bands to be used, as an array of
     * &lt;code&gt;int&lt;/code&gt;s.  By default, the value is &lt;code&gt;null&lt;/code&gt;,
     * indicating all destination bands should be written in order.
     */
    protected int[] destinationBands = null;

    /**
     * The minimum index of a progressive pass to read from the
     * source.  By default, the value is set to 0, which indicates
     * that passes starting with the first available pass should be
     * decoded.
     *
     * &lt;p&gt; Subclasses should ensure that this value is
     * non-negative.
     */
    protected int minProgressivePass = 0;

    /**
     * The maximum number of progressive passes to read from the
     * source.  By default, the value is set to
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, which indicates that passes up
     * to and including the last available pass should be decoded.
     *
     * &lt;p&gt; Subclasses should ensure that this value is positive.
     * Additionally, if the value is not
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, then &lt;code&gt;minProgressivePass +
     * numProgressivePasses - 1&lt;/code&gt; should not exceed
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.
     */
    protected int numProgressivePasses = Integer.MAX_VALUE;

    /**
     * Constructs an &lt;code&gt;ImageReadParam&lt;/code&gt;.
     */
    public ImageReadParam() {}

    // Comment inherited
    public void setDestinationType(ImageTypeSpecifier destinationType) {
        super.setDestinationType(destinationType);
        setDestination(null);
    }

    /**
     * Supplies a &lt;code&gt;BufferedImage&lt;/code&gt; to be used as the
     * destination for decoded pixel data.  The currently set image
     * will be written to by the &lt;code&gt;read&lt;/code&gt;,
     * &lt;code&gt;readAll&lt;/code&gt;, and &lt;code&gt;readRaster&lt;/code&gt; methods, and
     * a reference to it will be returned by those methods.
     *
     * &lt;p&gt; Pixel data from the aforementioned methods will be written
     * starting at the offset specified by
     * &lt;code&gt;getDestinationOffset&lt;/code&gt;.
     *
     * &lt;p&gt; If &lt;code&gt;destination&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a
     * newly-created &lt;code&gt;BufferedImage&lt;/code&gt; will be returned by
     * those methods.
     *
     * &lt;p&gt; At the time of reading, the image is checked to verify that
     * its &lt;code&gt;ColorModel&lt;/code&gt; and &lt;code&gt;SampleModel&lt;/code&gt;
     * correspond to one of the &lt;code&gt;ImageTypeSpecifier&lt;/code&gt;s
     * returned from the &lt;code&gt;ImageReader&lt;/code&gt;'s
     * &lt;code&gt;getImageTypes&lt;/code&gt; method.  If it does not, the reader
     * will throw an &lt;code&gt;IIOException&lt;/code&gt;.
     *
     * @param destination the BufferedImage to be written to, or
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @see #getDestination
     */
    public void setDestination(BufferedImage destination) {
        this.destination = destination;
    }

    /**
     * Returns the &lt;code&gt;BufferedImage&lt;/code&gt; currently set by the
     * &lt;code&gt;setDestination&lt;/code&gt; method, or &lt;code&gt;null&lt;/code&gt;
     * if none is set.
     *
     * @return the BufferedImage to be written to.
     *
     * @see #setDestination
     */
    public BufferedImage getDestination() {
        return destination;
    }

    /**
     * Sets the indices of the destination bands where data
     * will be placed.  Duplicate indices are not allowed.
     *
     * &lt;p&gt; A &lt;code&gt;null&lt;/code&gt; value indicates that all destination
     * bands will be used.
     *
     * &lt;p&gt; Choosing a destination band subset will not affect the
     * number of bands in the output image of a read if no destination
     * image is specified; the created destination image will still
     * have the same number of bands as if this method had never been
     * called.  If a different number of bands in the destination
     * image is desired, an image must be supplied using the
     * &lt;code&gt;ImageReadParam.setDestination&lt;/code&gt; method.
     *
     * &lt;p&gt; At the time of reading or writing, an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown by the
     * reader or writer if a value larger than the largest destination
     * band index has been specified, or if the number of source bands
     * and destination bands to be used differ.  The
     * &lt;code&gt;ImageReader.checkReadParamBandSettings&lt;/code&gt; method may
     * be used to automate this test.
     *
     * @param destinationBands an array of integer band indices to be
     * used.
     *
     * @exception IllegalArgumentException if &lt;code&gt;destinationBands&lt;/code&gt;
     * contains a negative or duplicate value.
     *
     * @see #getDestinationBands
     * @see #getSourceBands
     * @see ImageReader#checkReadParamBandSettings
     */
    public void setDestinationBands(int[] destinationBands) {
        if (destinationBands == null) {
            this.destinationBands = null;
        } else {
            int numBands = destinationBands.length;
            for (int i = 0; i &lt; numBands; i++) {
                int band = destinationBands[i];
                if (band &lt; 0) {
                    throw new IllegalArgumentException(&quot;Band value &lt; 0!&quot;);
                }
                for (int j = i + 1; j &lt; numBands; j++) {
                    if (band == destinationBands[j]) {
                        throw new IllegalArgumentException(&quot;Duplicate band value!&quot;);
                    }
                }
            }
            this.destinationBands = (int[])destinationBands.clone();
        }
    }

    /**
     * Returns the set of band indices where data will be placed.
     * If no value has been set, &lt;code&gt;null&lt;/code&gt; is returned to
     * indicate that all destination bands will be used.
     *
     * @return the indices of the destination bands to be used,
     * or &lt;code&gt;null&lt;/code&gt;.
     *
     * @see #setDestinationBands
     */
    public int[] getDestinationBands() {
        if (destinationBands == null) {
            return null;
        } else {
            return (int[])(destinationBands.clone());
        }
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this reader allows the source
     * image to be rendered at an arbitrary size as part of the
     * decoding process, by means of the
     * &lt;code&gt;setSourceRenderSize&lt;/code&gt; method.  If this method
     * returns &lt;code&gt;false&lt;/code&gt;, calls to
     * &lt;code&gt;setSourceRenderSize&lt;/code&gt; will throw an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if setting source rendering size is
     * supported.
     *
     * @see #setSourceRenderSize
     */
    public boolean canSetSourceRenderSize() {
        return canSetSourceRenderSize;
    }

    /**
     * If the image is able to be rendered at an arbitrary size, sets
     * the source width and height to the supplied values.  Note that
     * the values returned from the &lt;code&gt;getWidth&lt;/code&gt; and
     * &lt;code&gt;getHeight&lt;/code&gt; methods on &lt;code&gt;ImageReader&lt;/code&gt; are
     * not affected by this method; they will continue to return the
     * default size for the image.  Similarly, if the image is also
     * tiled the tile width and height are given in terms of the default
     * size.
     *
     * &lt;p&gt; Typically, the width and height should be chosen such that
     * the ratio of width to height closely approximates the aspect
     * ratio of the image, as returned from
     * &lt;code&gt;ImageReader.getAspectRatio&lt;/code&gt;.
     *
     * &lt;p&gt; If this plug-in does not allow the rendering size to be
     * set, an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be
     * thrown.
     *
     * &lt;p&gt; To remove the render size setting, pass in a value of
     * &lt;code&gt;null&lt;/code&gt; for &lt;code&gt;size&lt;/code&gt;.
     *
     * @param size a &lt;code&gt;Dimension&lt;/code&gt; indicating the desired
     * width and height.
     *
     * @exception IllegalArgumentException if either the width or the
     * height is negative or 0.
     * @exception UnsupportedOperationException if image resizing
     * is not supported by this plug-in.
     *
     * @see #getSourceRenderSize
     * @see ImageReader#getWidth
     * @see ImageReader#getHeight
     * @see ImageReader#getAspectRatio
     */
    public void setSourceRenderSize(Dimension size)
        throws UnsupportedOperationException {
        if (!canSetSourceRenderSize()) {
            throw new UnsupportedOperationException
                (&quot;Can't set source render size!&quot;);
        }

        if (size == null) {
            this.sourceRenderSize = null;
        } else {
            if (size.width &lt;= 0 || size.height &lt;= 0) {
                throw new IllegalArgumentException(&quot;width or height &lt;= 0!&quot;);
            }
            this.sourceRenderSize = (Dimension)size.clone();
        }
    }

    /**
     * Returns the width and height of the source image as it
     * will be rendered during decoding, if they have been set via the
     * &lt;code&gt;setSourceRenderSize&lt;/code&gt; method.  A
     * &lt;code&gt;null&lt;/code&gt;value indicates that no setting has been made.
     *
     * @return the rendered width and height of the source image
     * as a &lt;code&gt;Dimension&lt;/code&gt;.
     *
     * @see #setSourceRenderSize
     */
    public Dimension getSourceRenderSize() {
        return (sourceRenderSize == null) ?
            null : (Dimension)sourceRenderSize.clone();
    }

    /**
     * Sets the range of progressive passes that will be decoded.
     * Passes outside of this range will be ignored.
     *
     * &lt;p&gt; A progressive pass is a re-encoding of the entire image,
     * generally at progressively higher effective resolutions, but
     * requiring greater transmission bandwidth.  The most common use
     * of progressive encoding is found in the JPEG format, where
     * successive passes include more detailed representations of the
     * high-frequency image content.
     *
     * &lt;p&gt; The actual number of passes to be decoded is determined
     * during decoding, based on the number of actual passes available
     * in the stream.  Thus if &lt;code&gt;minPass + numPasses - 1&lt;/code&gt; is
     * larger than the index of the last available passes, decoding
     * will end with that pass.
     *
     * &lt;p&gt; A value of &lt;code&gt;numPasses&lt;/code&gt; of
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; indicates that all passes from
     * &lt;code&gt;minPass&lt;/code&gt; forward should be read.  Otherwise, the
     * index of the last pass (&lt;i&gt;i.e.&lt;/i&gt;, &lt;code&gt;minPass + numPasses
     * - 1&lt;/code&gt;) must not exceed &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.
     *
     * &lt;p&gt; There is no &lt;code&gt;unsetSourceProgressivePasses&lt;/code&gt;
     * method; the same effect may be obtained by calling
     * &lt;code&gt;setSourceProgressivePasses(0, Integer.MAX_VALUE)&lt;/code&gt;.
     *
     * @param minPass the index of the first pass to be decoded.
     * @param numPasses the maximum number of passes to be decoded.
     *
     * @exception IllegalArgumentException if &lt;code&gt;minPass&lt;/code&gt; is
     * negative, &lt;code&gt;numPasses&lt;/code&gt; is negative or 0, or
     * &lt;code&gt;numPasses&lt;/code&gt; is smaller than
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; but &lt;code&gt;minPass +
     * numPasses - 1&lt;/code&gt; is greater than
     * &lt;code&gt;INTEGER.MAX_VALUE&lt;/code&gt;.
     *
     * @see #getSourceMinProgressivePass
     * @see #getSourceMaxProgressivePass
     */
    public void setSourceProgressivePasses(int minPass, int numPasses) {
        if (minPass &lt; 0) {
            throw new IllegalArgumentException(&quot;minPass &lt; 0!&quot;);
        }
        if (numPasses &lt;= 0) {
            throw new IllegalArgumentException(&quot;numPasses &lt;= 0!&quot;);
        }
        if ((numPasses != Integer.MAX_VALUE) &amp;&amp;
            (((minPass + numPasses - 1) &amp; 0x80000000) != 0)) {
            throw new IllegalArgumentException
                (&quot;minPass + numPasses - 1 &gt; INTEGER.MAX_VALUE!&quot;);
        }

        this.minProgressivePass = minPass;
        this.numProgressivePasses = numPasses;
    }

    /**
     * Returns the index of the first progressive pass that will be
     * decoded. If no value has been set, 0 will be returned (which is
     * the correct value).
     *
     * @return the index of the first pass that will be decoded.
     *
     * @see #setSourceProgressivePasses
     * @see #getSourceNumProgressivePasses
     */
    public int getSourceMinProgressivePass() {
        return minProgressivePass;
    }

    /**
     * If &lt;code&gt;getSourceNumProgressivePasses&lt;/code&gt; is equal to
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, returns
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.  Otherwise, returns
     * &lt;code&gt;getSourceMinProgressivePass() +
     * getSourceNumProgressivePasses() - 1&lt;/code&gt;.
     *
     * @return the index of the last pass to be read, or
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.
     */
    public int getSourceMaxProgressivePass() {
        if (numProgressivePasses == Integer.MAX_VALUE) {
            return Integer.MAX_VALUE;
        } else {
            return minProgressivePass + numProgressivePasses - 1;
        }
    }

    /**
     * Returns the number of the progressive passes that will be
     * decoded. If no value has been set,
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; will be returned (which is the
     * correct value).
     *
     * @return the number of the passes that will be decoded.
     *
     * @see #setSourceProgressivePasses
     * @see #getSourceMinProgressivePass
     */
    public int getSourceNumProgressivePasses() {
        return numProgressivePasses;
    }
}
</pre>
</body>
</html>
