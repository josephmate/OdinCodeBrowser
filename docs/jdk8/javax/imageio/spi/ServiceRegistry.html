<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.imageio.spi;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.ServiceLoader;

/**
 * A registry for service provider instances.
 *
 * &lt;p&gt; A &lt;i&gt;service&lt;/i&gt; is a well-known set of interfaces and (usually
 * abstract) classes.  A &lt;i&gt;service provider&lt;/i&gt; is a specific
 * implementation of a service.  The classes in a provider typically
 * implement the interface or subclass the class defined by the
 * service itself.
 *
 * &lt;p&gt; Service providers are stored in one or more &lt;i&gt;categories&lt;/i&gt;,
 * each of which is defined by a class of interface (described by a
 * &lt;code&gt;Class&lt;/code&gt; object) that all of its members must implement.
 * The set of categories may be changed dynamically.
 *
 * &lt;p&gt; Only a single instance of a given leaf class (that is, the
 * actual class returned by &lt;code&gt;getClass()&lt;/code&gt;, as opposed to any
 * inherited classes or interfaces) may be registered.  That is,
 * suppose that the
 * &lt;code&gt;com.mycompany.mypkg.GreenServiceProvider&lt;/code&gt; class
 * implements the &lt;code&gt;com.mycompany.mypkg.MyService&lt;/code&gt;
 * interface.  If a &lt;code&gt;GreenServiceProvider&lt;/code&gt; instance is
 * registered, it will be stored in the category defined by the
 * &lt;code&gt;MyService&lt;/code&gt; class.  If a new instance of
 * &lt;code&gt;GreenServiceProvider&lt;/code&gt; is registered, it will replace
 * the previous instance.  In practice, service provider objects are
 * usually singletons so this behavior is appropriate.
 *
 * &lt;p&gt; To declare a service provider, a &lt;code&gt;services&lt;/code&gt;
 * subdirectory is placed within the &lt;code&gt;META-INF&lt;/code&gt; directory
 * that is present in every JAR file.  This directory contains a file
 * for each service provider interface that has one or more
 * implementation classes present in the JAR file.  For example, if
 * the JAR file contained a class named
 * &lt;code&gt;com.mycompany.mypkg.MyServiceImpl&lt;/code&gt; which implements the
 * &lt;code&gt;javax.someapi.SomeService&lt;/code&gt; interface, the JAR file
 * would contain a file named: &lt;pre&gt;
 * META-INF/services/javax.someapi.SomeService &lt;/pre&gt;
 *
 * containing the line:
 *
 * &lt;pre&gt;
 * com.mycompany.mypkg.MyService
 * &lt;/pre&gt;
 *
 * &lt;p&gt; The service provider classes should be to be lightweight and
 * quick to load.  Implementations of these interfaces should avoid
 * complex dependencies on other classes and on native code. The usual
 * pattern for more complex services is to register a lightweight
 * proxy for the heavyweight service.
 *
 * &lt;p&gt; An application may customize the contents of a registry as it
 * sees fit, so long as it has the appropriate runtime permission.
 *
 * &lt;p&gt; For more details on declaring service providers, and the JAR
 * format in general, see the &lt;a
 * href=&quot;../../../../technotes/guides/jar/jar.html&quot;&gt;
 * JAR File Specification&lt;/a&gt;.
 *
 * @see RegisterableService
 *
 */
public class ServiceRegistry {

    // Class -&gt; Registry
    private Map categoryMap = new HashMap();

    /**
     * Constructs a &lt;code&gt;ServiceRegistry&lt;/code&gt; instance with a
     * set of categories taken from the &lt;code&gt;categories&lt;/code&gt;
     * argument.
     *
     * @param categories an &lt;code&gt;Iterator&lt;/code&gt; containing
     * &lt;code&gt;Class&lt;/code&gt; objects to be used to define categories.
     *
     * @exception IllegalArgumentException if
     * &lt;code&gt;categories&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     */
    public ServiceRegistry(Iterator&lt;Class&lt;?&gt;&gt; categories) {
        if (categories == null) {
            throw new IllegalArgumentException(&quot;categories == null!&quot;);
        }
        while (categories.hasNext()) {
            Class category = (Class)categories.next();
            SubRegistry reg = new SubRegistry(this, category);
            categoryMap.put(category, reg);
        }
    }

    // The following two methods expose functionality from
    // sun.misc.Service.  If that class is made public, they may be
    // removed.
    //
    // The sun.misc.ServiceConfigurationError class may also be
    // exposed, in which case the references to 'an
    // &lt;code&gt;Error&lt;/code&gt;' below should be changed to 'a
    // &lt;code&gt;ServiceConfigurationError&lt;/code&gt;'.

    /**
     * Searches for implementations of a particular service class
     * using the given class loader.
     *
     * &lt;p&gt; This method transforms the name of the given service class
     * into a provider-configuration filename as described in the
     * class comment and then uses the &lt;code&gt;getResources&lt;/code&gt;
     * method of the given class loader to find all available files
     * with that name.  These files are then read and parsed to
     * produce a list of provider-class names.  The iterator that is
     * returned uses the given class loader to look up and then
     * instantiate each element of the list.
     *
     * &lt;p&gt; Because it is possible for extensions to be installed into
     * a running Java virtual machine, this method may return
     * different results each time it is invoked.
     *
     * @param providerClass a &lt;code&gt;Class&lt;/code&gt;object indicating the
     * class or interface of the service providers being detected.
     *
     * @param loader the class loader to be used to load
     * provider-configuration files and instantiate provider classes,
     * or &lt;code&gt;null&lt;/code&gt; if the system class loader (or, failing that
     * the bootstrap class loader) is to be used.
     *
     * @param &lt;T&gt; the type of the providerClass.
     *
     * @return An &lt;code&gt;Iterator&lt;/code&gt; that yields provider objects
     * for the given service, in some arbitrary order.  The iterator
     * will throw an &lt;code&gt;Error&lt;/code&gt; if a provider-configuration
     * file violates the specified format or if a provider class
     * cannot be found and instantiated.
     *
     * @exception IllegalArgumentException if
     * &lt;code&gt;providerClass&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     */
    public static &lt;T&gt; Iterator&lt;T&gt; lookupProviders(Class&lt;T&gt; providerClass,
                                                  ClassLoader loader)
    {
        if (providerClass == null) {
            throw new IllegalArgumentException(&quot;providerClass == null!&quot;);
        }
        return ServiceLoader.load(providerClass, loader).iterator();
    }

    /**
     * Locates and incrementally instantiates the available providers
     * of a given service using the context class loader.  This
     * convenience method is equivalent to:
     *
     * &lt;pre&gt;
     *   ClassLoader cl = Thread.currentThread().getContextClassLoader();
     *   return Service.providers(service, cl);
     * &lt;/pre&gt;
     *
     * @param providerClass a &lt;code&gt;Class&lt;/code&gt;object indicating the
     * class or interface of the service providers being detected.
     *
     * @param &lt;T&gt; the type of the providerClass.
     *
     * @return An &lt;code&gt;Iterator&lt;/code&gt; that yields provider objects
     * for the given service, in some arbitrary order.  The iterator
     * will throw an &lt;code&gt;Error&lt;/code&gt; if a provider-configuration
     * file violates the specified format or if a provider class
     * cannot be found and instantiated.
     *
     * @exception IllegalArgumentException if
     * &lt;code&gt;providerClass&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     */
    public static &lt;T&gt; Iterator&lt;T&gt; lookupProviders(Class&lt;T&gt; providerClass) {
        if (providerClass == null) {
            throw new IllegalArgumentException(&quot;providerClass == null!&quot;);
        }
        return ServiceLoader.load(providerClass).iterator();
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; of &lt;code&gt;Class&lt;/code&gt; objects
     * indicating the current set of categories.  The iterator will be
     * empty if no categories exist.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing
     * &lt;code&gt;Class&lt;/code&gt;objects.
     */
    public Iterator&lt;Class&lt;?&gt;&gt; getCategories() {
        Set keySet = categoryMap.keySet();
        return keySet.iterator();
    }

    /**
     * Returns an Iterator containing the subregistries to which the
     * provider belongs.
     */
    private Iterator getSubRegistries(Object provider) {
        List l = new ArrayList();
        Iterator iter = categoryMap.keySet().iterator();
        while (iter.hasNext()) {
            Class c = (Class)iter.next();
            if (c.isAssignableFrom(provider.getClass())) {
                l.add((SubRegistry)categoryMap.get(c));
            }
        }
        return l.iterator();
    }

    /**
     * Adds a service provider object to the registry.  The provider
     * is associated with the given category.
     *
     * &lt;p&gt; If &lt;code&gt;provider&lt;/code&gt; implements the
     * &lt;code&gt;RegisterableService&lt;/code&gt; interface, its
     * &lt;code&gt;onRegistration&lt;/code&gt; method will be called.  Its
     * &lt;code&gt;onDeregistration&lt;/code&gt; method will be called each time
     * it is deregistered from a category, for example if a
     * category is removed or the registry is garbage collected.
     *
     * @param provider the service provide object to be registered.
     * @param category the category under which to register the
     * provider.
     * @param &lt;T&gt; the type of the provider.
     *
     * @return true if no provider of the same class was previously
     * registered in the same category category.
     *
     * @exception IllegalArgumentException if &lt;code&gt;provider&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if there is no category
     * corresponding to &lt;code&gt;category&lt;/code&gt;.
     * @exception ClassCastException if provider does not implement
     * the &lt;code&gt;Class&lt;/code&gt; defined by &lt;code&gt;category&lt;/code&gt;.
     */
    public &lt;T&gt; boolean registerServiceProvider(T provider,
                                               Class&lt;T&gt; category) {
        if (provider == null) {
            throw new IllegalArgumentException(&quot;provider == null!&quot;);
        }
        SubRegistry reg = (SubRegistry)categoryMap.get(category);
        if (reg == null) {
            throw new IllegalArgumentException(&quot;category unknown!&quot;);
        }
        if (!category.isAssignableFrom(provider.getClass())) {
            throw new ClassCastException();
        }

        return reg.registerServiceProvider(provider);
    }

    /**
     * Adds a service provider object to the registry.  The provider
     * is associated within each category present in the registry
     * whose &lt;code&gt;Class&lt;/code&gt; it implements.
     *
     * &lt;p&gt; If &lt;code&gt;provider&lt;/code&gt; implements the
     * &lt;code&gt;RegisterableService&lt;/code&gt; interface, its
     * &lt;code&gt;onRegistration&lt;/code&gt; method will be called once for each
     * category it is registered under.  Its
     * &lt;code&gt;onDeregistration&lt;/code&gt; method will be called each time
     * it is deregistered from a category or when the registry is
     * finalized.
     *
     * @param provider the service provider object to be registered.
     *
     * @exception IllegalArgumentException if
     * &lt;code&gt;provider&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     */
    public void registerServiceProvider(Object provider) {
        if (provider == null) {
            throw new IllegalArgumentException(&quot;provider == null!&quot;);
        }
        Iterator regs = getSubRegistries(provider);
        while (regs.hasNext()) {
            SubRegistry reg = (SubRegistry)regs.next();
            reg.registerServiceProvider(provider);
        }
    }

    /**
     * Adds a set of service provider objects, taken from an
     * &lt;code&gt;Iterator&lt;/code&gt; to the registry.  Each provider is
     * associated within each category present in the registry whose
     * &lt;code&gt;Class&lt;/code&gt; it implements.
     *
     * &lt;p&gt; For each entry of &lt;code&gt;providers&lt;/code&gt; that implements
     * the &lt;code&gt;RegisterableService&lt;/code&gt; interface, its
     * &lt;code&gt;onRegistration&lt;/code&gt; method will be called once for each
     * category it is registered under.  Its
     * &lt;code&gt;onDeregistration&lt;/code&gt; method will be called each time
     * it is deregistered from a category or when the registry is
     * finalized.
     *
     * @param providers an Iterator containing service provider
     * objects to be registered.
     *
     * @exception IllegalArgumentException if &lt;code&gt;providers&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt; or contains a &lt;code&gt;null&lt;/code&gt; entry.
     */
    public void registerServiceProviders(Iterator&lt;?&gt; providers) {
        if (providers == null) {
            throw new IllegalArgumentException(&quot;provider == null!&quot;);
        }
        while (providers.hasNext()) {
            registerServiceProvider(providers.next());
        }
    }

    /**
     * Removes a service provider object from the given category.  If
     * the provider was not previously registered, nothing happens and
     * &lt;code&gt;false&lt;/code&gt; is returned.  Otherwise, &lt;code&gt;true&lt;/code&gt;
     * is returned.  If an object of the same class as
     * &lt;code&gt;provider&lt;/code&gt; but not equal (using &lt;code&gt;==&lt;/code&gt;) to
     * &lt;code&gt;provider&lt;/code&gt; is registered, it will not be
     * deregistered.
     *
     * &lt;p&gt; If &lt;code&gt;provider&lt;/code&gt; implements the
     * &lt;code&gt;RegisterableService&lt;/code&gt; interface, its
     * &lt;code&gt;onDeregistration&lt;/code&gt; method will be called.
     *
     * @param provider the service provider object to be deregistered.
     * @param category the category from which to deregister the
     * provider.
     * @param &lt;T&gt; the type of the provider.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the provider was previously
     * registered in the same category category,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     *
     * @exception IllegalArgumentException if &lt;code&gt;provider&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if there is no category
     * corresponding to &lt;code&gt;category&lt;/code&gt;.
     * @exception ClassCastException if provider does not implement
     * the class defined by &lt;code&gt;category&lt;/code&gt;.
     */
    public &lt;T&gt; boolean deregisterServiceProvider(T provider,
                                                 Class&lt;T&gt; category) {
        if (provider == null) {
            throw new IllegalArgumentException(&quot;provider == null!&quot;);
        }
        SubRegistry reg = (SubRegistry)categoryMap.get(category);
        if (reg == null) {
            throw new IllegalArgumentException(&quot;category unknown!&quot;);
        }
        if (!category.isAssignableFrom(provider.getClass())) {
            throw new ClassCastException();
        }
        return reg.deregisterServiceProvider(provider);
    }

    /**
     * Removes a service provider object from all categories that
     * contain it.
     *
     * @param provider the service provider object to be deregistered.
     *
     * @exception IllegalArgumentException if &lt;code&gt;provider&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     */
    public void deregisterServiceProvider(Object provider) {
        if (provider == null) {
            throw new IllegalArgumentException(&quot;provider == null!&quot;);
        }
        Iterator regs = getSubRegistries(provider);
        while (regs.hasNext()) {
            SubRegistry reg = (SubRegistry)regs.next();
            reg.deregisterServiceProvider(provider);
        }
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;provider&lt;/code&gt; is currently
     * registered.
     *
     * @param provider the service provider object to be queried.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the given provider has been
     * registered.
     *
     * @exception IllegalArgumentException if &lt;code&gt;provider&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     */
    public boolean contains(Object provider) {
        if (provider == null) {
            throw new IllegalArgumentException(&quot;provider == null!&quot;);
        }
        Iterator regs = getSubRegistries(provider);
        while (regs.hasNext()) {
            SubRegistry reg = (SubRegistry)regs.next();
            if (reg.contains(provider)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; containing all registered
     * service providers in the given category.  If
     * &lt;code&gt;useOrdering&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the iterator
     * will return all of the server provider objects in an arbitrary
     * order.  Otherwise, the ordering will respect any pairwise
     * orderings that have been set.  If the graph of pairwise
     * orderings contains cycles, any providers that belong to a cycle
     * will not be returned.
     *
     * @param category the category to be retrieved from.
     * @param useOrdering &lt;code&gt;true&lt;/code&gt; if pairwise orderings
     * should be taken account in ordering the returned objects.
     * @param &lt;T&gt; the type of the category.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing service provider
     * objects from the given category, possibly in order.
     *
     * @exception IllegalArgumentException if there is no category
     * corresponding to &lt;code&gt;category&lt;/code&gt;.
     */
    public &lt;T&gt; Iterator&lt;T&gt; getServiceProviders(Class&lt;T&gt; category,
                                               boolean useOrdering) {
        SubRegistry reg = (SubRegistry)categoryMap.get(category);
        if (reg == null) {
            throw new IllegalArgumentException(&quot;category unknown!&quot;);
        }
        return reg.getServiceProviders(useOrdering);
    }

    /**
     * A simple filter interface used by
     * &lt;code&gt;ServiceRegistry.getServiceProviders&lt;/code&gt; to select
     * providers matching an arbitrary criterion.  Classes that
     * implement this interface should be defined in order to make use
     * of the &lt;code&gt;getServiceProviders&lt;/code&gt; method of
     * &lt;code&gt;ServiceRegistry&lt;/code&gt; that takes a &lt;code&gt;Filter&lt;/code&gt;.
     *
     * @see ServiceRegistry#getServiceProviders(Class, ServiceRegistry.Filter, boolean)
     */
    public interface Filter {

        /**
         * Returns &lt;code&gt;true&lt;/code&gt; if the given
         * &lt;code&gt;provider&lt;/code&gt; object matches the criterion defined
         * by this &lt;code&gt;Filter&lt;/code&gt;.
         *
         * @param provider a service provider &lt;code&gt;Object&lt;/code&gt;.
         *
         * @return true if the provider matches the criterion.
         */
        boolean filter(Object provider);
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; containing service provider
     * objects within a given category that satisfy a criterion
     * imposed by the supplied &lt;code&gt;ServiceRegistry.Filter&lt;/code&gt;
     * object's &lt;code&gt;filter&lt;/code&gt; method.
     *
     * &lt;p&gt; The &lt;code&gt;useOrdering&lt;/code&gt; argument controls the
     * ordering of the results using the same rules as
     * &lt;code&gt;getServiceProviders(Class, boolean)&lt;/code&gt;.
     *
     * @param category the category to be retrieved from.
     * @param filter an instance of &lt;code&gt;ServiceRegistry.Filter&lt;/code&gt;
     * whose &lt;code&gt;filter&lt;/code&gt; method will be invoked.
     * @param useOrdering &lt;code&gt;true&lt;/code&gt; if pairwise orderings
     * should be taken account in ordering the returned objects.
     * @param &lt;T&gt; the type of the category.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing service provider
     * objects from the given category, possibly in order.
     *
     * @exception IllegalArgumentException if there is no category
     * corresponding to &lt;code&gt;category&lt;/code&gt;.
     */
    public &lt;T&gt; Iterator&lt;T&gt; getServiceProviders(Class&lt;T&gt; category,
                                               Filter filter,
                                               boolean useOrdering) {
        SubRegistry reg = (SubRegistry)categoryMap.get(category);
        if (reg == null) {
            throw new IllegalArgumentException(&quot;category unknown!&quot;);
        }
        Iterator iter = getServiceProviders(category, useOrdering);
        return new FilterIterator(iter, filter);
    }

    /**
     * Returns the currently registered service provider object that
     * is of the given class type.  At most one object of a given
     * class is allowed to be registered at any given time.  If no
     * registered object has the desired class type, &lt;code&gt;null&lt;/code&gt;
     * is returned.
     *
     * @param providerClass the &lt;code&gt;Class&lt;/code&gt; of the desired
     * service provider object.
     * @param &lt;T&gt; the type of the provider.
     *
     * @return a currently registered service provider object with the
     * desired &lt;code&gt;Class&lt;/code&gt;type, or &lt;code&gt;null&lt;/code&gt; is none is
     * present.
     *
     * @exception IllegalArgumentException if &lt;code&gt;providerClass&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     */
    public &lt;T&gt; T getServiceProviderByClass(Class&lt;T&gt; providerClass) {
        if (providerClass == null) {
            throw new IllegalArgumentException(&quot;providerClass == null!&quot;);
        }
        Iterator iter = categoryMap.keySet().iterator();
        while (iter.hasNext()) {
            Class c = (Class)iter.next();
            if (c.isAssignableFrom(providerClass)) {
                SubRegistry reg = (SubRegistry)categoryMap.get(c);
                T provider = reg.getServiceProviderByClass(providerClass);
                if (provider != null) {
                    return provider;
                }
            }
        }
        return null;
    }

    /**
     * Sets a pairwise ordering between two service provider objects
     * within a given category.  If one or both objects are not
     * currently registered within the given category, or if the
     * desired ordering is already set, nothing happens and
     * &lt;code&gt;false&lt;/code&gt; is returned.  If the providers previously
     * were ordered in the reverse direction, that ordering is
     * removed.
     *
     * &lt;p&gt; The ordering will be used by the
     * &lt;code&gt;getServiceProviders&lt;/code&gt; methods when their
     * &lt;code&gt;useOrdering&lt;/code&gt; argument is &lt;code&gt;true&lt;/code&gt;.
     *
     * @param category a &lt;code&gt;Class&lt;/code&gt; object indicating the
     * category under which the preference is to be established.
     * @param firstProvider the preferred provider.
     * @param secondProvider the provider to which
     * &lt;code&gt;firstProvider&lt;/code&gt; is preferred.
     * @param &lt;T&gt; the type of the category.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if a previously unset ordering
     * was established.
     *
     * @exception IllegalArgumentException if either provider is
     * &lt;code&gt;null&lt;/code&gt; or they are the same object.
     * @exception IllegalArgumentException if there is no category
     * corresponding to &lt;code&gt;category&lt;/code&gt;.
     */
    public &lt;T&gt; boolean setOrdering(Class&lt;T&gt; category,
                                   T firstProvider,
                                   T secondProvider) {
        if (firstProvider == null || secondProvider == null) {
            throw new IllegalArgumentException(&quot;provider is null!&quot;);
        }
        if (firstProvider == secondProvider) {
            throw new IllegalArgumentException(&quot;providers are the same!&quot;);
        }
        SubRegistry reg = (SubRegistry)categoryMap.get(category);
        if (reg == null) {
            throw new IllegalArgumentException(&quot;category unknown!&quot;);
        }
        if (reg.contains(firstProvider) &amp;&amp;
            reg.contains(secondProvider)) {
            return reg.setOrdering(firstProvider, secondProvider);
        }
        return false;
    }

    /**
     * Sets a pairwise ordering between two service provider objects
     * within a given category.  If one or both objects are not
     * currently registered within the given category, or if no
     * ordering is currently set between them, nothing happens
     * and &lt;code&gt;false&lt;/code&gt; is returned.
     *
     * &lt;p&gt; The ordering will be used by the
     * &lt;code&gt;getServiceProviders&lt;/code&gt; methods when their
     * &lt;code&gt;useOrdering&lt;/code&gt; argument is &lt;code&gt;true&lt;/code&gt;.
     *
     * @param category a &lt;code&gt;Class&lt;/code&gt; object indicating the
     * category under which the preference is to be disestablished.
     * @param firstProvider the formerly preferred provider.
     * @param secondProvider the provider to which
     * &lt;code&gt;firstProvider&lt;/code&gt; was formerly preferred.
     * @param &lt;T&gt; the type of the category.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if a previously set ordering was
     * disestablished.
     *
     * @exception IllegalArgumentException if either provider is
     * &lt;code&gt;null&lt;/code&gt; or they are the same object.
     * @exception IllegalArgumentException if there is no category
     * corresponding to &lt;code&gt;category&lt;/code&gt;.
     */
    public &lt;T&gt; boolean unsetOrdering(Class&lt;T&gt; category,
                                     T firstProvider,
                                     T secondProvider) {
        if (firstProvider == null || secondProvider == null) {
            throw new IllegalArgumentException(&quot;provider is null!&quot;);
        }
        if (firstProvider == secondProvider) {
            throw new IllegalArgumentException(&quot;providers are the same!&quot;);
        }
        SubRegistry reg = (SubRegistry)categoryMap.get(category);
        if (reg == null) {
            throw new IllegalArgumentException(&quot;category unknown!&quot;);
        }
        if (reg.contains(firstProvider) &amp;&amp;
            reg.contains(secondProvider)) {
            return reg.unsetOrdering(firstProvider, secondProvider);
        }
        return false;
    }

    /**
     * Deregisters all service provider object currently registered
     * under the given category.
     *
     * @param category the category to be emptied.
     *
     * @exception IllegalArgumentException if there is no category
     * corresponding to &lt;code&gt;category&lt;/code&gt;.
     */
    public void deregisterAll(Class&lt;?&gt; category) {
        SubRegistry reg = (SubRegistry)categoryMap.get(category);
        if (reg == null) {
            throw new IllegalArgumentException(&quot;category unknown!&quot;);
        }
        reg.clear();
    }

    /**
     * Deregisters all currently registered service providers from all
     * categories.
     */
    public void deregisterAll() {
        Iterator iter = categoryMap.values().iterator();
        while (iter.hasNext()) {
            SubRegistry reg = (SubRegistry)iter.next();
            reg.clear();
        }
    }

    /**
     * Finalizes this object prior to garbage collection.  The
     * &lt;code&gt;deregisterAll&lt;/code&gt; method is called to deregister all
     * currently registered service providers.  This method should not
     * be called from application code.
     *
     * @exception Throwable if an error occurs during superclass
     * finalization.
     */
    public void finalize() throws Throwable {
        deregisterAll();
        super.finalize();
    }
}


/**
 * A portion of a registry dealing with a single superclass or
 * interface.
 */
class SubRegistry {

    ServiceRegistry registry;

    Class category;

    // Provider Objects organized by partial oridering
    PartiallyOrderedSet poset = new PartiallyOrderedSet();

    // Class -&gt; Provider Object of that class
    Map&lt;Class&lt;?&gt;,Object&gt; map = new HashMap();

    public SubRegistry(ServiceRegistry registry, Class category) {
        this.registry = registry;
        this.category = category;
    }

    public boolean registerServiceProvider(Object provider) {
        Object oprovider = map.get(provider.getClass());
        boolean present =  oprovider != null;

        if (present) {
            deregisterServiceProvider(oprovider);
        }
        map.put(provider.getClass(), provider);
        poset.add(provider);
        if (provider instanceof RegisterableService) {
            RegisterableService rs = (RegisterableService)provider;
            rs.onRegistration(registry, category);
        }

        return !present;
    }

    /**
     * If the provider was not previously registered, do nothing.
     *
     * @return true if the provider was previously registered.
     */
    public boolean deregisterServiceProvider(Object provider) {
        Object oprovider = map.get(provider.getClass());

        if (provider == oprovider) {
            map.remove(provider.getClass());
            poset.remove(provider);
            if (provider instanceof RegisterableService) {
                RegisterableService rs = (RegisterableService)provider;
                rs.onDeregistration(registry, category);
            }

            return true;
        }
        return false;
    }

    public boolean contains(Object provider) {
        Object oprovider = map.get(provider.getClass());
        return oprovider == provider;
    }

    public boolean setOrdering(Object firstProvider,
                               Object secondProvider) {
        return poset.setOrdering(firstProvider, secondProvider);
    }

    public boolean unsetOrdering(Object firstProvider,
                                 Object secondProvider) {
        return poset.unsetOrdering(firstProvider, secondProvider);
    }

    public Iterator getServiceProviders(boolean useOrdering) {
        if (useOrdering) {
            return poset.iterator();
        } else {
            return map.values().iterator();
        }
    }

    public &lt;T&gt; T getServiceProviderByClass(Class&lt;T&gt; providerClass) {
        return (T)map.get(providerClass);
    }

    public void clear() {
        Iterator iter = map.values().iterator();
        while (iter.hasNext()) {
            Object provider = iter.next();
            iter.remove();

            if (provider instanceof RegisterableService) {
                RegisterableService rs = (RegisterableService)provider;
                rs.onDeregistration(registry, category);
            }
        }
        poset.clear();
    }

    public void finalize() {
        clear();
    }
}


/**
 * A class for wrapping &lt;code&gt;Iterators&lt;/code&gt; with a filter function.
 * This provides an iterator for a subset without duplication.
 */
class FilterIterator&lt;T&gt; implements Iterator&lt;T&gt; {

    private Iterator&lt;T&gt; iter;
    private ServiceRegistry.Filter filter;

    private T next = null;

    public FilterIterator(Iterator&lt;T&gt; iter,
                          ServiceRegistry.Filter filter) {
        this.iter = iter;
        this.filter = filter;
        advance();
    }

    private void advance() {
        while (iter.hasNext()) {
            T elt = iter.next();
            if (filter.filter(elt)) {
                next = elt;
                return;
            }
        }

        next = null;
    }

    public boolean hasNext() {
        return next != null;
    }

    public T next() {
        if (next == null) {
            throw new NoSuchElementException();
        }
        T o = next;
        advance();
        return o;
    }

    public void remove() {
        throw new UnsupportedOperationException();
    }
}
</pre>
</body>
</html>
