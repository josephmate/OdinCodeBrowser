<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.print;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;


/**
 * Class &lt;code&gt;DocFlavor&lt;/code&gt; encapsulates an object that specifies the
 * format in which print data is supplied to a {@link DocPrintJob}.
 * &quot;Doc&quot; is a short, easy-to-pronounce term that means &quot;a piece of print data.&quot;
 * The print data format, or &quot;doc flavor&quot;, consists of two things:
 * &lt;UL&gt;
 * &lt;LI&gt;
 * &lt;B&gt;MIME type.&lt;/B&gt; This is a Multipurpose Internet Mail Extensions (MIME)
 * media type (as defined in &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC
 * 2045&lt;/A&gt; and &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;RFC 2046&lt;/A&gt;)
 * that specifies how the print data is to be interpreted.
 * The charset of text data should be the IANA MIME-preferred name, or its
 * canonical name if no preferred name is specified. Additionally a few
 * historical names supported by earlier versions of the Java platform may
 * be recognized.
 * See &lt;a href=&quot;../../java/lang/package-summary.html#charenc&quot;&gt;
 * character encodings&lt;/a&gt; for more information on the character encodings
 * supported on the Java platform.
 * &lt;P&gt;
 * &lt;LI&gt;
 * &lt;B&gt;Representation class name.&lt;/B&gt; This specifies the fully-qualified name of
 * the class of the object from which the actual print data comes, as returned
 * by the {@link java.lang.Class#getName() Class.getName()} method.
 * (Thus the class name for &lt;CODE&gt;byte[]&lt;/CODE&gt; is &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt;, for
 * &lt;CODE&gt;char[]&lt;/CODE&gt; it is &lt;CODE&gt;&quot;[C&quot;&lt;/CODE&gt;.)
 * &lt;/UL&gt;
 * &lt;P&gt;
 * A &lt;code&gt;DocPrintJob&lt;/code&gt; obtains its print data by means of interface
 * {@link Doc Doc}. A &lt;code&gt;Doc&lt;/code&gt; object lets the &lt;code&gt;DocPrintJob&lt;/code&gt;
 * determine the doc flavor the client can supply.  A &lt;code&gt;Doc&lt;/code&gt; object
 * also lets the &lt;code&gt;DocPrintJob&lt;/code&gt; obtain an instance of the doc flavor's
 * representation class, from which the &lt;code&gt;DocPrintJob&lt;/code&gt; then obtains
 * the actual print data.
 * &lt;P&gt;
 * &lt;HR&gt;
 * &lt;H3&gt;Client Formatted Print Data&lt;/H3&gt;
 * There are two broad categories of print data, client formatted print data
 * and service formatted print data.
 * &lt;P&gt;
 * For &lt;B&gt;client formatted print data&lt;/B&gt;, the client determines or knows the
 * print data format.
 * For example the client may have a JPEG encoded image, a URL for
 * HTML code, or a disk file containing plain text in some encoding,
 * possibly obtained from an external source, and
 * requires a way to describe the data format to the print service.
 * &lt;p&gt;
 * The doc flavor's representation class is a conduit for the JPS
 * &lt;code&gt;DocPrintJob&lt;/code&gt; to obtain a sequence of characters or
 * bytes from the client. The
 * doc flavor's MIME type is one of the standard media types telling how to
 * interpret the sequence of characters or bytes. For a list of standard media
 * types, see the Internet Assigned Numbers Authority's (IANA's) &lt;A
 * HREF=&quot;http://www.iana.org/assignments/media-types/&quot;&gt;Media Types
 * Directory&lt;/A&gt;. Interface {@link Doc Doc} provides two utility operations,
 * {@link Doc#getReaderForText() getReaderForText} and
 * {@link Doc#getStreamForBytes() getStreamForBytes()}, to help a
 * &lt;code&gt;Doc&lt;/code&gt; object's client extract client formatted print data.
 * &lt;P&gt;
 * For client formatted print data, the print data representation class is
 * typically one of the following (although other representation classes are
 * permitted):
 * &lt;UL&gt;
 * &lt;LI&gt;
 * Character array (&lt;CODE&gt;char[]&lt;/CODE&gt;) -- The print data consists of the
 * Unicode characters in the array.
 * &lt;P&gt;
 * &lt;LI&gt;
 * &lt;code&gt;String&lt;/code&gt;  --
 * The print data consists of the Unicode characters in the string.
 * &lt;P&gt;
 * &lt;LI&gt;
 * Character stream ({@link java.io.Reader java.io.Reader})
 * -- The print data consists of the Unicode characters read from the stream
 * up to the end-of-stream.
 * &lt;P&gt;
 * &lt;LI&gt;
 * Byte array (&lt;CODE&gt;byte[]&lt;/CODE&gt;) -- The print data consists of the bytes in
 * the array. The bytes are encoded in the character set specified by the doc
 * flavor's MIME type. If the MIME type does not specify a character set, the
 * default character set is US-ASCII.
 * &lt;P&gt;
 * &lt;LI&gt;
 * Byte stream ({@link java.io.InputStream java.io.InputStream}) --
 * The print data consists of the bytes read from the stream up to the
 * end-of-stream. The bytes are encoded in the character set specified by the
 * doc flavor's MIME type. If the MIME type does not specify a character set,
 * the default character set is US-ASCII.

 * &lt;LI&gt;
 * Uniform Resource Locator ({@link java.net.URL URL})
 * -- The print data consists of the bytes read from the URL location.
 * The bytes are encoded in the character set specified by the doc flavor's
 * MIME type. If the MIME type does not specify a character set, the default
 * character set is US-ASCII.
 * &lt;P&gt;
 * When the representation class is a URL, the print service itself accesses
 * and downloads the document directly from its URL address, without involving
 * the client. The service may be some form of network print service which
 * is executing in a different environment.
 * This means you should not use a URL print data flavor to print a
 * document at a restricted URL that the client can see but the printer cannot
 * see. This also means you should not use a URL print data flavor to print a
 * document stored in a local file that is not available at a URL
 * accessible independently of the client.
 * For example, a file that is not served up by an HTTP server or FTP server.
 * To print such documents, let the client open an input stream on the URL
 * or file and use an input stream data flavor.
 * &lt;/UL&gt;
 * &lt;p&gt;
 * &lt;HR&gt;
 * &lt;h3&gt;Default and Platform Encodings&lt;/h3&gt;
 * &lt;P&gt;
 * For byte print data where the doc flavor's MIME type does not include a
 * &lt;CODE&gt;charset&lt;/CODE&gt; parameter, the Java Print Service instance assumes the
 * US-ASCII character set by default. This is in accordance with
 * &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;RFC 2046&lt;/A&gt;, which says the
 * default character set is US-ASCII. Note that US-ASCII is a subset of
 * UTF-8, so in the future this may be widened if a future RFC endorses
 * UTF-8 as the default in a compatible manner.
 * &lt;p&gt;
 * Also note that this is different than the behaviour of the Java runtime
 * when interpreting a stream of bytes as text data. That assumes the
 * default encoding for the user's locale. Thus, when spooling a file in local
 * encoding to a Java Print Service it is important to correctly specify
 * the encoding. Developers working in the English locales should
 * be particularly conscious of this, as their platform encoding corresponds
 * to the default mime charset. By this coincidence that particular
 * case may work without specifying the encoding of platform data.
 * &lt;p&gt;
 * Every instance of the Java virtual machine has a default character encoding
 * determined during virtual-machine startup and typically depends upon the
 * locale and charset being used by the underlying operating system.
 * In a distributed environment there is no guarantee that two VM share
 * the same default encoding. Thus clients which want to stream platform
 * encoded text data from the host platform to a Java Print Service instance
 * must explicitly declare the charset and not rely on defaults.
 * &lt;p&gt;
 * The preferred form is the official IANA primary name for an encoding.
 * Applications which stream text data should always specify the charset
 * in the mime type, which necessitates obtaining the encoding of the host
 * platform for data (eg files) stored in that platform's encoding.
 * A CharSet which corresponds to this and is suitable for use in a
 * mime-type for a DocFlavor can be obtained
 * from {@link DocFlavor#hostEncoding DocFlavor.hostEncoding}
 * This may not always be the primary IANA name but is guaranteed to be
 * understood by this VM.
 * For common flavors, the pre-defined *HOST DocFlavors may be used.
 * &lt;p&gt;
 * &lt;p&gt;
 * See &lt;a href=&quot;../../java/lang/package-summary.html#charenc&quot;&gt;
 * character encodings&lt;/a&gt; for more information on the character encodings
 * supported on the Java platform.
 * &lt;p&gt;
 * &lt;HR&gt;
 * &lt;h3&gt;Recommended DocFlavors&lt;/h3&gt;
 * &lt;P&gt;
 * The Java Print Service API does not define any mandatorily supported
 * DocFlavors.
 * However, here are some examples of MIME types that a Java Print Service
 * instance might support for client formatted print data.
 * Nested classes inside class DocFlavor declare predefined static
 * constant DocFlavor objects for these example doc flavors; class DocFlavor's
 * constructor can be used to create an arbitrary doc flavor.
 * &lt;UL&gt;
 * &lt;LI&gt;Preformatted text
 * &lt;P&gt;
 * &lt;TABLE BORDER=1 CELLPADDING=0 CELLSPACING=0 SUMMARY=&quot;MIME-Types and their descriptions&quot;&gt;
 * &lt;TR&gt;
 *  &lt;TH&gt;MIME-Type&lt;/TH&gt;&lt;TH&gt;Description&lt;/TH&gt;
 * &lt;/TR&gt;
 * &lt;TR&gt;
 * &lt;TD&gt;&lt;CODE&gt;&quot;text/plain&quot;&lt;/CODE&gt;&lt;/TD&gt;
 * &lt;TD&gt;Plain text in the default character set (US-ASCII)&lt;/TD&gt;
 * &lt;/TR&gt;
 * &lt;TR&gt;
 * &lt;TD&gt;&lt;CODE&gt;&quot;text/plain; charset=&lt;I&gt;xxx&lt;/I&gt;&quot;&lt;/CODE&gt;&lt;/TD&gt;
 * &lt;TD&gt;Plain text in character set &lt;I&gt;xxx&lt;/I&gt;&lt;/TD&gt;
 * &lt;/TR&gt;
 * &lt;TR&gt;
 * &lt;TD&gt;&lt;CODE&gt;&quot;text/html&quot;&lt;/CODE&gt;&lt;/TD&gt;
 * &lt;TD&gt;HyperText Markup Language in the default character set (US-ASCII)&lt;/TD&gt;
 * &lt;/TR&gt;
 * &lt;TR&gt;
 * &lt;TD&gt;&lt;CODE&gt;&quot;text/html; charset=&lt;I&gt;xxx&lt;/I&gt;&quot;&lt;/CODE&gt;&lt;/TD&gt;
 * &lt;TD&gt;HyperText Markup Language in character set &lt;I&gt;xxx&lt;/I&gt;&lt;/TD&gt;
 * &lt;/TR&gt;
 * &lt;/TABLE&gt;
 * &lt;P&gt;
 * In general, preformatted text print data is provided either in a character
 * oriented representation class (character array, String, Reader) or in a
 * byte oriented representation class (byte array, InputStream, URL).
 * &lt;P&gt;
 *  &lt;LI&gt;Preformatted page description language (PDL) documents
 *&lt;P&gt;
 * &lt;TABLE BORDER=1 CELLPADDING=0 CELLSPACING=0 SUMMARY=&quot;MIME-Types and their descriptions&quot;&gt;
 * &lt;TR&gt;
 *  &lt;TH&gt;MIME-Type&lt;/TH&gt;&lt;TH&gt;Description&lt;/TH&gt;
 * &lt;/TR&gt;
 *&lt;TR&gt;
 * &lt;TD&gt;&lt;CODE&gt;&quot;application/pdf&quot;&lt;/CODE&gt;&lt;/TD&gt;
 * &lt;TD&gt;Portable Document Format document&lt;/TD&gt;
 * &lt;/TR&gt;
 * &lt;TR&gt;
 * &lt;TD&gt;&lt;CODE&gt;&quot;application/postscript&quot;&lt;/CODE&gt;&lt;/TD&gt;
 * &lt;TD&gt;PostScript document&lt;/TD&gt;
 * &lt;/TR&gt;
 * &lt;TR&gt;
 * &lt;TD&gt;&lt;CODE&gt;&quot;application/vnd.hp-PCL&quot;&lt;/CODE&gt;&lt;/TD&gt;
 * &lt;TD&gt;Printer Control Language document&lt;/TD&gt;
 * &lt;/TR&gt;
 * &lt;/TABLE&gt;
 * &lt;P&gt;
 * In general, preformatted PDL print data is provided in a byte oriented
 * representation class (byte array, InputStream, URL).
 * &lt;P&gt;
 *  &lt;LI&gt;Preformatted images
 *&lt;P&gt;
 * &lt;TABLE BORDER=1 CELLPADDING=0 CELLSPACING=0 SUMMARY=&quot;MIME-Types and their descriptions&quot;&gt;
 * &lt;TR&gt;
 *  &lt;TH&gt;MIME-Type&lt;/TH&gt;&lt;TH&gt;Description&lt;/TH&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;&lt;CODE&gt;&quot;image/gif&quot;&lt;/CODE&gt;&lt;/TD&gt;
 * &lt;TD&gt;Graphics Interchange Format image&lt;/TD&gt;
 * &lt;/TR&gt;
 * &lt;TR&gt;
 * &lt;TD&gt;&lt;CODE&gt;&quot;image/jpeg&quot;&lt;/CODE&gt;&lt;/TD&gt;
 * &lt;TD&gt;Joint Photographic Experts Group image&lt;/TD&gt;
 * &lt;/TR&gt;
 * &lt;TR&gt;
 * &lt;TD&gt;&lt;CODE&gt;&quot;image/png&quot;&lt;/CODE&gt;&lt;/TD&gt;
 * &lt;TD&gt;Portable Network Graphics image&lt;/TD&gt;
 * &lt;/TR&gt;
 * &lt;/TABLE&gt;
 * &lt;P&gt;
 * In general, preformatted image print data is provided in a byte oriented
 * representation class (byte array, InputStream, URL).
 * &lt;P&gt;
 *  &lt;LI&gt;Preformatted autosense print data
 *   &lt;P&gt;
 * &lt;TABLE BORDER=1 CELLPADDING=0 CELLSPACING=0 SUMMARY=&quot;MIME-Types and their descriptions&quot;&gt;
 * &lt;TR&gt;
 *  &lt;TH&gt;MIME-Type&lt;/TH&gt;&lt;TH&gt;Description&lt;/TH&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;&lt;CODE&gt;&quot;application/octet-stream&quot;&lt;/CODE&gt;&lt;/TD&gt;
 * &lt;TD&gt;The print data format is unspecified (just an octet stream)&lt;/TD&gt;
 * &lt;/TABLE&gt;
 * &lt;P&gt;
 * The printer decides how to interpret the print data; the way this
 * &quot;autosensing&quot; works is implementation dependent. In general, preformatted
 * autosense print data is provided in a byte oriented representation class
 * (byte array, InputStream, URL).
 * &lt;/UL&gt;
 * &lt;P&gt;
 * &lt;HR&gt;
 * &lt;H3&gt;Service Formatted Print Data&lt;/H3&gt;
 * &lt;P&gt;
 * For &lt;B&gt;service formatted print data&lt;/B&gt;, the Java Print Service instance
 * determines the print data format. The doc flavor's representation class
 * denotes an interface whose methods the &lt;code&gt;DocPrintJob&lt;/code&gt; invokes to
 * determine the content to be printed -- such as a renderable image
 * interface or a Java printable interface.
 * The doc flavor's MIME type is the special value
 * &lt;CODE&gt;&quot;application/x-java-jvm-local-objectref&quot;&lt;/CODE&gt; indicating the client
 * will supply a reference to a Java object that implements the interface
 * named as the representation class.
 * This MIME type is just a placeholder; what's
 * important is the print data representation class.
 * &lt;P&gt;
 * For service formatted print data, the print data representation class is
 * typically one of the following (although other representation classes are
 * permitted). Nested classes inside class DocFlavor declare predefined static
 * constant DocFlavor objects for these example doc flavors; class DocFlavor's
 * constructor can be used to create an arbitrary doc flavor.
 * &lt;UL&gt;
 * &lt;LI&gt;
 * Renderable image object -- The client supplies an object that implements
 * interface
 * {@link java.awt.image.renderable.RenderableImage RenderableImage}. The
 * printer calls methods
 * in that interface to obtain the image to be printed.
 * &lt;P&gt;
 * &lt;LI&gt;
 * Printable object -- The client supplies an object that implements interface
 * {@link java.awt.print.Printable Printable}.
 * The printer calls methods in that interface to obtain the pages to be
 * printed, one by one.
 * For each page, the printer supplies a graphics context, and whatever the
 * client draws in that graphics context gets printed.
 * &lt;P&gt;
 * &lt;LI&gt;
 * Pageable object -- The client supplies an object that implements interface
 * {@link java.awt.print.Pageable Pageable}. The printer calls
 * methods in that interface to obtain the pages to be printed, one by one.
 * For each page, the printer supplies a graphics context, and whatever
 * the client draws in that graphics context gets printed.
 * &lt;/UL&gt;
 * &lt;P&gt;
 * &lt;HR&gt;
 * &lt;P&gt;
 * &lt;HR&gt;
 * &lt;H3&gt;Pre-defined Doc Flavors&lt;/H3&gt;
 * A Java Print Service instance is not &lt;B&gt;&lt;I&gt;required&lt;/I&gt;&lt;/B&gt; to support the
 * following print data formats and print data representation classes.  In
 * fact, a developer using this class should &lt;b&gt;never&lt;/b&gt; assume that a
 * particular print service supports the document types corresponding to
 * these pre-defined doc flavors.  Always query the print service
 * to determine what doc flavors it supports.  However,
 * developers who have print services that support these doc flavors are
 * encouraged to refer to the predefined singleton instances created here.
 * &lt;UL&gt;
 * &lt;LI&gt;
 * Plain text print data provided through a byte stream. Specifically, the
 * following doc flavors are recommended to be supported:
 * &lt;BR&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
 * &lt;CODE&gt;(&quot;text/plain&quot;, &quot;java.io.InputStream&quot;)&lt;/CODE&gt;
 * &lt;BR&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
 * &lt;CODE&gt;(&quot;text/plain; charset=us-ascii&quot;, &quot;java.io.InputStream&quot;)&lt;/CODE&gt;
 * &lt;BR&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
 * &lt;CODE&gt;(&quot;text/plain; charset=utf-8&quot;, &quot;java.io.InputStream&quot;)&lt;/CODE&gt;
 * &lt;P&gt;
 * &lt;LI&gt;
 * Renderable image objects. Specifically, the following doc flavor is
 * recommended to be supported:
 * &lt;BR&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
 * &lt;CODE&gt;(&quot;application/x-java-jvm-local-objectref&quot;, &quot;java.awt.image.renderable.RenderableImage&quot;)&lt;/CODE&gt;
 * &lt;/UL&gt;
 * &lt;P&gt;
 * A Java Print Service instance is allowed to support any other doc flavors
 * (or none) in addition to the above mandatory ones, at the implementation's
 * choice.
 * &lt;P&gt;
 * Support for the above doc flavors is desirable so a printing client can rely
 * on being able to print on any JPS printer, regardless of which doc flavors
 * the printer supports. If the printer doesn't support the client's preferred
 * doc flavor, the client can at least print plain text, or the client can
 * convert its data to a renderable image and print the image.
 * &lt;P&gt;
 * Furthermore, every Java Print Service instance must fulfill these
 * requirements for processing plain text print data:
 * &lt;UL&gt;
 * &lt;LI&gt;
 * The character pair carriage return-line feed (CR-LF) means
 * &quot;go to column 1 of the next line.&quot;
 * &lt;LI&gt;
 * A carriage return (CR) character standing by itself means
 * &quot;go to column 1 of the next line.&quot;
 * &lt;LI&gt;
 * A line feed (LF) character standing by itself means
 * &quot;go to column 1 of the next line.&quot;
 * &lt;LI&gt;
 * &lt;/UL&gt;
 * &lt;P&gt;
 * The client must itself perform all plain text print data formatting not
 * addressed by the above requirements.
 * &lt;P&gt;
 * &lt;H3&gt;Design Rationale&lt;/H3&gt;
 * &lt;P&gt;
 * Class DocFlavor in package javax.print.data is similar to class
 * {@link java.awt.datatransfer.DataFlavor DataFlavor}. Class
 * &lt;code&gt;DataFlavor&lt;/code&gt;
 * is not used in the Java Print Service (JPS) API
 * for three reasons which are all rooted in allowing the JPS API to be
 * shared by other print services APIs which may need to run on Java profiles
 * which do not include all of the Java Platform, Standard Edition.
 * &lt;OL TYPE=1&gt;
 * &lt;LI&gt;
 * The JPS API is designed to be used in Java profiles which do not support
 * AWT.
 * &lt;P&gt;
 * &lt;LI&gt;
 * The implementation of class &lt;code&gt;java.awt.datatransfer.DataFlavor&lt;/code&gt;
 * does not guarantee that equivalent data flavors will have the same
 * serialized representation. DocFlavor does, and can be used in services
 * which need this.
 * &lt;P&gt;
 * &lt;LI&gt;
 * The implementation of class &lt;code&gt;java.awt.datatransfer.DataFlavor&lt;/code&gt;
 * includes a human presentable name as part of the serialized representation.
 * This is not appropriate as part of a service matching constraint.
 * &lt;/OL&gt;
 * &lt;P&gt;
 * Class DocFlavor's serialized representation uses the following
 * canonical form of a MIME type string. Thus, two doc flavors with MIME types
 * that are not identical but that are equivalent (that have the same
 * canonical form) may be considered equal.
 * &lt;UL&gt;
 * &lt;LI&gt; The media type, media subtype, and parameters are retained, but all
 *      comments and whitespace characters are discarded.
 * &lt;LI&gt; The media type, media subtype, and parameter names are converted to
 *      lowercase.
 * &lt;LI&gt; The parameter values retain their original case, except a charset
 *      parameter value for a text media type is converted to lowercase.
 * &lt;LI&gt; Quote characters surrounding parameter values are removed.
 * &lt;LI&gt; Quoting backslash characters inside parameter values are removed.
 * &lt;LI&gt; The parameters are arranged in ascending order of parameter name.
 * &lt;/UL&gt;
 * &lt;P&gt;
 * Class DocFlavor's serialized representation also contains the
 * fully-qualified class &lt;I&gt;name&lt;/I&gt; of the representation class
 * (a String object), rather than the representation class itself
 * (a Class object). This allows a client to examine the doc flavors a
 * Java Print Service instance supports without having
 * to load the representation classes, which may be problematic for
 * limited-resource clients.
 * &lt;P&gt;
 *
 * @author  Alan Kaminsky
 */
public class DocFlavor implements Serializable, Cloneable {

    private static final long serialVersionUID = -4512080796965449721L;

    /**
     * A String representing the host operating system encoding.
     * This will follow the conventions documented in
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;
     * &lt;i&gt;RFC&amp;nbsp;2278:&amp;nbsp;IANA Charset Registration Procedures&lt;/i&gt;&lt;/a&gt;
     * except where historical names are returned for compatibility with
     * previous versions of the Java platform.
     * The value returned from method is valid only for the VM which
     * returns it, for use in a DocFlavor.
     * This is the charset for all the &quot;HOST&quot; pre-defined DocFlavors in
     * the executing VM.
     */
    public static final String hostEncoding;

    static {
        hostEncoding =
            (String)java.security.AccessController.doPrivileged(
                  new sun.security.action.GetPropertyAction(&quot;file.encoding&quot;));
    }

    /**
     * MIME type.
     */
    private transient MimeType myMimeType;

    /**
     * Representation class name.
     * @serial
     */
    private String myClassName;

    /**
     * String value for this doc flavor. Computed when needed and cached.
     */
    private transient String myStringValue = null;


    /**
     * Constructs a new doc flavor object from the given MIME type and
     * representation class name. The given MIME type is converted into
     * canonical form and stored internally.
     *
     * @param  mimeType   MIME media type string.
     * @param  className  Fully-qualified representation class name.
     *
     * @exception  NullPointerException
     *     (unchecked exception) Thrown if &lt;CODE&gt;mimeType&lt;/CODE&gt; is null or
     *     &lt;CODE&gt;className&lt;/CODE&gt; is null.
     * @exception  IllegalArgumentException
     *     (unchecked exception) Thrown if &lt;CODE&gt;mimeType&lt;/CODE&gt; does not
     *     obey the syntax for a MIME media type string.
     */
    public DocFlavor(String mimeType, String className) {
        if (className == null) {
            throw new NullPointerException();
        }
        myMimeType = new MimeType (mimeType);
        myClassName = className;
    }

    /**
     * Returns this doc flavor object's MIME type string based on the
     * canonical form. Each parameter value is enclosed in quotes.
     * @return the mime type
     */
    public String getMimeType() {
        return myMimeType.getMimeType();
    }

    /**
     * Returns this doc flavor object's media type (from the MIME type).
     * @return the media type
     */
    public String getMediaType() {
        return myMimeType.getMediaType();
    }

    /**
     * Returns this doc flavor object's media subtype (from the MIME type).
     * @return the media sub-type
     */
    public String getMediaSubtype() {
        return myMimeType.getMediaSubtype();
    }

    /**
     * Returns a &lt;code&gt;String&lt;/code&gt; representing a MIME
     * parameter.
     * Mime types may include parameters which are usually optional.
     * The charset for text types is a commonly useful example.
     * This convenience method will return the value of the specified
     * parameter if one was specified in the mime type for this flavor.
     * &lt;p&gt;
     * @param paramName the name of the paramater. This name is internally
     * converted to the canonical lower case format before performing
     * the match.
     * @return String representing a mime parameter, or
     * null if that parameter is not in the mime type string.
     * @exception NullPointerException if paramName is null.
     */
    public String getParameter(String paramName) {
        return
            (String)myMimeType.getParameterMap().get(paramName.toLowerCase());
    }

    /**
     * Returns the name of this doc flavor object's representation class.
     * @return the name of the representation class.
     */
    public String getRepresentationClassName() {
        return myClassName;
    }

    /**
     * Converts this &lt;code&gt;DocFlavor&lt;/code&gt; to a string.
     *
     * @return  MIME type string based on the canonical form. Each parameter
     *          value is enclosed in quotes.
     *          A &quot;class=&quot; parameter is appended to the
     *          MIME type string to indicate the representation class name.
     */
    public String toString() {
        return getStringValue();
    }

    /**
     * Returns a hash code for this doc flavor object.
     */
    public int hashCode() {
        return getStringValue().hashCode();
    }

    /**
     * Determines if this doc flavor object is equal to the given object.
     * The two are equal if the given object is not null, is an instance
     * of &lt;code&gt;DocFlavor&lt;/code&gt;, has a MIME type equivalent to this doc
     * flavor object's MIME type (that is, the MIME types have the same media
     * type, media subtype, and parameters), and has the same representation
     * class name as this doc flavor object. Thus, if two doc flavor objects'
     * MIME types are the same except for comments, they are considered equal.
     * However, two doc flavor objects with MIME types of &quot;text/plain&quot; and
     * &quot;text/plain; charset=US-ASCII&quot; are not considered equal, even though
     * they represent the same media type (because the default character
     * set for plain text is US-ASCII).
     *
     * @param  obj  Object to test.
     *
     * @return  True if this doc flavor object equals &lt;CODE&gt;obj&lt;/CODE&gt;, false
     *          otherwise.
     */
    public boolean equals(Object obj) {
        return
            obj != null &amp;&amp;
            obj instanceof DocFlavor &amp;&amp;
            getStringValue().equals (((DocFlavor) obj).getStringValue());
    }

    /**
     * Returns this doc flavor object's string value.
     */
    private String getStringValue() {
        if (myStringValue == null) {
            myStringValue = myMimeType + &quot;; class=\&quot;&quot; + myClassName + &quot;\&quot;&quot;;
        }
        return myStringValue;
    }

    /**
     * Write the instance to a stream (ie serialize the object).
     */
    private void writeObject(ObjectOutputStream s) throws IOException {

        s.defaultWriteObject();
        s.writeObject(myMimeType.getMimeType());
    }

    /**
     * Reconstitute an instance from a stream (that is, deserialize it).
     *
     * @serialData
     * The serialised form of a DocFlavor is the String naming the
     * representation class followed by the String representing the canonical
     * form of the mime type.
     */
    private void readObject(ObjectInputStream s)
        throws ClassNotFoundException, IOException {

        s.defaultReadObject();
        myMimeType = new MimeType((String)s.readObject());
    }

    /**
     * Class DocFlavor.BYTE_ARRAY provides predefined static constant
     * DocFlavor objects for example doc flavors using a byte array
     * (&lt;CODE&gt;byte[]&lt;/CODE&gt;) as the print data representation class.
     * &lt;P&gt;
     *
     * @author  Alan Kaminsky
     */
    public static class BYTE_ARRAY extends DocFlavor {

        private static final long serialVersionUID = -9065578006593857475L;

        /**
         * Constructs a new doc flavor with the given MIME type and a print
         * data representation class name of &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte array).
         *
         * @param  mimeType   MIME media type string.
         *
         * @exception  NullPointerException
         *     (unchecked exception) Thrown if &lt;CODE&gt;mimeType&lt;/CODE&gt; is null.
         * @exception  IllegalArgumentException
         *     (unchecked exception) Thrown if &lt;CODE&gt;mimeType&lt;/CODE&gt; does not
         *     obey the syntax for a MIME media type string.
         */
        public BYTE_ARRAY (String mimeType) {
            super (mimeType, &quot;[B&quot;);
        }

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;text/plain&quot;&lt;/CODE&gt;,
         * encoded in the host platform encoding.
         * See {@link DocFlavor#hostEncoding hostEncoding}
         * Print data representation class name =
         * &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte array).
         */
        public static final BYTE_ARRAY TEXT_PLAIN_HOST =
            new BYTE_ARRAY (&quot;text/plain; charset=&quot;+hostEncoding);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/plain; charset=utf-8&quot;&lt;/CODE&gt;,
         * print data representation class name = &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte
         * array).
         */
        public static final BYTE_ARRAY TEXT_PLAIN_UTF_8 =
            new BYTE_ARRAY (&quot;text/plain; charset=utf-8&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/plain; charset=utf-16&quot;&lt;/CODE&gt;,
         * print data representation class name = &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte
         * array).
         */
        public static final BYTE_ARRAY TEXT_PLAIN_UTF_16 =
            new BYTE_ARRAY (&quot;text/plain; charset=utf-16&quot;);


        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/plain; charset=utf-16be&quot;&lt;/CODE&gt;
         * (big-endian byte ordering),
         * print data representation class name = &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte
         * array).
         */
        public static final BYTE_ARRAY TEXT_PLAIN_UTF_16BE =
            new BYTE_ARRAY (&quot;text/plain; charset=utf-16be&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/plain; charset=utf-16le&quot;&lt;/CODE&gt;
         * (little-endian byte ordering),
         * print data representation class name = &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte
         * array).
         */
        public static final BYTE_ARRAY TEXT_PLAIN_UTF_16LE =
            new BYTE_ARRAY (&quot;text/plain; charset=utf-16le&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/plain; charset=us-ascii&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte array).
         */
        public static final BYTE_ARRAY TEXT_PLAIN_US_ASCII =
            new BYTE_ARRAY (&quot;text/plain; charset=us-ascii&quot;);


        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;text/html&quot;&lt;/CODE&gt;,
         * encoded in the host platform encoding.
         * See {@link DocFlavor#hostEncoding hostEncoding}
         * Print data representation class name =
         * &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte array).
         */
        public static final BYTE_ARRAY TEXT_HTML_HOST =
            new BYTE_ARRAY (&quot;text/html; charset=&quot;+hostEncoding);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/html; charset=utf-8&quot;&lt;/CODE&gt;,
         * print data representation class name = &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte
         * array).
         */
        public static final BYTE_ARRAY TEXT_HTML_UTF_8 =
            new BYTE_ARRAY (&quot;text/html; charset=utf-8&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/html; charset=utf-16&quot;&lt;/CODE&gt;,
         * print data representation class name = &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte
         * array).
         */
        public static final BYTE_ARRAY TEXT_HTML_UTF_16 =
            new BYTE_ARRAY (&quot;text/html; charset=utf-16&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/html; charset=utf-16be&quot;&lt;/CODE&gt;
         * (big-endian byte ordering),
         * print data representation class name = &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte
         * array).
         */
        public static final BYTE_ARRAY TEXT_HTML_UTF_16BE =
            new BYTE_ARRAY (&quot;text/html; charset=utf-16be&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/html; charset=utf-16le&quot;&lt;/CODE&gt;
         * (little-endian byte ordering),
         * print data representation class name = &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte
         * array).
         */
        public static final BYTE_ARRAY TEXT_HTML_UTF_16LE =
            new BYTE_ARRAY (&quot;text/html; charset=utf-16le&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/html; charset=us-ascii&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte array).
         */
        public static final BYTE_ARRAY TEXT_HTML_US_ASCII =
            new BYTE_ARRAY (&quot;text/html; charset=us-ascii&quot;);


        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;application/pdf&quot;&lt;/CODE&gt;, print
         * data representation class name = &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte array).
         */
        public static final BYTE_ARRAY PDF = new BYTE_ARRAY (&quot;application/pdf&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;application/postscript&quot;&lt;/CODE&gt;,
         * print data representation class name = &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte
         * array).
         */
        public static final BYTE_ARRAY POSTSCRIPT =
            new BYTE_ARRAY (&quot;application/postscript&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;application/vnd.hp-PCL&quot;&lt;/CODE&gt;,
         * print data representation class name = &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte
         * array).
         */
        public static final BYTE_ARRAY PCL =
            new BYTE_ARRAY (&quot;application/vnd.hp-PCL&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;image/gif&quot;&lt;/CODE&gt;, print data
         * representation class name = &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte array).
         */
        public static final BYTE_ARRAY GIF = new BYTE_ARRAY (&quot;image/gif&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;image/jpeg&quot;&lt;/CODE&gt;, print data
         * representation class name = &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte array).
         */
        public static final BYTE_ARRAY JPEG = new BYTE_ARRAY (&quot;image/jpeg&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;image/png&quot;&lt;/CODE&gt;, print data
         * representation class name = &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte array).
         */
        public static final BYTE_ARRAY PNG = new BYTE_ARRAY (&quot;image/png&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;application/octet-stream&quot;&lt;/CODE&gt;,
         * print data representation class name = &lt;CODE&gt;&quot;[B&quot;&lt;/CODE&gt; (byte
         * array). The client must determine that data described
         * using this DocFlavor is valid for the printer.
         */
        public static final BYTE_ARRAY AUTOSENSE =
            new BYTE_ARRAY (&quot;application/octet-stream&quot;);

    }

    /**
     * Class DocFlavor.INPUT_STREAM provides predefined static constant
     * DocFlavor objects for example doc flavors using a byte stream ({@link
     * java.io.InputStream java.io.InputStream}) as the print
     * data representation class.
     * &lt;P&gt;
     *
     * @author  Alan Kaminsky
     */
    public static class INPUT_STREAM extends DocFlavor {

        private static final long serialVersionUID = -7045842700749194127L;

        /**
         * Constructs a new doc flavor with the given MIME type and a print
         * data representation class name of
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         *
         * @param  mimeType   MIME media type string.
         *
         * @exception  NullPointerException
         *     (unchecked exception) Thrown if &lt;CODE&gt;mimeType&lt;/CODE&gt; is null.
         * @exception  IllegalArgumentException
         *     (unchecked exception) Thrown if &lt;CODE&gt;mimeType&lt;/CODE&gt; does not
         *     obey the syntax for a MIME media type string.
         */
        public INPUT_STREAM (String mimeType) {
            super (mimeType, &quot;java.io.InputStream&quot;);
        }

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;text/plain&quot;&lt;/CODE&gt;,
         * encoded in the host platform encoding.
         * See {@link DocFlavor#hostEncoding hostEncoding}
         * Print data representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM TEXT_PLAIN_HOST =
            new INPUT_STREAM (&quot;text/plain; charset=&quot;+hostEncoding);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/plain; charset=utf-8&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM TEXT_PLAIN_UTF_8 =
            new INPUT_STREAM (&quot;text/plain; charset=utf-8&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/plain; charset=utf-16&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM TEXT_PLAIN_UTF_16 =
            new INPUT_STREAM (&quot;text/plain; charset=utf-16&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/plain; charset=utf-16be&quot;&lt;/CODE&gt;
         * (big-endian byte ordering),
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM TEXT_PLAIN_UTF_16BE =
            new INPUT_STREAM (&quot;text/plain; charset=utf-16be&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/plain; charset=utf-16le&quot;&lt;/CODE&gt;
         * (little-endian byte ordering),
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM TEXT_PLAIN_UTF_16LE =
            new INPUT_STREAM (&quot;text/plain; charset=utf-16le&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/plain; charset=us-ascii&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM TEXT_PLAIN_US_ASCII =
                new INPUT_STREAM (&quot;text/plain; charset=us-ascii&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;text/html&quot;&lt;/CODE&gt;,
         * encoded in the host platform encoding.
         * See {@link DocFlavor#hostEncoding hostEncoding}
         * Print data representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM TEXT_HTML_HOST =
            new INPUT_STREAM (&quot;text/html; charset=&quot;+hostEncoding);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/html; charset=utf-8&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM TEXT_HTML_UTF_8 =
            new INPUT_STREAM (&quot;text/html; charset=utf-8&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/html; charset=utf-16&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM TEXT_HTML_UTF_16 =
            new INPUT_STREAM (&quot;text/html; charset=utf-16&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/html; charset=utf-16be&quot;&lt;/CODE&gt;
         * (big-endian byte ordering),
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM TEXT_HTML_UTF_16BE =
            new INPUT_STREAM (&quot;text/html; charset=utf-16be&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/html; charset=utf-16le&quot;&lt;/CODE&gt;
         * (little-endian byte ordering),
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM TEXT_HTML_UTF_16LE =
            new INPUT_STREAM (&quot;text/html; charset=utf-16le&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/html; charset=us-ascii&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM TEXT_HTML_US_ASCII =
            new INPUT_STREAM (&quot;text/html; charset=us-ascii&quot;);


        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;application/pdf&quot;&lt;/CODE&gt;, print
         * data representation class name = &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt;
         * (byte stream).
         */
        public static final INPUT_STREAM PDF = new INPUT_STREAM (&quot;application/pdf&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;application/postscript&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM POSTSCRIPT =
            new INPUT_STREAM (&quot;application/postscript&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;application/vnd.hp-PCL&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM PCL =
            new INPUT_STREAM (&quot;application/vnd.hp-PCL&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;image/gif&quot;&lt;/CODE&gt;, print data
         * representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM GIF = new INPUT_STREAM (&quot;image/gif&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;image/jpeg&quot;&lt;/CODE&gt;, print data
         * representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM JPEG = new INPUT_STREAM (&quot;image/jpeg&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;image/png&quot;&lt;/CODE&gt;, print data
         * representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final INPUT_STREAM PNG = new INPUT_STREAM (&quot;image/png&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;application/octet-stream&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.io.InputStream&quot;&lt;/CODE&gt; (byte stream).
         * The client must determine that data described
         * using this DocFlavor is valid for the printer.
         */
        public static final INPUT_STREAM AUTOSENSE =
            new INPUT_STREAM (&quot;application/octet-stream&quot;);

    }

    /**
     * Class DocFlavor.URL provides predefined static constant DocFlavor
     * objects.
     * For example doc flavors using a Uniform Resource Locator ({@link
     * java.net.URL java.net.URL}) as the print data
     * representation  class.
     * &lt;P&gt;
     *
     * @author  Alan Kaminsky
     */
    public static class URL extends DocFlavor {

        /**
         * Constructs a new doc flavor with the given MIME type and a print
         * data representation class name of &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt;.
         *
         * @param  mimeType   MIME media type string.
         *
         * @exception  NullPointerException
         *     (unchecked exception) Thrown if &lt;CODE&gt;mimeType&lt;/CODE&gt; is null.
         * @exception  IllegalArgumentException
         *     (unchecked exception) Thrown if &lt;CODE&gt;mimeType&lt;/CODE&gt; does not
         *     obey the syntax for a MIME media type string.
         */
        public URL (String mimeType) {
            super (mimeType, &quot;java.net.URL&quot;);
        }

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;text/plain&quot;&lt;/CODE&gt;,
         * encoded in the host platform encoding.
         * See {@link DocFlavor#hostEncoding hostEncoding}
         * Print data representation class name =
         * &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final URL TEXT_PLAIN_HOST =
            new URL (&quot;text/plain; charset=&quot;+hostEncoding);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/plain; charset=utf-8&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final URL TEXT_PLAIN_UTF_8 =
            new URL (&quot;text/plain; charset=utf-8&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/plain; charset=utf-16&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;java.net.URL&quot;&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final URL TEXT_PLAIN_UTF_16 =
            new URL (&quot;text/plain; charset=utf-16&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/plain; charset=utf-16be&quot;&lt;/CODE&gt;
         * (big-endian byte ordering),
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final URL TEXT_PLAIN_UTF_16BE =
            new URL (&quot;text/plain; charset=utf-16be&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/plain; charset=utf-16le&quot;&lt;/CODE&gt;
         * (little-endian byte ordering),
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final URL TEXT_PLAIN_UTF_16LE =
            new URL (&quot;text/plain; charset=utf-16le&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/plain; charset=us-ascii&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final URL TEXT_PLAIN_US_ASCII =
            new URL (&quot;text/plain; charset=us-ascii&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;text/html&quot;&lt;/CODE&gt;,
         * encoded in the host platform encoding.
         * See {@link DocFlavor#hostEncoding hostEncoding}
         * Print data representation class name =
         * &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final URL TEXT_HTML_HOST =
            new URL (&quot;text/html; charset=&quot;+hostEncoding);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/html; charset=utf-8&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final URL TEXT_HTML_UTF_8 =
            new URL (&quot;text/html; charset=utf-8&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/html; charset=utf-16&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final URL TEXT_HTML_UTF_16 =
            new URL (&quot;text/html; charset=utf-16&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/html; charset=utf-16be&quot;&lt;/CODE&gt;
         * (big-endian byte ordering),
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final URL TEXT_HTML_UTF_16BE =
            new URL (&quot;text/html; charset=utf-16be&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/html; charset=utf-16le&quot;&lt;/CODE&gt;
         * (little-endian byte ordering),
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final URL TEXT_HTML_UTF_16LE =
            new URL (&quot;text/html; charset=utf-16le&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;text/html; charset=us-ascii&quot;&lt;/CODE&gt;,
         * print data representation class name =
         * &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt; (byte stream).
         */
        public static final URL TEXT_HTML_US_ASCII =
            new URL (&quot;text/html; charset=us-ascii&quot;);


        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;application/pdf&quot;&lt;/CODE&gt;, print
         * data representation class name = &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt;.
         */
        public static final URL PDF = new URL (&quot;application/pdf&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;application/postscript&quot;&lt;/CODE&gt;,
         * print data representation class name = &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt;.
         */
        public static final URL POSTSCRIPT = new URL (&quot;application/postscript&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;application/vnd.hp-PCL&quot;&lt;/CODE&gt;,
         * print data representation class name = &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt;.
         */
        public static final URL PCL = new URL (&quot;application/vnd.hp-PCL&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;image/gif&quot;&lt;/CODE&gt;, print data
         * representation class name = &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt;.
         */
        public static final URL GIF = new URL (&quot;image/gif&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;image/jpeg&quot;&lt;/CODE&gt;, print data
         * representation class name = &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt;.
         */
        public static final URL JPEG = new URL (&quot;image/jpeg&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;image/png&quot;&lt;/CODE&gt;, print data
         * representation class name = &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt;.
         */
        public static final URL PNG = new URL (&quot;image/png&quot;);

        /**
         * Doc flavor with MIME type =
         * &lt;CODE&gt;&quot;application/octet-stream&quot;&lt;/CODE&gt;,
         * print data representation class name = &lt;CODE&gt;&quot;java.net.URL&quot;&lt;/CODE&gt;.
         *  The client must determine that data described
         * using this DocFlavor is valid for the printer.
         */
        public static final URL AUTOSENSE = new URL (&quot;application/octet-stream&quot;);

    }

    /**
     * Class DocFlavor.CHAR_ARRAY provides predefined static constant
     * DocFlavor objects for example doc flavors using a character array
     * (&lt;CODE&gt;char[]&lt;/CODE&gt;) as the print data representation class. As such,
     * the character set is Unicode.
     * &lt;P&gt;
     *
     * @author  Alan Kaminsky
     */
    public static class CHAR_ARRAY extends DocFlavor {

        private static final long serialVersionUID = -8720590903724405128L;

        /**
         * Constructs a new doc flavor with the given MIME type and a print
         * data representation class name of
         * &lt;CODE&gt;&quot;[C&quot;&lt;/CODE&gt; (character array).
         *
         * @param  mimeType  MIME media type string. If it is a text media
         *                      type, it is assumed to contain a
         *                      &lt;CODE&gt;&quot;charset=utf-16&quot;&lt;/CODE&gt; parameter.
         *
         * @exception  NullPointerException
         *     (unchecked exception) Thrown if &lt;CODE&gt;mimeType&lt;/CODE&gt; is null.
         * @exception  IllegalArgumentException
         *     (unchecked exception) Thrown if &lt;CODE&gt;mimeType&lt;/CODE&gt; does not
         *     obey the syntax for a MIME media type string.
         */
        public CHAR_ARRAY (String mimeType) {
            super (mimeType, &quot;[C&quot;);
        }

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;text/plain;
         * charset=utf-16&quot;&lt;/CODE&gt;, print data representation class name =
         * &lt;CODE&gt;&quot;[C&quot;&lt;/CODE&gt; (character array).
         */
        public static final CHAR_ARRAY TEXT_PLAIN =
            new CHAR_ARRAY (&quot;text/plain; charset=utf-16&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;text/html;
         * charset=utf-16&quot;&lt;/CODE&gt;, print data representation class name =
         * &lt;CODE&gt;&quot;[C&quot;&lt;/CODE&gt; (character array).
         */
        public static final CHAR_ARRAY TEXT_HTML =
            new CHAR_ARRAY (&quot;text/html; charset=utf-16&quot;);

    }

    /**
     * Class DocFlavor.STRING provides predefined static constant DocFlavor
     * objects for example doc flavors using a string ({@link java.lang.String
     * java.lang.String}) as the print data representation class.
     * As such, the character set is Unicode.
     * &lt;P&gt;
     *
     * @author  Alan Kaminsky
     */
    public static class STRING extends DocFlavor {

        private static final long serialVersionUID = 4414407504887034035L;

        /**
         * Constructs a new doc flavor with the given MIME type and a print
         * data representation class name of &lt;CODE&gt;&quot;java.lang.String&quot;&lt;/CODE&gt;.
         *
         * @param  mimeType  MIME media type string. If it is a text media
         *                      type, it is assumed to contain a
         *                      &lt;CODE&gt;&quot;charset=utf-16&quot;&lt;/CODE&gt; parameter.
         *
         * @exception  NullPointerException
         *     (unchecked exception) Thrown if &lt;CODE&gt;mimeType&lt;/CODE&gt; is null.
         * @exception  IllegalArgumentException
         *     (unchecked exception) Thrown if &lt;CODE&gt;mimeType&lt;/CODE&gt; does not
         *     obey the syntax for a MIME media type string.
         */
        public STRING (String mimeType) {
            super (mimeType, &quot;java.lang.String&quot;);
        }

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;text/plain;
         * charset=utf-16&quot;&lt;/CODE&gt;, print data representation class name =
         * &lt;CODE&gt;&quot;java.lang.String&quot;&lt;/CODE&gt;.
         */
        public static final STRING TEXT_PLAIN =
            new STRING (&quot;text/plain; charset=utf-16&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;text/html;
         * charset=utf-16&quot;&lt;/CODE&gt;, print data representation class name =
         * &lt;CODE&gt;&quot;java.lang.String&quot;&lt;/CODE&gt;.
         */
        public static final STRING TEXT_HTML =
            new STRING (&quot;text/html; charset=utf-16&quot;);
    }

    /**
     * Class DocFlavor.READER provides predefined static constant DocFlavor
     * objects for example doc flavors using a character stream ({@link
     * java.io.Reader java.io.Reader}) as the print data
     * representation class. As such, the character set is Unicode.
     * &lt;P&gt;
     *
     * @author  Alan Kaminsky
     */
    public static class READER extends DocFlavor {

        private static final long serialVersionUID = 7100295812579351567L;

        /**
         * Constructs a new doc flavor with the given MIME type and a print
         * data representation class name of\
         * &lt;CODE&gt;&quot;java.io.Reader&quot;&lt;/CODE&gt; (character stream).
         *
         * @param  mimeType  MIME media type string. If it is a text media
         *                      type, it is assumed to contain a
         *                      &lt;CODE&gt;&quot;charset=utf-16&quot;&lt;/CODE&gt; parameter.
         *
         * @exception  NullPointerException
         *     (unchecked exception) Thrown if &lt;CODE&gt;mimeType&lt;/CODE&gt; is null.
         * @exception  IllegalArgumentException
         *     (unchecked exception) Thrown if &lt;CODE&gt;mimeType&lt;/CODE&gt; does not
         *     obey the syntax for a MIME media type string.
         */
        public READER (String mimeType) {
            super (mimeType, &quot;java.io.Reader&quot;);
        }

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;text/plain;
         * charset=utf-16&quot;&lt;/CODE&gt;, print data representation class name =
         * &lt;CODE&gt;&quot;java.io.Reader&quot;&lt;/CODE&gt; (character stream).
         */
        public static final READER TEXT_PLAIN =
            new READER (&quot;text/plain; charset=utf-16&quot;);

        /**
         * Doc flavor with MIME type = &lt;CODE&gt;&quot;text/html;
         * charset=utf-16&quot;&lt;/CODE&gt;, print data representation class name =
         * &lt;CODE&gt;&quot;java.io.Reader&quot;&lt;/CODE&gt; (character stream).
         */
        public static final READER TEXT_HTML =
            new READER (&quot;text/html; charset=utf-16&quot;);

    }

    /**
     * Class DocFlavor.SERVICE_FORMATTED provides predefined static constant
     * DocFlavor objects for example doc flavors for service formatted print
     * data.
     * &lt;P&gt;
     *
     * @author  Alan Kaminsky
     */
    public static class SERVICE_FORMATTED extends DocFlavor {

        private static final long serialVersionUID = 6181337766266637256L;

        /**
         * Constructs a new doc flavor with a MIME type of
         * &lt;CODE&gt;&quot;application/x-java-jvm-local-objectref&quot;&lt;/CODE&gt; indicating
         * service formatted print data and the given print data
         * representation class name.
         *
         * @param  className  Fully-qualified representation class name.
         *
         * @exception  NullPointerException
         *     (unchecked exception) Thrown if &lt;CODE&gt;className&lt;/CODE&gt; is
         *     null.
         */
        public SERVICE_FORMATTED (String className) {
            super (&quot;application/x-java-jvm-local-objectref&quot;, className);
        }

        /**
         * Service formatted print data doc flavor with print data
         * representation class name =
         * &lt;CODE&gt;&quot;java.awt.image.renderable.RenderableImage&quot;&lt;/CODE&gt;
         * (renderable image object).
         */
        public static final SERVICE_FORMATTED RENDERABLE_IMAGE =
            new SERVICE_FORMATTED(&quot;java.awt.image.renderable.RenderableImage&quot;);

        /**
         * Service formatted print data doc flavor with print data
         * representation class name = &lt;CODE&gt;&quot;java.awt.print.Printable&quot;&lt;/CODE&gt;
         * (printable object).
         */
        public static final SERVICE_FORMATTED PRINTABLE =
            new SERVICE_FORMATTED (&quot;java.awt.print.Printable&quot;);

        /**
         * Service formatted print data doc flavor with print data
         * representation class name = &lt;CODE&gt;&quot;java.awt.print.Pageable&quot;&lt;/CODE&gt;
         * (pageable object).
         */
        public static final SERVICE_FORMATTED PAGEABLE =
            new SERVICE_FORMATTED (&quot;java.awt.print.Pageable&quot;);

        }

}
</pre>
</body>
</html>
