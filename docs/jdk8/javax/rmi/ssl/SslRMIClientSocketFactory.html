<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.rmi.ssl;

import java.io.IOException;
import java.io.Serializable;
import java.net.Socket;
import java.rmi.server.RMIClientSocketFactory;
import java.util.StringTokenizer;
import javax.net.SocketFactory;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;

/**
 * &lt;p&gt;An &lt;code&gt;SslRMIClientSocketFactory&lt;/code&gt; instance is used by the RMI
 * runtime in order to obtain client sockets for RMI calls via SSL.&lt;/p&gt;
 *
 * &lt;p&gt;This class implements &lt;code&gt;RMIClientSocketFactory&lt;/code&gt; over
 * the Secure Sockets Layer (SSL) or Transport Layer Security (TLS)
 * protocols.&lt;/p&gt;
 *
 * &lt;p&gt;This class creates SSL sockets using the default
 * &lt;code&gt;SSLSocketFactory&lt;/code&gt; (see {@link
 * SSLSocketFactory#getDefault}).  All instances of this class are
 * functionally equivalent.  In particular, they all share the same
 * truststore, and the same keystore when client authentication is
 * required by the server.  This behavior can be modified in
 * subclasses by overriding the {@link #createSocket(String,int)}
 * method; in that case, {@link #equals(Object) equals} and {@link
 * #hashCode() hashCode} may also need to be overridden.&lt;/p&gt;
 *
 * &lt;p&gt;If the system property
 * &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; is specified,
 * the {@link #createSocket(String,int)} method will call {@link
 * SSLSocket#setEnabledCipherSuites(String[])} before returning the
 * socket.  The value of this system property is a string that is a
 * comma-separated list of SSL/TLS cipher suites to enable.&lt;/p&gt;
 *
 * &lt;p&gt;If the system property
 * &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; is specified,
 * the {@link #createSocket(String,int)} method will call {@link
 * SSLSocket#setEnabledProtocols(String[])} before returning the
 * socket.  The value of this system property is a string that is a
 * comma-separated list of SSL/TLS protocol versions to enable.&lt;/p&gt;
 *
 * @see javax.net.ssl.SSLSocketFactory
 * @see javax.rmi.ssl.SslRMIServerSocketFactory
 * @since 1.5
 */
public class SslRMIClientSocketFactory
    implements RMIClientSocketFactory, Serializable {

    /**
     * &lt;p&gt;Creates a new &lt;code&gt;SslRMIClientSocketFactory&lt;/code&gt;.&lt;/p&gt;
     */
    public SslRMIClientSocketFactory() {
        // We don't force the initialization of the default SSLSocketFactory
        // at construction time - because the RMI client socket factory is
        // created on the server side, where that initialization is a priori
        // meaningless, unless both server and client run in the same JVM.
        // We could possibly override readObject() to force this initialization,
        // but it might not be a good idea to actually mix this with possible
        // deserialization problems.
        // So contrarily to what we do for the server side, the initialization
        // of the SSLSocketFactory will be delayed until the first time
        // createSocket() is called - note that the default SSLSocketFactory
        // might already have been initialized anyway if someone in the JVM
        // already called SSLSocketFactory.getDefault().
        //
    }

    /**
     * &lt;p&gt;Creates an SSL socket.&lt;/p&gt;
     *
     * &lt;p&gt;If the system property
     * &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; is
     * specified, this method will call {@link
     * SSLSocket#setEnabledCipherSuites(String[])} before returning
     * the socket. The value of this system property is a string that
     * is a comma-separated list of SSL/TLS cipher suites to
     * enable.&lt;/p&gt;
     *
     * &lt;p&gt;If the system property
     * &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; is
     * specified, this method will call {@link
     * SSLSocket#setEnabledProtocols(String[])} before returning the
     * socket. The value of this system property is a string that is a
     * comma-separated list of SSL/TLS protocol versions to
     * enable.&lt;/p&gt;
     */
    public Socket createSocket(String host, int port) throws IOException {
        // Retrieve the SSLSocketFactory
        //
        final SocketFactory sslSocketFactory = getDefaultClientSocketFactory();
        // Create the SSLSocket
        //
        final SSLSocket sslSocket = (SSLSocket)
            sslSocketFactory.createSocket(host, port);
        // Set the SSLSocket Enabled Cipher Suites
        //
        final String enabledCipherSuites =
            System.getProperty(&quot;javax.rmi.ssl.client.enabledCipherSuites&quot;);
        if (enabledCipherSuites != null) {
            StringTokenizer st = new StringTokenizer(enabledCipherSuites, &quot;,&quot;);
            int tokens = st.countTokens();
            String enabledCipherSuitesList[] = new String[tokens];
            for (int i = 0 ; i &lt; tokens; i++) {
                enabledCipherSuitesList[i] = st.nextToken();
            }
            try {
                sslSocket.setEnabledCipherSuites(enabledCipherSuitesList);
            } catch (IllegalArgumentException e) {
                throw (IOException)
                    new IOException(e.getMessage()).initCause(e);
            }
        }
        // Set the SSLSocket Enabled Protocols
        //
        final String enabledProtocols =
            System.getProperty(&quot;javax.rmi.ssl.client.enabledProtocols&quot;);
        if (enabledProtocols != null) {
            StringTokenizer st = new StringTokenizer(enabledProtocols, &quot;,&quot;);
            int tokens = st.countTokens();
            String enabledProtocolsList[] = new String[tokens];
            for (int i = 0 ; i &lt; tokens; i++) {
                enabledProtocolsList[i] = st.nextToken();
            }
            try {
                sslSocket.setEnabledProtocols(enabledProtocolsList);
            } catch (IllegalArgumentException e) {
                throw (IOException)
                    new IOException(e.getMessage()).initCause(e);
            }
        }
        // Return the preconfigured SSLSocket
        //
        return sslSocket;
    }

    /**
     * &lt;p&gt;Indicates whether some other object is &quot;equal to&quot; this one.&lt;/p&gt;
     *
     * &lt;p&gt;Because all instances of this class are functionally equivalent
     * (they all use the default
     * &lt;code&gt;SSLSocketFactory&lt;/code&gt;), this method simply returns
     * &lt;code&gt;this.getClass().equals(obj.getClass())&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;A subclass should override this method (as well
     * as {@link #hashCode()}) if its instances are not all
     * functionally equivalent.&lt;/p&gt;
     */
    public boolean equals(Object obj) {
        if (obj == null) return false;
        if (obj == this) return true;
        return this.getClass().equals(obj.getClass());
    }

    /**
     * &lt;p&gt;Returns a hash code value for this
     * &lt;code&gt;SslRMIClientSocketFactory&lt;/code&gt;.&lt;/p&gt;
     *
     * @return a hash code value for this
     * &lt;code&gt;SslRMIClientSocketFactory&lt;/code&gt;.
     */
    public int hashCode() {
        return this.getClass().hashCode();
    }

    // We use a static field because:
    //
    //    SSLSocketFactory.getDefault() always returns the same object
    //    (at least on Sun's implementation), and we want to make sure
    //    that the Javadoc &amp; the implementation stay in sync.
    //
    // If someone needs to have different SslRMIClientSocketFactory factories
    // with different underlying SSLSocketFactory objects using different key
    // and trust stores, he can always do so by subclassing this class and
    // overriding createSocket(String host, int port).
    //
    private static SocketFactory defaultSocketFactory = null;

    private static synchronized SocketFactory getDefaultClientSocketFactory() {
        if (defaultSocketFactory == null)
            defaultSocketFactory = SSLSocketFactory.getDefault();
        return defaultSocketFactory;
    }

    private static final long serialVersionUID = -8310631444933958385L;
}
</pre>
</body>
</html>
