<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.rmi.ssl;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.rmi.server.RMIServerSocketFactory;
import java.util.Arrays;
import java.util.List;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLServerSocketFactory;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;

/**
 * &lt;p&gt;An &lt;code&gt;SslRMIServerSocketFactory&lt;/code&gt; instance is used by the RMI
 * runtime in order to obtain server sockets for RMI calls via SSL.&lt;/p&gt;
 *
 * &lt;p&gt;This class implements &lt;code&gt;RMIServerSocketFactory&lt;/code&gt; over
 * the Secure Sockets Layer (SSL) or Transport Layer Security (TLS)
 * protocols.&lt;/p&gt;
 *
 * &lt;p&gt;This class creates SSL sockets using the default
 * &lt;code&gt;SSLSocketFactory&lt;/code&gt; (see {@link
 * SSLSocketFactory#getDefault}) or the default
 * &lt;code&gt;SSLServerSocketFactory&lt;/code&gt; (see {@link
 * SSLServerSocketFactory#getDefault}) unless the
 * constructor taking an &lt;code&gt;SSLContext&lt;/code&gt; is
 * used in which case the SSL sockets are created using
 * the &lt;code&gt;SSLSocketFactory&lt;/code&gt; returned by
 * {@link SSLContext#getSocketFactory} or the
 * &lt;code&gt;SSLServerSocketFactory&lt;/code&gt; returned by
 * {@link SSLContext#getServerSocketFactory}.
 *
 * When an &lt;code&gt;SSLContext&lt;/code&gt; is not supplied all the instances of this
 * class share the same keystore, and the same truststore (when client
 * authentication is required by the server). This behavior can be modified
 * by supplying an already initialized &lt;code&gt;SSLContext&lt;/code&gt; instance.
 *
 * @see javax.net.ssl.SSLSocketFactory
 * @see javax.net.ssl.SSLServerSocketFactory
 * @see javax.rmi.ssl.SslRMIClientSocketFactory
 * @since 1.5
 */
public class SslRMIServerSocketFactory implements RMIServerSocketFactory {

    /**
     * &lt;p&gt;Creates a new &lt;code&gt;SslRMIServerSocketFactory&lt;/code&gt; with
     * the default SSL socket configuration.&lt;/p&gt;
     *
     * &lt;p&gt;SSL connections accepted by server sockets created by this
     * factory have the default cipher suites and protocol versions
     * enabled and do not require client authentication.&lt;/p&gt;
     */
    public SslRMIServerSocketFactory() {
        this(null, null, false);
    }

    /**
     * &lt;p&gt;Creates a new &lt;code&gt;SslRMIServerSocketFactory&lt;/code&gt; with
     * the specified SSL socket configuration.&lt;/p&gt;
     *
     * @param enabledCipherSuites names of all the cipher suites to
     * enable on SSL connections accepted by server sockets created by
     * this factory, or &lt;code&gt;null&lt;/code&gt; to use the cipher suites
     * that are enabled by default
     *
     * @param enabledProtocols names of all the protocol versions to
     * enable on SSL connections accepted by server sockets created by
     * this factory, or &lt;code&gt;null&lt;/code&gt; to use the protocol versions
     * that are enabled by default
     *
     * @param needClientAuth &lt;code&gt;true&lt;/code&gt; to require client
     * authentication on SSL connections accepted by server sockets
     * created by this factory; &lt;code&gt;false&lt;/code&gt; to not require
     * client authentication
     *
     * @exception IllegalArgumentException when one or more of the cipher
     * suites named by the &lt;code&gt;enabledCipherSuites&lt;/code&gt; parameter is
     * not supported, when one or more of the protocols named by the
     * &lt;code&gt;enabledProtocols&lt;/code&gt; parameter is not supported or when
     * a problem is encountered while trying to check if the supplied
     * cipher suites and protocols to be enabled are supported.
     *
     * @see SSLSocket#setEnabledCipherSuites
     * @see SSLSocket#setEnabledProtocols
     * @see SSLSocket#setNeedClientAuth
     */
    public SslRMIServerSocketFactory(
            String[] enabledCipherSuites,
            String[] enabledProtocols,
            boolean needClientAuth)
            throws IllegalArgumentException {
        this(null, enabledCipherSuites, enabledProtocols, needClientAuth);
    }

    /**
     * &lt;p&gt;Creates a new &lt;code&gt;SslRMIServerSocketFactory&lt;/code&gt; with the
     * specified &lt;code&gt;SSLContext&lt;/code&gt; and SSL socket configuration.&lt;/p&gt;
     *
     * @param context the SSL context to be used for creating SSL sockets.
     * If &lt;code&gt;context&lt;/code&gt; is null the default &lt;code&gt;SSLSocketFactory&lt;/code&gt;
     * or the default &lt;code&gt;SSLServerSocketFactory&lt;/code&gt; will be used to
     * create SSL sockets. Otherwise, the socket factory returned by
     * &lt;code&gt;SSLContext.getSocketFactory()&lt;/code&gt; or
     * &lt;code&gt;SSLContext.getServerSocketFactory()&lt;/code&gt; will be used instead.
     *
     * @param enabledCipherSuites names of all the cipher suites to
     * enable on SSL connections accepted by server sockets created by
     * this factory, or &lt;code&gt;null&lt;/code&gt; to use the cipher suites
     * that are enabled by default
     *
     * @param enabledProtocols names of all the protocol versions to
     * enable on SSL connections accepted by server sockets created by
     * this factory, or &lt;code&gt;null&lt;/code&gt; to use the protocol versions
     * that are enabled by default
     *
     * @param needClientAuth &lt;code&gt;true&lt;/code&gt; to require client
     * authentication on SSL connections accepted by server sockets
     * created by this factory; &lt;code&gt;false&lt;/code&gt; to not require
     * client authentication
     *
     * @exception IllegalArgumentException when one or more of the cipher
     * suites named by the &lt;code&gt;enabledCipherSuites&lt;/code&gt; parameter is
     * not supported, when one or more of the protocols named by the
     * &lt;code&gt;enabledProtocols&lt;/code&gt; parameter is not supported or when
     * a problem is encountered while trying to check if the supplied
     * cipher suites and protocols to be enabled are supported.
     *
     * @see SSLSocket#setEnabledCipherSuites
     * @see SSLSocket#setEnabledProtocols
     * @see SSLSocket#setNeedClientAuth
     * @since 1.7
     */
    public SslRMIServerSocketFactory(
            SSLContext context,
            String[] enabledCipherSuites,
            String[] enabledProtocols,
            boolean needClientAuth)
            throws IllegalArgumentException {
        // Initialize the configuration parameters.
        //
        this.enabledCipherSuites = enabledCipherSuites == null ?
            null : enabledCipherSuites.clone();
        this.enabledProtocols = enabledProtocols == null ?
            null : enabledProtocols.clone();
        this.needClientAuth = needClientAuth;

        // Force the initialization of the default at construction time,
        // rather than delaying it to the first time createServerSocket()
        // is called.
        //
        this.context = context;
        final SSLSocketFactory sslSocketFactory =
                context == null ?
                    getDefaultSSLSocketFactory() : context.getSocketFactory();
        SSLSocket sslSocket = null;
        if (this.enabledCipherSuites != null || this.enabledProtocols != null) {
            try {
                sslSocket = (SSLSocket) sslSocketFactory.createSocket();
            } catch (Exception e) {
                final String msg = &quot;Unable to check if the cipher suites &quot; +
                        &quot;and protocols to enable are supported&quot;;
                throw (IllegalArgumentException)
                new IllegalArgumentException(msg).initCause(e);
            }
        }

        // Check if all the cipher suites and protocol versions to enable
        // are supported by the underlying SSL/TLS implementation and if
        // true create lists from arrays.
        //
        if (this.enabledCipherSuites != null) {
            sslSocket.setEnabledCipherSuites(this.enabledCipherSuites);
            enabledCipherSuitesList = Arrays.asList(this.enabledCipherSuites);
        }
        if (this.enabledProtocols != null) {
            sslSocket.setEnabledProtocols(this.enabledProtocols);
            enabledProtocolsList = Arrays.asList(this.enabledProtocols);
        }
    }

    /**
     * &lt;p&gt;Returns the names of the cipher suites enabled on SSL
     * connections accepted by server sockets created by this factory,
     * or &lt;code&gt;null&lt;/code&gt; if this factory uses the cipher suites
     * that are enabled by default.&lt;/p&gt;
     *
     * @return an array of cipher suites enabled, or &lt;code&gt;null&lt;/code&gt;
     *
     * @see SSLSocket#setEnabledCipherSuites
     */
    public final String[] getEnabledCipherSuites() {
        return enabledCipherSuites == null ?
            null : enabledCipherSuites.clone();
    }

    /**
     * &lt;p&gt;Returns the names of the protocol versions enabled on SSL
     * connections accepted by server sockets created by this factory,
     * or &lt;code&gt;null&lt;/code&gt; if this factory uses the protocol versions
     * that are enabled by default.&lt;/p&gt;
     *
     * @return an array of protocol versions enabled, or
     * &lt;code&gt;null&lt;/code&gt;
     *
     * @see SSLSocket#setEnabledProtocols
     */
    public final String[] getEnabledProtocols() {
        return enabledProtocols == null ?
            null : enabledProtocols.clone();
    }

    /**
     * &lt;p&gt;Returns &lt;code&gt;true&lt;/code&gt; if client authentication is
     * required on SSL connections accepted by server sockets created
     * by this factory.&lt;/p&gt;
     *
     * @return &lt;code&gt;true&lt;/code&gt; if client authentication is required
     *
     * @see SSLSocket#setNeedClientAuth
     */
    public final boolean getNeedClientAuth() {
        return needClientAuth;
    }

    /**
     * &lt;p&gt;Creates a server socket that accepts SSL connections
     * configured according to this factory's SSL socket configuration
     * parameters.&lt;/p&gt;
     */
    public ServerSocket createServerSocket(int port) throws IOException {
        final SSLSocketFactory sslSocketFactory =
                context == null ?
                    getDefaultSSLSocketFactory() : context.getSocketFactory();
        return new ServerSocket(port) {
            public Socket accept() throws IOException {
                Socket socket = super.accept();
                SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(
                        socket, socket.getInetAddress().getHostName(),
                        socket.getPort(), true);
                sslSocket.setUseClientMode(false);
                if (enabledCipherSuites != null) {
                    sslSocket.setEnabledCipherSuites(enabledCipherSuites);
                }
                if (enabledProtocols != null) {
                    sslSocket.setEnabledProtocols(enabledProtocols);
                }
                sslSocket.setNeedClientAuth(needClientAuth);
                return sslSocket;
            }
        };
    }

    /**
     * &lt;p&gt;Indicates whether some other object is &quot;equal to&quot; this one.&lt;/p&gt;
     *
     * &lt;p&gt;Two &lt;code&gt;SslRMIServerSocketFactory&lt;/code&gt; objects are equal
     * if they have been constructed with the same SSL context and
     * SSL socket configuration parameters.&lt;/p&gt;
     *
     * &lt;p&gt;A subclass should override this method (as well as
     * {@link #hashCode()}) if it adds instance state that affects
     * equality.&lt;/p&gt;
     */
    public boolean equals(Object obj) {
        if (obj == null) return false;
        if (obj == this) return true;
        if (!(obj instanceof SslRMIServerSocketFactory))
            return false;
        SslRMIServerSocketFactory that = (SslRMIServerSocketFactory) obj;
        return (getClass().equals(that.getClass()) &amp;&amp; checkParameters(that));
    }

    private boolean checkParameters(SslRMIServerSocketFactory that) {
        // SSL context
        //
        if (context == null ? that.context != null : !context.equals(that.context))
            return false;

        // needClientAuth flag
        //
        if (needClientAuth != that.needClientAuth)
            return false;

        // enabledCipherSuites
        //
        if ((enabledCipherSuites == null &amp;&amp; that.enabledCipherSuites != null) ||
                (enabledCipherSuites != null &amp;&amp; that.enabledCipherSuites == null))
            return false;
        if (enabledCipherSuites != null &amp;&amp; that.enabledCipherSuites != null) {
            List&lt;String&gt; thatEnabledCipherSuitesList =
                    Arrays.asList(that.enabledCipherSuites);
            if (!enabledCipherSuitesList.equals(thatEnabledCipherSuitesList))
                return false;
        }

        // enabledProtocols
        //
        if ((enabledProtocols == null &amp;&amp; that.enabledProtocols != null) ||
                (enabledProtocols != null &amp;&amp; that.enabledProtocols == null))
            return false;
        if (enabledProtocols != null &amp;&amp; that.enabledProtocols != null) {
            List&lt;String&gt; thatEnabledProtocolsList =
                    Arrays.asList(that.enabledProtocols);
            if (!enabledProtocolsList.equals(thatEnabledProtocolsList))
                return false;
        }

        return true;
    }

    /**
     * &lt;p&gt;Returns a hash code value for this
     * &lt;code&gt;SslRMIServerSocketFactory&lt;/code&gt;.&lt;/p&gt;
     *
     * @return a hash code value for this
     * &lt;code&gt;SslRMIServerSocketFactory&lt;/code&gt;.
     */
    public int hashCode() {
        return getClass().hashCode() +
                (context == null ? 0 : context.hashCode()) +
                (needClientAuth ? Boolean.TRUE.hashCode() : Boolean.FALSE.hashCode()) +
                (enabledCipherSuites == null ? 0 : enabledCipherSuitesList.hashCode()) +
                (enabledProtocols == null ? 0 : enabledProtocolsList.hashCode());
    }

    // We use a static field because:
    //
    //    SSLSocketFactory.getDefault() always returns the same object
    //    (at least on Sun's implementation), and we want to make sure
    //    that the Javadoc &amp; the implementation stay in sync.
    //
    // If someone needs to have different SslRMIServerSocketFactory
    // factories with different underlying SSLSocketFactory objects
    // using different keystores and truststores, he/she can always
    // use the constructor that takes an SSLContext as input.
    //
    private static SSLSocketFactory defaultSSLSocketFactory = null;

    private static synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
        if (defaultSSLSocketFactory == null)
            defaultSSLSocketFactory =
                    (SSLSocketFactory) SSLSocketFactory.getDefault();
        return defaultSSLSocketFactory;
    }

    private final String[] enabledCipherSuites;
    private final String[] enabledProtocols;
    private final boolean needClientAuth;
    private List&lt;String&gt; enabledCipherSuitesList;
    private List&lt;String&gt; enabledProtocolsList;
    private SSLContext context;
}
</pre>
</body>
</html>
