<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.sql.rowset;

import java.sql.*;
import javax.sql.*;
import javax.naming.*;
import java.io.*;
import java.math.*;
import java.util.*;

import javax.sql.rowset.spi.*;

/**
 * The interface that all standard implementations of
 * &lt;code&gt;CachedRowSet&lt;/code&gt; must implement.
 * &lt;P&gt;
 * The reference implementation of the &lt;code&gt;CachedRowSet&lt;/code&gt; interface provided
 * by Oracle Corporation is a standard implementation. Developers may use this implementation
 * just as it is, they may extend it, or they may choose to write their own implementations
 * of this interface.
 * &lt;P&gt;
 * A &lt;code&gt;CachedRowSet&lt;/code&gt; object is a container for rows of data
 * that caches its rows in memory, which makes it possible to operate without always being
 * connected to its data source. Further, it is a
 * JavaBeans&amp;trade; component and is scrollable,
 * updatable, and serializable. A &lt;code&gt;CachedRowSet&lt;/code&gt; object typically
 * contains rows from a result set, but it can also contain rows from any file
 * with a tabular format, such as a spread sheet.  The reference implementation
 * supports getting data only from a &lt;code&gt;ResultSet&lt;/code&gt; object, but
 * developers can extend the &lt;code&gt;SyncProvider&lt;/code&gt; implementations to provide
 * access to other tabular data sources.
 * &lt;P&gt;
 * An application can modify the data in a &lt;code&gt;CachedRowSet&lt;/code&gt; object, and
 * those modifications can then be propagated back to the source of the data.
 * &lt;P&gt;
 * A &lt;code&gt;CachedRowSet&lt;/code&gt; object is a &lt;i&gt;disconnected&lt;/i&gt; rowset, which means
 * that it makes use of a connection to its data source only briefly. It connects to its
 * data source while it is reading data to populate itself with rows and again
 * while it is propagating changes back to its underlying data source. The rest
 * of the time, a &lt;code&gt;CachedRowSet&lt;/code&gt; object is disconnected, including
 * while its data is being modified. Being disconnected makes a &lt;code&gt;RowSet&lt;/code&gt;
 * object much leaner and therefore much easier to pass to another component.  For
 * example, a disconnected &lt;code&gt;RowSet&lt;/code&gt; object can be serialized and passed
 * over the wire to a thin client such as a personal digital assistant (PDA).
 *
 *
 * &lt;h3&gt;1.0 Creating a &lt;code&gt;CachedRowSet&lt;/code&gt; Object&lt;/h3&gt;
 * The following line of code uses the default constructor for
 * &lt;code&gt;CachedRowSet&lt;/code&gt;
 * supplied in the reference implementation (RI) to create a default
 * &lt;code&gt;CachedRowSet&lt;/code&gt; object.
 * &lt;PRE&gt;
 *     CachedRowSetImpl crs = new CachedRowSetImpl();
 * &lt;/PRE&gt;
 * This new &lt;code&gt;CachedRowSet&lt;/code&gt; object will have its properties set to the
 * default properties of a &lt;code&gt;BaseRowSet&lt;/code&gt; object, and, in addition, it will
 * have an &lt;code&gt;RIOptimisticProvider&lt;/code&gt; object as its synchronization provider.
 * &lt;code&gt;RIOptimisticProvider&lt;/code&gt;, one of two &lt;code&gt;SyncProvider&lt;/code&gt;
 * implementations included in the RI, is the default provider that the
 * &lt;code&gt;SyncFactory&lt;/code&gt; singleton will supply when no synchronization
 * provider is specified.
 * &lt;P&gt;
 * A &lt;code&gt;SyncProvider&lt;/code&gt; object provides a &lt;code&gt;CachedRowSet&lt;/code&gt; object
 * with a reader (a &lt;code&gt;RowSetReader&lt;/code&gt; object) for reading data from a
 * data source to populate itself with data. A reader can be implemented to read
 * data from a &lt;code&gt;ResultSet&lt;/code&gt; object or from a file with a tabular format.
 * A &lt;code&gt;SyncProvider&lt;/code&gt; object also provides
 * a writer (a &lt;code&gt;RowSetWriter&lt;/code&gt; object) for synchronizing any
 * modifications to the &lt;code&gt;CachedRowSet&lt;/code&gt; object's data made while it was
 * disconnected with the data in the underlying data source.
 * &lt;P&gt;
 * A writer can be implemented to exercise various degrees of care in checking
 * for conflicts and in avoiding them.
 * (A conflict occurs when a value in the data source has been changed after
 * the rowset populated itself with that value.)
 * The &lt;code&gt;RIOptimisticProvider&lt;/code&gt; implementation assumes there will be
 * few or no conflicts and therefore sets no locks. It updates the data source
 * with values from the &lt;code&gt;CachedRowSet&lt;/code&gt; object only if there are no
 * conflicts.
 * Other writers can be implemented so that they always write modified data to
 * the data source, which can be accomplished either by not checking for conflicts
 * or, on the other end of the spectrum, by setting locks sufficient to prevent data
 * in the data source from being changed. Still other writer implementations can be
 * somewhere in between.
 * &lt;P&gt;
 * A &lt;code&gt;CachedRowSet&lt;/code&gt; object may use any
 * &lt;code&gt;SyncProvider&lt;/code&gt; implementation that has been registered
 * with the &lt;code&gt;SyncFactory&lt;/code&gt; singleton. An application
 * can find out which &lt;code&gt;SyncProvider&lt;/code&gt; implementations have been
 * registered by calling the following line of code.
 * &lt;PRE&gt;
 *      java.util.Enumeration providers = SyncFactory.getRegisteredProviders();
 * &lt;/PRE&gt;
 * &lt;P&gt;
 * There are two ways for a &lt;code&gt;CachedRowSet&lt;/code&gt; object to specify which
 * &lt;code&gt;SyncProvider&lt;/code&gt; object it will use.
 * &lt;UL&gt;
 *     &lt;LI&gt;Supplying the name of the implementation to the constructor&lt;BR&gt;
 *     The following line of code creates the &lt;code&gt;CachedRowSet&lt;/code&gt;
 *     object &lt;i&gt;crs2&lt;/i&gt; that is initialized with default values except that its
 *     &lt;code&gt;SyncProvider&lt;/code&gt; object is the one specified.
 *     &lt;PRE&gt;
 *          CachedRowSetImpl crs2 = new CachedRowSetImpl(
 *                                 &quot;com.fred.providers.HighAvailabilityProvider&quot;);
 *     &lt;/PRE&gt;
 *     &lt;LI&gt;Setting the &lt;code&gt;SyncProvider&lt;/code&gt; using the &lt;code&gt;CachedRowSet&lt;/code&gt;
 *         method &lt;code&gt;setSyncProvider&lt;/code&gt;&lt;BR&gt;
 *      The following line of code resets the &lt;code&gt;SyncProvider&lt;/code&gt; object
 *      for &lt;i&gt;crs&lt;/i&gt;, the &lt;code&gt;CachedRowSet&lt;/code&gt; object created with the
 *      default constructor.
 *      &lt;PRE&gt;
 *           crs.setSyncProvider(&quot;com.fred.providers.HighAvailabilityProvider&quot;);
 *      &lt;/PRE&gt;
 * &lt;/UL&gt;
 * See the comments for &lt;code&gt;SyncFactory&lt;/code&gt; and &lt;code&gt;SyncProvider&lt;/code&gt; for
 * more details.
 *
 *
 * &lt;h3&gt;2.0 Retrieving Data from a &lt;code&gt;CachedRowSet&lt;/code&gt; Object&lt;/h3&gt;
 * Data is retrieved from a &lt;code&gt;CachedRowSet&lt;/code&gt; object by using the
 * getter methods inherited from the &lt;code&gt;ResultSet&lt;/code&gt;
 * interface.  The following examples, in which &lt;code&gt;crs&lt;/code&gt; is a
 * &lt;code&gt;CachedRowSet&lt;/code&gt;
 * object, demonstrate how to iterate through the rows, retrieving the column
 * values in each row.  The first example uses the version of the
 * getter methods that take a column number; the second example
 * uses the version that takes a column name. Column numbers are generally
 * used when the &lt;code&gt;RowSet&lt;/code&gt; object's command
 * is of the form &lt;code&gt;SELECT * FROM TABLENAME&lt;/code&gt;; column names are most
 * commonly used when the command specifies columns by name.
 * &lt;PRE&gt;
 *    while (crs.next()) {
 *        String name = crs.getString(1);
 *        int id = crs.getInt(2);
 *        Clob comment = crs.getClob(3);
 *        short dept = crs.getShort(4);
 *        System.out.println(name + &quot;  &quot; + id + &quot;  &quot; + comment + &quot;  &quot; + dept);
 *    }
 * &lt;/PRE&gt;
 *
 * &lt;PRE&gt;
 *    while (crs.next()) {
 *        String name = crs.getString(&quot;NAME&quot;);
 *        int id = crs.getInt(&quot;ID&quot;);
 *        Clob comment = crs.getClob(&quot;COM&quot;);
 *        short dept = crs.getShort(&quot;DEPT&quot;);
 *        System.out.println(name + &quot;  &quot; + id + &quot;  &quot; + comment + &quot;  &quot; + dept);
 *    }
 * &lt;/PRE&gt;
 * &lt;h4&gt;2.1 Retrieving &lt;code&gt;RowSetMetaData&lt;/code&gt;&lt;/h4&gt;
 * An application can get information about the columns in a &lt;code&gt;CachedRowSet&lt;/code&gt;
 * object by calling &lt;code&gt;ResultSetMetaData&lt;/code&gt; and &lt;code&gt;RowSetMetaData&lt;/code&gt;
 * methods on a &lt;code&gt;RowSetMetaData&lt;/code&gt; object. The following code fragment,
 * in which &lt;i&gt;crs&lt;/i&gt; is a &lt;code&gt;CachedRowSet&lt;/code&gt; object, illustrates the process.
 * The first line creates a &lt;code&gt;RowSetMetaData&lt;/code&gt; object with information
 * about the columns in &lt;i&gt;crs&lt;/i&gt;.  The method &lt;code&gt;getMetaData&lt;/code&gt;,
 * inherited from the &lt;code&gt;ResultSet&lt;/code&gt; interface, returns a
 * &lt;code&gt;ResultSetMetaData&lt;/code&gt; object, which is cast to a
 * &lt;code&gt;RowSetMetaData&lt;/code&gt; object before being assigned to the variable
 * &lt;i&gt;rsmd&lt;/i&gt;.  The second line finds out how many columns &lt;i&gt;jrs&lt;/i&gt; has, and
 * the third line gets the JDBC type of values stored in the second column of
 * &lt;code&gt;jrs&lt;/code&gt;.
 * &lt;PRE&gt;
 *     RowSetMetaData rsmd = (RowSetMetaData)crs.getMetaData();
 *     int count = rsmd.getColumnCount();
 *     int type = rsmd.getColumnType(2);
 * &lt;/PRE&gt;
 * The &lt;code&gt;RowSetMetaData&lt;/code&gt; interface differs from the
 * &lt;code&gt;ResultSetMetaData&lt;/code&gt; interface in two ways.
 * &lt;UL&gt;
 *   &lt;LI&gt;&lt;i&gt;It includes &lt;code&gt;setter&lt;/code&gt; methods:&lt;/i&gt; A &lt;code&gt;RowSet&lt;/code&gt;
 *   object uses these methods internally when it is populated with data from a
 *   different &lt;code&gt;ResultSet&lt;/code&gt; object.
 *
 *   &lt;LI&gt;&lt;i&gt;It contains fewer &lt;code&gt;getter&lt;/code&gt; methods:&lt;/i&gt; Some
 *   &lt;code&gt;ResultSetMetaData&lt;/code&gt; methods to not apply to a &lt;code&gt;RowSet&lt;/code&gt;
 *   object. For example, methods retrieving whether a column value is writable
 *   or read only do not apply because all of a &lt;code&gt;RowSet&lt;/code&gt; object's
 *   columns will be writable or read only, depending on whether the rowset is
 *   updatable or not.
 * &lt;/UL&gt;
 * NOTE: In order to return a &lt;code&gt;RowSetMetaData&lt;/code&gt; object, implementations must
 * override the &lt;code&gt;getMetaData()&lt;/code&gt; method defined in
 * &lt;code&gt;java.sql.ResultSet&lt;/code&gt; and return a &lt;code&gt;RowSetMetaData&lt;/code&gt; object.
 *
 * &lt;h3&gt;3.0 Updating a &lt;code&gt;CachedRowSet&lt;/code&gt; Object&lt;/h3&gt;
 * Updating a &lt;code&gt;CachedRowSet&lt;/code&gt; object is similar to updating a
 * &lt;code&gt;ResultSet&lt;/code&gt; object, but because the rowset is not connected to
 * its data source while it is being updated, it must take an additional step
 * to effect changes in its underlying data source. After calling the method
 * &lt;code&gt;updateRow&lt;/code&gt; or &lt;code&gt;insertRow&lt;/code&gt;, a
 * &lt;code&gt;CachedRowSet&lt;/code&gt;
 * object must also call the method &lt;code&gt;acceptChanges&lt;/code&gt; to have updates
 * written to the data source. The following example, in which the cursor is
 * on a row in the &lt;code&gt;CachedRowSet&lt;/code&gt; object &lt;i&gt;crs&lt;/i&gt;, shows
 * the code required to update two column values in the current row and also
 * update the &lt;code&gt;RowSet&lt;/code&gt; object's underlying data source.
 * &lt;PRE&gt;
 *     crs.updateShort(3, 58);
 *     crs.updateInt(4, 150000);
 *     crs.updateRow();
 *     crs.acceptChanges();
 * &lt;/PRE&gt;
 * &lt;P&gt;
 * The next example demonstrates moving to the insert row, building a new
 * row on the insert row, inserting it into the rowset, and then calling the
 * method &lt;code&gt;acceptChanges&lt;/code&gt; to add the new row to the underlying data
 * source.  Note that as with the getter methods, the  updater methods may take
 * either a column index or a column name to designate the column being acted upon.
 * &lt;PRE&gt;
 *     crs.moveToInsertRow();
 *     crs.updateString(&quot;Name&quot;, &quot;Shakespeare&quot;);
 *     crs.updateInt(&quot;ID&quot;, 10098347);
 *     crs.updateShort(&quot;Age&quot;, 58);
 *     crs.updateInt(&quot;Sal&quot;, 150000);
 *     crs.insertRow();
 *     crs.moveToCurrentRow();
 *     crs.acceptChanges();
 * &lt;/PRE&gt;
 * &lt;P&gt;
 * NOTE: Where the &lt;code&gt;insertRow()&lt;/code&gt; method inserts the contents of a
 * &lt;code&gt;CachedRowSet&lt;/code&gt; object's insert row is implementation-defined.
 * The reference implementation for the &lt;code&gt;CachedRowSet&lt;/code&gt; interface
 * inserts a new row immediately following the current row, but it could be
 * implemented to insert new rows in any number of other places.
 * &lt;P&gt;
 * Another thing to note about these examples is how they use the method
 * &lt;code&gt;acceptChanges&lt;/code&gt;.  It is this method that propagates changes in
 * a &lt;code&gt;CachedRowSet&lt;/code&gt; object back to the underlying data source,
 * calling on the &lt;code&gt;RowSet&lt;/code&gt; object's writer internally to write
 * changes to the data source. To do this, the writer has to incur the expense
 * of establishing a connection with that data source. The
 * preceding two code fragments call the method &lt;code&gt;acceptChanges&lt;/code&gt;
 * immediately after calling &lt;code&gt;updateRow&lt;/code&gt; or &lt;code&gt;insertRow&lt;/code&gt;.
 * However, when there are multiple rows being changed, it is more efficient to call
 * &lt;code&gt;acceptChanges&lt;/code&gt; after all calls to &lt;code&gt;updateRow&lt;/code&gt;
 * and &lt;code&gt;insertRow&lt;/code&gt; have been made.  If &lt;code&gt;acceptChanges&lt;/code&gt;
 * is called only once, only one connection needs to be established.
 *
 * &lt;h3&gt;4.0 Updating the Underlying Data Source&lt;/h3&gt;
 * When the method &lt;code&gt;acceptChanges&lt;/code&gt; is executed, the
 * &lt;code&gt;CachedRowSet&lt;/code&gt; object's writer, a &lt;code&gt;RowSetWriterImpl&lt;/code&gt;
 * object, is called behind the scenes to write the changes made to the
 * rowset to the underlying data source. The writer is implemented to make a
 * connection to the data source and write updates to it.
 * &lt;P&gt;
 * A writer is made available through an implementation of the
 * &lt;code&gt;SyncProvider&lt;/code&gt; interface, as discussed in section 1,
 * &quot;Creating a &lt;code&gt;CachedRowSet&lt;/code&gt; Object.&quot;
 * The default reference implementation provider, &lt;code&gt;RIOptimisticProvider&lt;/code&gt;,
 * has its writer implemented to use an optimistic concurrency control
 * mechanism. That is, it maintains no locks in the underlying database while
 * the rowset is disconnected from the database and simply checks to see if there
 * are any conflicts before writing data to the data source.  If there are any
 * conflicts, it does not write anything to the data source.
 * &lt;P&gt;
 * The reader/writer facility
 * provided by the &lt;code&gt;SyncProvider&lt;/code&gt; class is pluggable, allowing for the
 * customization of data retrieval and updating. If a different concurrency
 * control mechanism is desired, a different implementation of
 * &lt;code&gt;SyncProvider&lt;/code&gt; can be plugged in using the method
 * &lt;code&gt;setSyncProvider&lt;/code&gt;.
 * &lt;P&gt;
 * In order to use the optimistic concurrency control routine, the
 * &lt;code&gt;RIOptismisticProvider&lt;/code&gt; maintains both its current
 * value and its original value (the value it had immediately preceding the
 * current value). Note that if no changes have been made to the data in a
 * &lt;code&gt;RowSet&lt;/code&gt; object, its current values and its original values are the same,
 * both being the values with which the &lt;code&gt;RowSet&lt;/code&gt; object was initially
 * populated.  However, once any values in the &lt;code&gt;RowSet&lt;/code&gt; object have been
 * changed, the current values and the original values will be different, though at
 * this stage, the original values are still the initial values. With any subsequent
 * changes to data in a &lt;code&gt;RowSet&lt;/code&gt; object, its original values and current
 * values will still differ, but its original values will be the values that
 * were previously the current values.
 * &lt;P&gt;
 * Keeping track of original values allows the writer to compare the &lt;code&gt;RowSet&lt;/code&gt;
 * object's original value with the value in the database. If the values in
 * the database differ from the &lt;code&gt;RowSet&lt;/code&gt; object's original values, which means that
 * the values in the database have been changed, there is a conflict.
 * Whether a writer checks for conflicts, what degree of checking it does, and how
 * it handles conflicts all depend on how it is implemented.
 *
 * &lt;h3&gt;5.0 Registering and Notifying Listeners&lt;/h3&gt;
 * Being JavaBeans components, all rowsets participate in the JavaBeans event
 * model, inheriting methods for registering listeners and notifying them of
 * changes from the &lt;code&gt;BaseRowSet&lt;/code&gt; class.  A listener for a
 * &lt;code&gt;CachedRowSet&lt;/code&gt; object is a component that wants to be notified
 * whenever there is a change in the rowset.  For example, if a
 * &lt;code&gt;CachedRowSet&lt;/code&gt; object contains the results of a query and
 * those
 * results are being displayed in, say, a table and a bar graph, the table and
 * bar graph could be registered as listeners with the rowset so that they can
 * update themselves to reflect changes. To become listeners, the table and
 * bar graph classes must implement the &lt;code&gt;RowSetListener&lt;/code&gt; interface.
 * Then they can be added to the &lt;Code&gt;CachedRowSet&lt;/code&gt; object's list of
 * listeners, as is illustrated in the following lines of code.
 * &lt;PRE&gt;
 *    crs.addRowSetListener(table);
 *    crs.addRowSetListener(barGraph);
 * &lt;/PRE&gt;
 * Each &lt;code&gt;CachedRowSet&lt;/code&gt; method that moves the cursor or changes
 * data also notifies registered listeners of the changes, so
 * &lt;code&gt;table&lt;/code&gt; and &lt;code&gt;barGraph&lt;/code&gt; will be notified when there is
 * a change in &lt;code&gt;crs&lt;/code&gt;.
 *
 * &lt;h3&gt;6.0 Passing Data to Thin Clients&lt;/h3&gt;
 * One of the main reasons to use a &lt;code&gt;CachedRowSet&lt;/code&gt; object is to
 * pass data between different components of an application. Because it is
 * serializable, a &lt;code&gt;CachedRowSet&lt;/code&gt; object can be used, for example,
 * to send the result of a query executed by an enterprise JavaBeans component
 * running in a server environment over a network to a client running in a
 * web browser.
 * &lt;P&gt;
 * While a &lt;code&gt;CachedRowSet&lt;/code&gt; object is disconnected, it can be much
 * leaner than a &lt;code&gt;ResultSet&lt;/code&gt; object with the same data.
 * As a result, it can be especially suitable for sending data to a thin client
 * such as a PDA, where it would be inappropriate to use a JDBC driver
 * due to resource limitations or security considerations.
 * Thus, a &lt;code&gt;CachedRowSet&lt;/code&gt; object provides a means to &quot;get rows in&quot;
 * without the need to implement the full JDBC API.
 *
 * &lt;h3&gt;7.0 Scrolling and Updating&lt;/h3&gt;
 * A second major use for &lt;code&gt;CachedRowSet&lt;/code&gt; objects is to provide
 * scrolling and updating for &lt;code&gt;ResultSet&lt;/code&gt; objects that
 * do not provide these capabilities themselves.  In other words, a
 * &lt;code&gt;CachedRowSet&lt;/code&gt; object can be used to augment the
 * capabilities of a JDBC technology-enabled driver (hereafter called a
 * &quot;JDBC driver&quot;) when the DBMS does not provide full support for scrolling and
 * updating. To achieve the effect of making a non-scrollble and read-only
 * &lt;code&gt;ResultSet&lt;/code&gt; object scrollable and updatable, a programmer
 * simply needs to create a &lt;code&gt;CachedRowSet&lt;/code&gt; object populated
 * with that &lt;code&gt;ResultSet&lt;/code&gt; object's data.  This is demonstrated
 * in the following code fragment, where &lt;code&gt;stmt&lt;/code&gt; is a
 * &lt;code&gt;Statement&lt;/code&gt; object.
 * &lt;PRE&gt;
 *    ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM EMPLOYEES&quot;);
 *    CachedRowSetImpl crs = new CachedRowSetImpl();
 *    crs.populate(rs);
 * &lt;/PRE&gt;
 * &lt;P&gt;
 * The object &lt;code&gt;crs&lt;/code&gt; now contains the data from the table
 * &lt;code&gt;EMPLOYEES&lt;/code&gt;, just as the object &lt;code&gt;rs&lt;/code&gt; does.
 * The difference is that the cursor for &lt;code&gt;crs&lt;/code&gt; can be moved
 * forward, backward, or to a particular row even if the cursor for
 * &lt;code&gt;rs&lt;/code&gt; can move only forward.  In addition, &lt;code&gt;crs&lt;/code&gt; is
 * updatable even if &lt;code&gt;rs&lt;/code&gt; is not because by default, a
 * &lt;code&gt;CachedRowSet&lt;/code&gt; object is both scrollable and updatable.
 * &lt;P&gt;
 * In summary, a &lt;code&gt;CachedRowSet&lt;/code&gt; object can be thought of as simply
 * a disconnected set of rows that are being cached outside of a data source.
 * Being thin and serializable, it can easily be sent across a wire,
 * and it is well suited to sending data to a thin client. However, a
 * &lt;code&gt;CachedRowSet&lt;/code&gt; object does have a limitation: It is limited in
 * size by the amount of data it can store in memory at one time.
 *
 * &lt;h3&gt;8.0 Getting Universal Data Access&lt;/h3&gt;
 * Another advantage of the &lt;code&gt;CachedRowSet&lt;/code&gt; class is that it makes it
 * possible to retrieve and store data from sources other than a relational
 * database. The reader for a rowset can be implemented to read and populate
 * its rowset with data from any tabular data source, including a spreadsheet
 * or flat file.
 * Because both a &lt;code&gt;CachedRowSet&lt;/code&gt; object and its metadata can be
 * created from scratch, a component that acts as a factory for rowsets
 * can use this capability to create a rowset containing data from
 * non-SQL data sources. Nevertheless, it is expected that most of the time,
 * &lt;code&gt;CachedRowSet&lt;/code&gt; objects will contain data that was fetched
 * from an SQL database using the JDBC API.
 *
 * &lt;h3&gt;9.0 Setting Properties&lt;/h3&gt;
 * All rowsets maintain a set of properties, which will usually be set using
 * a tool.  The number and kinds of properties a rowset has will vary,
 * depending on what the rowset does and how it gets its data.  For example,
 * rowsets that get their data from a &lt;code&gt;ResultSet&lt;/code&gt; object need to
 * set the properties that are required for making a database connection.
 * If a rowset uses the &lt;code&gt;DriverManager&lt;/code&gt; facility to make a
 * connection, it needs to set a property for the JDBC URL that identifies
 * the appropriate driver, and it needs to set the properties that give the
 * user name and password.
 * If, on the other hand, the rowset uses a &lt;code&gt;DataSource&lt;/code&gt; object
 * to make the connection, which is the preferred method, it does not need to
 * set the property for the JDBC URL.  Instead, it needs to set
 * properties for the logical name of the data source, for the user name,
 * and for the password.
 * &lt;P&gt;
 * NOTE:  In order to use a &lt;code&gt;DataSource&lt;/code&gt; object for making a
 * connection, the &lt;code&gt;DataSource&lt;/code&gt; object must have been registered
 * with a naming service that uses the Java Naming and Directory
 * Interface&amp;trade; (JNDI) API.  This registration
 * is usually done by a person acting in the capacity of a system
 * administrator.
 * &lt;P&gt;
 * In order to be able to populate itself with data from a database, a rowset
 * needs to set a command property.  This property is a query that is a
 * &lt;code&gt;PreparedStatement&lt;/code&gt; object, which allows the query to have
 * parameter placeholders that are set at run time, as opposed to design time.
 * To set these placeholder parameters with values, a rowset provides
 * setter methods for setting values of each data type,
 * similar to the setter methods provided by the &lt;code&gt;PreparedStatement&lt;/code&gt;
 * interface.
 * &lt;P&gt;
 * The following code fragment illustrates how the &lt;code&gt;CachedRowSet&lt;/code&gt;
 * object &lt;code&gt;crs&lt;/code&gt; might have its command property set.  Note that if a
 * tool is used to set properties, this is the code that the tool would use.
 * &lt;PRE&gt;{@code
 *    crs.setCommand(&quot;SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS &quot; +
 *                   &quot;WHERE CREDIT_LIMIT &gt; ? AND REGION = ?&quot;);
 * } &lt;/PRE&gt;
 * &lt;P&gt;
 * The values that will be used to set the command's placeholder parameters are
 * contained in the &lt;code&gt;RowSet&lt;/code&gt; object's &lt;code&gt;params&lt;/code&gt; field, which is a
 * &lt;code&gt;Vector&lt;/code&gt; object.
 * The &lt;code&gt;CachedRowSet&lt;/code&gt; class provides a set of setter
 * methods for setting the elements in its &lt;code&gt;params&lt;/code&gt; field.  The
 * following code fragment demonstrates setting the two parameters in the
 * query from the previous example.
 * &lt;PRE&gt;
 *    crs.setInt(1, 5000);
 *    crs.setString(2, &quot;West&quot;);
 * &lt;/PRE&gt;
 * &lt;P&gt;
 * The &lt;code&gt;params&lt;/code&gt; field now contains two elements, each of which is
 * an array two elements long.  The first element is the parameter number;
 * the second is the value to be set.
 * In this case, the first element of &lt;code&gt;params&lt;/code&gt; is
 * &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;5000&lt;/code&gt;, and the second element is &lt;code&gt;2&lt;/code&gt;,
 * &lt;code&gt;&quot;West&quot;&lt;/code&gt;.  When an application calls the method
 * &lt;code&gt;execute&lt;/code&gt;, it will in turn call on this &lt;code&gt;RowSet&lt;/code&gt; object's reader,
 * which will in turn invoke its &lt;code&gt;readData&lt;/code&gt; method. As part of
 * its implementation, &lt;code&gt;readData&lt;/code&gt; will get the values in
 * &lt;code&gt;params&lt;/code&gt; and use them to set the command's placeholder
 * parameters.
 * The following code fragment gives an idea of how the reader
 * does this, after obtaining the &lt;code&gt;Connection&lt;/code&gt; object
 * &lt;code&gt;con&lt;/code&gt;.
 * &lt;PRE&gt;{@code
 *    PreparedStatement pstmt = con.prepareStatement(crs.getCommand());
 *    reader.decodeParams();
 *    // decodeParams figures out which setter methods to use and does something
 *    // like the following:
 *    //    for (i = 0; i &lt; params.length; i++) {
 *    //        pstmt.setObject(i + 1, params[i]);
 *    //    }
 * }&lt;/PRE&gt;
 * &lt;P&gt;
 * At this point, the command for &lt;code&gt;crs&lt;/code&gt; is the query {@code &quot;SELECT
 * FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS WHERE CREDIT_LIMIT &gt; 5000
 * AND REGION = &quot;West&quot;}.  After the &lt;code&gt;readData&lt;/code&gt; method executes
 * this command with the following line of code, it will have the data from
 * &lt;code&gt;rs&lt;/code&gt; with which to populate &lt;code&gt;crs&lt;/code&gt;.
 * &lt;PRE&gt;{@code
 *     ResultSet rs = pstmt.executeQuery();
 * }&lt;/PRE&gt;
 * &lt;P&gt;
 * The preceding code fragments give an idea of what goes on behind the
 * scenes; they would not appear in an application, which would not invoke
 * methods like &lt;code&gt;readData&lt;/code&gt; and &lt;code&gt;decodeParams&lt;/code&gt;.
 * In contrast, the following code fragment shows what an application might do.
 * It sets the rowset's command, sets the command's parameters, and executes
 * the command. Simply by calling the &lt;code&gt;execute&lt;/code&gt; method,
 * &lt;code&gt;crs&lt;/code&gt; populates itself with the requested data from the
 * table &lt;code&gt;CUSTOMERS&lt;/code&gt;.
 * &lt;PRE&gt;{@code
 *    crs.setCommand(&quot;SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS&quot; +
 *                   &quot;WHERE CREDIT_LIMIT &gt; ? AND REGION = ?&quot;);
 *    crs.setInt(1, 5000);
 *    crs.setString(2, &quot;West&quot;);
 *    crs.execute();
 * }&lt;/PRE&gt;
 *
 * &lt;h3&gt;10.0 Paging Data&lt;/h3&gt;
 * Because a &lt;code&gt;CachedRowSet&lt;/code&gt; object stores data in memory,
 * the amount of data that it can contain at any one
 * time is determined by the amount of memory available. To get around this limitation,
 * a &lt;code&gt;CachedRowSet&lt;/code&gt; object can retrieve data from a &lt;code&gt;ResultSet&lt;/code&gt;
 * object in chunks of data, called &lt;i&gt;pages&lt;/i&gt;. To take advantage of this mechanism,
 * an application sets the number of rows to be included in a page using the method
 * &lt;code&gt;setPageSize&lt;/code&gt;. In other words, if the page size is set to five, a chunk
 * of five rows of
 * data will be fetched from the data source at one time. An application can also
 * optionally set the maximum number of rows that may be fetched at one time.  If the
 * maximum number of rows is set to zero, or no maximum number of rows is set, there is
 * no limit to the number of rows that may be fetched at a time.
 * &lt;P&gt;
 * After properties have been set,
 * the &lt;code&gt;CachedRowSet&lt;/code&gt; object must be populated with data
 * using either the method &lt;code&gt;populate&lt;/code&gt; or the method &lt;code&gt;execute&lt;/code&gt;.
 * The following lines of code demonstrate using the method &lt;code&gt;populate&lt;/code&gt;.
 * Note that this version of the method takes two parameters, a &lt;code&gt;ResultSet&lt;/code&gt;
 * handle and the row in the &lt;code&gt;ResultSet&lt;/code&gt; object from which to start
 * retrieving rows.
 * &lt;PRE&gt;
 *     CachedRowSet crs = new CachedRowSetImpl();
 *     crs.setMaxRows(20);
 *     crs.setPageSize(4);
 *     crs.populate(rsHandle, 10);
 * &lt;/PRE&gt;
 * When this code runs, &lt;i&gt;crs&lt;/i&gt; will be populated with four rows from
 * &lt;i&gt;rsHandle&lt;/i&gt; starting with the tenth row.
 * &lt;P&gt;
 * The next code fragment shows populating a &lt;code&gt;CachedRowSet&lt;/code&gt; object using the
 * method &lt;code&gt;execute&lt;/code&gt;, which may or may not take a &lt;code&gt;Connection&lt;/code&gt;
 * object as a parameter.  This code passes &lt;code&gt;execute&lt;/code&gt; the &lt;code&gt;Connection&lt;/code&gt;
 * object &lt;i&gt;conHandle&lt;/i&gt;.
 * &lt;P&gt;
 * Note that there are two differences between the following code
 * fragment and the previous one. First, the method &lt;code&gt;setMaxRows&lt;/code&gt; is not
 * called, so there is no limit set for the number of rows that &lt;i&gt;crs&lt;/i&gt; may contain.
 * (Remember that &lt;i&gt;crs&lt;/i&gt; always has the overriding limit of how much data it can
 * store in memory.) The second difference is that the you cannot pass the method
 * &lt;code&gt;execute&lt;/code&gt; the number of the row in the &lt;code&gt;ResultSet&lt;/code&gt; object
 * from which to start retrieving rows. This method always starts with the first row.
 * &lt;PRE&gt;
 *     CachedRowSet crs = new CachedRowSetImpl();
 *     crs.setPageSize(5);
 *     crs.execute(conHandle);
 * &lt;/PRE&gt;
 * After this code has run, &lt;i&gt;crs&lt;/i&gt; will contain five rows of data from the
 * &lt;code&gt;ResultSet&lt;/code&gt; object produced by the command for &lt;i&gt;crs&lt;/i&gt;. The writer
 * for &lt;i&gt;crs&lt;/i&gt; will use &lt;i&gt;conHandle&lt;/i&gt; to connect to the data source and
 * execute the command for &lt;i&gt;crs&lt;/i&gt;. An application is then able to operate on the
 * data in &lt;i&gt;crs&lt;/i&gt; in the same way that it would operate on data in any other
 * &lt;code&gt;CachedRowSet&lt;/code&gt; object.
 * &lt;P&gt;
 * To access the next page (chunk of data), an application calls the method
 * &lt;code&gt;nextPage&lt;/code&gt;.  This method creates a new &lt;code&gt;CachedRowSet&lt;/code&gt; object
 * and fills it with the next page of data.  For example, assume that the
 * &lt;code&gt;CachedRowSet&lt;/code&gt; object's command returns a &lt;code&gt;ResultSet&lt;/code&gt; object
 * &lt;i&gt;rs&lt;/i&gt; with 1000 rows of data.  If the page size has been set to 100, the first
 *  call to the method &lt;code&gt;nextPage&lt;/code&gt; will create a &lt;code&gt;CachedRowSet&lt;/code&gt; object
 * containing the first 100 rows of &lt;i&gt;rs&lt;/i&gt;. After doing what it needs to do with the
 * data in these first 100 rows, the application can again call the method
 * &lt;code&gt;nextPage&lt;/code&gt; to create another &lt;code&gt;CachedRowSet&lt;/code&gt; object
 * with the second 100 rows from &lt;i&gt;rs&lt;/i&gt;. The data from the first &lt;code&gt;CachedRowSet&lt;/code&gt;
 * object will no longer be in memory because it is replaced with the data from the
 * second &lt;code&gt;CachedRowSet&lt;/code&gt; object. After the tenth call to the method &lt;code&gt;nextPage&lt;/code&gt;,
 * the tenth &lt;code&gt;CachedRowSet&lt;/code&gt; object will contain the last 100 rows of data from
 * &lt;i&gt;rs&lt;/i&gt;, which are stored in memory. At any given time, the data from only one
 * &lt;code&gt;CachedRowSet&lt;/code&gt; object is stored in memory.
 * &lt;P&gt;
 * The method &lt;code&gt;nextPage&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; as long as the current
 * page is not the last page of rows and &lt;code&gt;false&lt;/code&gt; when there are no more pages.
 * It can therefore be used in a &lt;code&gt;while&lt;/code&gt; loop to retrieve all of the pages,
 * as is demonstrated in the following lines of code.
 * &lt;PRE&gt;
 *     CachedRowSet crs = CachedRowSetImpl();
 *     crs.setPageSize(100);
 *     crs.execute(conHandle);
 *
 *     while(crs.nextPage()) {
 *         while(crs.next()) {
 *             . . . // operate on chunks (of 100 rows each) in crs,
 *                   // row by row
 *         }
 *     }
 * &lt;/PRE&gt;
 * After this code fragment has been run, the application will have traversed all
 * 1000 rows, but it will have had no more than 100 rows in memory at a time.
 * &lt;P&gt;
 * The &lt;code&gt;CachedRowSet&lt;/code&gt; interface also defines the method &lt;code&gt;previousPage&lt;/code&gt;.
 * Just as the method &lt;code&gt;nextPage&lt;/code&gt; is analogous to the &lt;code&gt;ResultSet&lt;/code&gt;
 * method &lt;code&gt;next&lt;/code&gt;, the method &lt;code&gt;previousPage&lt;/code&gt; is analogous to
 * the &lt;code&gt;ResultSet&lt;/code&gt; method &lt;code&gt;previous&lt;/code&gt;.  Similar to the method
 * &lt;code&gt;nextPage&lt;/code&gt;, &lt;code&gt;previousPage&lt;/code&gt; creates a &lt;code&gt;CachedRowSet&lt;/code&gt;
 * object containing the number of rows set as the page size.  So, for instance, the
 * method &lt;code&gt;previousPage&lt;/code&gt; could be used in a &lt;code&gt;while&lt;/code&gt; loop at
 * the end of the preceding code fragment to navigate back through the pages from the last
 * page to the first page.
 * The method &lt;code&gt;previousPage&lt;/code&gt; is also similar to &lt;code&gt;nextPage&lt;/code&gt;
 * in that it can be used in a &lt;code&gt;while&lt;/code&gt;
 * loop, except that it returns &lt;code&gt;true&lt;/code&gt; as long as there is another page
 * preceding it and &lt;code&gt;false&lt;/code&gt; when there are no more pages ahead of it.
 * &lt;P&gt;
 * By positioning the cursor after the last row for each page,
 * as is done in the following code fragment, the method &lt;code&gt;previous&lt;/code&gt;
 * navigates from the last row to the first row in each page.
 * The code could also have left the cursor before the first row on each page and then
 * used the method &lt;code&gt;next&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop to navigate each page
 * from the first row to the last row.
 * &lt;P&gt;
 * The following code fragment assumes a continuation from the previous code fragment,
 * meaning that the cursor for the tenth &lt;code&gt;CachedRowSet&lt;/code&gt; object is on the
 * last row.  The code moves the cursor to after the last row so that the first
 * call to the method &lt;code&gt;previous&lt;/code&gt; will put the cursor back on the last row.
 * After going through all of the rows in the last page (the &lt;code&gt;CachedRowSet&lt;/code&gt;
 * object &lt;i&gt;crs&lt;/i&gt;), the code then enters
 * the &lt;code&gt;while&lt;/code&gt; loop to get to the ninth page, go through the rows backwards,
 * go to the eighth page, go through the rows backwards, and so on to the first row
 * of the first page.
 *
 * &lt;PRE&gt;
 *     crs.afterLast();
 *     while(crs.previous())  {
 *         . . . // navigate through the rows, last to first
 *     {
 *     while(crs.previousPage())  {
 *         crs.afterLast();
 *         while(crs.previous())  {
 *             . . . // go from the last row to the first row of each page
 *         }
 *     }
 * &lt;/PRE&gt;
 *
 * @author Jonathan Bruce
 */

public interface CachedRowSet extends RowSet, Joinable {

   /**
    * Populates this &lt;code&gt;CachedRowSet&lt;/code&gt; object with data from
    * the given &lt;code&gt;ResultSet&lt;/code&gt; object.
    * &lt;P&gt;
    * This method can be used as an alternative to the &lt;code&gt;execute&lt;/code&gt; method when an
    * application has a connection to an open &lt;code&gt;ResultSet&lt;/code&gt; object.
    * Using the method &lt;code&gt;populate&lt;/code&gt; can be more efficient than using
    * the version of the &lt;code&gt;execute&lt;/code&gt; method that takes no parameters
    * because it does not open a new connection and re-execute this
    * &lt;code&gt;CachedRowSet&lt;/code&gt; object's command. Using the &lt;code&gt;populate&lt;/code&gt;
    * method is more a matter of convenience when compared to using the version
    * of &lt;code&gt;execute&lt;/code&gt; that takes a &lt;code&gt;ResultSet&lt;/code&gt; object.
    *
    * @param data the &lt;code&gt;ResultSet&lt;/code&gt; object containing the data
    * to be read into this &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * @throws SQLException if a null &lt;code&gt;ResultSet&lt;/code&gt; object is supplied
    * or this &lt;code&gt;CachedRowSet&lt;/code&gt; object cannot
    * retrieve the associated &lt;code&gt;ResultSetMetaData&lt;/code&gt; object
    * @see #execute
    * @see java.sql.ResultSet
    * @see java.sql.ResultSetMetaData
    */
    public void populate(ResultSet data) throws SQLException;

   /**
    * Populates this &lt;code&gt;CachedRowSet&lt;/code&gt; object with data, using the
    * given connection to produce the result set from which the data will be read.
    * This method should close any database connections that it creates to
    * ensure that this &lt;code&gt;CachedRowSet&lt;/code&gt; object is disconnected except when
    * it is reading data from its data source or writing data to its data source.
    * &lt;P&gt;
    * The reader for this &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * will use &lt;i&gt;conn&lt;/i&gt; to establish a connection to the data source
    * so that it can execute the rowset's command and read data from the
    * the resulting &lt;code&gt;ResultSet&lt;/code&gt; object into this
    * &lt;code&gt;CachedRowSet&lt;/code&gt; object. This method also closes &lt;i&gt;conn&lt;/i&gt;
    * after it has populated this &lt;code&gt;CachedRowSet&lt;/code&gt; object.
    * &lt;P&gt;
    * If this method is called when an implementation has already been
    * populated, the contents and the metadata are (re)set. Also, if this method is
    * called before the method &lt;code&gt;acceptChanges&lt;/code&gt; has been called
    * to commit outstanding updates, those updates are lost.
    *
    * @param conn a standard JDBC &lt;code&gt;Connection&lt;/code&gt; object with valid
    * properties
    * @throws SQLException if an invalid &lt;code&gt;Connection&lt;/code&gt; object is supplied
    * or an error occurs in establishing the connection to the
    * data source
    * @see #populate
    * @see java.sql.Connection
    */
    public void execute(Connection conn) throws SQLException;

   /**
    * Propagates row update, insert and delete changes made to this
    * &lt;code&gt;CachedRowSet&lt;/code&gt; object to the underlying data source.
    * &lt;P&gt;
    * This method calls on this &lt;code&gt;CachedRowSet&lt;/code&gt; object's writer
    * to do the work behind the scenes.
    * Standard &lt;code&gt;CachedRowSet&lt;/code&gt; implementations should use the
    * &lt;code&gt;SyncFactory&lt;/code&gt; singleton
    * to obtain a &lt;code&gt;SyncProvider&lt;/code&gt; instance providing a
    * &lt;code&gt;RowSetWriter&lt;/code&gt; object (writer).  The writer will attempt
    * to propagate changes made in this &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * back to the data source.
    * &lt;P&gt;
    * When the method &lt;code&gt;acceptChanges&lt;/code&gt; executes successfully, in
    * addition to writing changes to the data source, it
    * makes the values in the current row be the values in the original row.
    * &lt;P&gt;
    * Depending on the synchronization level of the &lt;code&gt;SyncProvider&lt;/code&gt;
    * implementation being used, the writer will compare the original values
    * with those in the data source to check for conflicts. When there is a conflict,
    * the &lt;code&gt;RIOptimisticProvider&lt;/code&gt; implementation, for example, throws a
    * &lt;code&gt;SyncProviderException&lt;/code&gt; and does not write anything to the
    * data source.
    * &lt;P&gt;
    * An application may choose to catch the &lt;code&gt;SyncProviderException&lt;/code&gt;
    * object and retrieve the &lt;code&gt;SyncResolver&lt;/code&gt; object it contains.
    * The &lt;code&gt;SyncResolver&lt;/code&gt; object lists the conflicts row by row and
    * sets a lock on the data source to avoid further conflicts while the
    * current conflicts are being resolved.
    * Further, for each conflict, it provides methods for examining the conflict
    * and setting the value that should be persisted in the data source.
    * After all conflicts have been resolved, an application must call the
    * &lt;code&gt;acceptChanges&lt;/code&gt; method again to write resolved values to the
    * data source.  If all of the values in the data source are already the
    * values to be persisted, the method &lt;code&gt;acceptChanges&lt;/code&gt; does nothing.
    * &lt;P&gt;
    * Some provider implementations may use locks to ensure that there are no
    * conflicts.  In such cases, it is guaranteed that the writer will succeed in
    * writing changes to the data source when the method &lt;code&gt;acceptChanges&lt;/code&gt;
    * is called.  This method may be called immediately after the methods
    * &lt;code&gt;updateRow&lt;/code&gt;, &lt;code&gt;insertRow&lt;/code&gt;, or &lt;code&gt;deleteRow&lt;/code&gt;
    * have been called, but it is more efficient to call it only once after
    * all changes have been made so that only one connection needs to be
    * established.
    * &lt;P&gt;
    * Note: The &lt;code&gt;acceptChanges()&lt;/code&gt; method will determine if the
    * &lt;code&gt;COMMIT_ON_ACCEPT_CHANGES&lt;/code&gt; is set to true or not. If it is set
    * to true, all updates in the synchronization are committed to the data
    * source. Otherwise, the application &lt;b&gt;must&lt;/b&gt; explicity call the
    * &lt;code&gt;commit()&lt;/code&gt; or &lt;code&gt;rollback()&lt;/code&gt; methods as appropriate.
    *
    * @throws SyncProviderException if the underlying
    * synchronization provider's writer fails to write the updates
    * back to the data source
    * @see #acceptChanges(java.sql.Connection)
    * @see javax.sql.RowSetWriter
    * @see javax.sql.rowset.spi.SyncFactory
    * @see javax.sql.rowset.spi.SyncProvider
    * @see javax.sql.rowset.spi.SyncProviderException
    * @see javax.sql.rowset.spi.SyncResolver
    */
    public void acceptChanges() throws SyncProviderException;

   /**
    * Propagates all row update, insert and delete changes to the
    * data source backing this &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * using the specified &lt;code&gt;Connection&lt;/code&gt; object to establish a
    * connection to the data source.
    * &lt;P&gt;
    * The other version of the &lt;code&gt;acceptChanges&lt;/code&gt; method is not passed
    * a connection because it uses
    * the &lt;code&gt;Connection&lt;/code&gt; object already defined within the &lt;code&gt;RowSet&lt;/code&gt;
    * object, which is the connection used for populating it initially.
    * &lt;P&gt;
    * This form of the method &lt;code&gt;acceptChanges&lt;/code&gt; is similar to the
    * form that takes no arguments; however, unlike the other form, this form
    * can be used only when the underlying data source is a JDBC data source.
    * The updated &lt;code&gt;Connection&lt;/code&gt; properties must be used by the
    * &lt;code&gt;SyncProvider&lt;/code&gt; to reset the &lt;code&gt;RowSetWriter&lt;/code&gt;
    * configuration to ensure that the contents of the &lt;code&gt;CachedRowSet&lt;/code&gt;
    * object are synchronized correctly.
    * &lt;P&gt;
    * When the method &lt;code&gt;acceptChanges&lt;/code&gt; executes successfully, in
    * addition to writing changes to the data source, it
    * makes the values in the current row be the values in the original row.
    * &lt;P&gt;
    * Depending on the synchronization level of the &lt;code&gt;SyncProvider&lt;/code&gt;
    * implementation being used, the writer will compare the original values
    * with those in the data source to check for conflicts. When there is a conflict,
    * the &lt;code&gt;RIOptimisticProvider&lt;/code&gt; implementation, for example, throws a
    * &lt;code&gt;SyncProviderException&lt;/code&gt; and does not write anything to the
    * data source.
    * &lt;P&gt;
    * An application may choose to catch the &lt;code&gt;SyncProviderException&lt;/code&gt;
    * object and retrieve the &lt;code&gt;SyncResolver&lt;/code&gt; object it contains.
    * The &lt;code&gt;SyncResolver&lt;/code&gt; object lists the conflicts row by row and
    * sets a lock on the data source to avoid further conflicts while the
    * current conflicts are being resolved.
    * Further, for each conflict, it provides methods for examining the conflict
    * and setting the value that should be persisted in the data source.
    * After all conflicts have been resolved, an application must call the
    * &lt;code&gt;acceptChanges&lt;/code&gt; method again to write resolved values to the
    * data source.  If all of the values in the data source are already the
    * values to be persisted, the method &lt;code&gt;acceptChanges&lt;/code&gt; does nothing.
    * &lt;P&gt;
    * Some provider implementations may use locks to ensure that there are no
    * conflicts.  In such cases, it is guaranteed that the writer will succeed in
    * writing changes to the data source when the method &lt;code&gt;acceptChanges&lt;/code&gt;
    * is called.  This method may be called immediately after the methods
    * &lt;code&gt;updateRow&lt;/code&gt;, &lt;code&gt;insertRow&lt;/code&gt;, or &lt;code&gt;deleteRow&lt;/code&gt;
    * have been called, but it is more efficient to call it only once after
    * all changes have been made so that only one connection needs to be
    * established.
    * &lt;P&gt;
    * Note: The &lt;code&gt;acceptChanges()&lt;/code&gt; method will determine if the
    * &lt;code&gt;COMMIT_ON_ACCEPT_CHANGES&lt;/code&gt; is set to true or not. If it is set
    * to true, all updates in the synchronization are committed to the data
    * source. Otherwise, the application &lt;b&gt;must&lt;/b&gt; explicity call the
    * &lt;code&gt;commit&lt;/code&gt; or &lt;code&gt;rollback&lt;/code&gt; methods as appropriate.
    *
    * @param con a standard JDBC &lt;code&gt;Connection&lt;/code&gt; object
    * @throws SyncProviderException if the underlying
    * synchronization provider's writer fails to write the updates
    * back to the data source
    * @see #acceptChanges()
    * @see javax.sql.RowSetWriter
    * @see javax.sql.rowset.spi.SyncFactory
    * @see javax.sql.rowset.spi.SyncProvider
    * @see javax.sql.rowset.spi.SyncProviderException
    * @see javax.sql.rowset.spi.SyncResolver
    */
    public void acceptChanges(Connection con) throws SyncProviderException;

   /**
    * Restores this &lt;code&gt;CachedRowSet&lt;/code&gt; object to its original
    * value, that is, its value before the last set of changes. If there
    * have been no changes to the rowset or only one set of changes,
    * the original value is the value with which this &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * was populated; otherwise, the original value is
    * the value it had immediately before its current value.
    * &lt;P&gt;
    * When this method is called, a &lt;code&gt;CachedRowSet&lt;/code&gt; implementation
    * must ensure that all updates, inserts, and deletes to the current
    * rowset instance are replaced by the previous values. In addition,
    * the cursor should be
    * reset to the first row and a &lt;code&gt;rowSetChanged&lt;/code&gt; event
    * should be fired to notify all registered listeners.
    *
    * @throws SQLException if an error occurs rolling back the current value of
    *       this &lt;code&gt;CachedRowSet&lt;/code&gt; object to its previous value
    * @see javax.sql.RowSetListener#rowSetChanged
    */
    public void restoreOriginal() throws SQLException;

   /**
    * Releases the current contents of this &lt;code&gt;CachedRowSet&lt;/code&gt;
    * object and sends a &lt;code&gt;rowSetChanged&lt;/code&gt; event to all
    * registered listeners. Any outstanding updates are discarded and
    * the rowset contains no rows after this method is called. There
    * are no interactions with the underlying data source, and any rowset
    * content, metadata, and content updates should be non-recoverable.
    * &lt;P&gt;
    * This &lt;code&gt;CachedRowSet&lt;/code&gt; object should lock until its contents and
    * associated updates are fully cleared, thus preventing 'dirty' reads by
    * other components that hold a reference to this &lt;code&gt;RowSet&lt;/code&gt; object.
    * In addition, the contents cannot be released
    * until all all components reading this &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * have completed their reads. This &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * should be returned to normal behavior after firing the
    * &lt;code&gt;rowSetChanged&lt;/code&gt; event.
    * &lt;P&gt;
    * The metadata, including JDBC properties and Synchronization SPI
    * properties, are maintained for future use. It is important that
    * properties such as the &lt;code&gt;command&lt;/code&gt; property be
    * relevant to the originating data source from which this &lt;code&gt;CachedRowSet&lt;/code&gt;
    * object was originally established.
    * &lt;P&gt;
    * This method empties a rowset, as opposed to the &lt;code&gt;close&lt;/code&gt; method,
    * which marks the entire rowset as recoverable to allow the garbage collector
    * the rowset's Java VM resources.
    *
    * @throws SQLException if an error occurs flushing the contents of this
    * &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * @see javax.sql.RowSetListener#rowSetChanged
    * @see java.sql.ResultSet#close
    */
    public void release() throws SQLException;

   /**
    * Cancels the deletion of the current row and notifies listeners that
    * a row has changed. After this method is called, the current row is
    * no longer marked for deletion. This method can be called at any
    * time during the lifetime of the rowset.
    * &lt;P&gt;
    * In addition, multiple cancellations of row deletions can be made
    * by adjusting the position of the cursor using any of the cursor
    * position control methods such as:
    * &lt;ul&gt;
    * &lt;li&gt;&lt;code&gt;CachedRowSet.absolute&lt;/code&gt;
    * &lt;li&gt;&lt;code&gt;CachedRowSet.first&lt;/code&gt;
    * &lt;li&gt;&lt;code&gt;CachedRowSet.last&lt;/code&gt;
    * &lt;/ul&gt;
    *
    * @throws SQLException if (1) the current row has not been deleted or
    * (2) the cursor is on the insert row, before the first row, or
    * after the last row
    * @see javax.sql.rowset.CachedRowSet#undoInsert
    * @see java.sql.ResultSet#cancelRowUpdates
    */
    public void undoDelete() throws SQLException;

   /**
    * Immediately removes the current row from this &lt;code&gt;CachedRowSet&lt;/code&gt;
    * object if the row has been inserted, and also notifies listeners that a
    * row has changed. This method can be called at any time during the
    * lifetime of a rowset and assuming the current row is within
    * the exception limitations (see below), it cancels the row insertion
    * of the current row.
    * &lt;P&gt;
    * In addition, multiple cancellations of row insertions can be made
    * by adjusting the position of the cursor using any of the cursor
    * position control methods such as:
    * &lt;ul&gt;
    * &lt;li&gt;&lt;code&gt;CachedRowSet.absolute&lt;/code&gt;
    * &lt;li&gt;&lt;code&gt;CachedRowSet.first&lt;/code&gt;
    * &lt;li&gt;&lt;code&gt;CachedRowSet.last&lt;/code&gt;
    * &lt;/ul&gt;
    *
    * @throws SQLException if (1) the current row has not been inserted or (2)
    * the cursor is before the first row, after the last row, or on the
    * insert row
    * @see javax.sql.rowset.CachedRowSet#undoDelete
    * @see java.sql.ResultSet#cancelRowUpdates
    */
    public void undoInsert() throws SQLException;


   /**
    * Immediately reverses the last update operation if the
    * row has been modified. This method can be
    * called to reverse updates on all columns until all updates in a row have
    * been rolled back to their state just prior to the last synchronization
    * (&lt;code&gt;acceptChanges&lt;/code&gt;) or population. This method may also be called
    * while performing updates to the insert row.
    * &lt;P&gt;
    * &lt;code&gt;undoUpdate&lt;/code&gt; may be called at any time during the lifetime of a
    * rowset; however, after a synchronization has occurred, this method has no
    * effect until further modification to the rowset data has occurred.
    *
    * @throws SQLException if the cursor is before the first row or after the last
    *     row in in this &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * @see #undoDelete
    * @see #undoInsert
    * @see java.sql.ResultSet#cancelRowUpdates
    */
    public void undoUpdate() throws SQLException;

   /**
    * Indicates whether the designated column in the current row of this
    * &lt;code&gt;CachedRowSet&lt;/code&gt; object has been updated.
    *
    * @param idx an &lt;code&gt;int&lt;/code&gt; identifying the column to be checked for updates
    * @return &lt;code&gt;true&lt;/code&gt; if the designated column has been visibly updated;
    * &lt;code&gt;false&lt;/code&gt; otherwise
    * @throws SQLException if the cursor is on the insert row, before the first row,
    *     or after the last row
    * @see java.sql.DatabaseMetaData#updatesAreDetected
    */
    public boolean columnUpdated(int idx) throws SQLException;


   /**
    * Indicates whether the designated column in the current row of this
    * &lt;code&gt;CachedRowSet&lt;/code&gt; object has been updated.
    *
    * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the name of the
    *        column to be checked for updates
    * @return &lt;code&gt;true&lt;/code&gt; if the column has been visibly updated;
    * &lt;code&gt;false&lt;/code&gt; otherwise
    * @throws SQLException if the cursor is on the insert row, before the first row,
    *      or after the last row
    * @see java.sql.DatabaseMetaData#updatesAreDetected
    */
    public boolean columnUpdated(String columnName) throws SQLException;

   /**
    * Converts this &lt;code&gt;CachedRowSet&lt;/code&gt; object to a &lt;code&gt;Collection&lt;/code&gt;
    * object that contains all of this &lt;code&gt;CachedRowSet&lt;/code&gt; object's data.
    * Implementations have some latitude in
    * how they can represent this &lt;code&gt;Collection&lt;/code&gt; object because of the
    * abstract nature of the &lt;code&gt;Collection&lt;/code&gt; framework.
    * Each row must be fully represented in either a
    * general purpose &lt;code&gt;Collection&lt;/code&gt; implementation or a specialized
    * &lt;code&gt;Collection&lt;/code&gt; implementation, such as a &lt;code&gt;TreeMap&lt;/code&gt;
    * object or a &lt;code&gt;Vector&lt;/code&gt; object.
    * An SQL &lt;code&gt;NULL&lt;/code&gt; column value must be represented as a &lt;code&gt;null&lt;/code&gt;
    * in the Java programming language.
    * &lt;P&gt;
    * The standard reference implementation for the &lt;code&gt;CachedRowSet&lt;/code&gt;
    * interface uses a &lt;code&gt;TreeMap&lt;/code&gt; object for the rowset, with the
    * values in each row being contained in  &lt;code&gt;Vector&lt;/code&gt; objects. It is
    * expected that most implementations will do the same.
    * &lt;P&gt;
    * The &lt;code&gt;TreeMap&lt;/code&gt; type of collection guarantees that the map will be in
    * ascending key order, sorted according to the natural order for the
    * key's class.
    * Each key references a &lt;code&gt;Vector&lt;/code&gt; object that corresponds to one
    * row of a &lt;code&gt;RowSet&lt;/code&gt; object. Therefore, the size of each
    * &lt;code&gt;Vector&lt;/code&gt; object  must be exactly equal to the number of
    * columns in the &lt;code&gt;RowSet&lt;/code&gt; object.
    * The key used by the &lt;code&gt;TreeMap&lt;/code&gt; collection is determined by the
    * implementation, which may choose to leverage a set key that is
    * available within the internal &lt;code&gt;RowSet&lt;/code&gt; tabular structure by
    * virtue of a key already set either on the &lt;code&gt;RowSet&lt;/code&gt; object
    * itself or on the underlying SQL data.
    * &lt;P&gt;
    *
    * @return a &lt;code&gt;Collection&lt;/code&gt; object that contains the values in
    * each row in this &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * @throws SQLException if an error occurs generating the collection
    * @see #toCollection(int)
    * @see #toCollection(String)
    */
    public Collection&lt;?&gt; toCollection() throws SQLException;

   /**
    * Converts the designated column in this &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * to a &lt;code&gt;Collection&lt;/code&gt; object. Implementations have some latitude in
    * how they can represent this &lt;code&gt;Collection&lt;/code&gt; object because of the
    * abstract nature of the &lt;code&gt;Collection&lt;/code&gt; framework.
    * Each column value should be fully represented in either a
    * general purpose &lt;code&gt;Collection&lt;/code&gt; implementation or a specialized
    * &lt;code&gt;Collection&lt;/code&gt; implementation, such as a &lt;code&gt;Vector&lt;/code&gt; object.
    * An SQL &lt;code&gt;NULL&lt;/code&gt; column value must be represented as a &lt;code&gt;null&lt;/code&gt;
    * in the Java programming language.
    * &lt;P&gt;
    * The standard reference implementation uses a &lt;code&gt;Vector&lt;/code&gt; object
    * to contain the column values, and it is expected
    * that most implementations will do the same. If a &lt;code&gt;Vector&lt;/code&gt; object
    * is used, it size must be exactly equal to the number of rows
    * in this &lt;code&gt;CachedRowSet&lt;/code&gt; object.
    *
    * @param column an &lt;code&gt;int&lt;/code&gt; indicating the column whose values
    *        are to be represented in a &lt;code&gt;Collection&lt;/code&gt; object
    * @return a &lt;code&gt;Collection&lt;/code&gt; object that contains the values
    * stored in the specified column of this &lt;code&gt;CachedRowSet&lt;/code&gt;
    * object
    * @throws SQLException if an error occurs generating the collection or
    * an invalid column id is provided
    * @see #toCollection
    * @see #toCollection(String)
    */
    public Collection&lt;?&gt; toCollection(int column) throws SQLException;

   /**
    * Converts the designated column in this &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * to a &lt;code&gt;Collection&lt;/code&gt; object. Implementations have some latitude in
    * how they can represent this &lt;code&gt;Collection&lt;/code&gt; object because of the
    * abstract nature of the &lt;code&gt;Collection&lt;/code&gt; framework.
    * Each column value should be fully represented in either a
    * general purpose &lt;code&gt;Collection&lt;/code&gt; implementation or a specialized
    * &lt;code&gt;Collection&lt;/code&gt; implementation, such as a &lt;code&gt;Vector&lt;/code&gt; object.
    * An SQL &lt;code&gt;NULL&lt;/code&gt; column value must be represented as a &lt;code&gt;null&lt;/code&gt;
    * in the Java programming language.
    * &lt;P&gt;
    * The standard reference implementation uses a &lt;code&gt;Vector&lt;/code&gt; object
    * to contain the column values, and it is expected
    * that most implementations will do the same. If a &lt;code&gt;Vector&lt;/code&gt; object
    * is used, it size must be exactly equal to the number of rows
    * in this &lt;code&gt;CachedRowSet&lt;/code&gt; object.
    *
    * @param column a &lt;code&gt;String&lt;/code&gt; object giving the name of the
    *        column whose values are to be represented in a collection
    * @return a &lt;code&gt;Collection&lt;/code&gt; object that contains the values
    * stored in the specified column of this &lt;code&gt;CachedRowSet&lt;/code&gt;
    * object
    * @throws SQLException if an error occurs generating the collection or
    * an invalid column id is provided
    * @see #toCollection
    * @see #toCollection(int)
    */
    public Collection&lt;?&gt; toCollection(String column) throws SQLException;

   /**
    * Retrieves the &lt;code&gt;SyncProvider&lt;/code&gt; implementation for this
    * &lt;code&gt;CachedRowSet&lt;/code&gt; object. Internally, this method is used by a rowset
    * to trigger read or write actions between the rowset
    * and the data source. For example, a rowset may need to get a handle
    * on the the rowset reader (&lt;code&gt;RowSetReader&lt;/code&gt; object) from the
    * &lt;code&gt;SyncProvider&lt;/code&gt; to allow the rowset to be populated.
    * &lt;pre&gt;
    *     RowSetReader rowsetReader = null;
    *     SyncProvider provider =
    *         SyncFactory.getInstance(&quot;javax.sql.rowset.provider.RIOptimisticProvider&quot;);
    *         if (provider instanceof RIOptimisticProvider) {
    *             rowsetReader = provider.getRowSetReader();
    *         }
    * &lt;/pre&gt;
    * Assuming &lt;i&gt;rowsetReader&lt;/i&gt; is a private, accessible field within
    * the rowset implementation, when an application calls the &lt;code&gt;execute&lt;/code&gt;
    * method, it in turn calls on the reader's &lt;code&gt;readData&lt;/code&gt; method
    * to populate the &lt;code&gt;RowSet&lt;/code&gt; object.
    *&lt;pre&gt;
    *     rowsetReader.readData((RowSetInternal)this);
    * &lt;/pre&gt;
    * &lt;P&gt;
    * In addition, an application can use the &lt;code&gt;SyncProvider&lt;/code&gt; object
    * returned by this method to call methods that return information about the
    * &lt;code&gt;SyncProvider&lt;/code&gt; object, including information about the
    * vendor, version, provider identification, synchronization grade, and locks
    * it currently has set.
    *
    * @return the &lt;code&gt;SyncProvider&lt;/code&gt; object that was set when the rowset
    *      was instantiated, or if none was was set, the default provider
    * @throws SQLException if an error occurs while returning the
    * &lt;code&gt;SyncProvider&lt;/code&gt; object
    * @see #setSyncProvider
    */
    public SyncProvider getSyncProvider() throws SQLException;

   /**
    * Sets the &lt;code&gt;SyncProvider&lt;/code&gt; object for this &lt;code&gt;CachedRowSet&lt;/code&gt;
    * object to the one specified.  This method
    * allows the &lt;code&gt;SyncProvider&lt;/code&gt; object to be reset.
    * &lt;P&gt;
    * A &lt;code&gt;CachedRowSet&lt;/code&gt; implementation should always be instantiated
    * with an available &lt;code&gt;SyncProvider&lt;/code&gt; mechanism, but there are
    * cases where resetting the &lt;code&gt;SyncProvider&lt;/code&gt; object is desirable
    * or necessary. For example, an application might want to use the default
    * &lt;code&gt;SyncProvider&lt;/code&gt; object for a time and then choose to use a provider
    * that has more recently become available and better fits its needs.
    * &lt;P&gt;
    * Resetting the &lt;code&gt;SyncProvider&lt;/code&gt; object causes the
    * &lt;code&gt;RowSet&lt;/code&gt; object to request a new &lt;code&gt;SyncProvider&lt;/code&gt; implementation
    * from the &lt;code&gt;SyncFactory&lt;/code&gt;. This has the effect of resetting
    * all previous connections and relationships with the originating
    * data source and can potentially drastically change the synchronization
    * behavior of a disconnected rowset.
    *
    * @param provider a &lt;code&gt;String&lt;/code&gt; object giving the fully qualified class
    *        name of a &lt;code&gt;SyncProvider&lt;/code&gt; implementation
    * @throws SQLException if an error occurs while attempting to reset the
    * &lt;code&gt;SyncProvider&lt;/code&gt; implementation
    * @see #getSyncProvider
    */
    public void setSyncProvider(String provider) throws SQLException;

   /**
    * Returns the number of rows in this &lt;code&gt;CachedRowSet&lt;/code&gt;
    * object.
    *
    * @return number of rows in the rowset
    */
    public int size();

   /**
    * Sets the metadata for this &lt;code&gt;CachedRowSet&lt;/code&gt; object with
    * the given &lt;code&gt;RowSetMetaData&lt;/code&gt; object. When a
    * &lt;code&gt;RowSetReader&lt;/code&gt; object is reading the contents of a rowset,
    * it creates a &lt;code&gt;RowSetMetaData&lt;/code&gt; object and initializes
    * it using the methods in the &lt;code&gt;RowSetMetaData&lt;/code&gt; implementation.
    * The reference implementation uses the &lt;code&gt;RowSetMetaDataImpl&lt;/code&gt;
    * class. When the reader has completed reading the rowset contents,
    * this method is called internally to pass the &lt;code&gt;RowSetMetaData&lt;/code&gt;
    * object to the rowset.
    *
    * @param md a &lt;code&gt;RowSetMetaData&lt;/code&gt; object containing
    * metadata about the columns in this &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * @throws SQLException if invalid metadata is supplied to the
    * rowset
    */
    public void setMetaData(RowSetMetaData md) throws SQLException;

   /**
    * Returns a &lt;code&gt;ResultSet&lt;/code&gt; object containing the original value of this
    * &lt;code&gt;CachedRowSet&lt;/code&gt; object.
    * &lt;P&gt;
    * The cursor for the &lt;code&gt;ResultSet&lt;/code&gt;
    * object should be positioned before the first row.
    * In addition, the returned &lt;code&gt;ResultSet&lt;/code&gt; object should have the following
    * properties:
    * &lt;UL&gt;
    * &lt;LI&gt;ResultSet.TYPE_SCROLL_INSENSITIVE
    * &lt;LI&gt;ResultSet.CONCUR_UPDATABLE
    * &lt;/UL&gt;
    * &lt;P&gt;
    * The original value for a &lt;code&gt;RowSet&lt;/code&gt; object is the value it had before
    * the last synchronization with the underlying data source.  If there have been
    * no synchronizations, the original value will be the value with which the
    * &lt;code&gt;RowSet&lt;/code&gt; object was populated.  This method is called internally
    * when an application calls the method &lt;code&gt;acceptChanges&lt;/code&gt; and the
    * &lt;code&gt;SyncProvider&lt;/code&gt; object has been implemented to check for conflicts.
    * If this is the case, the writer compares the original value with the value
    * currently in the data source to check for conflicts.
    *
    * @return a &lt;code&gt;ResultSet&lt;/code&gt; object that contains the original value for
    *         this &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * @throws SQLException if an error occurs producing the
    * &lt;code&gt;ResultSet&lt;/code&gt; object
    */
   public ResultSet getOriginal() throws SQLException;

   /**
    * Returns a &lt;code&gt;ResultSet&lt;/code&gt; object containing the original value for the
    * current row only of this &lt;code&gt;CachedRowSet&lt;/code&gt; object.
    * &lt;P&gt;
    * The cursor for the &lt;code&gt;ResultSet&lt;/code&gt;
    * object should be positioned before the first row.
    * In addition, the returned &lt;code&gt;ResultSet&lt;/code&gt; object should have the following
    * properties:
    * &lt;UL&gt;
    * &lt;LI&gt;ResultSet.TYPE_SCROLL_INSENSITIVE
    * &lt;LI&gt;ResultSet.CONCUR_UPDATABLE
    * &lt;/UL&gt;
    *
    * @return the original result set of the row
    * @throws SQLException if there is no current row
    * @see #setOriginalRow
    */
    public ResultSet getOriginalRow() throws SQLException;

   /**
    * Sets the current row in this &lt;code&gt;CachedRowSet&lt;/code&gt; object as the original
    * row.
    * &lt;P&gt;
    * This method is called internally after the any modified values in the current
    * row have been synchronized with the data source. The current row must be tagged
    * as no longer inserted, deleted or updated.
    * &lt;P&gt;
    * A call to &lt;code&gt;setOriginalRow&lt;/code&gt; is irreversible.
    *
    * @throws SQLException if there is no current row or an error is
    * encountered resetting the contents of the original row
    * @see #getOriginalRow
    */
    public void setOriginalRow() throws SQLException;

   /**
    * Returns an identifier for the object (table) that was used to
    * create this &lt;code&gt;CachedRowSet&lt;/code&gt; object. This name may be set on multiple occasions,
    * and the specification imposes no limits on how many times this
    * may occur or whether standard implementations should keep track
    * of previous table names.
    *
    * @return a &lt;code&gt;String&lt;/code&gt; object giving the name of the table that is the
    *         source of data for this &lt;code&gt;CachedRowSet&lt;/code&gt; object or &lt;code&gt;null&lt;/code&gt;
    *         if no name has been set for the table
    * @throws SQLException if an error is encountered returning the table name
    * @see javax.sql.RowSetMetaData#getTableName
    */
    public String getTableName() throws SQLException;

   /**
    * Sets the identifier for the table from which this &lt;code&gt;CachedRowSet&lt;/code&gt;
    * object was derived to the given table name. The writer uses this name to
    * determine which table to use when comparing the values in the data source with the
    * &lt;code&gt;CachedRowSet&lt;/code&gt; object's values during a synchronization attempt.
    * The table identifier also indicates where modified values from this
    * &lt;code&gt;CachedRowSet&lt;/code&gt; object should be written.
    * &lt;P&gt;
    * The implementation of this &lt;code&gt;CachedRowSet&lt;/code&gt; object may obtain the
    * the name internally from the &lt;code&gt;RowSetMetaDataImpl&lt;/code&gt; object.
    *
    * @param tabName a &lt;code&gt;String&lt;/code&gt; object identifying the table from which this
             &lt;code&gt;CachedRowSet&lt;/code&gt; object was derived; cannot be &lt;code&gt;null&lt;/code&gt;
    *         but may be an empty string
    * @throws SQLException if an error is encountered naming the table or
    *     &lt;i&gt;tabName&lt;/i&gt; is &lt;code&gt;null&lt;/code&gt;
    * @see javax.sql.RowSetMetaData#setTableName
    * @see javax.sql.RowSetWriter
    * @see javax.sql.rowset.spi.SyncProvider
    */
   public void setTableName(String tabName) throws SQLException;

   /**
    * Returns an array containing one or more column numbers indicating the columns
    * that form a key that uniquely
    * identifies a row in this &lt;code&gt;CachedRowSet&lt;/code&gt; object.
    *
    * @return an array containing the column number or numbers that indicate which columns
    *       constitute a primary key
    *       for a row in this &lt;code&gt;CachedRowSet&lt;/code&gt; object. This array should be
    *       empty if no columns are representative of a primary key.
    * @throws SQLException if this &lt;code&gt;CachedRowSet&lt;/code&gt; object is empty
    * @see #setKeyColumns
    * @see Joinable#getMatchColumnIndexes
    * @see Joinable#getMatchColumnNames
    */
    public int[] getKeyColumns() throws SQLException;

   /**
    * Sets this &lt;code&gt;CachedRowSet&lt;/code&gt; object's &lt;code&gt;keyCols&lt;/code&gt;
    * field with the given array of column numbers, which forms a key
    * for uniquely identifying a row in this &lt;code&gt;CachedRowSet&lt;/code&gt; object.
    * &lt;p&gt;
    * If a &lt;code&gt;CachedRowSet&lt;/code&gt; object becomes part of a &lt;code&gt;JoinRowSet&lt;/code&gt;
    * object, the keys defined by this method and the resulting constraints are
    * maintained if the columns designated as key columns also become match
    * columns.
    *
    * @param keys an array of &lt;code&gt;int&lt;/code&gt; indicating the columns that form
    *        a primary key for this &lt;code&gt;CachedRowSet&lt;/code&gt; object; every
    *        element in the array must be greater than &lt;code&gt;0&lt;/code&gt; and
    *        less than or equal to the number of columns in this rowset
    * @throws SQLException if any of the numbers in the given array
    *            are not valid for this rowset
    * @see #getKeyColumns
    * @see Joinable#setMatchColumn(String)
    * @see Joinable#setMatchColumn(int)

    */
    public void setKeyColumns(int[] keys) throws SQLException;


   /**
    * Returns a new &lt;code&gt;RowSet&lt;/code&gt; object backed by the same data as
    * that of this &lt;code&gt;CachedRowSet&lt;/code&gt; object. In effect, both
    * &lt;code&gt;CachedRowSet&lt;/code&gt; objects have a cursor over the same data.
    * As a result, any changes made by a duplicate are visible to the original
    * and to any other duplicates, just as a change made by the original is visible
    * to all of its duplicates. If a duplicate calls a method that changes the
    * underlying data, the method it calls notifies all registered listeners
    * just as it would when it is called by the original &lt;code&gt;CachedRowSet&lt;/code&gt;
    * object.
    * &lt;P&gt;
    * In addition, any &lt;code&gt;RowSet&lt;/code&gt; object
    * created by this method will have the same properties as this
    * &lt;code&gt;CachedRowSet&lt;/code&gt; object. For example, if this &lt;code&gt;CachedRowSet&lt;/code&gt;
    * object is read-only, all of its duplicates will also be read-only. If it is
    * changed to be updatable, the duplicates also become updatable.
    * &lt;P&gt;
    * NOTE: If multiple threads access &lt;code&gt;RowSet&lt;/code&gt; objects created from
    * the &lt;code&gt;createShared()&lt;/code&gt; method, the following behavior is specified
    * to preserve shared data integrity: reads and writes of all
    * shared &lt;code&gt;RowSet&lt;/code&gt; objects should be made serially between each
    * object and the single underlying tabular structure.
    *
    * @return a new shared &lt;code&gt;RowSet&lt;/code&gt; object that has the same properties
    *         as this &lt;code&gt;CachedRowSet&lt;/code&gt; object and that has a cursor over
    *         the same data
    * @throws SQLException if an error occurs or cloning is not
    * supported in the underlying platform
    * @see javax.sql.RowSetEvent
    * @see javax.sql.RowSetListener
    */
    public RowSet createShared() throws SQLException;

   /**
    * Creates a &lt;code&gt;RowSet&lt;/code&gt; object that is a deep copy of the data in
    * this &lt;code&gt;CachedRowSet&lt;/code&gt; object. In contrast to
    * the &lt;code&gt;RowSet&lt;/code&gt; object generated from a &lt;code&gt;createShared&lt;/code&gt;
    * call, updates made to the copy of the original &lt;code&gt;RowSet&lt;/code&gt; object
    * must not be visible to the original &lt;code&gt;RowSet&lt;/code&gt; object. Also, any
    * event listeners that are registered with the original
    * &lt;code&gt;RowSet&lt;/code&gt; must not have scope over the new
    * &lt;code&gt;RowSet&lt;/code&gt; copies. In addition, any constraint restrictions
    * established must be maintained.
    *
    * @return a new &lt;code&gt;RowSet&lt;/code&gt; object that is a deep copy
    * of this &lt;code&gt;CachedRowSet&lt;/code&gt; object and is
    * completely independent of this &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * @throws SQLException if an error occurs in generating the copy of
    * the of this &lt;code&gt;CachedRowSet&lt;/code&gt; object
    * @see #createShared
    * @see #createCopySchema
    * @see #createCopyNoConstraints
    * @see javax.sql.RowSetEvent
    * @see javax.sql.RowSetListener
    */
    public CachedRowSet createCopy() throws SQLException;

    /**
     * Creates a &lt;code&gt;CachedRowSet&lt;/code&gt; object that is an empty copy of this
     * &lt;code&gt;CachedRowSet&lt;/code&gt; object.  The copy
     * must not contain any contents but only represent the table
     * structure of the original &lt;code&gt;CachedRowSet&lt;/code&gt; object. In addition, primary
     * or foreign key constraints set in the originating &lt;code&gt;CachedRowSet&lt;/code&gt; object must
     * be equally enforced in the new empty &lt;code&gt;CachedRowSet&lt;/code&gt; object.
     * In contrast to
     * the &lt;code&gt;RowSet&lt;/code&gt; object generated from a &lt;code&gt;createShared&lt;/code&gt; method
     * call, updates made to a copy of this &lt;code&gt;CachedRowSet&lt;/code&gt; object with the
     * &lt;code&gt;createCopySchema&lt;/code&gt; method must not be visible to it.
     * &lt;P&gt;
     * Applications can form a &lt;code&gt;WebRowSet&lt;/code&gt; object from the &lt;code&gt;CachedRowSet&lt;/code&gt;
     * object returned by this method in order
     * to export the &lt;code&gt;RowSet&lt;/code&gt; schema definition to XML for future use.
     * @return An empty copy of this {@code CachedRowSet} object
     * @throws SQLException if an error occurs in cloning the structure of this
     *         &lt;code&gt;CachedRowSet&lt;/code&gt; object
     * @see #createShared
     * @see #createCopySchema
     * @see #createCopyNoConstraints
     * @see javax.sql.RowSetEvent
     * @see javax.sql.RowSetListener
     */
    public CachedRowSet createCopySchema() throws SQLException;

    /**
     * Creates a &lt;code&gt;CachedRowSet&lt;/code&gt; object that is a deep copy of
     * this &lt;code&gt;CachedRowSet&lt;/code&gt; object's data but is independent of it.
     * In contrast to
     * the &lt;code&gt;RowSet&lt;/code&gt; object generated from a &lt;code&gt;createShared&lt;/code&gt;
     * method call, updates made to a copy of this &lt;code&gt;CachedRowSet&lt;/code&gt; object
     * must not be visible to it. Also, any
     * event listeners that are registered with this
     * &lt;code&gt;CachedRowSet&lt;/code&gt; object must not have scope over the new
     * &lt;code&gt;RowSet&lt;/code&gt; object. In addition, any constraint restrictions
     * established for this &lt;code&gt;CachedRowSet&lt;/code&gt; object must &lt;b&gt;not&lt;/b&gt; be maintained
     * in the copy.
     *
     * @return a new &lt;code&gt;CachedRowSet&lt;/code&gt; object that is a deep copy
     *     of this &lt;code&gt;CachedRowSet&lt;/code&gt; object and is
     *     completely independent of this  &lt;code&gt;CachedRowSet&lt;/code&gt; object
     * @throws SQLException if an error occurs in generating the copy of
     *     the of this &lt;code&gt;CachedRowSet&lt;/code&gt; object
     * @see #createCopy
     * @see #createShared
     * @see #createCopySchema
     * @see javax.sql.RowSetEvent
     * @see javax.sql.RowSetListener
     */
    public CachedRowSet createCopyNoConstraints() throws SQLException;

    /**
     * Retrieves the first warning reported by calls on this &lt;code&gt;RowSet&lt;/code&gt; object.
     * Subsequent warnings on this &lt;code&gt;RowSet&lt;/code&gt; object will be chained to the
     * &lt;code&gt;RowSetWarning&lt;/code&gt; object that this method returns.
     *
     * The warning chain is automatically cleared each time a new row is read.
     * This method may not be called on a RowSet object that has been closed;
     * doing so will cause a &lt;code&gt;SQLException&lt;/code&gt; to be thrown.
     *
     * @return RowSetWarning the first &lt;code&gt;RowSetWarning&lt;/code&gt;
     * object reported or null if there are none
     * @throws SQLException if this method is called on a closed RowSet
     * @see RowSetWarning
     */
    public RowSetWarning getRowSetWarnings() throws SQLException;

    /**
     * Retrieves a &lt;code&gt;boolean&lt;/code&gt; indicating whether rows marked
     * for deletion appear in the set of current rows. If &lt;code&gt;true&lt;/code&gt; is
     * returned, deleted rows are visible with the current rows. If
     * &lt;code&gt;false&lt;/code&gt; is returned, rows are not visible with the set of
     * current rows. The default value is &lt;code&gt;false&lt;/code&gt;.
     * &lt;P&gt;
     * Standard rowset implementations may choose to restrict this behavior
     * due to security considerations or to better fit certain deployment
     * scenarios. This is left as implementation defined and does not
     * represent standard behavior.
     * &lt;P&gt;
     * Note: Allowing deleted rows to remain visible complicates the behavior
     * of some standard JDBC &lt;code&gt;RowSet&lt;/code&gt; Implementations methods.
     * However, most rowset users can simply ignore this extra detail because
     * only very specialized applications will likely want to take advantage of
     * this feature.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if deleted rows are visible;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @throws SQLException if a rowset implementation is unable to
     * to determine whether rows marked for deletion are visible
     * @see #setShowDeleted
     */
    public boolean getShowDeleted() throws SQLException;

    /**
     * Sets the property &lt;code&gt;showDeleted&lt;/code&gt; to the given
     * &lt;code&gt;boolean&lt;/code&gt; value, which determines whether
     * rows marked for deletion appear in the set of current rows.
     * If the value is set to &lt;code&gt;true&lt;/code&gt;, deleted rows are immediately
     * visible with the set of current rows. If the value is set to
     * &lt;code&gt;false&lt;/code&gt;, the deleted rows are set as invisible with the
     * current set of rows.
     * &lt;P&gt;
     * Standard rowset implementations may choose to restrict this behavior
     * due to security considerations or to better fit certain deployment
     * scenarios. This is left as implementations defined and does not
     * represent standard behavior.
     *
     * @param b &lt;code&gt;true&lt;/code&gt; if deleted rows should be shown;
     *              &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a rowset implementation is unable to
     * to reset whether deleted rows should be visible
     * @see #getShowDeleted
     */
    public void setShowDeleted(boolean b) throws SQLException;

    /**
     * Each &lt;code&gt;CachedRowSet&lt;/code&gt; object's &lt;code&gt;SyncProvider&lt;/code&gt; contains
     * a &lt;code&gt;Connection&lt;/code&gt; object from the &lt;code&gt;ResultSet&lt;/code&gt; or JDBC
     * properties passed to it's constructors. This method wraps the
     * &lt;code&gt;Connection&lt;/code&gt; commit method to allow flexible
     * auto commit or non auto commit transactional control support.
     * &lt;p&gt;
     * Makes all changes that are performed by the &lt;code&gt;acceptChanges()&lt;/code&gt;
     * method since the previous commit/rollback permanent. This method should
     * be used only when auto-commit mode has been disabled.
     *
     * @throws SQLException if a database access error occurs or this
     * Connection object within this &lt;code&gt;CachedRowSet&lt;/code&gt; is in auto-commit mode
     * @see java.sql.Connection#setAutoCommit
     */
    public void commit() throws SQLException;

    /**
     * Each &lt;code&gt;CachedRowSet&lt;/code&gt; object's &lt;code&gt;SyncProvider&lt;/code&gt; contains
     * a &lt;code&gt;Connection&lt;/code&gt; object from the original &lt;code&gt;ResultSet&lt;/code&gt;
     * or JDBC properties passed to it.
     * &lt;p&gt;
     * Undoes all changes made in the current transaction.  This method
     * should be used only when auto-commit mode has been disabled.
     *
     * @throws SQLException if a database access error occurs or this Connection
     * object within this &lt;code&gt;CachedRowSet&lt;/code&gt; is in auto-commit mode.
     */
    public void rollback() throws SQLException;

    /**
     * Each &lt;code&gt;CachedRowSet&lt;/code&gt; object's &lt;code&gt;SyncProvider&lt;/code&gt; contains
     * a &lt;code&gt;Connection&lt;/code&gt; object from the original &lt;code&gt;ResultSet&lt;/code&gt;
     * or JDBC properties passed to it.
     * &lt;p&gt;
     * Undoes all changes made in the current transaction back to the last
     * &lt;code&gt;Savepoint&lt;/code&gt; transaction marker. This method should be used only
     * when auto-commit mode has been disabled.
     *
     * @param s A &lt;code&gt;Savepoint&lt;/code&gt; transaction marker
     * @throws SQLException if a database access error occurs or this Connection
     * object within this &lt;code&gt;CachedRowSet&lt;/code&gt; is in auto-commit mode.
     */
    public void rollback(Savepoint s) throws SQLException;

    /**
     * Causes the &lt;code&gt;CachedRowSet&lt;/code&gt; object's &lt;code&gt;SyncProvider&lt;/code&gt;
     * to commit the changes when &lt;code&gt;acceptChanges()&lt;/code&gt; is called. If
     * set to false, the changes will &lt;b&gt;not&lt;/b&gt; be committed until one of the
     * &lt;code&gt;CachedRowSet&lt;/code&gt; interface transaction methods is called.
     *
     * @deprecated Because this field is final (it is part of an interface),
     *  its value cannot be changed.
     * @see #commit
     * @see #rollback
     */
    @Deprecated
    public static final boolean COMMIT_ON_ACCEPT_CHANGES = true;

    /**
     * Notifies registered listeners that a RowSet object in the given RowSetEvent
     * object has populated a number of additional rows. The &lt;code&gt;numRows&lt;/code&gt; parameter
     * ensures that this event will only be fired every &lt;code&gt;numRow&lt;/code&gt;.
     * &lt;p&gt;
     * The source of the event can be retrieved with the method event.getSource.
     *
     * @param event a &lt;code&gt;RowSetEvent&lt;/code&gt; object that contains the
     *     &lt;code&gt;RowSet&lt;/code&gt; object that is the source of the events
     * @param numRows when populating, the number of rows interval on which the
     *     &lt;code&gt;CachedRowSet&lt;/code&gt; populated should fire; the default value
     *     is zero; cannot be less than &lt;code&gt;fetchSize&lt;/code&gt; or zero
     * @throws SQLException {@code numRows &lt; 0 or numRows &lt; getFetchSize() }
     */
    public void rowSetPopulated(RowSetEvent event, int numRows) throws SQLException;

    /**
     * Populates this &lt;code&gt;CachedRowSet&lt;/code&gt; object with data from
     * the given &lt;code&gt;ResultSet&lt;/code&gt; object. While related to the &lt;code&gt;populate(ResultSet)&lt;/code&gt;
     * method, an additional parameter is provided to allow starting position within
     * the &lt;code&gt;ResultSet&lt;/code&gt; from where to populate the CachedRowSet
     * instance.
     * &lt;P&gt;
     * This method can be used as an alternative to the &lt;code&gt;execute&lt;/code&gt; method when an
     * application has a connection to an open &lt;code&gt;ResultSet&lt;/code&gt; object.
     * Using the method &lt;code&gt;populate&lt;/code&gt; can be more efficient than using
     * the version of the &lt;code&gt;execute&lt;/code&gt; method that takes no parameters
     * because it does not open a new connection and re-execute this
     * &lt;code&gt;CachedRowSet&lt;/code&gt; object's command. Using the &lt;code&gt;populate&lt;/code&gt;
     *  method is more a matter of convenience when compared to using the version
     * of &lt;code&gt;execute&lt;/code&gt; that takes a &lt;code&gt;ResultSet&lt;/code&gt; object.
     *
     * @param startRow the position in the &lt;code&gt;ResultSet&lt;/code&gt; from where to start
     *                populating the records in this &lt;code&gt;CachedRowSet&lt;/code&gt;
     * @param rs the &lt;code&gt;ResultSet&lt;/code&gt; object containing the data
     * to be read into this &lt;code&gt;CachedRowSet&lt;/code&gt; object
     * @throws SQLException if a null &lt;code&gt;ResultSet&lt;/code&gt; object is supplied
     * or this &lt;code&gt;CachedRowSet&lt;/code&gt; object cannot
     * retrieve the associated &lt;code&gt;ResultSetMetaData&lt;/code&gt; object
     * @see #execute
     * @see #populate(ResultSet)
     * @see java.sql.ResultSet
     * @see java.sql.ResultSetMetaData
    */
    public void populate(ResultSet rs, int startRow) throws SQLException;

    /**
     * Sets the &lt;code&gt;CachedRowSet&lt;/code&gt; object's page-size. A &lt;code&gt;CachedRowSet&lt;/code&gt;
     * may be configured to populate itself in page-size sized batches of rows. When
     * either &lt;code&gt;populate()&lt;/code&gt; or &lt;code&gt;execute()&lt;/code&gt; are called, the
     * &lt;code&gt;CachedRowSet&lt;/code&gt; fetches an additional page according to the
     * original SQL query used to populate the RowSet.
     *
     * @param size the page-size of the &lt;code&gt;CachedRowSet&lt;/code&gt;
     * @throws SQLException if an error occurs setting the &lt;code&gt;CachedRowSet&lt;/code&gt;
     *      page size or if the page size is less than 0.
     */
    public void setPageSize(int size) throws SQLException;

    /**
     * Returns the page-size for the &lt;code&gt;CachedRowSet&lt;/code&gt; object
     *
     * @return an &lt;code&gt;int&lt;/code&gt; page size
     */
    public int getPageSize();

    /**
     * Increments the current page of the &lt;code&gt;CachedRowSet&lt;/code&gt;. This causes
     * the &lt;code&gt;CachedRowSet&lt;/code&gt; implementation to fetch the next page-size
     * rows and populate the RowSet, if remaining rows remain within scope of the
     * original SQL query used to populated the RowSet.
     *
     * @return true if more pages exist; false if this is the last page
     * @throws SQLException if an error occurs fetching the next page, or if this
     *     method is called prematurely before populate or execute.
     */
    public boolean nextPage() throws SQLException;

    /**
     * Decrements the current page of the &lt;code&gt;CachedRowSet&lt;/code&gt;. This causes
     * the &lt;code&gt;CachedRowSet&lt;/code&gt; implementation to fetch the previous page-size
     * rows and populate the RowSet. The amount of rows returned in the previous
     * page must always remain within scope of the original SQL query used to
     * populate the RowSet.
     *
     * @return true if the previous page is successfully retrieved; false if this
     *     is the first page.
     * @throws SQLException if an error occurs fetching the previous page, or if
     *     this method is called prematurely before populate or execute.
     */
    public boolean previousPage() throws SQLException;

}
</pre>
</body>
</html>
