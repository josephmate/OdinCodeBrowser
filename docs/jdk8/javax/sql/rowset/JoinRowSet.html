<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.sql.rowset;

import java.sql.*;
import javax.sql.*;
import javax.naming.*;
import java.io.*;
import java.math.*;
import java.util.*;

import javax.sql.rowset.*;

/**
 * The &lt;code&gt;JoinRowSet&lt;/code&gt; interface provides a mechanism for combining related
 * data from different &lt;code&gt;RowSet&lt;/code&gt; objects into one &lt;code&gt;JoinRowSet&lt;/code&gt;
 * object, which represents an SQL &lt;code&gt;JOIN&lt;/code&gt;.
 * In other words, a &lt;code&gt;JoinRowSet&lt;/code&gt; object acts as a
 * container for the data from &lt;code&gt;RowSet&lt;/code&gt; objects that form an SQL
 * &lt;code&gt;JOIN&lt;/code&gt; relationship.
 * &lt;P&gt;
 * The &lt;code&gt;Joinable&lt;/code&gt; interface provides the methods for setting,
 * retrieving, and unsetting a match column, the basis for
 * establishing an SQL &lt;code&gt;JOIN&lt;/code&gt; relationship. The match column may
 * alternatively be set by supplying it to the appropriate version of the
 * &lt;code&gt;JointRowSet&lt;/code&gt; method &lt;code&gt;addRowSet&lt;/code&gt;.
 *
 * &lt;h3&gt;1.0 Overview&lt;/h3&gt;
 * Disconnected &lt;code&gt;RowSet&lt;/code&gt; objects (&lt;code&gt;CachedRowSet&lt;/code&gt; objects
 * and implementations extending the &lt;code&gt;CachedRowSet&lt;/code&gt; interface)
 * do not have a standard way to establish an SQL &lt;code&gt;JOIN&lt;/code&gt; between
 * &lt;code&gt;RowSet&lt;/code&gt; objects without the expensive operation of
 * reconnecting to the data source. The &lt;code&gt;JoinRowSet&lt;/code&gt;
 * interface is specifically designed to address this need.
 * &lt;P&gt;
 * Any &lt;code&gt;RowSet&lt;/code&gt; object
 * can be added to a &lt;code&gt;JoinRowSet&lt;/code&gt; object to become
 * part of an SQL &lt;code&gt;JOIN&lt;/code&gt; relationship. This means that both connected
 * and disconnected &lt;code&gt;RowSet&lt;/code&gt; objects can be part of a &lt;code&gt;JOIN&lt;/code&gt;.
 * &lt;code&gt;RowSet&lt;/code&gt; objects operating in a connected environment
 * (&lt;code&gt;JdbcRowSet&lt;/code&gt; objects) are
 * encouraged to use the database to which they are already
 * connected to establish SQL &lt;code&gt;JOIN&lt;/code&gt; relationships between
 * tables directly. However, it is possible for a
 * &lt;code&gt;JdbcRowSet&lt;/code&gt; object to be added to a &lt;code&gt;JoinRowSet&lt;/code&gt; object
 * if necessary.
 * &lt;P&gt;
 * Any number of &lt;code&gt;RowSet&lt;/code&gt; objects can be added to an
 * instance of &lt;code&gt;JoinRowSet&lt;/code&gt; provided that they
 * can be related in an SQL &lt;code&gt;JOIN&lt;/code&gt;.
 * By definition, the SQL &lt;code&gt;JOIN&lt;/code&gt; statement is used to
 * combine the data contained in two or more relational database tables based
 * upon a common attribute. The &lt;code&gt;Joinable&lt;/code&gt; interface provides the methods
 * for establishing a common attribute, which is done by setting a
 * &lt;i&gt;match column&lt;/i&gt;. The match column commonly coincides with
 * the primary key, but there is
 * no requirement that the match column be the same as the primary key.
 * By establishing and then enforcing column matches,
 * a &lt;code&gt;JoinRowSet&lt;/code&gt; object establishes &lt;code&gt;JOIN&lt;/code&gt; relationships
 * between &lt;code&gt;RowSet&lt;/code&gt; objects without the assistance of an available
 * relational database.
 * &lt;P&gt;
 * The type of &lt;code&gt;JOIN&lt;/code&gt; to be established is determined by setting
 * one of the &lt;code&gt;JoinRowSet&lt;/code&gt; constants using the method
 * &lt;code&gt;setJoinType&lt;/code&gt;. The following SQL &lt;code&gt;JOIN&lt;/code&gt; types can be set:
 * &lt;UL&gt;
 *  &lt;LI&gt;&lt;code&gt;CROSS_JOIN&lt;/code&gt;
 *  &lt;LI&gt;&lt;code&gt;FULL_JOIN&lt;/code&gt;
 *  &lt;LI&gt;&lt;code&gt;INNER_JOIN&lt;/code&gt; - the default if no &lt;code&gt;JOIN&lt;/code&gt; type has been set
 *  &lt;LI&gt;&lt;code&gt;LEFT_OUTER_JOIN&lt;/code&gt;
 *  &lt;LI&gt;&lt;code&gt;RIGHT_OUTER_JOIN&lt;/code&gt;
 * &lt;/UL&gt;
 * Note that if no type is set, the &lt;code&gt;JOIN&lt;/code&gt; will automatically be an
 * inner join. The comments for the fields in the
 * &lt;code&gt;JoinRowSet&lt;/code&gt; interface explain these &lt;code&gt;JOIN&lt;/code&gt; types, which are
 * standard SQL &lt;code&gt;JOIN&lt;/code&gt; types.
 *
 * &lt;h3&gt;2.0 Using a &lt;code&gt;JoinRowSet&lt;/code&gt; Object for Creating a &lt;code&gt;JOIN&lt;/code&gt;&lt;/h3&gt;
 * When a &lt;code&gt;JoinRowSet&lt;/code&gt; object is created, it is empty.
 * The first &lt;code&gt;RowSet&lt;/code&gt; object to be added becomes the basis for the
 * &lt;code&gt;JOIN&lt;/code&gt; relationship.
 * Applications must determine which column in each of the
 * &lt;code&gt;RowSet&lt;/code&gt; objects to be added to the &lt;code&gt;JoinRowSet&lt;/code&gt; object
 * should be the match column. All of the
 * &lt;code&gt;RowSet&lt;/code&gt; objects must contain a match column, and the values in
 * each match column must be ones that can be compared to values in the other match
 * columns. The columns do not have to have the same name, though they often do,
 * and they do not have to store the exact same data type as long as the data types
 * can be compared.
 * &lt;P&gt;
 * A match column can be be set in two ways:
 * &lt;ul&gt;
 *  &lt;li&gt;By calling the &lt;code&gt;Joinable&lt;/code&gt; method &lt;code&gt;setMatchColumn&lt;/code&gt;&lt;br&gt;
 *  This is the only method that can set the match column before a &lt;code&gt;RowSet&lt;/code&gt;
 *  object is added to a &lt;code&gt;JoinRowSet&lt;/code&gt; object. The &lt;code&gt;RowSet&lt;/code&gt; object
 *  must have implemented the &lt;code&gt;Joinable&lt;/code&gt; interface in order to use the method
 *  &lt;code&gt;setMatchColumn&lt;/code&gt;. Once the match column value
 *  has been set, this method can be used to reset the match column at any time.
 *  &lt;li&gt;By calling one of the versions of the &lt;code&gt;JoinRowSet&lt;/code&gt; method
 *  &lt;code&gt;addRowSet&lt;/code&gt; that takes a column name or number (or an array of
 *  column names or numbers)&lt;BR&gt;
 *  Four of the five &lt;code&gt;addRowSet&lt;/code&gt; methods take a match column as a parameter.
 *  These four methods set or reset the match column at the time a &lt;code&gt;RowSet&lt;/code&gt;
 *  object is being added to a &lt;code&gt;JoinRowSet&lt;/code&gt; object.
 * &lt;/ul&gt;
 * &lt;h3&gt;3.0 Sample Usage&lt;/h3&gt;
 * &lt;p&gt;
 * The following code fragment adds two &lt;code&gt;CachedRowSet&lt;/code&gt;
 * objects to a &lt;code&gt;JoinRowSet&lt;/code&gt; object. Note that in this example,
 * no SQL &lt;code&gt;JOIN&lt;/code&gt; type is set, so the default &lt;code&gt;JOIN&lt;/code&gt; type,
 * which is &lt;i&gt;INNER_JOIN&lt;/i&gt;, is established.
 * &lt;p&gt;
 * In the following code fragment, the table &lt;code&gt;EMPLOYEES&lt;/code&gt;, whose match
 * column is set to the first column (&lt;code&gt;EMP_ID&lt;/code&gt;), is added to the
 * &lt;code&gt;JoinRowSet&lt;/code&gt; object &lt;i&gt;jrs&lt;/i&gt;. Then
 * the table &lt;code&gt;ESSP_BONUS_PLAN&lt;/code&gt;, whose match column is likewise
 * the &lt;code&gt;EMP_ID&lt;/code&gt; column, is added. When this second
 * table is added to &lt;i&gt;jrs&lt;/i&gt;, only the rows in
 * &lt;code&gt;ESSP_BONUS_PLAN&lt;/code&gt; whose &lt;code&gt;EMP_ID&lt;/code&gt; value matches an
 * &lt;code&gt;EMP_ID&lt;/code&gt; value in the &lt;code&gt;EMPLOYEES&lt;/code&gt; table are added.
 * In this case, everyone in the bonus plan is an employee, so all of the rows
 * in the table &lt;code&gt;ESSP_BONUS_PLAN&lt;/code&gt; are added to the &lt;code&gt;JoinRowSet&lt;/code&gt;
 * object.  In this example, both &lt;code&gt;CachedRowSet&lt;/code&gt; objects being added
 * have implemented the &lt;code&gt;Joinable&lt;/code&gt; interface and can therefore call
 * the &lt;code&gt;Joinable&lt;/code&gt; method &lt;code&gt;setMatchColumn&lt;/code&gt;.
 * &lt;PRE&gt;
 *     JoinRowSet jrs = new JoinRowSetImpl();
 *
 *     ResultSet rs1 = stmt.executeQuery(&quot;SELECT * FROM EMPLOYEES&quot;);
 *     CachedRowSet empl = new CachedRowSetImpl();
 *     empl.populate(rs1);
 *     empl.setMatchColumn(1);
 *     jrs.addRowSet(empl);
 *
 *     ResultSet rs2 = stmt.executeQuery(&quot;SELECT * FROM ESSP_BONUS_PLAN&quot;);
 *     CachedRowSet bonus = new CachedRowSetImpl();
 *     bonus.populate(rs2);
 *     bonus.setMatchColumn(1); // EMP_ID is the first column
 *     jrs.addRowSet(bonus);
 * &lt;/PRE&gt;
 * &lt;P&gt;
 * At this point, &lt;i&gt;jrs&lt;/i&gt; is an inside JOIN of the two &lt;code&gt;RowSet&lt;/code&gt; objects
 * based on their &lt;code&gt;EMP_ID&lt;/code&gt; columns. The application can now browse the
 * combined data as if it were browsing one single &lt;code&gt;RowSet&lt;/code&gt; object.
 * Because &lt;i&gt;jrs&lt;/i&gt; is itself a &lt;code&gt;RowSet&lt;/code&gt; object, an application can
 * navigate or modify it using &lt;code&gt;RowSet&lt;/code&gt; methods.
 * &lt;PRE&gt;
 *     jrs.first();
 *     int employeeID = jrs.getInt(1);
 *     String employeeName = jrs.getString(2);
 * &lt;/PRE&gt;
 * &lt;P&gt;
 * Note that because the SQL &lt;code&gt;JOIN&lt;/code&gt; must be enforced when an application
 * adds a second or subsequent &lt;code&gt;RowSet&lt;/code&gt; object, there
 * may be an initial degradation in performance while the &lt;code&gt;JOIN&lt;/code&gt; is
 * being performed.
 * &lt;P&gt;
 * The following code fragment adds an additional &lt;code&gt;CachedRowSet&lt;/code&gt; object.
 * In this case, the match column (&lt;code&gt;EMP_ID&lt;/code&gt;) is set when the
 * &lt;code&gt;CachedRowSet&lt;/code&gt; object is added to the &lt;code&gt;JoinRowSet&lt;/code&gt; object.
 * &lt;PRE&gt;
 *     ResultSet rs3 = stmt.executeQuery(&quot;SELECT * FROM 401K_CONTRIB&quot;);
 *     CachedRowSet fourO1k = new CachedRowSetImpl();
 *     four01k.populate(rs3);
 *     jrs.addRowSet(four01k, 1);
 * &lt;/PRE&gt;
 * &lt;P&gt;
 * The &lt;code&gt;JoinRowSet&lt;/code&gt; object &lt;i&gt;jrs&lt;/i&gt; now contains values from all three
 * tables. The data in each row in &lt;i&gt;four01k&lt;/i&gt; in which the value for the
 * &lt;code&gt;EMP_ID&lt;/code&gt; column matches a value for the &lt;code&gt;EMP_ID&lt;/code&gt; column
 * in &lt;i&gt;jrs&lt;/i&gt; has been added to &lt;i&gt;jrs&lt;/i&gt;.
 *
 * &lt;h3&gt;4.0 &lt;code&gt;JoinRowSet&lt;/code&gt; Methods&lt;/h3&gt;
 * The &lt;code&gt;JoinRowSet&lt;/code&gt; interface supplies several methods for adding
 * &lt;code&gt;RowSet&lt;/code&gt; objects and for getting information about the
 * &lt;code&gt;JoinRowSet&lt;/code&gt; object.
 * &lt;UL&gt;
 *   &lt;LI&gt;Methods for adding one or more &lt;code&gt;RowSet&lt;/code&gt; objects&lt;BR&gt;
 *       These methods allow an application to add one &lt;code&gt;RowSet&lt;/code&gt; object
 *       at a time or to add multiple &lt;code&gt;RowSet&lt;/code&gt; objects at one time. In
 *       either case, the methods may specify the match column for each
 *       &lt;code&gt;RowSet&lt;/code&gt; object being added.
 *   &lt;LI&gt;Methods for getting information&lt;BR&gt;
 *       One method retrieves the &lt;code&gt;RowSet&lt;/code&gt; objects in the
 *       &lt;code&gt;JoinRowSet&lt;/code&gt; object, and another method retrieves the
 *       &lt;code&gt;RowSet&lt;/code&gt; names.  A third method retrieves either the SQL
 *       &lt;code&gt;WHERE&lt;/code&gt; clause used behind the scenes to form the
 *       &lt;code&gt;JOIN&lt;/code&gt; or a text description of what the &lt;code&gt;WHERE&lt;/code&gt;
 *       clause does.
 *   &lt;LI&gt;Methods related to the type of &lt;code&gt;JOIN&lt;/code&gt;&lt;BR&gt;
 *       One method sets the &lt;code&gt;JOIN&lt;/code&gt; type, and five methods find out whether
 *       the &lt;code&gt;JoinRowSet&lt;/code&gt; object supports a given type.
 *   &lt;LI&gt;A method to make a separate copy of the &lt;code&gt;JoinRowSet&lt;/code&gt; object&lt;BR&gt;
 *       This method creates a copy that can be persisted to the data source.
 * &lt;/UL&gt;
 *
 */

public interface JoinRowSet extends WebRowSet {

    /**
     * Adds the given &lt;code&gt;RowSet&lt;/code&gt; object to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object. If the &lt;code&gt;RowSet&lt;/code&gt; object
     * is the first to be added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, it forms the basis of the &lt;code&gt;JOIN&lt;/code&gt; relationship to be
     * established.
     * &lt;P&gt;
     * This method should be used only when the given &lt;code&gt;RowSet&lt;/code&gt;
     * object already has a match column that was set with the &lt;code&gt;Joinable&lt;/code&gt;
     * method &lt;code&gt;setMatchColumn&lt;/code&gt;.
     * &lt;p&gt;
     * Note: A &lt;code&gt;Joinable&lt;/code&gt; object is any &lt;code&gt;RowSet&lt;/code&gt; object
     * that has implemented the &lt;code&gt;Joinable&lt;/code&gt; interface.
     *
     * @param rowset the &lt;code&gt;RowSet&lt;/code&gt; object that is to be added to this
     *        &lt;code&gt;JoinRowSet&lt;/code&gt; object; it must implement the
     *        &lt;code&gt;Joinable&lt;/code&gt; interface and have a match column set
     * @throws SQLException if (1) an empty rowset is added to the to this
     *         &lt;code&gt;JoinRowSet&lt;/code&gt; object, (2) a match column has not been
     *         set for &lt;i&gt;rowset&lt;/i&gt;, or (3) &lt;i&gt;rowset&lt;/i&gt;
     *         violates the active &lt;code&gt;JOIN&lt;/code&gt;
     * @see Joinable#setMatchColumn
     */
    public void addRowSet(Joinable rowset) throws SQLException;

    /**
     * Adds the given &lt;code&gt;RowSet&lt;/code&gt; object to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object and sets the designated column as the match column for
     * the &lt;code&gt;RowSet&lt;/code&gt; object. If the &lt;code&gt;RowSet&lt;/code&gt; object
     * is the first to be added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, it forms the basis of the &lt;code&gt;JOIN&lt;/code&gt; relationship to be
     * established.
     * &lt;P&gt;
     * This method should be used when &lt;i&gt;RowSet&lt;/i&gt; does not already have a match
     * column set.
     *
     * @param rowset the &lt;code&gt;RowSet&lt;/code&gt; object that is to be added to this
     *        &lt;code&gt;JoinRowSet&lt;/code&gt; object; it may implement the
     *        &lt;code&gt;Joinable&lt;/code&gt; interface
     * @param columnIdx an &lt;code&gt;int&lt;/code&gt; that identifies the column to become the
     *         match column
     * @throws SQLException if (1) &lt;i&gt;rowset&lt;/i&gt; is an empty rowset or
     *         (2) &lt;i&gt;rowset&lt;/i&gt; violates the active &lt;code&gt;JOIN&lt;/code&gt;
     * @see Joinable#unsetMatchColumn
     */
    public void addRowSet(RowSet rowset, int columnIdx) throws SQLException;

    /**
     * Adds &lt;i&gt;rowset&lt;/i&gt; to this &lt;code&gt;JoinRowSet&lt;/code&gt; object and
     * sets the designated column as the match column. If &lt;i&gt;rowset&lt;/i&gt;
     * is the first to be added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, it forms the basis for the &lt;code&gt;JOIN&lt;/code&gt; relationship to be
     * established.
     * &lt;P&gt;
     * This method should be used when the given &lt;code&gt;RowSet&lt;/code&gt; object
     * does not already have a match column.
     *
     * @param rowset the &lt;code&gt;RowSet&lt;/code&gt; object that is to be added to this
     *        &lt;code&gt;JoinRowSet&lt;/code&gt; object; it may implement the
     *        &lt;code&gt;Joinable&lt;/code&gt; interface
     * @param columnName the &lt;code&gt;String&lt;/code&gt; object giving the name of the
     *        column to be set as the match column
     * @throws SQLException if (1) &lt;i&gt;rowset&lt;/i&gt; is an empty rowset or
     *         (2) the match column for &lt;i&gt;rowset&lt;/i&gt; does not satisfy the
     *         conditions of the &lt;code&gt;JOIN&lt;/code&gt;
     */
     public void addRowSet(RowSet rowset,
                           String columnName) throws SQLException;

    /**
     * Adds one or more &lt;code&gt;RowSet&lt;/code&gt; objects contained in the given
     * array of &lt;code&gt;RowSet&lt;/code&gt; objects to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object and sets the match column for
     * each of the &lt;code&gt;RowSet&lt;/code&gt; objects to the match columns
     * in the given array of column indexes. The first element in
     * &lt;i&gt;columnIdx&lt;/i&gt; is set as the match column for the first
     * &lt;code&gt;RowSet&lt;/code&gt; object in &lt;i&gt;rowset&lt;/i&gt;, the second element of
     * &lt;i&gt;columnIdx&lt;/i&gt; is set as the match column for the second element
     * in &lt;i&gt;rowset&lt;/i&gt;, and so on.
     * &lt;P&gt;
     * The first &lt;code&gt;RowSet&lt;/code&gt; object added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object forms the basis for the &lt;code&gt;JOIN&lt;/code&gt; relationship.
     * &lt;P&gt;
     * This method should be used when the given &lt;code&gt;RowSet&lt;/code&gt; object
     * does not already have a match column.
     *
     * @param rowset an array of one or more &lt;code&gt;RowSet&lt;/code&gt; objects
     *        to be added to the &lt;code&gt;JOIN&lt;/code&gt;; it may implement the
     *        &lt;code&gt;Joinable&lt;/code&gt; interface
     * @param columnIdx an array of &lt;code&gt;int&lt;/code&gt; values indicating the index(es)
     *        of the columns to be set as the match columns for the &lt;code&gt;RowSet&lt;/code&gt;
     *        objects in &lt;i&gt;rowset&lt;/i&gt;
     * @throws SQLException if (1) an empty rowset is added to this
     *         &lt;code&gt;JoinRowSet&lt;/code&gt; object, (2) a match column is not set
     *         for a &lt;code&gt;RowSet&lt;/code&gt; object in &lt;i&gt;rowset&lt;/i&gt;, or (3)
     *         a &lt;code&gt;RowSet&lt;/code&gt; object being added violates the active
     *         &lt;code&gt;JOIN&lt;/code&gt;
     */
    public void addRowSet(RowSet[] rowset,
                          int[] columnIdx) throws SQLException;

    /**
     * Adds one or more &lt;code&gt;RowSet&lt;/code&gt; objects contained in the given
     * array of &lt;code&gt;RowSet&lt;/code&gt; objects to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object and sets the match column for
     * each of the &lt;code&gt;RowSet&lt;/code&gt; objects to the match columns
     * in the given array of column names. The first element in
     * &lt;i&gt;columnName&lt;/i&gt; is set as the match column for the first
     * &lt;code&gt;RowSet&lt;/code&gt; object in &lt;i&gt;rowset&lt;/i&gt;, the second element of
     * &lt;i&gt;columnName&lt;/i&gt; is set as the match column for the second element
     * in &lt;i&gt;rowset&lt;/i&gt;, and so on.
     * &lt;P&gt;
     * The first &lt;code&gt;RowSet&lt;/code&gt; object added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object forms the basis for the &lt;code&gt;JOIN&lt;/code&gt; relationship.
     * &lt;P&gt;
     * This method should be used when the given &lt;code&gt;RowSet&lt;/code&gt; object(s)
     * does not already have a match column.
     *
     * @param rowset an array of one or more &lt;code&gt;RowSet&lt;/code&gt; objects
     *        to be added to the &lt;code&gt;JOIN&lt;/code&gt;; it may implement the
     *        &lt;code&gt;Joinable&lt;/code&gt; interface
     * @param columnName an array of &lt;code&gt;String&lt;/code&gt; values indicating the
     *        names of the columns to be set as the match columns for the
     *        &lt;code&gt;RowSet&lt;/code&gt; objects in &lt;i&gt;rowset&lt;/i&gt;
     * @throws SQLException if (1) an empty rowset is added to this
     *         &lt;code&gt;JoinRowSet&lt;/code&gt; object, (2) a match column is not set
     *         for a &lt;code&gt;RowSet&lt;/code&gt; object in &lt;i&gt;rowset&lt;/i&gt;, or (3)
     *         a &lt;code&gt;RowSet&lt;/code&gt; object being added violates the active
     *         &lt;code&gt;JOIN&lt;/code&gt;
     */
    public void addRowSet(RowSet[] rowset,
                          String[] columnName) throws SQLException;

    /**
     * Returns a &lt;code&gt;Collection&lt;/code&gt; object containing the
     * &lt;code&gt;RowSet&lt;/code&gt; objects that have been added to this
     * &lt;code&gt;JoinRowSet&lt;/code&gt; object.
     * This should return the 'n' number of RowSet contained
     * within the &lt;code&gt;JOIN&lt;/code&gt; and maintain any updates that have occurred while in
     * this union.
     *
     * @return a &lt;code&gt;Collection&lt;/code&gt; object consisting of the
     *        &lt;code&gt;RowSet&lt;/code&gt; objects added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     *        object
     * @throws SQLException if an error occurs generating the
     *         &lt;code&gt;Collection&lt;/code&gt; object to be returned
     */
    public Collection&lt;?&gt; getRowSets() throws java.sql.SQLException;

    /**
     * Returns a &lt;code&gt;String&lt;/code&gt; array containing the names of the
     *         &lt;code&gt;RowSet&lt;/code&gt; objects added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     *         object.
     *
     * @return a &lt;code&gt;String&lt;/code&gt; array of the names of the
     *         &lt;code&gt;RowSet&lt;/code&gt; objects in this &lt;code&gt;JoinRowSet&lt;/code&gt;
     *         object
     * @throws SQLException if an error occurs retrieving the names of
     *         the &lt;code&gt;RowSet&lt;/code&gt; objects
     * @see CachedRowSet#setTableName
     */
    public String[] getRowSetNames() throws java.sql.SQLException;

    /**
     * Creates a new &lt;code&gt;CachedRowSet&lt;/code&gt; object containing the
     * data in this &lt;code&gt;JoinRowSet&lt;/code&gt; object, which can be saved
     * to a data source using the &lt;code&gt;SyncProvider&lt;/code&gt; object for
     * the &lt;code&gt;CachedRowSet&lt;/code&gt; object.
     * &lt;P&gt;
     * If any updates or modifications have been applied to the JoinRowSet
     * the CachedRowSet returned by the method will not be able to persist
     * it's changes back to the originating rows and tables in the
     * in the datasource. The CachedRowSet instance returned should not
     * contain modification data and it should clear all properties of
     * it's originating SQL statement. An application should reset the
     * SQL statement using the &lt;code&gt;RowSet.setCommand&lt;/code&gt; method.
     * &lt;p&gt;
     * In order to allow changes to be persisted back to the datasource
     * to the originating tables, the &lt;code&gt;acceptChanges&lt;/code&gt; method
     * should be used and called on a JoinRowSet object instance. Implementations
     * can leverage the internal data and update tracking in their
     * implementations to interact with the SyncProvider to persist any
     * changes.
     *
     * @return a CachedRowSet containing the contents of the JoinRowSet
     * @throws SQLException if an error occurs assembling the CachedRowSet
     * object
     * @see javax.sql.RowSet
     * @see javax.sql.rowset.CachedRowSet
     * @see javax.sql.rowset.spi.SyncProvider
     */
    public CachedRowSet toCachedRowSet() throws java.sql.SQLException;

    /**
     * Indicates if CROSS_JOIN is supported by a JoinRowSet
     * implementation
     *
     * @return true if the CROSS_JOIN is supported; false otherwise
     */
    public boolean supportsCrossJoin();

    /**
     * Indicates if INNER_JOIN is supported by a JoinRowSet
     * implementation
     *
     * @return true is the INNER_JOIN is supported; false otherwise
     */
    public boolean supportsInnerJoin();

    /**
     * Indicates if LEFT_OUTER_JOIN is supported by a JoinRowSet
     * implementation
     *
     * @return true is the LEFT_OUTER_JOIN is supported; false otherwise
     */
    public boolean supportsLeftOuterJoin();

    /**
     * Indicates if RIGHT_OUTER_JOIN is supported by a JoinRowSet
     * implementation
     *
     * @return true is the RIGHT_OUTER_JOIN is supported; false otherwise
     */
    public boolean supportsRightOuterJoin();

    /**
     * Indicates if FULL_JOIN is supported by a JoinRowSet
     * implementation
     *
     * @return true is the FULL_JOIN is supported; false otherwise
     */
    public boolean supportsFullJoin();

    /**
     * Allow the application to adjust the type of &lt;code&gt;JOIN&lt;/code&gt; imposed
     * on tables contained within the JoinRowSet object instance.
     * Implementations should throw a SQLException if they do
     * not support a given &lt;code&gt;JOIN&lt;/code&gt; type.
     *
     * @param joinType the standard JoinRowSet.XXX static field definition
     * of a SQL &lt;code&gt;JOIN&lt;/code&gt; to re-configure a JoinRowSet instance on
     * the fly.
     * @throws SQLException if an unsupported &lt;code&gt;JOIN&lt;/code&gt; type is set
     * @see #getJoinType
     */
    public void setJoinType(int joinType) throws SQLException;

    /**
     * Return a SQL-like description of the WHERE clause being used
     * in a JoinRowSet object. An implementation can describe
     * the WHERE clause of the SQL &lt;code&gt;JOIN&lt;/code&gt; by supplying a SQL
     * strings description of &lt;code&gt;JOIN&lt;/code&gt; or provide a textual
     * description to assist applications using a &lt;code&gt;JoinRowSet&lt;/code&gt;
     *
     * @return whereClause a textual or SQL description of the logical
     * WHERE clause used in the JoinRowSet instance
     * @throws SQLException if an error occurs in generating a representation
     * of the WHERE clause.
     */
    public String getWhereClause() throws SQLException;

    /**
     * Returns a &lt;code&gt;int&lt;/code&gt; describing the set SQL &lt;code&gt;JOIN&lt;/code&gt; type
     * governing this JoinRowSet instance. The returned type will be one of
     * standard JoinRowSet types: &lt;code&gt;CROSS_JOIN&lt;/code&gt;, &lt;code&gt;INNER_JOIN&lt;/code&gt;,
     * &lt;code&gt;LEFT_OUTER_JOIN&lt;/code&gt;, &lt;code&gt;RIGHT_OUTER_JOIN&lt;/code&gt; or
     * &lt;code&gt;FULL_JOIN&lt;/code&gt;.
     *
     * @return joinType one of the standard JoinRowSet static field
     *     definitions of a SQL &lt;code&gt;JOIN&lt;/code&gt;. &lt;code&gt;JoinRowSet.INNER_JOIN&lt;/code&gt;
     *     is returned as the default &lt;code&gt;JOIN&lt;/code&gt; type is no type has been
     *     explicitly set.
     * @throws SQLException if an error occurs determining the SQL &lt;code&gt;JOIN&lt;/code&gt;
     *     type supported by the JoinRowSet instance.
     * @see #setJoinType
     */
    public int getJoinType() throws SQLException;

    /**
     * An ANSI-style &lt;code&gt;JOIN&lt;/code&gt; providing a cross product of two tables
     */
    public static int CROSS_JOIN = 0;

    /**
     * An ANSI-style &lt;code&gt;JOIN&lt;/code&gt; providing a inner join between two tables. Any
     * unmatched rows in either table of the join should be discarded.
     */
    public static int INNER_JOIN = 1;

    /**
     * An ANSI-style &lt;code&gt;JOIN&lt;/code&gt; providing a left outer join between two
     * tables. In SQL, this is described where all records should be
     * returned from the left side of the JOIN statement.
     */
    public static int LEFT_OUTER_JOIN = 2;

    /**
     * An ANSI-style &lt;code&gt;JOIN&lt;/code&gt; providing a right outer join between
     * two tables. In SQL, this is described where all records from the
     * table on the right side of the JOIN statement even if the table
     * on the left has no matching record.
     */
    public static int RIGHT_OUTER_JOIN = 3;

    /**
     * An ANSI-style &lt;code&gt;JOIN&lt;/code&gt; providing a a full JOIN. Specifies that all
     * rows from either table be returned regardless of matching
     * records on the other table.
     */
    public static int FULL_JOIN = 4;


}
</pre>
</body>
</html>
