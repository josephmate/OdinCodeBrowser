<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.sql.rowset.serial;

import java.sql.*;
import java.io.*;
import java.lang.reflect.*;
import java.util.Arrays;


/**
 * A serialized mapping in the Java programming language of an SQL
 * &lt;code&gt;BLOB&lt;/code&gt; value.
 * &lt;P&gt;
 * The &lt;code&gt;SerialBlob&lt;/code&gt; class provides a constructor for creating
 * an instance from a &lt;code&gt;Blob&lt;/code&gt; object.  Note that the
 * &lt;code&gt;Blob&lt;/code&gt;
 * object should have brought the SQL &lt;code&gt;BLOB&lt;/code&gt; value's data over
 * to the client before a &lt;code&gt;SerialBlob&lt;/code&gt; object
 * is constructed from it.  The data of an SQL &lt;code&gt;BLOB&lt;/code&gt; value can
 * be materialized on the client as an array of bytes (using the method
 * &lt;code&gt;Blob.getBytes&lt;/code&gt;) or as a stream of uninterpreted bytes
 * (using the method &lt;code&gt;Blob.getBinaryStream&lt;/code&gt;).
 * &lt;P&gt;
 * &lt;code&gt;SerialBlob&lt;/code&gt; methods make it possible to make a copy of a
 * &lt;code&gt;SerialBlob&lt;/code&gt; object as an array of bytes or as a stream.
 * They also make it possible to locate a given pattern of bytes or a
 * &lt;code&gt;Blob&lt;/code&gt; object within a &lt;code&gt;SerialBlob&lt;/code&gt; object
 * and to update or truncate a &lt;code&gt;Blob&lt;/code&gt; object.
 *
 * &lt;h3&gt; Thread safety &lt;/h3&gt;
 *
 * &lt;p&gt; A SerialBlob is not safe for use by multiple concurrent threads.  If a
 * SerialBlob is to be used by more than one thread then access to the SerialBlob
 * should be controlled by appropriate synchronization.
 *
 * @author Jonathan Bruce
 */
public class SerialBlob implements Blob, Serializable, Cloneable {

    /**
     * A serialized array of uninterpreted bytes representing the
     * value of this &lt;code&gt;SerialBlob&lt;/code&gt; object.
     * @serial
     */
    private byte buf[];

    /**
     * The internal representation of the &lt;code&gt;Blob&lt;/code&gt; object on which this
     * &lt;code&gt;SerialBlob&lt;/code&gt; object is based.
     */
    private Blob blob;

    /**
     * The number of bytes in this &lt;code&gt;SerialBlob&lt;/code&gt; object's
     * array of bytes.
     * @serial
     */
    private long len;

    /**
     * The original number of bytes in this &lt;code&gt;SerialBlob&lt;/code&gt; object's
     * array of bytes when it was first established.
     * @serial
     */
    private long origLen;

    /**
     * Constructs a &lt;code&gt;SerialBlob&lt;/code&gt; object that is a serialized version of
     * the given &lt;code&gt;byte&lt;/code&gt; array.
     * &lt;p&gt;
     * The new &lt;code&gt;SerialBlob&lt;/code&gt; object is initialized with the data from the
     * &lt;code&gt;byte&lt;/code&gt; array, thus allowing disconnected &lt;code&gt;RowSet&lt;/code&gt;
     * objects to establish serialized &lt;code&gt;Blob&lt;/code&gt; objects without
     * touching the data source.
     *
     * @param b the &lt;code&gt;byte&lt;/code&gt; array containing the data for the
     *        &lt;code&gt;Blob&lt;/code&gt; object to be serialized
     * @throws SerialException if an error occurs during serialization
     * @throws SQLException if a SQL errors occurs
     */
    public SerialBlob(byte[] b) throws SerialException, SQLException {

        len = b.length;
        buf = new byte[(int)len];
        for(int i = 0; i &lt; len; i++) {
           buf[i] = b[i];
        }
        origLen = len;
    }


    /**
     * Constructs a &lt;code&gt;SerialBlob&lt;/code&gt; object that is a serialized
     * version of the given &lt;code&gt;Blob&lt;/code&gt; object.
     * &lt;P&gt;
     * The new &lt;code&gt;SerialBlob&lt;/code&gt; object is initialized with the
     * data from the &lt;code&gt;Blob&lt;/code&gt; object; therefore, the
     * &lt;code&gt;Blob&lt;/code&gt; object should have previously brought the
     * SQL &lt;code&gt;BLOB&lt;/code&gt; value's data over to the client from
     * the database. Otherwise, the new &lt;code&gt;SerialBlob&lt;/code&gt; object
     * will contain no data.
     *
     * @param blob the &lt;code&gt;Blob&lt;/code&gt; object from which this
     *     &lt;code&gt;SerialBlob&lt;/code&gt; object is to be constructed;
     *     cannot be null.
     * @throws SerialException if an error occurs during serialization
     * @throws SQLException if the &lt;code&gt;Blob&lt;/code&gt; passed to this
     *     to this constructor is a &lt;code&gt;null&lt;/code&gt;.
     * @see java.sql.Blob
     */
    public SerialBlob (Blob blob) throws SerialException, SQLException {

        if (blob == null) {
            throw new SQLException(&quot;Cannot instantiate a SerialBlob &quot; +
                 &quot;object with a null Blob object&quot;);
        }

        len = blob.length();
        buf = blob.getBytes(1, (int)len );
        this.blob = blob;

         //if ( len &lt; 10240000)
         // len = 10240000;
        origLen = len;
    }

    /**
     * Copies the specified number of bytes, starting at the given
     * position, from this &lt;code&gt;SerialBlob&lt;/code&gt; object to
     * another array of bytes.
     * &lt;P&gt;
     * Note that if the given number of bytes to be copied is larger than
     * the length of this &lt;code&gt;SerialBlob&lt;/code&gt; object's array of
     * bytes, the given number will be shortened to the array's length.
     *
     * @param pos the ordinal position of the first byte in this
     *            &lt;code&gt;SerialBlob&lt;/code&gt; object to be copied;
     *            numbering starts at &lt;code&gt;1&lt;/code&gt;; must not be less
     *            than &lt;code&gt;1&lt;/code&gt; and must be less than or equal
     *            to the length of this &lt;code&gt;SerialBlob&lt;/code&gt; object
     * @param length the number of bytes to be copied
     * @return an array of bytes that is a copy of a region of this
     *         &lt;code&gt;SerialBlob&lt;/code&gt; object, starting at the given
     *         position and containing the given number of consecutive bytes
     * @throws SerialException if the given starting position is out of bounds;
     * if {@code free} had previously been called on this object
     */
    public byte[] getBytes(long pos, int length) throws SerialException {
        isValid();
        if (length &gt; len) {
            length = (int)len;
        }

        if (pos &lt; 1 || len - pos &lt; 0 ) {
            throw new SerialException(&quot;Invalid arguments: position cannot be &quot;
                    + &quot;less than 1 or greater than the length of the SerialBlob&quot;);
        }

        pos--; // correct pos to array index

        byte[] b = new byte[length];

        for (int i = 0; i &lt; length; i++) {
            b[i] = this.buf[(int)pos];
            pos++;
        }
        return b;
    }

    /**
     * Retrieves the number of bytes in this &lt;code&gt;SerialBlob&lt;/code&gt;
     * object's array of bytes.
     *
     * @return a &lt;code&gt;long&lt;/code&gt; indicating the length in bytes of this
     *         &lt;code&gt;SerialBlob&lt;/code&gt; object's array of bytes
     * @throws SerialException if an error occurs;
     * if {@code free} had previously been called on this object
     */
    public long length() throws SerialException {
        isValid();
        return len;
    }

    /**
     * Returns this &lt;code&gt;SerialBlob&lt;/code&gt; object as an input stream.
     * Unlike the related method, &lt;code&gt;setBinaryStream&lt;/code&gt;,
     * a stream is produced regardless of whether the &lt;code&gt;SerialBlob&lt;/code&gt;
     * was created with a &lt;code&gt;Blob&lt;/code&gt; object or a &lt;code&gt;byte&lt;/code&gt; array.
     *
     * @return a &lt;code&gt;java.io.InputStream&lt;/code&gt; object that contains
     *         this &lt;code&gt;SerialBlob&lt;/code&gt; object's array of bytes
     * @throws SerialException if an error occurs;
     * if {@code free} had previously been called on this object
     * @see #setBinaryStream
     */
    public java.io.InputStream getBinaryStream() throws SerialException {
        isValid();
        InputStream stream = new ByteArrayInputStream(buf);
        return stream;
    }

    /**
     * Returns the position in this &lt;code&gt;SerialBlob&lt;/code&gt; object where
     * the given pattern of bytes begins, starting the search at the
     * specified position.
     *
     * @param pattern the pattern of bytes for which to search
     * @param start the position of the byte in this
     *              &lt;code&gt;SerialBlob&lt;/code&gt; object from which to begin
     *              the search; the first position is &lt;code&gt;1&lt;/code&gt;;
     *              must not be less than &lt;code&gt;1&lt;/code&gt; nor greater than
     *              the length of this &lt;code&gt;SerialBlob&lt;/code&gt; object
     * @return the position in this &lt;code&gt;SerialBlob&lt;/code&gt; object
     *         where the given pattern begins, starting at the specified
     *         position; &lt;code&gt;-1&lt;/code&gt; if the pattern is not found
     *         or the given starting position is out of bounds; position
     *         numbering for the return value starts at &lt;code&gt;1&lt;/code&gt;
     * @throws SerialException if an error occurs when serializing the blob;
     * if {@code free} had previously been called on this object
     * @throws SQLException if there is an error accessing the &lt;code&gt;BLOB&lt;/code&gt;
     *         value from the database
     */
    public long position(byte[] pattern, long start)
                throws SerialException, SQLException {
        isValid();
        if (start &lt; 1 || start &gt; len) {
            return -1;
        }

        int pos = (int)start-1; // internally Blobs are stored as arrays.
        int i = 0;
        long patlen = pattern.length;

        while (pos &lt; len) {
            if (pattern[i] == buf[pos]) {
                if (i + 1 == patlen) {
                    return (pos + 1) - (patlen - 1);
                }
                i++; pos++; // increment pos, and i
            } else if (pattern[i] != buf[pos]) {
                pos++; // increment pos only
            }
        }
        return -1; // not found
    }

    /**
     * Returns the position in this &lt;code&gt;SerialBlob&lt;/code&gt; object where
     * the given &lt;code&gt;Blob&lt;/code&gt; object begins, starting the search at the
     * specified position.
     *
     * @param pattern the &lt;code&gt;Blob&lt;/code&gt; object for which to search;
     * @param start the position of the byte in this
     *              &lt;code&gt;SerialBlob&lt;/code&gt; object from which to begin
     *              the search; the first position is &lt;code&gt;1&lt;/code&gt;;
     *              must not be less than &lt;code&gt;1&lt;/code&gt; nor greater than
     *              the length of this &lt;code&gt;SerialBlob&lt;/code&gt; object
     * @return the position in this &lt;code&gt;SerialBlob&lt;/code&gt; object
     *         where the given &lt;code&gt;Blob&lt;/code&gt; object begins, starting
     *         at the specified position; &lt;code&gt;-1&lt;/code&gt; if the pattern is
     *         not found or the given starting position is out of bounds;
     *         position numbering for the return value starts at &lt;code&gt;1&lt;/code&gt;
     * @throws SerialException if an error occurs when serializing the blob;
     * if {@code free} had previously been called on this object
     * @throws SQLException if there is an error accessing the &lt;code&gt;BLOB&lt;/code&gt;
     *         value from the database
     */
    public long position(Blob pattern, long start)
       throws SerialException, SQLException {
        isValid();
        return position(pattern.getBytes(1, (int)(pattern.length())), start);
    }

    /**
     * Writes the given array of bytes to the &lt;code&gt;BLOB&lt;/code&gt; value that
     * this &lt;code&gt;Blob&lt;/code&gt; object represents, starting at position
     * &lt;code&gt;pos&lt;/code&gt;, and returns the number of bytes written.
     *
     * @param pos the position in the SQL &lt;code&gt;BLOB&lt;/code&gt; value at which
     *     to start writing. The first position is &lt;code&gt;1&lt;/code&gt;;
     *     must not be less than &lt;code&gt;1&lt;/code&gt; nor greater than
     *     the length of this &lt;code&gt;SerialBlob&lt;/code&gt; object.
     * @param bytes the array of bytes to be written to the &lt;code&gt;BLOB&lt;/code&gt;
     *        value that this &lt;code&gt;Blob&lt;/code&gt; object represents
     * @return the number of bytes written
     * @throws SerialException if there is an error accessing the
     *     &lt;code&gt;BLOB&lt;/code&gt; value; or if an invalid position is set; if an
     *     invalid offset value is set;
     * if {@code free} had previously been called on this object
     * @throws SQLException if there is an error accessing the &lt;code&gt;BLOB&lt;/code&gt;
     *         value from the database
     * @see #getBytes
     */
    public int setBytes(long pos, byte[] bytes)
        throws SerialException, SQLException {
        return (setBytes(pos, bytes, 0, bytes.length));
    }

    /**
     * Writes all or part of the given &lt;code&gt;byte&lt;/code&gt; array to the
     * &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object represents
     * and returns the number of bytes written.
     * Writing starts at position &lt;code&gt;pos&lt;/code&gt; in the &lt;code&gt;BLOB&lt;/code&gt;
     * value; &lt;i&gt;len&lt;/i&gt; bytes from the given byte array are written.
     *
     * @param pos the position in the &lt;code&gt;BLOB&lt;/code&gt; object at which
     *     to start writing. The first position is &lt;code&gt;1&lt;/code&gt;;
     *     must not be less than &lt;code&gt;1&lt;/code&gt; nor greater than
     *     the length of this &lt;code&gt;SerialBlob&lt;/code&gt; object.
     * @param bytes the array of bytes to be written to the &lt;code&gt;BLOB&lt;/code&gt;
     *     value
     * @param offset the offset in the &lt;code&gt;byte&lt;/code&gt; array at which
     *     to start reading the bytes. The first offset position is
     *     &lt;code&gt;0&lt;/code&gt;; must not be less than &lt;code&gt;0&lt;/code&gt; nor greater
     *     than the length of the &lt;code&gt;byte&lt;/code&gt; array
     * @param length the number of bytes to be written to the
     *     &lt;code&gt;BLOB&lt;/code&gt; value from the array of bytes &lt;i&gt;bytes&lt;/i&gt;.
     *
     * @return the number of bytes written
     * @throws SerialException if there is an error accessing the
     *     &lt;code&gt;BLOB&lt;/code&gt; value; if an invalid position is set; if an
     *     invalid offset value is set; if number of bytes to be written
     *     is greater than the &lt;code&gt;SerialBlob&lt;/code&gt; length; or the combined
     *     values of the length and offset is greater than the Blob buffer;
     * if {@code free} had previously been called on this object
     * @throws SQLException if there is an error accessing the &lt;code&gt;BLOB&lt;/code&gt;
     *         value from the database.
     * @see #getBytes
     */
    public int setBytes(long pos, byte[] bytes, int offset, int length)
        throws SerialException, SQLException {

        isValid();
        if (offset &lt; 0 || offset &gt; bytes.length) {
            throw new SerialException(&quot;Invalid offset in byte array set&quot;);
        }

        if (pos &lt; 1 || pos &gt; this.length()) {
            throw new SerialException(&quot;Invalid position in BLOB object set&quot;);
        }

        if ((long)(length) &gt; origLen) {
            throw new SerialException(&quot;Buffer is not sufficient to hold the value&quot;);
        }

        if ((length + offset) &gt; bytes.length) {
            throw new SerialException(&quot;Invalid OffSet. Cannot have combined offset &quot; +
                &quot;and length that is greater that the Blob buffer&quot;);
        }

        int i = 0;
        pos--; // correct to array indexing
        while ( i &lt; length || (offset + i +1) &lt; (bytes.length-offset) ) {
            this.buf[(int)pos + i] = bytes[offset + i ];
            i++;
        }
        return i;
    }

    /**
     * Retrieves a stream that can be used to write to the &lt;code&gt;BLOB&lt;/code&gt;
     * value that this &lt;code&gt;Blob&lt;/code&gt; object represents.  The stream begins
     * at position &lt;code&gt;pos&lt;/code&gt;. This method forwards the
     * &lt;code&gt;setBinaryStream()&lt;/code&gt; call to the underlying &lt;code&gt;Blob&lt;/code&gt; in
     * the event that this &lt;code&gt;SerialBlob&lt;/code&gt; object is instantiated with a
     * &lt;code&gt;Blob&lt;/code&gt;. If this &lt;code&gt;SerialBlob&lt;/code&gt; is instantiated with
     * a &lt;code&gt;byte&lt;/code&gt; array, a &lt;code&gt;SerialException&lt;/code&gt; is thrown.
     *
     * @param pos the position in the &lt;code&gt;BLOB&lt;/code&gt; value at which
     *        to start writing
     * @return a &lt;code&gt;java.io.OutputStream&lt;/code&gt; object to which data can
     *         be written
     * @throws SQLException if there is an error accessing the
     *            &lt;code&gt;BLOB&lt;/code&gt; value
     * @throws SerialException if the SerialBlob in not instantiated with a
     *     &lt;code&gt;Blob&lt;/code&gt; object that supports &lt;code&gt;setBinaryStream()&lt;/code&gt;;
     * if {@code free} had previously been called on this object
     * @see #getBinaryStream
     */
    public java.io.OutputStream setBinaryStream(long pos)
        throws SerialException, SQLException {
        isValid();
        if (this.blob != null) {
            return this.blob.setBinaryStream(pos);
        } else {
            throw new SerialException(&quot;Unsupported operation. SerialBlob cannot &quot; +
                &quot;return a writable binary stream, unless instantiated with a Blob object &quot; +
                &quot;that provides a setBinaryStream() implementation&quot;);
        }
    }

    /**
     * Truncates the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt;
     * object represents to be &lt;code&gt;len&lt;/code&gt; bytes in length.
     *
     * @param length the length, in bytes, to which the &lt;code&gt;BLOB&lt;/code&gt;
     *        value that this &lt;code&gt;Blob&lt;/code&gt; object represents should be
     *        truncated
     * @throws SerialException if there is an error accessing the Blob value;
     *     or the length to truncate is greater that the SerialBlob length;
     * if {@code free} had previously been called on this object
     */
    public void truncate(long length) throws SerialException {

        isValid();
        if (length &gt; len) {
           throw new SerialException
              (&quot;Length more than what can be truncated&quot;);
        } else if((int)length == 0) {
             buf = new byte[0];
             len = length;
        } else {
             len = length;
             buf = this.getBytes(1, (int)len);
        }
    }


    /**
     * Returns an
     * &lt;code&gt;InputStream&lt;/code&gt; object that contains a partial
     * {@code Blob} value, starting with the byte specified by pos, which is
     * length bytes in length.
     *
     * @param pos the offset to the first byte of the partial value to be
     * retrieved. The first byte in the {@code Blob} is at position 1
     * @param length the length in bytes of the partial value to be retrieved
     * @return
     * &lt;code&gt;InputStream&lt;/code&gt; through which the partial {@code Blob} value can
     * be read.
     * @throws SQLException if pos is less than 1 or if pos is greater than the
     * number of bytes in the {@code Blob} or if pos + length is greater than
     * the number of bytes in the {@code Blob}
     * @throws SerialException if the {@code free} method had been previously
     * called on this object
     *
     * @since 1.6
     */
    public InputStream getBinaryStream(long pos, long length) throws SQLException {
        isValid();
        if (pos &lt; 1 || pos &gt; this.length()) {
            throw new SerialException(&quot;Invalid position in BLOB object set&quot;);
        }
        if (length &lt; 1 || length &gt; len - pos + 1) {
            throw new SerialException(&quot;length is &lt; 1 or pos + length &gt;&quot;
                    + &quot;total number of bytes&quot;);
        }
        return new ByteArrayInputStream(buf, (int) pos - 1, (int) length);
    }


    /**
     * This method frees the {@code SeriableBlob} object and releases the
     * resources that it holds. The object is invalid once the {@code free}
     * method is called. &lt;p&gt; If {@code free} is called multiple times, the
     * subsequent calls to {@code free} are treated as a no-op. &lt;/P&gt;
     *
     * @throws SQLException if an error occurs releasing the Blob's resources
     * @since 1.6
     */
    public void free() throws SQLException {
        if (buf != null) {
            buf = null;
            if (blob != null) {
                blob.free();
            }
            blob = null;
        }
    }

    /**
     * Compares this SerialBlob to the specified object.  The result is {@code
     * true} if and only if the argument is not {@code null} and is a {@code
     * SerialBlob} object that represents the same sequence of bytes as this
     * object.
     *
     * @param  obj The object to compare this {@code SerialBlob} against
     *
     * @return {@code true} if the given object represents a {@code SerialBlob}
     *          equivalent to this SerialBlob, {@code false} otherwise
     *
     */
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof SerialBlob) {
            SerialBlob sb = (SerialBlob)obj;
            if (this.len == sb.len) {
                return Arrays.equals(buf, sb.buf);
            }
        }
        return false;
    }

    /**
     * Returns a hash code for this {@code SerialBlob}.
     * @return  a hash code value for this object.
     */
    public int hashCode() {
       return ((31 + Arrays.hashCode(buf)) * 31 + (int)len) * 31 + (int)origLen;
    }

    /**
     * Returns a clone of this {@code SerialBlob}. The copy will contain a
     * reference to a clone of the internal byte array, not a reference
     * to the original internal byte array of this {@code SerialBlob} object.
     * The underlying {@code Blob} object will be set to null.
     *
     * @return  a clone of this SerialBlob
     */
    public Object clone() {
        try {
            SerialBlob sb = (SerialBlob) super.clone();
            sb.buf =  (buf != null) ? Arrays.copyOf(buf, (int)len) : null;
            sb.blob = null;
            return sb;
        } catch (CloneNotSupportedException ex) {
            // this shouldn't happen, since we are Cloneable
            throw new InternalError();
        }

    }

    /**
     * readObject is called to restore the state of the SerialBlob from
     * a stream.
     */
    private void readObject(ObjectInputStream s)
            throws IOException, ClassNotFoundException {

        ObjectInputStream.GetField fields = s.readFields();
       byte[] tmp = (byte[])fields.get(&quot;buf&quot;, null);
       if (tmp == null)
           throw new InvalidObjectException(&quot;buf is null and should not be!&quot;);
       buf = tmp.clone();
       len = fields.get(&quot;len&quot;, 0L);
       if (buf.length != len)
           throw new InvalidObjectException(&quot;buf is not the expected size&quot;);
       origLen = fields.get(&quot;origLen&quot;, 0L);
       blob = (Blob) fields.get(&quot;blob&quot;, null);
    }

    /**
     * writeObject is called to save the state of the SerialBlob
     * to a stream.
     */
    private void writeObject(ObjectOutputStream s)
            throws IOException, ClassNotFoundException {

        ObjectOutputStream.PutField fields = s.putFields();
        fields.put(&quot;buf&quot;, buf);
        fields.put(&quot;len&quot;, len);
        fields.put(&quot;origLen&quot;, origLen);
        // Note: this check to see if it is an instance of Serializable
        // is for backwards compatibiity
        fields.put(&quot;blob&quot;, blob instanceof Serializable ? blob : null);
        s.writeFields();
    }

    /**
     * Check to see if this object had previously had its {@code free} method
     * called
     *
     * @throws SerialException
     */
    private void isValid() throws SerialException {
        if (buf == null) {
            throw new SerialException(&quot;Error: You cannot call a method on a &quot;
                    + &quot;SerialBlob instance once free() has been called.&quot;);
        }
    }

    /**
     * The identifier that assists in the serialization of this
     * {@code SerialBlob} object.
     */
    static final long serialVersionUID = -8144641928112860441L;
}
</pre>
</body>
</html>
