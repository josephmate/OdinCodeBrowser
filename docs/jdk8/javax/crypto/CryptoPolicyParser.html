<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.crypto;

import java.io.*;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import static java.util.Locale.ENGLISH;

import java.security.GeneralSecurityException;
import java.security.spec.AlgorithmParameterSpec;
import java.lang.reflect.*;

/**
 * JCE has two pairs of jurisdiction policy files: one represents U.S. export
 * laws, and the other represents the local laws of the country where the
 * JCE will be used.
 *
 * The jurisdiction policy file has the same syntax as JDK policy files except
 * that JCE has new permission classes called javax.crypto.CryptoPermission
 * and javax.crypto.CryptoAllPermission.
 *
 * The format of a permission entry in the jurisdiction policy file is:
 *
 *   permission &lt;crypto permission class name&gt;[, &lt;algorithm name&gt;
 *              [[, &lt;exemption mechanism name&gt;][, &lt;maxKeySize&gt;
 *              [, &lt;AlgrithomParameterSpec class name&gt;, &lt;parameters
 *              for constructing an AlgrithomParameterSpec object&gt;]]]];
 *
 * @author Sharon Liu
 *
 * @see java.security.Permissions
 * @see java.security.spec.AlgorithmParameterSpec
 * @see javax.crypto.CryptoPermission
 * @see javax.crypto.CryptoAllPermission
 * @see javax.crypto.CryptoPermissions
 * @since 1.4
 */

final class CryptoPolicyParser {

    private Vector&lt;GrantEntry&gt; grantEntries;

    // Convenience variables for parsing
    private StreamTokenizer st;
    private int lookahead;

    /**
     * Creates a CryptoPolicyParser object.
     */
    CryptoPolicyParser() {
        grantEntries = new Vector&lt;GrantEntry&gt;();
    }

    /**
     * Reads a policy configuration using a Reader object. &lt;p&gt;
     *
     * @param policy the policy Reader object.
     *
     * @exception ParsingException if the policy configuration
     * contains a syntax error.
     *
     * @exception IOException if an error occurs while reading
     * the policy configuration.
     */

    void read(Reader policy)
        throws ParsingException, IOException
    {
        if (!(policy instanceof BufferedReader)) {
            policy = new BufferedReader(policy);
        }

        /*
         * Configure the stream tokenizer:
         *      Recognize strings between &quot;...&quot;
         *      Don't convert words to lowercase
         *      Recognize both C-style and C++-style comments
         *      Treat end-of-line as white space, not as a token
         */
        st = new StreamTokenizer(policy);

        st.resetSyntax();
        st.wordChars('a', 'z');
        st.wordChars('A', 'Z');
        st.wordChars('.', '.');
        st.wordChars('0', '9');
        st.wordChars('_', '_');
        st.wordChars('$', '$');
        st.wordChars(128 + 32, 255);
        st.whitespaceChars(0, ' ');
        st.commentChar('/');
        st.quoteChar('\'');
        st.quoteChar('&quot;');
        st.lowerCaseMode(false);
        st.ordinaryChar('/');
        st.slashSlashComments(true);
        st.slashStarComments(true);
        st.parseNumbers();

        /*
         * The crypto jurisdiction policy must be consistent. The
         * following hashtable is used for checking consistency.
         */
        Hashtable&lt;String, Vector&lt;String&gt;&gt; processedPermissions = null;

        /*
         * The main parsing loop.  The loop is executed once for each entry
         * in the policy file. The entries are delimited by semicolons. Once
         * we've read in the information for an entry, go ahead and try to
         * add it to the grantEntries.
         */
        lookahead = st.nextToken();
        while (lookahead != StreamTokenizer.TT_EOF) {
            if (peek(&quot;grant&quot;)) {
                GrantEntry ge = parseGrantEntry(processedPermissions);
                if (ge != null)
                    grantEntries.addElement(ge);
            } else {
                throw new ParsingException(st.lineno(), &quot;expected grant &quot; +
                                           &quot;statement&quot;);
            }
            match(&quot;;&quot;);
        }
    }

    /**
     * parse a Grant entry
     */
    private GrantEntry parseGrantEntry(
            Hashtable&lt;String, Vector&lt;String&gt;&gt; processedPermissions)
        throws ParsingException, IOException
    {
        GrantEntry e = new GrantEntry();

        match(&quot;grant&quot;);
        match(&quot;{&quot;);

        while(!peek(&quot;}&quot;)) {
            if (peek(&quot;Permission&quot;)) {
                CryptoPermissionEntry pe =
                    parsePermissionEntry(processedPermissions);
                e.add(pe);
                match(&quot;;&quot;);
            } else {
                throw new
                    ParsingException(st.lineno(), &quot;expected permission entry&quot;);
            }
        }
        match(&quot;}&quot;);

        return e;
    }

    /**
     * parse a CryptoPermission entry
     */
    private CryptoPermissionEntry parsePermissionEntry(
            Hashtable&lt;String, Vector&lt;String&gt;&gt; processedPermissions)
        throws ParsingException, IOException
    {
        CryptoPermissionEntry e = new CryptoPermissionEntry();

        match(&quot;Permission&quot;);
        e.cryptoPermission = match(&quot;permission type&quot;);

        if (e.cryptoPermission.equals(&quot;javax.crypto.CryptoAllPermission&quot;)) {
            // Done with the CryptoAllPermission entry.
            e.alg = CryptoAllPermission.ALG_NAME;
            e.maxKeySize = Integer.MAX_VALUE;
            return e;
        }

        // Should see the algorithm name.
        if (peek(&quot;\&quot;&quot;)) {
            // Algorithm name - always convert to upper case after parsing.
            e.alg = match(&quot;quoted string&quot;).toUpperCase(ENGLISH);
        } else {
            // The algorithm name can be a wildcard.
            if (peek(&quot;*&quot;)) {
                match(&quot;*&quot;);
                e.alg = CryptoPermission.ALG_NAME_WILDCARD;
            } else {
                throw new ParsingException(st.lineno(),
                                           &quot;Missing the algorithm name&quot;);
            }
        }

        peekAndMatch(&quot;,&quot;);

        // May see the exemption mechanism name.
        if (peek(&quot;\&quot;&quot;)) {
            // Exemption mechanism name - convert to upper case too.
            e.exemptionMechanism = match(&quot;quoted string&quot;).toUpperCase(ENGLISH);
        }

        peekAndMatch(&quot;,&quot;);

        // Check whether this entry is consistent with other permission entries
        // that have been read.
        if (!isConsistent(e.alg, e.exemptionMechanism, processedPermissions)) {
            throw new ParsingException(st.lineno(), &quot;Inconsistent policy&quot;);
        }

        // Should see the maxKeySize if not at the end of this entry yet.
        if (peek(&quot;number&quot;)) {
            e.maxKeySize = match();
        } else {
            if (peek(&quot;*&quot;)) {
                match(&quot;*&quot;);
                e.maxKeySize = Integer.MAX_VALUE;
            } else {
                if (!peek(&quot;;&quot;)) {
                    throw new ParsingException(st.lineno(),
                                               &quot;Missing the maximum &quot; +
                                               &quot;allowable key size&quot;);
                } else {
                    // At the end of this permission entry
                    e.maxKeySize = Integer.MAX_VALUE;
                }
            }
        }

        peekAndMatch(&quot;,&quot;);

        // May see an AlgorithmParameterSpec class name.
        if (peek(&quot;\&quot;&quot;)) {
            // AlgorithmParameterSpec class name.
            String algParamSpecClassName = match(&quot;quoted string&quot;);

            Vector&lt;Integer&gt; paramsV = new Vector&lt;&gt;(1);
            while (peek(&quot;,&quot;)) {
                match(&quot;,&quot;);
                if (peek(&quot;number&quot;)) {
                    paramsV.addElement(new Integer(match()));
                } else {
                    if (peek(&quot;*&quot;)) {
                        match(&quot;*&quot;);
                        paramsV.addElement(new Integer(Integer.MAX_VALUE));
                    } else {
                        throw new ParsingException(st.lineno(),
                                                   &quot;Expecting an integer&quot;);
                    }
                }
            }

            Integer[] params = new Integer[paramsV.size()];
            paramsV.copyInto(params);

            e.checkParam = true;
            e.algParamSpec = getInstance(algParamSpecClassName, params);
        }

        return e;
    }

    private static final AlgorithmParameterSpec getInstance(String type,
                                                            Integer[] params)
        throws ParsingException
    {
        AlgorithmParameterSpec ret = null;

        try {
            Class&lt;?&gt; apsClass = Class.forName(type);
            Class&lt;?&gt;[] paramClasses = new Class&lt;?&gt;[params.length];

            for (int i = 0; i &lt; params.length; i++) {
                paramClasses[i] = int.class;
            }

            Constructor&lt;?&gt; c = apsClass.getConstructor(paramClasses);
            ret = (AlgorithmParameterSpec) c.newInstance((Object[]) params);
        } catch (Exception e) {
            throw new ParsingException(&quot;Cannot call the constructor of &quot; +
                                       type + e);
        }
        return ret;
    }


    private boolean peekAndMatch(String expect)
        throws ParsingException, IOException
    {
        if (peek(expect)) {
            match(expect);
            return true;
        }
        return false;
    }

    private boolean peek(String expect) {
        boolean found = false;

        switch (lookahead) {

        case StreamTokenizer.TT_WORD:
            if (expect.equalsIgnoreCase(st.sval))
                found = true;
            break;
        case StreamTokenizer.TT_NUMBER:
            if (expect.equalsIgnoreCase(&quot;number&quot;)) {
                found = true;
            }
            break;
        case ',':
            if (expect.equals(&quot;,&quot;))
                found = true;
            break;
        case '{':
            if (expect.equals(&quot;{&quot;))
                found = true;
            break;
        case '}':
            if (expect.equals(&quot;}&quot;))
                found = true;
            break;
        case '&quot;':
            if (expect.equals(&quot;\&quot;&quot;))
                found = true;
            break;
        case '*':
            if (expect.equals(&quot;*&quot;))
                found = true;
            break;
        case ';':
            if (expect.equals(&quot;;&quot;))
                found = true;
            break;
        default:
            break;
        }
        return found;
    }

    /**
     * Excepts to match a non-negative number.
     */
    private int match()
        throws ParsingException, IOException
    {
        int value = -1;
        int lineno = st.lineno();
        String sValue = null;

        switch (lookahead) {
        case StreamTokenizer.TT_NUMBER:
            value = (int)st.nval;
            if (value &lt; 0) {
                sValue = String.valueOf(st.nval);
            }
            lookahead = st.nextToken();
            break;
        default:
            sValue = st.sval;
            break;
        }
        if (value &lt;= 0) {
            throw new ParsingException(lineno, &quot;a non-negative number&quot;,
                                       sValue);
        }
        return value;
    }

    private String match(String expect)
        throws ParsingException, IOException
    {
        String value = null;

        switch (lookahead) {
        case StreamTokenizer.TT_NUMBER:
            throw new ParsingException(st.lineno(), expect,
                                       &quot;number &quot;+String.valueOf(st.nval));
        case StreamTokenizer.TT_EOF:
           throw new ParsingException(&quot;expected &quot;+expect+&quot;, read end of file&quot;);
        case StreamTokenizer.TT_WORD:
            if (expect.equalsIgnoreCase(st.sval)) {
                lookahead = st.nextToken();
            }
            else if (expect.equalsIgnoreCase(&quot;permission type&quot;)) {
                value = st.sval;
                lookahead = st.nextToken();
            }
            else
                throw new ParsingException(st.lineno(), expect, st.sval);
            break;
        case '&quot;':
            if (expect.equalsIgnoreCase(&quot;quoted string&quot;)) {
                value = st.sval;
                lookahead = st.nextToken();
            } else if (expect.equalsIgnoreCase(&quot;permission type&quot;)) {
                value = st.sval;
                lookahead = st.nextToken();
            }
            else
                throw new ParsingException(st.lineno(), expect, st.sval);
            break;
        case ',':
            if (expect.equals(&quot;,&quot;))
                lookahead = st.nextToken();
            else
                throw new ParsingException(st.lineno(), expect, &quot;,&quot;);
            break;
        case '{':
            if (expect.equals(&quot;{&quot;))
                lookahead = st.nextToken();
            else
                throw new ParsingException(st.lineno(), expect, &quot;{&quot;);
            break;
        case '}':
            if (expect.equals(&quot;}&quot;))
                lookahead = st.nextToken();
            else
                throw new ParsingException(st.lineno(), expect, &quot;}&quot;);
            break;
        case ';':
            if (expect.equals(&quot;;&quot;))
                lookahead = st.nextToken();
            else
                throw new ParsingException(st.lineno(), expect, &quot;;&quot;);
            break;
        case '*':
            if (expect.equals(&quot;*&quot;))
                lookahead = st.nextToken();
            else
                throw new ParsingException(st.lineno(), expect, &quot;*&quot;);
            break;
        default:
            throw new ParsingException(st.lineno(), expect,
                               new String(new char[] {(char)lookahead}));
        }
        return value;
    }

    CryptoPermission[] getPermissions() {
        Vector&lt;CryptoPermission&gt; result = new Vector&lt;&gt;();

        Enumeration&lt;GrantEntry&gt; grantEnum = grantEntries.elements();
        while (grantEnum.hasMoreElements()) {
            GrantEntry ge = grantEnum.nextElement();
            Enumeration&lt;CryptoPermissionEntry&gt; permEnum =
                    ge.permissionElements();
            while (permEnum.hasMoreElements()) {
                CryptoPermissionEntry pe = permEnum.nextElement();
                if (pe.cryptoPermission.equals(
                                        &quot;javax.crypto.CryptoAllPermission&quot;)) {
                    result.addElement(CryptoAllPermission.INSTANCE);
                } else {
                    if (pe.checkParam) {
                        result.addElement(new CryptoPermission(
                                                pe.alg,
                                                pe.maxKeySize,
                                                pe.algParamSpec,
                                                pe.exemptionMechanism));
                    } else {
                        result.addElement(new CryptoPermission(
                                                pe.alg,
                                                pe.maxKeySize,
                                                pe.exemptionMechanism));
                    }
                }
            }
        }

        CryptoPermission[] ret = new CryptoPermission[result.size()];
        result.copyInto(ret);

        return ret;
    }

    private boolean isConsistent(String alg, String exemptionMechanism,
            Hashtable&lt;String, Vector&lt;String&gt;&gt; processedPermissions) {
        String thisExemptionMechanism =
            exemptionMechanism == null ? &quot;none&quot; : exemptionMechanism;

        if (processedPermissions == null) {
            processedPermissions = new Hashtable&lt;String, Vector&lt;String&gt;&gt;();
            Vector&lt;String&gt; exemptionMechanisms = new Vector&lt;&gt;(1);
            exemptionMechanisms.addElement(thisExemptionMechanism);
            processedPermissions.put(alg, exemptionMechanisms);
            return true;
        }

        if (processedPermissions.containsKey(CryptoAllPermission.ALG_NAME)) {
            return false;
        }

        Vector&lt;String&gt; exemptionMechanisms;

        if (processedPermissions.containsKey(alg)) {
            exemptionMechanisms = processedPermissions.get(alg);
            if (exemptionMechanisms.contains(thisExemptionMechanism)) {
                return false;
            }
        } else {
            exemptionMechanisms = new Vector&lt;String&gt;(1);
        }

        exemptionMechanisms.addElement(thisExemptionMechanism);
        processedPermissions.put(alg, exemptionMechanisms);
        return true;
    }

    /**
     * Each grant entry in the policy configuration file is  represented by a
     * GrantEntry object.  &lt;p&gt;
     *
     * &lt;p&gt;
     * For example, the entry
     * &lt;pre&gt;
     *      grant {
     *       permission javax.crypto.CryptoPermission &quot;DES&quot;, 56;
     *      };
     *
     * &lt;/pre&gt;
     * is represented internally
     * &lt;pre&gt;
     *
     * pe = new CryptoPermissionEntry(&quot;javax.crypto.CryptoPermission&quot;,
     *                           &quot;DES&quot;, 56);
     *
     * ge = new GrantEntry();
     *
     * ge.add(pe);
     *
     * &lt;/pre&gt;
     *
     * @see java.security.Permission
     * @see javax.crypto.CryptoPermission
     * @see javax.crypto.CryptoPermissions
     */

    private static class GrantEntry {

        private Vector&lt;CryptoPermissionEntry&gt; permissionEntries;

        GrantEntry() {
            permissionEntries = new Vector&lt;CryptoPermissionEntry&gt;();
        }

        void add(CryptoPermissionEntry pe)
        {
            permissionEntries.addElement(pe);
        }

        boolean remove(CryptoPermissionEntry pe)
        {
            return permissionEntries.removeElement(pe);
        }

        boolean contains(CryptoPermissionEntry pe)
        {
            return permissionEntries.contains(pe);
        }

        /**
         * Enumerate all the permission entries in this GrantEntry.
         */
        Enumeration&lt;CryptoPermissionEntry&gt; permissionElements(){
            return permissionEntries.elements();
        }

    }

    /**
     * Each crypto permission entry in the policy configuration file is
     * represented by a CryptoPermissionEntry object.  &lt;p&gt;
     *
     * &lt;p&gt;
     * For example, the entry
     * &lt;pre&gt;
     *     permission javax.crypto.CryptoPermission &quot;DES&quot;, 56;
     * &lt;/pre&gt;
     * is represented internally
     * &lt;pre&gt;
     *
     * pe = new CryptoPermissionEntry(&quot;javax.crypto.cryptoPermission&quot;,
     *                           &quot;DES&quot;, 56);
     * &lt;/pre&gt;
     *
     * @see java.security.Permissions
     * @see javax.crypto.CryptoPermission
     * @see javax.crypto.CryptoAllPermission
     */

    private static class CryptoPermissionEntry {

        String cryptoPermission;
        String alg;
        String exemptionMechanism;
        int maxKeySize;
        boolean checkParam;
        AlgorithmParameterSpec algParamSpec;

        CryptoPermissionEntry() {
            // Set default values.
            maxKeySize = 0;
            alg = null;
            exemptionMechanism = null;
            checkParam = false;
            algParamSpec = null;
        }

        /**
         * Calculates a hash code value for the object.  Objects
         * which are equal will also have the same hashcode.
         */
        public int hashCode() {
            int retval = cryptoPermission.hashCode();
            if (alg != null) retval ^= alg.hashCode();
            if (exemptionMechanism != null) {
                retval ^= exemptionMechanism.hashCode();
            }
            retval ^= maxKeySize;
            if (checkParam) retval ^= 100;
            if (algParamSpec != null) {
                retval ^= algParamSpec.hashCode();
            }
            return retval;
        }

        public boolean equals(Object obj) {
            if (obj == this)
                return true;

            if (!(obj instanceof CryptoPermissionEntry))
                return false;

            CryptoPermissionEntry that = (CryptoPermissionEntry) obj;

            if (this.cryptoPermission == null) {
                if (that.cryptoPermission != null) return false;
            } else {
                if (!this.cryptoPermission.equals(
                                                 that.cryptoPermission))
                    return false;
            }

            if (this.alg == null) {
                if (that.alg != null) return false;
            } else {
                if (!this.alg.equalsIgnoreCase(that.alg))
                    return false;
            }

            if (!(this.maxKeySize == that.maxKeySize)) return false;

            if (this.checkParam != that.checkParam) return false;

            if (this.algParamSpec == null) {
                if (that.algParamSpec != null) return false;
            } else {
                if (!this.algParamSpec.equals(that.algParamSpec))
                    return false;
            }

            // everything matched -- the 2 objects are equal
            return true;
        }
    }

    static final class ParsingException extends GeneralSecurityException {

        private static final long serialVersionUID = 7147241245566588374L;

        /**
         * Constructs a ParsingException with the specified
         * detail message.
         * @param msg the detail message.
         */
        ParsingException(String msg) {
            super(msg);
        }

        ParsingException(int line, String msg) {
            super(&quot;line &quot; + line + &quot;: &quot; + msg);
        }

        ParsingException(int line, String expect, String actual) {
            super(&quot;line &quot;+line+&quot;: expected '&quot;+expect+&quot;', found '&quot;+actual+&quot;'&quot;);
        }
    }
}
</pre>
</body>
</html>
