<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.crypto.spec;

import java.security.spec.KeySpec;

/**
 * A user-chosen password that can be used with password-based encryption
 * (&lt;i&gt;PBE&lt;/i&gt;).
 *
 * &lt;p&gt;The password can be viewed as some kind of raw key material, from which
 * the encryption mechanism that uses it derives a cryptographic key.
 *
 * &lt;p&gt;Different PBE mechanisms may consume different bits of each password
 * character. For example, the PBE mechanism defined in
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2898.txt&quot;&gt;
 * PKCS #5&lt;/a&gt; looks at only the low order 8 bits of each character, whereas
 * PKCS #12 looks at all 16 bits of each character.
 *
 * &lt;p&gt;You convert the password characters to a PBE key by creating an
 * instance of the appropriate secret-key factory. For example, a secret-key
 * factory for PKCS #5 will construct a PBE key from only the low order 8 bits
 * of each password character, whereas a secret-key factory for PKCS #12 will
 * take all 16 bits of each character.
 *
 * &lt;p&gt;Also note that this class stores passwords as char arrays instead of
 * &lt;code&gt;String&lt;/code&gt; objects (which would seem more logical), because the
 * String class is immutable and there is no way to overwrite its
 * internal value when the password stored in it is no longer needed. Hence,
 * this class requests the password as a char array, so it can be overwritten
 * when done.
 *
 * @author Jan Luehe
 * @author Valerie Peng
 *
 * @see javax.crypto.SecretKeyFactory
 * @see PBEParameterSpec
 * @since 1.4
 */
public class PBEKeySpec implements KeySpec {

    private char[] password;
    private byte[] salt = null;
    private int iterationCount = 0;
    private int keyLength = 0;

    /**
     * Constructor that takes a password. An empty char[] is used if
     * null is specified.
     *
     * &lt;p&gt; Note: &lt;code&gt;password&lt;/code&gt; is cloned before it is stored in
     * the new &lt;code&gt;PBEKeySpec&lt;/code&gt; object.
     *
     * @param password the password.
     */
    public PBEKeySpec(char[] password) {
        if ((password == null) || (password.length == 0)) {
            this.password = new char[0];
        } else {
            this.password = password.clone();
        }
    }


    /**
     * Constructor that takes a password, salt, iteration count, and
     * to-be-derived key length for generating PBEKey of variable-key-size
     * PBE ciphers.  An empty char[] is used if null is specified for
     * &lt;code&gt;password&lt;/code&gt;.
     *
     * &lt;p&gt; Note: the &lt;code&gt;password&lt;/code&gt; and &lt;code&gt;salt&lt;/code&gt;
     * are cloned before they are stored in
     * the new &lt;code&gt;PBEKeySpec&lt;/code&gt; object.
     *
     * @param password the password.
     * @param salt the salt.
     * @param iterationCount the iteration count.
     * @param keyLength the to-be-derived key length.
     * @exception NullPointerException if &lt;code&gt;salt&lt;/code&gt; is null.
     * @exception IllegalArgumentException if &lt;code&gt;salt&lt;/code&gt; is empty,
     * i.e. 0-length, &lt;code&gt;iterationCount&lt;/code&gt; or
     * &lt;code&gt;keyLength&lt;/code&gt; is not positive.
     */
    public PBEKeySpec(char[] password, byte[] salt, int iterationCount,
        int keyLength) {
        if ((password == null) || (password.length == 0)) {
            this.password = new char[0];
        } else {
            this.password = password.clone();
        }
        if (salt == null) {
            throw new NullPointerException(&quot;the salt parameter &quot; +
                                            &quot;must be non-null&quot;);
        } else if (salt.length == 0) {
            throw new IllegalArgumentException(&quot;the salt parameter &quot; +
                                                &quot;must not be empty&quot;);
        } else {
            this.salt = salt.clone();
        }
        if (iterationCount&lt;=0) {
            throw new IllegalArgumentException(&quot;invalid iterationCount value&quot;);
        }
        if (keyLength&lt;=0) {
            throw new IllegalArgumentException(&quot;invalid keyLength value&quot;);
        }
        this.iterationCount = iterationCount;
        this.keyLength = keyLength;
    }


    /**
     * Constructor that takes a password, salt, iteration count for
     * generating PBEKey of fixed-key-size PBE ciphers. An empty
     * char[] is used if null is specified for &lt;code&gt;password&lt;/code&gt;.
     *
     * &lt;p&gt; Note: the &lt;code&gt;password&lt;/code&gt; and &lt;code&gt;salt&lt;/code&gt;
     * are cloned before they are stored in the new
     * &lt;code&gt;PBEKeySpec&lt;/code&gt; object.
     *
     * @param password the password.
     * @param salt the salt.
     * @param iterationCount the iteration count.
     * @exception NullPointerException if &lt;code&gt;salt&lt;/code&gt; is null.
     * @exception IllegalArgumentException if &lt;code&gt;salt&lt;/code&gt; is empty,
     * i.e. 0-length, or &lt;code&gt;iterationCount&lt;/code&gt; is not positive.
     */
    public PBEKeySpec(char[] password, byte[] salt, int iterationCount) {
        if ((password == null) || (password.length == 0)) {
            this.password = new char[0];
        } else {
            this.password = password.clone();
        }
        if (salt == null) {
            throw new NullPointerException(&quot;the salt parameter &quot; +
                                            &quot;must be non-null&quot;);
        } else if (salt.length == 0) {
            throw new IllegalArgumentException(&quot;the salt parameter &quot; +
                                                &quot;must not be empty&quot;);
        } else {
            this.salt = salt.clone();
        }
        if (iterationCount&lt;=0) {
            throw new IllegalArgumentException(&quot;invalid iterationCount value&quot;);
        }
        this.iterationCount = iterationCount;
    }

    /**
     * Clears the internal copy of the password.
     *
     */
    public final void clearPassword() {
        if (password != null) {
            for (int i = 0; i &lt; password.length; i++) {
                password[i] = ' ';
            }
            password = null;
        }
    }

    /**
     * Returns a copy of the password.
     *
     * &lt;p&gt; Note: this method returns a copy of the password. It is
     * the caller's responsibility to zero out the password information after
     * it is no longer needed.
     *
     * @exception IllegalStateException if password has been cleared by
     * calling &lt;code&gt;clearPassword&lt;/code&gt; method.
     * @return the password.
     */
    public final char[] getPassword() {
        if (password == null) {
            throw new IllegalStateException(&quot;password has been cleared&quot;);
        }
        return password.clone();
    }

    /**
     * Returns a copy of the salt or null if not specified.
     *
     * &lt;p&gt; Note: this method should return a copy of the salt. It is
     * the caller's responsibility to zero out the salt information after
     * it is no longer needed.
     *
     * @return the salt.
     */
    public final byte[] getSalt() {
        if (salt != null) {
            return salt.clone();
        } else {
            return null;
        }
    }

    /**
     * Returns the iteration count or 0 if not specified.
     *
     * @return the iteration count.
     */
    public final int getIterationCount() {
        return iterationCount;
    }

    /**
     * Returns the to-be-derived key length or 0 if not specified.
     *
     * &lt;p&gt; Note: this is used to indicate the preference on key length
     * for variable-key-size ciphers. The actual key size depends on
     * each provider's implementation.
     *
     * @return the to-be-derived key length.
     */
    public final int getKeyLength() {
        return keyLength;
    }
}
</pre>
</body>
</html>
