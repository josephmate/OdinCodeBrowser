<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2002, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.security.Permission;

/**
 * &lt;p&gt;Permission controlling access to MBeanServer operations.  If a
 * security manager has been set using {@link
 * System#setSecurityManager}, most operations on the MBean Server
 * require that the caller's permissions imply an MBeanPermission
 * appropriate for the operation.  This is described in detail in the
 * documentation for the {@link MBeanServer} interface.&lt;/p&gt;
 *
 * &lt;p&gt;As with other {@link Permission} objects, an MBeanPermission can
 * represent either a permission that you &lt;em&gt;have&lt;/em&gt; or a
 * permission that you &lt;em&gt;need&lt;/em&gt;.  When a sensitive operation is
 * being checked for permission, an MBeanPermission is constructed
 * representing the permission you need.  The operation is only
 * allowed if the permissions you have {@linkplain #implies imply} the
 * permission you need.&lt;/p&gt;
 *
 * &lt;p&gt;An MBeanPermission contains four items of information:&lt;/p&gt;
 *
 * &lt;ul&gt;
 *
 * &lt;li&gt;&lt;p&gt;The &lt;em&gt;action&lt;/em&gt;.  For a permission you need,
 * this is one of the actions in the list &lt;a
 * href=&quot;#action-list&quot;&gt;below&lt;/a&gt;.  For a permission you have, this is
 * a comma-separated list of those actions, or &lt;code&gt;*&lt;/code&gt;,
 * representing all actions.&lt;/p&gt;
 *
 * &lt;p&gt;The action is returned by {@link #getActions()}.&lt;/p&gt;
 *
 * &lt;li&gt;&lt;p&gt;The &lt;em&gt;class name&lt;/em&gt;.&lt;/p&gt;
 *
 * &lt;p&gt;For a permission you need, this is the class name of an MBean
 * you are accessing, as returned by {@link
 * MBeanServer#getMBeanInfo(ObjectName)
 * MBeanServer.getMBeanInfo(name)}.{@link MBeanInfo#getClassName()
 * getClassName()}.  Certain operations do not reference a class name,
 * in which case the class name is null.&lt;/p&gt;
 *
 * &lt;p&gt;For a permission you have, this is either empty or a &lt;em&gt;class
 * name pattern&lt;/em&gt;.  A class name pattern is a string following the
 * Java conventions for dot-separated class names.  It may end with
 * &quot;&lt;code&gt;.*&lt;/code&gt;&quot; meaning that the permission grants access to any
 * class that begins with the string preceding &quot;&lt;code&gt;.*&lt;/code&gt;&quot;.  For
 * instance, &quot;&lt;code&gt;javax.management.*&lt;/code&gt;&quot; grants access to
 * &lt;code&gt;javax.management.MBeanServerDelegate&lt;/code&gt; and
 * &lt;code&gt;javax.management.timer.Timer&lt;/code&gt;, among other classes.&lt;/p&gt;
 *
 * &lt;p&gt;A class name pattern can also be empty or the single character
 * &quot;&lt;code&gt;*&lt;/code&gt;&quot;, both of which grant access to any class.&lt;/p&gt;
 *
 * &lt;li&gt;&lt;p&gt;The &lt;em&gt;member&lt;/em&gt;.&lt;/p&gt;
 *
 * &lt;p&gt;For a permission you need, this is the name of the attribute or
 * operation you are accessing.  For operations that do not reference
 * an attribute or operation, the member is null.&lt;/p&gt;
 *
 * &lt;p&gt;For a permission you have, this is either the name of an attribute
 * or operation you can access, or it is empty or the single character
 * &quot;&lt;code&gt;*&lt;/code&gt;&quot;, both of which grant access to any member.&lt;/p&gt;
 *
 * &lt;li id=&quot;MBeanName&quot;&gt;&lt;p&gt;The &lt;em&gt;object name&lt;/em&gt;.&lt;/p&gt;
 *
 * &lt;p&gt;For a permission you need, this is the {@link ObjectName} of the
 * MBean you are accessing.  For operations that do not reference a
 * single MBean, it is null.  It is never an object name pattern.&lt;/p&gt;
 *
 * &lt;p&gt;For a permission you have, this is the {@link ObjectName} of the
 * MBean or MBeans you can access.  It may be an object name pattern
 * to grant access to all MBeans whose names match the pattern.  It
 * may also be empty, which grants access to all MBeans whatever their
 * name.&lt;/p&gt;
 *
 * &lt;/ul&gt;
 *
 * &lt;p&gt;If you have an MBeanPermission, it allows operations only if all
 * four of the items match.&lt;/p&gt;
 *
 * &lt;p&gt;The class name, member, and object name can be written together
 * as a single string, which is the &lt;em&gt;name&lt;/em&gt; of this permission.
 * The name of the permission is the string returned by {@link
 * Permission#getName() getName()}.  The format of the string is:&lt;/p&gt;
 *
 * &lt;blockquote&gt;
 * &lt;code&gt;className#member[objectName]&lt;/code&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt;The object name is written using the usual syntax for {@link
 * ObjectName}.  It may contain any legal characters, including
 * &lt;code&gt;]&lt;/code&gt;.  It is terminated by a &lt;code&gt;]&lt;/code&gt; character
 * that is the last character in the string.&lt;/p&gt;
 *
 * &lt;p&gt;One or more of the &lt;code&gt;className&lt;/code&gt;, &lt;code&gt;member&lt;/code&gt;,
 * or &lt;code&gt;objectName&lt;/code&gt; may be omitted.  If the
 * &lt;code&gt;member&lt;/code&gt; is omitted, the &lt;code&gt;#&lt;/code&gt; may be too (but
 * does not have to be).  If the &lt;code&gt;objectName&lt;/code&gt; is omitted,
 * the &lt;code&gt;[]&lt;/code&gt; may be too (but does not have to be).  It is
 * not legal to omit all three items, that is to have a &lt;em&gt;name&lt;/em&gt;
 * that is the empty string.&lt;/p&gt;
 *
 * &lt;p&gt;One or more of the &lt;code&gt;className&lt;/code&gt;, &lt;code&gt;member&lt;/code&gt;,
 * or &lt;code&gt;objectName&lt;/code&gt; may be the character &quot;&lt;code&gt;-&lt;/code&gt;&quot;,
 * which is equivalent to a null value.  A null value is implied by
 * any value (including another null value) but does not imply any
 * other value.&lt;/p&gt;
 *
 * &lt;p&gt;&lt;a name=&quot;action-list&quot;&gt;The possible actions are these:&lt;/a&gt;&lt;/p&gt;
 *
 * &lt;ul&gt;
 * &lt;li&gt;addNotificationListener&lt;/li&gt;
 * &lt;li&gt;getAttribute&lt;/li&gt;
 * &lt;li&gt;getClassLoader&lt;/li&gt;
 * &lt;li&gt;getClassLoaderFor&lt;/li&gt;
 * &lt;li&gt;getClassLoaderRepository&lt;/li&gt;
 * &lt;li&gt;getDomains&lt;/li&gt;
 * &lt;li&gt;getMBeanInfo&lt;/li&gt;
 * &lt;li&gt;getObjectInstance&lt;/li&gt;
 * &lt;li&gt;instantiate&lt;/li&gt;
 * &lt;li&gt;invoke&lt;/li&gt;
 * &lt;li&gt;isInstanceOf&lt;/li&gt;
 * &lt;li&gt;queryMBeans&lt;/li&gt;
 * &lt;li&gt;queryNames&lt;/li&gt;
 * &lt;li&gt;registerMBean&lt;/li&gt;
 * &lt;li&gt;removeNotificationListener&lt;/li&gt;
 * &lt;li&gt;setAttribute&lt;/li&gt;
 * &lt;li&gt;unregisterMBean&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;In a comma-separated list of actions, spaces are allowed before
 * and after each action.&lt;/p&gt;
 *
 * @since 1.5
 */
public class MBeanPermission extends Permission {

    private static final long serialVersionUID = -2416928705275160661L;

    /**
     * Actions list.
     */
    private static final int AddNotificationListener    = 0x00001;
    private static final int GetAttribute               = 0x00002;
    private static final int GetClassLoader             = 0x00004;
    private static final int GetClassLoaderFor          = 0x00008;
    private static final int GetClassLoaderRepository   = 0x00010;
    private static final int GetDomains                 = 0x00020;
    private static final int GetMBeanInfo               = 0x00040;
    private static final int GetObjectInstance          = 0x00080;
    private static final int Instantiate                = 0x00100;
    private static final int Invoke                     = 0x00200;
    private static final int IsInstanceOf               = 0x00400;
    private static final int QueryMBeans                = 0x00800;
    private static final int QueryNames                 = 0x01000;
    private static final int RegisterMBean              = 0x02000;
    private static final int RemoveNotificationListener = 0x04000;
    private static final int SetAttribute               = 0x08000;
    private static final int UnregisterMBean            = 0x10000;

    /**
     * No actions.
     */
    private static final int NONE = 0x00000;

    /**
     * All actions.
     */
    private static final int ALL =
        AddNotificationListener    |
        GetAttribute               |
        GetClassLoader             |
        GetClassLoaderFor          |
        GetClassLoaderRepository   |
        GetDomains                 |
        GetMBeanInfo               |
        GetObjectInstance          |
        Instantiate                |
        Invoke                     |
        IsInstanceOf               |
        QueryMBeans                |
        QueryNames                 |
        RegisterMBean              |
        RemoveNotificationListener |
        SetAttribute               |
        UnregisterMBean;

    /**
     * The actions string.
     */
    private String actions;

    /**
     * The actions mask.
     */
    private transient int mask;

    /**
     * The classname prefix that must match.  If null, is implied by any
     * classNamePrefix but does not imply any non-null classNamePrefix.
     */
    private transient String classNamePrefix;

    /**
     * True if classNamePrefix must match exactly.  Otherwise, the
     * className being matched must start with classNamePrefix.
     */
    private transient boolean classNameExactMatch;

    /**
     * The member that must match.  If null, is implied by any member
     * but does not imply any non-null member.
     */
    private transient String member;

    /**
     * The objectName that must match.  If null, is implied by any
     * objectName but does not imply any non-null objectName.
     */
    private transient ObjectName objectName;

    /**
     * Parse &lt;code&gt;actions&lt;/code&gt; parameter.
     */
    private void parseActions() {

        int mask;

        if (actions == null)
            throw new IllegalArgumentException(&quot;MBeanPermission: &quot; +
                                               &quot;actions can't be null&quot;);
        if (actions.equals(&quot;&quot;))
            throw new IllegalArgumentException(&quot;MBeanPermission: &quot; +
                                               &quot;actions can't be empty&quot;);

        mask = getMask(actions);

        if ((mask &amp; ALL) != mask)
            throw new IllegalArgumentException(&quot;Invalid actions mask&quot;);
        if (mask == NONE)
            throw new IllegalArgumentException(&quot;Invalid actions mask&quot;);
        this.mask = mask;
    }

    /**
     * Parse &lt;code&gt;name&lt;/code&gt; parameter.
     */
    private void parseName() {
        String name = getName();

        if (name == null)
            throw new IllegalArgumentException(&quot;MBeanPermission name &quot; +
                                               &quot;cannot be null&quot;);

        if (name.equals(&quot;&quot;))
            throw new IllegalArgumentException(&quot;MBeanPermission name &quot; +
                                               &quot;cannot be empty&quot;);

        /* The name looks like &quot;class#member[objectname]&quot;.  We subtract
           elements from the right as we parse, so after parsing the
           objectname we have &quot;class#member&quot; and after parsing the
           member we have &quot;class&quot;.  Each element is optional.  */

        // Parse ObjectName

        int openingBracket = name.indexOf(&quot;[&quot;);
        if (openingBracket == -1) {
            // If &quot;[on]&quot; missing then ObjectName(&quot;*:*&quot;)
            //
            objectName = ObjectName.WILDCARD;
        } else {
            if (!name.endsWith(&quot;]&quot;)) {
                throw new IllegalArgumentException(&quot;MBeanPermission: &quot; +
                                                   &quot;The ObjectName in the &quot; +
                                                   &quot;target name must be &quot; +
                                                   &quot;included in square &quot; +
                                                   &quot;brackets&quot;);
            } else {
                // Create ObjectName
                //
                try {
                    // If &quot;[]&quot; then ObjectName(&quot;*:*&quot;)
                    //
                    String on = name.substring(openingBracket + 1,
                                               name.length() - 1);
                    if (on.equals(&quot;&quot;))
                        objectName = ObjectName.WILDCARD;
                    else if (on.equals(&quot;-&quot;))
                        objectName = null;
                    else
                        objectName = new ObjectName(on);
                } catch (MalformedObjectNameException e) {
                    throw new IllegalArgumentException(&quot;MBeanPermission: &quot; +
                                                       &quot;The target name does &quot; +
                                                       &quot;not specify a valid &quot; +
                                                       &quot;ObjectName&quot;, e);
                }
            }

            name = name.substring(0, openingBracket);
        }

        // Parse member

        int poundSign = name.indexOf(&quot;#&quot;);

        if (poundSign == -1)
            setMember(&quot;*&quot;);
        else {
            String memberName = name.substring(poundSign + 1);
            setMember(memberName);
            name = name.substring(0, poundSign);
        }

        // Parse className

        setClassName(name);
    }

    /**
     * Assign fields based on className, member, and objectName
     * parameters.
     */
    private void initName(String className, String member,
                          ObjectName objectName) {
        setClassName(className);
        setMember(member);
        this.objectName = objectName;
    }

    private void setClassName(String className) {
        if (className == null || className.equals(&quot;-&quot;)) {
            classNamePrefix = null;
            classNameExactMatch = false;
        } else if (className.equals(&quot;&quot;) || className.equals(&quot;*&quot;)) {
            classNamePrefix = &quot;&quot;;
            classNameExactMatch = false;
        } else if (className.endsWith(&quot;.*&quot;)) {
            // Note that we include the &quot;.&quot; in the required prefix
            classNamePrefix = className.substring(0, className.length() - 1);
            classNameExactMatch = false;
        } else {
            classNamePrefix = className;
            classNameExactMatch = true;
        }
    }

    private void setMember(String member) {
        if (member == null || member.equals(&quot;-&quot;))
            this.member = null;
        else if (member.equals(&quot;&quot;))
            this.member = &quot;*&quot;;
        else
            this.member = member;
    }

    /**
     * &lt;p&gt;Create a new MBeanPermission object with the specified target name
     * and actions.&lt;/p&gt;
     *
     * &lt;p&gt;The target name is of the form
     * &quot;&lt;code&gt;className#member[objectName]&lt;/code&gt;&quot; where each part is
     * optional.  It must not be empty or null.&lt;/p&gt;
     *
     * &lt;p&gt;The actions parameter contains a comma-separated list of the
     * desired actions granted on the target name.  It must not be
     * empty or null.&lt;/p&gt;
     *
     * @param name the triplet &quot;className#member[objectName]&quot;.
     * @param actions the action string.
     *
     * @exception IllegalArgumentException if the &lt;code&gt;name&lt;/code&gt; or
     * &lt;code&gt;actions&lt;/code&gt; is invalid.
     */
    public MBeanPermission(String name, String actions) {
        super(name);

        parseName();

        this.actions = actions;
        parseActions();
    }

    /**
     * &lt;p&gt;Create a new MBeanPermission object with the specified target name
     * (class name, member, object name) and actions.&lt;/p&gt;
     *
     * &lt;p&gt;The class name, member and object name parameters define a
     * target name of the form
     * &quot;&lt;code&gt;className#member[objectName]&lt;/code&gt;&quot; where each part is
     * optional.  This will be the result of {@link #getName()} on the
     * resultant MBeanPermission.&lt;/p&gt;
     *
     * &lt;p&gt;The actions parameter contains a comma-separated list of the
     * desired actions granted on the target name.  It must not be
     * empty or null.&lt;/p&gt;
     *
     * @param className the class name to which this permission applies.
     * May be null or &lt;code&gt;&quot;-&quot;&lt;/code&gt;, which represents a class name
     * that is implied by any class name but does not imply any other
     * class name.
     * @param member the member to which this permission applies.  May
     * be null or &lt;code&gt;&quot;-&quot;&lt;/code&gt;, which represents a member that is
     * implied by any member but does not imply any other member.
     * @param objectName the object name to which this permission
     * applies.  May be null, which represents an object name that is
     * implied by any object name but does not imply any other object
     * name.
     * @param actions the action string.
     */
    public MBeanPermission(String className,
                           String member,
                           ObjectName objectName,
                           String actions) {

        super(makeName(className, member, objectName));
        initName(className, member, objectName);

        this.actions = actions;
        parseActions();
    }

    private static String makeName(String className, String member,
                                   ObjectName objectName) {
        final StringBuilder name = new StringBuilder();
        if (className == null)
            className = &quot;-&quot;;
        name.append(className);
        if (member == null)
            member = &quot;-&quot;;
        name.append(&quot;#&quot; + member);
        if (objectName == null)
            name.append(&quot;[-]&quot;);
        else
            name.append(&quot;[&quot;).append(objectName.getCanonicalName()).append(&quot;]&quot;);

        /* In the interests of legibility for Permission.toString(), we
           transform the empty string into &quot;*&quot;.  */
        if (name.length() == 0)
            return &quot;*&quot;;
        else
            return name.toString();
    }

    /**
     * Returns the &quot;canonical string representation&quot; of the actions. That is,
     * this method always returns present actions in alphabetical order.
     *
     * @return the canonical string representation of the actions.
     */
    public String getActions() {

        if (actions == null)
            actions = getActions(this.mask);

        return actions;
    }

    /**
     * Returns the &quot;canonical string representation&quot;
     * of the actions from the mask.
     */
    private static String getActions(int mask) {
        final StringBuilder sb = new StringBuilder();
        boolean comma = false;

        if ((mask &amp; AddNotificationListener) == AddNotificationListener) {
            comma = true;
            sb.append(&quot;addNotificationListener&quot;);
        }

        if ((mask &amp; GetAttribute) == GetAttribute) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;getAttribute&quot;);
        }

        if ((mask &amp; GetClassLoader) == GetClassLoader) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;getClassLoader&quot;);
        }

        if ((mask &amp; GetClassLoaderFor) == GetClassLoaderFor) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;getClassLoaderFor&quot;);
        }

        if ((mask &amp; GetClassLoaderRepository) == GetClassLoaderRepository) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;getClassLoaderRepository&quot;);
        }

        if ((mask &amp; GetDomains) == GetDomains) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;getDomains&quot;);
        }

        if ((mask &amp; GetMBeanInfo) == GetMBeanInfo) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;getMBeanInfo&quot;);
        }

        if ((mask &amp; GetObjectInstance) == GetObjectInstance) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;getObjectInstance&quot;);
        }

        if ((mask &amp; Instantiate) == Instantiate) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;instantiate&quot;);
        }

        if ((mask &amp; Invoke) == Invoke) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;invoke&quot;);
        }

        if ((mask &amp; IsInstanceOf) == IsInstanceOf) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;isInstanceOf&quot;);
        }

        if ((mask &amp; QueryMBeans) == QueryMBeans) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;queryMBeans&quot;);
        }

        if ((mask &amp; QueryNames) == QueryNames) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;queryNames&quot;);
        }

        if ((mask &amp; RegisterMBean) == RegisterMBean) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;registerMBean&quot;);
        }

        if ((mask &amp; RemoveNotificationListener) == RemoveNotificationListener) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;removeNotificationListener&quot;);
        }

        if ((mask &amp; SetAttribute) == SetAttribute) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;setAttribute&quot;);
        }

        if ((mask &amp; UnregisterMBean) == UnregisterMBean) {
            if (comma) sb.append(',');
            else comma = true;
            sb.append(&quot;unregisterMBean&quot;);
        }

        return sb.toString();
    }

    /**
     * Returns the hash code value for this object.
     *
     * @return a hash code value for this object.
     */
    public int hashCode() {
        return this.getName().hashCode() + this.getActions().hashCode();
    }

    /**
     * Converts an action String to an integer action mask.
     *
     * @param action the action string.
     * @return the action mask.
     */
    private static int getMask(String action) {

        /*
         * BE CAREFUL HERE! PARSING ORDER IS IMPORTANT IN THIS ALGORITHM.
         *
         * The 'string length' test must be performed for the lengthiest
         * strings first.
         *
         * In this permission if the &quot;unregisterMBean&quot; string length test is
         * performed after the &quot;registerMBean&quot; string length test the algorithm
         * considers the 'unregisterMBean' action as being the 'registerMBean'
         * action and a parsing error is returned.
         */

        int mask = NONE;

        if (action == null) {
            return mask;
        }

        if (action.equals(&quot;*&quot;)) {
            return ALL;
        }

        char[] a = action.toCharArray();

        int i = a.length - 1;
        if (i &lt; 0)
            return mask;

        while (i != -1) {
            char c;

            // skip whitespace
            while ((i!=-1) &amp;&amp; ((c = a[i]) == ' ' ||
                               c == '\r' ||
                               c == '\n' ||
                               c == '\f' ||
                               c == '\t'))
                i--;

            // check for the known strings
            int matchlen;

            if (i &gt;= 25 &amp;&amp; /* removeNotificationListener */
                (a[i-25] == 'r') &amp;&amp;
                (a[i-24] == 'e') &amp;&amp;
                (a[i-23] == 'm') &amp;&amp;
                (a[i-22] == 'o') &amp;&amp;
                (a[i-21] == 'v') &amp;&amp;
                (a[i-20] == 'e') &amp;&amp;
                (a[i-19] == 'N') &amp;&amp;
                (a[i-18] == 'o') &amp;&amp;
                (a[i-17] == 't') &amp;&amp;
                (a[i-16] == 'i') &amp;&amp;
                (a[i-15] == 'f') &amp;&amp;
                (a[i-14] == 'i') &amp;&amp;
                (a[i-13] == 'c') &amp;&amp;
                (a[i-12] == 'a') &amp;&amp;
                (a[i-11] == 't') &amp;&amp;
                (a[i-10] == 'i') &amp;&amp;
                (a[i-9] == 'o') &amp;&amp;
                (a[i-8] == 'n') &amp;&amp;
                (a[i-7] == 'L') &amp;&amp;
                (a[i-6] == 'i') &amp;&amp;
                (a[i-5] == 's') &amp;&amp;
                (a[i-4] == 't') &amp;&amp;
                (a[i-3] == 'e') &amp;&amp;
                (a[i-2] == 'n') &amp;&amp;
                (a[i-1] == 'e') &amp;&amp;
                (a[i] == 'r')) {
                matchlen = 26;
                mask |= RemoveNotificationListener;
            } else if (i &gt;= 23 &amp;&amp; /* getClassLoaderRepository */
                       (a[i-23] == 'g') &amp;&amp;
                       (a[i-22] == 'e') &amp;&amp;
                       (a[i-21] == 't') &amp;&amp;
                       (a[i-20] == 'C') &amp;&amp;
                       (a[i-19] == 'l') &amp;&amp;
                       (a[i-18] == 'a') &amp;&amp;
                       (a[i-17] == 's') &amp;&amp;
                       (a[i-16] == 's') &amp;&amp;
                       (a[i-15] == 'L') &amp;&amp;
                       (a[i-14] == 'o') &amp;&amp;
                       (a[i-13] == 'a') &amp;&amp;
                       (a[i-12] == 'd') &amp;&amp;
                       (a[i-11] == 'e') &amp;&amp;
                       (a[i-10] == 'r') &amp;&amp;
                       (a[i-9] == 'R') &amp;&amp;
                       (a[i-8] == 'e') &amp;&amp;
                       (a[i-7] == 'p') &amp;&amp;
                       (a[i-6] == 'o') &amp;&amp;
                       (a[i-5] == 's') &amp;&amp;
                       (a[i-4] == 'i') &amp;&amp;
                       (a[i-3] == 't') &amp;&amp;
                       (a[i-2] == 'o') &amp;&amp;
                       (a[i-1] == 'r') &amp;&amp;
                       (a[i] == 'y')) {
                matchlen = 24;
                mask |= GetClassLoaderRepository;
            } else if (i &gt;= 22 &amp;&amp; /* addNotificationListener */
                       (a[i-22] == 'a') &amp;&amp;
                       (a[i-21] == 'd') &amp;&amp;
                       (a[i-20] == 'd') &amp;&amp;
                       (a[i-19] == 'N') &amp;&amp;
                       (a[i-18] == 'o') &amp;&amp;
                       (a[i-17] == 't') &amp;&amp;
                       (a[i-16] == 'i') &amp;&amp;
                       (a[i-15] == 'f') &amp;&amp;
                       (a[i-14] == 'i') &amp;&amp;
                       (a[i-13] == 'c') &amp;&amp;
                       (a[i-12] == 'a') &amp;&amp;
                       (a[i-11] == 't') &amp;&amp;
                       (a[i-10] == 'i') &amp;&amp;
                       (a[i-9] == 'o') &amp;&amp;
                       (a[i-8] == 'n') &amp;&amp;
                       (a[i-7] == 'L') &amp;&amp;
                       (a[i-6] == 'i') &amp;&amp;
                       (a[i-5] == 's') &amp;&amp;
                       (a[i-4] == 't') &amp;&amp;
                       (a[i-3] == 'e') &amp;&amp;
                       (a[i-2] == 'n') &amp;&amp;
                       (a[i-1] == 'e') &amp;&amp;
                       (a[i] == 'r')) {
                matchlen = 23;
                mask |= AddNotificationListener;
            } else if (i &gt;= 16 &amp;&amp; /* getClassLoaderFor */
                       (a[i-16] == 'g') &amp;&amp;
                       (a[i-15] == 'e') &amp;&amp;
                       (a[i-14] == 't') &amp;&amp;
                       (a[i-13] == 'C') &amp;&amp;
                       (a[i-12] == 'l') &amp;&amp;
                       (a[i-11] == 'a') &amp;&amp;
                       (a[i-10] == 's') &amp;&amp;
                       (a[i-9] == 's') &amp;&amp;
                       (a[i-8] == 'L') &amp;&amp;
                       (a[i-7] == 'o') &amp;&amp;
                       (a[i-6] == 'a') &amp;&amp;
                       (a[i-5] == 'd') &amp;&amp;
                       (a[i-4] == 'e') &amp;&amp;
                       (a[i-3] == 'r') &amp;&amp;
                       (a[i-2] == 'F') &amp;&amp;
                       (a[i-1] == 'o') &amp;&amp;
                       (a[i] == 'r')) {
                matchlen = 17;
                mask |= GetClassLoaderFor;
            } else if (i &gt;= 16 &amp;&amp; /* getObjectInstance */
                       (a[i-16] == 'g') &amp;&amp;
                       (a[i-15] == 'e') &amp;&amp;
                       (a[i-14] == 't') &amp;&amp;
                       (a[i-13] == 'O') &amp;&amp;
                       (a[i-12] == 'b') &amp;&amp;
                       (a[i-11] == 'j') &amp;&amp;
                       (a[i-10] == 'e') &amp;&amp;
                       (a[i-9] == 'c') &amp;&amp;
                       (a[i-8] == 't') &amp;&amp;
                       (a[i-7] == 'I') &amp;&amp;
                       (a[i-6] == 'n') &amp;&amp;
                       (a[i-5] == 's') &amp;&amp;
                       (a[i-4] == 't') &amp;&amp;
                       (a[i-3] == 'a') &amp;&amp;
                       (a[i-2] == 'n') &amp;&amp;
                       (a[i-1] == 'c') &amp;&amp;
                       (a[i] == 'e')) {
                matchlen = 17;
                mask |= GetObjectInstance;
            } else if (i &gt;= 14 &amp;&amp; /* unregisterMBean */
                       (a[i-14] == 'u') &amp;&amp;
                       (a[i-13] == 'n') &amp;&amp;
                       (a[i-12] == 'r') &amp;&amp;
                       (a[i-11] == 'e') &amp;&amp;
                       (a[i-10] == 'g') &amp;&amp;
                       (a[i-9] == 'i') &amp;&amp;
                       (a[i-8] == 's') &amp;&amp;
                       (a[i-7] == 't') &amp;&amp;
                       (a[i-6] == 'e') &amp;&amp;
                       (a[i-5] == 'r') &amp;&amp;
                       (a[i-4] == 'M') &amp;&amp;
                       (a[i-3] == 'B') &amp;&amp;
                       (a[i-2] == 'e') &amp;&amp;
                       (a[i-1] == 'a') &amp;&amp;
                       (a[i] == 'n')) {
                matchlen = 15;
                mask |= UnregisterMBean;
            } else if (i &gt;= 13 &amp;&amp; /* getClassLoader */
                       (a[i-13] == 'g') &amp;&amp;
                       (a[i-12] == 'e') &amp;&amp;
                       (a[i-11] == 't') &amp;&amp;
                       (a[i-10] == 'C') &amp;&amp;
                       (a[i-9] == 'l') &amp;&amp;
                       (a[i-8] == 'a') &amp;&amp;
                       (a[i-7] == 's') &amp;&amp;
                       (a[i-6] == 's') &amp;&amp;
                       (a[i-5] == 'L') &amp;&amp;
                       (a[i-4] == 'o') &amp;&amp;
                       (a[i-3] == 'a') &amp;&amp;
                       (a[i-2] == 'd') &amp;&amp;
                       (a[i-1] == 'e') &amp;&amp;
                       (a[i] == 'r')) {
                matchlen = 14;
                mask |= GetClassLoader;
            } else if (i &gt;= 12 &amp;&amp; /* registerMBean */
                       (a[i-12] == 'r') &amp;&amp;
                       (a[i-11] == 'e') &amp;&amp;
                       (a[i-10] == 'g') &amp;&amp;
                       (a[i-9] == 'i') &amp;&amp;
                       (a[i-8] == 's') &amp;&amp;
                       (a[i-7] == 't') &amp;&amp;
                       (a[i-6] == 'e') &amp;&amp;
                       (a[i-5] == 'r') &amp;&amp;
                       (a[i-4] == 'M') &amp;&amp;
                       (a[i-3] == 'B') &amp;&amp;
                       (a[i-2] == 'e') &amp;&amp;
                       (a[i-1] == 'a') &amp;&amp;
                       (a[i] == 'n')) {
                matchlen = 13;
                mask |= RegisterMBean;
            } else if (i &gt;= 11 &amp;&amp; /* getAttribute */
                       (a[i-11] == 'g') &amp;&amp;
                       (a[i-10] == 'e') &amp;&amp;
                       (a[i-9] == 't') &amp;&amp;
                       (a[i-8] == 'A') &amp;&amp;
                       (a[i-7] == 't') &amp;&amp;
                       (a[i-6] == 't') &amp;&amp;
                       (a[i-5] == 'r') &amp;&amp;
                       (a[i-4] == 'i') &amp;&amp;
                       (a[i-3] == 'b') &amp;&amp;
                       (a[i-2] == 'u') &amp;&amp;
                       (a[i-1] == 't') &amp;&amp;
                       (a[i] == 'e')) {
                matchlen = 12;
                mask |= GetAttribute;
            } else if (i &gt;= 11 &amp;&amp; /* getMBeanInfo */
                       (a[i-11] == 'g') &amp;&amp;
                       (a[i-10] == 'e') &amp;&amp;
                       (a[i-9] == 't') &amp;&amp;
                       (a[i-8] == 'M') &amp;&amp;
                       (a[i-7] == 'B') &amp;&amp;
                       (a[i-6] == 'e') &amp;&amp;
                       (a[i-5] == 'a') &amp;&amp;
                       (a[i-4] == 'n') &amp;&amp;
                       (a[i-3] == 'I') &amp;&amp;
                       (a[i-2] == 'n') &amp;&amp;
                       (a[i-1] == 'f') &amp;&amp;
                       (a[i] == 'o')) {
                matchlen = 12;
                mask |= GetMBeanInfo;
            } else if (i &gt;= 11 &amp;&amp; /* isInstanceOf */
                       (a[i-11] == 'i') &amp;&amp;
                       (a[i-10] == 's') &amp;&amp;
                       (a[i-9] == 'I') &amp;&amp;
                       (a[i-8] == 'n') &amp;&amp;
                       (a[i-7] == 's') &amp;&amp;
                       (a[i-6] == 't') &amp;&amp;
                       (a[i-5] == 'a') &amp;&amp;
                       (a[i-4] == 'n') &amp;&amp;
                       (a[i-3] == 'c') &amp;&amp;
                       (a[i-2] == 'e') &amp;&amp;
                       (a[i-1] == 'O') &amp;&amp;
                       (a[i] == 'f')) {
                matchlen = 12;
                mask |= IsInstanceOf;
            } else if (i &gt;= 11 &amp;&amp; /* setAttribute */
                       (a[i-11] == 's') &amp;&amp;
                       (a[i-10] == 'e') &amp;&amp;
                       (a[i-9] == 't') &amp;&amp;
                       (a[i-8] == 'A') &amp;&amp;
                       (a[i-7] == 't') &amp;&amp;
                       (a[i-6] == 't') &amp;&amp;
                       (a[i-5] == 'r') &amp;&amp;
                       (a[i-4] == 'i') &amp;&amp;
                       (a[i-3] == 'b') &amp;&amp;
                       (a[i-2] == 'u') &amp;&amp;
                       (a[i-1] == 't') &amp;&amp;
                       (a[i] == 'e')) {
                matchlen = 12;
                mask |= SetAttribute;
            } else if (i &gt;= 10 &amp;&amp; /* instantiate */
                       (a[i-10] == 'i') &amp;&amp;
                       (a[i-9] == 'n') &amp;&amp;
                       (a[i-8] == 's') &amp;&amp;
                       (a[i-7] == 't') &amp;&amp;
                       (a[i-6] == 'a') &amp;&amp;
                       (a[i-5] == 'n') &amp;&amp;
                       (a[i-4] == 't') &amp;&amp;
                       (a[i-3] == 'i') &amp;&amp;
                       (a[i-2] == 'a') &amp;&amp;
                       (a[i-1] == 't') &amp;&amp;
                       (a[i] == 'e')) {
                matchlen = 11;
                mask |= Instantiate;
            } else if (i &gt;= 10 &amp;&amp; /* queryMBeans */
                       (a[i-10] == 'q') &amp;&amp;
                       (a[i-9] == 'u') &amp;&amp;
                       (a[i-8] == 'e') &amp;&amp;
                       (a[i-7] == 'r') &amp;&amp;
                       (a[i-6] == 'y') &amp;&amp;
                       (a[i-5] == 'M') &amp;&amp;
                       (a[i-4] == 'B') &amp;&amp;
                       (a[i-3] == 'e') &amp;&amp;
                       (a[i-2] == 'a') &amp;&amp;
                       (a[i-1] == 'n') &amp;&amp;
                       (a[i] == 's')) {
                matchlen = 11;
                mask |= QueryMBeans;
            } else if (i &gt;= 9 &amp;&amp; /* getDomains */
                       (a[i-9] == 'g') &amp;&amp;
                       (a[i-8] == 'e') &amp;&amp;
                       (a[i-7] == 't') &amp;&amp;
                       (a[i-6] == 'D') &amp;&amp;
                       (a[i-5] == 'o') &amp;&amp;
                       (a[i-4] == 'm') &amp;&amp;
                       (a[i-3] == 'a') &amp;&amp;
                       (a[i-2] == 'i') &amp;&amp;
                       (a[i-1] == 'n') &amp;&amp;
                       (a[i] == 's')) {
                matchlen = 10;
                mask |= GetDomains;
            } else if (i &gt;= 9 &amp;&amp; /* queryNames */
                       (a[i-9] == 'q') &amp;&amp;
                       (a[i-8] == 'u') &amp;&amp;
                       (a[i-7] == 'e') &amp;&amp;
                       (a[i-6] == 'r') &amp;&amp;
                       (a[i-5] == 'y') &amp;&amp;
                       (a[i-4] == 'N') &amp;&amp;
                       (a[i-3] == 'a') &amp;&amp;
                       (a[i-2] == 'm') &amp;&amp;
                       (a[i-1] == 'e') &amp;&amp;
                       (a[i] == 's')) {
                matchlen = 10;
                mask |= QueryNames;
            } else if (i &gt;= 5 &amp;&amp; /* invoke */
                       (a[i-5] == 'i') &amp;&amp;
                       (a[i-4] == 'n') &amp;&amp;
                       (a[i-3] == 'v') &amp;&amp;
                       (a[i-2] == 'o') &amp;&amp;
                       (a[i-1] == 'k') &amp;&amp;
                       (a[i] == 'e')) {
                matchlen = 6;
                mask |= Invoke;
            } else {
                // parse error
                throw new IllegalArgumentException(&quot;Invalid permission: &quot; +
                                                   action);
            }

            // make sure we didn't just match the tail of a word
            // like &quot;ackbarfaccept&quot;.  Also, skip to the comma.
            boolean seencomma = false;
            while (i &gt;= matchlen &amp;&amp; !seencomma) {
                switch(a[i-matchlen]) {
                case ',':
                    seencomma = true;
                    break;
                case ' ': case '\r': case '\n':
                case '\f': case '\t':
                    break;
                default:
                    throw new IllegalArgumentException(&quot;Invalid permission: &quot; +
                                                       action);
                }
                i--;
            }

            // point i at the location of the comma minus one (or -1).
            i -= matchlen;
        }

        return mask;
    }

    /**
     * &lt;p&gt;Checks if this MBeanPermission object &quot;implies&quot; the
     * specified permission.&lt;/p&gt;
     *
     * &lt;p&gt;More specifically, this method returns true if:&lt;/p&gt;
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt; is an instance of MBeanPermission; and&lt;/li&gt;
     *
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt; has a null className or &lt;i&gt;p&lt;/i&gt;'s className
     * matches this object's className; and&lt;/li&gt;
     *
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt; has a null member or &lt;i&gt;p&lt;/i&gt;'s member matches this
     * object's member; and&lt;/li&gt;
     *
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt; has a null object name or &lt;i&gt;p&lt;/i&gt;'s
     * object name matches this object's object name; and&lt;/li&gt;
     *
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt;'s actions are a subset of this object's actions&lt;/li&gt;
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt;If this object's className is &quot;&lt;code&gt;*&lt;/code&gt;&quot;, &lt;i&gt;p&lt;/i&gt;'s
     * className always matches it.  If it is &quot;&lt;code&gt;a.*&lt;/code&gt;&quot;, &lt;i&gt;p&lt;/i&gt;'s
     * className matches it if it begins with &quot;&lt;code&gt;a.&lt;/code&gt;&quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If this object's member is &quot;&lt;code&gt;*&lt;/code&gt;&quot;, &lt;i&gt;p&lt;/i&gt;'s
     * member always matches it.&lt;/p&gt;
     *
     * &lt;p&gt;If this object's objectName &lt;i&gt;n1&lt;/i&gt; is an object name pattern,
     * &lt;i&gt;p&lt;/i&gt;'s objectName &lt;i&gt;n2&lt;/i&gt; matches it if
     * {@link ObjectName#equals &lt;i&gt;n1&lt;/i&gt;.equals(&lt;i&gt;n2&lt;/i&gt;)} or if
     * {@link ObjectName#apply &lt;i&gt;n1&lt;/i&gt;.apply(&lt;i&gt;n2&lt;/i&gt;)}.&lt;/p&gt;
     *
     * &lt;p&gt;A permission that includes the &lt;code&gt;queryMBeans&lt;/code&gt; action
     * is considered to include &lt;code&gt;queryNames&lt;/code&gt; as well.&lt;/p&gt;
     *
     * @param p the permission to check against.
     * @return true if the specified permission is implied by this object,
     * false if not.
     */
    public boolean implies(Permission p) {
        if (!(p instanceof MBeanPermission))
            return false;

        MBeanPermission that = (MBeanPermission) p;

        // Actions
        //
        // The actions in 'this' permission must be a
        // superset of the actions in 'that' permission
        //

        /* &quot;queryMBeans&quot; implies &quot;queryNames&quot; */
        if ((this.mask &amp; QueryMBeans) == QueryMBeans) {
            if (((this.mask | QueryNames) &amp; that.mask) != that.mask) {
                //System.out.println(&quot;action [with QueryNames] does not imply&quot;);
                return false;
            }
        } else {
            if ((this.mask &amp; that.mask) != that.mask) {
                //System.out.println(&quot;action does not imply&quot;);
                return false;
            }
        }

        // Target name
        //
        // The 'className' check is true iff:
        // 1) the className in 'this' permission is omitted or &quot;*&quot;, or
        // 2) the className in 'that' permission is omitted or &quot;*&quot;, or
        // 3) the className in 'this' permission does pattern
        //    matching with the className in 'that' permission.
        //
        // The 'member' check is true iff:
        // 1) the member in 'this' permission is omitted or &quot;*&quot;, or
        // 2) the member in 'that' permission is omitted or &quot;*&quot;, or
        // 3) the member in 'this' permission equals the member in
        //    'that' permission.
        //
        // The 'object name' check is true iff:
        // 1) the object name in 'this' permission is omitted or &quot;*:*&quot;, or
        // 2) the object name in 'that' permission is omitted or &quot;*:*&quot;, or
        // 3) the object name in 'this' permission does pattern
        //    matching with the object name in 'that' permission.
        //

        /* Check if this.className implies that.className.

           If that.classNamePrefix is empty that means the className is
           irrelevant for this permission check.  Otherwise, we do not
           expect that &quot;that&quot; contains a wildcard, since it is a
           needed permission.  So we assume that.classNameExactMatch.  */

        if (that.classNamePrefix == null) {
            // bottom is implied
        } else if (this.classNamePrefix == null) {
            // bottom implies nothing but itself
            return false;
        } else if (this.classNameExactMatch) {
            if (!that.classNameExactMatch)
                return false; // exact never implies wildcard
            if (!that.classNamePrefix.equals(this.classNamePrefix))
                return false; // exact match fails
        } else {
            // prefix match, works even if &quot;that&quot; is also a wildcard
            // e.g. a.* implies a.* and a.b.*
            if (!that.classNamePrefix.startsWith(this.classNamePrefix))
                return false;
        }

        /* Check if this.member implies that.member */

        if (that.member == null) {
            // bottom is implied
        } else if (this.member == null) {
            // bottom implies nothing but itself
            return false;
        } else if (this.member.equals(&quot;*&quot;)) {
            // wildcard implies everything (including itself)
        } else if (!this.member.equals(that.member)) {
            return false;
        }

        /* Check if this.objectName implies that.objectName */

        if (that.objectName == null) {
            // bottom is implied
        } else if (this.objectName == null) {
            // bottom implies nothing but itself
            return false;
        } else if (!this.objectName.apply(that.objectName)) {
            /* ObjectName.apply returns false if that.objectName is a
               wildcard so we also allow equals for that case.  This
               never happens during real permission checks, but means
               the implies relation is reflexive.  */
            if (!this.objectName.equals(that.objectName))
                return false;
        }

        return true;
    }

    /**
     * Checks two MBeanPermission objects for equality. Checks
     * that &lt;i&gt;obj&lt;/i&gt; is an MBeanPermission, and has the same
     * name and actions as this object.
     * &lt;P&gt;
     * @param obj the object we are testing for equality with this object.
     * @return true if obj is an MBeanPermission, and has the
     * same name and actions as this MBeanPermission object.
     */
    public boolean equals(Object obj) {
        if (obj == this)
            return true;

        if (! (obj instanceof MBeanPermission))
            return false;

        MBeanPermission that = (MBeanPermission) obj;

        return (this.mask == that.mask) &amp;&amp;
            (this.getName().equals(that.getName()));
    }

    /**
     * Deserialize this object based on its name and actions.
     */
    private void readObject(ObjectInputStream in)
            throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        parseName();
        parseActions();
    }
}
</pre>
</body>
</html>
