<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management;

import com.sun.jmx.mbeanserver.GetPropertyAction;
import com.sun.jmx.mbeanserver.Util;
import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamField;
import java.security.AccessController;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;

/**
 * &lt;p&gt;Represents the object name of an MBean, or a pattern that can
 * match the names of several MBeans.  Instances of this class are
 * immutable.&lt;/p&gt;
 *
 * &lt;p&gt;An instance of this class can be used to represent:&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;An object name&lt;/li&gt;
 * &lt;li&gt;An object name pattern, within the context of a query&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;An object name consists of two parts, the domain and the key
 * properties.&lt;/p&gt;
 *
 * &lt;p&gt;The &lt;em&gt;domain&lt;/em&gt; is a string of characters not including
 * the character colon (&lt;code&gt;:&lt;/code&gt;).  It is recommended that the domain
 * should not contain the string &quot;{@code //}&quot;, which is reserved for future use.
 *
 * &lt;p&gt;If the domain includes at least one occurrence of the wildcard
 * characters asterisk (&lt;code&gt;*&lt;/code&gt;) or question mark
 * (&lt;code&gt;?&lt;/code&gt;), then the object name is a pattern.  The asterisk
 * matches any sequence of zero or more characters, while the question
 * mark matches any single character.&lt;/p&gt;
 *
 * &lt;p&gt;If the domain is empty, it will be replaced in certain contexts
 * by the &lt;em&gt;default domain&lt;/em&gt; of the MBean server in which the
 * ObjectName is used.&lt;/p&gt;
 *
 * &lt;p&gt;The &lt;em&gt;key properties&lt;/em&gt; are an unordered set of keys and
 * associated values.&lt;/p&gt;
 *
 * &lt;p&gt;Each &lt;em&gt;key&lt;/em&gt; is a nonempty string of characters which may
 * not contain any of the characters comma (&lt;code&gt;,&lt;/code&gt;), equals
 * (&lt;code&gt;=&lt;/code&gt;), colon, asterisk, or question mark.  The same key
 * may not occur twice in a given ObjectName.&lt;/p&gt;
 *
 * &lt;p&gt;Each &lt;em&gt;value&lt;/em&gt; associated with a key is a string of
 * characters that is either unquoted or quoted.&lt;/p&gt;
 *
 * &lt;p&gt;An &lt;em&gt;unquoted value&lt;/em&gt; is a possibly empty string of
 * characters which may not contain any of the characters comma,
 * equals, colon, or quote.&lt;/p&gt;
 *
 * &lt;p&gt;If the &lt;em&gt;unquoted value&lt;/em&gt; contains at least one occurrence
 * of the wildcard characters asterisk or question mark, then the object
 * name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk matches any
 * sequence of zero or more characters, while the question mark matches
 * any single character.&lt;/p&gt;
 *
 * &lt;p&gt;A &lt;em&gt;quoted value&lt;/em&gt; consists of a quote (&lt;code&gt;&quot;&lt;/code&gt;),
 * followed by a possibly empty string of characters, followed by
 * another quote.  Within the string of characters, the backslash
 * (&lt;code&gt;\&lt;/code&gt;) has a special meaning.  It must be followed by
 * one of the following characters:&lt;/p&gt;
 *
 * &lt;ul&gt;
 * &lt;li&gt;Another backslash.  The second backslash has no special
 * meaning and the two characters represent a single backslash.&lt;/li&gt;
 *
 * &lt;li&gt;The character 'n'.  The two characters represent a newline
 * ('\n' in Java).&lt;/li&gt;
 *
 * &lt;li&gt;A quote.  The two characters represent a quote, and that quote
 * is not considered to terminate the quoted value. An ending closing
 * quote must be present for the quoted value to be valid.&lt;/li&gt;
 *
 * &lt;li&gt;A question mark (?) or asterisk (*).  The two characters represent
 * a question mark or asterisk respectively.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;A quote may not appear inside a quoted value except immediately
 * after an odd number of consecutive backslashes.&lt;/p&gt;
 *
 * &lt;p&gt;The quotes surrounding a quoted value, and any backslashes
 * within that value, are considered to be part of the value.&lt;/p&gt;
 *
 * &lt;p&gt;If the &lt;em&gt;quoted value&lt;/em&gt; contains at least one occurrence of
 * the characters asterisk or question mark and they are not preceded
 * by a backslash, then they are considered as wildcard characters and
 * the object name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk
 * matches any sequence of zero or more characters, while the question
 * mark matches any single character.&lt;/p&gt;
 *
 * &lt;p&gt;An ObjectName may be a &lt;em&gt;property list pattern&lt;/em&gt;. In this
 * case it may have zero or more keys and associated values. It matches
 * a nonpattern ObjectName whose domain matches and that contains the
 * same keys and associated values, as well as possibly other keys and
 * values.&lt;/p&gt;
 *
 * &lt;p&gt;An ObjectName is a &lt;em&gt;property value pattern&lt;/em&gt; when at least
 * one of its &lt;em&gt;quoted&lt;/em&gt; or &lt;em&gt;unquoted&lt;/em&gt; key property values
 * contains the wildcard characters asterisk or question mark as described
 * above. In this case it has one or more keys and associated values, with
 * at least one of the values containing wildcard characters. It matches a
 * nonpattern ObjectName whose domain matches and that contains the same
 * keys whose values match; if the property value pattern is also a
 * property list pattern then the nonpattern ObjectName can contain
 * other keys and values.&lt;/p&gt;
 *
 * &lt;p&gt;An ObjectName is a &lt;em&gt;property pattern&lt;/em&gt; if it is either a
 * &lt;em&gt;property list pattern&lt;/em&gt; or a &lt;em&gt;property value pattern&lt;/em&gt;
 * or both.&lt;/p&gt;
 *
 * &lt;p&gt;An ObjectName is a pattern if its domain contains a wildcard or
 * if the ObjectName is a property pattern.&lt;/p&gt;
 *
 * &lt;p&gt;If an ObjectName is not a pattern, it must contain at least one
 * key with its associated value.&lt;/p&gt;
 *
 * &lt;p&gt;Examples of ObjectName patterns are:&lt;/p&gt;
 *
 * &lt;ul&gt;
 * &lt;li&gt;{@code *:type=Foo,name=Bar} to match names in any domain whose
 *     exact set of keys is {@code type=Foo,name=Bar}.&lt;/li&gt;
 * &lt;li&gt;{@code d:type=Foo,name=Bar,*} to match names in the domain
 *     {@code d} that have the keys {@code type=Foo,name=Bar} plus
 *     zero or more other keys.&lt;/li&gt;
 * &lt;li&gt;{@code *:type=Foo,name=Bar,*} to match names in any domain
 *     that has the keys {@code type=Foo,name=Bar} plus zero or
 *     more other keys.&lt;/li&gt;
 * &lt;li&gt;{@code d:type=F?o,name=Bar} will match e.g.
 *     {@code d:type=Foo,name=Bar} and {@code d:type=Fro,name=Bar}.&lt;/li&gt;
 * &lt;li&gt;{@code d:type=F*o,name=Bar} will match e.g.
 *     {@code d:type=Fo,name=Bar} and {@code d:type=Frodo,name=Bar}.&lt;/li&gt;
 * &lt;li&gt;{@code d:type=Foo,name=&quot;B*&quot;} will match e.g.
 *     {@code d:type=Foo,name=&quot;Bling&quot;}. Wildcards are recognized even
 *     inside quotes, and like other special characters can be escaped
 *     with {@code \}.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;An ObjectName can be written as a String with the following
 * elements in order:&lt;/p&gt;
 *
 * &lt;ul&gt;
 * &lt;li&gt;The domain.
 * &lt;li&gt;A colon (&lt;code&gt;:&lt;/code&gt;).
 * &lt;li&gt;A key property list as defined below.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;A key property list written as a String is a comma-separated
 * list of elements.  Each element is either an asterisk or a key
 * property.  A key property consists of a key, an equals
 * (&lt;code&gt;=&lt;/code&gt;), and the associated value.&lt;/p&gt;
 *
 * &lt;p&gt;At most one element of a key property list may be an asterisk.
 * If the key property list contains an asterisk element, the
 * ObjectName is a property list pattern.&lt;/p&gt;
 *
 * &lt;p&gt;Spaces have no special significance in a String representing an
 * ObjectName.  For example, the String:
 * &lt;pre&gt;
 * domain: key1 = value1 , key2 = value2
 * &lt;/pre&gt;
 * represents an ObjectName with two keys.  The name of each key
 * contains six characters, of which the first and last are spaces.
 * The value associated with the key &lt;code&gt;&quot;&amp;nbsp;key1&amp;nbsp;&quot;&lt;/code&gt;
 * also begins and ends with a space.
 *
 * &lt;p&gt;In addition to the restrictions on characters spelt out above,
 * no part of an ObjectName may contain a newline character
 * (&lt;code&gt;'\n'&lt;/code&gt;), whether the domain, a key, or a value, whether
 * quoted or unquoted.  The newline character can be represented in a
 * quoted value with the sequence &lt;code&gt;\n&lt;/code&gt;.
 *
 * &lt;p&gt;The rules on special characters and quoting apply regardless of
 * which constructor is used to make an ObjectName.&lt;/p&gt;
 *
 * &lt;p&gt;To avoid collisions between MBeans supplied by different
 * vendors, a useful convention is to begin the domain name with the
 * reverse DNS name of the organization that specifies the MBeans,
 * followed by a period and a string whose interpretation is
 * determined by that organization.  For example, MBeans specified by
 * &lt;code&gt;example.com&lt;/code&gt;  would have
 * domains such as &lt;code&gt;com.example.MyDomain&lt;/code&gt;.  This is essentially
 * the same convention as for Java-language package names.&lt;/p&gt;
 *
 * &lt;p&gt;The &lt;b&gt;serialVersionUID&lt;/b&gt; of this class is &lt;code&gt;1081892073854801359L&lt;/code&gt;.
 *
 * @since 1.5
 */
@SuppressWarnings(&quot;serial&quot;) // don't complain serialVersionUID not constant
public class ObjectName implements Comparable&lt;ObjectName&gt;, QueryExp {

    /**
     * A structure recording property structure and
     * proposing minimal services
     */
    private static class Property {

        int _key_index;
        int _key_length;
        int _value_length;

        /**
         * Constructor.
         */
        Property(int key_index, int key_length, int value_length) {
            _key_index = key_index;
            _key_length = key_length;
            _value_length = value_length;
        }

        /**
         * Assigns the key index of property
         */
        void setKeyIndex(int key_index) {
            _key_index = key_index;
        }

        /**
         * Returns a key string for receiver key
         */
        String getKeyString(String name) {
            return name.substring(_key_index, _key_index + _key_length);
        }

        /**
         * Returns a value string for receiver key
         */
        String getValueString(String name) {
            int in_begin = _key_index + _key_length + 1;
            int out_end = in_begin + _value_length;
            return name.substring(in_begin, out_end);
        }
    }

    /**
     * Marker class for value pattern property.
     */
    private static class PatternProperty extends Property {
        /**
         * Constructor.
         */
        PatternProperty(int key_index, int key_length, int value_length) {
            super(key_index, key_length, value_length);
        }
    }

    // Inner classes &lt;========================================



    // Private fields ----------------------------------------&gt;


    // Serialization compatibility stuff --------------------&gt;

    // Two serial forms are supported in this class. The selected form depends
    // on system property &quot;jmx.serial.form&quot;:
    //  - &quot;1.0&quot; for JMX 1.0
    //  - any other value for JMX 1.1 and higher
    //
    // Serial version for old serial form
    private static final long oldSerialVersionUID = -5467795090068647408L;
    //
    // Serial version for new serial form
    private static final long newSerialVersionUID = 1081892073854801359L;
    //
    // Serializable fields in old serial form
    private static final ObjectStreamField[] oldSerialPersistentFields =
    {
        new ObjectStreamField(&quot;domain&quot;, String.class),
        new ObjectStreamField(&quot;propertyList&quot;, Hashtable.class),
        new ObjectStreamField(&quot;propertyListString&quot;, String.class),
        new ObjectStreamField(&quot;canonicalName&quot;, String.class),
        new ObjectStreamField(&quot;pattern&quot;, Boolean.TYPE),
        new ObjectStreamField(&quot;propertyPattern&quot;, Boolean.TYPE)
    };
    //
    // Serializable fields in new serial form
    private static final ObjectStreamField[] newSerialPersistentFields = { };
    //
    // Actual serial version and serial form
    private static final long serialVersionUID;
    private static final ObjectStreamField[] serialPersistentFields;
    private static boolean compat = false;
    static {
        try {
            GetPropertyAction act = new GetPropertyAction(&quot;jmx.serial.form&quot;);
            String form = AccessController.doPrivileged(act);
            compat = (form != null &amp;&amp; form.equals(&quot;1.0&quot;));
        } catch (Exception e) {
            // OK: exception means no compat with 1.0, too bad
        }
        if (compat) {
            serialPersistentFields = oldSerialPersistentFields;
            serialVersionUID = oldSerialVersionUID;
        } else {
            serialPersistentFields = newSerialPersistentFields;
            serialVersionUID = newSerialVersionUID;
        }
    }

    //
    // Serialization compatibility stuff &lt;==============================

    // Class private fields -----------------------------------&gt;

    /**
     * a shared empty array for empty property lists
     */
    static final private Property[] _Empty_property_array = new Property[0];


    // Class private fields &lt;==============================

    // Instance private fields -----------------------------------&gt;

    /**
     * a String containing the canonical name
     */
    private transient String _canonicalName;


    /**
     * An array of properties in the same seq order as time creation
     */
    private transient Property[] _kp_array;

    /**
     * An array of properties in the same seq order as canonical order
     */
    private transient Property[] _ca_array;


    /**
     * The length of the domain part of built objectname
     */
    private transient int _domain_length = 0;


    /**
     * The propertyList of built object name. Initialized lazily.
     * Table that contains all the pairs (key,value) for this ObjectName.
     */
    private transient Map&lt;String,String&gt; _propertyList;

    /**
     * boolean that declares if this ObjectName domain part is a pattern
     */
    private transient boolean _domain_pattern = false;

    /**
     * boolean that declares if this ObjectName contains a pattern on the
     * key property list
     */
    private transient boolean _property_list_pattern = false;

    /**
     * boolean that declares if this ObjectName contains a pattern on the
     * value of at least one key property
     */
    private transient boolean _property_value_pattern = false;

    // Instance private fields &lt;=======================================

    // Private fields &lt;========================================


    //  Private methods ----------------------------------------&gt;

    // Category : Instance construction -------------------------&gt;

    /**
     * Initializes this {@link ObjectName} from the given string
     * representation.
     *
     * @param name A string representation of the {@link ObjectName}
     *
     * @exception MalformedObjectNameException The string passed as a
     * parameter does not have the right format.
     * @exception NullPointerException The &lt;code&gt;name&lt;/code&gt; parameter
     * is null.
     */
    private void construct(String name)
        throws MalformedObjectNameException {

        // The name cannot be null
        if (name == null)
            throw new NullPointerException(&quot;name cannot be null&quot;);

        // Test if the name is empty
        if (name.length() == 0) {
            // this is equivalent to the whole word query object name.
            _canonicalName = &quot;*:*&quot;;
            _kp_array = _Empty_property_array;
            _ca_array = _Empty_property_array;
            _domain_length = 1;
            _propertyList = null;
            _domain_pattern = true;
            _property_list_pattern = true;
            _property_value_pattern = false;
            return;
        }

        // initialize parsing of the string
        final char[] name_chars = name.toCharArray();
        final int len = name_chars.length;
        final char[] canonical_chars = new char[len]; // canonical form will
                                                      // be same length at most
        int cname_index = 0;
        int index = 0;
        char c, c1;

        // parses domain part
    domain_parsing:
        while (index &lt; len) {
            switch (name_chars[index]) {
                case ':' :
                    _domain_length = index++;
                    break domain_parsing;
                case '=' :
                    // &quot;:&quot; omission check.
                    //
                    // Although &quot;=&quot; is a valid character in the domain part
                    // it is true that it is rarely used in the real world.
                    // So check straight away if the &quot;:&quot; has been omitted
                    // from the ObjectName. This allows us to provide a more
                    // accurate exception message.
                    int i = ++index;
                    while ((i &lt; len) &amp;&amp; (name_chars[i++] != ':'))
                        if (i == len)
                            throw new MalformedObjectNameException(
                                &quot;Domain part must be specified&quot;);
                    break;
                case '\n' :
                    throw new MalformedObjectNameException(
                              &quot;Invalid character '\\n' in domain name&quot;);
                case '*' :
                case '?' :
                    _domain_pattern = true;
                    index++;
                    break;
                default :
                    index++;
                    break;
            }
        }

        // check for non-empty properties
        if (index == len)
            throw new MalformedObjectNameException(
                                         &quot;Key properties cannot be empty&quot;);

        // we have got the domain part, begins building of _canonicalName
        System.arraycopy(name_chars, 0, canonical_chars, 0, _domain_length);
        canonical_chars[_domain_length] = ':';
        cname_index = _domain_length + 1;

        // parses property list
        Property prop;
        Map&lt;String,Property&gt; keys_map = new HashMap&lt;String,Property&gt;();
        String[] keys;
        String key_name;
        boolean quoted_value;
        int property_index = 0;
        int in_index;
        int key_index, key_length, value_index, value_length;

        keys = new String[10];
        _kp_array = new Property[10];
        _property_list_pattern = false;
        _property_value_pattern = false;

        while (index &lt; len) {
            c = name_chars[index];

            // case of pattern properties
            if (c == '*') {
                if (_property_list_pattern)
                    throw new MalformedObjectNameException(
                              &quot;Cannot have several '*' characters in pattern &quot; +
                              &quot;property list&quot;);
                else {
                    _property_list_pattern = true;
                    if ((++index &lt; len ) &amp;&amp; (name_chars[index] != ','))
                        throw new MalformedObjectNameException(
                                  &quot;Invalid character found after '*': end of &quot; +
                                  &quot;name or ',' expected&quot;);
                    else if (index == len) {
                        if (property_index == 0) {
                            // empty properties case
                            _kp_array = _Empty_property_array;
                            _ca_array = _Empty_property_array;
                            _propertyList = Collections.emptyMap();
                        }
                        break;
                    } else {
                        // correct pattern spec in props, continue
                        index++;
                        continue;
                    }
                }
            }

            // standard property case, key part
            in_index = index;
            key_index = in_index;
            if (name_chars[in_index] == '=')
                throw new MalformedObjectNameException(&quot;Invalid key (empty)&quot;);
            while ((in_index &lt; len) &amp;&amp; ((c1 = name_chars[in_index++]) != '='))
                switch (c1) {
                    // '=' considered to introduce value part
                    case  '*' :
                    case  '?' :
                    case  ',' :
                    case  ':' :
                    case  '\n' :
                        final String ichar = ((c1=='\n')?&quot;\\n&quot;:&quot;&quot;+c1);
                        throw new MalformedObjectNameException(
                                  &quot;Invalid character '&quot; + ichar +
                                  &quot;' in key part of property&quot;);
                }
            if (name_chars[in_index - 1] != '=')
                throw new MalformedObjectNameException(
                                             &quot;Unterminated key property part&quot;);
            value_index = in_index; // in_index pointing after '=' char
            key_length = value_index - key_index - 1; // found end of key

            // standard property case, value part
            boolean value_pattern = false;
            if (in_index &lt; len &amp;&amp; name_chars[in_index] == '\&quot;') {
                quoted_value = true;
                // the case of quoted value part
            quoted_value_parsing:
                while ((++in_index &lt; len) &amp;&amp;
                       ((c1 = name_chars[in_index]) != '\&quot;')) {
                    // the case of an escaped character
                    if (c1 == '\\') {
                        if (++in_index == len)
                            throw new MalformedObjectNameException(
                                               &quot;Unterminated quoted value&quot;);
                        switch (c1 = name_chars[in_index]) {
                            case '\\' :
                            case '\&quot;' :
                            case '?' :
                            case '*' :
                            case 'n' :
                                break; // valid character
                            default :
                                throw new MalformedObjectNameException(
                                          &quot;Invalid escape sequence '\\&quot; +
                                          c1 + &quot;' in quoted value&quot;);
                        }
                    } else if (c1 == '\n') {
                        throw new MalformedObjectNameException(
                                                     &quot;Newline in quoted value&quot;);
                    } else {
                        switch (c1) {
                            case '?' :
                            case '*' :
                                value_pattern = true;
                                break;
                        }
                    }
                }
                if (in_index == len)
                    throw new MalformedObjectNameException(
                                                 &quot;Unterminated quoted value&quot;);
                else value_length = ++in_index - value_index;
            } else {
                // the case of standard value part
                quoted_value = false;
                while ((in_index &lt; len) &amp;&amp; ((c1 = name_chars[in_index]) != ','))
                switch (c1) {
                    // ',' considered to be the value separator
                    case '*' :
                    case '?' :
                        value_pattern = true;
                        in_index++;
                        break;
                    case '=' :
                    case ':' :
                    case '&quot;' :
                    case '\n' :
                        final String ichar = ((c1=='\n')?&quot;\\n&quot;:&quot;&quot;+c1);
                        throw new MalformedObjectNameException(
                                                 &quot;Invalid character '&quot; + ichar +
                                                 &quot;' in value part of property&quot;);
                    default :
                        in_index++;
                        break;
                }
                value_length = in_index - value_index;
            }

            // Parsed property, checks the end of name
            if (in_index == len - 1) {
                if (quoted_value)
                    throw new MalformedObjectNameException(
                                             &quot;Invalid ending character `&quot; +
                                             name_chars[in_index] + &quot;'&quot;);
                else throw new MalformedObjectNameException(
                                                  &quot;Invalid ending comma&quot;);
            } else in_index++;

            // we got the key and value part, prepare a property for this
            if (!value_pattern) {
                prop = new Property(key_index, key_length, value_length);
            } else {
                _property_value_pattern = true;
                prop = new PatternProperty(key_index, key_length, value_length);
            }
            key_name = name.substring(key_index, key_index + key_length);

            if (property_index == keys.length) {
                String[] tmp_string_array = new String[property_index + 10];
                System.arraycopy(keys, 0, tmp_string_array, 0, property_index);
                keys = tmp_string_array;
            }
            keys[property_index] = key_name;

            addProperty(prop, property_index, keys_map, key_name);
            property_index++;
            index = in_index;
        }

        // computes and set canonical name
        setCanonicalName(name_chars, canonical_chars, keys,
                         keys_map, cname_index, property_index);
    }

    /**
     * Construct an ObjectName from a domain and a Hashtable.
     *
     * @param domain Domain of the ObjectName.
     * @param props  Map containing couples &lt;i&gt;key&lt;/i&gt; {@literal -&gt;} &lt;i&gt;value&lt;/i&gt;.
     *
     * @exception MalformedObjectNameException The &lt;code&gt;domain&lt;/code&gt;
     * contains an illegal character, or one of the keys or values in
     * &lt;code&gt;table&lt;/code&gt; contains an illegal character, or one of the
     * values in &lt;code&gt;table&lt;/code&gt; does not follow the rules for quoting.
     * @exception NullPointerException One of the parameters is null.
     */
    private void construct(String domain, Map&lt;String,String&gt; props)
        throws MalformedObjectNameException {

        // The domain cannot be null
        if (domain == null)
            throw new NullPointerException(&quot;domain cannot be null&quot;);

        // The key property list cannot be null
        if (props == null)
            throw new NullPointerException(&quot;key property list cannot be null&quot;);

        // The key property list cannot be empty
        if (props.isEmpty())
            throw new MalformedObjectNameException(
                                         &quot;key property list cannot be empty&quot;);

        // checks domain validity
        if (!isDomain(domain))
            throw new MalformedObjectNameException(&quot;Invalid domain: &quot; + domain);

        // init canonicalname
        final StringBuilder sb = new StringBuilder();
        sb.append(domain).append(':');
        _domain_length = domain.length();

        // allocates the property array
        int nb_props = props.size();
        _kp_array = new Property[nb_props];

        String[] keys = new String[nb_props];
        final Map&lt;String,Property&gt; keys_map = new HashMap&lt;String,Property&gt;();
        Property prop;
        int key_index;
        int i = 0;
        for (Map.Entry&lt;String,String&gt; entry : props.entrySet()) {
            if (sb.length() &gt; 0)
                sb.append(&quot;,&quot;);
            String key = entry.getKey();
            String value;
            try {
                value = entry.getValue();
            } catch (ClassCastException e) {
                throw new MalformedObjectNameException(e.getMessage());
            }
            key_index = sb.length();
            checkKey(key);
            sb.append(key);
            keys[i] = key;
            sb.append(&quot;=&quot;);
            boolean value_pattern = checkValue(value);
            sb.append(value);
            if (!value_pattern) {
                prop = new Property(key_index,
                                    key.length(),
                                    value.length());
            } else {
                _property_value_pattern = true;
                prop = new PatternProperty(key_index,
                                           key.length(),
                                           value.length());
            }
            addProperty(prop, i, keys_map, key);
            i++;
        }

        // initialize canonical name and data structure
        int len = sb.length();
        char[] initial_chars = new char[len];
        sb.getChars(0, len, initial_chars, 0);
        char[] canonical_chars = new char[len];
        System.arraycopy(initial_chars, 0, canonical_chars, 0,
                         _domain_length + 1);
        setCanonicalName(initial_chars, canonical_chars, keys, keys_map,
                         _domain_length + 1, _kp_array.length);
    }
    // Category : Instance construction &lt;==============================

    // Category : Internal utilities ------------------------------&gt;

    /**
     * Add passed property to the list at the given index
     * for the passed key name
     */
    private void addProperty(Property prop, int index,
                             Map&lt;String,Property&gt; keys_map, String key_name)
        throws MalformedObjectNameException {

        if (keys_map.containsKey(key_name)) throw new
                MalformedObjectNameException(&quot;key `&quot; +
                                         key_name +&quot;' already defined&quot;);

        // if no more space for property arrays, have to increase it
        if (index == _kp_array.length) {
            Property[] tmp_prop_array = new Property[index + 10];
            System.arraycopy(_kp_array, 0, tmp_prop_array, 0, index);
            _kp_array = tmp_prop_array;
        }
        _kp_array[index] = prop;
        keys_map.put(key_name, prop);
    }

    /**
     * Sets the canonical name of receiver from input 'specified_chars'
     * array, by filling 'canonical_chars' array with found 'nb-props'
     * properties starting at position 'prop_index'.
     */
    private void setCanonicalName(char[] specified_chars,
                                  char[] canonical_chars,
                                  String[] keys, Map&lt;String,Property&gt; keys_map,
                                  int prop_index, int nb_props) {

        // Sort the list of found properties
        if (_kp_array != _Empty_property_array) {
            String[] tmp_keys = new String[nb_props];
            Property[] tmp_props = new Property[nb_props];

            System.arraycopy(keys, 0, tmp_keys, 0, nb_props);
            Arrays.sort(tmp_keys);
            keys = tmp_keys;
            System.arraycopy(_kp_array, 0, tmp_props, 0 , nb_props);
            _kp_array = tmp_props;
            _ca_array = new Property[nb_props];

            // now assigns _ca_array to the sorted list of keys
            // (there cannot be two identical keys in an objectname.
            for (int i = 0; i &lt; nb_props; i++)
                _ca_array[i] = keys_map.get(keys[i]);

            // now we build the canonical name and set begin indexes of
            // properties to reflect canonical form
            int last_index = nb_props - 1;
            int prop_len;
            Property prop;
            for (int i = 0; i &lt;= last_index; i++) {
                prop = _ca_array[i];
                // length of prop including '=' char
                prop_len = prop._key_length + prop._value_length + 1;
                System.arraycopy(specified_chars, prop._key_index,
                                 canonical_chars, prop_index, prop_len);
                prop.setKeyIndex(prop_index);
                prop_index += prop_len;
                if (i != last_index) {
                    canonical_chars[prop_index] = ',';
                    prop_index++;
                }
            }
        }

        // terminate canonicalname with '*' in case of pattern
        if (_property_list_pattern) {
            if (_kp_array != _Empty_property_array)
                canonical_chars[prop_index++] = ',';
            canonical_chars[prop_index++] = '*';
        }

        // we now build the canonicalname string
        _canonicalName = (new String(canonical_chars, 0, prop_index)).intern();
    }

    /**
     * Parse a key.
     * &lt;pre&gt;final int endKey=parseKey(s,startKey);&lt;/pre&gt;
     * &lt;p&gt;key starts at startKey (included), and ends at endKey (excluded).
     * If (startKey == endKey), then the key is empty.
     *
     * @param s The char array of the original string.
     * @param startKey index at which to begin parsing.
     * @return The index following the last character of the key.
     **/
    private static int parseKey(final char[] s, final int startKey)
        throws MalformedObjectNameException {
        int next   = startKey;
        int endKey = startKey;
        final int len = s.length;
        while (next &lt; len) {
            final char k = s[next++];
            switch (k) {
            case '*':
            case '?':
            case ',':
            case ':':
            case '\n':
                final String ichar = ((k=='\n')?&quot;\\n&quot;:&quot;&quot;+k);
                throw new
                    MalformedObjectNameException(&quot;Invalid character in key: `&quot;
                                                 + ichar + &quot;'&quot;);
            case '=':
                // we got the key.
                endKey = next-1;
                break;
            default:
                if (next &lt; len) continue;
                else endKey=next;
            }
            break;
        }
        return endKey;
    }

    /**
     * Parse a value.
     * &lt;pre&gt;final int endVal=parseValue(s,startVal);&lt;/pre&gt;
     * &lt;p&gt;value starts at startVal (included), and ends at endVal (excluded).
     * If (startVal == endVal), then the key is empty.
     *
     * @param s The char array of the original string.
     * @param startValue index at which to begin parsing.
     * @return The first element of the int array indicates the index
     *         following the last character of the value. The second
     *         element of the int array indicates that the value is
     *         a pattern when its value equals 1.
     **/
    private static int[] parseValue(final char[] s, final int startValue)
        throws MalformedObjectNameException {

        boolean value_pattern = false;

        int next   = startValue;
        int endValue = startValue;

        final int len = s.length;
        final char q=s[startValue];

        if (q == '&quot;') {
            // quoted value
            if (++next == len) throw new
                MalformedObjectNameException(&quot;Invalid quote&quot;);
            while (next &lt; len) {
                char last = s[next];
                if (last == '\\') {
                    if (++next == len) throw new
                        MalformedObjectNameException(
                           &quot;Invalid unterminated quoted character sequence&quot;);
                    last = s[next];
                    switch (last) {
                        case '\\' :
                        case '?' :
                        case '*' :
                        case 'n' :
                            break;
                        case '\&quot;' :
                            // We have an escaped quote. If this escaped
                            // quote is the last character, it does not
                            // qualify as a valid termination quote.
                            //
                            if (next+1 == len) throw new
                                MalformedObjectNameException(
                                                 &quot;Missing termination quote&quot;);
                            break;
                        default:
                            throw new
                                MalformedObjectNameException(
                                &quot;Invalid quoted character sequence '\\&quot; +
                                last + &quot;'&quot;);
                    }
                } else if (last == '\n') {
                    throw new MalformedObjectNameException(
                                                 &quot;Newline in quoted value&quot;);
                } else if (last == '\&quot;') {
                    next++;
                    break;
                } else {
                    switch (last) {
                        case '?' :
                        case '*' :
                            value_pattern = true;
                            break;
                    }
                }
                next++;

                // Check that last character is a termination quote.
                // We have already handled the case were the last
                // character is an escaped quote earlier.
                //
                if ((next &gt;= len) &amp;&amp; (last != '\&quot;')) throw new
                    MalformedObjectNameException(&quot;Missing termination quote&quot;);
            }
            endValue = next;
            if (next &lt; len) {
                if (s[next++] != ',') throw new
                    MalformedObjectNameException(&quot;Invalid quote&quot;);
            }
        } else {
            // Non quoted value.
            while (next &lt; len) {
                final char v=s[next++];
                switch(v) {
                    case '*':
                    case '?':
                        value_pattern = true;
                        if (next &lt; len) continue;
                        else endValue=next;
                        break;
                    case '=':
                    case ':':
                    case '\n' :
                        final String ichar = ((v=='\n')?&quot;\\n&quot;:&quot;&quot;+v);
                        throw new
                            MalformedObjectNameException(&quot;Invalid character `&quot; +
                                                         ichar + &quot;' in value&quot;);
                    case ',':
                        endValue = next-1;
                        break;
                    default:
                        if (next &lt; len) continue;
                        else endValue=next;
                }
                break;
            }
        }
        return new int[] { endValue, value_pattern ? 1 : 0 };
    }

    /**
     * Check if the supplied value is a valid value.
     *
     * @return true if the value is a pattern, otherwise false.
     */
    private static boolean checkValue(String val)
        throws MalformedObjectNameException {

        if (val == null) throw new
            NullPointerException(&quot;Invalid value (null)&quot;);

        final int len = val.length();
        if (len == 0)
            return false;

        final char[] s = val.toCharArray();
        final int[] result = parseValue(s,0);
        final int endValue = result[0];
        final boolean value_pattern = result[1] == 1;
        if (endValue &lt; len) throw new
            MalformedObjectNameException(&quot;Invalid character in value: `&quot; +
                                         s[endValue] + &quot;'&quot;);
        return value_pattern;
    }

    /**
     * Check if the supplied key is a valid key.
     */
    private static void checkKey(String key)
        throws MalformedObjectNameException {

        if (key == null) throw new
            NullPointerException(&quot;Invalid key (null)&quot;);

        final int len = key.length();
        if (len == 0) throw new
            MalformedObjectNameException(&quot;Invalid key (empty)&quot;);
        final char[] k=key.toCharArray();
        final int endKey = parseKey(k,0);
        if (endKey &lt; len) throw new
            MalformedObjectNameException(&quot;Invalid character in value: `&quot; +
                                         k[endKey] + &quot;'&quot;);
    }


    // Category : Internal utilities &lt;==============================

    // Category : Internal accessors ------------------------------&gt;

    /**
     * Check if domain is a valid domain.  Set _domain_pattern if appropriate.
     */
    private boolean isDomain(String domain) {
        if (domain == null) return true;
        final int len = domain.length();
        int next = 0;
        while (next &lt; len) {
            final char c = domain.charAt(next++);
            switch (c) {
                case ':' :
                case '\n' :
                    return false;
                case '*' :
                case '?' :
                    _domain_pattern = true;
                    break;
            }
        }
        return true;
    }

    // Category : Internal accessors &lt;==============================

    // Category : Serialization -----------------------------------&gt;

    /**
     * Deserializes an {@link ObjectName} from an {@link ObjectInputStream}.
     * @serialData &lt;ul&gt;
     *               &lt;li&gt;In the current serial form (value of property
     *                   &lt;code&gt;jmx.serial.form&lt;/code&gt; differs from
     *                   &lt;code&gt;1.0&lt;/code&gt;): the string
     *                   &amp;quot;&amp;lt;domain&amp;gt;:&amp;lt;properties&amp;gt;&amp;lt;wild&amp;gt;&amp;quot;,
     *                   where: &lt;ul&gt;
     *                            &lt;li&gt;&amp;lt;domain&amp;gt; represents the domain part
     *                                of the {@link ObjectName}&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;properties&amp;gt; represents the list of
     *                                properties, as returned by
     *                                {@link #getKeyPropertyListString}
     *                            &lt;li&gt;&amp;lt;wild&amp;gt; is empty if not
     *                                &lt;code&gt;isPropertyPattern&lt;/code&gt;, or
     *                                is the character &quot;&lt;code&gt;*&lt;/code&gt;&quot; if
     *                                &lt;code&gt;isPropertyPattern&lt;/code&gt;
     *                                and &amp;lt;properties&amp;gt; is empty, or
     *                                is &quot;&lt;code&gt;,*&lt;/code&gt;&quot; if
     *                                &lt;code&gt;isPropertyPattern&lt;/code&gt; and
     *                                &amp;lt;properties&amp;gt; is not empty.
     *                            &lt;/li&gt;
     *                          &lt;/ul&gt;
     *                   The intent is that this string could be supplied
     *                   to the {@link #ObjectName(String)} constructor to
     *                   produce an equivalent {@link ObjectName}.
     *               &lt;/li&gt;
     *               &lt;li&gt;In the old serial form (value of property
     *                   &lt;code&gt;jmx.serial.form&lt;/code&gt; is
     *                   &lt;code&gt;1.0&lt;/code&gt;): &amp;lt;domain&amp;gt; &amp;lt;propertyList&amp;gt;
     *                   &amp;lt;propertyListString&amp;gt; &amp;lt;canonicalName&amp;gt;
     *                   &amp;lt;pattern&amp;gt; &amp;lt;propertyPattern&amp;gt;,
     *                   where: &lt;ul&gt;
     *                            &lt;li&gt;&amp;lt;domain&amp;gt; represents the domain part
     *                                of the {@link ObjectName}&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;propertyList&amp;gt; is the
     *                                {@link Hashtable} that contains all the
     *                                pairs (key,value) for this
     *                                {@link ObjectName}&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;propertyListString&amp;gt; is the
     *                                {@link String} representation of the
     *                                list of properties in any order (not
     *                                mandatorily a canonical representation)
     *                                &lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;canonicalName&amp;gt; is the
     *                                {@link String} containing this
     *                                {@link ObjectName}'s canonical name&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;pattern&amp;gt; is a boolean which is
     *                                &lt;code&gt;true&lt;/code&gt; if this
     *                                {@link ObjectName} contains a pattern&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;propertyPattern&amp;gt; is a boolean which
     *                                is &lt;code&gt;true&lt;/code&gt; if this
     *                                {@link ObjectName} contains a pattern in
     *                                the list of properties&lt;/li&gt;
     *                          &lt;/ul&gt;
     *               &lt;/li&gt;
     *             &lt;/ul&gt;
     */
    private void readObject(ObjectInputStream in)
        throws IOException, ClassNotFoundException {

        String cn;
        if (compat) {
            // Read an object serialized in the old serial form
            //
            //in.defaultReadObject();
            final ObjectInputStream.GetField fields = in.readFields();
            String propListString =
                    (String)fields.get(&quot;propertyListString&quot;, &quot;&quot;);

            // 6616825: take care of property patterns
            final boolean propPattern =
                    fields.get(&quot;propertyPattern&quot; , false);
            if (propPattern) {
                propListString =
                        (propListString.length()==0?&quot;*&quot;:(propListString+&quot;,*&quot;));
            }

            cn = (String)fields.get(&quot;domain&quot;, &quot;default&quot;)+
                &quot;:&quot;+ propListString;
        } else {
            // Read an object serialized in the new serial form
            //
            in.defaultReadObject();
            cn = (String)in.readObject();
        }

        try {
            construct(cn);
        } catch (NullPointerException e) {
            throw new InvalidObjectException(e.toString());
        } catch (MalformedObjectNameException e) {
            throw new InvalidObjectException(e.toString());
        }
    }


    /**
     * Serializes an {@link ObjectName} to an {@link ObjectOutputStream}.
     * @serialData &lt;ul&gt;
     *               &lt;li&gt;In the current serial form (value of property
     *                   &lt;code&gt;jmx.serial.form&lt;/code&gt; differs from
     *                   &lt;code&gt;1.0&lt;/code&gt;): the string
     *                   &amp;quot;&amp;lt;domain&amp;gt;:&amp;lt;properties&amp;gt;&amp;lt;wild&amp;gt;&amp;quot;,
     *                   where: &lt;ul&gt;
     *                            &lt;li&gt;&amp;lt;domain&amp;gt; represents the domain part
     *                                of the {@link ObjectName}&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;properties&amp;gt; represents the list of
     *                                properties, as returned by
     *                                {@link #getKeyPropertyListString}
     *                            &lt;li&gt;&amp;lt;wild&amp;gt; is empty if not
     *                                &lt;code&gt;isPropertyPattern&lt;/code&gt;, or
     *                                is the character &quot;&lt;code&gt;*&lt;/code&gt;&quot; if
     *                                this &lt;code&gt;isPropertyPattern&lt;/code&gt;
     *                                and &amp;lt;properties&amp;gt; is empty, or
     *                                is &quot;&lt;code&gt;,*&lt;/code&gt;&quot; if
     *                                &lt;code&gt;isPropertyPattern&lt;/code&gt; and
     *                                &amp;lt;properties&amp;gt; is not empty.
     *                            &lt;/li&gt;
     *                          &lt;/ul&gt;
     *                   The intent is that this string could be supplied
     *                   to the {@link #ObjectName(String)} constructor to
     *                   produce an equivalent {@link ObjectName}.
     *               &lt;/li&gt;
     *               &lt;li&gt;In the old serial form (value of property
     *                   &lt;code&gt;jmx.serial.form&lt;/code&gt; is
     *                   &lt;code&gt;1.0&lt;/code&gt;): &amp;lt;domain&amp;gt; &amp;lt;propertyList&amp;gt;
     *                   &amp;lt;propertyListString&amp;gt; &amp;lt;canonicalName&amp;gt;
     *                   &amp;lt;pattern&amp;gt; &amp;lt;propertyPattern&amp;gt;,
     *                   where: &lt;ul&gt;
     *                            &lt;li&gt;&amp;lt;domain&amp;gt; represents the domain part
     *                                of the {@link ObjectName}&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;propertyList&amp;gt; is the
     *                                {@link Hashtable} that contains all the
     *                                pairs (key,value) for this
     *                                {@link ObjectName}&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;propertyListString&amp;gt; is the
     *                                {@link String} representation of the
     *                                list of properties in any order (not
     *                                mandatorily a canonical representation)
     *                                &lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;canonicalName&amp;gt; is the
     *                                {@link String} containing this
     *                                {@link ObjectName}'s canonical name&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;pattern&amp;gt; is a boolean which is
     *                                &lt;code&gt;true&lt;/code&gt; if this
     *                                {@link ObjectName} contains a pattern&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;propertyPattern&amp;gt; is a boolean which
     *                                is &lt;code&gt;true&lt;/code&gt; if this
     *                                {@link ObjectName} contains a pattern in
     *                                the list of properties&lt;/li&gt;
     *                          &lt;/ul&gt;
     *               &lt;/li&gt;
     *             &lt;/ul&gt;
     */
    private void writeObject(ObjectOutputStream out)
            throws IOException {

      if (compat)
      {
        // Serializes this instance in the old serial form
        // Read CR 6441274 before making any changes to this code
        ObjectOutputStream.PutField fields = out.putFields();
        fields.put(&quot;domain&quot;, _canonicalName.substring(0, _domain_length));
        fields.put(&quot;propertyList&quot;, getKeyPropertyList());
        fields.put(&quot;propertyListString&quot;, getKeyPropertyListString());
        fields.put(&quot;canonicalName&quot;, _canonicalName);
        fields.put(&quot;pattern&quot;, (_domain_pattern || _property_list_pattern));
        fields.put(&quot;propertyPattern&quot;, _property_list_pattern);
        out.writeFields();
      }
      else
      {
        // Serializes this instance in the new serial form
        //
        out.defaultWriteObject();
        out.writeObject(getSerializedNameString());
      }
    }

    //  Category : Serialization &lt;===================================

    // Private methods &lt;========================================

    // Public methods ----------------------------------------&gt;

    // Category : ObjectName Construction ------------------------------&gt;

    /**
     * &lt;p&gt;Return an instance of ObjectName that can be used anywhere
     * an object obtained with {@link #ObjectName(String) new
     * ObjectName(name)} can be used.  The returned object may be of
     * a subclass of ObjectName.  Calling this method twice with the
     * same parameters may return the same object or two equal but
     * not identical objects.&lt;/p&gt;
     *
     * @param name  A string representation of the object name.
     *
     * @return an ObjectName corresponding to the given String.
     *
     * @exception MalformedObjectNameException The string passed as a
     * parameter does not have the right format.
     * @exception NullPointerException The &lt;code&gt;name&lt;/code&gt; parameter
     * is null.
     *
     */
    public static ObjectName getInstance(String name)
            throws MalformedObjectNameException, NullPointerException {
        return new ObjectName(name);
    }

    /**
     * &lt;p&gt;Return an instance of ObjectName that can be used anywhere
     * an object obtained with {@link #ObjectName(String, String,
     * String) new ObjectName(domain, key, value)} can be used.  The
     * returned object may be of a subclass of ObjectName.  Calling
     * this method twice with the same parameters may return the same
     * object or two equal but not identical objects.&lt;/p&gt;
     *
     * @param domain  The domain part of the object name.
     * @param key  The attribute in the key property of the object name.
     * @param value The value in the key property of the object name.
     *
     * @return an ObjectName corresponding to the given domain,
     * key, and value.
     *
     * @exception MalformedObjectNameException The
     * &lt;code&gt;domain&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;value&lt;/code&gt;
     * contains an illegal character, or &lt;code&gt;value&lt;/code&gt; does not
     * follow the rules for quoting.
     * @exception NullPointerException One of the parameters is null.
     *
     */
    public static ObjectName getInstance(String domain, String key,
                                         String value)
            throws MalformedObjectNameException {
        return new ObjectName(domain, key, value);
    }

    /**
     * &lt;p&gt;Return an instance of ObjectName that can be used anywhere
     * an object obtained with {@link #ObjectName(String, Hashtable)
     * new ObjectName(domain, table)} can be used.  The returned
     * object may be of a subclass of ObjectName.  Calling this method
     * twice with the same parameters may return the same object or
     * two equal but not identical objects.&lt;/p&gt;
     *
     * @param domain  The domain part of the object name.
     * @param table A hash table containing one or more key
     * properties.  The key of each entry in the table is the key of a
     * key property in the object name.  The associated value in the
     * table is the associated value in the object name.
     *
     * @return an ObjectName corresponding to the given domain and
     * key mappings.
     *
     * @exception MalformedObjectNameException The &lt;code&gt;domain&lt;/code&gt;
     * contains an illegal character, or one of the keys or values in
     * &lt;code&gt;table&lt;/code&gt; contains an illegal character, or one of the
     * values in &lt;code&gt;table&lt;/code&gt; does not follow the rules for
     * quoting.
     * @exception NullPointerException One of the parameters is null.
     *
     */
    public static ObjectName getInstance(String domain,
                                         Hashtable&lt;String,String&gt; table)
        throws MalformedObjectNameException {
        return new ObjectName(domain, table);
    }

    /**
     * &lt;p&gt;Return an instance of ObjectName that can be used anywhere
     * the given object can be used.  The returned object may be of a
     * subclass of ObjectName.  If &lt;code&gt;name&lt;/code&gt; is of a subclass
     * of ObjectName, it is not guaranteed that the returned object
     * will be of the same class.&lt;/p&gt;
     *
     * &lt;p&gt;The returned value may or may not be identical to
     * &lt;code&gt;name&lt;/code&gt;.  Calling this method twice with the same
     * parameters may return the same object or two equal but not
     * identical objects.&lt;/p&gt;
     *
     * &lt;p&gt;Since ObjectName is immutable, it is not usually useful to
     * make a copy of an ObjectName.  The principal use of this method
     * is to guard against a malicious caller who might pass an
     * instance of a subclass with surprising behavior to sensitive
     * code.  Such code can call this method to obtain an ObjectName
     * that is known not to have surprising behavior.&lt;/p&gt;
     *
     * @param name an instance of the ObjectName class or of a subclass
     *
     * @return an instance of ObjectName or a subclass that is known to
     * have the same semantics.  If &lt;code&gt;name&lt;/code&gt; respects the
     * semantics of ObjectName, then the returned object is equal
     * (though not necessarily identical) to &lt;code&gt;name&lt;/code&gt;.
     *
     * @exception NullPointerException The &lt;code&gt;name&lt;/code&gt; is null.
     *
     */
    public static ObjectName getInstance(ObjectName name) {
        if (name.getClass().equals(ObjectName.class))
            return name;
        return Util.newObjectName(name.getSerializedNameString());
    }

    /**
     * Construct an object name from the given string.
     *
     * @param name  A string representation of the object name.
     *
     * @exception MalformedObjectNameException The string passed as a
     * parameter does not have the right format.
     * @exception NullPointerException The &lt;code&gt;name&lt;/code&gt; parameter
     * is null.
     */
    public ObjectName(String name)
        throws MalformedObjectNameException {
        construct(name);
    }

    /**
     * Construct an object name with exactly one key property.
     *
     * @param domain  The domain part of the object name.
     * @param key  The attribute in the key property of the object name.
     * @param value The value in the key property of the object name.
     *
     * @exception MalformedObjectNameException The
     * &lt;code&gt;domain&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;value&lt;/code&gt;
     * contains an illegal character, or &lt;code&gt;value&lt;/code&gt; does not
     * follow the rules for quoting.
     * @exception NullPointerException One of the parameters is null.
     */
    public ObjectName(String domain, String key, String value)
        throws MalformedObjectNameException {
        // If key or value are null a NullPointerException
        // will be thrown by the put method in Hashtable.
        //
        Map&lt;String,String&gt; table = Collections.singletonMap(key, value);
        construct(domain, table);
    }

    /**
     * Construct an object name with several key properties from a Hashtable.
     *
     * @param domain  The domain part of the object name.
     * @param table A hash table containing one or more key
     * properties.  The key of each entry in the table is the key of a
     * key property in the object name.  The associated value in the
     * table is the associated value in the object name.
     *
     * @exception MalformedObjectNameException The &lt;code&gt;domain&lt;/code&gt;
     * contains an illegal character, or one of the keys or values in
     * &lt;code&gt;table&lt;/code&gt; contains an illegal character, or one of the
     * values in &lt;code&gt;table&lt;/code&gt; does not follow the rules for
     * quoting.
     * @exception NullPointerException One of the parameters is null.
     */
    public ObjectName(String domain, Hashtable&lt;String,String&gt; table)
            throws MalformedObjectNameException {
        construct(domain, table);
        /* The exception for when a key or value in the table is not a
           String is now ClassCastException rather than
           MalformedObjectNameException.  This was not previously
           specified.  */
    }

    // Category : ObjectName Construction &lt;==============================


    // Category : Getter methods ------------------------------&gt;

    /**
     * Checks whether the object name is a pattern.
     * &lt;p&gt;
     * An object name is a pattern if its domain contains a
     * wildcard or if the object name is a property pattern.
     *
     * @return  True if the name is a pattern, otherwise false.
     */
    public boolean isPattern() {
        return (_domain_pattern ||
                _property_list_pattern ||
                _property_value_pattern);
    }

    /**
     * Checks whether the object name is a pattern on the domain part.
     *
     * @return  True if the name is a domain pattern, otherwise false.
     *
     */
    public boolean isDomainPattern() {
        return _domain_pattern;
    }

    /**
     * Checks whether the object name is a pattern on the key properties.
     * &lt;p&gt;
     * An object name is a pattern on the key properties if it is a
     * pattern on the key property list (e.g. &quot;d:k=v,*&quot;) or on the
     * property values (e.g. &quot;d:k=*&quot;) or on both (e.g. &quot;d:k=*,*&quot;).
     *
     * @return  True if the name is a property pattern, otherwise false.
     */
    public boolean isPropertyPattern() {
        return _property_list_pattern || _property_value_pattern;
    }

    /**
     * Checks whether the object name is a pattern on the key property list.
     * &lt;p&gt;
     * For example, &quot;d:k=v,*&quot; and &quot;d:k=*,*&quot; are key property list patterns
     * whereas &quot;d:k=*&quot; is not.
     *
     * @return  True if the name is a property list pattern, otherwise false.
     *
     * @since 1.6
     */
    public boolean isPropertyListPattern() {
        return _property_list_pattern;
    }

    /**
     * Checks whether the object name is a pattern on the value part
     * of at least one of the key properties.
     * &lt;p&gt;
     * For example, &quot;d:k=*&quot; and &quot;d:k=*,*&quot; are property value patterns
     * whereas &quot;d:k=v,*&quot; is not.
     *
     * @return  True if the name is a property value pattern, otherwise false.
     *
     * @since 1.6
     */
    public boolean isPropertyValuePattern() {
        return _property_value_pattern;
    }

    /**
     * Checks whether the value associated with a key in a key
     * property is a pattern.
     *
     * @param property The property whose value is to be checked.
     *
     * @return True if the value associated with the given key property
     * is a pattern, otherwise false.
     *
     * @exception NullPointerException If &lt;code&gt;property&lt;/code&gt; is null.
     * @exception IllegalArgumentException If &lt;code&gt;property&lt;/code&gt; is not
     * a valid key property for this ObjectName.
     *
     * @since 1.6
     */
    public boolean isPropertyValuePattern(String property) {
        if (property == null)
            throw new NullPointerException(&quot;key property can't be null&quot;);
        for (int i = 0; i &lt; _ca_array.length; i++) {
            Property prop = _ca_array[i];
            String key = prop.getKeyString(_canonicalName);
            if (key.equals(property))
                return (prop instanceof PatternProperty);
        }
        throw new IllegalArgumentException(&quot;key property not found&quot;);
    }

    /**
     * &lt;p&gt;Returns the canonical form of the name; that is, a string
     * representation where the properties are sorted in lexical
     * order.&lt;/p&gt;
     *
     * &lt;p&gt;More precisely, the canonical form of the name is a String
     * consisting of the &lt;em&gt;domain part&lt;/em&gt;, a colon
     * (&lt;code&gt;:&lt;/code&gt;), the &lt;em&gt;canonical key property list&lt;/em&gt;, and
     * a &lt;em&gt;pattern indication&lt;/em&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;The &lt;em&gt;canonical key property list&lt;/em&gt; is the same string
     * as described for {@link #getCanonicalKeyPropertyListString()}.&lt;/p&gt;
     *
     * &lt;p&gt;The &lt;em&gt;pattern indication&lt;/em&gt; is:
     * &lt;ul&gt;
     * &lt;li&gt;empty for an ObjectName
     * that is not a property list pattern;
     * &lt;li&gt;an asterisk for an ObjectName
     * that is a property list pattern with no keys; or
     * &lt;li&gt;a comma and an
     * asterisk (&lt;code&gt;,*&lt;/code&gt;) for an ObjectName that is a property
     * list pattern with at least one key.
     * &lt;/ul&gt;
     *
     * @return The canonical form of the name.
     */
    public String getCanonicalName()  {
        return _canonicalName;
    }

    /**
     * Returns the domain part.
     *
     * @return The domain.
     */
    public String getDomain()  {
        return _canonicalName.substring(0, _domain_length);
    }

    /**
     * Obtains the value associated with a key in a key property.
     *
     * @param property The property whose value is to be obtained.
     *
     * @return The value of the property, or null if there is no such
     * property in this ObjectName.
     *
     * @exception NullPointerException If &lt;code&gt;property&lt;/code&gt; is null.
     */
    public String getKeyProperty(String property) {
        return _getKeyPropertyList().get(property);
    }

    /**
     * &lt;p&gt;Returns the key properties as a Map.  The returned
     * value is a Map in which each key is a key in the
     * ObjectName's key property list and each value is the associated
     * value.&lt;/p&gt;
     *
     * &lt;p&gt;The returned value must not be modified.&lt;/p&gt;
     *
     * @return The table of key properties.
     */
    private Map&lt;String,String&gt; _getKeyPropertyList()  {
        synchronized (this) {
            if (_propertyList == null) {
                // build (lazy eval) the property list from the canonical
                // properties array
                _propertyList = new HashMap&lt;String,String&gt;();
                int len = _ca_array.length;
                Property prop;
                for (int i = len - 1; i &gt;= 0; i--) {
                    prop = _ca_array[i];
                    _propertyList.put(prop.getKeyString(_canonicalName),
                                      prop.getValueString(_canonicalName));
                }
            }
        }
        return _propertyList;
    }

    /**
     * &lt;p&gt;Returns the key properties as a Hashtable.  The returned
     * value is a Hashtable in which each key is a key in the
     * ObjectName's key property list and each value is the associated
     * value.&lt;/p&gt;
     *
     * &lt;p&gt;The returned value may be unmodifiable.  If it is
     * modifiable, changing it has no effect on this ObjectName.&lt;/p&gt;
     *
     * @return The table of key properties.
     */
    // CR 6441274 depends on the modification property defined above
    public Hashtable&lt;String,String&gt; getKeyPropertyList()  {
        return new Hashtable&lt;String,String&gt;(_getKeyPropertyList());
    }

    /**
     * &lt;p&gt;Returns a string representation of the list of key
     * properties specified at creation time.  If this ObjectName was
     * constructed with the constructor {@link #ObjectName(String)},
     * the key properties in the returned String will be in the same
     * order as in the argument to the constructor.&lt;/p&gt;
     *
     * @return The key property list string.  This string is
     * independent of whether the ObjectName is a pattern.
     */
    public String getKeyPropertyListString()  {
        // BEWARE : we rebuild the propertyliststring at each call !!
        if (_kp_array.length == 0) return &quot;&quot;;

        // the size of the string is the canonical one minus domain
        // part and pattern part
        final int total_size = _canonicalName.length() - _domain_length - 1
            - (_property_list_pattern?2:0);

        final char[] dest_chars = new char[total_size];
        final char[] value = _canonicalName.toCharArray();
        writeKeyPropertyListString(value,dest_chars,0);
        return new String(dest_chars);
    }

    /**
     * &lt;p&gt;Returns the serialized string of the ObjectName.
     * properties specified at creation time.  If this ObjectName was
     * constructed with the constructor {@link #ObjectName(String)},
     * the key properties in the returned String will be in the same
     * order as in the argument to the constructor.&lt;/p&gt;
     *
     * @return The key property list string.  This string is
     * independent of whether the ObjectName is a pattern.
     */
    private String getSerializedNameString()  {

        // the size of the string is the canonical one
        final int total_size = _canonicalName.length();
        final char[] dest_chars = new char[total_size];
        final char[] value = _canonicalName.toCharArray();
        final int offset = _domain_length+1;

        // copy &quot;domain:&quot; into dest_chars
        //
        System.arraycopy(value, 0, dest_chars, 0, offset);

        // Add property list string
        final int end = writeKeyPropertyListString(value,dest_chars,offset);

        // Add &quot;,*&quot; if necessary
        if (_property_list_pattern) {
            if (end == offset)  {
                // Property list string is empty.
                dest_chars[end] = '*';
            } else {
                // Property list string is not empty.
                dest_chars[end]   = ',';
                dest_chars[end+1] = '*';
            }
        }

        return new String(dest_chars);
    }

    /**
     * &lt;p&gt;Write a string representation of the list of key
     * properties specified at creation time in the given array, starting
     * at the specified offset.  If this ObjectName was
     * constructed with the constructor {@link #ObjectName(String)},
     * the key properties in the returned String will be in the same
     * order as in the argument to the constructor.&lt;/p&gt;
     *
     * @return offset + #of chars written
     */
    private int writeKeyPropertyListString(char[] canonicalChars,
                                           char[] data, int offset)  {
        if (_kp_array.length == 0) return offset;

        final char[] dest_chars = data;
        final char[] value = canonicalChars;

        int index = offset;
        final int len = _kp_array.length;
        final int last = len - 1;
        for (int i = 0; i &lt; len; i++) {
            final Property prop = _kp_array[i];
            final int prop_len = prop._key_length + prop._value_length + 1;
            System.arraycopy(value, prop._key_index, dest_chars, index,
                             prop_len);
            index += prop_len;
            if (i &lt; last ) dest_chars[index++] = ',';
        }
        return index;
    }



    /**
     * Returns a string representation of the list of key properties,
     * in which the key properties are sorted in lexical order. This
     * is used in lexicographic comparisons performed in order to
     * select MBeans based on their key property list.  Lexical order
     * is the order implied by {@link String#compareTo(String)
     * String.compareTo(String)}.
     *
     * @return The canonical key property list string.  This string is
     * independent of whether the ObjectName is a pattern.
     */
    public String getCanonicalKeyPropertyListString()  {
        if (_ca_array.length == 0) return &quot;&quot;;

        int len = _canonicalName.length();
        if (_property_list_pattern) len -= 2;
        return _canonicalName.substring(_domain_length +1, len);
    }
    // Category : Getter methods &lt;===================================

    // Category : Utilities ----------------------------------------&gt;

    /**
     * &lt;p&gt;Returns a string representation of the object name.  The
     * format of this string is not specified, but users can expect
     * that two ObjectNames return the same string if and only if they
     * are equal.&lt;/p&gt;
     *
     * @return a string representation of this object name.
     */
    @Override
    public String toString()  {
        return getSerializedNameString();
    }

    /**
     * Compares the current object name with another object name.  Two
     * ObjectName instances are equal if and only if their canonical
     * forms are equal.  The canonical form is the string described
     * for {@link #getCanonicalName()}.
     *
     * @param object  The object name that the current object name is to be
     *        compared with.
     *
     * @return True if &lt;code&gt;object&lt;/code&gt; is an ObjectName whose
     * canonical form is equal to that of this ObjectName.
     */
    @Override
    public boolean equals(Object object)  {

        // same object case
        if (this == object) return true;

        // object is not an object name case
        if (!(object instanceof ObjectName)) return false;

        // equality when canonical names are the same
        // (because usage of intern())
        ObjectName on = (ObjectName) object;
        String on_string = on._canonicalName;
        if (_canonicalName == on_string) return true;  // ES: OK

        // Because we are sharing canonical form between object names,
        // we have finished the comparison at this stage ==&gt; unequal
        return false;
   }

    /**
     * Returns a hash code for this object name.
     *
     */
    @Override
    public int hashCode() {
        return _canonicalName.hashCode();
    }

    /**
     * &lt;p&gt;Returns a quoted form of the given String, suitable for
     * inclusion in an ObjectName.  The returned value can be used as
     * the value associated with a key in an ObjectName.  The String
     * &lt;code&gt;s&lt;/code&gt; may contain any character.  Appropriate quoting
     * ensures that the returned value is legal in an ObjectName.&lt;/p&gt;
     *
     * &lt;p&gt;The returned value consists of a quote ('&quot;'), a sequence of
     * characters corresponding to the characters of &lt;code&gt;s&lt;/code&gt;,
     * and another quote.  Characters in &lt;code&gt;s&lt;/code&gt; appear
     * unchanged within the returned value except:&lt;/p&gt;
     *
     * &lt;ul&gt;
     * &lt;li&gt;A quote ('&quot;') is replaced by a backslash (\) followed by a quote.&lt;/li&gt;
     * &lt;li&gt;An asterisk ('*') is replaced by a backslash (\) followed by an
     * asterisk.&lt;/li&gt;
     * &lt;li&gt;A question mark ('?') is replaced by a backslash (\) followed by
     * a question mark.&lt;/li&gt;
     * &lt;li&gt;A backslash ('\') is replaced by two backslashes.&lt;/li&gt;
     * &lt;li&gt;A newline character (the character '\n' in Java) is replaced
     * by a backslash followed by the character '\n'.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param s the String to be quoted.
     *
     * @return the quoted String.
     *
     * @exception NullPointerException if &lt;code&gt;s&lt;/code&gt; is null.
     *
     */
    public static String quote(String s) {
        final StringBuilder buf = new StringBuilder(&quot;\&quot;&quot;);
        final int len = s.length();
        for (int i = 0; i &lt; len; i++) {
            char c = s.charAt(i);
            switch (c) {
            case '\n':
                c = 'n';
                buf.append('\\');
                break;
            case '\\':
            case '\&quot;':
            case '*':
            case '?':
                buf.append('\\');
                break;
            }
            buf.append(c);
        }
        buf.append('&quot;');
        return buf.toString();
    }

    /**
     * &lt;p&gt;Returns an unquoted form of the given String.  If
     * &lt;code&gt;q&lt;/code&gt; is a String returned by {@link #quote quote(s)},
     * then &lt;code&gt;unquote(q).equals(s)&lt;/code&gt;.  If there is no String
     * &lt;code&gt;s&lt;/code&gt; for which &lt;code&gt;quote(s).equals(q)&lt;/code&gt;, then
     * unquote(q) throws an IllegalArgumentException.&lt;/p&gt;
     *
     * &lt;p&gt;These rules imply that there is a one-to-one mapping between
     * quoted and unquoted forms.&lt;/p&gt;
     *
     * @param q the String to be unquoted.
     *
     * @return the unquoted String.
     *
     * @exception IllegalArgumentException if &lt;code&gt;q&lt;/code&gt; could not
     * have been returned by the {@link #quote} method, for instance
     * if it does not begin and end with a quote (&quot;).
     *
     * @exception NullPointerException if &lt;code&gt;q&lt;/code&gt; is null.
     *
     */
    public static String unquote(String q) {
        final StringBuilder buf = new StringBuilder();
        final int len = q.length();
        if (len &lt; 2 || q.charAt(0) != '&quot;' || q.charAt(len - 1) != '&quot;')
            throw new IllegalArgumentException(&quot;Argument not quoted&quot;);
        for (int i = 1; i &lt; len - 1; i++) {
            char c = q.charAt(i);
            if (c == '\\') {
                if (i == len - 2)
                    throw new IllegalArgumentException(&quot;Trailing backslash&quot;);
                c = q.charAt(++i);
                switch (c) {
                case 'n':
                    c = '\n';
                    break;
                case '\\':
                case '\&quot;':
                case '*':
                case '?':
                    break;
                default:
                  throw new IllegalArgumentException(
                                   &quot;Bad character '&quot; + c + &quot;' after backslash&quot;);
                }
            } else {
                switch (c) {
                    case '*' :
                    case '?' :
                    case '\&quot;':
                    case '\n':
                         throw new IllegalArgumentException(
                                          &quot;Invalid unescaped character '&quot; + c +
                                          &quot;' in the string to unquote&quot;);
                }
            }
            buf.append(c);
        }
        return buf.toString();
    }

    /**
     * Defines the wildcard &quot;*:*&quot; ObjectName.
     *
     * @since 1.6
     */
    public static final ObjectName WILDCARD = Util.newObjectName(&quot;*:*&quot;);

    // Category : Utilities &lt;===================================

    // Category : QueryExp Interface ----------------------------------------&gt;

    /**
     * &lt;p&gt;Test whether this ObjectName, which may be a pattern,
     * matches another ObjectName.  If &lt;code&gt;name&lt;/code&gt; is a pattern,
     * the result is false.  If this ObjectName is a pattern, the
     * result is true if and only if &lt;code&gt;name&lt;/code&gt; matches the
     * pattern.  If neither this ObjectName nor &lt;code&gt;name&lt;/code&gt; is
     * a pattern, the result is true if and only if the two
     * ObjectNames are equal as described for the {@link
     * #equals(Object)} method.&lt;/p&gt;
     *
     * @param name The name of the MBean to compare to.
     *
     * @return True if &lt;code&gt;name&lt;/code&gt; matches this ObjectName.
     *
     * @exception NullPointerException if &lt;code&gt;name&lt;/code&gt; is null.
     *
     */
    public boolean apply(ObjectName name) {

        if (name == null) throw new NullPointerException();

        if (name._domain_pattern ||
            name._property_list_pattern ||
            name._property_value_pattern)
            return false;

        // No pattern
        if (!_domain_pattern &amp;&amp;
            !_property_list_pattern &amp;&amp;
            !_property_value_pattern)
            return _canonicalName.equals(name._canonicalName);

        return matchDomains(name) &amp;&amp; matchKeys(name);
    }

    private final boolean matchDomains(ObjectName name) {
        if (_domain_pattern) {
            // wildmatch domains
            // This ObjectName is the pattern
            // The other ObjectName is the string.
            return Util.wildmatch(name.getDomain(),getDomain());
        }
        return getDomain().equals(name.getDomain());
    }

    private final boolean matchKeys(ObjectName name) {
        // If key property value pattern but not key property list
        // pattern, then the number of key properties must be equal
        //
        if (_property_value_pattern &amp;&amp;
            !_property_list_pattern &amp;&amp;
            (name._ca_array.length != _ca_array.length))
                return false;

        // If key property value pattern or key property list pattern,
        // then every property inside pattern should exist in name
        //
        if (_property_value_pattern || _property_list_pattern) {
            final Map&lt;String,String&gt; nameProps = name._getKeyPropertyList();
            final Property[] props = _ca_array;
            final String cn = _canonicalName;
            for (int i = props.length - 1; i &gt;= 0 ; i--) {
                // Find value in given object name for key at current
                // index in receiver
                //
                final Property p = props[i];
                final String   k = p.getKeyString(cn);
                final String   v = nameProps.get(k);
                // Did we find a value for this key ?
                //
                if (v == null) return false;
                // If this property is ok (same key, same value), go to next
                //
                if (_property_value_pattern &amp;&amp; (p instanceof PatternProperty)) {
                    // wildmatch key property values
                    // p is the property pattern, v is the string
                    if (Util.wildmatch(v,p.getValueString(cn)))
                        continue;
                    else
                        return false;
                }
                if (v.equals(p.getValueString(cn))) continue;
                return false;
            }
            return true;
        }

        // If no pattern, then canonical names must be equal
        //
        final String p1 = name.getCanonicalKeyPropertyListString();
        final String p2 = getCanonicalKeyPropertyListString();
        return (p1.equals(p2));
    }

    /* Method inherited from QueryExp, no implementation needed here
       because ObjectName is not relative to an MBeanServer and does
       not contain a subquery.
    */
    public void setMBeanServer(MBeanServer mbs) { }

    // Category : QueryExp Interface &lt;=========================

    // Category : Comparable Interface ----------------------------------------&gt;

    /**
     * &lt;p&gt;Compares two ObjectName instances. The ordering relation between
     * ObjectNames is not completely specified but is intended to be such
     * that a sorted list of ObjectNames will appear in an order that is
     * convenient for a person to read.&lt;/p&gt;
     *
     * &lt;p&gt;In particular, if the two ObjectName instances have different
     * domains then their order is the lexicographical order of the domains.
     * The ordering of the key property list remains unspecified.&lt;/p&gt;
     *
     * &lt;p&gt;For example, the ObjectName instances below:&lt;/p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;Shapes:type=Square,name=3&lt;/li&gt;
     * &lt;li&gt;Colors:type=Red,name=2&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Triangle,side=isosceles,name=2&lt;/li&gt;
     * &lt;li&gt;Colors:type=Red,name=1&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Square,name=1&lt;/li&gt;
     * &lt;li&gt;Colors:type=Blue,name=1&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Square,name=2&lt;/li&gt;
     * &lt;li&gt;JMImplementation:type=MBeanServerDelegate&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Triangle,side=scalene,name=1&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;could be ordered as follows:&lt;/p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;Colors:type=Blue,name=1&lt;/li&gt;
     * &lt;li&gt;Colors:type=Red,name=1&lt;/li&gt;
     * &lt;li&gt;Colors:type=Red,name=2&lt;/li&gt;
     * &lt;li&gt;JMImplementation:type=MBeanServerDelegate&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Square,name=1&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Square,name=2&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Square,name=3&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Triangle,side=scalene,name=1&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Triangle,side=isosceles,name=2&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param name the ObjectName to be compared.
     *
     * @return a negative integer, zero, or a positive integer as this
     *         ObjectName is less than, equal to, or greater than the
     *         specified ObjectName.
     *
     * @since 1.6
     */
    public int compareTo(ObjectName name) {
        // Quick optimization:
        //
        if (name == this) return 0;

        // (1) Compare domains
        //
        int domainValue = this.getDomain().compareTo(name.getDomain());
        if (domainValue != 0)
            return domainValue;

        // (2) Compare &quot;type=&quot; keys
        //
        // Within a given domain, all names with missing or empty &quot;type=&quot;
        // come before all names with non-empty type.
        //
        // When both types are missing or empty, canonical-name ordering
        // applies which is a total order.
        //
        String thisTypeKey = this.getKeyProperty(&quot;type&quot;);
        String anotherTypeKey = name.getKeyProperty(&quot;type&quot;);
        if (thisTypeKey == null)
            thisTypeKey = &quot;&quot;;
        if (anotherTypeKey == null)
            anotherTypeKey = &quot;&quot;;
        int typeKeyValue = thisTypeKey.compareTo(anotherTypeKey);
        if (typeKeyValue != 0)
            return typeKeyValue;

        // (3) Compare canonical names
        //
        return this.getCanonicalName().compareTo(name.getCanonicalName());
    }

    // Category : Comparable Interface &lt;=========================

    // Public methods &lt;========================================

}
</pre>
</body>
</html>
