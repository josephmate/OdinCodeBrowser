<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management.openmbean;

import com.sun.jmx.mbeanserver.GetPropertyAction;
import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import javax.management.Descriptor;
import javax.management.ImmutableDescriptor;

/**
 * The &lt;code&gt;OpenType&lt;/code&gt; class is the parent abstract class of all classes which describe the actual &lt;i&gt;open type&lt;/i&gt;
 * of open data values.
 * &lt;p&gt;
 * An &lt;i&gt;open type&lt;/i&gt; is defined by:
 * &lt;ul&gt;
 *  &lt;li&gt;the fully qualified Java class name of the open data values this type describes;
 *      note that only a limited set of Java classes is allowed for open data values
 *      (see {@link #ALLOWED_CLASSNAMES_LIST ALLOWED_CLASSNAMES_LIST}),&lt;/li&gt;
 *  &lt;li&gt;its name,&lt;/li&gt;
 *  &lt;li&gt;its description.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @param &lt;T&gt; the Java type that instances described by this type must
 * have.  For example, {@link SimpleType#INTEGER} is a {@code
 * SimpleType&lt;Integer&gt;} which is a subclass of {@code OpenType&lt;Integer&gt;},
 * meaning that an attribute, parameter, or return value that is described
 * as a {@code SimpleType.INTEGER} must have Java type
 * {@link Integer}.
 *
 * @since 1.5
 */
public abstract class OpenType&lt;T&gt; implements Serializable {

    /* Serial version */
    static final long serialVersionUID = -9195195325186646468L;


    /**
     * List of the fully qualified names of the Java classes allowed for open
     * data values. A multidimensional array of any one of these classes or
     * their corresponding primitive types is also an allowed class for open
     * data values.
     *
       &lt;pre&gt;ALLOWED_CLASSNAMES_LIST = {
        &quot;java.lang.Void&quot;,
        &quot;java.lang.Boolean&quot;,
        &quot;java.lang.Character&quot;,
        &quot;java.lang.Byte&quot;,
        &quot;java.lang.Short&quot;,
        &quot;java.lang.Integer&quot;,
        &quot;java.lang.Long&quot;,
        &quot;java.lang.Float&quot;,
        &quot;java.lang.Double&quot;,
        &quot;java.lang.String&quot;,
        &quot;java.math.BigDecimal&quot;,
        &quot;java.math.BigInteger&quot;,
        &quot;java.util.Date&quot;,
        &quot;javax.management.ObjectName&quot;,
        CompositeData.class.getName(),
        TabularData.class.getName() } ;
       &lt;/pre&gt;
     *
     */
    public static final List&lt;String&gt; ALLOWED_CLASSNAMES_LIST =
      Collections.unmodifiableList(
        Arrays.asList(
          &quot;java.lang.Void&quot;,
          &quot;java.lang.Boolean&quot;,
          &quot;java.lang.Character&quot;,
          &quot;java.lang.Byte&quot;,
          &quot;java.lang.Short&quot;,
          &quot;java.lang.Integer&quot;,
          &quot;java.lang.Long&quot;,
          &quot;java.lang.Float&quot;,
          &quot;java.lang.Double&quot;,
          &quot;java.lang.String&quot;,
          &quot;java.math.BigDecimal&quot;,
          &quot;java.math.BigInteger&quot;,
          &quot;java.util.Date&quot;,
          &quot;javax.management.ObjectName&quot;,
          CompositeData.class.getName(),        // better refer to these two class names like this, rather than hardcoding a string,
          TabularData.class.getName()) );       // in case the package of these classes should change (who knows...)


    /**
     * @deprecated Use {@link #ALLOWED_CLASSNAMES_LIST ALLOWED_CLASSNAMES_LIST} instead.
     */
    @Deprecated
    public static final String[] ALLOWED_CLASSNAMES =
        ALLOWED_CLASSNAMES_LIST.toArray(new String[0]);


    /**
     * @serial The fully qualified Java class name of open data values this
     *         type describes.
     */
    private String className;

    /**
     * @serial The type description (should not be null or empty).
     */
    private String description;

    /**
     * @serial The name given to this type (should not be null or empty).
     */
    private String typeName;

    /**
     * Tells if this type describes an array (checked in constructor).
     */
    private transient boolean isArray = false;

    /**
     * Cached Descriptor for this OpenType, constructed on demand.
     */
    private transient Descriptor descriptor;

    /* *** Constructor *** */

    /**
     * Constructs an &lt;code&gt;OpenType&lt;/code&gt; instance (actually a subclass instance as &lt;code&gt;OpenType&lt;/code&gt; is abstract),
     * checking for the validity of the given parameters.
     * The validity constraints are described below for each parameter.
     * &lt;br&gt;&amp;nbsp;
     * @param  className  The fully qualified Java class name of the open data values this open type describes.
     *                    The valid Java class names allowed for open data values are listed in
     *                    {@link #ALLOWED_CLASSNAMES_LIST ALLOWED_CLASSNAMES_LIST}.
     *                    A multidimensional array of any one of these classes
     *                    or their corresponding primitive types is also an allowed class,
     *                    in which case the class name follows the rules defined by the method
     *                    {@link Class#getName() getName()} of &lt;code&gt;java.lang.Class&lt;/code&gt;.
     *                    For example, a 3-dimensional array of Strings has for class name
     *                    &amp;quot;&lt;code&gt;[[[Ljava.lang.String;&lt;/code&gt;&amp;quot; (without the quotes).
     * &lt;br&gt;&amp;nbsp;
     * @param  typeName  The name given to the open type this instance represents; cannot be a null or empty string.
     * &lt;br&gt;&amp;nbsp;
     * @param  description  The human readable description of the open type this instance represents;
     *                      cannot be a null or empty string.
     * &lt;br&gt;&amp;nbsp;
     * @throws IllegalArgumentException  if &lt;var&gt;className&lt;/var&gt;, &lt;var&gt;typeName&lt;/var&gt; or &lt;var&gt;description&lt;/var&gt;
     *                                   is a null or empty string
     * &lt;br&gt;&amp;nbsp;
     * @throws OpenDataException  if &lt;var&gt;className&lt;/var&gt; is not one of the allowed Java class names for open data
     */
    protected OpenType(String  className,
                       String  typeName,
                       String  description) throws OpenDataException {
        checkClassNameOverride();
        this.typeName = valid(&quot;typeName&quot;, typeName);
        this.description = valid(&quot;description&quot;, description);
        this.className = validClassName(className);
        this.isArray = (this.className != null &amp;&amp; this.className.startsWith(&quot;[&quot;));
    }

    /* Package-private constructor for callers we trust to get it right. */
    OpenType(String className, String typeName, String description,
             boolean isArray) {
        this.className   = valid(&quot;className&quot;,className);
        this.typeName    = valid(&quot;typeName&quot;, typeName);
        this.description = valid(&quot;description&quot;, description);
        this.isArray     = isArray;
    }

    private void checkClassNameOverride() throws SecurityException {
        if (this.getClass().getClassLoader() == null)
            return;  // We trust bootstrap classes.
        if (overridesGetClassName(this.getClass())) {
            final GetPropertyAction getExtendOpenTypes =
                new GetPropertyAction(&quot;jmx.extend.open.types&quot;);
            if (AccessController.doPrivileged(getExtendOpenTypes) == null) {
                throw new SecurityException(&quot;Cannot override getClassName() &quot; +
                        &quot;unless -Djmx.extend.open.types&quot;);
            }
        }
    }

    private static boolean overridesGetClassName(final Class&lt;?&gt; c) {
        return AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() {
            public Boolean run() {
                try {
                    return (c.getMethod(&quot;getClassName&quot;).getDeclaringClass() !=
                            OpenType.class);
                } catch (Exception e) {
                    return true;  // fail safe
                }
            }
        });
    }

    private static String validClassName(String className) throws OpenDataException {
        className   = valid(&quot;className&quot;, className);

        // Check if className describes an array class, and determines its elements' class name.
        // (eg: a 3-dimensional array of Strings has for class name: &quot;[[[Ljava.lang.String;&quot;)
        //
        int n = 0;
        while (className.startsWith(&quot;[&quot;, n)) {
            n++;
        }
        String eltClassName; // class name of array elements
        boolean isPrimitiveArray = false;
        if (n &gt; 0) {
            if (className.startsWith(&quot;L&quot;, n) &amp;&amp; className.endsWith(&quot;;&quot;)) {
                // removes the n leading '[' + the 'L' characters
                // and the last ';' character
                eltClassName = className.substring(n+1, className.length()-1);
            } else if (n == className.length() - 1) {
                // removes the n leading '[' characters
                eltClassName = className.substring(n, className.length());
                isPrimitiveArray = true;
            } else {
                throw new OpenDataException(&quot;Argument className=\&quot;&quot; + className +
                        &quot;\&quot; is not a valid class name&quot;);
            }
        } else {
            // not an array
            eltClassName = className;
        }

        // Check that eltClassName's value is one of the allowed basic data types for open data
        //
        boolean ok = false;
        if (isPrimitiveArray) {
            ok = ArrayType.isPrimitiveContentType(eltClassName);
        } else {
            ok = ALLOWED_CLASSNAMES_LIST.contains(eltClassName);
        }
        if ( ! ok ) {
            throw new OpenDataException(&quot;Argument className=\&quot;&quot;+ className +
                                        &quot;\&quot; is not one of the allowed Java class names for open data.&quot;);
        }

        return className;
    }

    /* Return argValue.trim() provided argValue is neither null nor empty;
       otherwise throw IllegalArgumentException.  */
    private static String valid(String argName, String argValue) {
        if (argValue == null || (argValue = argValue.trim()).equals(&quot;&quot;))
            throw new IllegalArgumentException(&quot;Argument &quot; + argName +
                                               &quot; cannot be null or empty&quot;);
        return argValue;
    }

    /* Package-private access to a Descriptor containing this OpenType. */
    synchronized Descriptor getDescriptor() {
        if (descriptor == null) {
            descriptor = new ImmutableDescriptor(new String[] {&quot;openType&quot;},
                                                 new Object[] {this});
        }
        return descriptor;
    }

    /* *** Open type information methods *** */

    /**
     * Returns the fully qualified Java class name of the open data values
     * this open type describes.
     * The only possible Java class names for open data values are listed in
     * {@link #ALLOWED_CLASSNAMES_LIST ALLOWED_CLASSNAMES_LIST}.
     * A multidimensional array of any one of these classes or their
     * corresponding primitive types is also an allowed class,
     * in which case the class name follows the rules defined by the method
     * {@link Class#getName() getName()} of &lt;code&gt;java.lang.Class&lt;/code&gt;.
     * For example, a 3-dimensional array of Strings has for class name
     * &amp;quot;&lt;code&gt;[[[Ljava.lang.String;&lt;/code&gt;&amp;quot; (without the quotes),
     * a 3-dimensional array of Integers has for class name
     * &amp;quot;&lt;code&gt;[[[Ljava.lang.Integer;&lt;/code&gt;&amp;quot; (without the quotes),
     * and a 3-dimensional array of int has for class name
     * &amp;quot;&lt;code&gt;[[[I&lt;/code&gt;&amp;quot; (without the quotes)
     *
     * @return the class name.
     */
    public String getClassName() {
        return className;
    }

    // A version of getClassName() that can only be called from within this
    // package and that cannot be overridden.
    String safeGetClassName() {
        return className;
    }

    /**
     * Returns the name of this &lt;code&gt;OpenType&lt;/code&gt; instance.
     *
     * @return the type name.
     */
    public String getTypeName() {

        return typeName;
    }

    /**
     * Returns the text description of this &lt;code&gt;OpenType&lt;/code&gt; instance.
     *
     * @return the description.
     */
    public String getDescription() {

        return description;
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the open data values this open
     * type describes are arrays, &lt;code&gt;false&lt;/code&gt; otherwise.
     *
     * @return true if this is an array type.
     */
    public boolean isArray() {

        return isArray;
    }

    /**
     * Tests whether &lt;var&gt;obj&lt;/var&gt; is a value for this open type.
     *
     * @param obj the object to be tested for validity.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;var&gt;obj&lt;/var&gt; is a value for this
     * open type, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public abstract boolean isValue(Object obj) ;

    /**
     * Tests whether values of the given type can be assigned to this open type.
     * The default implementation of this method returns true only if the
     * types are equal.
     *
     * @param ot the type to be tested.
     *
     * @return true if {@code ot} is assignable to this open type.
     */
    boolean isAssignableFrom(OpenType&lt;?&gt; ot) {
        return this.equals(ot);
    }

    /* *** Methods overriden from class Object *** */

    /**
     * Compares the specified &lt;code&gt;obj&lt;/code&gt; parameter with this
     * open type instance for equality.
     *
     * @param obj the object to compare to.
     *
     * @return true if this object and &lt;code&gt;obj&lt;/code&gt; are equal.
     */
    public abstract boolean equals(Object obj) ;

    public abstract int hashCode() ;

    /**
     * Returns a string representation of this open type instance.
     *
     * @return the string representation.
     */
    public abstract String toString() ;

    /**
     * Deserializes an {@link OpenType} from an {@link java.io.ObjectInputStream}.
     */
    private void readObject(ObjectInputStream in)
            throws IOException, ClassNotFoundException {
        checkClassNameOverride();
        ObjectInputStream.GetField fields = in.readFields();
        final String classNameField;
        final String descriptionField;
        final String typeNameField;
        try {
            classNameField =
                validClassName((String) fields.get(&quot;className&quot;, null));
            descriptionField =
                valid(&quot;description&quot;, (String) fields.get(&quot;description&quot;, null));
            typeNameField =
                valid(&quot;typeName&quot;, (String) fields.get(&quot;typeName&quot;, null));
        } catch (Exception e) {
            IOException e2 = new InvalidObjectException(e.getMessage());
            e2.initCause(e);
            throw e2;
        }
        className = classNameField;
        description = descriptionField;
        typeName = typeNameField;
        isArray = (className.startsWith(&quot;[&quot;));
    }
}
</pre>
</body>
</html>
