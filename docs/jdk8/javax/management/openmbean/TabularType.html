<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package javax.management.openmbean;


// java import
//
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

// jmx import
//


/**
 * The &lt;code&gt;TabularType&lt;/code&gt; class is the &lt;i&gt; open type&lt;/i&gt; class
 * whose instances describe the types of {@link TabularData TabularData} values.
 *
 * @since 1.5
 */
public class TabularType extends OpenType&lt;TabularData&gt; {

    /* Serial version */
    static final long serialVersionUID = 6554071860220659261L;


    /**
     * @serial The composite type of rows
     */
    private CompositeType  rowType;

    /**
     * @serial The items used to index each row element, kept in the order the user gave
     *         This is an unmodifiable {@link ArrayList}
     */
    private List&lt;String&gt; indexNames;


    private transient Integer myHashCode = null; // As this instance is immutable, these two values
    private transient String  myToString = null; // need only be calculated once.


    /* *** Constructor *** */

    /**
     * Constructs a &lt;code&gt;TabularType&lt;/code&gt; instance, checking for the validity of the given parameters.
     * The validity constraints are described below for each parameter.
     * &lt;p&gt;
     * The Java class name of tabular data values this tabular type represents
     * (ie the class name returned by the {@link OpenType#getClassName() getClassName} method)
     * is set to the string value returned by &lt;code&gt;TabularData.class.getName()&lt;/code&gt;.
     * &lt;p&gt;
     * @param  typeName  The name given to the tabular type this instance represents; cannot be a null or empty string.
     * &lt;br&gt;&amp;nbsp;
     * @param  description  The human readable description of the tabular type this instance represents;
     *                      cannot be a null or empty string.
     * &lt;br&gt;&amp;nbsp;
     * @param  rowType  The type of the row elements of tabular data values described by this tabular type instance;
     *                  cannot be null.
     * &lt;br&gt;&amp;nbsp;
     * @param  indexNames  The names of the items the values of which are used to uniquely index each row element in the
     *                     tabular data values described by this tabular type instance;
     *                     cannot be null or empty. Each element should be an item name defined in &lt;var&gt;rowType&lt;/var&gt;
     *                     (no null or empty string allowed).
     *                     It is important to note that the &lt;b&gt;order&lt;/b&gt; of the item names in &lt;var&gt;indexNames&lt;/var&gt;
     *                     is used by the methods {@link TabularData#get(java.lang.Object[]) get} and
     *                     {@link TabularData#remove(java.lang.Object[]) remove} of class
     *                     &lt;code&gt;TabularData&lt;/code&gt; to match their array of values parameter to items.
     * &lt;br&gt;&amp;nbsp;
     * @throws IllegalArgumentException  if &lt;var&gt;rowType&lt;/var&gt; is null,
     *                                   or &lt;var&gt;indexNames&lt;/var&gt; is a null or empty array,
     *                                   or an element in &lt;var&gt;indexNames&lt;/var&gt; is a null or empty string,
     *                                   or &lt;var&gt;typeName&lt;/var&gt; or &lt;var&gt;description&lt;/var&gt; is a null or empty string.
     * &lt;br&gt;&amp;nbsp;
     * @throws OpenDataException  if an element's value of &lt;var&gt;indexNames&lt;/var&gt;
     *                            is not an item name defined in &lt;var&gt;rowType&lt;/var&gt;.
     */
    public TabularType(String         typeName,
                       String         description,
                       CompositeType  rowType,
                       String[]       indexNames) throws OpenDataException {

        // Check and initialize state defined by parent.
        //
        super(TabularData.class.getName(), typeName, description, false);

        // Check rowType is not null
        //
        if (rowType == null) {
            throw new IllegalArgumentException(&quot;Argument rowType cannot be null.&quot;);
        }

        // Check indexNames is neither null nor empty and does not contain any null element or empty string
        //
        checkForNullElement(indexNames, &quot;indexNames&quot;);
        checkForEmptyString(indexNames, &quot;indexNames&quot;);

        // Check all indexNames values are valid item names for rowType
        //
        for (int i=0; i&lt;indexNames.length; i++) {
            if ( ! rowType.containsKey(indexNames[i]) ) {
                throw new OpenDataException(&quot;Argument's element value indexNames[&quot;+ i +&quot;]=\&quot;&quot;+ indexNames[i] +
                                            &quot;\&quot; is not a valid item name for rowType.&quot;);
            }
        }

        // initialize rowType
        //
        this.rowType    = rowType;

        // initialize indexNames (copy content so that subsequent
        // modifs to the array referenced by the indexNames parameter
        // have no impact)
        //
        List&lt;String&gt; tmpList = new ArrayList&lt;String&gt;(indexNames.length + 1);
        for (int i=0; i&lt;indexNames.length; i++) {
            tmpList.add(indexNames[i]);
        }
        this.indexNames = Collections.unmodifiableList(tmpList);
    }

    /**
     * Checks that Object[] arg is neither null nor empty (ie length==0)
     * and that it does not contain any null element.
     */
    private static void checkForNullElement(Object[] arg, String argName) {
        if ( (arg == null) || (arg.length == 0) ) {
            throw new IllegalArgumentException(&quot;Argument &quot;+ argName +&quot;[] cannot be null or empty.&quot;);
        }
        for (int i=0; i&lt;arg.length; i++) {
            if (arg[i] == null) {
                throw new IllegalArgumentException(&quot;Argument's element &quot;+ argName +&quot;[&quot;+ i +&quot;] cannot be null.&quot;);
            }
        }
    }

    /**
     * Checks that String[] does not contain any empty (or blank characters only) string.
     */
    private static void checkForEmptyString(String[] arg, String argName) {
        for (int i=0; i&lt;arg.length; i++) {
            if (arg[i].trim().equals(&quot;&quot;)) {
                throw new IllegalArgumentException(&quot;Argument's element &quot;+ argName +&quot;[&quot;+ i +&quot;] cannot be an empty string.&quot;);
            }
        }
    }


    /* *** Tabular type specific information methods *** */

    /**
     * Returns the type of the row elements of tabular data values
     * described by this &lt;code&gt;TabularType&lt;/code&gt; instance.
     *
     * @return the type of each row.
     */
    public CompositeType getRowType() {

        return rowType;
    }

    /**
     * &lt;p&gt;Returns, in the same order as was given to this instance's
     * constructor, an unmodifiable List of the names of the items the
     * values of which are used to uniquely index each row element of
     * tabular data values described by this &lt;code&gt;TabularType&lt;/code&gt;
     * instance.&lt;/p&gt;
     *
     * @return a List of String representing the names of the index
     * items.
     *
     */
    public List&lt;String&gt; getIndexNames() {

        return indexNames;
    }

    /**
     * Tests whether &lt;var&gt;obj&lt;/var&gt; is a value which could be
     * described by this &lt;code&gt;TabularType&lt;/code&gt; instance.
     *
     * &lt;p&gt;If &lt;var&gt;obj&lt;/var&gt; is null or is not an instance of
     * &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;,
     * &lt;code&gt;isValue&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;If &lt;var&gt;obj&lt;/var&gt; is an instance of
     * &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;, say {@code
     * td}, the result is true if this {@code TabularType} is
     * &lt;em&gt;assignable from&lt;/em&gt; {@link TabularData#getTabularType()
     * td.getTabularType()}, as defined in {@link
     * CompositeType#isValue CompositeType.isValue}.&lt;/p&gt;
     *
     * @param obj the value whose open type is to be tested for
     * compatibility with this &lt;code&gt;TabularType&lt;/code&gt; instance.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;var&gt;obj&lt;/var&gt; is a value for this
     * tabular type, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean isValue(Object obj) {

        // if obj is null or not a TabularData, return false
        //
        if (!(obj instanceof TabularData))
            return false;

        // if obj is not a TabularData, return false
        //
        TabularData value = (TabularData) obj;
        TabularType valueType = value.getTabularType();
        return isAssignableFrom(valueType);
    }

    @Override
    boolean isAssignableFrom(OpenType&lt;?&gt; ot) {
        if (!(ot instanceof TabularType))
            return false;
        TabularType tt = (TabularType) ot;
        if (!getTypeName().equals(tt.getTypeName()) ||
                !getIndexNames().equals(tt.getIndexNames()))
            return false;
        return getRowType().isAssignableFrom(tt.getRowType());
    }


    /* *** Methods overriden from class Object *** */

    /**
     * Compares the specified &lt;code&gt;obj&lt;/code&gt; parameter with this &lt;code&gt;TabularType&lt;/code&gt; instance for equality.
     * &lt;p&gt;
     * Two &lt;code&gt;TabularType&lt;/code&gt; instances are equal if and only if all of the following statements are true:
     * &lt;ul&gt;
     * &lt;li&gt;their type names are equal&lt;/li&gt;
     * &lt;li&gt;their row types are equal&lt;/li&gt;
     * &lt;li&gt;they use the same index names, in the same order&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;br&gt;&amp;nbsp;
     * @param  obj  the object to be compared for equality with this &lt;code&gt;TabularType&lt;/code&gt; instance;
     *              if &lt;var&gt;obj&lt;/var&gt; is &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;equals&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.
     *
     * @return  &lt;code&gt;true&lt;/code&gt; if the specified object is equal to this &lt;code&gt;TabularType&lt;/code&gt; instance.
     */
    public boolean equals(Object obj) {

        // if obj is null, return false
        //
        if (obj == null) {
            return false;
        }

        // if obj is not a TabularType, return false
        //
        TabularType other;
        try {
            other = (TabularType) obj;
        } catch (ClassCastException e) {
            return false;
        }

        // Now, really test for equality between this TabularType instance and the other:
        //

        // their names should be equal
        if ( ! this.getTypeName().equals(other.getTypeName()) ) {
            return false;
        }

        // their row types should be equal
        if ( ! this.rowType.equals(other.rowType) ) {
            return false;
        }

        // their index names should be equal and in the same order (ensured by List.equals())
        if ( ! this.indexNames.equals(other.indexNames) ) {
            return false;
        }

        // All tests for equality were successfull
        //
        return true;
    }

    /**
     * Returns the hash code value for this &lt;code&gt;TabularType&lt;/code&gt; instance.
     * &lt;p&gt;
     * The hash code of a &lt;code&gt;TabularType&lt;/code&gt; instance is the sum of the hash codes
     * of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons
     * (ie: name, row type, index names).
     * This ensures that &lt;code&gt; t1.equals(t2) &lt;/code&gt; implies that &lt;code&gt; t1.hashCode()==t2.hashCode() &lt;/code&gt;
     * for any two &lt;code&gt;TabularType&lt;/code&gt; instances &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;,
     * as required by the general contract of the method
     * {@link Object#hashCode() Object.hashCode()}.
     * &lt;p&gt;
     * As &lt;code&gt;TabularType&lt;/code&gt; instances are immutable, the hash code for this instance is calculated once,
     * on the first call to &lt;code&gt;hashCode&lt;/code&gt;, and then the same value is returned for subsequent calls.
     *
     * @return  the hash code value for this &lt;code&gt;TabularType&lt;/code&gt; instance
     */
    public int hashCode() {

        // Calculate the hash code value if it has not yet been done (ie 1st call to hashCode())
        //
        if (myHashCode == null) {
            int value = 0;
            value += this.getTypeName().hashCode();
            value += this.rowType.hashCode();
            for (String index : indexNames)
                value += index.hashCode();
            myHashCode = Integer.valueOf(value);
        }

        // return always the same hash code for this instance (immutable)
        //
        return myHashCode.intValue();
    }

    /**
     * Returns a string representation of this &lt;code&gt;TabularType&lt;/code&gt; instance.
     * &lt;p&gt;
     * The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.TabularType&lt;/code&gt;),
     * the type name for this instance, the row type string representation of this instance,
     * and the index names of this instance.
     * &lt;p&gt;
     * As &lt;code&gt;TabularType&lt;/code&gt; instances are immutable, the string representation for this instance is calculated once,
     * on the first call to &lt;code&gt;toString&lt;/code&gt;, and then the same value is returned for subsequent calls.
     *
     * @return  a string representation of this &lt;code&gt;TabularType&lt;/code&gt; instance
     */
    public String toString() {

        // Calculate the string representation if it has not yet been done (ie 1st call to toString())
        //
        if (myToString == null) {
            final StringBuilder result = new StringBuilder()
                .append(this.getClass().getName())
                .append(&quot;(name=&quot;)
                .append(getTypeName())
                .append(&quot;,rowType=&quot;)
                .append(rowType.toString())
                .append(&quot;,indexNames=(&quot;);
            String sep = &quot;&quot;;
            for (String index : indexNames) {
                result.append(sep).append(index);
                sep = &quot;,&quot;;
            }
            result.append(&quot;))&quot;);
            myToString = result.toString();
        }

        // return always the same string representation for this instance (immutable)
        //
        return myToString;
    }

}
</pre>
</body>
</html>
