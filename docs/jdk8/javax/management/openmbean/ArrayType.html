<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management.openmbean;

import java.io.ObjectStreamException;
import java.lang.reflect.Array;

/**
 * The &lt;code&gt;ArrayType&lt;/code&gt; class is the &lt;i&gt;open type&lt;/i&gt; class whose instances describe
 * all &lt;i&gt;open data&lt;/i&gt; values which are n-dimensional arrays of &lt;i&gt;open data&lt;/i&gt; values.
 * &lt;p&gt;
 * Examples of valid {@code ArrayType} instances are:
 * &lt;pre&gt;{@code
 * // 2-dimension array of java.lang.String
 * ArrayType&lt;String[][]&gt; a1 = new ArrayType&lt;String[][]&gt;(2, SimpleType.STRING);
 *
 * // 1-dimension array of int
 * ArrayType&lt;int[]&gt; a2 = new ArrayType&lt;int[]&gt;(SimpleType.INTEGER, true);
 *
 * // 1-dimension array of java.lang.Integer
 * ArrayType&lt;Integer[]&gt; a3 = new ArrayType&lt;Integer[]&gt;(SimpleType.INTEGER, false);
 *
 * // 4-dimension array of int
 * ArrayType&lt;int[][][][]&gt; a4 = new ArrayType&lt;int[][][][]&gt;(3, a2);
 *
 * // 4-dimension array of java.lang.Integer
 * ArrayType&lt;Integer[][][][]&gt; a5 = new ArrayType&lt;Integer[][][][]&gt;(3, a3);
 *
 * // 1-dimension array of java.lang.String
 * ArrayType&lt;String[]&gt; a6 = new ArrayType&lt;String[]&gt;(SimpleType.STRING, false);
 *
 * // 1-dimension array of long
 * ArrayType&lt;long[]&gt; a7 = new ArrayType&lt;long[]&gt;(SimpleType.LONG, true);
 *
 * // 1-dimension array of java.lang.Integer
 * ArrayType&lt;Integer[]&gt; a8 = ArrayType.getArrayType(SimpleType.INTEGER);
 *
 * // 2-dimension array of java.lang.Integer
 * ArrayType&lt;Integer[][]&gt; a9 = ArrayType.getArrayType(a8);
 *
 * // 2-dimension array of int
 * ArrayType&lt;int[][]&gt; a10 = ArrayType.getPrimitiveArrayType(int[][].class);
 *
 * // 3-dimension array of int
 * ArrayType&lt;int[][][]&gt; a11 = ArrayType.getArrayType(a10);
 *
 * // 1-dimension array of float
 * ArrayType&lt;float[]&gt; a12 = ArrayType.getPrimitiveArrayType(float[].class);
 *
 * // 2-dimension array of float
 * ArrayType&lt;float[][]&gt; a13 = ArrayType.getArrayType(a12);
 *
 * // 1-dimension array of javax.management.ObjectName
 * ArrayType&lt;ObjectName[]&gt; a14 = ArrayType.getArrayType(SimpleType.OBJECTNAME);
 *
 * // 2-dimension array of javax.management.ObjectName
 * ArrayType&lt;ObjectName[][]&gt; a15 = ArrayType.getArrayType(a14);
 *
 * // 3-dimension array of java.lang.String
 * ArrayType&lt;String[][][]&gt; a16 = new ArrayType&lt;String[][][]&gt;(3, SimpleType.STRING);
 *
 * // 1-dimension array of java.lang.String
 * ArrayType&lt;String[]&gt; a17 = new ArrayType&lt;String[]&gt;(1, SimpleType.STRING);
 *
 * // 2-dimension array of java.lang.String
 * ArrayType&lt;String[][]&gt; a18 = new ArrayType&lt;String[][]&gt;(1, a17);
 *
 * // 3-dimension array of java.lang.String
 * ArrayType&lt;String[][][]&gt; a19 = new ArrayType&lt;String[][][]&gt;(1, a18);
 * }&lt;/pre&gt;
 *
 *
 * @since 1.5
 */
/*
  Generification note: we could have defined a type parameter that is the
  element type, with class ArrayType&lt;E&gt; extends OpenType&lt;E[]&gt;.  However,
  that doesn't buy us all that much.  We can't say
    public OpenType&lt;E&gt; getElementOpenType()
  because this ArrayType could be a multi-dimensional array.
  For example, if we had
    ArrayType(2, SimpleType.INTEGER)
  then E would have to be Integer[], while getElementOpenType() would
  return SimpleType.INTEGER, which is an OpenType&lt;Integer&gt;.

  Furthermore, we would like to support int[] (as well as Integer[]) as
  an Open Type (RFE 5045358).  We would want this to be an OpenType&lt;int[]&gt;
  which can't be expressed as &lt;E[]&gt; because E can't be a primitive type
  like int.
 */
public class ArrayType&lt;T&gt; extends OpenType&lt;T&gt; {

    /* Serial version */
    static final long serialVersionUID = 720504429830309770L;

    /**
     * @serial The dimension of arrays described by this {@link ArrayType}
     *         instance.
     */
    private int dimension;

    /**
     * @serial The &lt;i&gt;open type&lt;/i&gt; of element values contained in the arrays
     *         described by this {@link ArrayType} instance.
     */
    private OpenType&lt;?&gt; elementType;

    /**
     * @serial This flag indicates whether this {@link ArrayType}
     *         describes a primitive array.
     *
     * @since 1.6
     */
    private boolean primitiveArray;

    private transient Integer  myHashCode = null;       // As this instance is immutable, these two values
    private transient String   myToString = null;       // need only be calculated once.

    // indexes refering to columns in the PRIMITIVE_ARRAY_TYPES table.
    private static final int PRIMITIVE_WRAPPER_NAME_INDEX = 0;
    private static final int PRIMITIVE_TYPE_NAME_INDEX = 1;
    private static final int PRIMITIVE_TYPE_KEY_INDEX  = 2;
    private static final int PRIMITIVE_OPEN_TYPE_INDEX  = 3;

    private static final Object[][] PRIMITIVE_ARRAY_TYPES = {
        { Boolean.class.getName(),   boolean.class.getName(), &quot;Z&quot;, SimpleType.BOOLEAN },
        { Character.class.getName(), char.class.getName(),    &quot;C&quot;, SimpleType.CHARACTER },
        { Byte.class.getName(),      byte.class.getName(),    &quot;B&quot;, SimpleType.BYTE },
        { Short.class.getName(),     short.class.getName(),   &quot;S&quot;, SimpleType.SHORT },
        { Integer.class.getName(),   int.class.getName(),     &quot;I&quot;, SimpleType.INTEGER },
        { Long.class.getName(),      long.class.getName(),    &quot;J&quot;, SimpleType.LONG },
        { Float.class.getName(),     float.class.getName(),   &quot;F&quot;, SimpleType.FLOAT },
        { Double.class.getName(),    double.class.getName(),  &quot;D&quot;, SimpleType.DOUBLE }
    };

    static boolean isPrimitiveContentType(final String primitiveKey) {
        for (Object[] typeDescr : PRIMITIVE_ARRAY_TYPES) {
            if (typeDescr[PRIMITIVE_TYPE_KEY_INDEX].equals(primitiveKey)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Return the key used to identify the element type in
     * arrays - e.g. &quot;Z&quot; for boolean, &quot;C&quot; for char etc...
     * @param elementClassName the wrapper class name of the array
     *        element (&quot;Boolean&quot;,  &quot;Character&quot;, etc...)
     * @return the key corresponding to the given type (&quot;Z&quot;, &quot;C&quot;, etc...)
     *         return null if the given elementClassName is not a primitive
     *         wrapper class name.
     **/
    static String getPrimitiveTypeKey(String elementClassName) {
        for (Object[] typeDescr : PRIMITIVE_ARRAY_TYPES) {
            if (elementClassName.equals(typeDescr[PRIMITIVE_WRAPPER_NAME_INDEX]))
                return (String)typeDescr[PRIMITIVE_TYPE_KEY_INDEX];
        }
        return null;
    }

    /**
     * Return the primitive type name corresponding to the given wrapper class.
     * e.g. &quot;boolean&quot; for &quot;Boolean&quot;, &quot;char&quot; for &quot;Character&quot; etc...
     * @param elementClassName the type of the array element (&quot;Boolean&quot;,
     *        &quot;Character&quot;, etc...)
     * @return the primitive type name corresponding to the given wrapper class
     *         (&quot;boolean&quot;, &quot;char&quot;, etc...)
     *         return null if the given elementClassName is not a primitive
     *         wrapper type name.
     **/
    static String getPrimitiveTypeName(String elementClassName) {
        for (Object[] typeDescr : PRIMITIVE_ARRAY_TYPES) {
            if (elementClassName.equals(typeDescr[PRIMITIVE_WRAPPER_NAME_INDEX]))
                return (String)typeDescr[PRIMITIVE_TYPE_NAME_INDEX];
        }
        return null;
    }

    /**
     * Return the primitive open type corresponding to the given primitive type.
     * e.g. SimpleType.BOOLEAN for &quot;boolean&quot;, SimpleType.CHARACTER for
     * &quot;char&quot;, etc...
     * @param primitiveTypeName the primitive type of the array element (&quot;boolean&quot;,
     *        &quot;char&quot;, etc...)
     * @return the OpenType corresponding to the given primitive type name
     *         (SimpleType.BOOLEAN, SimpleType.CHARACTER, etc...)
     *         return null if the given elementClassName is not a primitive
     *         type name.
     **/
    static SimpleType&lt;?&gt; getPrimitiveOpenType(String primitiveTypeName) {
        for (Object[] typeDescr : PRIMITIVE_ARRAY_TYPES) {
            if (primitiveTypeName.equals(typeDescr[PRIMITIVE_TYPE_NAME_INDEX]))
                return (SimpleType&lt;?&gt;)typeDescr[PRIMITIVE_OPEN_TYPE_INDEX];
        }
        return null;
    }

    /* *** Constructor *** */

    /**
     * Constructs an &lt;tt&gt;ArrayType&lt;/tt&gt; instance describing &lt;i&gt;open data&lt;/i&gt; values which are
     * arrays with dimension &lt;var&gt;dimension&lt;/var&gt; of elements whose &lt;i&gt;open type&lt;/i&gt; is &lt;var&gt;elementType&lt;/var&gt;.
     * &lt;p&gt;
     * When invoked on an &lt;tt&gt;ArrayType&lt;/tt&gt; instance, the {@link OpenType#getClassName() getClassName} method
     * returns the class name of the array instances it describes (following the rules defined by the
     * {@link Class#getName() getName} method of &lt;code&gt;java.lang.Class&lt;/code&gt;), not the class name of the array elements
     * (which is returned by a call to &lt;tt&gt;getElementOpenType().getClassName()&lt;/tt&gt;).
     * &lt;p&gt;
     * The internal field corresponding to the type name of this &lt;code&gt;ArrayType&lt;/code&gt; instance is also set to
     * the class name of the array instances it describes.
     * In other words, the methods &lt;code&gt;getClassName&lt;/code&gt; and &lt;code&gt;getTypeName&lt;/code&gt; return the same string value.
     * The internal field corresponding to the description of this &lt;code&gt;ArrayType&lt;/code&gt; instance is set to a string value
     * which follows the following template:
     * &lt;ul&gt;
     * &lt;li&gt;if non-primitive array: &lt;tt&gt;&lt;i&gt;&amp;lt;dimension&amp;gt;&lt;/i&gt;-dimension array of &lt;i&gt;&amp;lt;element_class_name&amp;gt;&lt;/i&gt;&lt;/tt&gt;&lt;/li&gt;
     * &lt;li&gt;if primitive array: &lt;tt&gt;&lt;i&gt;&amp;lt;dimension&amp;gt;&lt;/i&gt;-dimension array of &lt;i&gt;&amp;lt;primitive_type_of_the_element_class_name&amp;gt;&lt;/i&gt;&lt;/tt&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * As an example, the following piece of code:
     * &lt;pre&gt;{@code
     * ArrayType&lt;String[][][]&gt; t = new ArrayType&lt;String[][][]&gt;(3, SimpleType.STRING);
     * System.out.println(&quot;array class name       = &quot; + t.getClassName());
     * System.out.println(&quot;element class name     = &quot; + t.getElementOpenType().getClassName());
     * System.out.println(&quot;array type name        = &quot; + t.getTypeName());
     * System.out.println(&quot;array type description = &quot; + t.getDescription());
     * }&lt;/pre&gt;
     * would produce the following output:
     * &lt;pre&gt;{@code
     * array class name       = [[[Ljava.lang.String;
     * element class name     = java.lang.String
     * array type name        = [[[Ljava.lang.String;
     * array type description = 3-dimension array of java.lang.String
     * }&lt;/pre&gt;
     * And the following piece of code which is equivalent to the one listed
     * above would also produce the same output:
     * &lt;pre&gt;{@code
     * ArrayType&lt;String[]&gt; t1 = new ArrayType&lt;String[]&gt;(1, SimpleType.STRING);
     * ArrayType&lt;String[][]&gt; t2 = new ArrayType&lt;String[][]&gt;(1, t1);
     * ArrayType&lt;String[][][]&gt; t3 = new ArrayType&lt;String[][][]&gt;(1, t2);
     * System.out.println(&quot;array class name       = &quot; + t3.getClassName());
     * System.out.println(&quot;element class name     = &quot; + t3.getElementOpenType().getClassName());
     * System.out.println(&quot;array type name        = &quot; + t3.getTypeName());
     * System.out.println(&quot;array type description = &quot; + t3.getDescription());
     * }&lt;/pre&gt;
     *
     * @param  dimension  the dimension of arrays described by this &lt;tt&gt;ArrayType&lt;/tt&gt; instance;
     *                    must be greater than or equal to 1.
     *
     * @param  elementType  the &lt;i&gt;open type&lt;/i&gt; of element values contained
     *                      in the arrays described by this &lt;tt&gt;ArrayType&lt;/tt&gt;
     *                      instance; must be an instance of either
     *                      &lt;tt&gt;SimpleType&lt;/tt&gt;, &lt;tt&gt;CompositeType&lt;/tt&gt;,
     *                      &lt;tt&gt;TabularType&lt;/tt&gt; or another &lt;tt&gt;ArrayType&lt;/tt&gt;
     *                      with a &lt;tt&gt;SimpleType&lt;/tt&gt;, &lt;tt&gt;CompositeType&lt;/tt&gt;
     *                      or &lt;tt&gt;TabularType&lt;/tt&gt; as its &lt;tt&gt;elementType&lt;/tt&gt;.
     *
     * @throws IllegalArgumentException if {@code dimension} is not a positive
     *                                  integer.
     * @throws OpenDataException  if &lt;var&gt;elementType's className&lt;/var&gt; is not
     *                            one of the allowed Java class names for open
     *                            data.
     */
    public ArrayType(int dimension,
                     OpenType&lt;?&gt; elementType) throws OpenDataException {
        // Check and construct state defined by parent.
        // We can't use the package-private OpenType constructor because
        // we don't know if the elementType parameter is sane.
        super(buildArrayClassName(dimension, elementType),
              buildArrayClassName(dimension, elementType),
              buildArrayDescription(dimension, elementType));

        // Check and construct state specific to ArrayType
        //
        if (elementType.isArray()) {
            ArrayType&lt;?&gt; at = (ArrayType&lt;?&gt;) elementType;
            this.dimension = at.getDimension() + dimension;
            this.elementType = at.getElementOpenType();
            this.primitiveArray = at.isPrimitiveArray();
        } else {
            this.dimension = dimension;
            this.elementType = elementType;
            this.primitiveArray = false;
        }
    }

    /**
     * Constructs a unidimensional {@code ArrayType} instance for the
     * supplied {@code SimpleType}.
     * &lt;p&gt;
     * This constructor supports the creation of arrays of primitive
     * types when {@code primitiveArray} is {@code true}.
     * &lt;p&gt;
     * For primitive arrays the {@link #getElementOpenType()} method
     * returns the {@link SimpleType} corresponding to the wrapper
     * type of the primitive type of the array.
     * &lt;p&gt;
     * When invoked on an &lt;tt&gt;ArrayType&lt;/tt&gt; instance, the {@link OpenType#getClassName() getClassName} method
     * returns the class name of the array instances it describes (following the rules defined by the
     * {@link Class#getName() getName} method of &lt;code&gt;java.lang.Class&lt;/code&gt;), not the class name of the array elements
     * (which is returned by a call to &lt;tt&gt;getElementOpenType().getClassName()&lt;/tt&gt;).
     * &lt;p&gt;
     * The internal field corresponding to the type name of this &lt;code&gt;ArrayType&lt;/code&gt; instance is also set to
     * the class name of the array instances it describes.
     * In other words, the methods &lt;code&gt;getClassName&lt;/code&gt; and &lt;code&gt;getTypeName&lt;/code&gt; return the same string value.
     * The internal field corresponding to the description of this &lt;code&gt;ArrayType&lt;/code&gt; instance is set to a string value
     * which follows the following template:
     * &lt;ul&gt;
     * &lt;li&gt;if non-primitive array: &lt;tt&gt;1-dimension array of &lt;i&gt;&amp;lt;element_class_name&amp;gt;&lt;/i&gt;&lt;/tt&gt;&lt;/li&gt;
     * &lt;li&gt;if primitive array: &lt;tt&gt;1-dimension array of &lt;i&gt;&amp;lt;primitive_type_of_the_element_class_name&amp;gt;&lt;/i&gt;&lt;/tt&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * As an example, the following piece of code:
     * &lt;pre&gt;{@code
     * ArrayType&lt;int[]&gt; t = new ArrayType&lt;int[]&gt;(SimpleType.INTEGER, true);
     * System.out.println(&quot;array class name       = &quot; + t.getClassName());
     * System.out.println(&quot;element class name     = &quot; + t.getElementOpenType().getClassName());
     * System.out.println(&quot;array type name        = &quot; + t.getTypeName());
     * System.out.println(&quot;array type description = &quot; + t.getDescription());
     * }&lt;/pre&gt;
     * would produce the following output:
     * &lt;pre&gt;{@code
     * array class name       = [I
     * element class name     = java.lang.Integer
     * array type name        = [I
     * array type description = 1-dimension array of int
     * }&lt;/pre&gt;
     *
     * @param elementType the {@code SimpleType} of the element values
     *                    contained in the arrays described by this
     *                    {@code ArrayType} instance.
     *
     * @param primitiveArray {@code true} when this array describes
     *                       primitive arrays.
     *
     * @throws IllegalArgumentException if {@code dimension} is not a positive
     * integer.
     * @throws OpenDataException if {@code primitiveArray} is {@code true} and
     * {@code elementType} is not a valid {@code SimpleType} for a primitive
     * type.
     *
     * @since 1.6
     */
    public ArrayType(SimpleType&lt;?&gt; elementType,
                     boolean primitiveArray) throws OpenDataException {

        // Check and construct state defined by parent.
        // We can call the package-private OpenType constructor because the
        // set of SimpleTypes is fixed and SimpleType can't be subclassed.
        super(buildArrayClassName(1, elementType, primitiveArray),
              buildArrayClassName(1, elementType, primitiveArray),
              buildArrayDescription(1, elementType, primitiveArray),
              true);

        // Check and construct state specific to ArrayType
        //
        this.dimension = 1;
        this.elementType = elementType;
        this.primitiveArray = primitiveArray;
    }

    /* Package-private constructor for callers we trust to get it right. */
    ArrayType(String className, String typeName, String description,
              int dimension, OpenType&lt;?&gt; elementType,
              boolean primitiveArray) {
        super(className, typeName, description, true);
        this.dimension = dimension;
        this.elementType = elementType;
        this.primitiveArray = primitiveArray;
    }

    private static String buildArrayClassName(int dimension,
                                              OpenType&lt;?&gt; elementType)
        throws OpenDataException {
        boolean isPrimitiveArray = false;
        if (elementType.isArray()) {
            isPrimitiveArray = ((ArrayType&lt;?&gt;) elementType).isPrimitiveArray();
        }
        return buildArrayClassName(dimension, elementType, isPrimitiveArray);
    }

    private static String buildArrayClassName(int dimension,
                                              OpenType&lt;?&gt; elementType,
                                              boolean isPrimitiveArray)
        throws OpenDataException {
        if (dimension &lt; 1) {
            throw new IllegalArgumentException(
                &quot;Value of argument dimension must be greater than 0&quot;);
        }
        StringBuilder result = new StringBuilder();
        String elementClassName = elementType.getClassName();
        // Add N (= dimension) additional '[' characters to the existing array
        for (int i = 1; i &lt;= dimension; i++) {
            result.append('[');
        }
        if (elementType.isArray()) {
            result.append(elementClassName);
        } else {
            if (isPrimitiveArray) {
                final String key = getPrimitiveTypeKey(elementClassName);
                // Ideally we should throw an IllegalArgumentException here,
                // but for compatibility reasons we throw an OpenDataException.
                // (used to be thrown by OpenType() constructor).
                //
                if (key == null)
                    throw new OpenDataException(&quot;Element type is not primitive: &quot;
                            + elementClassName);
                result.append(key);
            } else {
                result.append(&quot;L&quot;);
                result.append(elementClassName);
                result.append(';');
            }
        }
        return result.toString();
    }

    private static String buildArrayDescription(int dimension,
                                                OpenType&lt;?&gt; elementType)
        throws OpenDataException {
        boolean isPrimitiveArray = false;
        if (elementType.isArray()) {
            isPrimitiveArray = ((ArrayType&lt;?&gt;) elementType).isPrimitiveArray();
        }
        return buildArrayDescription(dimension, elementType, isPrimitiveArray);
    }

    private static String buildArrayDescription(int dimension,
                                                OpenType&lt;?&gt; elementType,
                                                boolean isPrimitiveArray)
        throws OpenDataException {
        if (elementType.isArray()) {
            ArrayType&lt;?&gt; at = (ArrayType&lt;?&gt;) elementType;
            dimension += at.getDimension();
            elementType = at.getElementOpenType();
            isPrimitiveArray = at.isPrimitiveArray();
        }
        StringBuilder result =
            new StringBuilder(dimension + &quot;-dimension array of &quot;);
        final String elementClassName = elementType.getClassName();
        if (isPrimitiveArray) {
            // Convert from wrapper type to primitive type
            final String primitiveType =
                    getPrimitiveTypeName(elementClassName);

            // Ideally we should throw an IllegalArgumentException here,
            // but for compatibility reasons we throw an OpenDataException.
            // (used to be thrown by OpenType() constructor).
            //
            if (primitiveType == null)
                throw new OpenDataException(&quot;Element is not a primitive type: &quot;+
                        elementClassName);
            result.append(primitiveType);
        } else {
            result.append(elementClassName);
        }
        return result.toString();
    }

    /* *** ArrayType specific information methods *** */

    /**
     * Returns the dimension of arrays described by this &lt;tt&gt;ArrayType&lt;/tt&gt; instance.
     *
     * @return the dimension.
     */
    public int getDimension() {

        return dimension;
    }

    /**
     * Returns the &lt;i&gt;open type&lt;/i&gt; of element values contained in the arrays described by this &lt;tt&gt;ArrayType&lt;/tt&gt; instance.
     *
     * @return the element type.
     */
    public OpenType&lt;?&gt; getElementOpenType() {

        return elementType;
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the open data values this open
     * type describes are primitive arrays, &lt;code&gt;false&lt;/code&gt; otherwise.
     *
     * @return true if this is a primitive array type.
     *
     * @since 1.6
     */
    public boolean isPrimitiveArray() {

        return primitiveArray;
    }

    /**
     * Tests whether &lt;var&gt;obj&lt;/var&gt; is a value for this &lt;code&gt;ArrayType&lt;/code&gt;
     * instance.
     * &lt;p&gt;
     * This method returns &lt;code&gt;true&lt;/code&gt; if and only if &lt;var&gt;obj&lt;/var&gt;
     * is not null, &lt;var&gt;obj&lt;/var&gt; is an array and any one of the following
     * is &lt;tt&gt;true&lt;/tt&gt;:
     *
     * &lt;ul&gt;
     * &lt;li&gt;if this &lt;code&gt;ArrayType&lt;/code&gt; instance describes an array of
     * &lt;tt&gt;SimpleType&lt;/tt&gt; elements or their corresponding primitive types,
     * &lt;var&gt;obj&lt;/var&gt;'s class name is the same as the className field defined
     * for this &lt;code&gt;ArrayType&lt;/code&gt; instance (i.e. the class name returned
     * by the {@link OpenType#getClassName() getClassName} method, which
     * includes the dimension information),&lt;br&gt;&amp;nbsp;&lt;/li&gt;
     * &lt;li&gt;if this &lt;code&gt;ArrayType&lt;/code&gt; instance describes an array of
     * classes implementing the {@code TabularData} interface or the
     * {@code CompositeData} interface, &lt;var&gt;obj&lt;/var&gt; is assignable to
     * such a declared array, and each element contained in {&lt;var&gt;obj&lt;/var&gt;
     * is either null or a valid value for the element's open type specified
     * by this &lt;code&gt;ArrayType&lt;/code&gt; instance.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param obj the object to be tested.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;var&gt;obj&lt;/var&gt; is a value for this
     * &lt;code&gt;ArrayType&lt;/code&gt; instance.
     */
    public boolean isValue(Object obj) {

        // if obj is null, return false
        //
        if (obj == null) {
            return false;
        }

        Class&lt;?&gt; objClass = obj.getClass();
        String objClassName = objClass.getName();

        // if obj is not an array, return false
        //
        if ( ! objClass.isArray() ) {
            return false;
        }

        // Test if obj's class name is the same as for the array values that this instance describes
        // (this is fine if elements are of simple types, which are final classes)
        //
        if ( this.getClassName().equals(objClassName) ) {
            return true;
        }

        // In case this ArrayType instance describes an array of classes implementing the TabularData or CompositeData interface,
        // we first check for the assignability of obj to such an array of TabularData or CompositeData,
        // which ensures that:
        //  . obj is of the the same dimension as this ArrayType instance,
        //  . it is declared as an array of elements which are either all TabularData or all CompositeData.
        //
        // If the assignment check is positive,
        // then we have to check that each element in obj is of the same TabularType or CompositeType
        // as the one described by this ArrayType instance.
        //
        // [About assignment check, note that the call below returns true: ]
        // [Class.forName(&quot;[Lpackage.CompositeData;&quot;).isAssignableFrom(Class.forName(&quot;[Lpackage.CompositeDataImpl;)&quot;)); ]
        //
        if ( (this.elementType.getClassName().equals(TabularData.class.getName()))  ||
             (this.elementType.getClassName().equals(CompositeData.class.getName()))   ) {

            boolean isTabular =
                (elementType.getClassName().equals(TabularData.class.getName()));
            int[] dims = new int[getDimension()];
            Class&lt;?&gt; elementClass = isTabular ? TabularData.class : CompositeData.class;
            Class&lt;?&gt; targetClass = Array.newInstance(elementClass, dims).getClass();

            // assignment check: return false if negative
            if  ( ! targetClass.isAssignableFrom(objClass) ) {
                return false;
            }

            // check that all elements in obj are valid values for this ArrayType
            if ( ! checkElementsType( (Object[]) obj, this.dimension) ) { // we know obj's dimension is this.dimension
                return false;
            }

            return true;
        }

        // if previous tests did not return, then obj is not a value for this ArrayType instance
        return false;
    }

    /**
     * Returns true if and only if all elements contained in the array argument x_dim_Array of dimension dim
     * are valid values (ie either null or of the right openType)
     * for the element open type specified by this ArrayType instance.
     *
     * This method's implementation uses recursion to go down the dimensions of the array argument.
     */
    private boolean checkElementsType(Object[] x_dim_Array, int dim) {

        // if the elements of x_dim_Array are themselves array: go down recursively....
        if ( dim &gt; 1 ) {
            for (int i=0; i&lt;x_dim_Array.length; i++) {
                if ( ! checkElementsType((Object[])x_dim_Array[i], dim-1) ) {
                    return false;
                }
            }
            return true;
        }
        // ...else, for a non-empty array, each element must be a valid value: either null or of the right openType
        else {
            for (int i=0; i&lt;x_dim_Array.length; i++) {
                if ( (x_dim_Array[i] != null) &amp;&amp; (! this.getElementOpenType().isValue(x_dim_Array[i])) ) {
                    return false;
                }
            }
            return true;
        }
    }

    @Override
    boolean isAssignableFrom(OpenType&lt;?&gt; ot) {
        if (!(ot instanceof ArrayType&lt;?&gt;))
            return false;
        ArrayType&lt;?&gt; at = (ArrayType&lt;?&gt;) ot;
        return (at.getDimension() == getDimension() &amp;&amp;
                at.isPrimitiveArray() == isPrimitiveArray() &amp;&amp;
                at.getElementOpenType().isAssignableFrom(getElementOpenType()));
    }


    /* *** Methods overriden from class Object *** */

    /**
     * Compares the specified &lt;code&gt;obj&lt;/code&gt; parameter with this
     * &lt;code&gt;ArrayType&lt;/code&gt; instance for equality.
     * &lt;p&gt;
     * Two &lt;code&gt;ArrayType&lt;/code&gt; instances are equal if and only if they
     * describe array instances which have the same dimension, elements'
     * open type and primitive array flag.
     *
     * @param obj the object to be compared for equality with this
     *            &lt;code&gt;ArrayType&lt;/code&gt; instance; if &lt;var&gt;obj&lt;/var&gt;
     *            is &lt;code&gt;null&lt;/code&gt; or is not an instance of the
     *            class &lt;code&gt;ArrayType&lt;/code&gt; this method returns
     *            &lt;code&gt;false&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the specified object is equal to
     *         this &lt;code&gt;ArrayType&lt;/code&gt; instance.
     */
    public boolean equals(Object obj) {

        // if obj is null, return false
        //
        if (obj == null) {
            return false;
        }

        // if obj is not an ArrayType, return false
        //
        if (!(obj instanceof ArrayType&lt;?&gt;))
            return false;
        ArrayType&lt;?&gt; other = (ArrayType&lt;?&gt;) obj;

        // if other's dimension is different than this instance's, return false
        //
        if (this.dimension != other.dimension) {
            return false;
        }

        // Test if other's elementType field is the same as for this instance
        //
        if (!this.elementType.equals(other.elementType)) {
            return false;
        }

        // Test if other's primitiveArray flag is the same as for this instance
        //
        return this.primitiveArray == other.primitiveArray;
    }

    /**
     * Returns the hash code value for this &lt;code&gt;ArrayType&lt;/code&gt; instance.
     * &lt;p&gt;
     * The hash code of an &lt;code&gt;ArrayType&lt;/code&gt; instance is the sum of the
     * hash codes of all the elements of information used in &lt;code&gt;equals&lt;/code&gt;
     * comparisons (i.e. dimension, elements' open type and primitive array flag).
     * The hashcode for a primitive value is the hashcode of the corresponding boxed
     * object (e.g. the hashcode for &lt;tt&gt;true&lt;/tt&gt; is &lt;tt&gt;Boolean.TRUE.hashCode()&lt;/tt&gt;).
     * This ensures that &lt;code&gt; t1.equals(t2) &lt;/code&gt; implies that
     * &lt;code&gt; t1.hashCode()==t2.hashCode() &lt;/code&gt; for any two
     * &lt;code&gt;ArrayType&lt;/code&gt; instances &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;,
     * as required by the general contract of the method
     * {@link Object#hashCode() Object.hashCode()}.
     * &lt;p&gt;
     * As &lt;code&gt;ArrayType&lt;/code&gt; instances are immutable, the hash
     * code for this instance is calculated once, on the first call
     * to &lt;code&gt;hashCode&lt;/code&gt;, and then the same value is returned
     * for subsequent calls.
     *
     * @return  the hash code value for this &lt;code&gt;ArrayType&lt;/code&gt; instance
     */
    public int hashCode() {

        // Calculate the hash code value if it has not yet been done (ie 1st call to hashCode())
        //
        if (myHashCode == null) {
            int value = 0;
            value += dimension;
            value += elementType.hashCode();
            value += Boolean.valueOf(primitiveArray).hashCode();
            myHashCode = Integer.valueOf(value);
        }

        // return always the same hash code for this instance (immutable)
        //
        return myHashCode.intValue();
    }

    /**
     * Returns a string representation of this &lt;code&gt;ArrayType&lt;/code&gt; instance.
     * &lt;p&gt;
     * The string representation consists of the name of this class (i.e.
     * &lt;code&gt;javax.management.openmbean.ArrayType&lt;/code&gt;), the type name,
     * the dimension, the elements' open type and the primitive array flag
     * defined for this instance.
     * &lt;p&gt;
     * As &lt;code&gt;ArrayType&lt;/code&gt; instances are immutable, the
     * string representation for this instance is calculated
     * once, on the first call to &lt;code&gt;toString&lt;/code&gt;, and
     * then the same value is returned for subsequent calls.
     *
     * @return a string representation of this &lt;code&gt;ArrayType&lt;/code&gt; instance
     */
    public String toString() {

        // Calculate the string representation if it has not yet been done (ie 1st call to toString())
        //
        if (myToString == null) {
            myToString = getClass().getName() +
                         &quot;(name=&quot; + getTypeName() +
                         &quot;,dimension=&quot; + dimension +
                         &quot;,elementType=&quot; + elementType +
                         &quot;,primitiveArray=&quot; + primitiveArray + &quot;)&quot;;
        }

        // return always the same string representation for this instance (immutable)
        //
        return myToString;
    }

    /**
     * Create an {@code ArrayType} instance in a type-safe manner.
     * &lt;p&gt;
     * Multidimensional arrays can be built up by calling this method as many
     * times as necessary.
     * &lt;p&gt;
     * Calling this method twice with the same parameters may return the same
     * object or two equal but not identical objects.
     * &lt;p&gt;
     * As an example, the following piece of code:
     * &lt;pre&gt;{@code
     * ArrayType&lt;String[]&gt; t1 = ArrayType.getArrayType(SimpleType.STRING);
     * ArrayType&lt;String[][]&gt; t2 = ArrayType.getArrayType(t1);
     * ArrayType&lt;String[][][]&gt; t3 = ArrayType.getArrayType(t2);
     * System.out.println(&quot;array class name       = &quot; + t3.getClassName());
     * System.out.println(&quot;element class name     = &quot; + t3.getElementOpenType().getClassName());
     * System.out.println(&quot;array type name        = &quot; + t3.getTypeName());
     * System.out.println(&quot;array type description = &quot; + t3.getDescription());
     * }&lt;/pre&gt;
     * would produce the following output:
     * &lt;pre&gt;{@code
     * array class name       = [[[Ljava.lang.String;
     * element class name     = java.lang.String
     * array type name        = [[[Ljava.lang.String;
     * array type description = 3-dimension array of java.lang.String
     * }&lt;/pre&gt;
     *
     * @param  elementType  the &lt;i&gt;open type&lt;/i&gt; of element values contained
     *                      in the arrays described by this &lt;tt&gt;ArrayType&lt;/tt&gt;
     *                      instance; must be an instance of either
     *                      &lt;tt&gt;SimpleType&lt;/tt&gt;, &lt;tt&gt;CompositeType&lt;/tt&gt;,
     *                      &lt;tt&gt;TabularType&lt;/tt&gt; or another &lt;tt&gt;ArrayType&lt;/tt&gt;
     *                      with a &lt;tt&gt;SimpleType&lt;/tt&gt;, &lt;tt&gt;CompositeType&lt;/tt&gt;
     *                      or &lt;tt&gt;TabularType&lt;/tt&gt; as its &lt;tt&gt;elementType&lt;/tt&gt;.
     *
     * @throws OpenDataException if &lt;var&gt;elementType's className&lt;/var&gt; is not
     *                           one of the allowed Java class names for open
     *                           data.
     *
     * @since 1.6
     */
    public static &lt;E&gt; ArrayType&lt;E[]&gt; getArrayType(OpenType&lt;E&gt; elementType)
        throws OpenDataException {
        return new ArrayType&lt;E[]&gt;(1, elementType);
    }

    /**
     * Create an {@code ArrayType} instance in a type-safe manner.
     * &lt;p&gt;
     * Calling this method twice with the same parameters may return the
     * same object or two equal but not identical objects.
     * &lt;p&gt;
     * As an example, the following piece of code:
     * &lt;pre&gt;{@code
     * ArrayType&lt;int[][][]&gt; t = ArrayType.getPrimitiveArrayType(int[][][].class);
     * System.out.println(&quot;array class name       = &quot; + t.getClassName());
     * System.out.println(&quot;element class name     = &quot; + t.getElementOpenType().getClassName());
     * System.out.println(&quot;array type name        = &quot; + t.getTypeName());
     * System.out.println(&quot;array type description = &quot; + t.getDescription());
     * }&lt;/pre&gt;
     * would produce the following output:
     * &lt;pre&gt;{@code
     * array class name       = [[[I
     * element class name     = java.lang.Integer
     * array type name        = [[[I
     * array type description = 3-dimension array of int
     * }&lt;/pre&gt;
     *
     * @param arrayClass a primitive array class such as {@code int[].class},
     *                   {@code boolean[][].class}, etc. The {@link
     *                   #getElementOpenType()} method of the returned
     *                   {@code ArrayType} returns the {@link SimpleType}
     *                   corresponding to the wrapper type of the primitive
     *                   type of the array.
     *
     * @throws IllegalArgumentException if &lt;var&gt;arrayClass&lt;/var&gt; is not
     *                                  a primitive array.
     *
     * @since 1.6
     */
    @SuppressWarnings(&quot;unchecked&quot;)  // can't get appropriate T for primitive array
    public static &lt;T&gt; ArrayType&lt;T&gt; getPrimitiveArrayType(Class&lt;T&gt; arrayClass) {
        // Check if the supplied parameter is an array
        //
        if (!arrayClass.isArray()) {
            throw new IllegalArgumentException(&quot;arrayClass must be an array&quot;);
        }

        // Calculate array dimension and component type name
        //
        int n = 1;
        Class&lt;?&gt; componentType = arrayClass.getComponentType();
        while (componentType.isArray()) {
            n++;
            componentType = componentType.getComponentType();
        }
        String componentTypeName = componentType.getName();

        // Check if the array's component type is a primitive type
        //
        if (!componentType.isPrimitive()) {
            throw new IllegalArgumentException(
                &quot;component type of the array must be a primitive type&quot;);
        }

        // Map component type name to corresponding SimpleType
        //
        final SimpleType&lt;?&gt; simpleType =
                getPrimitiveOpenType(componentTypeName);

        // Build primitive array
        //
        try {
            @SuppressWarnings(&quot;rawtypes&quot;)
            ArrayType at = new ArrayType(simpleType, true);
            if (n &gt; 1)
                at = new ArrayType&lt;T&gt;(n - 1, at);
            return at;
        } catch (OpenDataException e) {
            throw new IllegalArgumentException(e); // should not happen
        }
    }

    /**
     * Replace/resolve the object read from the stream before it is returned
     * to the caller.
     *
     * @serialData The new serial form of this class defines a new serializable
     * {@code boolean} field {@code primitiveArray}. In order to guarantee the
     * interoperability with previous versions of this class the new serial
     * form must continue to refer to primitive wrapper types even when the
     * {@code ArrayType} instance describes a primitive type array. So when
     * {@code primitiveArray} is {@code true} the {@code className},
     * {@code typeName} and {@code description} serializable fields
     * are converted into primitive types before the deserialized
     * {@code ArrayType} instance is return to the caller. The
     * {@code elementType} field always returns the {@code SimpleType}
     * corresponding to the primitive wrapper type of the array's
     * primitive type.
     * &lt;p&gt;
     * Therefore the following serializable fields are deserialized as follows:
     * &lt;ul&gt;
     *   &lt;li&gt;if {@code primitiveArray} is {@code true} the {@code className}
     *       field is deserialized by replacing the array's component primitive
     *       wrapper type by the corresponding array's component primitive type,
     *       e.g. {@code &quot;[[Ljava.lang.Integer;&quot;} will be deserialized as
     *       {@code &quot;[[I&quot;}.&lt;/li&gt;
     *   &lt;li&gt;if {@code primitiveArray} is {@code true} the {@code typeName}
     *       field is deserialized by replacing the array's component primitive
     *       wrapper type by the corresponding array's component primitive type,
     *       e.g. {@code &quot;[[Ljava.lang.Integer;&quot;} will be deserialized as
     *       {@code &quot;[[I&quot;}.&lt;/li&gt;
     *   &lt;li&gt;if {@code primitiveArray} is {@code true} the {@code description}
     *       field is deserialized by replacing the array's component primitive
     *       wrapper type by the corresponding array's component primitive type,
     *       e.g. {@code &quot;2-dimension array of java.lang.Integer&quot;} will be
     *       deserialized as {@code &quot;2-dimension array of int&quot;}.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @since 1.6
     */
    private Object readResolve() throws ObjectStreamException {
        if (primitiveArray) {
            return convertFromWrapperToPrimitiveTypes();
        } else {
            return this;
        }
    }

    private &lt;T&gt; ArrayType&lt;T&gt; convertFromWrapperToPrimitiveTypes() {
        String cn = getClassName();
        String tn = getTypeName();
        String d = getDescription();
        for (Object[] typeDescr : PRIMITIVE_ARRAY_TYPES) {
            if (cn.indexOf((String)typeDescr[PRIMITIVE_WRAPPER_NAME_INDEX]) != -1) {
                cn = cn.replaceFirst(
                    &quot;L&quot; + typeDescr[PRIMITIVE_WRAPPER_NAME_INDEX] + &quot;;&quot;,
                    (String) typeDescr[PRIMITIVE_TYPE_KEY_INDEX]);
                tn = tn.replaceFirst(
                    &quot;L&quot; + typeDescr[PRIMITIVE_WRAPPER_NAME_INDEX] + &quot;;&quot;,
                    (String) typeDescr[PRIMITIVE_TYPE_KEY_INDEX]);
                d = d.replaceFirst(
                    (String) typeDescr[PRIMITIVE_WRAPPER_NAME_INDEX],
                    (String) typeDescr[PRIMITIVE_TYPE_NAME_INDEX]);
                break;
            }
        }
        return new ArrayType&lt;T&gt;(cn, tn, d,
                                dimension, elementType, primitiveArray);
    }

    /**
     * Nominate a replacement for this object in the stream before the object
     * is written.
     *
     * @serialData The new serial form of this class defines a new serializable
     * {@code boolean} field {@code primitiveArray}. In order to guarantee the
     * interoperability with previous versions of this class the new serial
     * form must continue to refer to primitive wrapper types even when the
     * {@code ArrayType} instance describes a primitive type array. So when
     * {@code primitiveArray} is {@code true} the {@code className},
     * {@code typeName} and {@code description} serializable fields
     * are converted into wrapper types before the serialized
     * {@code ArrayType} instance is written to the stream. The
     * {@code elementType} field always returns the {@code SimpleType}
     * corresponding to the primitive wrapper type of the array's
     * primitive type.
     * &lt;p&gt;
     * Therefore the following serializable fields are serialized as follows:
     * &lt;ul&gt;
     *   &lt;li&gt;if {@code primitiveArray} is {@code true} the {@code className}
     *       field is serialized by replacing the array's component primitive
     *       type by the corresponding array's component primitive wrapper type,
     *       e.g. {@code &quot;[[I&quot;} will be serialized as
     *       {@code &quot;[[Ljava.lang.Integer;&quot;}.&lt;/li&gt;
     *   &lt;li&gt;if {@code primitiveArray} is {@code true} the {@code typeName}
     *       field is serialized by replacing the array's component primitive
     *       type by the corresponding array's component primitive wrapper type,
     *       e.g. {@code &quot;[[I&quot;} will be serialized as
     *       {@code &quot;[[Ljava.lang.Integer;&quot;}.&lt;/li&gt;
     *   &lt;li&gt;if {@code primitiveArray} is {@code true} the {@code description}
     *       field is serialized by replacing the array's component primitive
     *       type by the corresponding array's component primitive wrapper type,
     *       e.g. {@code &quot;2-dimension array of int&quot;} will be serialized as
     *       {@code &quot;2-dimension array of java.lang.Integer&quot;}.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @since 1.6
     */
    private Object writeReplace() throws ObjectStreamException {
        if (primitiveArray) {
            return convertFromPrimitiveToWrapperTypes();
        } else {
            return this;
        }
    }

    private &lt;T&gt; ArrayType&lt;T&gt; convertFromPrimitiveToWrapperTypes() {
        String cn = getClassName();
        String tn = getTypeName();
        String d = getDescription();
        for (Object[] typeDescr : PRIMITIVE_ARRAY_TYPES) {
            if (cn.indexOf((String) typeDescr[PRIMITIVE_TYPE_KEY_INDEX]) != -1) {
                cn = cn.replaceFirst(
                    (String) typeDescr[PRIMITIVE_TYPE_KEY_INDEX],
                    &quot;L&quot; + typeDescr[PRIMITIVE_WRAPPER_NAME_INDEX] + &quot;;&quot;);
                tn = tn.replaceFirst(
                    (String) typeDescr[PRIMITIVE_TYPE_KEY_INDEX],
                    &quot;L&quot; + typeDescr[PRIMITIVE_WRAPPER_NAME_INDEX] + &quot;;&quot;);
                d = d.replaceFirst(
                    (String) typeDescr[PRIMITIVE_TYPE_NAME_INDEX],
                    (String) typeDescr[PRIMITIVE_WRAPPER_NAME_INDEX]);
                break;
            }
        }
        return new ArrayType&lt;T&gt;(cn, tn, d,
                                dimension, elementType, primitiveArray);
    }
}
</pre>
</body>
</html>
