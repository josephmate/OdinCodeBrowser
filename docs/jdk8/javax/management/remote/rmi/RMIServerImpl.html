<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management.remote.rmi;

import com.sun.jmx.remote.internal.ArrayNotificationBuffer;
import com.sun.jmx.remote.internal.NotificationBuffer;
import com.sun.jmx.remote.security.JMXPluggableAuthenticator;
import com.sun.jmx.remote.util.ClassLogger;

import java.io.Closeable;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.rmi.Remote;
import java.rmi.server.RemoteServer;
import java.rmi.server.ServerNotActiveException;
import java.security.Principal;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.management.MBeanServer;
import javax.management.remote.JMXAuthenticator;
import javax.management.remote.JMXConnectorServer;
import javax.security.auth.Subject;

/**
 * &lt;p&gt;An RMI object representing a connector server.  Remote clients
 * can make connections using the {@link #newClient(Object)} method.  This
 * method returns an RMI object representing the connection.&lt;/p&gt;
 *
 * &lt;p&gt;User code does not usually reference this class directly.
 * RMI connection servers are usually created with the class {@link
 * RMIConnectorServer}.  Remote clients usually create connections
 * either with {@link javax.management.remote.JMXConnectorFactory}
 * or by instantiating {@link RMIConnector}.&lt;/p&gt;
 *
 * &lt;p&gt;This is an abstract class.  Concrete subclasses define the
 * details of the client connection objects, such as whether they use
 * JRMP or IIOP.&lt;/p&gt;
 *
 * @since 1.5
 */
public abstract class RMIServerImpl implements Closeable, RMIServer {
    /**
     * &lt;p&gt;Constructs a new &lt;code&gt;RMIServerImpl&lt;/code&gt;.&lt;/p&gt;
     *
     * @param env the environment containing attributes for the new
     * &lt;code&gt;RMIServerImpl&lt;/code&gt;.  Can be null, which is equivalent
     * to an empty Map.
     */
    public RMIServerImpl(Map&lt;String,?&gt; env) {
        this.env = (env == null) ? Collections.&lt;String,Object&gt;emptyMap() : env;
    }

    void setRMIConnectorServer(RMIConnectorServer connServer)
            throws IOException {
        this.connServer = connServer;
    }

    /**
     * &lt;p&gt;Exports this RMI object.&lt;/p&gt;
     *
     * @exception IOException if this RMI object cannot be exported.
     */
    protected abstract void export() throws IOException;

    /**
     * Returns a remotable stub for this server object.
     * @return a remotable stub.
     * @exception IOException if the stub cannot be obtained - e.g the
     *            RMIServerImpl has not been exported yet.
     **/
    public abstract Remote toStub() throws IOException;

    /**
     * &lt;p&gt;Sets the default &lt;code&gt;ClassLoader&lt;/code&gt; for this connector
     * server. New client connections will use this classloader.
     * Existing client connections are unaffected.&lt;/p&gt;
     *
     * @param cl the new &lt;code&gt;ClassLoader&lt;/code&gt; to be used by this
     * connector server.
     *
     * @see #getDefaultClassLoader
     */
    public synchronized void setDefaultClassLoader(ClassLoader cl) {
        this.cl = cl;
    }

    /**
     * &lt;p&gt;Gets the default &lt;code&gt;ClassLoader&lt;/code&gt; used by this connector
     * server.&lt;/p&gt;
     *
     * @return the default &lt;code&gt;ClassLoader&lt;/code&gt; used by this
     * connector server.
     *
     * @see #setDefaultClassLoader
     */
    public synchronized ClassLoader getDefaultClassLoader() {
        return cl;
    }

    /**
     * &lt;p&gt;Sets the &lt;code&gt;MBeanServer&lt;/code&gt; to which this connector
     * server is attached. New client connections will interact
     * with this &lt;code&gt;MBeanServer&lt;/code&gt;. Existing client connections are
     * unaffected.&lt;/p&gt;
     *
     * @param mbs the new &lt;code&gt;MBeanServer&lt;/code&gt;.  Can be null, but
     * new client connections will be refused as long as it is.
     *
     * @see #getMBeanServer
     */
    public synchronized void setMBeanServer(MBeanServer mbs) {
        this.mbeanServer = mbs;
    }

    /**
     * &lt;p&gt;The &lt;code&gt;MBeanServer&lt;/code&gt; to which this connector server
     * is attached.  This is the last value passed to {@link
     * #setMBeanServer} on this object, or null if that method has
     * never been called.&lt;/p&gt;
     *
     * @return the &lt;code&gt;MBeanServer&lt;/code&gt; to which this connector
     * is attached.
     *
     * @see #setMBeanServer
     */
    public synchronized MBeanServer getMBeanServer() {
        return mbeanServer;
    }

    public String getVersion() {
        // Expected format is: &quot;protocol-version implementation-name&quot;
        try {
            return &quot;1.0 java_runtime_&quot; +
                    System.getProperty(&quot;java.runtime.version&quot;);
        } catch (SecurityException e) {
            return &quot;1.0 &quot;;
        }
    }

    /**
     * &lt;p&gt;Creates a new client connection.  This method calls {@link
     * #makeClient makeClient} and adds the returned client connection
     * object to an internal list.  When this
     * &lt;code&gt;RMIServerImpl&lt;/code&gt; is shut down via its {@link
     * #close()} method, the {@link RMIConnection#close() close()}
     * method of each object remaining in the list is called.&lt;/p&gt;
     *
     * &lt;p&gt;The fact that a client connection object is in this internal
     * list does not prevent it from being garbage collected.&lt;/p&gt;
     *
     * @param credentials this object specifies the user-defined
     * credentials to be passed in to the server in order to
     * authenticate the caller before creating the
     * &lt;code&gt;RMIConnection&lt;/code&gt;.  Can be null.
     *
     * @return the newly-created &lt;code&gt;RMIConnection&lt;/code&gt;.  This is
     * usually the object created by &lt;code&gt;makeClient&lt;/code&gt;, though
     * an implementation may choose to wrap that object in another
     * object implementing &lt;code&gt;RMIConnection&lt;/code&gt;.
     *
     * @exception IOException if the new client object cannot be
     * created or exported.
     *
     * @exception SecurityException if the given credentials do not allow
     * the server to authenticate the user successfully.
     *
     * @exception IllegalStateException if {@link #getMBeanServer()}
     * is null.
     */
    public RMIConnection newClient(Object credentials) throws IOException {
        return doNewClient(credentials);
    }

    /**
     * This method could be overridden by subclasses defined in this package
     * to perform additional operations specific to the underlying transport
     * before creating the new client connection.
     */
    RMIConnection doNewClient(Object credentials) throws IOException {
        final boolean tracing = logger.traceOn();

        if (tracing) logger.trace(&quot;newClient&quot;,&quot;making new client&quot;);

        if (getMBeanServer() == null)
            throw new IllegalStateException(&quot;Not attached to an MBean server&quot;);

        Subject subject = null;
        JMXAuthenticator authenticator =
            (JMXAuthenticator) env.get(JMXConnectorServer.AUTHENTICATOR);
        if (authenticator == null) {
            /*
             * Create the JAAS-based authenticator only if authentication
             * has been enabled
             */
            if (env.get(&quot;jmx.remote.x.password.file&quot;) != null ||
                env.get(&quot;jmx.remote.x.login.config&quot;) != null) {
                authenticator = new JMXPluggableAuthenticator(env);
            }
        }
        if (authenticator != null) {
            if (tracing) logger.trace(&quot;newClient&quot;,&quot;got authenticator: &quot; +
                               authenticator.getClass().getName());
            try {
                subject = authenticator.authenticate(credentials);
            } catch (SecurityException e) {
                logger.trace(&quot;newClient&quot;, &quot;Authentication failed: &quot; + e);
                throw e;
            }
        }

        if (tracing) {
            if (subject != null)
                logger.trace(&quot;newClient&quot;,&quot;subject is not null&quot;);
            else logger.trace(&quot;newClient&quot;,&quot;no subject&quot;);
        }

        final String connectionId = makeConnectionId(getProtocol(), subject);

        if (tracing)
            logger.trace(&quot;newClient&quot;,&quot;making new connection: &quot; + connectionId);

        RMIConnection client = makeClient(connectionId, subject);

        dropDeadReferences();
        WeakReference&lt;RMIConnection&gt; wr = new WeakReference&lt;RMIConnection&gt;(client);
        synchronized (clientList) {
            clientList.add(wr);
        }

        connServer.connectionOpened(connectionId, &quot;Connection opened&quot;, null);

        synchronized (clientList) {
            if (!clientList.contains(wr)) {
                // can be removed only by a JMXConnectionNotification listener
                throw new IOException(&quot;The connection is refused.&quot;);
            }
        }

        if (tracing)
            logger.trace(&quot;newClient&quot;,&quot;new connection done: &quot; + connectionId );

        return client;
    }

    /**
     * &lt;p&gt;Creates a new client connection.  This method is called by
     * the public method {@link #newClient(Object)}.&lt;/p&gt;
     *
     * @param connectionId the ID of the new connection.  Every
     * connection opened by this connector server will have a
     * different ID.  The behavior is unspecified if this parameter is
     * null.
     *
     * @param subject the authenticated subject.  Can be null.
     *
     * @return the newly-created &lt;code&gt;RMIConnection&lt;/code&gt;.
     *
     * @exception IOException if the new client object cannot be
     * created or exported.
     */
    protected abstract RMIConnection makeClient(String connectionId,
                                                Subject subject)
            throws IOException;

    /**
     * &lt;p&gt;Closes a client connection made by {@link #makeClient makeClient}.
     *
     * @param client a connection previously returned by
     * &lt;code&gt;makeClient&lt;/code&gt; on which the &lt;code&gt;closeClient&lt;/code&gt;
     * method has not previously been called.  The behavior is
     * unspecified if these conditions are violated, including the
     * case where &lt;code&gt;client&lt;/code&gt; is null.
     *
     * @exception IOException if the client connection cannot be
     * closed.
     */
    protected abstract void closeClient(RMIConnection client)
            throws IOException;

    /**
     * &lt;p&gt;Returns the protocol string for this object.  The string is
     * &lt;code&gt;rmi&lt;/code&gt; for RMI/JRMP and &lt;code&gt;iiop&lt;/code&gt; for RMI/IIOP.
     *
     * @return the protocol string for this object.
     */
    protected abstract String getProtocol();

    /**
     * &lt;p&gt;Method called when a client connection created by {@link
     * #makeClient makeClient} is closed.  A subclass that defines
     * &lt;code&gt;makeClient&lt;/code&gt; must arrange for this method to be
     * called when the resultant object's {@link RMIConnection#close()
     * close} method is called.  This enables it to be removed from
     * the &lt;code&gt;RMIServerImpl&lt;/code&gt;'s list of connections.  It is
     * not an error for &lt;code&gt;client&lt;/code&gt; not to be in that
     * list.&lt;/p&gt;
     *
     * &lt;p&gt;After removing &lt;code&gt;client&lt;/code&gt; from the list of
     * connections, this method calls {@link #closeClient
     * closeClient(client)}.&lt;/p&gt;
     *
     * @param client the client connection that has been closed.
     *
     * @exception IOException if {@link #closeClient} throws this
     * exception.
     *
     * @exception NullPointerException if &lt;code&gt;client&lt;/code&gt; is null.
     */
    protected void clientClosed(RMIConnection client) throws IOException {
        final boolean debug = logger.debugOn();

        if (debug) logger.trace(&quot;clientClosed&quot;,&quot;client=&quot;+client);

        if (client == null)
            throw new NullPointerException(&quot;Null client&quot;);

        synchronized (clientList) {
            dropDeadReferences();
            for (Iterator&lt;WeakReference&lt;RMIConnection&gt;&gt; it = clientList.iterator();
                 it.hasNext(); ) {
                WeakReference&lt;RMIConnection&gt; wr = it.next();
                if (wr.get() == client) {
                    it.remove();
                    break;
                }
            }
            /* It is not a bug for this loop not to find the client.  In
               our close() method, we remove a client from the list before
               calling its close() method.  */
        }

        if (debug) logger.trace(&quot;clientClosed&quot;, &quot;closing client.&quot;);
        closeClient(client);

        if (debug) logger.trace(&quot;clientClosed&quot;, &quot;sending notif&quot;);
        connServer.connectionClosed(client.getConnectionId(),
                                    &quot;Client connection closed&quot;, null);

        if (debug) logger.trace(&quot;clientClosed&quot;,&quot;done&quot;);
    }

    /**
     * &lt;p&gt;Closes this connection server.  This method first calls the
     * {@link #closeServer()} method so that no new client connections
     * will be accepted.  Then, for each remaining {@link
     * RMIConnection} object returned by {@link #makeClient
     * makeClient}, its {@link RMIConnection#close() close} method is
     * called.&lt;/p&gt;
     *
     * &lt;p&gt;The behavior when this method is called more than once is
     * unspecified.&lt;/p&gt;
     *
     * &lt;p&gt;If {@link #closeServer()} throws an
     * &lt;code&gt;IOException&lt;/code&gt;, the individual connections are
     * nevertheless closed, and then the &lt;code&gt;IOException&lt;/code&gt; is
     * thrown from this method.&lt;/p&gt;
     *
     * &lt;p&gt;If {@link #closeServer()} returns normally but one or more
     * of the individual connections throws an
     * &lt;code&gt;IOException&lt;/code&gt;, then, after closing all the
     * connections, one of those &lt;code&gt;IOException&lt;/code&gt;s is thrown
     * from this method.  If more than one connection throws an
     * &lt;code&gt;IOException&lt;/code&gt;, it is unspecified which one is thrown
     * from this method.&lt;/p&gt;
     *
     * @exception IOException if {@link #closeServer()} or one of the
     * {@link RMIConnection#close()} calls threw
     * &lt;code&gt;IOException&lt;/code&gt;.
     */
    public synchronized void close() throws IOException {
        final boolean tracing = logger.traceOn();
        final boolean debug   = logger.debugOn();

        if (tracing) logger.trace(&quot;close&quot;,&quot;closing&quot;);

        IOException ioException = null;
        try {
            if (debug)   logger.debug(&quot;close&quot;,&quot;closing Server&quot;);
            closeServer();
        } catch (IOException e) {
            if (tracing) logger.trace(&quot;close&quot;,&quot;Failed to close server: &quot; + e);
            if (debug)   logger.debug(&quot;close&quot;,e);
            ioException = e;
        }

        if (debug)   logger.debug(&quot;close&quot;,&quot;closing Clients&quot;);
        // Loop to close all clients
        while (true) {
            synchronized (clientList) {
                if (debug) logger.debug(&quot;close&quot;,&quot;droping dead references&quot;);
                dropDeadReferences();

                if (debug) logger.debug(&quot;close&quot;,&quot;client count: &quot;+clientList.size());
                if (clientList.size() == 0)
                    break;
                /* Loop until we find a non-null client.  Because we called
                   dropDeadReferences(), this will usually be the first
                   element of the list, but a garbage collection could have
                   happened in between.  */
                for (Iterator&lt;WeakReference&lt;RMIConnection&gt;&gt; it = clientList.iterator();
                     it.hasNext(); ) {
                    WeakReference&lt;RMIConnection&gt; wr = it.next();
                    RMIConnection client = wr.get();
                    it.remove();
                    if (client != null) {
                        try {
                            client.close();
                        } catch (IOException e) {
                            if (tracing)
                                logger.trace(&quot;close&quot;,&quot;Failed to close client: &quot; + e);
                            if (debug) logger.debug(&quot;close&quot;,e);
                            if (ioException == null)
                                ioException = e;
                        }
                        break;
                    }
                }
            }
        }

        if(notifBuffer != null)
            notifBuffer.dispose();

        if (ioException != null) {
            if (tracing) logger.trace(&quot;close&quot;,&quot;close failed.&quot;);
            throw ioException;
        }

        if (tracing) logger.trace(&quot;close&quot;,&quot;closed.&quot;);
    }

    /**
     * &lt;p&gt;Called by {@link #close()} to close the connector server.
     * After returning from this method, the connector server must
     * not accept any new connections.&lt;/p&gt;
     *
     * @exception IOException if the attempt to close the connector
     * server failed.
     */
    protected abstract void closeServer() throws IOException;

    private static synchronized String makeConnectionId(String protocol,
                                                        Subject subject) {
        connectionIdNumber++;

        String clientHost = &quot;&quot;;
        try {
            clientHost = RemoteServer.getClientHost();
            /*
             * According to the rules specified in the javax.management.remote
             * package description, a numeric IPv6 address (detected by the
             * presence of otherwise forbidden &quot;:&quot; character) forming a part
             * of the connection id must be enclosed in square brackets.
             */
            if (clientHost.contains(&quot;:&quot;)) {
                clientHost = &quot;[&quot; + clientHost + &quot;]&quot;;
            }
        } catch (ServerNotActiveException e) {
            logger.trace(&quot;makeConnectionId&quot;, &quot;getClientHost&quot;, e);
        }

        final StringBuilder buf = new StringBuilder();
        buf.append(protocol).append(&quot;:&quot;);
        if (clientHost.length() &gt; 0)
            buf.append(&quot;//&quot;).append(clientHost);
        buf.append(&quot; &quot;);
        if (subject != null) {
            Set&lt;Principal&gt; principals = subject.getPrincipals();
            String sep = &quot;&quot;;
            for (Iterator&lt;Principal&gt; it = principals.iterator(); it.hasNext(); ) {
                Principal p = it.next();
                String name = p.getName().replace(' ', '_').replace(';', ':');
                buf.append(sep).append(name);
                sep = &quot;;&quot;;
            }
        }
        buf.append(&quot; &quot;).append(connectionIdNumber);
        if (logger.traceOn())
            logger.trace(&quot;newConnectionId&quot;,&quot;connectionId=&quot;+buf);
        return buf.toString();
    }

    private void dropDeadReferences() {
        synchronized (clientList) {
            for (Iterator&lt;WeakReference&lt;RMIConnection&gt;&gt; it = clientList.iterator();
                 it.hasNext(); ) {
                WeakReference&lt;RMIConnection&gt; wr = it.next();
                if (wr.get() == null)
                    it.remove();
            }
        }
    }

    synchronized NotificationBuffer getNotifBuffer() {
        //Notification buffer is lazily created when the first client connects
        if(notifBuffer == null)
            notifBuffer =
                ArrayNotificationBuffer.getNotificationBuffer(mbeanServer,
                                                              env);
        return notifBuffer;
    }

    private static final ClassLogger logger =
        new ClassLogger(&quot;javax.management.remote.rmi&quot;, &quot;RMIServerImpl&quot;);

    /** List of WeakReference values.  Each one references an
        RMIConnection created by this object, or null if the
        RMIConnection has been garbage-collected.  */
    private final List&lt;WeakReference&lt;RMIConnection&gt;&gt; clientList =
            new ArrayList&lt;WeakReference&lt;RMIConnection&gt;&gt;();

    private ClassLoader cl;

    private MBeanServer mbeanServer;

    private final Map&lt;String, ?&gt; env;

    private RMIConnectorServer connServer;

    private static int connectionIdNumber;

    private NotificationBuffer notifBuffer;
}
</pre>
</body>
</html>
