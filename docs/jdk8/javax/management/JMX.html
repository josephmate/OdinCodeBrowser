<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management;

import com.sun.jmx.mbeanserver.Introspector;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Modifier;
import java.lang.reflect.Proxy;
import sun.reflect.misc.ReflectUtil;

/**
 * Static methods from the JMX API.  There are no instances of this class.
 *
 * @since 1.6
 */
public class JMX {
    /* Code within this package can prove that by providing this instance of
     * this class.
     */
    static final JMX proof = new JMX();

    private JMX() {}

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#defaultValue&quot;&gt;{@code
     * defaultValue}&lt;/a&gt; field.
     */
    public static final String DEFAULT_VALUE_FIELD = &quot;defaultValue&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#immutableInfo&quot;&gt;{@code
     * immutableInfo}&lt;/a&gt; field.
     */
    public static final String IMMUTABLE_INFO_FIELD = &quot;immutableInfo&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#interfaceClassName&quot;&gt;{@code
     * interfaceClassName}&lt;/a&gt; field.
     */
    public static final String INTERFACE_CLASS_NAME_FIELD = &quot;interfaceClassName&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#legalValues&quot;&gt;{@code
     * legalValues}&lt;/a&gt; field.
     */
    public static final String LEGAL_VALUES_FIELD = &quot;legalValues&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#maxValue&quot;&gt;{@code
     * maxValue}&lt;/a&gt; field.
     */
    public static final String MAX_VALUE_FIELD = &quot;maxValue&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#minValue&quot;&gt;{@code
     * minValue}&lt;/a&gt; field.
     */
    public static final String MIN_VALUE_FIELD = &quot;minValue&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#mxbean&quot;&gt;{@code
     * mxbean}&lt;/a&gt; field.
     */
    public static final String MXBEAN_FIELD = &quot;mxbean&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#openType&quot;&gt;{@code
     * openType}&lt;/a&gt; field.
     */
    public static final String OPEN_TYPE_FIELD = &quot;openType&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#originalType&quot;&gt;{@code
     * originalType}&lt;/a&gt; field.
     */
    public static final String ORIGINAL_TYPE_FIELD = &quot;originalType&quot;;

    /**
     * &lt;p&gt;Make a proxy for a Standard MBean in a local or remote
     * MBean Server.&lt;/p&gt;
     *
     * &lt;p&gt;If you have an MBean Server {@code mbs} containing an MBean
     * with {@link ObjectName} {@code name}, and if the MBean's
     * management interface is described by the Java interface
     * {@code MyMBean}, you can construct a proxy for the MBean like
     * this:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * MyMBean proxy = JMX.newMBeanProxy(mbs, name, MyMBean.class);
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Suppose, for example, {@code MyMBean} looks like this:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * public interface MyMBean {
     *     public String getSomeAttribute();
     *     public void setSomeAttribute(String value);
     *     public void someOperation(String param1, int param2);
     * }
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Then you can execute:&lt;/p&gt;
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;{@code proxy.getSomeAttribute()} which will result in a
     * call to {@code mbs.}{@link MBeanServerConnection#getAttribute
     * getAttribute}{@code (name, &quot;SomeAttribute&quot;)}.
     *
     * &lt;li&gt;{@code proxy.setSomeAttribute(&quot;whatever&quot;)} which will result
     * in a call to {@code mbs.}{@link MBeanServerConnection#setAttribute
     * setAttribute}{@code (name, new Attribute(&quot;SomeAttribute&quot;, &quot;whatever&quot;))}.
     *
     * &lt;li&gt;{@code proxy.someOperation(&quot;param1&quot;, 2)} which will be
     * translated into a call to {@code mbs.}{@link
     * MBeanServerConnection#invoke invoke}{@code (name, &quot;someOperation&quot;, &lt;etc&gt;)}.
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt;The object returned by this method is a
     * {@link Proxy} whose {@code InvocationHandler} is an
     * {@link MBeanServerInvocationHandler}.&lt;/p&gt;
     *
     * &lt;p&gt;This method is equivalent to {@link
     * #newMBeanProxy(MBeanServerConnection, ObjectName, Class,
     * boolean) newMBeanProxy(connection, objectName, interfaceClass,
     * false)}.&lt;/p&gt;
     *
     * @param connection the MBean server to forward to.
     * @param objectName the name of the MBean within
     * {@code connection} to forward to.
     * @param interfaceClass the management interface that the MBean
     * exports, which will also be implemented by the returned proxy.
     *
     * @param &lt;T&gt; allows the compiler to know that if the {@code
     * interfaceClass} parameter is {@code MyMBean.class}, for
     * example, then the return type is {@code MyMBean}.
     *
     * @return the new proxy instance.
     *
     * @throws IllegalArgumentException if {@code interfaceClass} is not
     * a &lt;a href=&quot;package-summary.html#mgIface&quot;&gt;compliant MBean
     * interface&lt;/a&gt;
     */
    public static &lt;T&gt; T newMBeanProxy(MBeanServerConnection connection,
                                      ObjectName objectName,
                                      Class&lt;T&gt; interfaceClass) {
        return newMBeanProxy(connection, objectName, interfaceClass, false);
    }

    /**
     * &lt;p&gt;Make a proxy for a Standard MBean in a local or remote MBean
     * Server that may also support the methods of {@link
     * NotificationEmitter}.&lt;/p&gt;
     *
     * &lt;p&gt;This method behaves the same as {@link
     * #newMBeanProxy(MBeanServerConnection, ObjectName, Class)}, but
     * additionally, if {@code notificationEmitter} is {@code
     * true}, then the MBean is assumed to be a {@link
     * NotificationBroadcaster} or {@link NotificationEmitter} and the
     * returned proxy will implement {@link NotificationEmitter} as
     * well as {@code interfaceClass}.  A call to {@link
     * NotificationBroadcaster#addNotificationListener} on the proxy
     * will result in a call to {@link
     * MBeanServerConnection#addNotificationListener(ObjectName,
     * NotificationListener, NotificationFilter, Object)}, and
     * likewise for the other methods of {@link
     * NotificationBroadcaster} and {@link NotificationEmitter}.&lt;/p&gt;
     *
     * @param connection the MBean server to forward to.
     * @param objectName the name of the MBean within
     * {@code connection} to forward to.
     * @param interfaceClass the management interface that the MBean
     * exports, which will also be implemented by the returned proxy.
     * @param notificationEmitter make the returned proxy
     * implement {@link NotificationEmitter} by forwarding its methods
     * via {@code connection}.
     *
     * @param &lt;T&gt; allows the compiler to know that if the {@code
     * interfaceClass} parameter is {@code MyMBean.class}, for
     * example, then the return type is {@code MyMBean}.
     *
     * @return the new proxy instance.
     *
     * @throws IllegalArgumentException if {@code interfaceClass} is not
     * a &lt;a href=&quot;package-summary.html#mgIface&quot;&gt;compliant MBean
     * interface&lt;/a&gt;
     */
    public static &lt;T&gt; T newMBeanProxy(MBeanServerConnection connection,
                                      ObjectName objectName,
                                      Class&lt;T&gt; interfaceClass,
                                      boolean notificationEmitter) {
        return createProxy(connection, objectName, interfaceClass, notificationEmitter, false);
    }

    /**
     * Make a proxy for an MXBean in a local or remote MBean Server.
     *
     * &lt;p&gt;If you have an MBean Server {@code mbs} containing an
     * MXBean with {@link ObjectName} {@code name}, and if the
     * MXBean's management interface is described by the Java
     * interface {@code MyMXBean}, you can construct a proxy for
     * the MXBean like this:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * MyMXBean proxy = JMX.newMXBeanProxy(mbs, name, MyMXBean.class);
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Suppose, for example, {@code MyMXBean} looks like this:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * public interface MyMXBean {
     *     public String getSimpleAttribute();
     *     public void setSimpleAttribute(String value);
     *     public {@link java.lang.management.MemoryUsage} getMappedAttribute();
     *     public void setMappedAttribute(MemoryUsage memoryUsage);
     *     public MemoryUsage someOperation(String param1, MemoryUsage param2);
     * }
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Then:&lt;/p&gt;
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;&lt;p&gt;{@code proxy.getSimpleAttribute()} will result in a
     * call to {@code mbs.}{@link MBeanServerConnection#getAttribute
     * getAttribute}{@code (name, &quot;SimpleAttribute&quot;)}.&lt;/p&gt;
     *
     * &lt;li&gt;&lt;p&gt;{@code proxy.setSimpleAttribute(&quot;whatever&quot;)} will result
     * in a call to {@code mbs.}{@link
     * MBeanServerConnection#setAttribute setAttribute}&lt;code&gt;(name,
     * new Attribute(&quot;SimpleAttribute&quot;, &quot;whatever&quot;))&lt;/code&gt;.&lt;/p&gt;
     *
     *     &lt;p&gt;Because {@code String} is a &lt;em&gt;simple type&lt;/em&gt;, in the
     *     sense of {@link javax.management.openmbean.SimpleType}, it
     *     is not changed in the context of an MXBean.  The MXBean
     *     proxy behaves the same as a Standard MBean proxy (see
     *     {@link #newMBeanProxy(MBeanServerConnection, ObjectName,
     *     Class) newMBeanProxy}) for the attribute {@code
     *     SimpleAttribute}.&lt;/p&gt;
     *
     * &lt;li&gt;&lt;p&gt;{@code proxy.getMappedAttribute()} will result in a call
     * to {@code mbs.getAttribute(&quot;MappedAttribute&quot;)}.  The MXBean
     * mapping rules mean that the actual type of the attribute {@code
     * MappedAttribute} will be {@link
     * javax.management.openmbean.CompositeData CompositeData} and
     * that is what the {@code mbs.getAttribute} call will return.
     * The proxy will then convert the {@code CompositeData} back into
     * the expected type {@code MemoryUsage} using the MXBean mapping
     * rules.&lt;/p&gt;
     *
     * &lt;li&gt;&lt;p&gt;Similarly, {@code proxy.setMappedAttribute(memoryUsage)}
     * will convert the {@code MemoryUsage} argument into a {@code
     * CompositeData} before calling {@code mbs.setAttribute}.&lt;/p&gt;
     *
     * &lt;li&gt;&lt;p&gt;{@code proxy.someOperation(&quot;whatever&quot;, memoryUsage)}
     * will convert the {@code MemoryUsage} argument into a {@code
     * CompositeData} and call {@code mbs.invoke}.  The value returned
     * by {@code mbs.invoke} will be also be a {@code CompositeData},
     * and the proxy will convert this into the expected type {@code
     * MemoryUsage} using the MXBean mapping rules.&lt;/p&gt;
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt;The object returned by this method is a
     * {@link Proxy} whose {@code InvocationHandler} is an
     * {@link MBeanServerInvocationHandler}.&lt;/p&gt;
     *
     * &lt;p&gt;This method is equivalent to {@link
     * #newMXBeanProxy(MBeanServerConnection, ObjectName, Class,
     * boolean) newMXBeanProxy(connection, objectName, interfaceClass,
     * false)}.&lt;/p&gt;
     *
     * @param connection the MBean server to forward to.
     * @param objectName the name of the MBean within
     * {@code connection} to forward to.
     * @param interfaceClass the MXBean interface,
     * which will also be implemented by the returned proxy.
     *
     * @param &lt;T&gt; allows the compiler to know that if the {@code
     * interfaceClass} parameter is {@code MyMXBean.class}, for
     * example, then the return type is {@code MyMXBean}.
     *
     * @return the new proxy instance.
     *
     * @throws IllegalArgumentException if {@code interfaceClass} is not
     * a {@link javax.management.MXBean compliant MXBean interface}
     */
    public static &lt;T&gt; T newMXBeanProxy(MBeanServerConnection connection,
                                       ObjectName objectName,
                                       Class&lt;T&gt; interfaceClass) {
        return newMXBeanProxy(connection, objectName, interfaceClass, false);
    }

    /**
     * &lt;p&gt;Make a proxy for an MXBean in a local or remote MBean
     * Server that may also support the methods of {@link
     * NotificationEmitter}.&lt;/p&gt;
     *
     * &lt;p&gt;This method behaves the same as {@link
     * #newMXBeanProxy(MBeanServerConnection, ObjectName, Class)}, but
     * additionally, if {@code notificationEmitter} is {@code
     * true}, then the MXBean is assumed to be a {@link
     * NotificationBroadcaster} or {@link NotificationEmitter} and the
     * returned proxy will implement {@link NotificationEmitter} as
     * well as {@code interfaceClass}.  A call to {@link
     * NotificationBroadcaster#addNotificationListener} on the proxy
     * will result in a call to {@link
     * MBeanServerConnection#addNotificationListener(ObjectName,
     * NotificationListener, NotificationFilter, Object)}, and
     * likewise for the other methods of {@link
     * NotificationBroadcaster} and {@link NotificationEmitter}.&lt;/p&gt;
     *
     * @param connection the MBean server to forward to.
     * @param objectName the name of the MBean within
     * {@code connection} to forward to.
     * @param interfaceClass the MXBean interface,
     * which will also be implemented by the returned proxy.
     * @param notificationEmitter make the returned proxy
     * implement {@link NotificationEmitter} by forwarding its methods
     * via {@code connection}.
     *
     * @param &lt;T&gt; allows the compiler to know that if the {@code
     * interfaceClass} parameter is {@code MyMXBean.class}, for
     * example, then the return type is {@code MyMXBean}.
     *
     * @return the new proxy instance.
     *
     * @throws IllegalArgumentException if {@code interfaceClass} is not
     * a {@link javax.management.MXBean compliant MXBean interface}
     */
    public static &lt;T&gt; T newMXBeanProxy(MBeanServerConnection connection,
                                       ObjectName objectName,
                                       Class&lt;T&gt; interfaceClass,
                                       boolean notificationEmitter) {
        return createProxy(connection, objectName, interfaceClass, notificationEmitter, true);
    }

    /**
     * &lt;p&gt;Test whether an interface is an MXBean interface.
     * An interface is an MXBean interface if it is public,
     * annotated {@link MXBean &amp;#64;MXBean} or {@code @MXBean(true)}
     * or if it does not have an {@code @MXBean} annotation
     * and its name ends with &quot;{@code MXBean}&quot;.&lt;/p&gt;
     *
     * @param interfaceClass The candidate interface.
     *
     * @return true if {@code interfaceClass} is a
     * {@link javax.management.MXBean compliant MXBean interface}
     *
     * @throws NullPointerException if {@code interfaceClass} is null.
     */
    public static boolean isMXBeanInterface(Class&lt;?&gt; interfaceClass) {
        if (!interfaceClass.isInterface())
            return false;
        if (!Modifier.isPublic(interfaceClass.getModifiers()) &amp;&amp;
            !Introspector.ALLOW_NONPUBLIC_MBEAN) {
            return false;
        }
        MXBean a = interfaceClass.getAnnotation(MXBean.class);
        if (a != null)
            return a.value();
        return interfaceClass.getName().endsWith(&quot;MXBean&quot;);
        // We don't bother excluding the case where the name is
        // exactly the string &quot;MXBean&quot; since that would mean there
        // was no package name, which is pretty unlikely in practice.
    }

    /**
     * Centralised M(X)Bean proxy creation code
     * @param connection {@linkplain MBeanServerConnection} to use
     * @param objectName M(X)Bean object name
     * @param interfaceClass M(X)Bean interface class
     * @param notificationEmitter Is a notification emitter?
     * @param isMXBean Is an MXBean?
     * @return Returns an M(X)Bean proxy generated for the provided interface class
     * @throws SecurityException
     * @throws IllegalArgumentException
     */
    private static &lt;T&gt; T createProxy(MBeanServerConnection connection,
                                     ObjectName objectName,
                                     Class&lt;T&gt; interfaceClass,
                                     boolean notificationEmitter,
                                     boolean isMXBean) {

        try {
            if (isMXBean) {
                // Check interface for MXBean compliance
                Introspector.testComplianceMXBeanInterface(interfaceClass);
            } else {
                // Check interface for MBean compliance
                Introspector.testComplianceMBeanInterface(interfaceClass);
            }
        } catch (NotCompliantMBeanException e) {
            throw new IllegalArgumentException(e);
        }

        InvocationHandler handler = new MBeanServerInvocationHandler(
                connection, objectName, isMXBean);
        final Class&lt;?&gt;[] interfaces;
        if (notificationEmitter) {
            interfaces =
                new Class&lt;?&gt;[] {interfaceClass, NotificationEmitter.class};
        } else
            interfaces = new Class&lt;?&gt;[] {interfaceClass};

        Object proxy = Proxy.newProxyInstance(
                interfaceClass.getClassLoader(),
                interfaces,
                handler);
        return interfaceClass.cast(proxy);
    }
}
</pre>
</body>
</html>
