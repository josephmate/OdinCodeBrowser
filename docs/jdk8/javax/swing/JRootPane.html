<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import java.applet.Applet;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.security.AccessController;
import javax.accessibility.*;
import javax.swing.plaf.RootPaneUI;
import java.util.Vector;
import java.io.Serializable;
import javax.swing.border.*;
import sun.awt.AWTAccessor;
import sun.security.action.GetBooleanAction;


/**
 * A lightweight container used behind the scenes by
 * &lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;JDialog&lt;/code&gt;, &lt;code&gt;JWindow&lt;/code&gt;,
 * &lt;code&gt;JApplet&lt;/code&gt;, and &lt;code&gt;JInternalFrame&lt;/code&gt;.
 * For task-oriented information on functionality provided by root panes
 * see &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/rootpane.html&quot;&gt;How to Use Root Panes&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
 *
 * &lt;p&gt;
 * The following image shows the relationships between
 * the classes that use root panes.
 * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/JRootPane-1.gif&quot;
 * alt=&quot;The following text describes this graphic.&quot;
 * HEIGHT=484 WIDTH=629&gt;&lt;/p&gt;
 * The &amp;quot;heavyweight&amp;quot; components (those that delegate to a peer, or native
 * component on the host system) are shown with a darker, heavier box. The four
 * heavyweight JFC/Swing containers (&lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;JDialog&lt;/code&gt;,
 * &lt;code&gt;JWindow&lt;/code&gt;, and &lt;code&gt;JApplet&lt;/code&gt;) are
 * shown in relation to the AWT classes they extend.
 * These four components are the
 * only heavyweight containers in the Swing library. The lightweight container
 * &lt;code&gt;JInternalFrame&lt;/code&gt; is also shown.
 * All five of these JFC/Swing containers implement the
 * &lt;code&gt;RootPaneContainer&lt;/code&gt; interface,
 * and they all delegate their operations to a
 * &lt;code&gt;JRootPane&lt;/code&gt; (shown with a little &quot;handle&quot; on top).
 * &lt;blockquote&gt;
 * &lt;b&gt;Note:&lt;/b&gt; The &lt;code&gt;JComponent&lt;/code&gt; method &lt;code&gt;getRootPane&lt;/code&gt;
 * can be used to obtain the &lt;code&gt;JRootPane&lt;/code&gt; that contains
 * a given component.
 * &lt;/blockquote&gt;
 * &lt;table style=&quot;float:right&quot; border=&quot;0&quot; summary=&quot;layout&quot;&gt;
 * &lt;tr&gt;
 * &lt;td align=&quot;center&quot;&gt;
 * &lt;img src=&quot;doc-files/JRootPane-2.gif&quot;
 * alt=&quot;The following text describes this graphic.&quot; HEIGHT=386 WIDTH=349&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;
 * The diagram at right shows the structure of a &lt;code&gt;JRootPane&lt;/code&gt;.
 * A &lt;code&gt;JRootpane&lt;/code&gt; is made up of a &lt;code&gt;glassPane&lt;/code&gt;,
 * an optional &lt;code&gt;menuBar&lt;/code&gt;, and a &lt;code&gt;contentPane&lt;/code&gt;.
 * (The &lt;code&gt;JLayeredPane&lt;/code&gt; manages the &lt;code&gt;menuBar&lt;/code&gt;
 * and the &lt;code&gt;contentPane&lt;/code&gt;.)
 * The &lt;code&gt;glassPane&lt;/code&gt; sits over the top of everything,
 * where it is in a position to intercept mouse movements.
 * Since the &lt;code&gt;glassPane&lt;/code&gt; (like the &lt;code&gt;contentPane&lt;/code&gt;)
 * can be an arbitrary component, it is also possible to set up the
 * &lt;code&gt;glassPane&lt;/code&gt; for drawing. Lines and images on the
 * &lt;code&gt;glassPane&lt;/code&gt; can then range
 * over the frames underneath without being limited by their boundaries.
 * &lt;p&gt;
 * Although the &lt;code&gt;menuBar&lt;/code&gt; component is optional,
 * the &lt;code&gt;layeredPane&lt;/code&gt;, &lt;code&gt;contentPane&lt;/code&gt;,
 * and &lt;code&gt;glassPane&lt;/code&gt; always exist.
 * Attempting to set them to &lt;code&gt;null&lt;/code&gt; generates an exception.
 * &lt;p&gt;
 * To add components to the &lt;code&gt;JRootPane&lt;/code&gt; (other than the
 * optional menu bar), you add the object to the &lt;code&gt;contentPane&lt;/code&gt;
 * of the &lt;code&gt;JRootPane&lt;/code&gt;, like this:
 * &lt;pre&gt;
 *       rootPane.getContentPane().add(child);
 * &lt;/pre&gt;
 * The same principle holds true for setting layout managers, removing
 * components, listing children, etc. All these methods are invoked on
 * the &lt;code&gt;contentPane&lt;/code&gt; instead of on the &lt;code&gt;JRootPane&lt;/code&gt;.
 * &lt;blockquote&gt;
 * &lt;b&gt;Note:&lt;/b&gt; The default layout manager for the &lt;code&gt;contentPane&lt;/code&gt; is
 *  a &lt;code&gt;BorderLayout&lt;/code&gt; manager. However, the &lt;code&gt;JRootPane&lt;/code&gt;
 *  uses a custom &lt;code&gt;LayoutManager&lt;/code&gt;.
 *  So, when you want to change the layout manager for the components you added
 *  to a &lt;code&gt;JRootPane&lt;/code&gt;, be sure to use code like this:
 * &lt;pre&gt;
 *    rootPane.getContentPane().setLayout(new BoxLayout());
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * If a &lt;code&gt;JMenuBar&lt;/code&gt; component is set on the &lt;code&gt;JRootPane&lt;/code&gt;,
 * it is positioned along the upper edge of the frame.
 * The &lt;code&gt;contentPane&lt;/code&gt; is adjusted in location and size to
 * fill the remaining area.
 * (The &lt;code&gt;JMenuBar&lt;/code&gt; and the &lt;code&gt;contentPane&lt;/code&gt; are added to the
 * &lt;code&gt;layeredPane&lt;/code&gt; component at the
 * &lt;code&gt;JLayeredPane.FRAME_CONTENT_LAYER&lt;/code&gt; layer.)
 * &lt;p&gt;
 * The &lt;code&gt;layeredPane&lt;/code&gt; is the parent of all children in the
 * &lt;code&gt;JRootPane&lt;/code&gt; -- both as the direct parent of the menu and
 * the grandparent of all components added to the &lt;code&gt;contentPane&lt;/code&gt;.
 * It is an instance of &lt;code&gt;JLayeredPane&lt;/code&gt;,
 * which provides the ability to add components at several layers.
 * This capability is very useful when working with menu popups,
 * dialog boxes, and dragging -- situations in which you need to place
 * a component on top of all other components in the pane.
 * &lt;p&gt;
 * The &lt;code&gt;glassPane&lt;/code&gt; sits on top of all other components in the
 * &lt;code&gt;JRootPane&lt;/code&gt;.
 * That provides a convenient place to draw above all other components,
 * and makes it possible to intercept mouse events,
 * which is useful both for dragging and for drawing.
 * Developers can use &lt;code&gt;setVisible&lt;/code&gt; on the &lt;code&gt;glassPane&lt;/code&gt;
 * to control when the &lt;code&gt;glassPane&lt;/code&gt; displays over the other children.
 * By default the &lt;code&gt;glassPane&lt;/code&gt; is not visible.
 * &lt;p&gt;
 * The custom &lt;code&gt;LayoutManager&lt;/code&gt; used by &lt;code&gt;JRootPane&lt;/code&gt;
 * ensures that:
 * &lt;OL&gt;
 * &lt;LI&gt;The &lt;code&gt;glassPane&lt;/code&gt; fills the entire viewable
 *     area of the &lt;code&gt;JRootPane&lt;/code&gt; (bounds - insets).
 * &lt;LI&gt;The &lt;code&gt;layeredPane&lt;/code&gt; fills the entire viewable area of the
 *     &lt;code&gt;JRootPane&lt;/code&gt;. (bounds - insets)
 * &lt;LI&gt;The &lt;code&gt;menuBar&lt;/code&gt; is positioned at the upper edge of the
 *     &lt;code&gt;layeredPane&lt;/code&gt;.
 * &lt;LI&gt;The &lt;code&gt;contentPane&lt;/code&gt; fills the entire viewable area,
 *     minus the &lt;code&gt;menuBar&lt;/code&gt;, if present.
 * &lt;/OL&gt;
 * Any other views in the &lt;code&gt;JRootPane&lt;/code&gt; view hierarchy are ignored.
 * &lt;p&gt;
 * If you replace the &lt;code&gt;LayoutManager&lt;/code&gt; of the &lt;code&gt;JRootPane&lt;/code&gt;,
 * you are responsible for managing all of these views.
 * So ordinarily you will want to be sure that you
 * change the layout manager for the &lt;code&gt;contentPane&lt;/code&gt; rather than
 * for the &lt;code&gt;JRootPane&lt;/code&gt; itself!
 * &lt;p&gt;
 * The painting architecture of Swing requires an opaque
 * &lt;code&gt;JComponent&lt;/code&gt;
 * to exist in the containment hierarchy above all other components. This is
 * typically provided by way of the content pane. If you replace the content
 * pane, it is recommended that you make the content pane opaque
 * by way of &lt;code&gt;setOpaque(true)&lt;/code&gt;. Additionally, if the content pane
 * overrides &lt;code&gt;paintComponent&lt;/code&gt;, it
 * will need to completely fill in the background in an opaque color in
 * &lt;code&gt;paintComponent&lt;/code&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 * information see &lt;a
 * href=&quot;package-summary.html#threading&quot;&gt;Swing's Threading
 * Policy&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @see JLayeredPane
 * @see JMenuBar
 * @see JWindow
 * @see JFrame
 * @see JDialog
 * @see JApplet
 * @see JInternalFrame
 * @see JComponent
 * @see BoxLayout
 *
 * @see &lt;a href=&quot;http://java.sun.com/products/jfc/tsc/articles/mixing/&quot;&gt;
 * Mixing Heavy and Light Components&lt;/a&gt;
 *
 * @author David Kloba
 */
/// PENDING(klobad) Who should be opaque in this component?
@SuppressWarnings(&quot;serial&quot;)
public class JRootPane extends JComponent implements Accessible {

    private static final String uiClassID = &quot;RootPaneUI&quot;;

    /**
     * Whether or not we should dump the stack when true double buffering
     * is disabled. Default is false.
     */
    private static final boolean LOG_DISABLE_TRUE_DOUBLE_BUFFERING;

    /**
     * Whether or not we should ignore requests to disable true double
     * buffering. Default is false.
     */
    private static final boolean IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should not provide any sort of
     * Window decorations.
     *
     * @since 1.4
     */
    public static final int NONE = 0;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Frame.
     *
     * @since 1.4
     */
    public static final int FRAME = 1;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Dialog.
     *
     * @since 1.4
     */
    public static final int PLAIN_DIALOG = 2;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Dialog used to display an informational message.
     *
     * @since 1.4
     */
    public static final int INFORMATION_DIALOG = 3;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Dialog used to display an error message.
     *
     * @since 1.4
     */
    public static final int ERROR_DIALOG = 4;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Dialog used to display a &lt;code&gt;JColorChooser&lt;/code&gt;.
     *
     * @since 1.4
     */
    public static final int COLOR_CHOOSER_DIALOG = 5;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Dialog used to display a &lt;code&gt;JFileChooser&lt;/code&gt;.
     *
     * @since 1.4
     */
    public static final int FILE_CHOOSER_DIALOG = 6;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Dialog used to present a question to the user.
     *
     * @since 1.4
     */
    public static final int QUESTION_DIALOG = 7;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Dialog used to display a warning message.
     *
     * @since 1.4
     */
    public static final int WARNING_DIALOG = 8;

    private int windowDecorationStyle;

    /** The menu bar. */
    protected JMenuBar menuBar;

    /** The content pane. */
    protected Container contentPane;

    /** The layered pane that manages the menu bar and content pane. */
    protected JLayeredPane layeredPane;

    /**
     * The glass pane that overlays the menu bar and content pane,
     *  so it can intercept mouse movements and such.
     */
    protected Component glassPane;
    /**
     * The button that gets activated when the pane has the focus and
     * a UI-specific action like pressing the &lt;b&gt;Enter&lt;/b&gt; key occurs.
     */
    protected JButton defaultButton;
    /**
     * As of Java 2 platform v1.3 this unusable field is no longer used.
     * To override the default button you should replace the &lt;code&gt;Action&lt;/code&gt;
     * in the &lt;code&gt;JRootPane&lt;/code&gt;'s &lt;code&gt;ActionMap&lt;/code&gt;. Please refer to
     * the key bindings specification for further details.
     *
     * @deprecated As of Java 2 platform v1.3.
     *  @see #defaultButton
     */
    @Deprecated
    protected DefaultAction defaultPressAction;
    /**
     * As of Java 2 platform v1.3 this unusable field is no longer used.
     * To override the default button you should replace the &lt;code&gt;Action&lt;/code&gt;
     * in the &lt;code&gt;JRootPane&lt;/code&gt;'s &lt;code&gt;ActionMap&lt;/code&gt;. Please refer to
     * the key bindings specification for further details.
     *
     * @deprecated As of Java 2 platform v1.3.
     *  @see #defaultButton
     */
    @Deprecated
    protected DefaultAction defaultReleaseAction;

    /**
     * Whether or not true double buffering should be used.  This is typically
     * true, but may be set to false in special situations.  For example,
     * heavy weight popups (backed by a window) set this to false.
     */
    boolean useTrueDoubleBuffering = true;

    static {
        LOG_DISABLE_TRUE_DOUBLE_BUFFERING =
            AccessController.doPrivileged(new GetBooleanAction(
                                   &quot;swing.logDoubleBufferingDisable&quot;));
        IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING =
            AccessController.doPrivileged(new GetBooleanAction(
                                   &quot;swing.ignoreDoubleBufferingDisable&quot;));
    }

    /**
     * Creates a &lt;code&gt;JRootPane&lt;/code&gt;, setting up its
     * &lt;code&gt;glassPane&lt;/code&gt;, &lt;code&gt;layeredPane&lt;/code&gt;,
     * and &lt;code&gt;contentPane&lt;/code&gt;.
     */
    public JRootPane() {
        setGlassPane(createGlassPane());
        setLayeredPane(createLayeredPane());
        setContentPane(createContentPane());
        setLayout(createRootLayout());
        setDoubleBuffered(true);
        updateUI();
    }

    /**
     * {@inheritDoc}
     * @since 1.6
     */
    public void setDoubleBuffered(boolean aFlag) {
        if (isDoubleBuffered() != aFlag) {
            super.setDoubleBuffered(aFlag);
            RepaintManager.currentManager(this).doubleBufferingChanged(this);
        }
    }

    /**
     * Returns a constant identifying the type of Window decorations the
     * &lt;code&gt;JRootPane&lt;/code&gt; is providing.
     *
     * @return One of &lt;code&gt;NONE&lt;/code&gt;, &lt;code&gt;FRAME&lt;/code&gt;,
     *        &lt;code&gt;PLAIN_DIALOG&lt;/code&gt;, &lt;code&gt;INFORMATION_DIALOG&lt;/code&gt;,
     *        &lt;code&gt;ERROR_DIALOG&lt;/code&gt;, &lt;code&gt;COLOR_CHOOSER_DIALOG&lt;/code&gt;,
     *        &lt;code&gt;FILE_CHOOSER_DIALOG&lt;/code&gt;, &lt;code&gt;QUESTION_DIALOG&lt;/code&gt; or
     *        &lt;code&gt;WARNING_DIALOG&lt;/code&gt;.
     * @see #setWindowDecorationStyle
     * @since 1.4
     */
    public int getWindowDecorationStyle() {
        return windowDecorationStyle;
    }

    /**
     * Sets the type of Window decorations (such as borders, widgets for
     * closing a Window, title ...) the &lt;code&gt;JRootPane&lt;/code&gt; should
     * provide. The default is to provide no Window decorations
     * (&lt;code&gt;NONE&lt;/code&gt;).
     * &lt;p&gt;
     * This is only a hint, and some look and feels may not support
     * this.
     * This is a bound property.
     *
     * @param windowDecorationStyle Constant identifying Window decorations
     *        to provide.
     * @see JDialog#setDefaultLookAndFeelDecorated
     * @see JFrame#setDefaultLookAndFeelDecorated
     * @see LookAndFeel#getSupportsWindowDecorations
     * @throws IllegalArgumentException if &lt;code&gt;style&lt;/code&gt; is
     *        not one of: &lt;code&gt;NONE&lt;/code&gt;, &lt;code&gt;FRAME&lt;/code&gt;,
     *        &lt;code&gt;PLAIN_DIALOG&lt;/code&gt;, &lt;code&gt;INFORMATION_DIALOG&lt;/code&gt;,
     *        &lt;code&gt;ERROR_DIALOG&lt;/code&gt;, &lt;code&gt;COLOR_CHOOSER_DIALOG&lt;/code&gt;,
     *        &lt;code&gt;FILE_CHOOSER_DIALOG&lt;/code&gt;, &lt;code&gt;QUESTION_DIALOG&lt;/code&gt;, or
     *        &lt;code&gt;WARNING_DIALOG&lt;/code&gt;.
     * @since 1.4
     * @beaninfo
     *        bound: true
     *         enum: NONE                   JRootPane.NONE
     *               FRAME                  JRootPane.FRAME
     *               PLAIN_DIALOG           JRootPane.PLAIN_DIALOG
     *               INFORMATION_DIALOG     JRootPane.INFORMATION_DIALOG
     *               ERROR_DIALOG           JRootPane.ERROR_DIALOG
     *               COLOR_CHOOSER_DIALOG   JRootPane.COLOR_CHOOSER_DIALOG
     *               FILE_CHOOSER_DIALOG    JRootPane.FILE_CHOOSER_DIALOG
     *               QUESTION_DIALOG        JRootPane.QUESTION_DIALOG
     *               WARNING_DIALOG         JRootPane.WARNING_DIALOG
     *       expert: true
     *    attribute: visualUpdate true
     *  description: Identifies the type of Window decorations to provide
     */
    public void setWindowDecorationStyle(int windowDecorationStyle) {
        if (windowDecorationStyle &lt; 0 ||
                  windowDecorationStyle &gt; WARNING_DIALOG) {
            throw new IllegalArgumentException(&quot;Invalid decoration style&quot;);
        }
        int oldWindowDecorationStyle = getWindowDecorationStyle();
        this.windowDecorationStyle = windowDecorationStyle;
        firePropertyChange(&quot;windowDecorationStyle&quot;,
                            oldWindowDecorationStyle,
                            windowDecorationStyle);
    }

    /**
     * Returns the L&amp;amp;F object that renders this component.
     *
     * @return &lt;code&gt;LabelUI&lt;/code&gt; object
     * @since 1.3
     */
    public RootPaneUI getUI() {
        return (RootPaneUI)ui;
    }

    /**
     * Sets the L&amp;amp;F object that renders this component.
     *
     * @param ui  the &lt;code&gt;LabelUI&lt;/code&gt; L&amp;amp;F object
     * @see UIDefaults#getUI
     * @beaninfo
     *        bound: true
     *       hidden: true
     *      expert: true
     *    attribute: visualUpdate true
     *  description: The UI object that implements the Component's LookAndFeel.
     * @since 1.3
     */
    public void setUI(RootPaneUI ui) {
        super.setUI(ui);
    }


    /**
     * Resets the UI property to a value from the current look and feel.
     *
     * @see JComponent#updateUI
     */
    public void updateUI() {
        setUI((RootPaneUI)UIManager.getUI(this));
    }


    /**
     * Returns a string that specifies the name of the L&amp;amp;F class
     * that renders this component.
     *
     * @return the string &quot;RootPaneUI&quot;
     *
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     */
    public String getUIClassID() {
        return uiClassID;
    }

    /**
      * Called by the constructor methods to create the default
      * &lt;code&gt;layeredPane&lt;/code&gt;.
      * Bt default it creates a new &lt;code&gt;JLayeredPane&lt;/code&gt;.
      * @return the default &lt;code&gt;layeredPane&lt;/code&gt;
      */
    protected JLayeredPane createLayeredPane() {
        JLayeredPane p = new JLayeredPane();
        p.setName(this.getName()+&quot;.layeredPane&quot;);
        return p;
    }

    /**
     * Called by the constructor methods to create the default
     * &lt;code&gt;contentPane&lt;/code&gt;.
     * By default this method creates a new &lt;code&gt;JComponent&lt;/code&gt; add sets a
     * &lt;code&gt;BorderLayout&lt;/code&gt; as its &lt;code&gt;LayoutManager&lt;/code&gt;.
     * @return the default &lt;code&gt;contentPane&lt;/code&gt;
     */
    protected Container createContentPane() {
        JComponent c = new JPanel();
        c.setName(this.getName()+&quot;.contentPane&quot;);
        c.setLayout(new BorderLayout() {
            /* This BorderLayout subclass maps a null constraint to CENTER.
             * Although the reference BorderLayout also does this, some VMs
             * throw an IllegalArgumentException.
             */
            public void addLayoutComponent(Component comp, Object constraints) {
                if (constraints == null) {
                    constraints = BorderLayout.CENTER;
                }
                super.addLayoutComponent(comp, constraints);
            }
        });
        return c;
    }

    /**
      * Called by the constructor methods to create the default
      * &lt;code&gt;glassPane&lt;/code&gt;.
      * By default this method creates a new &lt;code&gt;JComponent&lt;/code&gt;
      * with visibility set to false.
      * @return the default &lt;code&gt;glassPane&lt;/code&gt;
      */
    protected Component createGlassPane() {
        JComponent c = new JPanel();
        c.setName(this.getName()+&quot;.glassPane&quot;);
        c.setVisible(false);
        ((JPanel)c).setOpaque(false);
        return c;
    }

    /**
     * Called by the constructor methods to create the default
     * &lt;code&gt;layoutManager&lt;/code&gt;.
     * @return the default &lt;code&gt;layoutManager&lt;/code&gt;.
     */
    protected LayoutManager createRootLayout() {
        return new RootLayout();
    }

    /**
     * Adds or changes the menu bar used in the layered pane.
     * @param menu the &lt;code&gt;JMenuBar&lt;/code&gt; to add
     */
    public void setJMenuBar(JMenuBar menu) {
        if(menuBar != null &amp;&amp; menuBar.getParent() == layeredPane)
            layeredPane.remove(menuBar);
        menuBar = menu;

        if(menuBar != null)
            layeredPane.add(menuBar, JLayeredPane.FRAME_CONTENT_LAYER);
    }

    /**
     * Specifies the menu bar value.
     * @deprecated As of Swing version 1.0.3
     *  replaced by &lt;code&gt;setJMenuBar(JMenuBar menu)&lt;/code&gt;.
     * @param menu the &lt;code&gt;JMenuBar&lt;/code&gt; to add.
     */
    @Deprecated
    public void setMenuBar(JMenuBar menu){
        if(menuBar != null &amp;&amp; menuBar.getParent() == layeredPane)
            layeredPane.remove(menuBar);
        menuBar = menu;

        if(menuBar != null)
            layeredPane.add(menuBar, JLayeredPane.FRAME_CONTENT_LAYER);
    }

    /**
     * Returns the menu bar from the layered pane.
     * @return the &lt;code&gt;JMenuBar&lt;/code&gt; used in the pane
     */
    public JMenuBar getJMenuBar() { return menuBar; }

    /**
     * Returns the menu bar value.
     * @deprecated As of Swing version 1.0.3
     *  replaced by &lt;code&gt;getJMenuBar()&lt;/code&gt;.
     * @return the &lt;code&gt;JMenuBar&lt;/code&gt; used in the pane
     */
    @Deprecated
    public JMenuBar getMenuBar() { return menuBar; }

    /**
     * Sets the content pane -- the container that holds the components
     * parented by the root pane.
     * &lt;p&gt;
     * Swing's painting architecture requires an opaque &lt;code&gt;JComponent&lt;/code&gt;
     * in the containment hierarchy. This is typically provided by the
     * content pane. If you replace the content pane it is recommended you
     * replace it with an opaque &lt;code&gt;JComponent&lt;/code&gt;.
     *
     * @param content the &lt;code&gt;Container&lt;/code&gt; to use for component-contents
     * @exception java.awt.IllegalComponentStateException (a runtime
     *            exception) if the content pane parameter is &lt;code&gt;null&lt;/code&gt;
     */
    public void setContentPane(Container content) {
        if(content == null)
            throw new IllegalComponentStateException(&quot;contentPane cannot be set to null.&quot;);
        if(contentPane != null &amp;&amp; contentPane.getParent() == layeredPane)
            layeredPane.remove(contentPane);
        contentPane = content;

        layeredPane.add(contentPane, JLayeredPane.FRAME_CONTENT_LAYER);
    }

    /**
     * Returns the content pane -- the container that holds the components
     * parented by the root pane.
     *
     * @return the &lt;code&gt;Container&lt;/code&gt; that holds the component-contents
     */
    public Container getContentPane() { return contentPane; }

// PENDING(klobad) Should this reparent the contentPane and MenuBar?
    /**
     * Sets the layered pane for the root pane. The layered pane
     * typically holds a content pane and an optional &lt;code&gt;JMenuBar&lt;/code&gt;.
     *
     * @param layered  the &lt;code&gt;JLayeredPane&lt;/code&gt; to use
     * @exception java.awt.IllegalComponentStateException (a runtime
     *            exception) if the layered pane parameter is &lt;code&gt;null&lt;/code&gt;
     */
    public void setLayeredPane(JLayeredPane layered) {
        if(layered == null)
            throw new IllegalComponentStateException(&quot;layeredPane cannot be set to null.&quot;);
        if(layeredPane != null &amp;&amp; layeredPane.getParent() == this)
            this.remove(layeredPane);
        layeredPane = layered;

        this.add(layeredPane, -1);
    }
    /**
     * Gets the layered pane used by the root pane. The layered pane
     * typically holds a content pane and an optional &lt;code&gt;JMenuBar&lt;/code&gt;.
     *
     * @return the &lt;code&gt;JLayeredPane&lt;/code&gt; currently in use
     */
    public JLayeredPane getLayeredPane() { return layeredPane; }

    /**
     * Sets a specified &lt;code&gt;Component&lt;/code&gt; to be the glass pane for this
     * root pane.  The glass pane should normally be a lightweight,
     * transparent component, because it will be made visible when
     * ever the root pane needs to grab input events.
     * &lt;p&gt;
     * The new glass pane's visibility is changed to match that of
     * the current glass pane.  An implication of this is that care
     * must be taken when you want to replace the glass pane and
     * make it visible.  Either of the following will work:
     * &lt;pre&gt;
     *   root.setGlassPane(newGlassPane);
     *   newGlassPane.setVisible(true);
     * &lt;/pre&gt;
     * or:
     * &lt;pre&gt;
     *   root.getGlassPane().setVisible(true);
     *   root.setGlassPane(newGlassPane);
     * &lt;/pre&gt;
     *
     * @param glass the &lt;code&gt;Component&lt;/code&gt; to use as the glass pane
     *              for this &lt;code&gt;JRootPane&lt;/code&gt;
     * @exception NullPointerException if the &lt;code&gt;glass&lt;/code&gt; parameter is
     *          &lt;code&gt;null&lt;/code&gt;
     */
    public void setGlassPane(Component glass) {
        if (glass == null) {
            throw new NullPointerException(&quot;glassPane cannot be set to null.&quot;);
        }

        AWTAccessor.getComponentAccessor().setMixingCutoutShape(glass,
                new Rectangle());

        boolean visible = false;
        if (glassPane != null &amp;&amp; glassPane.getParent() == this) {
            this.remove(glassPane);
            visible = glassPane.isVisible();
        }

        glass.setVisible(visible);
        glassPane = glass;
        this.add(glassPane, 0);
        if (visible) {
            repaint();
        }
    }

    /**
     * Returns the current glass pane for this &lt;code&gt;JRootPane&lt;/code&gt;.
     * @return the current glass pane
     * @see #setGlassPane
     */
    public Component getGlassPane() {
        return glassPane;
    }

    /**
     * If a descendant of this &lt;code&gt;JRootPane&lt;/code&gt; calls
     * &lt;code&gt;revalidate&lt;/code&gt;, validate from here on down.
     *&lt;p&gt;
     * Deferred requests to layout a component and its descendents again.
     * For example, calls to &lt;code&gt;revalidate&lt;/code&gt;, are pushed upwards to
     * either a &lt;code&gt;JRootPane&lt;/code&gt; or a &lt;code&gt;JScrollPane&lt;/code&gt;
     * because both classes override &lt;code&gt;isValidateRoot&lt;/code&gt; to return true.
     *
     * @see JComponent#isValidateRoot
     * @see java.awt.Container#isValidateRoot
     * @return true
     */
    @Override
    public boolean isValidateRoot() {
        return true;
    }

    /**
     * The &lt;code&gt;glassPane&lt;/code&gt; and &lt;code&gt;contentPane&lt;/code&gt;
     * have the same bounds, which means &lt;code&gt;JRootPane&lt;/code&gt;
     * does not tiles its children and this should return false.
     * On the other hand, the &lt;code&gt;glassPane&lt;/code&gt;
     * is normally not visible, and so this can return true if the
     * &lt;code&gt;glassPane&lt;/code&gt; isn't visible. Therefore, the
     * return value here depends upon the visibility of the
     * &lt;code&gt;glassPane&lt;/code&gt;.
     *
     * @return true if this component's children don't overlap
     */
    public boolean isOptimizedDrawingEnabled() {
        return !glassPane.isVisible();
    }

    /**
     * {@inheritDoc}
     */
    public void addNotify() {
        super.addNotify();
        enableEvents(AWTEvent.KEY_EVENT_MASK);
    }

    /**
     * {@inheritDoc}
     */
    public void removeNotify() {
        super.removeNotify();
    }


    /**
     * Sets the &lt;code&gt;defaultButton&lt;/code&gt; property,
     * which determines the current default button for this &lt;code&gt;JRootPane&lt;/code&gt;.
     * The default button is the button which will be activated
     * when a UI-defined activation event (typically the &lt;b&gt;Enter&lt;/b&gt; key)
     * occurs in the root pane regardless of whether or not the button
     * has keyboard focus (unless there is another component within
     * the root pane which consumes the activation event,
     * such as a &lt;code&gt;JTextPane&lt;/code&gt;).
     * For default activation to work, the button must be an enabled
     * descendent of the root pane when activation occurs.
     * To remove a default button from this root pane, set this
     * property to &lt;code&gt;null&lt;/code&gt;.
     *
     * @see JButton#isDefaultButton
     * @param defaultButton the &lt;code&gt;JButton&lt;/code&gt; which is to be the default button
     *
     * @beaninfo
     *  description: The button activated by default in this root pane
     */
    public void setDefaultButton(JButton defaultButton) {
        JButton oldDefault = this.defaultButton;

        if (oldDefault != defaultButton) {
            this.defaultButton = defaultButton;

            if (oldDefault != null) {
                oldDefault.repaint();
            }
            if (defaultButton != null) {
                defaultButton.repaint();
            }
        }

        firePropertyChange(&quot;defaultButton&quot;, oldDefault, defaultButton);
    }

    /**
     * Returns the value of the &lt;code&gt;defaultButton&lt;/code&gt; property.
     * @return the &lt;code&gt;JButton&lt;/code&gt; which is currently the default button
     * @see #setDefaultButton
     */
    public JButton getDefaultButton() {
        return defaultButton;
    }

    final void setUseTrueDoubleBuffering(boolean useTrueDoubleBuffering) {
        this.useTrueDoubleBuffering = useTrueDoubleBuffering;
    }

    final boolean getUseTrueDoubleBuffering() {
        return useTrueDoubleBuffering;
    }

    final void disableTrueDoubleBuffering() {
        if (useTrueDoubleBuffering) {
            if (!IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING) {
                if (LOG_DISABLE_TRUE_DOUBLE_BUFFERING) {
                    System.out.println(&quot;Disabling true double buffering for &quot; +
                                       this);
                    Thread.dumpStack();
                }
                useTrueDoubleBuffering = false;
                RepaintManager.currentManager(this).
                        doubleBufferingChanged(this);
            }
        }
    }

    @SuppressWarnings(&quot;serial&quot;)
    static class DefaultAction extends AbstractAction {
        JButton owner;
        JRootPane root;
        boolean press;
        DefaultAction(JRootPane root, boolean press) {
            this.root = root;
            this.press = press;
        }
        public void setOwner(JButton owner) {
            this.owner = owner;
        }
        public void actionPerformed(ActionEvent e) {
            if (owner != null &amp;&amp; SwingUtilities.getRootPane(owner) == root) {
                ButtonModel model = owner.getModel();
                if (press) {
                    model.setArmed(true);
                    model.setPressed(true);
                } else {
                    model.setPressed(false);
                }
            }
        }
        public boolean isEnabled() {
            return owner.getModel().isEnabled();
        }
    }


    /**
     * Overridden to enforce the position of the glass component as
     * the zero child.
     *
     * @param comp the component to be enhanced
     * @param constraints the constraints to be respected
     * @param index the index
     */
    protected void addImpl(Component comp, Object constraints, int index) {
        super.addImpl(comp, constraints, index);

        /// We are making sure the glassPane is on top.
        if(glassPane != null
            &amp;&amp; glassPane.getParent() == this
            &amp;&amp; getComponent(0) != glassPane) {
            add(glassPane, 0);
        }
    }


///////////////////////////////////////////////////////////////////////////////
//// Begin Inner Classes
///////////////////////////////////////////////////////////////////////////////


    /**
     * A custom layout manager that is responsible for the layout of
     * layeredPane, glassPane, and menuBar.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    @SuppressWarnings(&quot;serial&quot;)
    protected class RootLayout implements LayoutManager2, Serializable
    {
        /**
         * Returns the amount of space the layout would like to have.
         *
         * @param parent the Container for which this layout manager
         * is being used
         * @return a Dimension object containing the layout's preferred size
         */
        public Dimension preferredLayoutSize(Container parent) {
            Dimension rd, mbd;
            Insets i = getInsets();

            if(contentPane != null) {
                rd = contentPane.getPreferredSize();
            } else {
                rd = parent.getSize();
            }
            if(menuBar != null &amp;&amp; menuBar.isVisible()) {
                mbd = menuBar.getPreferredSize();
            } else {
                mbd = new Dimension(0, 0);
            }
            return new Dimension(Math.max(rd.width, mbd.width) + i.left + i.right,
                                        rd.height + mbd.height + i.top + i.bottom);
        }

        /**
         * Returns the minimum amount of space the layout needs.
         *
         * @param parent the Container for which this layout manager
         * is being used
         * @return a Dimension object containing the layout's minimum size
         */
        public Dimension minimumLayoutSize(Container parent) {
            Dimension rd, mbd;
            Insets i = getInsets();
            if(contentPane != null) {
                rd = contentPane.getMinimumSize();
            } else {
                rd = parent.getSize();
            }
            if(menuBar != null &amp;&amp; menuBar.isVisible()) {
                mbd = menuBar.getMinimumSize();
            } else {
                mbd = new Dimension(0, 0);
            }
            return new Dimension(Math.max(rd.width, mbd.width) + i.left + i.right,
                        rd.height + mbd.height + i.top + i.bottom);
        }

        /**
         * Returns the maximum amount of space the layout can use.
         *
         * @param target the Container for which this layout manager
         * is being used
         * @return a Dimension object containing the layout's maximum size
         */
        public Dimension maximumLayoutSize(Container target) {
            Dimension rd, mbd;
            Insets i = getInsets();
            if(menuBar != null &amp;&amp; menuBar.isVisible()) {
                mbd = menuBar.getMaximumSize();
            } else {
                mbd = new Dimension(0, 0);
            }
            if(contentPane != null) {
                rd = contentPane.getMaximumSize();
            } else {
                // This is silly, but should stop an overflow error
                rd = new Dimension(Integer.MAX_VALUE,
                        Integer.MAX_VALUE - i.top - i.bottom - mbd.height - 1);
            }
            return new Dimension(Math.min(rd.width, mbd.width) + i.left + i.right,
                                         rd.height + mbd.height + i.top + i.bottom);
        }

        /**
         * Instructs the layout manager to perform the layout for the specified
         * container.
         *
         * @param parent the Container for which this layout manager
         * is being used
         */
        public void layoutContainer(Container parent) {
            Rectangle b = parent.getBounds();
            Insets i = getInsets();
            int contentY = 0;
            int w = b.width - i.right - i.left;
            int h = b.height - i.top - i.bottom;

            if(layeredPane != null) {
                layeredPane.setBounds(i.left, i.top, w, h);
            }
            if(glassPane != null) {
                glassPane.setBounds(i.left, i.top, w, h);
            }
            // Note: This is laying out the children in the layeredPane,
            // technically, these are not our children.
            if(menuBar != null &amp;&amp; menuBar.isVisible()) {
                Dimension mbd = menuBar.getPreferredSize();
                menuBar.setBounds(0, 0, w, mbd.height);
                contentY += mbd.height;
            }
            if(contentPane != null) {
                contentPane.setBounds(0, contentY, w, h - contentY);
            }
        }

        public void addLayoutComponent(String name, Component comp) {}
        public void removeLayoutComponent(Component comp) {}
        public void addLayoutComponent(Component comp, Object constraints) {}
        public float getLayoutAlignmentX(Container target) { return 0.0f; }
        public float getLayoutAlignmentY(Container target) { return 0.0f; }
        public void invalidateLayout(Container target) {}
    }

    /**
     * Returns a string representation of this &lt;code&gt;JRootPane&lt;/code&gt;.
     * This method is intended to be used only for debugging purposes,
     * and the content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not
     * be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return  a string representation of this &lt;code&gt;JRootPane&lt;/code&gt;.
     */
    protected String paramString() {
        return super.paramString();
    }

/////////////////
// Accessibility support
////////////////

    /**
     * Gets the &lt;code&gt;AccessibleContext&lt;/code&gt; associated with this
     * &lt;code&gt;JRootPane&lt;/code&gt;. For root panes, the
     * &lt;code&gt;AccessibleContext&lt;/code&gt; takes the form of an
     * &lt;code&gt;AccessibleJRootPane&lt;/code&gt;.
     * A new &lt;code&gt;AccessibleJRootPane&lt;/code&gt; instance is created if necessary.
     *
     * @return an &lt;code&gt;AccessibleJRootPane&lt;/code&gt; that serves as the
     *         &lt;code&gt;AccessibleContext&lt;/code&gt; of this &lt;code&gt;JRootPane&lt;/code&gt;
     */
    public AccessibleContext getAccessibleContext() {
        if (accessibleContext == null) {
            accessibleContext = new AccessibleJRootPane();
        }
        return accessibleContext;
    }

    /**
     * This class implements accessibility support for the
     * &lt;code&gt;JRootPane&lt;/code&gt; class.  It provides an implementation of the
     * Java Accessibility API appropriate to root pane user-interface elements.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    @SuppressWarnings(&quot;serial&quot;)
    protected class AccessibleJRootPane extends AccessibleJComponent {
        /**
         * Get the role of this object.
         *
         * @return an instance of AccessibleRole describing the role of
         * the object
         */
        public AccessibleRole getAccessibleRole() {
            return AccessibleRole.ROOT_PANE;
        }

        /**
         * Returns the number of accessible children of the object.
         *
         * @return the number of accessible children of the object.
         */
        public int getAccessibleChildrenCount() {
            return super.getAccessibleChildrenCount();
        }

        /**
         * Returns the specified Accessible child of the object.  The Accessible
         * children of an Accessible object are zero-based, so the first child
         * of an Accessible child is at index 0, the second child is at index 1,
         * and so on.
         *
         * @param i zero-based index of child
         * @return the Accessible child of the object
         * @see #getAccessibleChildrenCount
         */
        public Accessible getAccessibleChild(int i) {
            return super.getAccessibleChild(i);
        }
    } // inner class AccessibleJRootPane
}
</pre>
</body>
</html>
