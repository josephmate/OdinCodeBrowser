<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing;

/**
 * A &lt;code&gt;SizeSequence&lt;/code&gt; object
 * efficiently maintains an ordered list
 * of sizes and corresponding positions.
 * One situation for which &lt;code&gt;SizeSequence&lt;/code&gt;
 * might be appropriate is in a component
 * that displays multiple rows of unequal size.
 * In this case, a single &lt;code&gt;SizeSequence&lt;/code&gt;
 * object could be used to track the heights
 * and Y positions of all rows.
 * &lt;p&gt;
 * Another example would be a multi-column component,
 * such as a &lt;code&gt;JTable&lt;/code&gt;,
 * in which the column sizes are not all equal.
 * The &lt;code&gt;JTable&lt;/code&gt; might use a single
 * &lt;code&gt;SizeSequence&lt;/code&gt; object
 * to store the widths and X positions of all the columns.
 * The &lt;code&gt;JTable&lt;/code&gt; could then use the
 * &lt;code&gt;SizeSequence&lt;/code&gt; object
 * to find the column corresponding to a certain position.
 * The &lt;code&gt;JTable&lt;/code&gt; could update the
 * &lt;code&gt;SizeSequence&lt;/code&gt; object
 * whenever one or more column sizes changed.
 *
 * &lt;p&gt;
 * The following figure shows the relationship between size and position data
 * for a multi-column component.
 *
 * &lt;center&gt;
 * &lt;img src=&quot;doc-files/SizeSequence-1.gif&quot; width=384 height = 100
 * alt=&quot;The first item begins at position 0, the second at the position equal
 to the size of the previous item, and so on.&quot;&gt;
 * &lt;/center&gt;
 * &lt;p&gt;
 * In the figure, the first index (0) corresponds to the first column,
 * the second index (1) to the second column, and so on.
 * The first column's position starts at 0,
 * and the column occupies &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; pixels,
 * where &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; is the value returned by
 * &lt;code&gt;getSize(0)&lt;/code&gt;.
 * Thus, the first column ends at &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; - 1.
 * The second column then begins at
 * the position &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt;
 * and occupies &lt;em&gt;size&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; (&lt;code&gt;getSize(1)&lt;/code&gt;) pixels.
 * &lt;p&gt;
 * Note that a &lt;code&gt;SizeSequence&lt;/code&gt; object simply represents intervals
 * along an axis.
 * In our examples, the intervals represent height or width in pixels.
 * However, any other unit of measure (for example, time in days)
 * could be just as valid.
 *
 *
 * &lt;h3&gt;Implementation Notes&lt;/h3&gt;
 *
 * Normally when storing the size and position of entries,
 * one would choose between
 * storing the sizes or storing their positions
 * instead. The two common operations that are needed during
 * rendering are: &lt;code&gt;getIndex(position)&lt;/code&gt;
 * and &lt;code&gt;setSize(index, size)&lt;/code&gt;.
 * Whichever choice of internal format is made one of these
 * operations is costly when the number of entries becomes large.
 * If sizes are stored, finding the index of the entry
 * that encloses a particular position is linear in the
 * number of entries. If positions are stored instead, setting
 * the size of an entry at a particular index requires updating
 * the positions of the affected entries, which is also a linear
 * calculation.
 * &lt;p&gt;
 * Like the above techniques this class holds an array of N integers
 * internally but uses a hybrid encoding, which is halfway
 * between the size-based and positional-based approaches.
 * The result is a data structure that takes the same space to store
 * the information but can perform most operations in Log(N) time
 * instead of O(N), where N is the number of entries in the list.
 * &lt;p&gt;
 * Two operations that remain O(N) in the number of entries are
 * the &lt;code&gt;insertEntries&lt;/code&gt;
 * and &lt;code&gt;removeEntries&lt;/code&gt; methods, both
 * of which are implemented by converting the internal array to
 * a set of integer sizes, copying it into the new array, and then
 * reforming the hybrid representation in place.
 *
 * @author Philip Milne
 * @since 1.3
 */

/*
 *   Each method is implemented by taking the minimum and
 *   maximum of the range of integers that need to be operated
 *   upon. All the algorithms work by dividing this range
 *   into two smaller ranges and recursing. The recursion
 *   is terminated when the upper and lower bounds are equal.
 */

public class SizeSequence {

    private static int[] emptyArray = new int[0];
    private int a[];

    /**
     * Creates a new &lt;code&gt;SizeSequence&lt;/code&gt; object
     * that contains no entries.  To add entries, you
     * can use &lt;code&gt;insertEntries&lt;/code&gt; or &lt;code&gt;setSizes&lt;/code&gt;.
     *
     * @see #insertEntries
     * @see #setSizes(int[])
     */
    public SizeSequence() {
        a = emptyArray;
    }

    /**
     * Creates a new &lt;code&gt;SizeSequence&lt;/code&gt; object
     * that contains the specified number of entries,
     * all initialized to have size 0.
     *
     * @param numEntries  the number of sizes to track
     * @exception NegativeArraySizeException if
     *    &lt;code&gt;numEntries &amp;lt; 0&lt;/code&gt;
     */
    public SizeSequence(int numEntries) {
        this(numEntries, 0);
    }

    /**
     * Creates a new &lt;code&gt;SizeSequence&lt;/code&gt; object
     * that contains the specified number of entries,
     * all initialized to have size &lt;code&gt;value&lt;/code&gt;.
     *
     * @param numEntries  the number of sizes to track
     * @param value       the initial value of each size
     */
    public SizeSequence(int numEntries, int value) {
        this();
        insertEntries(0, numEntries, value);
    }

    /**
     * Creates a new &lt;code&gt;SizeSequence&lt;/code&gt; object
     * that contains the specified sizes.
     *
     * @param sizes  the array of sizes to be contained in
     *               the &lt;code&gt;SizeSequence&lt;/code&gt;
     */
    public SizeSequence(int[] sizes) {
        this();
        setSizes(sizes);
    }

    /**
     * Resets the size sequence to contain &lt;code&gt;length&lt;/code&gt; items
     * all with a size of &lt;code&gt;size&lt;/code&gt;.
     */
    void setSizes(int length, int size) {
        if (a.length != length) {
            a = new int[length];
        }
        setSizes(0, length, size);
    }

    private int setSizes(int from, int to, int size) {
        if (to &lt;= from) {
            return 0;
        }
        int m = (from + to)/2;
        a[m] = size + setSizes(from, m, size);
        return a[m] + setSizes(m + 1, to, size);
    }

    /**
     * Resets this &lt;code&gt;SizeSequence&lt;/code&gt; object,
     * using the data in the &lt;code&gt;sizes&lt;/code&gt; argument.
     * This method reinitializes this object so that it
     * contains as many entries as the &lt;code&gt;sizes&lt;/code&gt; array.
     * Each entry's size is initialized to the value of the
     * corresponding item in &lt;code&gt;sizes&lt;/code&gt;.
     *
     * @param sizes  the array of sizes to be contained in
     *               this &lt;code&gt;SizeSequence&lt;/code&gt;
     */
    public void setSizes(int[] sizes) {
        if (a.length != sizes.length) {
            a = new int[sizes.length];
        }
        setSizes(0, a.length, sizes);
    }

    private int setSizes(int from, int to, int[] sizes) {
        if (to &lt;= from) {
            return 0;
        }
        int m = (from + to)/2;
        a[m] = sizes[m] + setSizes(from, m, sizes);
        return a[m] + setSizes(m + 1, to, sizes);
    }

    /**
     * Returns the size of all entries.
     *
     * @return  a new array containing the sizes in this object
     */
    public int[] getSizes() {
        int n = a.length;
        int[] sizes = new int[n];
        getSizes(0, n, sizes);
        return sizes;
    }

    private int getSizes(int from, int to, int[] sizes) {
        if (to &lt;= from) {
            return 0;
        }
        int m = (from + to)/2;
        sizes[m] = a[m] - getSizes(from, m, sizes);
        return a[m] + getSizes(m + 1, to, sizes);
    }

    /**
     * Returns the start position for the specified entry.
     * For example, &lt;code&gt;getPosition(0)&lt;/code&gt; returns 0,
     * &lt;code&gt;getPosition(1)&lt;/code&gt; is equal to
     *   &lt;code&gt;getSize(0)&lt;/code&gt;,
     * &lt;code&gt;getPosition(2)&lt;/code&gt; is equal to
     *   &lt;code&gt;getSize(0)&lt;/code&gt; + &lt;code&gt;getSize(1)&lt;/code&gt;,
     * and so on.
     * &lt;p&gt;Note that if &lt;code&gt;index&lt;/code&gt; is greater than
     * &lt;code&gt;length&lt;/code&gt; the value returned may
     * be meaningless.
     *
     * @param index  the index of the entry whose position is desired
     * @return       the starting position of the specified entry
     */
    public int getPosition(int index) {
        return getPosition(0, a.length, index);
    }

    private int getPosition(int from, int to, int index) {
        if (to &lt;= from) {
            return 0;
        }
        int m = (from + to)/2;
        if (index &lt;= m) {
            return getPosition(from, m, index);
        }
        else {
            return a[m] + getPosition(m + 1, to, index);
        }
    }

    /**
     * Returns the index of the entry
     * that corresponds to the specified position.
     * For example, &lt;code&gt;getIndex(0)&lt;/code&gt; is 0,
     * since the first entry always starts at position 0.
     *
     * @param position  the position of the entry
     * @return  the index of the entry that occupies the specified position
     */
    public int getIndex(int position) {
        return getIndex(0, a.length, position);
    }

    private int getIndex(int from, int to, int position) {
        if (to &lt;= from) {
            return from;
        }
        int m = (from + to)/2;
        int pivot = a[m];
        if (position &lt; pivot) {
           return getIndex(from, m, position);
        }
        else {
            return getIndex(m + 1, to, position - pivot);
        }
    }

    /**
     * Returns the size of the specified entry.
     * If &lt;code&gt;index&lt;/code&gt; is out of the range
     * &lt;code&gt;(0 &amp;lt;= index &amp;lt; getSizes().length)&lt;/code&gt;
     * the behavior is unspecified.
     *
     * @param index  the index corresponding to the entry
     * @return  the size of the entry
     */
    public int getSize(int index) {
        return getPosition(index + 1) - getPosition(index);
    }

    /**
     * Sets the size of the specified entry.
     * Note that if the value of &lt;code&gt;index&lt;/code&gt;
     * does not fall in the range:
     * &lt;code&gt;(0 &amp;lt;= index &amp;lt; getSizes().length)&lt;/code&gt;
     * the behavior is unspecified.
     *
     * @param index  the index corresponding to the entry
     * @param size   the size of the entry
     */
    public void setSize(int index, int size) {
        changeSize(0, a.length, index, size - getSize(index));
    }

    private void changeSize(int from, int to, int index, int delta) {
        if (to &lt;= from) {
            return;
        }
        int m = (from + to)/2;
        if (index &lt;= m) {
            a[m] += delta;
            changeSize(from, m, index, delta);
        }
        else {
            changeSize(m + 1, to, index, delta);
        }
    }

    /**
     * Adds a contiguous group of entries to this &lt;code&gt;SizeSequence&lt;/code&gt;.
     * Note that the values of &lt;code&gt;start&lt;/code&gt; and
     * &lt;code&gt;length&lt;/code&gt; must satisfy the following
     * conditions:  &lt;code&gt;(0 &amp;lt;= start &amp;lt; getSizes().length)
     * AND (length &amp;gt;= 0)&lt;/code&gt;.  If these conditions are
     * not met, the behavior is unspecified and an exception
     * may be thrown.
     *
     * @param start   the index to be assigned to the first entry
     *                in the group
     * @param length  the number of entries in the group
     * @param value   the size to be assigned to each new entry
     * @exception ArrayIndexOutOfBoundsException if the parameters
     *   are outside of the range:
     *   (&lt;code&gt;0 &amp;lt;= start &amp;lt; (getSizes().length)) AND (length &amp;gt;= 0)&lt;/code&gt;
     */
    public void insertEntries(int start, int length, int value) {
        int sizes[] = getSizes();
        int end = start + length;
        int n = a.length + length;
        a = new int[n];
        for (int i = 0; i &lt; start; i++) {
            a[i] = sizes[i] ;
        }
        for (int i = start; i &lt; end; i++) {
            a[i] = value ;
        }
        for (int i = end; i &lt; n; i++) {
            a[i] = sizes[i-length] ;
        }
        setSizes(a);
    }

    /**
     * Removes a contiguous group of entries
     * from this &lt;code&gt;SizeSequence&lt;/code&gt;.
     * Note that the values of &lt;code&gt;start&lt;/code&gt; and
     * &lt;code&gt;length&lt;/code&gt; must satisfy the following
     * conditions:  &lt;code&gt;(0 &amp;lt;= start &amp;lt; getSizes().length)
     * AND (length &amp;gt;= 0)&lt;/code&gt;.  If these conditions are
     * not met, the behavior is unspecified and an exception
     * may be thrown.
     *
     * @param start   the index of the first entry to be removed
     * @param length  the number of entries to be removed
     */
    public void removeEntries(int start, int length) {
        int sizes[] = getSizes();
        int end = start + length;
        int n = a.length - length;
        a = new int[n];
        for (int i = 0; i &lt; start; i++) {
            a[i] = sizes[i] ;
        }
        for (int i = start; i &lt; n; i++) {
            a[i] = sizes[i+length] ;
        }
        setSizes(a);
    }
}
</pre>
</body>
</html>
