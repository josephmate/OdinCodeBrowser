<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */



package javax.swing;



import java.beans.ConstructorProperties;
import javax.swing.plaf.*;
import javax.accessibility.*;

import java.awt.*;

import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;



/**
 * &lt;code&gt;JSplitPane&lt;/code&gt; is used to divide two (and only two)
 * &lt;code&gt;Component&lt;/code&gt;s. The two &lt;code&gt;Component&lt;/code&gt;s
 * are graphically divided based on the look and feel
 * implementation, and the two &lt;code&gt;Component&lt;/code&gt;s can then be
 * interactively resized by the user.
 * Information on using &lt;code&gt;JSplitPane&lt;/code&gt; is in
 * &lt;a
 href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/splitpane.html&quot;&gt;How to Use Split Panes&lt;/a&gt; in
 * &lt;em&gt;The Java Tutorial&lt;/em&gt;.
 * &lt;p&gt;
 * The two &lt;code&gt;Component&lt;/code&gt;s in a split pane can be aligned
 * left to right using
 * &lt;code&gt;JSplitPane.HORIZONTAL_SPLIT&lt;/code&gt;, or top to bottom using
 * &lt;code&gt;JSplitPane.VERTICAL_SPLIT&lt;/code&gt;.
 * The preferred way to change the size of the &lt;code&gt;Component&lt;/code&gt;s
 * is to invoke
 * &lt;code&gt;setDividerLocation&lt;/code&gt; where &lt;code&gt;location&lt;/code&gt; is either
 * the new x or y position, depending on the orientation of the
 * &lt;code&gt;JSplitPane&lt;/code&gt;.
 * &lt;p&gt;
 * To resize the &lt;code&gt;Component&lt;/code&gt;s to their preferred sizes invoke
 * &lt;code&gt;resetToPreferredSizes&lt;/code&gt;.
 * &lt;p&gt;
 * When the user is resizing the &lt;code&gt;Component&lt;/code&gt;s the minimum
 * size of the &lt;code&gt;Components&lt;/code&gt; is used to determine the
 * maximum/minimum position the &lt;code&gt;Component&lt;/code&gt;s
 * can be set to. If the minimum size of the two
 * components is greater than the size of the split pane the divider
 * will not allow you to resize it. To alter the minimum size of a
 * &lt;code&gt;JComponent&lt;/code&gt;, see {@link JComponent#setMinimumSize}.
 * &lt;p&gt;
 * When the user resizes the split pane the new space is distributed between
 * the two components based on the &lt;code&gt;resizeWeight&lt;/code&gt; property.
 * A value of 0,
 * the default, indicates the right/bottom component gets all the space,
 * where as a value of 1 indicates the left/top component gets all the space.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 * information see &lt;a
 * href=&quot;package-summary.html#threading&quot;&gt;Swing's Threading
 * Policy&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @see #setDividerLocation
 * @see #resetToPreferredSizes
 *
 * @author Scott Violet
 */
public class JSplitPane extends JComponent implements Accessible
{
    /**
     * @see #getUIClassID
     * @see #readObject
     */
    private static final String uiClassID = &quot;SplitPaneUI&quot;;

    /**
     * Vertical split indicates the &lt;code&gt;Component&lt;/code&gt;s are
     * split along the y axis.  For example the two
     * &lt;code&gt;Component&lt;/code&gt;s will be split one on top of the other.
     */
    public final static int VERTICAL_SPLIT = 0;

    /**
     * Horizontal split indicates the &lt;code&gt;Component&lt;/code&gt;s are
     * split along the x axis.  For example the two
     * &lt;code&gt;Component&lt;/code&gt;s will be split one to the left of the
     * other.
     */
    public final static int HORIZONTAL_SPLIT = 1;

    /**
     * Used to add a &lt;code&gt;Component&lt;/code&gt; to the left of the other
     * &lt;code&gt;Component&lt;/code&gt;.
     */
    public final static String LEFT = &quot;left&quot;;

    /**
     * Used to add a &lt;code&gt;Component&lt;/code&gt; to the right of the other
     * &lt;code&gt;Component&lt;/code&gt;.
     */
    public final static String RIGHT = &quot;right&quot;;

    /**
     * Used to add a &lt;code&gt;Component&lt;/code&gt; above the other
     * &lt;code&gt;Component&lt;/code&gt;.
     */
    public final static String TOP = &quot;top&quot;;

    /**
     * Used to add a &lt;code&gt;Component&lt;/code&gt; below the other
     * &lt;code&gt;Component&lt;/code&gt;.
     */
    public final static String BOTTOM = &quot;bottom&quot;;

    /**
     * Used to add a &lt;code&gt;Component&lt;/code&gt; that will represent the divider.
     */
    public final static String DIVIDER = &quot;divider&quot;;

    /**
     * Bound property name for orientation (horizontal or vertical).
     */
    public final static String ORIENTATION_PROPERTY = &quot;orientation&quot;;

    /**
     * Bound property name for continuousLayout.
     */
    public final static String CONTINUOUS_LAYOUT_PROPERTY = &quot;continuousLayout&quot;;

    /**
     * Bound property name for border.
     */
    public final static String DIVIDER_SIZE_PROPERTY = &quot;dividerSize&quot;;

    /**
     * Bound property for oneTouchExpandable.
     */
    public final static String ONE_TOUCH_EXPANDABLE_PROPERTY =
                               &quot;oneTouchExpandable&quot;;

    /**
     * Bound property for lastLocation.
     */
    public final static String LAST_DIVIDER_LOCATION_PROPERTY =
                               &quot;lastDividerLocation&quot;;

    /**
     * Bound property for the dividerLocation.
     * @since 1.3
     */
    public final static String DIVIDER_LOCATION_PROPERTY = &quot;dividerLocation&quot;;

    /**
     * Bound property for weight.
     * @since 1.3
     */
    public final static String RESIZE_WEIGHT_PROPERTY = &quot;resizeWeight&quot;;

    /**
     * How the views are split.
     */
    protected int orientation;

    /**
     * Whether or not the views are continuously redisplayed while
     * resizing.
     */
    protected boolean continuousLayout;

    /**
     * The left or top component.
     */
    protected Component leftComponent;

    /**
     * The right or bottom component.
     */
    protected Component rightComponent;

    /**
     * Size of the divider.
     */
    protected int dividerSize;
    private boolean dividerSizeSet = false;

    /**
     * Is a little widget provided to quickly expand/collapse the
     * split pane?
     */
    protected boolean oneTouchExpandable;
    private boolean oneTouchExpandableSet;

    /**
     * Previous location of the split pane.
     */
    protected int lastDividerLocation;

    /**
     * How to distribute extra space.
     */
    private double resizeWeight;

    /**
     * Location of the divider, at least the value that was set, the UI may
     * have a different value.
     */
    private int dividerLocation;


    /**
     * Creates a new &lt;code&gt;JSplitPane&lt;/code&gt; configured to arrange the child
     * components side-by-side horizontally, using two buttons for the components.
     */
    public JSplitPane() {
        this(JSplitPane.HORIZONTAL_SPLIT,
                UIManager.getBoolean(&quot;SplitPane.continuousLayout&quot;),
                new JButton(UIManager.getString(&quot;SplitPane.leftButtonText&quot;)),
                new JButton(UIManager.getString(&quot;SplitPane.rightButtonText&quot;)));
    }


    /**
     * Creates a new &lt;code&gt;JSplitPane&lt;/code&gt; configured with the
     * specified orientation.
     *
     * @param newOrientation  &lt;code&gt;JSplitPane.HORIZONTAL_SPLIT&lt;/code&gt; or
     *                        &lt;code&gt;JSplitPane.VERTICAL_SPLIT&lt;/code&gt;
     * @exception IllegalArgumentException if &lt;code&gt;orientation&lt;/code&gt;
     *          is not one of HORIZONTAL_SPLIT or VERTICAL_SPLIT.
     */
    @ConstructorProperties({&quot;orientation&quot;})
    public JSplitPane(int newOrientation) {
        this(newOrientation,
                UIManager.getBoolean(&quot;SplitPane.continuousLayout&quot;));
    }


    /**
     * Creates a new &lt;code&gt;JSplitPane&lt;/code&gt; with the specified
     * orientation and redrawing style.
     *
     * @param newOrientation  &lt;code&gt;JSplitPane.HORIZONTAL_SPLIT&lt;/code&gt; or
     *                        &lt;code&gt;JSplitPane.VERTICAL_SPLIT&lt;/code&gt;
     * @param newContinuousLayout  a boolean, true for the components to
     *        redraw continuously as the divider changes position, false
     *        to wait until the divider position stops changing to redraw
     * @exception IllegalArgumentException if &lt;code&gt;orientation&lt;/code&gt;
     *          is not one of HORIZONTAL_SPLIT or VERTICAL_SPLIT
     */
    public JSplitPane(int newOrientation,
                      boolean newContinuousLayout) {
        this(newOrientation, newContinuousLayout, null, null);
    }


    /**
     * Creates a new &lt;code&gt;JSplitPane&lt;/code&gt; with the specified
     * orientation and the specified components.
     *
     * @param newOrientation  &lt;code&gt;JSplitPane.HORIZONTAL_SPLIT&lt;/code&gt; or
     *                        &lt;code&gt;JSplitPane.VERTICAL_SPLIT&lt;/code&gt;
     * @param newLeftComponent the &lt;code&gt;Component&lt;/code&gt; that will
     *          appear on the left
     *          of a horizontally-split pane, or at the top of a
     *          vertically-split pane
     * @param newRightComponent the &lt;code&gt;Component&lt;/code&gt; that will
     *          appear on the right
     *          of a horizontally-split pane, or at the bottom of a
     *          vertically-split pane
     * @exception IllegalArgumentException if &lt;code&gt;orientation&lt;/code&gt;
     *          is not one of: HORIZONTAL_SPLIT or VERTICAL_SPLIT
     */
    public JSplitPane(int newOrientation,
                      Component newLeftComponent,
                      Component newRightComponent){
        this(newOrientation,
                UIManager.getBoolean(&quot;SplitPane.continuousLayout&quot;),
                newLeftComponent, newRightComponent);
    }


    /**
     * Creates a new &lt;code&gt;JSplitPane&lt;/code&gt; with the specified
     * orientation and
     * redrawing style, and with the specified components.
     *
     * @param newOrientation  &lt;code&gt;JSplitPane.HORIZONTAL_SPLIT&lt;/code&gt; or
     *                        &lt;code&gt;JSplitPane.VERTICAL_SPLIT&lt;/code&gt;
     * @param newContinuousLayout  a boolean, true for the components to
     *        redraw continuously as the divider changes position, false
     *        to wait until the divider position stops changing to redraw
     * @param newLeftComponent the &lt;code&gt;Component&lt;/code&gt; that will
     *          appear on the left
     *          of a horizontally-split pane, or at the top of a
     *          vertically-split pane
     * @param newRightComponent the &lt;code&gt;Component&lt;/code&gt; that will
     *          appear on the right
     *          of a horizontally-split pane, or at the bottom of a
     *          vertically-split pane
     * @exception IllegalArgumentException if &lt;code&gt;orientation&lt;/code&gt;
     *          is not one of HORIZONTAL_SPLIT or VERTICAL_SPLIT
     */
    public JSplitPane(int newOrientation,
                      boolean newContinuousLayout,
                      Component newLeftComponent,
                      Component newRightComponent){
        super();

        dividerLocation = -1;
        setLayout(null);
        setUIProperty(&quot;opaque&quot;, Boolean.TRUE);
        orientation = newOrientation;
        if (orientation != HORIZONTAL_SPLIT &amp;&amp; orientation != VERTICAL_SPLIT)
            throw new IllegalArgumentException(&quot;cannot create JSplitPane, &quot; +
                                               &quot;orientation must be one of &quot; +
                                               &quot;JSplitPane.HORIZONTAL_SPLIT &quot; +
                                               &quot;or JSplitPane.VERTICAL_SPLIT&quot;);
        continuousLayout = newContinuousLayout;
        if (newLeftComponent != null)
            setLeftComponent(newLeftComponent);
        if (newRightComponent != null)
            setRightComponent(newRightComponent);
        updateUI();

    }


    /**
     * Sets the L&amp;amp;F object that renders this component.
     *
     * @param ui  the &lt;code&gt;SplitPaneUI&lt;/code&gt; L&amp;amp;F object
     * @see UIDefaults#getUI
     * @beaninfo
     *        bound: true
     *       hidden: true
     *    attribute: visualUpdate true
     *  description: The UI object that implements the Component's LookAndFeel.
     */
    public void setUI(SplitPaneUI ui) {
        if ((SplitPaneUI)this.ui != ui) {
            super.setUI(ui);
            revalidate();
        }
    }


    /**
     * Returns the &lt;code&gt;SplitPaneUI&lt;/code&gt; that is providing the
     * current look and feel.
     *
     * @return the &lt;code&gt;SplitPaneUI&lt;/code&gt; object that renders this component
     * @beaninfo
     *       expert: true
     *  description: The L&amp;amp;F object that renders this component.
     */
    public SplitPaneUI getUI() {
        return (SplitPaneUI)ui;
    }


    /**
     * Notification from the &lt;code&gt;UIManager&lt;/code&gt; that the L&amp;amp;F has changed.
     * Replaces the current UI object with the latest version from the
     * &lt;code&gt;UIManager&lt;/code&gt;.
     *
     * @see JComponent#updateUI
     */
    public void updateUI() {
        setUI((SplitPaneUI)UIManager.getUI(this));
        revalidate();
    }


    /**
     * Returns the name of the L&amp;amp;F class that renders this component.
     *
     * @return the string &quot;SplitPaneUI&quot;
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     * @beaninfo
     *       expert: true
     *  description: A string that specifies the name of the L&amp;amp;F class.
     */
    public String getUIClassID() {
        return uiClassID;
    }


    /**
     * Sets the size of the divider.
     *
     * @param newSize an integer giving the size of the divider in pixels
     * @beaninfo
     *        bound: true
     *  description: The size of the divider.
     */
    public void setDividerSize(int newSize) {
        int           oldSize = dividerSize;

        dividerSizeSet = true;
        if (oldSize != newSize) {
            dividerSize = newSize;
            firePropertyChange(DIVIDER_SIZE_PROPERTY, oldSize, newSize);
        }
    }


    /**
     * Returns the size of the divider.
     *
     * @return an integer giving the size of the divider in pixels
     */
    public int getDividerSize() {
        return dividerSize;
    }


    /**
     * Sets the component to the left (or above) the divider.
     *
     * @param comp the &lt;code&gt;Component&lt;/code&gt; to display in that position
     */
    public void setLeftComponent(Component comp) {
        if (comp == null) {
            if (leftComponent != null) {
                remove(leftComponent);
                leftComponent = null;
            }
        } else {
            add(comp, JSplitPane.LEFT);
        }
    }


    /**
     * Returns the component to the left (or above) the divider.
     *
     * @return the &lt;code&gt;Component&lt;/code&gt; displayed in that position
     * @beaninfo
     *    preferred: true
     *  description: The component to the left (or above) the divider.
     */
    public Component getLeftComponent() {
        return leftComponent;
    }


    /**
     * Sets the component above, or to the left of the divider.
     *
     * @param comp the &lt;code&gt;Component&lt;/code&gt; to display in that position
     * @beaninfo
     *  description: The component above, or to the left of the divider.
     */
    public void setTopComponent(Component comp) {
        setLeftComponent(comp);
    }


    /**
     * Returns the component above, or to the left of the divider.
     *
     * @return the &lt;code&gt;Component&lt;/code&gt; displayed in that position
     */
    public Component getTopComponent() {
        return leftComponent;
    }


    /**
     * Sets the component to the right (or below) the divider.
     *
     * @param comp the &lt;code&gt;Component&lt;/code&gt; to display in that position
     * @beaninfo
     *    preferred: true
     *  description: The component to the right (or below) the divider.
     */
    public void setRightComponent(Component comp) {
        if (comp == null) {
            if (rightComponent != null) {
                remove(rightComponent);
                rightComponent = null;
            }
        } else {
            add(comp, JSplitPane.RIGHT);
        }
    }


    /**
     * Returns the component to the right (or below) the divider.
     *
     * @return the &lt;code&gt;Component&lt;/code&gt; displayed in that position
     */
    public Component getRightComponent() {
        return rightComponent;
    }


    /**
     * Sets the component below, or to the right of the divider.
     *
     * @param comp the &lt;code&gt;Component&lt;/code&gt; to display in that position
     * @beaninfo
     *  description: The component below, or to the right of the divider.
     */
    public void setBottomComponent(Component comp) {
        setRightComponent(comp);
    }


    /**
     * Returns the component below, or to the right of the divider.
     *
     * @return the &lt;code&gt;Component&lt;/code&gt; displayed in that position
     */
    public Component getBottomComponent() {
        return rightComponent;
    }


    /**
     * Sets the value of the &lt;code&gt;oneTouchExpandable&lt;/code&gt; property,
     * which must be &lt;code&gt;true&lt;/code&gt; for the
     * &lt;code&gt;JSplitPane&lt;/code&gt; to provide a UI widget
     * on the divider to quickly expand/collapse the divider.
     * The default value of this property is &lt;code&gt;false&lt;/code&gt;.
     * Some look and feels might not support one-touch expanding;
     * they will ignore this property.
     *
     * @param newValue &lt;code&gt;true&lt;/code&gt; to specify that the split pane should provide a
     *        collapse/expand widget
     * @beaninfo
     *        bound: true
     *  description: UI widget on the divider to quickly
     *               expand/collapse the divider.
     *
     * @see #isOneTouchExpandable
     */
    public void setOneTouchExpandable(boolean newValue) {
        boolean           oldValue = oneTouchExpandable;

        oneTouchExpandable = newValue;
        oneTouchExpandableSet = true;
        firePropertyChange(ONE_TOUCH_EXPANDABLE_PROPERTY, oldValue, newValue);
        repaint();
    }


    /**
     * Gets the &lt;code&gt;oneTouchExpandable&lt;/code&gt; property.
     *
     * @return the value of the &lt;code&gt;oneTouchExpandable&lt;/code&gt; property
     * @see #setOneTouchExpandable
     */
    public boolean isOneTouchExpandable() {
        return oneTouchExpandable;
    }


    /**
     * Sets the last location the divider was at to
     * &lt;code&gt;newLastLocation&lt;/code&gt;.
     *
     * @param newLastLocation an integer specifying the last divider location
     *        in pixels, from the left (or upper) edge of the pane to the
     *        left (or upper) edge of the divider
     * @beaninfo
     *        bound: true
     *  description: The last location the divider was at.
     */
    public void setLastDividerLocation(int newLastLocation) {
        int               oldLocation = lastDividerLocation;

        lastDividerLocation = newLastLocation;
        firePropertyChange(LAST_DIVIDER_LOCATION_PROPERTY, oldLocation,
                           newLastLocation);
    }


    /**
     * Returns the last location the divider was at.
     *
     * @return an integer specifying the last divider location as a count
     *       of pixels from the left (or upper) edge of the pane to the
     *       left (or upper) edge of the divider
     */
    public int getLastDividerLocation() {
        return lastDividerLocation;
    }


    /**
     * Sets the orientation, or how the splitter is divided. The options
     * are:&lt;ul&gt;
     * &lt;li&gt;JSplitPane.VERTICAL_SPLIT  (above/below orientation of components)
     * &lt;li&gt;JSplitPane.HORIZONTAL_SPLIT  (left/right orientation of components)
     * &lt;/ul&gt;
     *
     * @param orientation an integer specifying the orientation
     * @exception IllegalArgumentException if orientation is not one of:
     *        HORIZONTAL_SPLIT or VERTICAL_SPLIT.
     * @beaninfo
     *        bound: true
     *  description: The orientation, or how the splitter is divided.
     *         enum: HORIZONTAL_SPLIT JSplitPane.HORIZONTAL_SPLIT
     *               VERTICAL_SPLIT   JSplitPane.VERTICAL_SPLIT
     */
    public void setOrientation(int orientation) {
        if ((orientation != VERTICAL_SPLIT) &amp;&amp;
            (orientation != HORIZONTAL_SPLIT)) {
           throw new IllegalArgumentException(&quot;JSplitPane: orientation must &quot; +
                                              &quot;be one of &quot; +
                                              &quot;JSplitPane.VERTICAL_SPLIT or &quot; +
                                              &quot;JSplitPane.HORIZONTAL_SPLIT&quot;);
        }

        int           oldOrientation = this.orientation;

        this.orientation = orientation;
        firePropertyChange(ORIENTATION_PROPERTY, oldOrientation, orientation);
    }


    /**
     * Returns the orientation.
     *
     * @return an integer giving the orientation
     * @see #setOrientation
     */
    public int getOrientation() {
        return orientation;
    }


    /**
     * Sets the value of the &lt;code&gt;continuousLayout&lt;/code&gt; property,
     * which must be &lt;code&gt;true&lt;/code&gt; for the child components
     * to be continuously
     * redisplayed and laid out during user intervention.
     * The default value of this property is look and feel dependent.
     * Some look and feels might not support continuous layout;
     * they will ignore this property.
     *
     * @param newContinuousLayout  &lt;code&gt;true&lt;/code&gt; if the components
     *        should continuously be redrawn as the divider changes position
     * @beaninfo
     *        bound: true
     *  description: Whether the child components are
     *               continuously redisplayed and laid out during
     *               user intervention.
     * @see #isContinuousLayout
     */
    public void setContinuousLayout(boolean newContinuousLayout) {
        boolean           oldCD = continuousLayout;

        continuousLayout = newContinuousLayout;
        firePropertyChange(CONTINUOUS_LAYOUT_PROPERTY, oldCD,
                           newContinuousLayout);
    }


    /**
     * Gets the &lt;code&gt;continuousLayout&lt;/code&gt; property.
     *
     * @return the value of the &lt;code&gt;continuousLayout&lt;/code&gt; property
     * @see #setContinuousLayout
     */
    public boolean isContinuousLayout() {
        return continuousLayout;
    }

    /**
     * Specifies how to distribute extra space when the size of the split pane
     * changes. A value of 0, the default,
     * indicates the right/bottom component gets all the extra space (the
     * left/top component acts fixed), where as a value of 1 specifies the
     * left/top component gets all the extra space (the right/bottom component
     * acts fixed). Specifically, the left/top component gets (weight * diff)
     * extra space and the right/bottom component gets (1 - weight) * diff
     * extra space.
     *
     * @param value as described above
     * @exception IllegalArgumentException if &lt;code&gt;value&lt;/code&gt; is &amp;lt; 0 or &amp;gt; 1
     * @since 1.3
     * @beaninfo
     *        bound: true
     *  description: Specifies how to distribute extra space when the split pane
     *               resizes.
     */
    public void setResizeWeight(double value) {
        if (value &lt; 0 || value &gt; 1) {
            throw new IllegalArgumentException(&quot;JSplitPane weight must be between 0 and 1&quot;);
        }
        double         oldWeight = resizeWeight;

        resizeWeight = value;
        firePropertyChange(RESIZE_WEIGHT_PROPERTY, oldWeight, value);
    }

    /**
     * Returns the number that determines how extra space is distributed.
     * @return how extra space is to be distributed on a resize of the
     *         split pane
     * @since 1.3
     */
    public double getResizeWeight() {
        return resizeWeight;
    }

    /**
     * Lays out the &lt;code&gt;JSplitPane&lt;/code&gt; layout based on the preferred size
     * of the children components. This will likely result in changing
     * the divider location.
     */
    public void resetToPreferredSizes() {
        SplitPaneUI         ui = getUI();

        if (ui != null) {
            ui.resetToPreferredSizes(this);
        }
    }


    /**
     * Sets the divider location as a percentage of the
     * &lt;code&gt;JSplitPane&lt;/code&gt;'s size.
     * &lt;p&gt;
     * This method is implemented in terms of
     * &lt;code&gt;setDividerLocation(int)&lt;/code&gt;.
     * This method immediately changes the size of the split pane based on
     * its current size. If the split pane is not correctly realized and on
     * screen, this method will have no effect (new divider location will
     * become (current size * proportionalLocation) which is 0).
     *
     * @param proportionalLocation  a double-precision floating point value
     *        that specifies a percentage, from zero (top/left) to 1.0
     *        (bottom/right)
     * @exception IllegalArgumentException if the specified location is &amp;lt; 0
     *            or &amp;gt; 1.0
     * @beaninfo
     *  description: The location of the divider.
     */
    public void setDividerLocation(double proportionalLocation) {
        if (proportionalLocation &lt; 0.0 ||
           proportionalLocation &gt; 1.0) {
            throw new IllegalArgumentException(&quot;proportional location must &quot; +
                                               &quot;be between 0.0 and 1.0.&quot;);
        }
        if (getOrientation() == VERTICAL_SPLIT) {
            setDividerLocation((int)((double)(getHeight() - getDividerSize()) *
                                     proportionalLocation));
        } else {
            setDividerLocation((int)((double)(getWidth() - getDividerSize()) *
                                     proportionalLocation));
        }
    }


    /**
     * Sets the location of the divider. This is passed off to the
     * look and feel implementation, and then listeners are notified. A value
     * less than 0 implies the divider should be reset to a value that
     * attempts to honor the preferred size of the left/top component.
     * After notifying the listeners, the last divider location is updated,
     * via &lt;code&gt;setLastDividerLocation&lt;/code&gt;.
     *
     * @param location an int specifying a UI-specific value (typically a
     *        pixel count)
     * @beaninfo
     *        bound: true
     *  description: The location of the divider.
     */
    public void setDividerLocation(int location) {
        int                 oldValue = dividerLocation;

        dividerLocation = location;

        // Notify UI.
        SplitPaneUI         ui = getUI();

        if (ui != null) {
            ui.setDividerLocation(this, location);
        }

        // Then listeners
        firePropertyChange(DIVIDER_LOCATION_PROPERTY, oldValue, location);

        // And update the last divider location.
        setLastDividerLocation(oldValue);
    }


    /**
     * Returns the last value passed to &lt;code&gt;setDividerLocation&lt;/code&gt;.
     * The value returned from this method may differ from the actual
     * divider location (if &lt;code&gt;setDividerLocation&lt;/code&gt; was passed a
     * value bigger than the current size).
     *
     * @return an integer specifying the location of the divider
     */
    public int getDividerLocation() {
        return dividerLocation;
    }


    /**
     * Returns the minimum location of the divider from the look and feel
     * implementation.
     *
     * @return an integer specifying a UI-specific value for the minimum
     *          location (typically a pixel count); or -1 if the UI is
     *          &lt;code&gt;null&lt;/code&gt;
     * @beaninfo
     *  description: The minimum location of the divider from the L&amp;amp;F.
     */
    public int getMinimumDividerLocation() {
        SplitPaneUI         ui = getUI();

        if (ui != null) {
            return ui.getMinimumDividerLocation(this);
        }
        return -1;
    }


    /**
     * Returns the maximum location of the divider from the look and feel
     * implementation.
     *
     * @return an integer specifying a UI-specific value for the maximum
     *          location (typically a pixel count); or -1 if the  UI is
     *          &lt;code&gt;null&lt;/code&gt;
     */
    public int getMaximumDividerLocation() {
        SplitPaneUI         ui = getUI();

        if (ui != null) {
            return ui.getMaximumDividerLocation(this);
        }
        return -1;
    }


    /**
     * Removes the child component, &lt;code&gt;component&lt;/code&gt; from the
     * pane. Resets the &lt;code&gt;leftComponent&lt;/code&gt; or
     * &lt;code&gt;rightComponent&lt;/code&gt; instance variable, as necessary.
     *
     * @param component the &lt;code&gt;Component&lt;/code&gt; to remove
     */
    public void remove(Component component) {
        if (component == leftComponent) {
            leftComponent = null;
        } else if (component == rightComponent) {
            rightComponent = null;
        }
        super.remove(component);

        // Update the JSplitPane on the screen
        revalidate();
        repaint();
    }


    /**
     * Removes the &lt;code&gt;Component&lt;/code&gt; at the specified index.
     * Updates the &lt;code&gt;leftComponent&lt;/code&gt; and &lt;code&gt;rightComponent&lt;/code&gt;
     * instance variables as necessary, and then messages super.
     *
     * @param index an integer specifying the component to remove, where
     *        1 specifies the left/top component and 2 specifies the
     *        bottom/right component
     */
    public void remove(int index) {
        Component    comp = getComponent(index);

        if (comp == leftComponent) {
            leftComponent = null;
        } else if (comp == rightComponent) {
            rightComponent = null;
        }
        super.remove(index);

        // Update the JSplitPane on the screen
        revalidate();
        repaint();
    }


    /**
     * Removes all the child components from the split pane. Resets the
     * &lt;code&gt;leftComonent&lt;/code&gt; and &lt;code&gt;rightComponent&lt;/code&gt;
     * instance variables.
     */
    public void removeAll() {
        leftComponent = rightComponent = null;
        super.removeAll();

        // Update the JSplitPane on the screen
        revalidate();
        repaint();
    }


    /**
     * Returns true, so that calls to &lt;code&gt;revalidate&lt;/code&gt;
     * on any descendant of this &lt;code&gt;JSplitPane&lt;/code&gt;
     * will cause a request to be queued that
     * will validate the &lt;code&gt;JSplitPane&lt;/code&gt; and all its descendants.
     *
     * @return true
     * @see JComponent#revalidate
     * @see java.awt.Container#isValidateRoot
     *
     * @beaninfo
     *    hidden: true
     */
    @Override
    public boolean isValidateRoot() {
        return true;
    }


    /**
     * Adds the specified component to this split pane.
     * If &lt;code&gt;constraints&lt;/code&gt; identifies the left/top or
     * right/bottom child component, and a component with that identifier
     * was previously added, it will be removed and then &lt;code&gt;comp&lt;/code&gt;
     * will be added in its place. If &lt;code&gt;constraints&lt;/code&gt; is not
     * one of the known identifiers the layout manager may throw an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt;.
     * &lt;p&gt;
     * The possible constraints objects (Strings) are:
     * &lt;ul&gt;
     * &lt;li&gt;JSplitPane.TOP
     * &lt;li&gt;JSplitPane.LEFT
     * &lt;li&gt;JSplitPane.BOTTOM
     * &lt;li&gt;JSplitPane.RIGHT
     * &lt;/ul&gt;
     * If the &lt;code&gt;constraints&lt;/code&gt; object is &lt;code&gt;null&lt;/code&gt;,
     * the component is added in the
     * first available position (left/top if open, else right/bottom).
     *
     * @param comp        the component to add
     * @param constraints an &lt;code&gt;Object&lt;/code&gt; specifying the
     *                    layout constraints
     *                    (position) for this component
     * @param index       an integer specifying the index in the container's
     *                    list.
     * @exception IllegalArgumentException  if the &lt;code&gt;constraints&lt;/code&gt;
     *          object does not match an existing component
     * @see java.awt.Container#addImpl(Component, Object, int)
     */
    protected void addImpl(Component comp, Object constraints, int index)
    {
        Component             toRemove;

        if (constraints != null &amp;&amp; !(constraints instanceof String)) {
            throw new IllegalArgumentException(&quot;cannot add to layout: &quot; +
                                               &quot;constraint must be a string &quot; +
                                               &quot;(or null)&quot;);
        }

        /* If the constraints are null and the left/right component is
           invalid, add it at the left/right component. */
        if (constraints == null) {
            if (getLeftComponent() == null) {
                constraints = JSplitPane.LEFT;
            } else if (getRightComponent() == null) {
                constraints = JSplitPane.RIGHT;
            }
        }

        /* Find the Component that already exists and remove it. */
        if (constraints != null &amp;&amp; (constraints.equals(JSplitPane.LEFT) ||
                                   constraints.equals(JSplitPane.TOP))) {
            toRemove = getLeftComponent();
            if (toRemove != null) {
                remove(toRemove);
            }
            leftComponent = comp;
            index = -1;
        } else if (constraints != null &amp;&amp;
                   (constraints.equals(JSplitPane.RIGHT) ||
                    constraints.equals(JSplitPane.BOTTOM))) {
            toRemove = getRightComponent();
            if (toRemove != null) {
                remove(toRemove);
            }
            rightComponent = comp;
            index = -1;
        } else if (constraints != null &amp;&amp;
                constraints.equals(JSplitPane.DIVIDER)) {
            index = -1;
        }
        /* LayoutManager should raise for else condition here. */

        super.addImpl(comp, constraints, index);

        // Update the JSplitPane on the screen
        revalidate();
        repaint();
    }


    /**
     * Subclassed to message the UI with &lt;code&gt;finishedPaintingChildren&lt;/code&gt;
     * after super has been messaged, as well as painting the border.
     *
     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context within which to paint
     */
    protected void paintChildren(Graphics g) {
        super.paintChildren(g);

        SplitPaneUI        ui = getUI();

        if (ui != null) {
            Graphics           tempG = g.create();
            ui.finishedPaintingChildren(this, tempG);
            tempG.dispose();
        }
    }


    /**
     * See &lt;code&gt;readObject&lt;/code&gt; and &lt;code&gt;writeObject&lt;/code&gt; in
     * &lt;code&gt;JComponent&lt;/code&gt; for more
     * information about serialization in Swing.
     */
    private void writeObject(ObjectOutputStream s) throws IOException {
        s.defaultWriteObject();
        if (getUIClassID().equals(uiClassID)) {
            byte count = JComponent.getWriteObjCounter(this);
            JComponent.setWriteObjCounter(this, --count);
            if (count == 0 &amp;&amp; ui != null) {
                ui.installUI(this);
            }
        }
    }

    void setUIProperty(String propertyName, Object value) {
        if (propertyName == &quot;dividerSize&quot;) {
            if (!dividerSizeSet) {
                setDividerSize(((Number)value).intValue());
                dividerSizeSet = false;
            }
        } else if (propertyName == &quot;oneTouchExpandable&quot;) {
            if (!oneTouchExpandableSet) {
                setOneTouchExpandable(((Boolean)value).booleanValue());
                oneTouchExpandableSet = false;
            }
        } else {
            super.setUIProperty(propertyName, value);
        }
    }


    /**
     * Returns a string representation of this &lt;code&gt;JSplitPane&lt;/code&gt;.
     * This method
     * is intended to be used only for debugging purposes, and the
     * content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not
     * be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return  a string representation of this &lt;code&gt;JSplitPane&lt;/code&gt;.
     */
    protected String paramString() {
        String orientationString = (orientation == HORIZONTAL_SPLIT ?
                                    &quot;HORIZONTAL_SPLIT&quot; : &quot;VERTICAL_SPLIT&quot;);
        String continuousLayoutString = (continuousLayout ?
                                         &quot;true&quot; : &quot;false&quot;);
        String oneTouchExpandableString = (oneTouchExpandable ?
                                           &quot;true&quot; : &quot;false&quot;);

        return super.paramString() +
        &quot;,continuousLayout=&quot; + continuousLayoutString +
        &quot;,dividerSize=&quot; + dividerSize +
        &quot;,lastDividerLocation=&quot; + lastDividerLocation +
        &quot;,oneTouchExpandable=&quot; + oneTouchExpandableString +
        &quot;,orientation=&quot; + orientationString;
    }



    ///////////////////////////
    // Accessibility support //
    ///////////////////////////


    /**
     * Gets the AccessibleContext associated with this JSplitPane.
     * For split panes, the AccessibleContext takes the form of an
     * AccessibleJSplitPane.
     * A new AccessibleJSplitPane instance is created if necessary.
     *
     * @return an AccessibleJSplitPane that serves as the
     *         AccessibleContext of this JSplitPane
     * @beaninfo
     *       expert: true
     *  description: The AccessibleContext associated with this SplitPane.
     */
    public AccessibleContext getAccessibleContext() {
        if (accessibleContext == null) {
            accessibleContext = new AccessibleJSplitPane();
        }
        return accessibleContext;
    }


    /**
     * This class implements accessibility support for the
     * &lt;code&gt;JSplitPane&lt;/code&gt; class.  It provides an implementation of the
     * Java Accessibility API appropriate to split pane user-interface elements.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    protected class AccessibleJSplitPane extends AccessibleJComponent
        implements AccessibleValue {
        /**
         * Gets the state set of this object.
         *
         * @return an instance of AccessibleState containing the current state
         * of the object
         * @see AccessibleState
         */
        public AccessibleStateSet getAccessibleStateSet() {
            AccessibleStateSet states = super.getAccessibleStateSet();
            // FIXME: [[[WDW - Should also add BUSY if this implements
            // Adjustable at some point.  If this happens, we probably
            // should also add actions.]]]
            if (getOrientation() == VERTICAL_SPLIT) {
                states.add(AccessibleState.VERTICAL);
            } else {
                states.add(AccessibleState.HORIZONTAL);
            }
            return states;
        }


        /**
         * Get the AccessibleValue associated with this object.  In the
         * implementation of the Java Accessibility API for this class,
         * return this object, which is responsible for implementing the
         * AccessibleValue interface on behalf of itself.
         *
         * @return this object
         */
        public AccessibleValue getAccessibleValue() {
            return this;
        }


        /**
         * Gets the accessible value of this object.
         *
         * @return a localized String describing the value of this object
         */
        public Number getCurrentAccessibleValue() {
            return Integer.valueOf(getDividerLocation());
        }


        /**
         * Sets the value of this object as a Number.
         *
         * @return True if the value was set.
         */
        public boolean setCurrentAccessibleValue(Number n) {
            // TIGER - 4422535
            if (n == null) {
                return false;
            }
            setDividerLocation(n.intValue());
            return true;
        }


        /**
         * Gets the minimum accessible value of this object.
         *
         * @return The minimum value of this object.
         */
        public Number getMinimumAccessibleValue() {
            return Integer.valueOf(getUI().getMinimumDividerLocation(
                                                        JSplitPane.this));
        }


        /**
         * Gets the maximum accessible value of this object.
         *
         * @return The maximum value of this object.
         */
        public Number getMaximumAccessibleValue() {
            return Integer.valueOf(getUI().getMaximumDividerLocation(
                                                        JSplitPane.this));
        }


        /**
         * Gets the role of this object.
         *
         * @return an instance of AccessibleRole describing the role of
         * the object
         * @see AccessibleRole
         */
        public AccessibleRole getAccessibleRole() {
            return AccessibleRole.SPLIT_PANE;
        }
    } // inner class AccessibleJSplitPane
}
</pre>
</body>
</html>
