<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import java.util.ArrayList;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Date;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

/**
 * &lt;code&gt;RowFilter&lt;/code&gt; is used to filter out entries from the
 * model so that they are not shown in the view.  For example, a
 * &lt;code&gt;RowFilter&lt;/code&gt; associated with a &lt;code&gt;JTable&lt;/code&gt; might
 * only allow rows that contain a column with a specific string. The
 * meaning of &lt;em&gt;entry&lt;/em&gt; depends on the component type.
 * For example, when a filter is
 * associated with a &lt;code&gt;JTable&lt;/code&gt;, an entry corresponds to a
 * row; when associated with a &lt;code&gt;JTree&lt;/code&gt;, an entry corresponds
 * to a node.
 * &lt;p&gt;
 * Subclasses must override the &lt;code&gt;include&lt;/code&gt; method to
 * indicate whether the entry should be shown in the
 * view.  The &lt;code&gt;Entry&lt;/code&gt; argument can be used to obtain the values in
 * each of the columns in that entry.  The following example shows an
 * &lt;code&gt;include&lt;/code&gt; method that allows only entries containing one or
 * more values starting with the string &quot;a&quot;:
 * &lt;pre&gt;
 * RowFilter&amp;lt;Object,Object&amp;gt; startsWithAFilter = new RowFilter&amp;lt;Object,Object&amp;gt;() {
 *   public boolean include(Entry&amp;lt;? extends Object, ? extends Object&amp;gt; entry) {
 *     for (int i = entry.getValueCount() - 1; i &amp;gt;= 0; i--) {
 *       if (entry.getStringValue(i).startsWith(&quot;a&quot;)) {
 *         // The value starts with &quot;a&quot;, include it
 *         return true;
 *       }
 *     }
 *     // None of the columns start with &quot;a&quot;; return false so that this
 *     // entry is not shown
 *     return false;
 *   }
 * };
 * &lt;/pre&gt;
 * &lt;code&gt;RowFilter&lt;/code&gt; has two formal type parameters that allow
 * you to create a &lt;code&gt;RowFilter&lt;/code&gt; for a specific model. For
 * example, the following assumes a specific model that is wrapping
 * objects of type &lt;code&gt;Person&lt;/code&gt;.  Only &lt;code&gt;Person&lt;/code&gt;s
 * with an age over 20 will be shown:
 * &lt;pre&gt;
 * RowFilter&amp;lt;PersonModel,Integer&amp;gt; ageFilter = new RowFilter&amp;lt;PersonModel,Integer&amp;gt;() {
 *   public boolean include(Entry&amp;lt;? extends PersonModel, ? extends Integer&amp;gt; entry) {
 *     PersonModel personModel = entry.getModel();
 *     Person person = personModel.getPerson(entry.getIdentifier());
 *     if (person.getAge() &amp;gt; 20) {
 *       // Returning true indicates this row should be shown.
 *       return true;
 *     }
 *     // Age is &amp;lt;= 20, don't show it.
 *     return false;
 *   }
 * };
 * PersonModel model = createPersonModel();
 * TableRowSorter&amp;lt;PersonModel&amp;gt; sorter = new TableRowSorter&amp;lt;PersonModel&amp;gt;(model);
 * sorter.setRowFilter(ageFilter);
 * &lt;/pre&gt;
 *
 * @param &lt;M&gt; the type of the model; for example &lt;code&gt;PersonModel&lt;/code&gt;
 * @param &lt;I&gt; the type of the identifier; when using
 *            &lt;code&gt;TableRowSorter&lt;/code&gt; this will be &lt;code&gt;Integer&lt;/code&gt;
 * @see javax.swing.table.TableRowSorter
 * @since 1.6
 */
public abstract class RowFilter&lt;M,I&gt; {
    /**
     * Enumeration of the possible comparison values supported by
     * some of the default &lt;code&gt;RowFilter&lt;/code&gt;s.
     *
     * @see RowFilter
     * @since 1.6
     */
    public enum ComparisonType {
        /**
         * Indicates that entries with a value before the supplied
         * value should be included.
         */
        BEFORE,

        /**
         * Indicates that entries with a value after the supplied
         * value should be included.
         */
        AFTER,

        /**
         * Indicates that entries with a value equal to the supplied
         * value should be included.
         */
        EQUAL,

        /**
         * Indicates that entries with a value not equal to the supplied
         * value should be included.
         */
        NOT_EQUAL
    }

    /**
     * Throws an IllegalArgumentException if any of the values in
     * columns are {@literal &lt;} 0.
     */
    private static void checkIndices(int[] columns) {
        for (int i = columns.length - 1; i &gt;= 0; i--) {
            if (columns[i] &lt; 0) {
                throw new IllegalArgumentException(&quot;Index must be &gt;= 0&quot;);
            }
        }
    }

    /**
     * Returns a &lt;code&gt;RowFilter&lt;/code&gt; that uses a regular
     * expression to determine which entries to include.  Only entries
     * with at least one matching value are included.  For
     * example, the following creates a &lt;code&gt;RowFilter&lt;/code&gt; that
     * includes entries with at least one value starting with
     * &quot;a&quot;:
     * &lt;pre&gt;
     *   RowFilter.regexFilter(&quot;^a&quot;);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The returned filter uses {@link java.util.regex.Matcher#find}
     * to test for inclusion.  To test for exact matches use the
     * characters '^' and '$' to match the beginning and end of the
     * string respectively.  For example, &quot;^foo$&quot; includes only rows whose
     * string is exactly &quot;foo&quot; and not, for example, &quot;food&quot;.  See
     * {@link java.util.regex.Pattern} for a complete description of
     * the supported regular-expression constructs.
     *
     * @param regex the regular expression to filter on
     * @param indices the indices of the values to check.  If not supplied all
     *               values are evaluated
     * @return a &lt;code&gt;RowFilter&lt;/code&gt; implementing the specified criteria
     * @throws NullPointerException if &lt;code&gt;regex&lt;/code&gt; is
     *         &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if any of the &lt;code&gt;indices&lt;/code&gt;
     *         are &amp;lt; 0
     * @throws PatternSyntaxException if &lt;code&gt;regex&lt;/code&gt; is
     *         not a valid regular expression.
     * @see java.util.regex.Pattern
     */
    public static &lt;M,I&gt; RowFilter&lt;M,I&gt; regexFilter(String regex,
                                                       int... indices) {
        return (RowFilter&lt;M,I&gt;)new RegexFilter(Pattern.compile(regex),
                                               indices);
    }

    /**
     * Returns a &lt;code&gt;RowFilter&lt;/code&gt; that includes entries that
     * have at least one &lt;code&gt;Date&lt;/code&gt; value meeting the specified
     * criteria.  For example, the following &lt;code&gt;RowFilter&lt;/code&gt; includes
     * only entries with at least one date value after the current date:
     * &lt;pre&gt;
     *   RowFilter.dateFilter(ComparisonType.AFTER, new Date());
     * &lt;/pre&gt;
     *
     * @param type the type of comparison to perform
     * @param date the date to compare against
     * @param indices the indices of the values to check.  If not supplied all
     *               values are evaluated
     * @return a &lt;code&gt;RowFilter&lt;/code&gt; implementing the specified criteria
     * @throws NullPointerException if &lt;code&gt;date&lt;/code&gt; is
     *          &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if any of the &lt;code&gt;indices&lt;/code&gt;
     *         are &amp;lt; 0 or &lt;code&gt;type&lt;/code&gt; is
     *         &lt;code&gt;null&lt;/code&gt;
     * @see java.util.Calendar
     * @see java.util.Date
     */
    public static &lt;M,I&gt; RowFilter&lt;M,I&gt; dateFilter(ComparisonType type,
                                            Date date, int... indices) {
        return (RowFilter&lt;M,I&gt;)new DateFilter(type, date.getTime(), indices);
    }

    /**
     * Returns a &lt;code&gt;RowFilter&lt;/code&gt; that includes entries that
     * have at least one &lt;code&gt;Number&lt;/code&gt; value meeting the
     * specified criteria.  For example, the following
     * filter will only include entries with at
     * least one number value equal to 10:
     * &lt;pre&gt;
     *   RowFilter.numberFilter(ComparisonType.EQUAL, 10);
     * &lt;/pre&gt;
     *
     * @param type the type of comparison to perform
     * @param indices the indices of the values to check.  If not supplied all
     *               values are evaluated
     * @return a &lt;code&gt;RowFilter&lt;/code&gt; implementing the specified criteria
     * @throws IllegalArgumentException if any of the &lt;code&gt;indices&lt;/code&gt;
     *         are &amp;lt; 0, &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     *         or &lt;code&gt;number&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     */
    public static &lt;M,I&gt; RowFilter&lt;M,I&gt; numberFilter(ComparisonType type,
                                            Number number, int... indices) {
        return (RowFilter&lt;M,I&gt;)new NumberFilter(type, number, indices);
    }

    /**
     * Returns a &lt;code&gt;RowFilter&lt;/code&gt; that includes entries if any
     * of the supplied filters includes the entry.
     * &lt;p&gt;
     * The following example creates a &lt;code&gt;RowFilter&lt;/code&gt; that will
     * include any entries containing the string &quot;foo&quot; or the string
     * &quot;bar&quot;:
     * &lt;pre&gt;
     *   List&amp;lt;RowFilter&amp;lt;Object,Object&amp;gt;&amp;gt; filters = new ArrayList&amp;lt;RowFilter&amp;lt;Object,Object&amp;gt;&amp;gt;(2);
     *   filters.add(RowFilter.regexFilter(&quot;foo&quot;));
     *   filters.add(RowFilter.regexFilter(&quot;bar&quot;));
     *   RowFilter&amp;lt;Object,Object&amp;gt; fooBarFilter = RowFilter.orFilter(filters);
     * &lt;/pre&gt;
     *
     * @param filters the &lt;code&gt;RowFilter&lt;/code&gt;s to test
     * @throws IllegalArgumentException if any of the filters
     *         are &lt;code&gt;null&lt;/code&gt;
     * @throws NullPointerException if &lt;code&gt;filters&lt;/code&gt; is null
     * @return a &lt;code&gt;RowFilter&lt;/code&gt; implementing the specified criteria
     * @see java.util.Arrays#asList
     */
    public static &lt;M,I&gt; RowFilter&lt;M,I&gt; orFilter(
            Iterable&lt;? extends RowFilter&lt;? super M, ? super I&gt;&gt; filters) {
        return new OrFilter&lt;M,I&gt;(filters);
    }

    /**
     * Returns a &lt;code&gt;RowFilter&lt;/code&gt; that includes entries if all
     * of the supplied filters include the entry.
     * &lt;p&gt;
     * The following example creates a &lt;code&gt;RowFilter&lt;/code&gt; that will
     * include any entries containing the string &quot;foo&quot; and the string
     * &quot;bar&quot;:
     * &lt;pre&gt;
     *   List&amp;lt;RowFilter&amp;lt;Object,Object&amp;gt;&amp;gt; filters = new ArrayList&amp;lt;RowFilter&amp;lt;Object,Object&amp;gt;&amp;gt;(2);
     *   filters.add(RowFilter.regexFilter(&quot;foo&quot;));
     *   filters.add(RowFilter.regexFilter(&quot;bar&quot;));
     *   RowFilter&amp;lt;Object,Object&amp;gt; fooBarFilter = RowFilter.andFilter(filters);
     * &lt;/pre&gt;
     *
     * @param filters the &lt;code&gt;RowFilter&lt;/code&gt;s to test
     * @return a &lt;code&gt;RowFilter&lt;/code&gt; implementing the specified criteria
     * @throws IllegalArgumentException if any of the filters
     *         are &lt;code&gt;null&lt;/code&gt;
     * @throws NullPointerException if &lt;code&gt;filters&lt;/code&gt; is null
     * @see java.util.Arrays#asList
     */
    public static &lt;M,I&gt; RowFilter&lt;M,I&gt; andFilter(
            Iterable&lt;? extends RowFilter&lt;? super M, ? super I&gt;&gt; filters) {
        return new AndFilter&lt;M,I&gt;(filters);
    }

    /**
     * Returns a &lt;code&gt;RowFilter&lt;/code&gt; that includes entries if the
     * supplied filter does not include the entry.
     *
     * @param filter the &lt;code&gt;RowFilter&lt;/code&gt; to negate
     * @return a &lt;code&gt;RowFilter&lt;/code&gt; implementing the specified criteria
     * @throws IllegalArgumentException if &lt;code&gt;filter&lt;/code&gt; is
     *         &lt;code&gt;null&lt;/code&gt;
     */
    public static &lt;M,I&gt; RowFilter&lt;M,I&gt; notFilter(RowFilter&lt;M,I&gt; filter) {
        return new NotFilter&lt;M,I&gt;(filter);
    }

    /**
     * Returns true if the specified entry should be shown;
     * returns false if the entry should be hidden.
     * &lt;p&gt;
     * The &lt;code&gt;entry&lt;/code&gt; argument is valid only for the duration of
     * the invocation.  Using &lt;code&gt;entry&lt;/code&gt; after the call returns
     * results in undefined behavior.
     *
     * @param entry a non-&lt;code&gt;null&lt;/code&gt; object that wraps the underlying
     *              object from the model
     * @return true if the entry should be shown
     */
    public abstract boolean include(Entry&lt;? extends M, ? extends I&gt; entry);

    //
    // WARNING:
    // Because of the method signature of dateFilter/numberFilter/regexFilter
    // we can NEVER add a method to RowFilter that returns M,I. If we were
    // to do so it would be possible to get a ClassCastException during normal
    // usage.
    //

    /**
     * An &lt;code&gt;Entry&lt;/code&gt; object is passed to instances of
     * &lt;code&gt;RowFilter&lt;/code&gt;, allowing the filter to get the value of the
     * entry's data, and thus to determine whether the entry should be shown.
     * An &lt;code&gt;Entry&lt;/code&gt; object contains information about the model
     * as well as methods for getting the underlying values from the model.
     *
     * @param &lt;M&gt; the type of the model; for example &lt;code&gt;PersonModel&lt;/code&gt;
     * @param &lt;I&gt; the type of the identifier; when using
     *            &lt;code&gt;TableRowSorter&lt;/code&gt; this will be &lt;code&gt;Integer&lt;/code&gt;
     * @see javax.swing.RowFilter
     * @see javax.swing.DefaultRowSorter#setRowFilter(javax.swing.RowFilter)
     * @since 1.6
     */
    public static abstract class Entry&lt;M, I&gt; {
        /**
         * Creates an &lt;code&gt;Entry&lt;/code&gt;.
         */
        public Entry() {
        }

        /**
         * Returns the underlying model.
         *
         * @return the model containing the data that this entry represents
         */
        public abstract M getModel();

        /**
         * Returns the number of values in the entry.  For
         * example, when used with a table this corresponds to the
         * number of columns.
         *
         * @return number of values in the object being filtered
         */
        public abstract int getValueCount();

        /**
         * Returns the value at the specified index.  This may return
         * &lt;code&gt;null&lt;/code&gt;.  When used with a table, index
         * corresponds to the column number in the model.
         *
         * @param index the index of the value to get
         * @return value at the specified index
         * @throws IndexOutOfBoundsException if index &amp;lt; 0 or
         *         &amp;gt;= getValueCount
         */
        public abstract Object getValue(int index);

        /**
         * Returns the string value at the specified index.  If
         * filtering is being done based on &lt;code&gt;String&lt;/code&gt; values
         * this method is preferred to that of &lt;code&gt;getValue&lt;/code&gt;
         * as &lt;code&gt;getValue(index).toString()&lt;/code&gt; may return a
         * different result than &lt;code&gt;getStringValue(index)&lt;/code&gt;.
         * &lt;p&gt;
         * This implementation calls &lt;code&gt;getValue(index).toString()&lt;/code&gt;
         * after checking for &lt;code&gt;null&lt;/code&gt;.  Subclasses that provide
         * different string conversion should override this method if
         * necessary.
         *
         * @param index the index of the value to get
         * @return {@code non-null} string at the specified index
         * @throws IndexOutOfBoundsException if index &amp;lt; 0 ||
         *         &amp;gt;= getValueCount
         */
        public String getStringValue(int index) {
            Object value = getValue(index);
            return (value == null) ? &quot;&quot; : value.toString();
        }

        /**
         * Returns the identifer (in the model) of the entry.
         * For a table this corresponds to the index of the row in the model,
         * expressed as an &lt;code&gt;Integer&lt;/code&gt;.
         *
         * @return a model-based (not view-based) identifier for
         *         this entry
         */
        public abstract I getIdentifier();
    }


    private static abstract class GeneralFilter extends RowFilter&lt;Object,Object&gt; {
        private int[] columns;

        GeneralFilter(int[] columns) {
            checkIndices(columns);
            this.columns = columns;
        }

        public boolean include(Entry&lt;? extends Object,? extends Object&gt; value){
            int count = value.getValueCount();
            if (columns.length &gt; 0) {
                for (int i = columns.length - 1; i &gt;= 0; i--) {
                    int index = columns[i];
                    if (index &lt; count) {
                        if (include(value, index)) {
                            return true;
                        }
                    }
                }
            }
            else {
                while (--count &gt;= 0) {
                    if (include(value, count)) {
                        return true;
                    }
                }
            }
            return false;
        }

        protected abstract boolean include(
              Entry&lt;? extends Object,? extends Object&gt; value, int index);
    }


    private static class RegexFilter extends GeneralFilter {
        private Matcher matcher;

        RegexFilter(Pattern regex, int[] columns) {
            super(columns);
            if (regex == null) {
                throw new IllegalArgumentException(&quot;Pattern must be non-null&quot;);
            }
            matcher = regex.matcher(&quot;&quot;);
        }

        protected boolean include(
                Entry&lt;? extends Object,? extends Object&gt; value, int index) {
            matcher.reset(value.getStringValue(index));
            return matcher.find();
        }
    }


    private static class DateFilter extends GeneralFilter {
        private long date;
        private ComparisonType type;

        DateFilter(ComparisonType type, long date, int[] columns) {
            super(columns);
            if (type == null) {
                throw new IllegalArgumentException(&quot;type must be non-null&quot;);
            }
            this.type = type;
            this.date = date;
        }

        protected boolean include(
                Entry&lt;? extends Object,? extends Object&gt; value, int index) {
            Object v = value.getValue(index);

            if (v instanceof Date) {
                long vDate = ((Date)v).getTime();
                switch(type) {
                case BEFORE:
                    return (vDate &lt; date);
                case AFTER:
                    return (vDate &gt; date);
                case EQUAL:
                    return (vDate == date);
                case NOT_EQUAL:
                    return (vDate != date);
                default:
                    break;
                }
            }
            return false;
        }
    }




    private static class NumberFilter extends GeneralFilter {
        private boolean isComparable;
        private Number number;
        private ComparisonType type;

        NumberFilter(ComparisonType type, Number number, int[] columns) {
            super(columns);
            if (type == null || number == null) {
                throw new IllegalArgumentException(
                    &quot;type and number must be non-null&quot;);
            }
            this.type = type;
            this.number = number;
            isComparable = (number instanceof Comparable);
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        protected boolean include(
                Entry&lt;? extends Object,? extends Object&gt; value, int index) {
            Object v = value.getValue(index);

            if (v instanceof Number) {
                boolean compared = true;
                int compareResult;
                Class vClass = v.getClass();
                if (number.getClass() == vClass &amp;&amp; isComparable) {
                    compareResult = ((Comparable)number).compareTo(v);
                }
                else {
                    compareResult = longCompare((Number)v);
                }
                switch(type) {
                case BEFORE:
                    return (compareResult &gt; 0);
                case AFTER:
                    return (compareResult &lt; 0);
                case EQUAL:
                    return (compareResult == 0);
                case NOT_EQUAL:
                    return (compareResult != 0);
                default:
                    break;
                }
            }
            return false;
        }

        private int longCompare(Number o) {
            long diff = number.longValue() - o.longValue();

            if (diff &lt; 0) {
                return -1;
            }
            else if (diff &gt; 0) {
                return 1;
            }
            return 0;
        }
    }


    private static class OrFilter&lt;M,I&gt; extends RowFilter&lt;M,I&gt; {
        List&lt;RowFilter&lt;? super M,? super I&gt;&gt; filters;

        OrFilter(Iterable&lt;? extends RowFilter&lt;? super M, ? super I&gt;&gt; filters) {
            this.filters = new ArrayList&lt;RowFilter&lt;? super M,? super I&gt;&gt;();
            for (RowFilter&lt;? super M, ? super I&gt; filter : filters) {
                if (filter == null) {
                    throw new IllegalArgumentException(
                        &quot;Filter must be non-null&quot;);
                }
                this.filters.add(filter);
            }
        }

        public boolean include(Entry&lt;? extends M, ? extends I&gt; value) {
            for (RowFilter&lt;? super M,? super I&gt; filter : filters) {
                if (filter.include(value)) {
                    return true;
                }
            }
            return false;
        }
    }


    private static class AndFilter&lt;M,I&gt; extends OrFilter&lt;M,I&gt; {
        AndFilter(Iterable&lt;? extends RowFilter&lt;? super M,? super I&gt;&gt; filters) {
            super(filters);
        }

        public boolean include(Entry&lt;? extends M, ? extends I&gt; value) {
            for (RowFilter&lt;? super M,? super I&gt; filter : filters) {
                if (!filter.include(value)) {
                    return false;
                }
            }
            return true;
        }
    }


    private static class NotFilter&lt;M,I&gt; extends RowFilter&lt;M,I&gt; {
        private RowFilter&lt;M,I&gt; filter;

        NotFilter(RowFilter&lt;M,I&gt; filter) {
            if (filter == null) {
                throw new IllegalArgumentException(
                    &quot;filter must be non-null&quot;);
            }
            this.filter = filter;
        }

        public boolean include(Entry&lt;? extends M, ? extends I&gt; value) {
            return !filter.include(value);
        }
    }
}
</pre>
</body>
</html>
