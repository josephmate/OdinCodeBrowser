<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text.html;

import java.awt.font.TextAttribute;
import java.util.*;
import java.net.URL;
import java.net.MalformedURLException;
import java.io.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.undo.*;
import sun.swing.SwingUtilities2;
import static sun.swing.SwingUtilities2.IMPLIED_CR;

/**
 * A document that models HTML.  The purpose of this model is to
 * support both browsing and editing.  As a result, the structure
 * described by an HTML document is not exactly replicated by default.
 * The element structure that is modeled by default, is built by the
 * class &lt;code&gt;HTMLDocument.HTMLReader&lt;/code&gt;, which implements the
 * &lt;code&gt;HTMLEditorKit.ParserCallback&lt;/code&gt; protocol that the parser
 * expects.  To change the structure one can subclass
 * &lt;code&gt;HTMLReader&lt;/code&gt;, and reimplement the method {@link
 * #getReader(int)} to return the new reader implementation.  The
 * documentation for &lt;code&gt;HTMLReader&lt;/code&gt; should be consulted for
 * the details of the default structure created.  The intent is that
 * the document be non-lossy (although reproducing the HTML format may
 * result in a different format).
 *
 * &lt;p&gt;The document models only HTML, and makes no attempt to store
 * view attributes in it.  The elements are identified by the
 * &lt;code&gt;StyleContext.NameAttribute&lt;/code&gt; attribute, which should
 * always have a value of type &lt;code&gt;HTML.Tag&lt;/code&gt; that identifies
 * the kind of element.  Some of the elements (such as comments) are
 * synthesized.  The &lt;code&gt;HTMLFactory&lt;/code&gt; uses this attribute to
 * determine what kind of view to build.&lt;/p&gt;
 *
 * &lt;p&gt;This document supports incremental loading.  The
 * &lt;code&gt;TokenThreshold&lt;/code&gt; property controls how much of the parse
 * is buffered before trying to update the element structure of the
 * document.  This property is set by the &lt;code&gt;EditorKit&lt;/code&gt; so
 * that subclasses can disable it.&lt;/p&gt;
 *
 * &lt;p&gt;The &lt;code&gt;Base&lt;/code&gt; property determines the URL against which
 * relative URLs are resolved.  By default, this will be the
 * &lt;code&gt;Document.StreamDescriptionProperty&lt;/code&gt; if the value of the
 * property is a URL.  If a &amp;lt;BASE&amp;gt; tag is encountered, the base
 * will become the URL specified by that tag.  Because the base URL is
 * a property, it can of course be set directly.&lt;/p&gt;
 *
 * &lt;p&gt;The default content storage mechanism for this document is a gap
 * buffer (&lt;code&gt;GapContent&lt;/code&gt;).  Alternatives can be supplied by
 * using the constructor that takes a &lt;code&gt;Content&lt;/code&gt;
 * implementation.&lt;/p&gt;
 *
 * &lt;h2&gt;Modifying HTMLDocument&lt;/h2&gt;
 *
 * &lt;p&gt;In addition to the methods provided by Document and
 * StyledDocument for mutating an HTMLDocument, HTMLDocument provides
 * a number of convenience methods.  The following methods can be used
 * to insert HTML content into an existing document.&lt;/p&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #setInnerHTML(Element, String)}&lt;/li&gt;
 *   &lt;li&gt;{@link #setOuterHTML(Element, String)}&lt;/li&gt;
 *   &lt;li&gt;{@link #insertBeforeStart(Element, String)}&lt;/li&gt;
 *   &lt;li&gt;{@link #insertAfterStart(Element, String)}&lt;/li&gt;
 *   &lt;li&gt;{@link #insertBeforeEnd(Element, String)}&lt;/li&gt;
 *   &lt;li&gt;{@link #insertAfterEnd(Element, String)}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;The following examples illustrate using these methods.  Each
 * example assumes the HTML document is initialized in the following
 * way:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * JEditorPane p = new JEditorPane();
 * p.setContentType(&quot;text/html&quot;);
 * p.setText(&quot;...&quot;); // Document text is provided below.
 * HTMLDocument d = (HTMLDocument) p.getDocument();
 * &lt;/pre&gt;
 *
 * &lt;p&gt;With the following HTML content:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * &amp;lt;html&amp;gt;
 *   &amp;lt;head&amp;gt;
 *     &amp;lt;title&amp;gt;An example HTMLDocument&amp;lt;/title&amp;gt;
 *     &amp;lt;style type=&quot;text/css&quot;&amp;gt;
 *       div { background-color: silver; }
 *       ul { color: red; }
 *     &amp;lt;/style&amp;gt;
 *   &amp;lt;/head&amp;gt;
 *   &amp;lt;body&amp;gt;
 *     &amp;lt;div id=&quot;BOX&quot;&amp;gt;
 *       &amp;lt;p&amp;gt;Paragraph 1&amp;lt;/p&amp;gt;
 *       &amp;lt;p&amp;gt;Paragraph 2&amp;lt;/p&amp;gt;
 *     &amp;lt;/div&amp;gt;
 *   &amp;lt;/body&amp;gt;
 * &amp;lt;/html&amp;gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;All the methods for modifying an HTML document require an {@link
 * Element}.  Elements can be obtained from an HTML document by using
 * the method {@link #getElement(Element e, Object attribute, Object
 * value)}.  It returns the first descendant element that contains the
 * specified attribute with the given value, in depth-first order.
 * For example, &lt;code&gt;d.getElement(d.getDefaultRootElement(),
 * StyleConstants.NameAttribute, HTML.Tag.P)&lt;/code&gt; returns the first
 * paragraph element.&lt;/p&gt;
 *
 * &lt;p&gt;A convenient shortcut for locating elements is the method {@link
 * #getElement(String)}; returns an element whose &lt;code&gt;ID&lt;/code&gt;
 * attribute matches the specified value.  For example,
 * &lt;code&gt;d.getElement(&quot;BOX&quot;)&lt;/code&gt; returns the &lt;code&gt;DIV&lt;/code&gt;
 * element.&lt;/p&gt;
 *
 * &lt;p&gt;The {@link #getIterator(HTML.Tag t)} method can also be used for
 * finding all occurrences of the specified HTML tag in the
 * document.&lt;/p&gt;
 *
 * &lt;h3&gt;Inserting elements&lt;/h3&gt;
 *
 * &lt;p&gt;Elements can be inserted before or after the existing children
 * of any non-leaf element by using the methods
 * &lt;code&gt;insertAfterStart&lt;/code&gt; and &lt;code&gt;insertBeforeEnd&lt;/code&gt;.
 * For example, if &lt;code&gt;e&lt;/code&gt; is the &lt;code&gt;DIV&lt;/code&gt; element,
 * &lt;code&gt;d.insertAfterStart(e, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List
 * Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; inserts the list before the first
 * paragraph, and &lt;code&gt;d.insertBeforeEnd(e, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List
 * Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; inserts the list after the last
 * paragraph.  The &lt;code&gt;DIV&lt;/code&gt; block becomes the parent of the
 * newly inserted elements.&lt;/p&gt;
 *
 * &lt;p&gt;Sibling elements can be inserted before or after any element by
 * using the methods &lt;code&gt;insertBeforeStart&lt;/code&gt; and
 * &lt;code&gt;insertAfterEnd&lt;/code&gt;.  For example, if &lt;code&gt;e&lt;/code&gt; is the
 * &lt;code&gt;DIV&lt;/code&gt; element, &lt;code&gt;d.insertBeforeStart(e,
 * &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; inserts the list
 * before the &lt;code&gt;DIV&lt;/code&gt; element, and &lt;code&gt;d.insertAfterEnd(e,
 * &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; inserts the list
 * after the &lt;code&gt;DIV&lt;/code&gt; element.  The newly inserted elements
 * become siblings of the &lt;code&gt;DIV&lt;/code&gt; element.&lt;/p&gt;
 *
 * &lt;h3&gt;Replacing elements&lt;/h3&gt;
 *
 * &lt;p&gt;Elements and all their descendants can be replaced by using the
 * methods &lt;code&gt;setInnerHTML&lt;/code&gt; and &lt;code&gt;setOuterHTML&lt;/code&gt;.
 * For example, if &lt;code&gt;e&lt;/code&gt; is the &lt;code&gt;DIV&lt;/code&gt; element,
 * &lt;code&gt;d.setInnerHTML(e, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List
 * Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; replaces all children paragraphs with
 * the list, and &lt;code&gt;d.setOuterHTML(e, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List
 * Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; replaces the &lt;code&gt;DIV&lt;/code&gt; element
 * itself.  In latter case the parent of the list is the
 * &lt;code&gt;BODY&lt;/code&gt; element.
 *
 * &lt;h3&gt;Summary&lt;/h3&gt;
 *
 * &lt;p&gt;The following table shows the example document and the results
 * of various methods described above.&lt;/p&gt;
 *
 * &lt;table border=1 cellspacing=0&gt;
 *   &lt;tr&gt;
 *     &lt;th&gt;Example&lt;/th&gt;
 *     &lt;th&gt;&lt;code&gt;insertAfterStart&lt;/code&gt;&lt;/th&gt;
 *     &lt;th&gt;&lt;code&gt;insertBeforeEnd&lt;/code&gt;&lt;/th&gt;
 *     &lt;th&gt;&lt;code&gt;insertBeforeStart&lt;/code&gt;&lt;/th&gt;
 *     &lt;th&gt;&lt;code&gt;insertAfterEnd&lt;/code&gt;&lt;/th&gt;
 *     &lt;th&gt;&lt;code&gt;setInnerHTML&lt;/code&gt;&lt;/th&gt;
 *     &lt;th&gt;&lt;code&gt;setOuterHTML&lt;/code&gt;&lt;/th&gt;
 *   &lt;/tr&gt;
 *   &lt;tr valign=&quot;top&quot;&gt;
 *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
 *       &lt;div style=&quot;background-color: silver;&quot;&gt;
 *         &lt;p&gt;Paragraph 1&lt;/p&gt;
 *         &lt;p&gt;Paragraph 2&lt;/p&gt;
 *       &lt;/div&gt;
 *     &lt;/td&gt;
 * &lt;!--insertAfterStart--&gt;
 *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
 *       &lt;div style=&quot;background-color: silver;&quot;&gt;
 *         &lt;ul style=&quot;color: red;&quot;&gt;
 *           &lt;li&gt;List Item&lt;/li&gt;
 *         &lt;/ul&gt;
 *         &lt;p&gt;Paragraph 1&lt;/p&gt;
 *         &lt;p&gt;Paragraph 2&lt;/p&gt;
 *       &lt;/div&gt;
 *     &lt;/td&gt;
 * &lt;!--insertBeforeEnd--&gt;
 *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
 *       &lt;div style=&quot;background-color: silver;&quot;&gt;
 *         &lt;p&gt;Paragraph 1&lt;/p&gt;
 *         &lt;p&gt;Paragraph 2&lt;/p&gt;
 *         &lt;ul style=&quot;color: red;&quot;&gt;
 *           &lt;li&gt;List Item&lt;/li&gt;
 *         &lt;/ul&gt;
 *       &lt;/div&gt;
 *     &lt;/td&gt;
 * &lt;!--insertBeforeStart--&gt;
 *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
 *       &lt;ul style=&quot;color: red;&quot;&gt;
 *         &lt;li&gt;List Item&lt;/li&gt;
 *       &lt;/ul&gt;
 *       &lt;div style=&quot;background-color: silver;&quot;&gt;
 *         &lt;p&gt;Paragraph 1&lt;/p&gt;
 *         &lt;p&gt;Paragraph 2&lt;/p&gt;
 *       &lt;/div&gt;
 *     &lt;/td&gt;
 * &lt;!--insertAfterEnd--&gt;
 *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
 *       &lt;div style=&quot;background-color: silver;&quot;&gt;
 *         &lt;p&gt;Paragraph 1&lt;/p&gt;
 *         &lt;p&gt;Paragraph 2&lt;/p&gt;
 *       &lt;/div&gt;
 *       &lt;ul style=&quot;color: red;&quot;&gt;
 *         &lt;li&gt;List Item&lt;/li&gt;
 *       &lt;/ul&gt;
 *     &lt;/td&gt;
 * &lt;!--setInnerHTML--&gt;
 *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
 *       &lt;div style=&quot;background-color: silver;&quot;&gt;
 *         &lt;ul style=&quot;color: red;&quot;&gt;
 *           &lt;li&gt;List Item&lt;/li&gt;
 *         &lt;/ul&gt;
 *       &lt;/div&gt;
 *     &lt;/td&gt;
 * &lt;!--setOuterHTML--&gt;
 *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
 *       &lt;ul style=&quot;color: red;&quot;&gt;
 *         &lt;li&gt;List Item&lt;/li&gt;
 *       &lt;/ul&gt;
 *     &lt;/td&gt;
 *   &lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; Serialized objects of this class will
 * not be compatible with future Swing releases. The current
 * serialization support is appropriate for short term storage or RMI
 * between applications running the same version of Swing.  As of 1.4,
 * support for long term storage of all JavaBeans&amp;trade;
 * has been added to the
 * &lt;code&gt;java.beans&lt;/code&gt; package.  Please see {@link
 * java.beans.XMLEncoder}.&lt;/p&gt;
 *
 * @author  Timothy Prinzing
 * @author  Scott Violet
 * @author  Sunita Mani
 */
public class HTMLDocument extends DefaultStyledDocument {
    /**
     * Constructs an HTML document using the default buffer size
     * and a default &lt;code&gt;StyleSheet&lt;/code&gt;.  This is a convenience
     * method for the constructor
     * &lt;code&gt;HTMLDocument(Content, StyleSheet)&lt;/code&gt;.
     */
    public HTMLDocument() {
        this(new GapContent(BUFFER_SIZE_DEFAULT), new StyleSheet());
    }

    /**
     * Constructs an HTML document with the default content
     * storage implementation and the specified style/attribute
     * storage mechanism.  This is a convenience method for the
     * constructor
     * &lt;code&gt;HTMLDocument(Content, StyleSheet)&lt;/code&gt;.
     *
     * @param styles  the styles
     */
    public HTMLDocument(StyleSheet styles) {
        this(new GapContent(BUFFER_SIZE_DEFAULT), styles);
    }

    /**
     * Constructs an HTML document with the given content
     * storage implementation and the given style/attribute
     * storage mechanism.
     *
     * @param c  the container for the content
     * @param styles the styles
     */
    public HTMLDocument(Content c, StyleSheet styles) {
        super(c, styles);
    }

    /**
     * Fetches the reader for the parser to use when loading the document
     * with HTML.  This is implemented to return an instance of
     * &lt;code&gt;HTMLDocument.HTMLReader&lt;/code&gt;.
     * Subclasses can reimplement this
     * method to change how the document gets structured if desired.
     * (For example, to handle custom tags, or structurally represent character
     * style elements.)
     *
     * @param pos the starting position
     * @return the reader used by the parser to load the document
     */
    public HTMLEditorKit.ParserCallback getReader(int pos) {
        Object desc = getProperty(Document.StreamDescriptionProperty);
        if (desc instanceof URL) {
            setBase((URL)desc);
        }
        HTMLReader reader = new HTMLReader(pos);
        return reader;
    }

    /**
     * Returns the reader for the parser to use to load the document
     * with HTML.  This is implemented to return an instance of
     * &lt;code&gt;HTMLDocument.HTMLReader&lt;/code&gt;.
     * Subclasses can reimplement this
     * method to change how the document gets structured if desired.
     * (For example, to handle custom tags, or structurally represent character
     * style elements.)
     * &lt;p&gt;This is a convenience method for
     * &lt;code&gt;getReader(int, int, int, HTML.Tag, TRUE)&lt;/code&gt;.
     *
     * @param popDepth   the number of &lt;code&gt;ElementSpec.EndTagTypes&lt;/code&gt;
     *          to generate before inserting
     * @param pushDepth  the number of &lt;code&gt;ElementSpec.StartTagTypes&lt;/code&gt;
     *          with a direction of &lt;code&gt;ElementSpec.JoinNextDirection&lt;/code&gt;
     *          that should be generated before inserting,
     *          but after the end tags have been generated
     * @param insertTag  the first tag to start inserting into document
     * @return the reader used by the parser to load the document
     */
    public HTMLEditorKit.ParserCallback getReader(int pos, int popDepth,
                                                  int pushDepth,
                                                  HTML.Tag insertTag) {
        return getReader(pos, popDepth, pushDepth, insertTag, true);
    }

    /**
     * Fetches the reader for the parser to use to load the document
     * with HTML.  This is implemented to return an instance of
     * HTMLDocument.HTMLReader.  Subclasses can reimplement this
     * method to change how the document get structured if desired
     * (e.g. to handle custom tags, structurally represent character
     * style elements, etc.).
     *
     * @param popDepth   the number of &lt;code&gt;ElementSpec.EndTagTypes&lt;/code&gt;
     *          to generate before inserting
     * @param pushDepth  the number of &lt;code&gt;ElementSpec.StartTagTypes&lt;/code&gt;
     *          with a direction of &lt;code&gt;ElementSpec.JoinNextDirection&lt;/code&gt;
     *          that should be generated before inserting,
     *          but after the end tags have been generated
     * @param insertTag  the first tag to start inserting into document
     * @param insertInsertTag  false if all the Elements after insertTag should
     *        be inserted; otherwise insertTag will be inserted
     * @return the reader used by the parser to load the document
     */
    HTMLEditorKit.ParserCallback getReader(int pos, int popDepth,
                                           int pushDepth,
                                           HTML.Tag insertTag,
                                           boolean insertInsertTag) {
        Object desc = getProperty(Document.StreamDescriptionProperty);
        if (desc instanceof URL) {
            setBase((URL)desc);
        }
        HTMLReader reader = new HTMLReader(pos, popDepth, pushDepth,
                                           insertTag, insertInsertTag, false,
                                           true);
        return reader;
    }

    /**
     * Returns the location to resolve relative URLs against.  By
     * default this will be the document's URL if the document
     * was loaded from a URL.  If a base tag is found and
     * can be parsed, it will be used as the base location.
     *
     * @return the base location
     */
    public URL getBase() {
        return base;
    }

    /**
     * Sets the location to resolve relative URLs against.  By
     * default this will be the document's URL if the document
     * was loaded from a URL.  If a base tag is found and
     * can be parsed, it will be used as the base location.
     * &lt;p&gt;This also sets the base of the &lt;code&gt;StyleSheet&lt;/code&gt;
     * to be &lt;code&gt;u&lt;/code&gt; as well as the base of the document.
     *
     * @param u  the desired base URL
     */
    public void setBase(URL u) {
        base = u;
        getStyleSheet().setBase(u);
    }

    /**
     * Inserts new elements in bulk.  This is how elements get created
     * in the document.  The parsing determines what structure is needed
     * and creates the specification as a set of tokens that describe the
     * edit while leaving the document free of a write-lock.  This method
     * can then be called in bursts by the reader to acquire a write-lock
     * for a shorter duration (i.e. while the document is actually being
     * altered).
     *
     * @param offset the starting offset
     * @param data the element data
     * @exception BadLocationException  if the given position does not
     *   represent a valid location in the associated document.
     */
    protected void insert(int offset, ElementSpec[] data) throws BadLocationException {
        super.insert(offset, data);
    }

    /**
     * Updates document structure as a result of text insertion.  This
     * will happen within a write lock.  This implementation simply
     * parses the inserted content for line breaks and builds up a set
     * of instructions for the element buffer.
     *
     * @param chng a description of the document change
     * @param attr the attributes
     */
    protected void insertUpdate(DefaultDocumentEvent chng, AttributeSet attr) {
        if(attr == null) {
            attr = contentAttributeSet;
        }

        // If this is the composed text element, merge the content attribute to it
        else if (attr.isDefined(StyleConstants.ComposedTextAttribute)) {
            ((MutableAttributeSet)attr).addAttributes(contentAttributeSet);
        }

        if (attr.isDefined(IMPLIED_CR)) {
            ((MutableAttributeSet)attr).removeAttribute(IMPLIED_CR);
        }

        super.insertUpdate(chng, attr);
    }

    /**
     * Replaces the contents of the document with the given
     * element specifications.  This is called before insert if
     * the loading is done in bursts.  This is the only method called
     * if loading the document entirely in one burst.
     *
     * @param data  the new contents of the document
     */
    protected void create(ElementSpec[] data) {
        super.create(data);
    }

    /**
     * Sets attributes for a paragraph.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param offset the offset into the paragraph (must be at least 0)
     * @param length the number of characters affected (must be at least 0)
     * @param s the attributes
     * @param replace whether to replace existing attributes, or merge them
     */
    public void setParagraphAttributes(int offset, int length, AttributeSet s,
                                       boolean replace) {
        try {
            writeLock();
            // Make sure we send out a change for the length of the paragraph.
            int end = Math.min(offset + length, getLength());
            Element e = getParagraphElement(offset);
            offset = e.getStartOffset();
            e = getParagraphElement(end);
            length = Math.max(0, e.getEndOffset() - offset);
            DefaultDocumentEvent changes =
                new DefaultDocumentEvent(offset, length,
                                         DocumentEvent.EventType.CHANGE);
            AttributeSet sCopy = s.copyAttributes();
            int lastEnd = Integer.MAX_VALUE;
            for (int pos = offset; pos &lt;= end; pos = lastEnd) {
                Element paragraph = getParagraphElement(pos);
                if (lastEnd == paragraph.getEndOffset()) {
                    lastEnd++;
                }
                else {
                    lastEnd = paragraph.getEndOffset();
                }
                MutableAttributeSet attr =
                    (MutableAttributeSet) paragraph.getAttributes();
                changes.addEdit(new AttributeUndoableEdit(paragraph, sCopy, replace));
                if (replace) {
                    attr.removeAttributes(attr);
                }
                attr.addAttributes(s);
            }
            changes.end();
            fireChangedUpdate(changes);
            fireUndoableEditUpdate(new UndoableEditEvent(this, changes));
        } finally {
            writeUnlock();
        }
    }

    /**
     * Fetches the &lt;code&gt;StyleSheet&lt;/code&gt; with the document-specific display
     * rules (CSS) that were specified in the HTML document itself.
     *
     * @return the &lt;code&gt;StyleSheet&lt;/code&gt;
     */
    public StyleSheet getStyleSheet() {
        return (StyleSheet) getAttributeContext();
    }

    /**
     * Fetches an iterator for the specified HTML tag.
     * This can be used for things like iterating over the
     * set of anchors contained, or iterating over the input
     * elements.
     *
     * @param t the requested &lt;code&gt;HTML.Tag&lt;/code&gt;
     * @return the &lt;code&gt;Iterator&lt;/code&gt; for the given HTML tag
     * @see javax.swing.text.html.HTML.Tag
     */
    public Iterator getIterator(HTML.Tag t) {
        if (t.isBlock()) {
            // TBD
            return null;
        }
        return new LeafIterator(t, this);
    }

    /**
     * Creates a document leaf element that directly represents
     * text (doesn't have any children).  This is implemented
     * to return an element of type
     * &lt;code&gt;HTMLDocument.RunElement&lt;/code&gt;.
     *
     * @param parent the parent element
     * @param a the attributes for the element
     * @param p0 the beginning of the range (must be at least 0)
     * @param p1 the end of the range (must be at least p0)
     * @return the new element
     */
    protected Element createLeafElement(Element parent, AttributeSet a, int p0, int p1) {
        return new RunElement(parent, a, p0, p1);
    }

    /**
     * Creates a document branch element, that can contain other elements.
     * This is implemented to return an element of type
     * &lt;code&gt;HTMLDocument.BlockElement&lt;/code&gt;.
     *
     * @param parent the parent element
     * @param a the attributes
     * @return the element
     */
    protected Element createBranchElement(Element parent, AttributeSet a) {
        return new BlockElement(parent, a);
    }

    /**
     * Creates the root element to be used to represent the
     * default document structure.
     *
     * @return the element base
     */
    protected AbstractElement createDefaultRoot() {
        // grabs a write-lock for this initialization and
        // abandon it during initialization so in normal
        // operation we can detect an illegitimate attempt
        // to mutate attributes.
        writeLock();
        MutableAttributeSet a = new SimpleAttributeSet();
        a.addAttribute(StyleConstants.NameAttribute, HTML.Tag.HTML);
        BlockElement html = new BlockElement(null, a.copyAttributes());
        a.removeAttributes(a);
        a.addAttribute(StyleConstants.NameAttribute, HTML.Tag.BODY);
        BlockElement body = new BlockElement(html, a.copyAttributes());
        a.removeAttributes(a);
        a.addAttribute(StyleConstants.NameAttribute, HTML.Tag.P);
        getStyleSheet().addCSSAttributeFromHTML(a, CSS.Attribute.MARGIN_TOP, &quot;0&quot;);
        BlockElement paragraph = new BlockElement(body, a.copyAttributes());
        a.removeAttributes(a);
        a.addAttribute(StyleConstants.NameAttribute, HTML.Tag.CONTENT);
        RunElement brk = new RunElement(paragraph, a, 0, 1);
        Element[] buff = new Element[1];
        buff[0] = brk;
        paragraph.replace(0, 0, buff);
        buff[0] = paragraph;
        body.replace(0, 0, buff);
        buff[0] = body;
        html.replace(0, 0, buff);
        writeUnlock();
        return html;
    }

    /**
     * Sets the number of tokens to buffer before trying to update
     * the documents element structure.
     *
     * @param n  the number of tokens to buffer
     */
    public void setTokenThreshold(int n) {
        putProperty(TokenThreshold, new Integer(n));
    }

    /**
     * Gets the number of tokens to buffer before trying to update
     * the documents element structure.  The default value is
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.
     *
     * @return the number of tokens to buffer
     */
    public int getTokenThreshold() {
        Integer i = (Integer) getProperty(TokenThreshold);
        if (i != null) {
            return i.intValue();
        }
        return Integer.MAX_VALUE;
    }

    /**
     * Determines how unknown tags are handled by the parser.
     * If set to true, unknown
     * tags are put in the model, otherwise they are dropped.
     *
     * @param preservesTags  true if unknown tags should be
     *          saved in the model, otherwise tags are dropped
     * @see javax.swing.text.html.HTML.Tag
     */
    public void setPreservesUnknownTags(boolean preservesTags) {
        preservesUnknownTags = preservesTags;
    }

    /**
     * Returns the behavior the parser observes when encountering
     * unknown tags.
     *
     * @see javax.swing.text.html.HTML.Tag
     * @return true if unknown tags are to be preserved when parsing
     */
    public boolean getPreservesUnknownTags() {
        return preservesUnknownTags;
    }

    /**
     * Processes &lt;code&gt;HyperlinkEvents&lt;/code&gt; that
     * are generated by documents in an HTML frame.
     * The &lt;code&gt;HyperlinkEvent&lt;/code&gt; type, as the parameter suggests,
     * is &lt;code&gt;HTMLFrameHyperlinkEvent&lt;/code&gt;.
     * In addition to the typical information contained in a
     * &lt;code&gt;HyperlinkEvent&lt;/code&gt;,
     * this event contains the element that corresponds to the frame in
     * which the click happened (the source element) and the
     * target name.  The target name has 4 possible values:
     * &lt;ul&gt;
     * &lt;li&gt;  _self
     * &lt;li&gt;  _parent
     * &lt;li&gt;  _top
     * &lt;li&gt;  a named frame
     * &lt;/ul&gt;
     *
     * If target is _self, the action is to change the value of the
     * &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute and fires a
     * &lt;code&gt;ChangedUpdate&lt;/code&gt; event.
     *&lt;p&gt;
     * If the target is _parent, then it deletes the parent element,
     * which is a &amp;lt;FRAMESET&amp;gt; element, and inserts a new &amp;lt;FRAME&amp;gt;
     * element, and sets its &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute
     * to have a value equal to the destination URL and fire a
     * &lt;code&gt;RemovedUpdate&lt;/code&gt; and &lt;code&gt;InsertUpdate&lt;/code&gt;.
     *&lt;p&gt;
     * If the target is _top, this method does nothing. In the implementation
     * of the view for a frame, namely the &lt;code&gt;FrameView&lt;/code&gt;,
     * the processing of _top is handled.  Given that _top implies
     * replacing the entire document, it made sense to handle this outside
     * of the document that it will replace.
     *&lt;p&gt;
     * If the target is a named frame, then the element hierarchy is searched
     * for an element with a name equal to the target, its
     * &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute is updated and a
     * &lt;code&gt;ChangedUpdate&lt;/code&gt; event is fired.
     *
     * @param e the event
     */
    public void processHTMLFrameHyperlinkEvent(HTMLFrameHyperlinkEvent e) {
        String frameName = e.getTarget();
        Element element = e.getSourceElement();
        String urlStr = e.getURL().toString();

        if (frameName.equals(&quot;_self&quot;)) {
            /*
              The source and destination elements
              are the same.
            */
            updateFrame(element, urlStr);
        } else if (frameName.equals(&quot;_parent&quot;)) {
            /*
              The destination is the parent of the frame.
            */
            updateFrameSet(element.getParentElement(), urlStr);
        } else {
            /*
              locate a named frame
            */
            Element targetElement = findFrame(frameName);
            if (targetElement != null) {
                updateFrame(targetElement, urlStr);
            }
        }
    }


    /**
     * Searches the element hierarchy for an FRAME element
     * that has its name attribute equal to the &lt;code&gt;frameName&lt;/code&gt;.
     *
     * @param frameName
     * @return the element whose NAME attribute has a value of
     *          &lt;code&gt;frameName&lt;/code&gt;; returns &lt;code&gt;null&lt;/code&gt;
     *          if not found
     */
    private Element findFrame(String frameName) {
        ElementIterator it = new ElementIterator(this);
        Element next;

        while ((next = it.next()) != null) {
            AttributeSet attr = next.getAttributes();
            if (matchNameAttribute(attr, HTML.Tag.FRAME)) {
                String frameTarget = (String)attr.getAttribute(HTML.Attribute.NAME);
                if (frameTarget != null &amp;&amp; frameTarget.equals(frameName)) {
                    break;
                }
            }
        }
        return next;
    }

    /**
     * Returns true if &lt;code&gt;StyleConstants.NameAttribute&lt;/code&gt; is
     * equal to the tag that is passed in as a parameter.
     *
     * @param attr the attributes to be matched
     * @param tag the value to be matched
     * @return true if there is a match, false otherwise
     * @see javax.swing.text.html.HTML.Attribute
     */
    static boolean matchNameAttribute(AttributeSet attr, HTML.Tag tag) {
        Object o = attr.getAttribute(StyleConstants.NameAttribute);
        if (o instanceof HTML.Tag) {
            HTML.Tag name = (HTML.Tag) o;
            if (name == tag) {
                return true;
            }
        }
        return false;
    }

    /**
     * Replaces a frameset branch Element with a frame leaf element.
     *
     * @param element the frameset element to remove
     * @param url     the value for the SRC attribute for the
     *                new frame that will replace the frameset
     */
    private void updateFrameSet(Element element, String url) {
        try {
            int startOffset = element.getStartOffset();
            int endOffset = Math.min(getLength(), element.getEndOffset());
            String html = &quot;&lt;frame&quot;;
            if (url != null) {
                html += &quot; src=\&quot;&quot; + url + &quot;\&quot;&quot;;
            }
            html += &quot;&gt;&quot;;
            installParserIfNecessary();
            setOuterHTML(element, html);
        } catch (BadLocationException e1) {
            // Should handle this better
        } catch (IOException ioe) {
            // Should handle this better
        }
    }


    /**
     * Updates the Frame elements &lt;code&gt;HTML.Attribute.SRC attribute&lt;/code&gt;
     * and fires a &lt;code&gt;ChangedUpdate&lt;/code&gt; event.
     *
     * @param element a FRAME element whose SRC attribute will be updated
     * @param url     a string specifying the new value for the SRC attribute
     */
    private void updateFrame(Element element, String url) {

        try {
            writeLock();
            DefaultDocumentEvent changes = new DefaultDocumentEvent(element.getStartOffset(),
                                                                    1,
                                                                    DocumentEvent.EventType.CHANGE);
            AttributeSet sCopy = element.getAttributes().copyAttributes();
            MutableAttributeSet attr = (MutableAttributeSet) element.getAttributes();
            changes.addEdit(new AttributeUndoableEdit(element, sCopy, false));
            attr.removeAttribute(HTML.Attribute.SRC);
            attr.addAttribute(HTML.Attribute.SRC, url);
            changes.end();
            fireChangedUpdate(changes);
            fireUndoableEditUpdate(new UndoableEditEvent(this, changes));
        } finally {
            writeUnlock();
        }
    }


    /**
     * Returns true if the document will be viewed in a frame.
     * @return true if document will be viewed in a frame, otherwise false
     */
    boolean isFrameDocument() {
        return frameDocument;
    }

    /**
     * Sets a boolean state about whether the document will be
     * viewed in a frame.
     * @param frameDoc  true if the document will be viewed in a frame,
     *          otherwise false
     */
    void setFrameDocumentState(boolean frameDoc) {
        this.frameDocument = frameDoc;
    }

    /**
     * Adds the specified map, this will remove a Map that has been
     * previously registered with the same name.
     *
     * @param map  the &lt;code&gt;Map&lt;/code&gt; to be registered
     */
    void addMap(Map map) {
        String     name = map.getName();

        if (name != null) {
            Object     maps = getProperty(MAP_PROPERTY);

            if (maps == null) {
                maps = new Hashtable(11);
                putProperty(MAP_PROPERTY, maps);
            }
            if (maps instanceof Hashtable) {
                ((Hashtable)maps).put(&quot;#&quot; + name, map);
            }
        }
    }

    /**
     * Removes a previously registered map.
     * @param map the &lt;code&gt;Map&lt;/code&gt; to be removed
     */
    void removeMap(Map map) {
        String     name = map.getName();

        if (name != null) {
            Object     maps = getProperty(MAP_PROPERTY);

            if (maps instanceof Hashtable) {
                ((Hashtable)maps).remove(&quot;#&quot; + name);
            }
        }
    }

    /**
     * Returns the Map associated with the given name.
     * @param name the name of the desired &lt;code&gt;Map&lt;/code&gt;
     * @return the &lt;code&gt;Map&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; if it can't
     *          be found, or if &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     */
    Map getMap(String name) {
        if (name != null) {
            Object     maps = getProperty(MAP_PROPERTY);

            if (maps != null &amp;&amp; (maps instanceof Hashtable)) {
                return (Map)((Hashtable)maps).get(name);
            }
        }
        return null;
    }

    /**
     * Returns an &lt;code&gt;Enumeration&lt;/code&gt; of the possible Maps.
     * @return the enumerated list of maps, or &lt;code&gt;null&lt;/code&gt;
     *          if the maps are not an instance of &lt;code&gt;Hashtable&lt;/code&gt;
     */
    Enumeration getMaps() {
        Object     maps = getProperty(MAP_PROPERTY);

        if (maps instanceof Hashtable) {
            return ((Hashtable)maps).elements();
        }
        return null;
    }

    /**
     * Sets the content type language used for style sheets that do not
     * explicitly specify the type. The default is text/css.
     * @param contentType  the content type language for the style sheets
     */
    /* public */
    void setDefaultStyleSheetType(String contentType) {
        putProperty(StyleType, contentType);
    }

    /**
     * Returns the content type language used for style sheets. The default
     * is text/css.
     * @return the content type language used for the style sheets
     */
    /* public */
    String getDefaultStyleSheetType() {
        String retValue = (String)getProperty(StyleType);
        if (retValue == null) {
            return &quot;text/css&quot;;
        }
        return retValue;
    }

    /**
     * Sets the parser that is used by the methods that insert html
     * into the existing document, such as &lt;code&gt;setInnerHTML&lt;/code&gt;,
     * and &lt;code&gt;setOuterHTML&lt;/code&gt;.
     * &lt;p&gt;
     * &lt;code&gt;HTMLEditorKit.createDefaultDocument&lt;/code&gt; will set the parser
     * for you. If you create an &lt;code&gt;HTMLDocument&lt;/code&gt; by hand,
     * be sure and set the parser accordingly.
     * @param parser the parser to be used for text insertion
     *
     * @since 1.3
     */
    public void setParser(HTMLEditorKit.Parser parser) {
        this.parser = parser;
        putProperty(&quot;__PARSER__&quot;, null);
    }

    /**
     * Returns the parser that is used when inserting HTML into the existing
     * document.
     * @return the parser used for text insertion
     *
     * @since 1.3
     */
    public HTMLEditorKit.Parser getParser() {
        Object p = getProperty(&quot;__PARSER__&quot;);

        if (p instanceof HTMLEditorKit.Parser) {
            return (HTMLEditorKit.Parser)p;
        }
        return parser;
    }

    /**
     * Replaces the children of the given element with the contents
     * specified as an HTML string.
     *
     * &lt;p&gt;This will be seen as at least two events, n inserts followed by
     * a remove.&lt;/p&gt;
     *
     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *     &amp;lt;body&amp;gt;
     *       |
     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *      /  \
     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Invoking &lt;code&gt;setInnerHTML(elem, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt;
     * results in the following structure (new elements are &lt;font
     * color=&quot;red&quot;&gt;in red&lt;/font&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *     &amp;lt;body&amp;gt;
     *       |
     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *         \
     *         &lt;font color=&quot;red&quot;&gt;&amp;lt;ul&amp;gt;&lt;/font&gt;
     *           \
     *           &lt;font color=&quot;red&quot;&gt;&amp;lt;li&amp;gt;&lt;/font&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Parameter &lt;code&gt;elem&lt;/code&gt; must not be a leaf element,
     * otherwise an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
     * If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt; parameter
     * is &lt;code&gt;null&lt;/code&gt;, no changes are made to the document.&lt;/p&gt;
     *
     * &lt;p&gt;For this to work correctly, the document must have an
     * &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set. This will be the case
     * if the document was created from an HTMLEditorKit via the
     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;
     *
     * @param elem the branch element whose children will be replaced
     * @param htmlText the string to be parsed and assigned to &lt;code&gt;elem&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;elem&lt;/code&gt; is a leaf
     * @throws IllegalStateException if an &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt;
     *         has not been defined
     * @since 1.3
     */
    public void setInnerHTML(Element elem, String htmlText) throws
                             BadLocationException, IOException {
        verifyParser();
        if (elem != null &amp;&amp; elem.isLeaf()) {
            throw new IllegalArgumentException
                (&quot;Can not set inner HTML of a leaf&quot;);
        }
        if (elem != null &amp;&amp; htmlText != null) {
            int oldCount = elem.getElementCount();
            int insertPosition = elem.getStartOffset();
            insertHTML(elem, elem.getStartOffset(), htmlText, true);
            if (elem.getElementCount() &gt; oldCount) {
                // Elements were inserted, do the cleanup.
                removeElements(elem, elem.getElementCount() - oldCount,
                               oldCount);
            }
        }
    }

    /**
     * Replaces the given element in the parent with the contents
     * specified as an HTML string.
     *
     * &lt;p&gt;This will be seen as at least two events, n inserts followed by
     * a remove.&lt;/p&gt;
     *
     * &lt;p&gt;When replacing a leaf this will attempt to make sure there is
     * a newline present if one is needed. This may result in an additional
     * element being inserted. Consider, if you were to replace a character
     * element that contained a newline with &amp;lt;img&amp;gt; this would create
     * two elements, one for the image, and one for the newline.&lt;/p&gt;
     *
     * &lt;p&gt;If you try to replace the element at length you will most
     * likely end up with two elements, eg
     * &lt;code&gt;setOuterHTML(getCharacterElement (getLength()),
     * &quot;blah&quot;)&lt;/code&gt; will result in two leaf elements at the end, one
     * representing 'blah', and the other representing the end
     * element.&lt;/p&gt;
     *
     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *     &amp;lt;body&amp;gt;
     *       |
     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *      /  \
     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Invoking &lt;code&gt;setOuterHTML(elem, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt;
     * results in the following structure (new elements are &lt;font
     * color=&quot;red&quot;&gt;in red&lt;/font&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *    &amp;lt;body&amp;gt;
     *      |
     *     &lt;font color=&quot;red&quot;&gt;&amp;lt;ul&amp;gt;&lt;/font&gt;
     *       \
     *       &lt;font color=&quot;red&quot;&gt;&amp;lt;li&amp;gt;&lt;/font&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt;
     * parameter is &lt;code&gt;null&lt;/code&gt;, no changes are made to the
     * document.&lt;/p&gt;
     *
     * &lt;p&gt;For this to work correctly, the document must have an
     * HTMLEditorKit.Parser set. This will be the case if the document
     * was created from an HTMLEditorKit via the
     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;
     *
     * @param elem the element to replace
     * @param htmlText the string to be parsed and inserted in place of &lt;code&gt;elem&lt;/code&gt;
     * @throws IllegalStateException if an HTMLEditorKit.Parser has not
     *         been set
     * @since 1.3
     */
    public void setOuterHTML(Element elem, String htmlText) throws
                            BadLocationException, IOException {
        verifyParser();
        if (elem != null &amp;&amp; elem.getParentElement() != null &amp;&amp;
            htmlText != null) {
            int start = elem.getStartOffset();
            int end = elem.getEndOffset();
            int startLength = getLength();
            // We don't want a newline if elem is a leaf, and doesn't contain
            // a newline.
            boolean wantsNewline = !elem.isLeaf();
            if (!wantsNewline &amp;&amp; (end &gt; startLength ||
                                 getText(end - 1, 1).charAt(0) == NEWLINE[0])){
                wantsNewline = true;
            }
            Element parent = elem.getParentElement();
            int oldCount = parent.getElementCount();
            insertHTML(parent, start, htmlText, wantsNewline);
            // Remove old.
            int newLength = getLength();
            if (oldCount != parent.getElementCount()) {
                int removeIndex = parent.getElementIndex(start + newLength -
                                                         startLength);
                removeElements(parent, removeIndex, 1);
            }
        }
    }

    /**
     * Inserts the HTML specified as a string at the start
     * of the element.
     *
     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *     &amp;lt;body&amp;gt;
     *       |
     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *      /  \
     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Invoking &lt;code&gt;insertAfterStart(elem,
     * &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt; results in the following structure
     * (new elements are &lt;font color=&quot;red&quot;&gt;in red&lt;/font&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *        &amp;lt;body&amp;gt;
     *          |
     *        &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *       /  |  \
     *    &lt;font color=&quot;red&quot;&gt;&amp;lt;ul&amp;gt;&lt;/font&gt; &amp;lt;p&amp;gt; &amp;lt;p&amp;gt;
     *     /
     *  &lt;font color=&quot;red&quot;&gt;&amp;lt;li&amp;gt;&lt;/font&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Unlike the &lt;code&gt;insertBeforeStart&lt;/code&gt; method, new
     *  elements become &lt;em&gt;children&lt;/em&gt; of the specified element,
     *  not siblings.&lt;/p&gt;
     *
     * &lt;p&gt;Parameter &lt;code&gt;elem&lt;/code&gt; must not be a leaf element,
     * otherwise an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
     * If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt; parameter
     * is &lt;code&gt;null&lt;/code&gt;, no changes are made to the document.&lt;/p&gt;
     *
     * &lt;p&gt;For this to work correctly, the document must have an
     * &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set. This will be the case
     * if the document was created from an HTMLEditorKit via the
     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;
     *
     * @param elem the branch element to be the root for the new text
     * @param htmlText the string to be parsed and assigned to &lt;code&gt;elem&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;elem&lt;/code&gt; is a leaf
     * @throws IllegalStateException if an HTMLEditorKit.Parser has not
     *         been set on the document
     * @since 1.3
     */
    public void insertAfterStart(Element elem, String htmlText) throws
                                 BadLocationException, IOException {
        verifyParser();

        if (elem == null || htmlText == null) {
            return;
        }

        if (elem.isLeaf()) {
            throw new IllegalArgumentException
                (&quot;Can not insert HTML after start of a leaf&quot;);
        }
        insertHTML(elem, elem.getStartOffset(), htmlText, false);
    }

    /**
     * Inserts the HTML specified as a string at the end of
     * the element.
     *
     * &lt;p&gt; If &lt;code&gt;elem&lt;/code&gt;'s children are leaves, and the
     * character at a &lt;code&gt;elem.getEndOffset() - 1&lt;/code&gt; is a newline,
     * this will insert before the newline so that there isn't text after
     * the newline.&lt;/p&gt;
     *
     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *     &amp;lt;body&amp;gt;
     *       |
     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *      /  \
     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Invoking &lt;code&gt;insertBeforeEnd(elem, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt;
     * results in the following structure (new elements are &lt;font
     * color=&quot;red&quot;&gt;in red&lt;/font&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *        &amp;lt;body&amp;gt;
     *          |
     *        &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *       /  |  \
     *     &amp;lt;p&amp;gt; &amp;lt;p&amp;gt; &lt;font color=&quot;red&quot;&gt;&amp;lt;ul&amp;gt;&lt;/font&gt;
     *               \
     *               &lt;font color=&quot;red&quot;&gt;&amp;lt;li&amp;gt;&lt;/font&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Unlike the &lt;code&gt;insertAfterEnd&lt;/code&gt; method, new elements
     * become &lt;em&gt;children&lt;/em&gt; of the specified element, not
     * siblings.&lt;/p&gt;
     *
     * &lt;p&gt;Parameter &lt;code&gt;elem&lt;/code&gt; must not be a leaf element,
     * otherwise an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
     * If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt; parameter
     * is &lt;code&gt;null&lt;/code&gt;, no changes are made to the document.&lt;/p&gt;
     *
     * &lt;p&gt;For this to work correctly, the document must have an
     * &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set. This will be the case
     * if the document was created from an HTMLEditorKit via the
     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;
     *
     * @param elem the element to be the root for the new text
     * @param htmlText the string to be parsed and assigned to &lt;code&gt;elem&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;elem&lt;/code&gt; is a leaf
     * @throws IllegalStateException if an HTMLEditorKit.Parser has not
     *         been set on the document
     * @since 1.3
     */
    public void insertBeforeEnd(Element elem, String htmlText) throws
                                BadLocationException, IOException {
        verifyParser();
        if (elem != null &amp;&amp; elem.isLeaf()) {
            throw new IllegalArgumentException
                (&quot;Can not set inner HTML before end of leaf&quot;);
        }
        if (elem != null) {
            int offset = elem.getEndOffset();
            if (elem.getElement(elem.getElementIndex(offset - 1)).isLeaf() &amp;&amp;
                getText(offset - 1, 1).charAt(0) == NEWLINE[0]) {
                offset--;
            }
            insertHTML(elem, offset, htmlText, false);
        }
    }

    /**
     * Inserts the HTML specified as a string before the start of
     * the given element.
     *
     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *     &amp;lt;body&amp;gt;
     *       |
     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *      /  \
     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Invoking &lt;code&gt;insertBeforeStart(elem,
     * &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt; results in the following structure
     * (new elements are &lt;font color=&quot;red&quot;&gt;in red&lt;/font&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *        &amp;lt;body&amp;gt;
     *         /  \
     *      &lt;font color=&quot;red&quot;&gt;&amp;lt;ul&amp;gt;&lt;/font&gt; &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *       /    /  \
     *     &lt;font color=&quot;red&quot;&gt;&amp;lt;li&amp;gt;&lt;/font&gt; &amp;lt;p&amp;gt;  &amp;lt;p&amp;gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Unlike the &lt;code&gt;insertAfterStart&lt;/code&gt; method, new
     * elements become &lt;em&gt;siblings&lt;/em&gt; of the specified element, not
     * children.&lt;/p&gt;
     *
     * &lt;p&gt;If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt;
     * parameter is &lt;code&gt;null&lt;/code&gt;, no changes are made to the
     * document.&lt;/p&gt;
     *
     * &lt;p&gt;For this to work correctly, the document must have an
     * &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set. This will be the case
     * if the document was created from an HTMLEditorKit via the
     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;
     *
     * @param elem the element the content is inserted before
     * @param htmlText the string to be parsed and inserted before &lt;code&gt;elem&lt;/code&gt;
     * @throws IllegalStateException if an HTMLEditorKit.Parser has not
     *         been set on the document
     * @since 1.3
     */
    public void insertBeforeStart(Element elem, String htmlText) throws
                                  BadLocationException, IOException {
        verifyParser();
        if (elem != null) {
            Element parent = elem.getParentElement();

            if (parent != null) {
                insertHTML(parent, elem.getStartOffset(), htmlText, false);
            }
        }
    }

    /**
     * Inserts the HTML specified as a string after the the end of the
     * given element.
     *
     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *     &amp;lt;body&amp;gt;
     *       |
     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *      /  \
     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Invoking &lt;code&gt;insertAfterEnd(elem, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt;
     * results in the following structure (new elements are &lt;font
     * color=&quot;red&quot;&gt;in red&lt;/font&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *        &amp;lt;body&amp;gt;
     *         /  \
     *      &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt; &lt;font color=&quot;red&quot;&gt;&amp;lt;ul&amp;gt;&lt;/font&gt;
     *       / \    \
     *     &amp;lt;p&amp;gt; &amp;lt;p&amp;gt;  &lt;font color=&quot;red&quot;&gt;&amp;lt;li&amp;gt;&lt;/font&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Unlike the &lt;code&gt;insertBeforeEnd&lt;/code&gt; method, new elements
     * become &lt;em&gt;siblings&lt;/em&gt; of the specified element, not
     * children.&lt;/p&gt;
     *
     * &lt;p&gt;If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt;
     * parameter is &lt;code&gt;null&lt;/code&gt;, no changes are made to the
     * document.&lt;/p&gt;
     *
     * &lt;p&gt;For this to work correctly, the document must have an
     * &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set. This will be the case
     * if the document was created from an HTMLEditorKit via the
     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;
     *
     * @param elem the element the content is inserted after
     * @param htmlText the string to be parsed and inserted after &lt;code&gt;elem&lt;/code&gt;
     * @throws IllegalStateException if an HTMLEditorKit.Parser has not
     *         been set on the document
     * @since 1.3
     */
    public void insertAfterEnd(Element elem, String htmlText) throws
                               BadLocationException, IOException {
        verifyParser();
        if (elem != null) {
            Element parent = elem.getParentElement();

            if (parent != null) {
                int offset = elem.getEndOffset();
                if (offset &gt; getLength()) {
                    offset--;
                }
                else if (elem.isLeaf() &amp;&amp; getText(offset - 1, 1).
                    charAt(0) == NEWLINE[0]) {
                    offset--;
                }
                insertHTML(parent, offset, htmlText, false);
            }
        }
    }

    /**
     * Returns the element that has the given id &lt;code&gt;Attribute&lt;/code&gt;.
     * If the element can't be found, &lt;code&gt;null&lt;/code&gt; is returned.
     * Note that this method works on an &lt;code&gt;Attribute&lt;/code&gt;,
     * &lt;i&gt;not&lt;/i&gt; a character tag.  In the following HTML snippet:
     * &lt;code&gt;&amp;lt;a id=&quot;HelloThere&quot;&amp;gt;&lt;/code&gt; the attribute is
     * 'id' and the character tag is 'a'.
     * This is a convenience method for
     * &lt;code&gt;getElement(RootElement, HTML.Attribute.id, id)&lt;/code&gt;.
     * This is not thread-safe.
     *
     * @param id  the string representing the desired &lt;code&gt;Attribute&lt;/code&gt;
     * @return the element with the specified &lt;code&gt;Attribute&lt;/code&gt;
     *          or &lt;code&gt;null&lt;/code&gt; if it can't be found,
     *          or &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;id&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @see javax.swing.text.html.HTML.Attribute
     * @since 1.3
     */
    public Element getElement(String id) {
        if (id == null) {
            return null;
        }
        return getElement(getDefaultRootElement(), HTML.Attribute.ID, id,
                          true);
    }

    /**
     * Returns the child element of &lt;code&gt;e&lt;/code&gt; that contains the
     * attribute, &lt;code&gt;attribute&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, or
     * &lt;code&gt;null&lt;/code&gt; if one isn't found. This is not thread-safe.
     *
     * @param e the root element where the search begins
     * @param attribute the desired &lt;code&gt;Attribute&lt;/code&gt;
     * @param value the values for the specified &lt;code&gt;Attribute&lt;/code&gt;
     * @return the element with the specified &lt;code&gt;Attribute&lt;/code&gt;
     *          and the specified &lt;code&gt;value&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
     *          if it can't be found
     * @see javax.swing.text.html.HTML.Attribute
     * @since 1.3
     */
    public Element getElement(Element e, Object attribute, Object value) {
        return getElement(e, attribute, value, true);
    }

    /**
     * Returns the child element of &lt;code&gt;e&lt;/code&gt; that contains the
     * attribute, &lt;code&gt;attribute&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, or
     * &lt;code&gt;null&lt;/code&gt; if one isn't found. This is not thread-safe.
     * &lt;p&gt;
     * If &lt;code&gt;searchLeafAttributes&lt;/code&gt; is true, and &lt;code&gt;e&lt;/code&gt; is
     * a leaf, any attributes that are instances of &lt;code&gt;HTML.Tag&lt;/code&gt;
     * with a value that is an &lt;code&gt;AttributeSet&lt;/code&gt; will also be checked.
     *
     * @param e the root element where the search begins
     * @param attribute the desired &lt;code&gt;Attribute&lt;/code&gt;
     * @param value the values for the specified &lt;code&gt;Attribute&lt;/code&gt;
     * @return the element with the specified &lt;code&gt;Attribute&lt;/code&gt;
     *          and the specified &lt;code&gt;value&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
     *          if it can't be found
     * @see javax.swing.text.html.HTML.Attribute
     */
    private Element getElement(Element e, Object attribute, Object value,
                               boolean searchLeafAttributes) {
        AttributeSet attr = e.getAttributes();

        if (attr != null &amp;&amp; attr.isDefined(attribute)) {
            if (value.equals(attr.getAttribute(attribute))) {
                return e;
            }
        }
        if (!e.isLeaf()) {
            for (int counter = 0, maxCounter = e.getElementCount();
                 counter &lt; maxCounter; counter++) {
                Element retValue = getElement(e.getElement(counter), attribute,
                                              value, searchLeafAttributes);

                if (retValue != null) {
                    return retValue;
                }
            }
        }
        else if (searchLeafAttributes &amp;&amp; attr != null) {
            // For some leaf elements we store the actual attributes inside
            // the AttributeSet of the Element (such as anchors).
            Enumeration names = attr.getAttributeNames();
            if (names != null) {
                while (names.hasMoreElements()) {
                    Object name = names.nextElement();
                    if ((name instanceof HTML.Tag) &amp;&amp;
                        (attr.getAttribute(name) instanceof AttributeSet)) {

                        AttributeSet check = (AttributeSet)attr.
                                             getAttribute(name);
                        if (check.isDefined(attribute) &amp;&amp;
                            value.equals(check.getAttribute(attribute))) {
                            return e;
                        }
                    }
                }
            }
        }
        return null;
    }

    /**
     * Verifies the document has an &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set.
     * If &lt;code&gt;getParser&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;, this will throw an
     * IllegalStateException.
     *
     * @throws IllegalStateException if the document does not have a Parser
     */
    private void verifyParser() {
        if (getParser() == null) {
            throw new IllegalStateException(&quot;No HTMLEditorKit.Parser&quot;);
        }
    }

    /**
     * Installs a default Parser if one has not been installed yet.
     */
    private void installParserIfNecessary() {
        if (getParser() == null) {
            setParser(new HTMLEditorKit().getParser());
        }
    }

    /**
     * Inserts a string of HTML into the document at the given position.
     * &lt;code&gt;parent&lt;/code&gt; is used to identify the location to insert the
     * &lt;code&gt;html&lt;/code&gt;. If &lt;code&gt;parent&lt;/code&gt; is a leaf this can have
     * unexpected results.
     */
    private void insertHTML(Element parent, int offset, String html,
                            boolean wantsTrailingNewline)
                 throws BadLocationException, IOException {
        if (parent != null &amp;&amp; html != null) {
            HTMLEditorKit.Parser parser = getParser();
            if (parser != null) {
                int lastOffset = Math.max(0, offset - 1);
                Element charElement = getCharacterElement(lastOffset);
                Element commonParent = parent;
                int pop = 0;
                int push = 0;

                if (parent.getStartOffset() &gt; lastOffset) {
                    while (commonParent != null &amp;&amp;
                           commonParent.getStartOffset() &gt; lastOffset) {
                        commonParent = commonParent.getParentElement();
                        push++;
                    }
                    if (commonParent == null) {
                        throw new BadLocationException(&quot;No common parent&quot;,
                                                       offset);
                    }
                }
                while (charElement != null &amp;&amp; charElement != commonParent) {
                    pop++;
                    charElement = charElement.getParentElement();
                }
                if (charElement != null) {
                    // Found it, do the insert.
                    HTMLReader reader = new HTMLReader(offset, pop - 1, push,
                                                       null, false, true,
                                                       wantsTrailingNewline);

                    parser.parse(new StringReader(html), reader, true);
                    reader.flush();
                }
            }
        }
    }

    /**
     * Removes child Elements of the passed in Element &lt;code&gt;e&lt;/code&gt;. This
     * will do the necessary cleanup to ensure the element representing the
     * end character is correctly created.
     * &lt;p&gt;This is not a general purpose method, it assumes that &lt;code&gt;e&lt;/code&gt;
     * will still have at least one child after the remove, and it assumes
     * the character at &lt;code&gt;e.getStartOffset() - 1&lt;/code&gt; is a newline and
     * is of length 1.
     */
    private void removeElements(Element e, int index, int count) throws BadLocationException {
        writeLock();
        try {
            int start = e.getElement(index).getStartOffset();
            int end = e.getElement(index + count - 1).getEndOffset();
            if (end &gt; getLength()) {
                removeElementsAtEnd(e, index, count, start, end);
            }
            else {
                removeElements(e, index, count, start, end);
            }
        } finally {
            writeUnlock();
        }
    }

    /**
     * Called to remove child elements of &lt;code&gt;e&lt;/code&gt; when one of the
     * elements to remove is representing the end character.
     * &lt;p&gt;Since the Content will not allow a removal to the end character
     * this will do a remove from &lt;code&gt;start - 1&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;.
     * The end Element(s) will be removed, and the element representing
     * &lt;code&gt;start - 1&lt;/code&gt; to &lt;code&gt;start&lt;/code&gt; will be recreated. This
     * Element has to be recreated as after the content removal its offsets
     * become &lt;code&gt;start - 1&lt;/code&gt; to &lt;code&gt;start - 1&lt;/code&gt;.
     */
    private void removeElementsAtEnd(Element e, int index, int count,
                         int start, int end) throws BadLocationException {
        // index must be &gt; 0 otherwise no insert would have happened.
        boolean isLeaf = (e.getElement(index - 1).isLeaf());
        DefaultDocumentEvent dde = new DefaultDocumentEvent(
                       start - 1, end - start + 1, DocumentEvent.
                       EventType.REMOVE);

        if (isLeaf) {
            Element endE = getCharacterElement(getLength());
            // e.getElement(index - 1) should represent the newline.
            index--;
            if (endE.getParentElement() != e) {
                // The hiearchies don't match, we'll have to manually
                // recreate the leaf at e.getElement(index - 1)
                replace(dde, e, index, ++count, start, end, true, true);
            }
            else {
                // The hierarchies for the end Element and
                // e.getElement(index - 1), match, we can safely remove
                // the Elements and the end content will be aligned
                // appropriately.
                replace(dde, e, index, count, start, end, true, false);
            }
        }
        else {
            // Not a leaf, descend until we find the leaf representing
            // start - 1 and remove it.
            Element newLineE = e.getElement(index - 1);
            while (!newLineE.isLeaf()) {
                newLineE = newLineE.getElement(newLineE.getElementCount() - 1);
            }
            newLineE = newLineE.getParentElement();
            replace(dde, e, index, count, start, end, false, false);
            replace(dde, newLineE, newLineE.getElementCount() - 1, 1, start,
                    end, true, true);
        }
        postRemoveUpdate(dde);
        dde.end();
        fireRemoveUpdate(dde);
        fireUndoableEditUpdate(new UndoableEditEvent(this, dde));
    }

    /**
     * This is used by &lt;code&gt;removeElementsAtEnd&lt;/code&gt;, it removes
     * &lt;code&gt;count&lt;/code&gt; elements starting at &lt;code&gt;start&lt;/code&gt; from
     * &lt;code&gt;e&lt;/code&gt;.  If &lt;code&gt;remove&lt;/code&gt; is true text of length
     * &lt;code&gt;start - 1&lt;/code&gt; to &lt;code&gt;end - 1&lt;/code&gt; is removed.  If
     * &lt;code&gt;create&lt;/code&gt; is true a new leaf is created of length 1.
     */
    private void replace(DefaultDocumentEvent dde, Element e, int index,
                         int count, int start, int end, boolean remove,
                         boolean create) throws BadLocationException {
        Element[] added;
        AttributeSet attrs = e.getElement(index).getAttributes();
        Element[] removed = new Element[count];

        for (int counter = 0; counter &lt; count; counter++) {
            removed[counter] = e.getElement(counter + index);
        }
        if (remove) {
            UndoableEdit u = getContent().remove(start - 1, end - start);
            if (u != null) {
                dde.addEdit(u);
            }
        }
        if (create) {
            added = new Element[1];
            added[0] = createLeafElement(e, attrs, start - 1, start);
        }
        else {
            added = new Element[0];
        }
        dde.addEdit(new ElementEdit(e, index, removed, added));
        ((AbstractDocument.BranchElement)e).replace(
                                             index, removed.length, added);
    }

    /**
     * Called to remove child Elements when the end is not touched.
     */
    private void removeElements(Element e, int index, int count,
                             int start, int end) throws BadLocationException {
        Element[] removed = new Element[count];
        Element[] added = new Element[0];
        for (int counter = 0; counter &lt; count; counter++) {
            removed[counter] = e.getElement(counter + index);
        }
        DefaultDocumentEvent dde = new DefaultDocumentEvent
                (start, end - start, DocumentEvent.EventType.REMOVE);
        ((AbstractDocument.BranchElement)e).replace(index, removed.length,
                                                    added);
        dde.addEdit(new ElementEdit(e, index, removed, added));
        UndoableEdit u = getContent().remove(start, end - start);
        if (u != null) {
            dde.addEdit(u);
        }
        postRemoveUpdate(dde);
        dde.end();
        fireRemoveUpdate(dde);
        if (u != null) {
            fireUndoableEditUpdate(new UndoableEditEvent(this, dde));
        }
    }


    // These two are provided for inner class access. The are named different
    // than the super class as the super class implementations are final.
    void obtainLock() {
        writeLock();
    }

    void releaseLock() {
        writeUnlock();
    }

    //
    // Provided for inner class access.
    //

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.
     *
     * @param e the event
     * @see EventListenerList
     */
    protected void fireChangedUpdate(DocumentEvent e) {
        super.fireChangedUpdate(e);
    }

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.
     *
     * @param e the event
     * @see EventListenerList
     */
    protected void fireUndoableEditUpdate(UndoableEditEvent e) {
        super.fireUndoableEditUpdate(e);
    }

    boolean hasBaseTag() {
        return hasBaseTag;
    }

    String getBaseTarget() {
        return baseTarget;
    }

    /*
     * state defines whether the document is a frame document
     * or not.
     */
    private boolean frameDocument = false;
    private boolean preservesUnknownTags = true;

    /*
     * Used to store button groups for radio buttons in
     * a form.
     */
    private HashMap&lt;String, ButtonGroup&gt; radioButtonGroupsMap;

    /**
     * Document property for the number of tokens to buffer
     * before building an element subtree to represent them.
     */
    static final String TokenThreshold = &quot;token threshold&quot;;

    private static final int MaxThreshold = 10000;

    private static final int StepThreshold = 5;


    /**
     * Document property key value. The value for the key will be a Vector
     * of Strings that are comments not found in the body.
     */
    public static final String AdditionalComments = &quot;AdditionalComments&quot;;

    /**
     * Document property key value. The value for the key will be a
     * String indicating the default type of stylesheet links.
     */
    /* public */ static final String StyleType = &quot;StyleType&quot;;

    /**
     * The location to resolve relative URLs against.  By
     * default this will be the document's URL if the document
     * was loaded from a URL.  If a base tag is found and
     * can be parsed, it will be used as the base location.
     */
    URL base;

    /**
     * does the document have base tag
     */
    boolean hasBaseTag = false;

    /**
     * BASE tag's TARGET attribute value
     */
    private String baseTarget = null;

    /**
     * The parser that is used when inserting html into the existing
     * document.
     */
    private HTMLEditorKit.Parser parser;

    /**
     * Used for inserts when a null AttributeSet is supplied.
     */
    private static AttributeSet contentAttributeSet;

    /**
     * Property Maps are registered under, will be a Hashtable.
     */
    static String MAP_PROPERTY = &quot;__MAP__&quot;;

    private static char[] NEWLINE;

    /**
     * I18N property key.
     *
     * @see AbstractDocument#I18NProperty
     */
    private static final String I18NProperty = &quot;i18n&quot;;

    static {
        contentAttributeSet = new SimpleAttributeSet();
        ((MutableAttributeSet)contentAttributeSet).
                        addAttribute(StyleConstants.NameAttribute,
                                     HTML.Tag.CONTENT);
        NEWLINE = new char[1];
        NEWLINE[0] = '\n';
    }


    /**
     * An iterator to iterate over a particular type of
     * tag.  The iterator is not thread safe.  If reliable
     * access to the document is not already ensured by
     * the context under which the iterator is being used,
     * its use should be performed under the protection of
     * Document.render.
     */
    public static abstract class Iterator {

        /**
         * Return the attributes for this tag.
         * @return the &lt;code&gt;AttributeSet&lt;/code&gt; for this tag, or
         *      &lt;code&gt;null&lt;/code&gt; if none can be found
         */
        public abstract AttributeSet getAttributes();

        /**
         * Returns the start of the range for which the current occurrence of
         * the tag is defined and has the same attributes.
         *
         * @return the start of the range, or -1 if it can't be found
         */
        public abstract int getStartOffset();

        /**
         * Returns the end of the range for which the current occurrence of
         * the tag is defined and has the same attributes.
         *
         * @return the end of the range
         */
        public abstract int getEndOffset();

        /**
         * Move the iterator forward to the next occurrence
         * of the tag it represents.
         */
        public abstract void next();

        /**
         * Indicates if the iterator is currently
         * representing an occurrence of a tag.  If
         * false there are no more tags for this iterator.
         * @return true if the iterator is currently representing an
         *              occurrence of a tag, otherwise returns false
         */
        public abstract boolean isValid();

        /**
         * Type of tag this iterator represents.
         */
        public abstract HTML.Tag getTag();
    }

    /**
     * An iterator to iterate over a particular type of tag.
     */
    static class LeafIterator extends Iterator {

        LeafIterator(HTML.Tag t, Document doc) {
            tag = t;
            pos = new ElementIterator(doc);
            endOffset = 0;
            next();
        }

        /**
         * Returns the attributes for this tag.
         * @return the &lt;code&gt;AttributeSet&lt;/code&gt; for this tag,
         *              or &lt;code&gt;null&lt;/code&gt; if none can be found
         */
        public AttributeSet getAttributes() {
            Element elem = pos.current();
            if (elem != null) {
                AttributeSet a = (AttributeSet)
                    elem.getAttributes().getAttribute(tag);
                if (a == null) {
                    a = elem.getAttributes();
                }
                return a;
            }
            return null;
        }

        /**
         * Returns the start of the range for which the current occurrence of
         * the tag is defined and has the same attributes.
         *
         * @return the start of the range, or -1 if it can't be found
         */
        public int getStartOffset() {
            Element elem = pos.current();
            if (elem != null) {
                return elem.getStartOffset();
            }
            return -1;
        }

        /**
         * Returns the end of the range for which the current occurrence of
         * the tag is defined and has the same attributes.
         *
         * @return the end of the range
         */
        public int getEndOffset() {
            return endOffset;
        }

        /**
         * Moves the iterator forward to the next occurrence
         * of the tag it represents.
         */
        public void next() {
            for (nextLeaf(pos); isValid(); nextLeaf(pos)) {
                Element elem = pos.current();
                if (elem.getStartOffset() &gt;= endOffset) {
                    AttributeSet a = pos.current().getAttributes();

                    if (a.isDefined(tag) ||
                        a.getAttribute(StyleConstants.NameAttribute) == tag) {

                        // we found the next one
                        setEndOffset();
                        break;
                    }
                }
            }
        }

        /**
         * Returns the type of tag this iterator represents.
         *
         * @return the &lt;code&gt;HTML.Tag&lt;/code&gt; that this iterator represents.
         * @see javax.swing.text.html.HTML.Tag
         */
        public HTML.Tag getTag() {
            return tag;
        }

        /**
         * Returns true if the current position is not &lt;code&gt;null&lt;/code&gt;.
         * @return true if current position is not &lt;code&gt;null&lt;/code&gt;,
         *              otherwise returns false
         */
        public boolean isValid() {
            return (pos.current() != null);
        }

        /**
         * Moves the given iterator to the next leaf element.
         * @param iter  the iterator to be scanned
         */
        void nextLeaf(ElementIterator iter) {
            for (iter.next(); iter.current() != null; iter.next()) {
                Element e = iter.current();
                if (e.isLeaf()) {
                    break;
                }
            }
        }

        /**
         * Marches a cloned iterator forward to locate the end
         * of the run.  This sets the value of &lt;code&gt;endOffset&lt;/code&gt;.
         */
        void setEndOffset() {
            AttributeSet a0 = getAttributes();
            endOffset = pos.current().getEndOffset();
            ElementIterator fwd = (ElementIterator) pos.clone();
            for (nextLeaf(fwd); fwd.current() != null; nextLeaf(fwd)) {
                Element e = fwd.current();
                AttributeSet a1 = (AttributeSet) e.getAttributes().getAttribute(tag);
                if ((a1 == null) || (! a1.equals(a0))) {
                    break;
                }
                endOffset = e.getEndOffset();
            }
        }

        private int endOffset;
        private HTML.Tag tag;
        private ElementIterator pos;

    }

    /**
     * An HTML reader to load an HTML document with an HTML
     * element structure.  This is a set of callbacks from
     * the parser, implemented to create a set of elements
     * tagged with attributes.  The parse builds up tokens
     * (ElementSpec) that describe the element subtree desired,
     * and burst it into the document under the protection of
     * a write lock using the insert method on the document
     * outer class.
     * &lt;p&gt;
     * The reader can be configured by registering actions
     * (of type &lt;code&gt;HTMLDocument.HTMLReader.TagAction&lt;/code&gt;)
     * that describe how to handle the action.  The idea behind
     * the actions provided is that the most natural text editing
     * operations can be provided if the element structure boils
     * down to paragraphs with runs of some kind of style
     * in them.  Some things are more naturally specified
     * structurally, so arbitrary structure should be allowed
     * above the paragraphs, but will need to be edited with structural
     * actions.  The implication of this is that some of the
     * HTML elements specified in the stream being parsed will
     * be collapsed into attributes, and in some cases paragraphs
     * will be synthesized.  When HTML elements have been
     * converted to attributes, the attribute key will be of
     * type HTML.Tag, and the value will be of type AttributeSet
     * so that no information is lost.  This enables many of the
     * existing actions to work so that the user can type input,
     * hit the return key, backspace, delete, etc and have a
     * reasonable result.  Selections can be created, and attributes
     * applied or removed, etc.  With this in mind, the work done
     * by the reader can be categorized into the following kinds
     * of tasks:
     * &lt;dl&gt;
     * &lt;dt&gt;Block
     * &lt;dd&gt;Build the structure like it's specified in the stream.
     * This produces elements that contain other elements.
     * &lt;dt&gt;Paragraph
     * &lt;dd&gt;Like block except that it's expected that the element
     * will be used with a paragraph view so a paragraph element
     * won't need to be synthesized.
     * &lt;dt&gt;Character
     * &lt;dd&gt;Contribute the element as an attribute that will start
     * and stop at arbitrary text locations.  This will ultimately
     * be mixed into a run of text, with all of the currently
     * flattened HTML character elements.
     * &lt;dt&gt;Special
     * &lt;dd&gt;Produce an embedded graphical element.
     * &lt;dt&gt;Form
     * &lt;dd&gt;Produce an element that is like the embedded graphical
     * element, except that it also has a component model associated
     * with it.
     * &lt;dt&gt;Hidden
     * &lt;dd&gt;Create an element that is hidden from view when the
     * document is being viewed read-only, and visible when the
     * document is being edited.  This is useful to keep the
     * model from losing information, and used to store things
     * like comments and unrecognized tags.
     *
     * &lt;/dl&gt;
     * &lt;p&gt;
     * Currently, &amp;lt;APPLET&amp;gt;, &amp;lt;PARAM&amp;gt;, &amp;lt;MAP&amp;gt;, &amp;lt;AREA&amp;gt;, &amp;lt;LINK&amp;gt;,
     * &amp;lt;SCRIPT&amp;gt; and &amp;lt;STYLE&amp;gt; are unsupported.
     *
     * &lt;p&gt;
     * The assignment of the actions described is shown in the
     * following table for the tags defined in &lt;code&gt;HTML.Tag&lt;/code&gt;.
     * &lt;table border=1 summary=&quot;HTML tags and assigned actions&quot;&gt;
     * &lt;tr&gt;&lt;th&gt;Tag&lt;/th&gt;&lt;th&gt;Action&lt;/th&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.A&lt;/code&gt;         &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.ADDRESS&lt;/code&gt;   &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.APPLET&lt;/code&gt;    &lt;td&gt;HiddenAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.AREA&lt;/code&gt;      &lt;td&gt;AreaAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.B&lt;/code&gt;         &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.BASE&lt;/code&gt;      &lt;td&gt;BaseAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.BASEFONT&lt;/code&gt;  &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.BIG&lt;/code&gt;       &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.BLOCKQUOTE&lt;/code&gt;&lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.BODY&lt;/code&gt;      &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.BR&lt;/code&gt;        &lt;td&gt;SpecialAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.CAPTION&lt;/code&gt;   &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.CENTER&lt;/code&gt;    &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.CITE&lt;/code&gt;      &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.CODE&lt;/code&gt;      &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.DD&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.DFN&lt;/code&gt;       &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.DIR&lt;/code&gt;       &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.DIV&lt;/code&gt;       &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.DL&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.DT&lt;/code&gt;        &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.EM&lt;/code&gt;        &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.FONT&lt;/code&gt;      &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.FORM&lt;/code&gt;      &lt;td&gt;As of 1.4 a BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.FRAME&lt;/code&gt;     &lt;td&gt;SpecialAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.FRAMESET&lt;/code&gt;  &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.H1&lt;/code&gt;        &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.H2&lt;/code&gt;        &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.H3&lt;/code&gt;        &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.H4&lt;/code&gt;        &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.H5&lt;/code&gt;        &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.H6&lt;/code&gt;        &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.HEAD&lt;/code&gt;      &lt;td&gt;HeadAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.HR&lt;/code&gt;        &lt;td&gt;SpecialAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.HTML&lt;/code&gt;      &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.I&lt;/code&gt;         &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.IMG&lt;/code&gt;       &lt;td&gt;SpecialAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.INPUT&lt;/code&gt;     &lt;td&gt;FormAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.ISINDEX&lt;/code&gt;   &lt;td&gt;IsndexAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.KBD&lt;/code&gt;       &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.LI&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.LINK&lt;/code&gt;      &lt;td&gt;LinkAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.MAP&lt;/code&gt;       &lt;td&gt;MapAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.MENU&lt;/code&gt;      &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.META&lt;/code&gt;      &lt;td&gt;MetaAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.NOFRAMES&lt;/code&gt;  &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.OBJECT&lt;/code&gt;    &lt;td&gt;SpecialAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.OL&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.OPTION&lt;/code&gt;    &lt;td&gt;FormAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.P&lt;/code&gt;         &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.PARAM&lt;/code&gt;     &lt;td&gt;HiddenAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.PRE&lt;/code&gt;       &lt;td&gt;PreAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.SAMP&lt;/code&gt;      &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.SCRIPT&lt;/code&gt;    &lt;td&gt;HiddenAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.SELECT&lt;/code&gt;    &lt;td&gt;FormAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.SMALL&lt;/code&gt;     &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.STRIKE&lt;/code&gt;    &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.S&lt;/code&gt;         &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.STRONG&lt;/code&gt;    &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.STYLE&lt;/code&gt;     &lt;td&gt;StyleAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.SUB&lt;/code&gt;       &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.SUP&lt;/code&gt;       &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.TABLE&lt;/code&gt;     &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.TD&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.TEXTAREA&lt;/code&gt;  &lt;td&gt;FormAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.TH&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.TITLE&lt;/code&gt;     &lt;td&gt;TitleAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.TR&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.TT&lt;/code&gt;        &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.U&lt;/code&gt;         &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.UL&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.VAR&lt;/code&gt;       &lt;td&gt;CharacterAction
     * &lt;/table&gt;
     * &lt;p&gt;
     * Once &amp;lt;/html&amp;gt; is encountered, the Actions are no longer notified.
     */
    public class HTMLReader extends HTMLEditorKit.ParserCallback {

        public HTMLReader(int offset) {
            this(offset, 0, 0, null);
        }

        public HTMLReader(int offset, int popDepth, int pushDepth,
                          HTML.Tag insertTag) {
            this(offset, popDepth, pushDepth, insertTag, true, false, true);
        }

        /**
         * Generates a RuntimeException (will eventually generate
         * a BadLocationException when API changes are alloced) if inserting
         * into non empty document, &lt;code&gt;insertTag&lt;/code&gt; is
         * non-&lt;code&gt;null&lt;/code&gt;, and &lt;code&gt;offset&lt;/code&gt; is not in the body.
         */
        // PENDING(sky): Add throws BadLocationException and remove
        // RuntimeException
        HTMLReader(int offset, int popDepth, int pushDepth,
                   HTML.Tag insertTag, boolean insertInsertTag,
                   boolean insertAfterImplied, boolean wantsTrailingNewline) {
            emptyDocument = (getLength() == 0);
            isStyleCSS = &quot;text/css&quot;.equals(getDefaultStyleSheetType());
            this.offset = offset;
            threshold = HTMLDocument.this.getTokenThreshold();
            tagMap = new Hashtable&lt;HTML.Tag, TagAction&gt;(57);
            TagAction na = new TagAction();
            TagAction ba = new BlockAction();
            TagAction pa = new ParagraphAction();
            TagAction ca = new CharacterAction();
            TagAction sa = new SpecialAction();
            TagAction fa = new FormAction();
            TagAction ha = new HiddenAction();
            TagAction conv = new ConvertAction();

            // register handlers for the well known tags
            tagMap.put(HTML.Tag.A, new AnchorAction());
            tagMap.put(HTML.Tag.ADDRESS, ca);
            tagMap.put(HTML.Tag.APPLET, ha);
            tagMap.put(HTML.Tag.AREA, new AreaAction());
            tagMap.put(HTML.Tag.B, conv);
            tagMap.put(HTML.Tag.BASE, new BaseAction());
            tagMap.put(HTML.Tag.BASEFONT, ca);
            tagMap.put(HTML.Tag.BIG, ca);
            tagMap.put(HTML.Tag.BLOCKQUOTE, ba);
            tagMap.put(HTML.Tag.BODY, ba);
            tagMap.put(HTML.Tag.BR, sa);
            tagMap.put(HTML.Tag.CAPTION, ba);
            tagMap.put(HTML.Tag.CENTER, ba);
            tagMap.put(HTML.Tag.CITE, ca);
            tagMap.put(HTML.Tag.CODE, ca);
            tagMap.put(HTML.Tag.DD, ba);
            tagMap.put(HTML.Tag.DFN, ca);
            tagMap.put(HTML.Tag.DIR, ba);
            tagMap.put(HTML.Tag.DIV, ba);
            tagMap.put(HTML.Tag.DL, ba);
            tagMap.put(HTML.Tag.DT, pa);
            tagMap.put(HTML.Tag.EM, ca);
            tagMap.put(HTML.Tag.FONT, conv);
            tagMap.put(HTML.Tag.FORM, new FormTagAction());
            tagMap.put(HTML.Tag.FRAME, sa);
            tagMap.put(HTML.Tag.FRAMESET, ba);
            tagMap.put(HTML.Tag.H1, pa);
            tagMap.put(HTML.Tag.H2, pa);
            tagMap.put(HTML.Tag.H3, pa);
            tagMap.put(HTML.Tag.H4, pa);
            tagMap.put(HTML.Tag.H5, pa);
            tagMap.put(HTML.Tag.H6, pa);
            tagMap.put(HTML.Tag.HEAD, new HeadAction());
            tagMap.put(HTML.Tag.HR, sa);
            tagMap.put(HTML.Tag.HTML, ba);
            tagMap.put(HTML.Tag.I, conv);
            tagMap.put(HTML.Tag.IMG, sa);
            tagMap.put(HTML.Tag.INPUT, fa);
            tagMap.put(HTML.Tag.ISINDEX, new IsindexAction());
            tagMap.put(HTML.Tag.KBD, ca);
            tagMap.put(HTML.Tag.LI, ba);
            tagMap.put(HTML.Tag.LINK, new LinkAction());
            tagMap.put(HTML.Tag.MAP, new MapAction());
            tagMap.put(HTML.Tag.MENU, ba);
            tagMap.put(HTML.Tag.META, new MetaAction());
            tagMap.put(HTML.Tag.NOBR, ca);
            tagMap.put(HTML.Tag.NOFRAMES, ba);
            tagMap.put(HTML.Tag.OBJECT, sa);
            tagMap.put(HTML.Tag.OL, ba);
            tagMap.put(HTML.Tag.OPTION, fa);
            tagMap.put(HTML.Tag.P, pa);
            tagMap.put(HTML.Tag.PARAM, new ObjectAction());
            tagMap.put(HTML.Tag.PRE, new PreAction());
            tagMap.put(HTML.Tag.SAMP, ca);
            tagMap.put(HTML.Tag.SCRIPT, ha);
            tagMap.put(HTML.Tag.SELECT, fa);
            tagMap.put(HTML.Tag.SMALL, ca);
            tagMap.put(HTML.Tag.SPAN, ca);
            tagMap.put(HTML.Tag.STRIKE, conv);
            tagMap.put(HTML.Tag.S, ca);
            tagMap.put(HTML.Tag.STRONG, ca);
            tagMap.put(HTML.Tag.STYLE, new StyleAction());
            tagMap.put(HTML.Tag.SUB, conv);
            tagMap.put(HTML.Tag.SUP, conv);
            tagMap.put(HTML.Tag.TABLE, ba);
            tagMap.put(HTML.Tag.TD, ba);
            tagMap.put(HTML.Tag.TEXTAREA, fa);
            tagMap.put(HTML.Tag.TH, ba);
            tagMap.put(HTML.Tag.TITLE, new TitleAction());
            tagMap.put(HTML.Tag.TR, ba);
            tagMap.put(HTML.Tag.TT, ca);
            tagMap.put(HTML.Tag.U, conv);
            tagMap.put(HTML.Tag.UL, ba);
            tagMap.put(HTML.Tag.VAR, ca);

            if (insertTag != null) {
                this.insertTag = insertTag;
                this.popDepth = popDepth;
                this.pushDepth = pushDepth;
                this.insertInsertTag = insertInsertTag;
                foundInsertTag = false;
            }
            else {
                foundInsertTag = true;
            }
            if (insertAfterImplied) {
                this.popDepth = popDepth;
                this.pushDepth = pushDepth;
                this.insertAfterImplied = true;
                foundInsertTag = false;
                midInsert = false;
                this.insertInsertTag = true;
                this.wantsTrailingNewline = wantsTrailingNewline;
            }
            else {
                midInsert = (!emptyDocument &amp;&amp; insertTag == null);
                if (midInsert) {
                    generateEndsSpecsForMidInsert();
                }
            }

            /**
             * This block initializes the &lt;code&gt;inParagraph&lt;/code&gt; flag.
             * It is left in &lt;code&gt;false&lt;/code&gt; value automatically
             * if the target document is empty or future inserts
             * were positioned into the 'body' tag.
             */
            if (!emptyDocument &amp;&amp; !midInsert) {
                int targetOffset = Math.max(this.offset - 1, 0);
                Element elem =
                        HTMLDocument.this.getCharacterElement(targetOffset);
                /* Going up by the left document structure path */
                for (int i = 0; i &lt;= this.popDepth; i++) {
                    elem = elem.getParentElement();
                }
                /* Going down by the right document structure path */
                for (int i = 0; i &lt; this.pushDepth; i++) {
                    int index = elem.getElementIndex(this.offset);
                    elem = elem.getElement(index);
                }
                AttributeSet attrs = elem.getAttributes();
                if (attrs != null) {
                    HTML.Tag tagToInsertInto =
                            (HTML.Tag) attrs.getAttribute(StyleConstants.NameAttribute);
                    if (tagToInsertInto != null) {
                        this.inParagraph = tagToInsertInto.isParagraph();
                    }
                }
            }
        }

        /**
         * Generates an initial batch of end &lt;code&gt;ElementSpecs&lt;/code&gt;
         * in parseBuffer to position future inserts into the body.
         */
        private void generateEndsSpecsForMidInsert() {
            int           count = heightToElementWithName(HTML.Tag.BODY,
                                                   Math.max(0, offset - 1));
            boolean       joinNext = false;

            if (count == -1 &amp;&amp; offset &gt; 0) {
                count = heightToElementWithName(HTML.Tag.BODY, offset);
                if (count != -1) {
                    // Previous isn't in body, but current is. Have to
                    // do some end specs, followed by join next.
                    count = depthTo(offset - 1) - 1;
                    joinNext = true;
                }
            }
            if (count == -1) {
                throw new RuntimeException(&quot;Must insert new content into body element-&quot;);
            }
            if (count != -1) {
                // Insert a newline, if necessary.
                try {
                    if (!joinNext &amp;&amp; offset &gt; 0 &amp;&amp;
                        !getText(offset - 1, 1).equals(&quot;\n&quot;)) {
                        SimpleAttributeSet newAttrs = new SimpleAttributeSet();
                        newAttrs.addAttribute(StyleConstants.NameAttribute,
                                              HTML.Tag.CONTENT);
                        ElementSpec spec = new ElementSpec(newAttrs,
                                    ElementSpec.ContentType, NEWLINE, 0, 1);
                        parseBuffer.addElement(spec);
                    }
                    // Should never throw, but will catch anyway.
                } catch (BadLocationException ble) {}
                while (count-- &gt; 0) {
                    parseBuffer.addElement(new ElementSpec
                                           (null, ElementSpec.EndTagType));
                }
                if (joinNext) {
                    ElementSpec spec = new ElementSpec(null, ElementSpec.
                                                       StartTagType);

                    spec.setDirection(ElementSpec.JoinNextDirection);
                    parseBuffer.addElement(spec);
                }
            }
            // We should probably throw an exception if (count == -1)
            // Or look for the body and reset the offset.
        }

        /**
         * @return number of parents to reach the child at offset.
         */
        private int depthTo(int offset) {
            Element       e = getDefaultRootElement();
            int           count = 0;

            while (!e.isLeaf()) {
                count++;
                e = e.getElement(e.getElementIndex(offset));
            }
            return count;
        }

        /**
         * @return number of parents of the leaf at &lt;code&gt;offset&lt;/code&gt;
         *         until a parent with name, &lt;code&gt;name&lt;/code&gt; has been
         *         found. -1 indicates no matching parent with
         *         &lt;code&gt;name&lt;/code&gt;.
         */
        private int heightToElementWithName(Object name, int offset) {
            Element       e = getCharacterElement(offset).getParentElement();
            int           count = 0;

            while (e != null &amp;&amp; e.getAttributes().getAttribute
                   (StyleConstants.NameAttribute) != name) {
                count++;
                e = e.getParentElement();
            }
            return (e == null) ? -1 : count;
        }

        /**
         * This will make sure there aren't two BODYs (the second is
         * typically created when you do a remove all, and then an insert).
         */
        private void adjustEndElement() {
            int length = getLength();
            if (length == 0) {
                return;
            }
            obtainLock();
            try {
                Element[] pPath = getPathTo(length - 1);
                int pLength = pPath.length;
                if (pLength &gt; 1 &amp;&amp; pPath[1].getAttributes().getAttribute
                         (StyleConstants.NameAttribute) == HTML.Tag.BODY &amp;&amp;
                         pPath[1].getEndOffset() == length) {
                    String lastText = getText(length - 1, 1);
                    DefaultDocumentEvent event;
                    Element[] added;
                    Element[] removed;
                    int index;
                    // Remove the fake second body.
                    added = new Element[0];
                    removed = new Element[1];
                    index = pPath[0].getElementIndex(length);
                    removed[0] = pPath[0].getElement(index);
                    ((BranchElement)pPath[0]).replace(index, 1, added);
                    ElementEdit firstEdit = new ElementEdit(pPath[0], index,
                                                            removed, added);

                    // Insert a new element to represent the end that the
                    // second body was representing.
                    SimpleAttributeSet sas = new SimpleAttributeSet();
                    sas.addAttribute(StyleConstants.NameAttribute,
                                         HTML.Tag.CONTENT);
                    sas.addAttribute(IMPLIED_CR, Boolean.TRUE);
                    added = new Element[1];
                    added[0] = createLeafElement(pPath[pLength - 1],
                                                     sas, length, length + 1);
                    index = pPath[pLength - 1].getElementCount();
                    ((BranchElement)pPath[pLength - 1]).replace(index, 0,
                                                                added);
                    event = new DefaultDocumentEvent(length, 1,
                                            DocumentEvent.EventType.CHANGE);
                    event.addEdit(new ElementEdit(pPath[pLength - 1],
                                         index, new Element[0], added));
                    event.addEdit(firstEdit);
                    event.end();
                    fireChangedUpdate(event);
                    fireUndoableEditUpdate(new UndoableEditEvent(this, event));

                    if (lastText.equals(&quot;\n&quot;)) {
                        // We now have two \n's, one part of the Document.
                        // We need to remove one
                        event = new DefaultDocumentEvent(length - 1, 1,
                                           DocumentEvent.EventType.REMOVE);
                        removeUpdate(event);
                        UndoableEdit u = getContent().remove(length - 1, 1);
                        if (u != null) {
                            event.addEdit(u);
                        }
                        postRemoveUpdate(event);
                        // Mark the edit as done.
                        event.end();
                        fireRemoveUpdate(event);
                        fireUndoableEditUpdate(new UndoableEditEvent(
                                               this, event));
                    }
                }
            }
            catch (BadLocationException ble) {
            }
            finally {
                releaseLock();
            }
        }

        private Element[] getPathTo(int offset) {
            Stack&lt;Element&gt; elements = new Stack&lt;Element&gt;();
            Element e = getDefaultRootElement();
            int index;
            while (!e.isLeaf()) {
                elements.push(e);
                e = e.getElement(e.getElementIndex(offset));
            }
            Element[] retValue = new Element[elements.size()];
            elements.copyInto(retValue);
            return retValue;
        }

        // -- HTMLEditorKit.ParserCallback methods --------------------

        /**
         * The last method called on the reader.  It allows
         * any pending changes to be flushed into the document.
         * Since this is currently loading synchronously, the entire
         * set of changes are pushed in at this point.
         */
        public void flush() throws BadLocationException {
            if (emptyDocument &amp;&amp; !insertAfterImplied) {
                if (HTMLDocument.this.getLength() &gt; 0 ||
                                      parseBuffer.size() &gt; 0) {
                    flushBuffer(true);
                    adjustEndElement();
                }
                // We won't insert when
            }
            else {
                flushBuffer(true);
            }
        }

        /**
         * Called by the parser to indicate a block of text was
         * encountered.
         */
        public void handleText(char[] data, int pos) {
            if (receivedEndHTML || (midInsert &amp;&amp; !inBody)) {
                return;
            }

            // see if complex glyph layout support is needed
            if(HTMLDocument.this.getProperty(I18NProperty).equals( Boolean.FALSE ) ) {
                // if a default direction of right-to-left has been specified,
                // we want complex layout even if the text is all left to right.
                Object d = getProperty(TextAttribute.RUN_DIRECTION);
                if ((d != null) &amp;&amp; (d.equals(TextAttribute.RUN_DIRECTION_RTL))) {
                    HTMLDocument.this.putProperty( I18NProperty, Boolean.TRUE);
                } else {
                    if (SwingUtilities2.isComplexLayout(data, 0, data.length)) {
                        HTMLDocument.this.putProperty( I18NProperty, Boolean.TRUE);
                    }
                }
            }

            if (inTextArea) {
                textAreaContent(data);
            } else if (inPre) {
                preContent(data);
            } else if (inTitle) {
                putProperty(Document.TitleProperty, new String(data));
            } else if (option != null) {
                option.setLabel(new String(data));
            } else if (inStyle) {
                if (styles != null) {
                    styles.addElement(new String(data));
                }
            } else if (inBlock &gt; 0) {
                if (!foundInsertTag &amp;&amp; insertAfterImplied) {
                    // Assume content should be added.
                    foundInsertTag(false);
                    foundInsertTag = true;
                    inParagraph = impliedP = true;
                }
                if (data.length &gt;= 1) {
                    addContent(data, 0, data.length);
                }
            }
        }

        /**
         * Callback from the parser.  Route to the appropriate
         * handler for the tag.
         */
        public void handleStartTag(HTML.Tag t, MutableAttributeSet a, int pos) {
            if (receivedEndHTML) {
                return;
            }
            if (midInsert &amp;&amp; !inBody) {
                if (t == HTML.Tag.BODY) {
                    inBody = true;
                    // Increment inBlock since we know we are in the body,
                    // this is needed incase an implied-p is needed. If
                    // inBlock isn't incremented, and an implied-p is
                    // encountered, addContent won't be called!
                    inBlock++;
                }
                return;
            }
            if (!inBody &amp;&amp; t == HTML.Tag.BODY) {
                inBody = true;
            }
            if (isStyleCSS &amp;&amp; a.isDefined(HTML.Attribute.STYLE)) {
                // Map the style attributes.
                String decl = (String)a.getAttribute(HTML.Attribute.STYLE);
                a.removeAttribute(HTML.Attribute.STYLE);
                styleAttributes = getStyleSheet().getDeclaration(decl);
                a.addAttributes(styleAttributes);
            }
            else {
                styleAttributes = null;
            }
            TagAction action = tagMap.get(t);

            if (action != null) {
                action.start(t, a);
            }
        }

        public void handleComment(char[] data, int pos) {
            if (receivedEndHTML) {
                addExternalComment(new String(data));
                return;
            }
            if (inStyle) {
                if (styles != null) {
                    styles.addElement(new String(data));
                }
            }
            else if (getPreservesUnknownTags()) {
                if (inBlock == 0 &amp;&amp; (foundInsertTag ||
                                     insertTag != HTML.Tag.COMMENT)) {
                    // Comment outside of body, will not be able to show it,
                    // but can add it as a property on the Document.
                    addExternalComment(new String(data));
                    return;
                }
                SimpleAttributeSet sas = new SimpleAttributeSet();
                sas.addAttribute(HTML.Attribute.COMMENT, new String(data));
                addSpecialElement(HTML.Tag.COMMENT, sas);
            }

            TagAction action = tagMap.get(HTML.Tag.COMMENT);
            if (action != null) {
                action.start(HTML.Tag.COMMENT, new SimpleAttributeSet());
                action.end(HTML.Tag.COMMENT);
            }
        }

        /**
         * Adds the comment &lt;code&gt;comment&lt;/code&gt; to the set of comments
         * maintained outside of the scope of elements.
         */
        private void addExternalComment(String comment) {
            Object comments = getProperty(AdditionalComments);
            if (comments != null &amp;&amp; !(comments instanceof Vector)) {
                // No place to put comment.
                return;
            }
            if (comments == null) {
                comments = new Vector();
                putProperty(AdditionalComments, comments);
            }
            ((Vector)comments).addElement(comment);
        }

        /**
         * Callback from the parser.  Route to the appropriate
         * handler for the tag.
         */
        public void handleEndTag(HTML.Tag t, int pos) {
            if (receivedEndHTML || (midInsert &amp;&amp; !inBody)) {
                return;
            }
            if (t == HTML.Tag.HTML) {
                receivedEndHTML = true;
            }
            if (t == HTML.Tag.BODY) {
                inBody = false;
                if (midInsert) {
                    inBlock--;
                }
            }
            TagAction action = tagMap.get(t);
            if (action != null) {
                action.end(t);
            }
        }

        /**
         * Callback from the parser.  Route to the appropriate
         * handler for the tag.
         */
        public void handleSimpleTag(HTML.Tag t, MutableAttributeSet a, int pos) {
            if (receivedEndHTML || (midInsert &amp;&amp; !inBody)) {
                return;
            }

            if (isStyleCSS &amp;&amp; a.isDefined(HTML.Attribute.STYLE)) {
                // Map the style attributes.
                String decl = (String)a.getAttribute(HTML.Attribute.STYLE);
                a.removeAttribute(HTML.Attribute.STYLE);
                styleAttributes = getStyleSheet().getDeclaration(decl);
                a.addAttributes(styleAttributes);
            }
            else {
                styleAttributes = null;
            }

            TagAction action = tagMap.get(t);
            if (action != null) {
                action.start(t, a);
                action.end(t);
            }
            else if (getPreservesUnknownTags()) {
                // unknown tag, only add if should preserve it.
                addSpecialElement(t, a);
            }
        }

        /**
         * This is invoked after the stream has been parsed, but before
         * &lt;code&gt;flush&lt;/code&gt;. &lt;code&gt;eol&lt;/code&gt; will be one of \n, \r
         * or \r\n, which ever is encountered the most in parsing the
         * stream.
         *
         * @since 1.3
         */
        public void handleEndOfLineString(String eol) {
            if (emptyDocument &amp;&amp; eol != null) {
                putProperty(DefaultEditorKit.EndOfLineStringProperty,
                            eol);
            }
        }

        // ---- tag handling support ------------------------------

        /**
         * Registers a handler for the given tag.  By default
         * all of the well-known tags will have been registered.
         * This can be used to change the handling of a particular
         * tag or to add support for custom tags.
         */
        protected void registerTag(HTML.Tag t, TagAction a) {
            tagMap.put(t, a);
        }

        /**
         * An action to be performed in response
         * to parsing a tag.  This allows customization
         * of how each tag is handled and avoids a large
         * switch statement.
         */
        public class TagAction {

            /**
             * Called when a start tag is seen for the
             * type of tag this action was registered
             * to.  The tag argument indicates the actual
             * tag for those actions that are shared across
             * many tags.  By default this does nothing and
             * completely ignores the tag.
             */
            public void start(HTML.Tag t, MutableAttributeSet a) {
            }

            /**
             * Called when an end tag is seen for the
             * type of tag this action was registered
             * to.  The tag argument indicates the actual
             * tag for those actions that are shared across
             * many tags.  By default this does nothing and
             * completely ignores the tag.
             */
            public void end(HTML.Tag t) {
            }

        }

        public class BlockAction extends TagAction {

            public void start(HTML.Tag t, MutableAttributeSet attr) {
                blockOpen(t, attr);
            }

            public void end(HTML.Tag t) {
                blockClose(t);
            }
        }


        /**
         * Action used for the actual element form tag. This is named such
         * as there was already a public class named FormAction.
         */
        private class FormTagAction extends BlockAction {
            public void start(HTML.Tag t, MutableAttributeSet attr) {
                super.start(t, attr);
                // initialize a ButtonGroupsMap when
                // FORM tag is encountered.  This will
                // be used for any radio buttons that
                // might be defined in the FORM.
                // for new group new ButtonGroup will be created (fix for 4529702)
                // group name is a key in radioButtonGroupsMap
                radioButtonGroupsMap = new HashMap&lt;String, ButtonGroup&gt;();
            }

            public void end(HTML.Tag t) {
                super.end(t);
                // reset the button group to null since
                // the form has ended.
                radioButtonGroupsMap = null;
            }
        }


        public class ParagraphAction extends BlockAction {

            public void start(HTML.Tag t, MutableAttributeSet a) {
                super.start(t, a);
                inParagraph = true;
            }

            public void end(HTML.Tag t) {
                super.end(t);
                inParagraph = false;
            }
        }

        public class SpecialAction extends TagAction {

            public void start(HTML.Tag t, MutableAttributeSet a) {
                addSpecialElement(t, a);
            }

        }

        public class IsindexAction extends TagAction {

            public void start(HTML.Tag t, MutableAttributeSet a) {
                blockOpen(HTML.Tag.IMPLIED, new SimpleAttributeSet());
                addSpecialElement(t, a);
                blockClose(HTML.Tag.IMPLIED);
            }

        }


        public class HiddenAction extends TagAction {

            public void start(HTML.Tag t, MutableAttributeSet a) {
                addSpecialElement(t, a);
            }

            public void end(HTML.Tag t) {
                if (!isEmpty(t)) {
                    MutableAttributeSet a = new SimpleAttributeSet();
                    a.addAttribute(HTML.Attribute.ENDTAG, &quot;true&quot;);
                    addSpecialElement(t, a);
                }
            }

            boolean isEmpty(HTML.Tag t) {
                if (t == HTML.Tag.APPLET ||
                    t == HTML.Tag.SCRIPT) {
                    return false;
                }
                return true;
            }
        }


        /**
         * Subclass of HiddenAction to set the content type for style sheets,
         * and to set the name of the default style sheet.
         */
        class MetaAction extends HiddenAction {

            public void start(HTML.Tag t, MutableAttributeSet a) {
                Object equiv = a.getAttribute(HTML.Attribute.HTTPEQUIV);
                if (equiv != null) {
                    equiv = ((String)equiv).toLowerCase();
                    if (equiv.equals(&quot;content-style-type&quot;)) {
                        String value = (String)a.getAttribute
                                       (HTML.Attribute.CONTENT);
                        setDefaultStyleSheetType(value);
                        isStyleCSS = &quot;text/css&quot;.equals
                                      (getDefaultStyleSheetType());
                    }
                    else if (equiv.equals(&quot;default-style&quot;)) {
                        defaultStyle = (String)a.getAttribute
                                       (HTML.Attribute.CONTENT);
                    }
                }
                super.start(t, a);
            }

            boolean isEmpty(HTML.Tag t) {
                return true;
            }
        }


        /**
         * End if overridden to create the necessary stylesheets that
         * are referenced via the link tag. It is done in this manner
         * as the meta tag can be used to specify an alternate style sheet,
         * and is not guaranteed to come before the link tags.
         */
        class HeadAction extends BlockAction {

            public void start(HTML.Tag t, MutableAttributeSet a) {
                inHead = true;
                // This check of the insertTag is put in to avoid considering
                // the implied-p that is generated for the head. This allows
                // inserts for HR to work correctly.
                if ((insertTag == null &amp;&amp; !insertAfterImplied) ||
                    (insertTag == HTML.Tag.HEAD) ||
                    (insertAfterImplied &amp;&amp;
                     (foundInsertTag || !a.isDefined(IMPLIED)))) {
                    super.start(t, a);
                }
            }

            public void end(HTML.Tag t) {
                inHead = inStyle = false;
                // See if there is a StyleSheet to link to.
                if (styles != null) {
                    boolean isDefaultCSS = isStyleCSS;
                    for (int counter = 0, maxCounter = styles.size();
                         counter &lt; maxCounter;) {
                        Object value = styles.elementAt(counter);
                        if (value == HTML.Tag.LINK) {
                            handleLink((AttributeSet)styles.
                                       elementAt(++counter));
                            counter++;
                        }
                        else {
                            // Rule.
                            // First element gives type.
                            String type = (String)styles.elementAt(++counter);
                            boolean isCSS = (type == null) ? isDefaultCSS :
                                            type.equals(&quot;text/css&quot;);
                            while (++counter &lt; maxCounter &amp;&amp;
                                   (styles.elementAt(counter)
                                    instanceof String)) {
                                if (isCSS) {
                                    addCSSRules((String)styles.elementAt
                                                (counter));
                                }
                            }
                        }
                    }
                }
                if ((insertTag == null &amp;&amp; !insertAfterImplied) ||
                    insertTag == HTML.Tag.HEAD ||
                    (insertAfterImplied &amp;&amp; foundInsertTag)) {
                    super.end(t);
                }
            }

            boolean isEmpty(HTML.Tag t) {
                return false;
            }

            private void handleLink(AttributeSet attr) {
                // Link.
                String type = (String)attr.getAttribute(HTML.Attribute.TYPE);
                if (type == null) {
                    type = getDefaultStyleSheetType();
                }
                // Only choose if type==text/css
                // Select link if rel==stylesheet.
                // Otherwise if rel==alternate stylesheet and
                //   title matches default style.
                if (type.equals(&quot;text/css&quot;)) {
                    String rel = (String)attr.getAttribute(HTML.Attribute.REL);
                    String title = (String)attr.getAttribute
                                               (HTML.Attribute.TITLE);
                    String media = (String)attr.getAttribute
                                                   (HTML.Attribute.MEDIA);
                    if (media == null) {
                        media = &quot;all&quot;;
                    }
                    else {
                        media = media.toLowerCase();
                    }
                    if (rel != null) {
                        rel = rel.toLowerCase();
                        if ((media.indexOf(&quot;all&quot;) != -1 ||
                             media.indexOf(&quot;screen&quot;) != -1) &amp;&amp;
                            (rel.equals(&quot;stylesheet&quot;) ||
                             (rel.equals(&quot;alternate stylesheet&quot;) &amp;&amp;
                              title.equals(defaultStyle)))) {
                            linkCSSStyleSheet((String)attr.getAttribute
                                              (HTML.Attribute.HREF));
                        }
                    }
                }
            }
        }


        /**
         * A subclass to add the AttributeSet to styles if the
         * attributes contains an attribute for 'rel' with value
         * 'stylesheet' or 'alternate stylesheet'.
         */
        class LinkAction extends HiddenAction {

            public void start(HTML.Tag t, MutableAttributeSet a) {
                String rel = (String)a.getAttribute(HTML.Attribute.REL);
                if (rel != null) {
                    rel = rel.toLowerCase();
                    if (rel.equals(&quot;stylesheet&quot;) ||
                        rel.equals(&quot;alternate stylesheet&quot;)) {
                        if (styles == null) {
                            styles = new Vector&lt;Object&gt;(3);
                        }
                        styles.addElement(t);
                        styles.addElement(a.copyAttributes());
                    }
                }
                super.start(t, a);
            }
        }

        class MapAction extends TagAction {

            public void start(HTML.Tag t, MutableAttributeSet a) {
                lastMap = new Map((String)a.getAttribute(HTML.Attribute.NAME));
                addMap(lastMap);
            }

            public void end(HTML.Tag t) {
            }
        }


        class AreaAction extends TagAction {

            public void start(HTML.Tag t, MutableAttributeSet a) {
                if (lastMap != null) {
                    lastMap.addArea(a.copyAttributes());
                }
            }

            public void end(HTML.Tag t) {
            }
        }


        class StyleAction extends TagAction {

            public void start(HTML.Tag t, MutableAttributeSet a) {
                if (inHead) {
                    if (styles == null) {
                        styles = new Vector&lt;Object&gt;(3);
                    }
                    styles.addElement(t);
                    styles.addElement(a.getAttribute(HTML.Attribute.TYPE));
                    inStyle = true;
                }
            }

            public void end(HTML.Tag t) {
                inStyle = false;
            }

            boolean isEmpty(HTML.Tag t) {
                return false;
            }
        }


        public class PreAction extends BlockAction {

            public void start(HTML.Tag t, MutableAttributeSet attr) {
                inPre = true;
                blockOpen(t, attr);
                attr.addAttribute(CSS.Attribute.WHITE_SPACE, &quot;pre&quot;);
                blockOpen(HTML.Tag.IMPLIED, attr);
            }

            public void end(HTML.Tag t) {
                blockClose(HTML.Tag.IMPLIED);
                // set inPre to false after closing, so that if a newline
                // is added it won't generate a blockOpen.
                inPre = false;
                blockClose(t);
            }
        }

        public class CharacterAction extends TagAction {

            public void start(HTML.Tag t, MutableAttributeSet attr) {
                pushCharacterStyle();
                if (!foundInsertTag) {
                    // Note that the third argument should really be based off
                    // inParagraph and impliedP. If we're wrong (that is
                    // insertTagDepthDelta shouldn't be changed), we'll end up
                    // removing an extra EndSpec, which won't matter anyway.
                    boolean insert = canInsertTag(t, attr, false);
                    if (foundInsertTag) {
                        if (!inParagraph) {
                            inParagraph = impliedP = true;
                        }
                    }
                    if (!insert) {
                        return;
                    }
                }
                if (attr.isDefined(IMPLIED)) {
                    attr.removeAttribute(IMPLIED);
                }
                charAttr.addAttribute(t, attr.copyAttributes());
                if (styleAttributes != null) {
                    charAttr.addAttributes(styleAttributes);
                }
            }

            public void end(HTML.Tag t) {
                popCharacterStyle();
            }
        }

        /**
         * Provides conversion of HTML tag/attribute
         * mappings that have a corresponding StyleConstants
         * and CSS mapping.  The conversion is to CSS attributes.
         */
        class ConvertAction extends TagAction {

            public void start(HTML.Tag t, MutableAttributeSet attr) {
                pushCharacterStyle();
                if (!foundInsertTag) {
                    // Note that the third argument should really be based off
                    // inParagraph and impliedP. If we're wrong (that is
                    // insertTagDepthDelta shouldn't be changed), we'll end up
                    // removing an extra EndSpec, which won't matter anyway.
                    boolean insert = canInsertTag(t, attr, false);
                    if (foundInsertTag) {
                        if (!inParagraph) {
                            inParagraph = impliedP = true;
                        }
                    }
                    if (!insert) {
                        return;
                    }
                }
                if (attr.isDefined(IMPLIED)) {
                    attr.removeAttribute(IMPLIED);
                }
                if (styleAttributes != null) {
                    charAttr.addAttributes(styleAttributes);
                }
                // We also need to add attr, otherwise we lose custom
                // attributes, including class/id for style lookups, and
                // further confuse style lookup (doesn't have tag).
                charAttr.addAttribute(t, attr.copyAttributes());
                StyleSheet sheet = getStyleSheet();
                if (t == HTML.Tag.B) {
                    sheet.addCSSAttribute(charAttr, CSS.Attribute.FONT_WEIGHT, &quot;bold&quot;);
                } else if (t == HTML.Tag.I) {
                    sheet.addCSSAttribute(charAttr, CSS.Attribute.FONT_STYLE, &quot;italic&quot;);
                } else if (t == HTML.Tag.U) {
                    Object v = charAttr.getAttribute(CSS.Attribute.TEXT_DECORATION);
                    String value = &quot;underline&quot;;
                    value = (v != null) ? value + &quot;,&quot; + v.toString() : value;
                    sheet.addCSSAttribute(charAttr, CSS.Attribute.TEXT_DECORATION, value);
                } else if (t == HTML.Tag.STRIKE) {
                    Object v = charAttr.getAttribute(CSS.Attribute.TEXT_DECORATION);
                    String value = &quot;line-through&quot;;
                    value = (v != null) ? value + &quot;,&quot; + v.toString() : value;
                    sheet.addCSSAttribute(charAttr, CSS.Attribute.TEXT_DECORATION, value);
                } else if (t == HTML.Tag.SUP) {
                    Object v = charAttr.getAttribute(CSS.Attribute.VERTICAL_ALIGN);
                    String value = &quot;sup&quot;;
                    value = (v != null) ? value + &quot;,&quot; + v.toString() : value;
                    sheet.addCSSAttribute(charAttr, CSS.Attribute.VERTICAL_ALIGN, value);
                } else if (t == HTML.Tag.SUB) {
                    Object v = charAttr.getAttribute(CSS.Attribute.VERTICAL_ALIGN);
                    String value = &quot;sub&quot;;
                    value = (v != null) ? value + &quot;,&quot; + v.toString() : value;
                    sheet.addCSSAttribute(charAttr, CSS.Attribute.VERTICAL_ALIGN, value);
                } else if (t == HTML.Tag.FONT) {
                    String color = (String) attr.getAttribute(HTML.Attribute.COLOR);
                    if (color != null) {
                        sheet.addCSSAttribute(charAttr, CSS.Attribute.COLOR, color);
                    }
                    String face = (String) attr.getAttribute(HTML.Attribute.FACE);
                    if (face != null) {
                        sheet.addCSSAttribute(charAttr, CSS.Attribute.FONT_FAMILY, face);
                    }
                    String size = (String) attr.getAttribute(HTML.Attribute.SIZE);
                    if (size != null) {
                        sheet.addCSSAttributeFromHTML(charAttr, CSS.Attribute.FONT_SIZE, size);
                    }
                }
            }

            public void end(HTML.Tag t) {
                popCharacterStyle();
            }

        }

        class AnchorAction extends CharacterAction {

            public void start(HTML.Tag t, MutableAttributeSet attr) {
                // set flag to catch empty anchors
                emptyAnchor = true;
                super.start(t, attr);
            }

            public void end(HTML.Tag t) {
                if (emptyAnchor) {
                    // if the anchor was empty it was probably a
                    // named anchor point and we don't want to throw
                    // it away.
                    char[] one = new char[1];
                    one[0] = '\n';
                    addContent(one, 0, 1);
                }
                super.end(t);
            }
        }

        class TitleAction extends HiddenAction {

            public void start(HTML.Tag t, MutableAttributeSet attr) {
                inTitle = true;
                super.start(t, attr);
            }

            public void end(HTML.Tag t) {
                inTitle = false;
                super.end(t);
            }

            boolean isEmpty(HTML.Tag t) {
                return false;
            }
        }


        class BaseAction extends TagAction {

            public void start(HTML.Tag t, MutableAttributeSet attr) {
                String href = (String) attr.getAttribute(HTML.Attribute.HREF);
                if (href != null) {
                    try {
                        URL newBase = new URL(base, href);
                        setBase(newBase);
                        hasBaseTag = true;
                    } catch (MalformedURLException ex) {
                    }
                }
                baseTarget = (String) attr.getAttribute(HTML.Attribute.TARGET);
            }
        }

        class ObjectAction extends SpecialAction {

            public void start(HTML.Tag t, MutableAttributeSet a) {
                if (t == HTML.Tag.PARAM) {
                    addParameter(a);
                } else {
                    super.start(t, a);
                }
            }

            public void end(HTML.Tag t) {
                if (t != HTML.Tag.PARAM) {
                    super.end(t);
                }
            }

            void addParameter(AttributeSet a) {
                String name = (String) a.getAttribute(HTML.Attribute.NAME);
                String value = (String) a.getAttribute(HTML.Attribute.VALUE);
                if ((name != null) &amp;&amp; (value != null)) {
                    ElementSpec objSpec = parseBuffer.lastElement();
                    MutableAttributeSet objAttr = (MutableAttributeSet) objSpec.getAttributes();
                    objAttr.addAttribute(name, value);
                }
            }
        }

        /**
         * Action to support forms by building all of the elements
         * used to represent form controls.  This will process
         * the &amp;lt;INPUT&amp;gt;, &amp;lt;TEXTAREA&amp;gt;, &amp;lt;SELECT&amp;gt;,
         * and &amp;lt;OPTION&amp;gt; tags.  The element created by
         * this action is expected to have the attribute
         * &lt;code&gt;StyleConstants.ModelAttribute&lt;/code&gt; set to
         * the model that holds the state for the form control.
         * This enables multiple views, and allows document to
         * be iterated over picking up the data of the form.
         * The following are the model assignments for the
         * various type of form elements.
         * &lt;table summary=&quot;model assignments for the various types of form elements&quot;&gt;
         * &lt;tr&gt;
         *   &lt;th&gt;Element Type
         *   &lt;th&gt;Model Type
         * &lt;tr&gt;
         *   &lt;td&gt;input, type button
         *   &lt;td&gt;{@link DefaultButtonModel}
         * &lt;tr&gt;
         *   &lt;td&gt;input, type checkbox
         *   &lt;td&gt;{@link javax.swing.JToggleButton.ToggleButtonModel}
         * &lt;tr&gt;
         *   &lt;td&gt;input, type image
         *   &lt;td&gt;{@link DefaultButtonModel}
         * &lt;tr&gt;
         *   &lt;td&gt;input, type password
         *   &lt;td&gt;{@link PlainDocument}
         * &lt;tr&gt;
         *   &lt;td&gt;input, type radio
         *   &lt;td&gt;{@link javax.swing.JToggleButton.ToggleButtonModel}
         * &lt;tr&gt;
         *   &lt;td&gt;input, type reset
         *   &lt;td&gt;{@link DefaultButtonModel}
         * &lt;tr&gt;
         *   &lt;td&gt;input, type submit
         *   &lt;td&gt;{@link DefaultButtonModel}
         * &lt;tr&gt;
         *   &lt;td&gt;input, type text or type is null.
         *   &lt;td&gt;{@link PlainDocument}
         * &lt;tr&gt;
         *   &lt;td&gt;select
         *   &lt;td&gt;{@link DefaultComboBoxModel} or an {@link DefaultListModel}, with an item type of Option
         * &lt;tr&gt;
         *   &lt;td&gt;textarea
         *   &lt;td&gt;{@link PlainDocument}
         * &lt;/table&gt;
         *
         */
        public class FormAction extends SpecialAction {

            public void start(HTML.Tag t, MutableAttributeSet attr) {
                if (t == HTML.Tag.INPUT) {
                    String type = (String)
                        attr.getAttribute(HTML.Attribute.TYPE);
                    /*
                     * if type is not defined the default is
                     * assumed to be text.
                     */
                    if (type == null) {
                        type = &quot;text&quot;;
                        attr.addAttribute(HTML.Attribute.TYPE, &quot;text&quot;);
                    }
                    setModel(type, attr);
                } else if (t == HTML.Tag.TEXTAREA) {
                    inTextArea = true;
                    textAreaDocument = new TextAreaDocument();
                    attr.addAttribute(StyleConstants.ModelAttribute,
                                      textAreaDocument);
                } else if (t == HTML.Tag.SELECT) {
                    int size = HTML.getIntegerAttributeValue(attr,
                                                             HTML.Attribute.SIZE,
                                                             1);
                    boolean multiple = attr.getAttribute(HTML.Attribute.MULTIPLE) != null;
                    if ((size &gt; 1) || multiple) {
                        OptionListModel&lt;Option&gt; m = new OptionListModel&lt;Option&gt;();
                        if (multiple) {
                            m.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
                        }
                        selectModel = m;
                    } else {
                        selectModel = new OptionComboBoxModel&lt;Option&gt;();
                    }
                    attr.addAttribute(StyleConstants.ModelAttribute,
                                      selectModel);

                }

                // build the element, unless this is an option.
                if (t == HTML.Tag.OPTION) {
                    option = new Option(attr);

                    if (selectModel instanceof OptionListModel) {
                        OptionListModel&lt;Option&gt; m = (OptionListModel&lt;Option&gt;) selectModel;
                        m.addElement(option);
                        if (option.isSelected()) {
                            m.addSelectionInterval(optionCount, optionCount);
                            m.setInitialSelection(optionCount);
                        }
                    } else if (selectModel instanceof OptionComboBoxModel) {
                        OptionComboBoxModel&lt;Option&gt; m = (OptionComboBoxModel&lt;Option&gt;) selectModel;
                        m.addElement(option);
                        if (option.isSelected()) {
                            m.setSelectedItem(option);
                            m.setInitialSelection(option);
                        }
                    }
                    optionCount++;
                } else {
                    super.start(t, attr);
                }
            }

            public void end(HTML.Tag t) {
                if (t == HTML.Tag.OPTION) {
                    option = null;
                } else {
                    if (t == HTML.Tag.SELECT) {
                        selectModel = null;
                        optionCount = 0;
                    } else if (t == HTML.Tag.TEXTAREA) {
                        inTextArea = false;

                        /* Now that the textarea has ended,
                         * store the entire initial text
                         * of the text area.  This will
                         * enable us to restore the initial
                         * state if a reset is requested.
                         */
                        textAreaDocument.storeInitialText();
                    }
                    super.end(t);
                }
            }

            void setModel(String type, MutableAttributeSet attr) {
                if (type.equals(&quot;submit&quot;) ||
                    type.equals(&quot;reset&quot;) ||
                    type.equals(&quot;image&quot;)) {

                    // button model
                    attr.addAttribute(StyleConstants.ModelAttribute,
                                      new DefaultButtonModel());
                } else if (type.equals(&quot;text&quot;) ||
                           type.equals(&quot;password&quot;)) {
                    // plain text model
                    int maxLength = HTML.getIntegerAttributeValue(
                                       attr, HTML.Attribute.MAXLENGTH, -1);
                    Document doc;

                    if (maxLength &gt; 0) {
                        doc = new FixedLengthDocument(maxLength);
                    }
                    else {
                        doc = new PlainDocument();
                    }
                    String value = (String)
                        attr.getAttribute(HTML.Attribute.VALUE);
                    try {
                        doc.insertString(0, value, null);
                    } catch (BadLocationException e) {
                    }
                    attr.addAttribute(StyleConstants.ModelAttribute, doc);
                } else if (type.equals(&quot;file&quot;)) {
                    // plain text model
                    attr.addAttribute(StyleConstants.ModelAttribute,
                                      new PlainDocument());
                } else if (type.equals(&quot;checkbox&quot;) ||
                           type.equals(&quot;radio&quot;)) {
                    JToggleButton.ToggleButtonModel model = new JToggleButton.ToggleButtonModel();
                    if (type.equals(&quot;radio&quot;)) {
                        String name = (String) attr.getAttribute(HTML.Attribute.NAME);
                        if ( radioButtonGroupsMap == null ) { //fix for 4772743
                           radioButtonGroupsMap = new HashMap&lt;String, ButtonGroup&gt;();
                        }
                        ButtonGroup radioButtonGroup = radioButtonGroupsMap.get(name);
                        if (radioButtonGroup == null) {
                            radioButtonGroup = new ButtonGroup();
                            radioButtonGroupsMap.put(name,radioButtonGroup);
                        }
                        model.setGroup(radioButtonGroup);
                    }
                    boolean checked = (attr.getAttribute(HTML.Attribute.CHECKED) != null);
                    model.setSelected(checked);
                    attr.addAttribute(StyleConstants.ModelAttribute, model);
                }
            }

            /**
             * If a &amp;lt;SELECT&amp;gt; tag is being processed, this
             * model will be a reference to the model being filled
             * with the &amp;lt;OPTION&amp;gt; elements (which produce
             * objects of type &lt;code&gt;Option&lt;/code&gt;.
             */
            Object selectModel;
            int optionCount;
        }


        // --- utility methods used by the reader ------------------

        /**
         * Pushes the current character style on a stack in preparation
         * for forming a new nested character style.
         */
        protected void pushCharacterStyle() {
            charAttrStack.push(charAttr.copyAttributes());
        }

        /**
         * Pops a previously pushed character style off the stack
         * to return to a previous style.
         */
        protected void popCharacterStyle() {
            if (!charAttrStack.empty()) {
                charAttr = (MutableAttributeSet) charAttrStack.peek();
                charAttrStack.pop();
            }
        }

        /**
         * Adds the given content to the textarea document.
         * This method gets called when we are in a textarea
         * context.  Therefore all text that is seen belongs
         * to the text area and is hence added to the
         * TextAreaDocument associated with the text area.
         */
        protected void textAreaContent(char[] data) {
            try {
                textAreaDocument.insertString(textAreaDocument.getLength(), new String(data), null);
            } catch (BadLocationException e) {
                // Should do something reasonable
            }
        }

        /**
         * Adds the given content that was encountered in a
         * PRE element.  This synthesizes lines to hold the
         * runs of text, and makes calls to addContent to
         * actually add the text.
         */
        protected void preContent(char[] data) {
            int last = 0;
            for (int i = 0; i &lt; data.length; i++) {
                if (data[i] == '\n') {
                    addContent(data, last, i - last + 1);
                    blockClose(HTML.Tag.IMPLIED);
                    MutableAttributeSet a = new SimpleAttributeSet();
                    a.addAttribute(CSS.Attribute.WHITE_SPACE, &quot;pre&quot;);
                    blockOpen(HTML.Tag.IMPLIED, a);
                    last = i + 1;
                }
            }
            if (last &lt; data.length) {
                addContent(data, last, data.length - last);
            }
        }

        /**
         * Adds an instruction to the parse buffer to create a
         * block element with the given attributes.
         */
        protected void blockOpen(HTML.Tag t, MutableAttributeSet attr) {
            if (impliedP) {
                blockClose(HTML.Tag.IMPLIED);
            }

            inBlock++;

            if (!canInsertTag(t, attr, true)) {
                return;
            }
            if (attr.isDefined(IMPLIED)) {
                attr.removeAttribute(IMPLIED);
            }
            lastWasNewline = false;
            attr.addAttribute(StyleConstants.NameAttribute, t);
            ElementSpec es = new ElementSpec(
                attr.copyAttributes(), ElementSpec.StartTagType);
            parseBuffer.addElement(es);
        }

        /**
         * Adds an instruction to the parse buffer to close out
         * a block element of the given type.
         */
        protected void blockClose(HTML.Tag t) {
            inBlock--;

            if (!foundInsertTag) {
                return;
            }

            // Add a new line, if the last character wasn't one. This is
            // needed for proper positioning of the cursor. addContent
            // with true will force an implied paragraph to be generated if
            // there isn't one. This may result in a rather bogus structure
            // (perhaps a table with a child pargraph), but the paragraph
            // is needed for proper positioning and display.
            if(!lastWasNewline) {
                pushCharacterStyle();
                charAttr.addAttribute(IMPLIED_CR, Boolean.TRUE);
                addContent(NEWLINE, 0, 1, true);
                popCharacterStyle();
                lastWasNewline = true;
            }

            if (impliedP) {
                impliedP = false;
                inParagraph = false;
                if (t != HTML.Tag.IMPLIED) {
                    blockClose(HTML.Tag.IMPLIED);
                }
            }
            // an open/close with no content will be removed, so we
            // add a space of content to keep the element being formed.
            ElementSpec prev = (parseBuffer.size() &gt; 0) ?
                parseBuffer.lastElement() : null;
            if (prev != null &amp;&amp; prev.getType() == ElementSpec.StartTagType) {
                char[] one = new char[1];
                one[0] = ' ';
                addContent(one, 0, 1);
            }
            ElementSpec es = new ElementSpec(
                null, ElementSpec.EndTagType);
            parseBuffer.addElement(es);
        }

        /**
         * Adds some text with the current character attributes.
         *
         * @param data the content to add
         * @param offs the initial offset
         * @param length the length
         */
        protected void addContent(char[] data, int offs, int length) {
            addContent(data, offs, length, true);
        }

        /**
         * Adds some text with the current character attributes.
         *
         * @param data the content to add
         * @param offs the initial offset
         * @param length the length
         * @param generateImpliedPIfNecessary whether to generate implied
         * paragraphs
         */
        protected void addContent(char[] data, int offs, int length,
                                  boolean generateImpliedPIfNecessary) {
            if (!foundInsertTag) {
                return;
            }

            if (generateImpliedPIfNecessary &amp;&amp; (! inParagraph) &amp;&amp; (! inPre)) {
                blockOpen(HTML.Tag.IMPLIED, new SimpleAttributeSet());
                inParagraph = true;
                impliedP = true;
            }
            emptyAnchor = false;
            charAttr.addAttribute(StyleConstants.NameAttribute, HTML.Tag.CONTENT);
            AttributeSet a = charAttr.copyAttributes();
            ElementSpec es = new ElementSpec(
                a, ElementSpec.ContentType, data, offs, length);
            parseBuffer.addElement(es);

            if (parseBuffer.size() &gt; threshold) {
                if ( threshold &lt;= MaxThreshold ) {
                    threshold *= StepThreshold;
                }
                try {
                    flushBuffer(false);
                } catch (BadLocationException ble) {
                }
            }
            if(length &gt; 0) {
                lastWasNewline = (data[offs + length - 1] == '\n');
            }
        }

        /**
         * Adds content that is basically specified entirely
         * in the attribute set.
         */
        protected void addSpecialElement(HTML.Tag t, MutableAttributeSet a) {
            if ((t != HTML.Tag.FRAME) &amp;&amp; (! inParagraph) &amp;&amp; (! inPre)) {
                nextTagAfterPImplied = t;
                blockOpen(HTML.Tag.IMPLIED, new SimpleAttributeSet());
                nextTagAfterPImplied = null;
                inParagraph = true;
                impliedP = true;
            }
            if (!canInsertTag(t, a, t.isBlock())) {
                return;
            }
            if (a.isDefined(IMPLIED)) {
                a.removeAttribute(IMPLIED);
            }
            emptyAnchor = false;
            a.addAttributes(charAttr);
            a.addAttribute(StyleConstants.NameAttribute, t);
            char[] one = new char[1];
            one[0] = ' ';
            ElementSpec es = new ElementSpec(
                a.copyAttributes(), ElementSpec.ContentType, one, 0, 1);
            parseBuffer.addElement(es);
            // Set this to avoid generating a newline for frames, frames
            // shouldn't have any content, and shouldn't need a newline.
            if (t == HTML.Tag.FRAME) {
                lastWasNewline = true;
            }
        }

        /**
         * Flushes the current parse buffer into the document.
         * @param endOfStream true if there is no more content to parser
         */
        void flushBuffer(boolean endOfStream) throws BadLocationException {
            int oldLength = HTMLDocument.this.getLength();
            int size = parseBuffer.size();
            if (endOfStream &amp;&amp; (insertTag != null || insertAfterImplied) &amp;&amp;
                size &gt; 0) {
                adjustEndSpecsForPartialInsert();
                size = parseBuffer.size();
            }
            ElementSpec[] spec = new ElementSpec[size];
            parseBuffer.copyInto(spec);

            if (oldLength == 0 &amp;&amp; (insertTag == null &amp;&amp; !insertAfterImplied)) {
                create(spec);
            } else {
                insert(offset, spec);
            }
            parseBuffer.removeAllElements();
            offset += HTMLDocument.this.getLength() - oldLength;
            flushCount++;
        }

        /**
         * This will be invoked for the last flush, if &lt;code&gt;insertTag&lt;/code&gt;
         * is non null.
         */
        private void adjustEndSpecsForPartialInsert() {
            int size = parseBuffer.size();
            if (insertTagDepthDelta &lt; 0) {
                // When inserting via an insertTag, the depths (of the tree
                // being read in, and existing hierarchy) may not match up.
                // This attemps to clean it up.
                int removeCounter = insertTagDepthDelta;
                while (removeCounter &lt; 0 &amp;&amp; size &gt;= 0 &amp;&amp;
                        parseBuffer.elementAt(size - 1).
                       getType() == ElementSpec.EndTagType) {
                    parseBuffer.removeElementAt(--size);
                    removeCounter++;
                }
            }
            if (flushCount == 0 &amp;&amp; (!insertAfterImplied ||
                                    !wantsTrailingNewline)) {
                // If this starts with content (or popDepth &gt; 0 &amp;&amp;
                // pushDepth &gt; 0) and ends with EndTagTypes, make sure
                // the last content isn't a \n, otherwise will end up with
                // an extra \n in the middle of content.
                int index = 0;
                if (pushDepth &gt; 0) {
                    if (parseBuffer.elementAt(0).getType() ==
                        ElementSpec.ContentType) {
                        index++;
                    }
                }
                index += (popDepth + pushDepth);
                int cCount = 0;
                int cStart = index;
                while (index &lt; size &amp;&amp; parseBuffer.elementAt
                        (index).getType() == ElementSpec.ContentType) {
                    index++;
                    cCount++;
                }
                if (cCount &gt; 1) {
                    while (index &lt; size &amp;&amp; parseBuffer.elementAt
                            (index).getType() == ElementSpec.EndTagType) {
                        index++;
                    }
                    if (index == size) {
                        char[] lastText = parseBuffer.elementAt
                                (cStart + cCount - 1).getArray();
                        if (lastText.length == 1 &amp;&amp; lastText[0] == NEWLINE[0]){
                            index = cStart + cCount - 1;
                            while (size &gt; index) {
                                parseBuffer.removeElementAt(--size);
                            }
                        }
                    }
                }
            }
            if (wantsTrailingNewline) {
                // Make sure there is in fact a newline
                for (int counter = parseBuffer.size() - 1; counter &gt;= 0;
                                   counter--) {
                    ElementSpec spec = parseBuffer.elementAt(counter);
                    if (spec.getType() == ElementSpec.ContentType) {
                        if (spec.getArray()[spec.getLength() - 1] != '\n') {
                            SimpleAttributeSet attrs =new SimpleAttributeSet();

                            attrs.addAttribute(StyleConstants.NameAttribute,
                                               HTML.Tag.CONTENT);
                            parseBuffer.insertElementAt(new ElementSpec(
                                    attrs,
                                    ElementSpec.ContentType, NEWLINE, 0, 1),
                                    counter + 1);
                        }
                        break;
                    }
                }
            }
        }

        /**
         * Adds the CSS rules in &lt;code&gt;rules&lt;/code&gt;.
         */
        void addCSSRules(String rules) {
            StyleSheet ss = getStyleSheet();
            ss.addRule(rules);
        }

        /**
         * Adds the CSS stylesheet at &lt;code&gt;href&lt;/code&gt; to the known list
         * of stylesheets.
         */
        void linkCSSStyleSheet(String href) {
            URL url;
            try {
                url = new URL(base, href);
            } catch (MalformedURLException mfe) {
                try {
                    url = new URL(href);
                } catch (MalformedURLException mfe2) {
                    url = null;
                }
            }
            if (url != null) {
                getStyleSheet().importStyleSheet(url);
            }
        }

        /**
         * Returns true if can insert starting at &lt;code&gt;t&lt;/code&gt;. This
         * will return false if the insert tag is set, and hasn't been found
         * yet.
         */
        private boolean canInsertTag(HTML.Tag t, AttributeSet attr,
                                     boolean isBlockTag) {
            if (!foundInsertTag) {
                boolean needPImplied = ((t == HTML.Tag.IMPLIED)
                                                          &amp;&amp; (!inParagraph)
                                                          &amp;&amp; (!inPre));
                if (needPImplied &amp;&amp; (nextTagAfterPImplied != null)) {

                    /*
                     * If insertTag == null then just proceed to
                     * foundInsertTag() call below and return true.
                     */
                    if (insertTag != null) {
                        boolean nextTagIsInsertTag =
                                isInsertTag(nextTagAfterPImplied);
                        if ( (! nextTagIsInsertTag) || (! insertInsertTag) ) {
                            return false;
                        }
                    }
                    /*
                     *  Proceed to foundInsertTag() call...
                     */
                 } else if ((insertTag != null &amp;&amp; !isInsertTag(t))
                               || (insertAfterImplied
                                    &amp;&amp; (attr == null
                                        || attr.isDefined(IMPLIED)
                                        || t == HTML.Tag.IMPLIED
                                       )
                                   )
                           ) {
                    return false;
                }

                // Allow the insert if t matches the insert tag, or
                // insertAfterImplied is true and the element is implied.
                foundInsertTag(isBlockTag);
                if (!insertInsertTag) {
                    return false;
                }
            }
            return true;
        }

        private boolean isInsertTag(HTML.Tag tag) {
            return (insertTag == tag);
        }

        private void foundInsertTag(boolean isBlockTag) {
            foundInsertTag = true;
            if (!insertAfterImplied &amp;&amp; (popDepth &gt; 0 || pushDepth &gt; 0)) {
                try {
                    if (offset == 0 || !getText(offset - 1, 1).equals(&quot;\n&quot;)) {
                        // Need to insert a newline.
                        AttributeSet newAttrs = null;
                        boolean joinP = true;

                        if (offset != 0) {
                            // Determine if we can use JoinPrevious, we can't
                            // if the Element has some attributes that are
                            // not meant to be duplicated.
                            Element charElement = getCharacterElement
                                                    (offset - 1);
                            AttributeSet attrs = charElement.getAttributes();

                            if (attrs.isDefined(StyleConstants.
                                                ComposedTextAttribute)) {
                                joinP = false;
                            }
                            else {
                                Object name = attrs.getAttribute
                                              (StyleConstants.NameAttribute);
                                if (name instanceof HTML.Tag) {
                                    HTML.Tag tag = (HTML.Tag)name;
                                    if (tag == HTML.Tag.IMG ||
                                        tag == HTML.Tag.HR ||
                                        tag == HTML.Tag.COMMENT ||
                                        (tag instanceof HTML.UnknownTag)) {
                                        joinP = false;
                                    }
                                }
                            }
                        }
                        if (!joinP) {
                            // If not joining with the previous element, be
                            // sure and set the name (otherwise it will be
                            // inherited).
                            newAttrs = new SimpleAttributeSet();
                            ((SimpleAttributeSet)newAttrs).addAttribute
                                              (StyleConstants.NameAttribute,
                                               HTML.Tag.CONTENT);
                        }
                        ElementSpec es = new ElementSpec(newAttrs,
                                     ElementSpec.ContentType, NEWLINE, 0,
                                     NEWLINE.length);
                        if (joinP) {
                            es.setDirection(ElementSpec.
                                            JoinPreviousDirection);
                        }
                        parseBuffer.addElement(es);
                    }
                } catch (BadLocationException ble) {}
            }
            // pops
            for (int counter = 0; counter &lt; popDepth; counter++) {
                parseBuffer.addElement(new ElementSpec(null, ElementSpec.
                                                       EndTagType));
            }
            // pushes
            for (int counter = 0; counter &lt; pushDepth; counter++) {
                ElementSpec es = new ElementSpec(null, ElementSpec.
                                                 StartTagType);
                es.setDirection(ElementSpec.JoinNextDirection);
                parseBuffer.addElement(es);
            }
            insertTagDepthDelta = depthTo(Math.max(0, offset - 1)) -
                                  popDepth + pushDepth - inBlock;
            if (isBlockTag) {
                // A start spec will be added (for this tag), so we account
                // for it here.
                insertTagDepthDelta++;
            }
            else {
                // An implied paragraph close (end spec) is going to be added,
                // so we account for it here.
                insertTagDepthDelta--;
                inParagraph = true;
                lastWasNewline = false;
            }
        }

        /**
         * This is set to true when and end is invoked for {@literal &lt;html&gt;}.
         */
        private boolean receivedEndHTML;
        /** Number of times &lt;code&gt;flushBuffer&lt;/code&gt; has been invoked. */
        private int flushCount;
        /** If true, behavior is similar to insertTag, but instead of
         * waiting for insertTag will wait for first Element without
         * an 'implied' attribute and begin inserting then. */
        private boolean insertAfterImplied;
        /** This is only used if insertAfterImplied is true. If false, only
         * inserting content, and there is a trailing newline it is removed. */
        private boolean wantsTrailingNewline;
        int threshold;
        int offset;
        boolean inParagraph = false;
        boolean impliedP = false;
        boolean inPre = false;
        boolean inTextArea = false;
        TextAreaDocument textAreaDocument = null;
        boolean inTitle = false;
        boolean lastWasNewline = true;
        boolean emptyAnchor;
        /** True if (!emptyDocument &amp;amp;&amp;amp; insertTag == null), this is used so
         * much it is cached. */
        boolean midInsert;
        /** True when the body has been encountered. */
        boolean inBody;
        /** If non null, gives parent Tag that insert is to happen at. */
        HTML.Tag insertTag;
        /** If true, the insertTag is inserted, otherwise elements after
         * the insertTag is found are inserted. */
        boolean insertInsertTag;
        /** Set to true when insertTag has been found. */
        boolean foundInsertTag;
        /** When foundInsertTag is set to true, this will be updated to
         * reflect the delta between the two structures. That is, it
         * will be the depth the inserts are happening at minus the
         * depth of the tags being passed in. A value of 0 (the common
         * case) indicates the structures match, a value greater than 0 indicates
         * the insert is happening at a deeper depth than the stream is
         * parsing, and a value less than 0 indicates the insert is happening earlier
         * in the tree that the parser thinks and that we will need to remove
         * EndTagType specs in the flushBuffer method.
         */
        int insertTagDepthDelta;
        /** How many parents to ascend before insert new elements. */
        int popDepth;
        /** How many parents to descend (relative to popDepth) before
         * inserting. */
        int pushDepth;
        /** Last Map that was encountered. */
        Map lastMap;
        /** Set to true when a style element is encountered. */
        boolean inStyle = false;
        /** Name of style to use. Obtained from Meta tag. */
        String defaultStyle;
        /** Vector describing styles that should be include. Will consist
         * of a bunch of HTML.Tags, which will either be:
         * &lt;p&gt;LINK: in which case it is followed by an AttributeSet
         * &lt;p&gt;STYLE: in which case the following element is a String
         * indicating the type (may be null), and the elements following
         * it until the next HTML.Tag are the rules as Strings.
         */
        Vector&lt;Object&gt; styles;
        /** True if inside the head tag. */
        boolean inHead = false;
        /** Set to true if the style language is text/css. Since this is
         * used alot, it is cached. */
        boolean isStyleCSS;
        /** True if inserting into an empty document. */
        boolean emptyDocument;
        /** Attributes from a style Attribute. */
        AttributeSet styleAttributes;

        /**
         * Current option, if in an option element (needed to
         * load the label.
         */
        Option option;

        protected Vector&lt;ElementSpec&gt; parseBuffer = new Vector&lt;ElementSpec&gt;();
        protected MutableAttributeSet charAttr = new TaggedAttributeSet();
        Stack&lt;AttributeSet&gt; charAttrStack = new Stack&lt;AttributeSet&gt;();
        Hashtable&lt;HTML.Tag, TagAction&gt; tagMap;
        int inBlock = 0;

        /**
         * This attribute is sometimes used to refer to next tag
         * to be handled after p-implied when the latter is
         * the current tag which is being handled.
         */
        private HTML.Tag nextTagAfterPImplied = null;
    }


    /**
     * Used by StyleSheet to determine when to avoid removing HTML.Tags
     * matching StyleConstants.
     */
    static class TaggedAttributeSet extends SimpleAttributeSet {
        TaggedAttributeSet() {
            super();
        }
    }


    /**
     * An element that represents a chunk of text that has
     * a set of HTML character level attributes assigned to
     * it.
     */
    public class RunElement extends LeafElement {

        /**
         * Constructs an element that represents content within the
         * document (has no children).
         *
         * @param parent  the parent element
         * @param a       the element attributes
         * @param offs0   the start offset (must be at least 0)
         * @param offs1   the end offset (must be at least offs0)
         * @since 1.4
         */
        public RunElement(Element parent, AttributeSet a, int offs0, int offs1) {
            super(parent, a, offs0, offs1);
        }

        /**
         * Gets the name of the element.
         *
         * @return the name, null if none
         */
        public String getName() {
            Object o = getAttribute(StyleConstants.NameAttribute);
            if (o != null) {
                return o.toString();
            }
            return super.getName();
        }

        /**
         * Gets the resolving parent.  HTML attributes are not inherited
         * at the model level so we override this to return null.
         *
         * @return null, there are none
         * @see AttributeSet#getResolveParent
         */
        public AttributeSet getResolveParent() {
            return null;
        }
    }

    /**
     * An element that represents a structural &lt;em&gt;block&lt;/em&gt; of
     * HTML.
     */
    public class BlockElement extends BranchElement {

        /**
         * Constructs a composite element that initially contains
         * no children.
         *
         * @param parent  the parent element
         * @param a       the attributes for the element
         * @since 1.4
         */
        public BlockElement(Element parent, AttributeSet a) {
            super(parent, a);
        }

        /**
         * Gets the name of the element.
         *
         * @return the name, null if none
         */
        public String getName() {
            Object o = getAttribute(StyleConstants.NameAttribute);
            if (o != null) {
                return o.toString();
            }
            return super.getName();
        }

        /**
         * Gets the resolving parent.  HTML attributes are not inherited
         * at the model level so we override this to return null.
         *
         * @return null, there are none
         * @see AttributeSet#getResolveParent
         */
        public AttributeSet getResolveParent() {
            return null;
        }

    }


    /**
     * Document that allows you to set the maximum length of the text.
     */
    private static class FixedLengthDocument extends PlainDocument {
        private int maxLength;

        public FixedLengthDocument(int maxLength) {
            this.maxLength = maxLength;
        }

        public void insertString(int offset, String str, AttributeSet a)
            throws BadLocationException {
            if (str != null &amp;&amp; str.length() + getLength() &lt;= maxLength) {
                super.insertString(offset, str, a);
            }
        }
    }
}
</pre>
</body>
</html>
