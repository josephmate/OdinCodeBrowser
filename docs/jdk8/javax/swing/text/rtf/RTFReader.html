<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text.rtf;

import java.lang.*;
import java.util.*;
import java.io.*;
import java.awt.Font;
import java.awt.Color;

import javax.swing.text.*;

/**
 * Takes a sequence of RTF tokens and text and appends the text
 * described by the RTF to a &lt;code&gt;StyledDocument&lt;/code&gt; (the &lt;em&gt;target&lt;/em&gt;).
 * The RTF is lexed
 * from the character stream by the &lt;code&gt;RTFParser&lt;/code&gt; which is this class's
 * superclass.
 *
 * This class is an indirect subclass of OutputStream. It must be closed
 * in order to guarantee that all of the text has been sent to
 * the text acceptor.
 *
 *   @see RTFParser
 *   @see java.io.OutputStream
 */
class RTFReader extends RTFParser
{
  /** The object to which the parsed text is sent. */
  StyledDocument target;

  /** Miscellaneous information about the parser's state. This
   *  dictionary is saved and restored when an RTF group begins
   *  or ends. */
  Dictionary&lt;Object, Object&gt; parserState;   /* Current parser state */
  /** This is the &quot;dst&quot; item from parserState. rtfDestination
   *  is the current rtf destination. It is cached in an instance
   *  variable for speed. */
  Destination rtfDestination;
  /** This holds the current document attributes. */
  MutableAttributeSet documentAttributes;

  /** This Dictionary maps Integer font numbers to String font names. */
  Dictionary&lt;Integer, String&gt; fontTable;
  /** This array maps color indices to Color objects. */
  Color[] colorTable;
  /** This array maps character style numbers to Style objects. */
  Style[] characterStyles;
  /** This array maps paragraph style numbers to Style objects. */
  Style[] paragraphStyles;
  /** This array maps section style numbers to Style objects. */
  Style[] sectionStyles;

  /** This is the RTF version number, extracted from the \rtf keyword.
   *  The version information is currently not used. */
  int rtfversion;

  /** &lt;code&gt;true&lt;/code&gt; to indicate that if the next keyword is unknown,
   *  the containing group should be ignored. */
  boolean ignoreGroupIfUnknownKeyword;

  /** The parameter of the most recently parsed \\ucN keyword,
   *  used for skipping alternative representations after a
   *  Unicode character. */
  int skippingCharacters;

  static private Dictionary&lt;String, RTFAttribute&gt; straightforwardAttributes;
  static {
      straightforwardAttributes = RTFAttributes.attributesByKeyword();
  }

  private MockAttributeSet mockery;

  /* this should be final, but there's a bug in javac... */
  /** textKeywords maps RTF keywords to single-character strings,
   *  for those keywords which simply insert some text. */
  static Dictionary&lt;String, String&gt; textKeywords = null;
  static {
      textKeywords = new Hashtable&lt;String, String&gt;();
      textKeywords.put(&quot;\\&quot;,         &quot;\\&quot;);
      textKeywords.put(&quot;{&quot;,          &quot;{&quot;);
      textKeywords.put(&quot;}&quot;,          &quot;}&quot;);
      textKeywords.put(&quot; &quot;,          &quot;\u00A0&quot;);  /* not in the spec... */
      textKeywords.put(&quot;~&quot;,          &quot;\u00A0&quot;);  /* nonbreaking space */
      textKeywords.put(&quot;_&quot;,          &quot;\u2011&quot;);  /* nonbreaking hyphen */
      textKeywords.put(&quot;bullet&quot;,     &quot;\u2022&quot;);
      textKeywords.put(&quot;emdash&quot;,     &quot;\u2014&quot;);
      textKeywords.put(&quot;emspace&quot;,    &quot;\u2003&quot;);
      textKeywords.put(&quot;endash&quot;,     &quot;\u2013&quot;);
      textKeywords.put(&quot;enspace&quot;,    &quot;\u2002&quot;);
      textKeywords.put(&quot;ldblquote&quot;,  &quot;\u201C&quot;);
      textKeywords.put(&quot;lquote&quot;,     &quot;\u2018&quot;);
      textKeywords.put(&quot;ltrmark&quot;,    &quot;\u200E&quot;);
      textKeywords.put(&quot;rdblquote&quot;,  &quot;\u201D&quot;);
      textKeywords.put(&quot;rquote&quot;,     &quot;\u2019&quot;);
      textKeywords.put(&quot;rtlmark&quot;,    &quot;\u200F&quot;);
      textKeywords.put(&quot;tab&quot;,        &quot;\u0009&quot;);
      textKeywords.put(&quot;zwj&quot;,        &quot;\u200D&quot;);
      textKeywords.put(&quot;zwnj&quot;,       &quot;\u200C&quot;);

      /* There is no Unicode equivalent to an optional hyphen, as far as
         I can tell. */
      textKeywords.put(&quot;-&quot;,          &quot;\u2027&quot;);  /* TODO: optional hyphen */
  }

  /* some entries in parserState */
  static final String TabAlignmentKey = &quot;tab_alignment&quot;;
  static final String TabLeaderKey = &quot;tab_leader&quot;;

  static Dictionary&lt;String, char[]&gt; characterSets;
  static boolean useNeXTForAnsi = false;
  static {
      characterSets = new Hashtable&lt;String, char[]&gt;();
  }

/* TODO: per-font font encodings ( \fcharset control word ) ? */

/**
 * Creates a new RTFReader instance. Text will be sent to
 * the specified TextAcceptor.
 *
 * @param destination The TextAcceptor which is to receive the text.
 */
public RTFReader(StyledDocument destination)
{
    int i;

    target = destination;
    parserState = new Hashtable&lt;Object, Object&gt;();
    fontTable = new Hashtable&lt;Integer, String&gt;();

    rtfversion = -1;

    mockery = new MockAttributeSet();
    documentAttributes = new SimpleAttributeSet();
}

/** Called when the RTFParser encounters a bin keyword in the
 *  RTF stream.
 *
 *  @see RTFParser
 */
public void handleBinaryBlob(byte[] data)
{
    if (skippingCharacters &gt; 0) {
        /* a blob only counts as one character for skipping purposes */
        skippingCharacters --;
        return;
    }

    /* someday, someone will want to do something with blobs */
}


/**
 * Handles any pure text (containing no control characters) in the input
 * stream. Called by the superclass. */
public void handleText(String text)
{
    if (skippingCharacters &gt; 0) {
        if (skippingCharacters &gt;= text.length()) {
            skippingCharacters -= text.length();
            return;
        } else {
            text = text.substring(skippingCharacters);
            skippingCharacters = 0;
        }
    }

    if (rtfDestination != null) {
        rtfDestination.handleText(text);
        return;
    }

    warning(&quot;Text with no destination. oops.&quot;);
}

/** The default color for text which has no specified color. */
Color defaultColor()
{
    return Color.black;
}

/** Called by the superclass when a new RTF group is begun.
 *  This implementation saves the current &lt;code&gt;parserState&lt;/code&gt;, and gives
 *  the current destination a chance to save its own state.
 * @see RTFParser#begingroup
 */
public void begingroup()
{
    if (skippingCharacters &gt; 0) {
        /* TODO this indicates an error in the RTF. Log it? */
        skippingCharacters = 0;
    }

    /* we do this little dance to avoid cloning the entire state stack and
       immediately throwing it away. */
    Object oldSaveState = parserState.get(&quot;_savedState&quot;);
    if (oldSaveState != null)
        parserState.remove(&quot;_savedState&quot;);
    Dictionary&lt;String, Object&gt; saveState = (Dictionary&lt;String, Object&gt;)((Hashtable)parserState).clone();
    if (oldSaveState != null)
        saveState.put(&quot;_savedState&quot;, oldSaveState);
    parserState.put(&quot;_savedState&quot;, saveState);

    if (rtfDestination != null)
        rtfDestination.begingroup();
}

/** Called by the superclass when the current RTF group is closed.
 *  This restores the parserState saved by &lt;code&gt;begingroup()&lt;/code&gt;
 *  as well as invoking the endgroup method of the current
 *  destination.
 * @see RTFParser#endgroup
 */
public void endgroup()
{
    if (skippingCharacters &gt; 0) {
        /* NB this indicates an error in the RTF. Log it? */
        skippingCharacters = 0;
    }

    Dictionary&lt;Object, Object&gt; restoredState = (Dictionary&lt;Object, Object&gt;)parserState.get(&quot;_savedState&quot;);
    Destination restoredDestination = (Destination)restoredState.get(&quot;dst&quot;);
    if (restoredDestination != rtfDestination) {
        rtfDestination.close(); /* allow the destination to clean up */
        rtfDestination = restoredDestination;
    }
    Dictionary oldParserState = parserState;
    parserState = restoredState;
    if (rtfDestination != null)
        rtfDestination.endgroup(oldParserState);
}

protected void setRTFDestination(Destination newDestination)
{
    /* Check that setting the destination won't close the
       current destination (should never happen) */
    Dictionary previousState = (Dictionary)parserState.get(&quot;_savedState&quot;);
    if (previousState != null) {
        if (rtfDestination != previousState.get(&quot;dst&quot;)) {
            warning(&quot;Warning, RTF destination overridden, invalid RTF.&quot;);
            rtfDestination.close();
        }
    }
    rtfDestination = newDestination;
    parserState.put(&quot;dst&quot;, rtfDestination);
}

/** Called by the user when there is no more input (&lt;i&gt;i.e.&lt;/i&gt;,
 * at the end of the RTF file.)
 *
 * @see OutputStream#close
 */
public void close()
    throws IOException
{
    Enumeration docProps = documentAttributes.getAttributeNames();
    while(docProps.hasMoreElements()) {
        Object propName = docProps.nextElement();
        target.putProperty(propName,
                           documentAttributes.getAttribute(propName));
    }

    /* RTFParser should have ensured that all our groups are closed */

    warning(&quot;RTF filter done.&quot;);

    super.close();
}

/**
 * Handles a parameterless RTF keyword. This is called by the superclass
 * (RTFParser) when a keyword is found in the input stream.
 *
 * @returns &lt;code&gt;true&lt;/code&gt; if the keyword is recognized and handled;
 *          &lt;code&gt;false&lt;/code&gt; otherwise
 * @see RTFParser#handleKeyword
 */
public boolean handleKeyword(String keyword)
{
    String item;
    boolean ignoreGroupIfUnknownKeywordSave = ignoreGroupIfUnknownKeyword;

    if (skippingCharacters &gt; 0) {
        skippingCharacters --;
        return true;
    }

    ignoreGroupIfUnknownKeyword = false;

    if ((item = textKeywords.get(keyword)) != null) {
        handleText(item);
        return true;
    }

    if (keyword.equals(&quot;fonttbl&quot;)) {
        setRTFDestination(new FonttblDestination());
        return true;
    }

    if (keyword.equals(&quot;colortbl&quot;)) {
        setRTFDestination(new ColortblDestination());
        return true;
    }

    if (keyword.equals(&quot;stylesheet&quot;)) {
        setRTFDestination(new StylesheetDestination());
        return true;
    }

    if (keyword.equals(&quot;info&quot;)) {
        setRTFDestination(new InfoDestination());
        return false;
    }

    if (keyword.equals(&quot;mac&quot;)) {
        setCharacterSet(&quot;mac&quot;);
        return true;
    }

    if (keyword.equals(&quot;ansi&quot;)) {
        if (useNeXTForAnsi)
            setCharacterSet(&quot;NeXT&quot;);
        else
            setCharacterSet(&quot;ansi&quot;);
        return true;
    }

    if (keyword.equals(&quot;next&quot;)) {
        setCharacterSet(&quot;NeXT&quot;);
        return true;
    }

    if (keyword.equals(&quot;pc&quot;)) {
        setCharacterSet(&quot;cpg437&quot;); /* IBM Code Page 437 */
        return true;
    }

    if (keyword.equals(&quot;pca&quot;)) {
        setCharacterSet(&quot;cpg850&quot;); /* IBM Code Page 850 */
        return true;
    }

    if (keyword.equals(&quot;*&quot;)) {
        ignoreGroupIfUnknownKeyword = true;
        return true;
    }

    if (rtfDestination != null) {
        if(rtfDestination.handleKeyword(keyword))
            return true;
    }

    /* this point is reached only if the keyword is unrecognized */

    /* other destinations we don't understand and therefore ignore */
    if (keyword.equals(&quot;aftncn&quot;) ||
        keyword.equals(&quot;aftnsep&quot;) ||
        keyword.equals(&quot;aftnsepc&quot;) ||
        keyword.equals(&quot;annotation&quot;) ||
        keyword.equals(&quot;atnauthor&quot;) ||
        keyword.equals(&quot;atnicn&quot;) ||
        keyword.equals(&quot;atnid&quot;) ||
        keyword.equals(&quot;atnref&quot;) ||
        keyword.equals(&quot;atntime&quot;) ||
        keyword.equals(&quot;atrfend&quot;) ||
        keyword.equals(&quot;atrfstart&quot;) ||
        keyword.equals(&quot;bkmkend&quot;) ||
        keyword.equals(&quot;bkmkstart&quot;) ||
        keyword.equals(&quot;datafield&quot;) ||
        keyword.equals(&quot;do&quot;) ||
        keyword.equals(&quot;dptxbxtext&quot;) ||
        keyword.equals(&quot;falt&quot;) ||
        keyword.equals(&quot;field&quot;) ||
        keyword.equals(&quot;file&quot;) ||
        keyword.equals(&quot;filetbl&quot;) ||
        keyword.equals(&quot;fname&quot;) ||
        keyword.equals(&quot;fontemb&quot;) ||
        keyword.equals(&quot;fontfile&quot;) ||
        keyword.equals(&quot;footer&quot;) ||
        keyword.equals(&quot;footerf&quot;) ||
        keyword.equals(&quot;footerl&quot;) ||
        keyword.equals(&quot;footerr&quot;) ||
        keyword.equals(&quot;footnote&quot;) ||
        keyword.equals(&quot;ftncn&quot;) ||
        keyword.equals(&quot;ftnsep&quot;) ||
        keyword.equals(&quot;ftnsepc&quot;) ||
        keyword.equals(&quot;header&quot;) ||
        keyword.equals(&quot;headerf&quot;) ||
        keyword.equals(&quot;headerl&quot;) ||
        keyword.equals(&quot;headerr&quot;) ||
        keyword.equals(&quot;keycode&quot;) ||
        keyword.equals(&quot;nextfile&quot;) ||
        keyword.equals(&quot;object&quot;) ||
        keyword.equals(&quot;pict&quot;) ||
        keyword.equals(&quot;pn&quot;) ||
        keyword.equals(&quot;pnseclvl&quot;) ||
        keyword.equals(&quot;pntxtb&quot;) ||
        keyword.equals(&quot;pntxta&quot;) ||
        keyword.equals(&quot;revtbl&quot;) ||
        keyword.equals(&quot;rxe&quot;) ||
        keyword.equals(&quot;tc&quot;) ||
        keyword.equals(&quot;template&quot;) ||
        keyword.equals(&quot;txe&quot;) ||
        keyword.equals(&quot;xe&quot;)) {
        ignoreGroupIfUnknownKeywordSave = true;
    }

    if (ignoreGroupIfUnknownKeywordSave) {
        setRTFDestination(new DiscardingDestination());
    }

    return false;
}

/**
 * Handles an RTF keyword and its integer parameter.
 * This is called by the superclass
 * (RTFParser) when a keyword is found in the input stream.
 *
 * @returns &lt;code&gt;true&lt;/code&gt; if the keyword is recognized and handled;
 *          &lt;code&gt;false&lt;/code&gt; otherwise
 * @see RTFParser#handleKeyword
 */
public boolean handleKeyword(String keyword, int parameter)
{
    boolean ignoreGroupIfUnknownKeywordSave = ignoreGroupIfUnknownKeyword;

    if (skippingCharacters &gt; 0) {
        skippingCharacters --;
        return true;
    }

    ignoreGroupIfUnknownKeyword = false;

    if (keyword.equals(&quot;uc&quot;)) {
        /* count of characters to skip after a unicode character */
        parserState.put(&quot;UnicodeSkip&quot;, Integer.valueOf(parameter));
        return true;
    }
    if (keyword.equals(&quot;u&quot;)) {
        if (parameter &lt; 0)
            parameter = parameter + 65536;
        handleText((char)parameter);
        Number skip = (Number)(parserState.get(&quot;UnicodeSkip&quot;));
        if (skip != null) {
            skippingCharacters = skip.intValue();
        } else {
            skippingCharacters = 1;
        }
        return true;
    }

    if (keyword.equals(&quot;rtf&quot;)) {
        rtfversion = parameter;
        setRTFDestination(new DocumentDestination());
        return true;
    }

    if (keyword.startsWith(&quot;NeXT&quot;) ||
        keyword.equals(&quot;private&quot;))
        ignoreGroupIfUnknownKeywordSave = true;

    if (rtfDestination != null) {
        if(rtfDestination.handleKeyword(keyword, parameter))
            return true;
    }

    /* this point is reached only if the keyword is unrecognized */

    if (ignoreGroupIfUnknownKeywordSave) {
        setRTFDestination(new DiscardingDestination());
    }

    return false;
}

private void setTargetAttribute(String name, Object value)
{
//    target.changeAttributes(new LFDictionary(LFArray.arrayWithObject(value), LFArray.arrayWithObject(name)));
}

/**
 * setCharacterSet sets the current translation table to correspond with
 * the named character set. The character set is loaded if necessary.
 *
 * @see AbstractFilter
 */
public void setCharacterSet(String name)
{
    Object set;

    try {
        set = getCharacterSet(name);
    } catch (Exception e) {
        warning(&quot;Exception loading RTF character set \&quot;&quot; + name + &quot;\&quot;: &quot; + e);
        set = null;
    }

    if (set != null) {
        translationTable = (char[])set;
    } else {
        warning(&quot;Unknown RTF character set \&quot;&quot; + name + &quot;\&quot;&quot;);
        if (!name.equals(&quot;ansi&quot;)) {
            try {
                translationTable = (char[])getCharacterSet(&quot;ansi&quot;);
            } catch (IOException e) {
                throw new InternalError(&quot;RTFReader: Unable to find character set resources (&quot; + e + &quot;)&quot;, e);
            }
        }
    }

    setTargetAttribute(Constants.RTFCharacterSet, name);
}

/** Adds a character set to the RTFReader's list
 *  of known character sets */
public static void
defineCharacterSet(String name, char[] table)
{
    if (table.length &lt; 256)
        throw new IllegalArgumentException(&quot;Translation table must have 256 entries.&quot;);
    characterSets.put(name, table);
}

/** Looks up a named character set. A character set is a 256-entry
 *  array of characters, mapping unsigned byte values to their Unicode
 *  equivalents. The character set is loaded if necessary.
 *
 *  @returns the character set
 */
public static Object
getCharacterSet(final String name)
    throws IOException
{
    char[] set = characterSets.get(name);
    if (set == null) {
      InputStream charsetStream;
      charsetStream = java.security.AccessController.
              doPrivileged(new java.security.PrivilegedAction&lt;InputStream&gt;() {
          public InputStream run() {
              return RTFReader.class.getResourceAsStream
                                     (&quot;charsets/&quot; + name + &quot;.txt&quot;);
          }
      });
      set = readCharset(charsetStream);
      defineCharacterSet(name, set);
    }
    return set;
}

/** Parses a character set from an InputStream. The character set
 * must contain 256 decimal integers, separated by whitespace, with
 * no punctuation. B- and C- style comments are allowed.
 *
 * @returns the newly read character set
 */
static char[] readCharset(InputStream strm)
     throws IOException
{
    char[] values = new char[256];
    int i;
    StreamTokenizer in = new StreamTokenizer(new BufferedReader(
            new InputStreamReader(strm, &quot;ISO-8859-1&quot;)));

    in.eolIsSignificant(false);
    in.commentChar('#');
    in.slashSlashComments(true);
    in.slashStarComments(true);

    i = 0;
    while (i &lt; 256) {
        int ttype;
        try {
            ttype = in.nextToken();
        } catch (Exception e) {
            throw new IOException(&quot;Unable to read from character set file (&quot; + e + &quot;)&quot;);
        }
        if (ttype != in.TT_NUMBER) {
//          System.out.println(&quot;Bad token: type=&quot; + ttype + &quot; tok=&quot; + in.sval);
            throw new IOException(&quot;Unexpected token in character set file&quot;);
//          continue;
        }
        values[i] = (char)(in.nval);
        i++;
    }

    return values;
}

static char[] readCharset(java.net.URL href)
     throws IOException
{
    return readCharset(href.openStream());
}

/** An interface (could be an entirely abstract class) describing
 *  a destination. The RTF reader always has a current destination
 *  which is where text is sent.
 *
 *  @see RTFReader
 */
interface Destination {
    void handleBinaryBlob(byte[] data);
    void handleText(String text);
    boolean handleKeyword(String keyword);
    boolean handleKeyword(String keyword, int parameter);

    void begingroup();
    void endgroup(Dictionary oldState);

    void close();
}

/** This data-sink class is used to implement ignored destinations
 *  (e.g. {\*\blegga blah blah blah} )
 *  It accepts all keywords and text but does nothing with them. */
class DiscardingDestination implements Destination
{
    public void handleBinaryBlob(byte[] data)
    {
        /* Discard binary blobs. */
    }

    public void handleText(String text)
    {
        /* Discard text. */
    }

    public boolean handleKeyword(String text)
    {
        /* Accept and discard keywords. */
        return true;
    }

    public boolean handleKeyword(String text, int parameter)
    {
        /* Accept and discard parameterized keywords. */
        return true;
    }

    public void begingroup()
    {
        /* Ignore groups --- the RTFReader will keep track of the
           current group level as necessary */
    }

    public void endgroup(Dictionary oldState)
    {
        /* Ignore groups */
    }

    public void close()
    {
        /* No end-of-destination cleanup needed */
    }
}

/** Reads the fonttbl group, inserting fonts into the RTFReader's
 *  fontTable dictionary. */
class FonttblDestination implements Destination
{
    int nextFontNumber;
    Integer fontNumberKey = null;
    String nextFontFamily;

    public void handleBinaryBlob(byte[] data)
    { /* Discard binary blobs. */ }

    public void handleText(String text)
    {
        int semicolon = text.indexOf(';');
        String fontName;

        if (semicolon &gt; -1)
            fontName = text.substring(0, semicolon);
        else
            fontName = text;


        /* TODO: do something with the font family. */

        if (nextFontNumber == -1
            &amp;&amp; fontNumberKey != null) {
            //font name might be broken across multiple calls
            fontName = fontTable.get(fontNumberKey) + fontName;
        } else {
            fontNumberKey = Integer.valueOf(nextFontNumber);
        }
        fontTable.put(fontNumberKey, fontName);

        nextFontNumber = -1;
        nextFontFamily = null;
    }

    public boolean handleKeyword(String keyword)
    {
        if (keyword.charAt(0) == 'f') {
            nextFontFamily = keyword.substring(1);
            return true;
        }

        return false;
    }

    public boolean handleKeyword(String keyword, int parameter)
    {
        if (keyword.equals(&quot;f&quot;)) {
            nextFontNumber = parameter;
            return true;
        }

        return false;
    }

    /* Groups are irrelevant. */
    public void begingroup() {}
    public void endgroup(Dictionary oldState) {}

    /* currently, the only thing we do when the font table ends is
       dump its contents to the debugging log. */
    public void close()
    {
        Enumeration&lt;Integer&gt; nums = fontTable.keys();
        warning(&quot;Done reading font table.&quot;);
        while(nums.hasMoreElements()) {
            Integer num = nums.nextElement();
            warning(&quot;Number &quot; + num + &quot;: &quot; + fontTable.get(num));
        }
    }
}

/** Reads the colortbl group. Upon end-of-group, the RTFReader's
 *  color table is set to an array containing the read colors. */
class ColortblDestination implements Destination
{
    int red, green, blue;
    Vector&lt;Color&gt; proTemTable;

    public ColortblDestination()
    {
        red = 0;
        green = 0;
        blue = 0;
        proTemTable = new Vector&lt;Color&gt;();
    }

    public void handleText(String text)
    {
        int index;

        for (index = 0; index &lt; text.length(); index ++) {
            if (text.charAt(index) == ';') {
                Color newColor;
                newColor = new Color(red, green, blue);
                proTemTable.addElement(newColor);
            }
        }
    }

    public void close()
    {
        int count = proTemTable.size();
        warning(&quot;Done reading color table, &quot; + count + &quot; entries.&quot;);
        colorTable = new Color[count];
        proTemTable.copyInto(colorTable);
    }

    public boolean handleKeyword(String keyword, int parameter)
    {
        if (keyword.equals(&quot;red&quot;))
            red = parameter;
        else if (keyword.equals(&quot;green&quot;))
            green = parameter;
        else if (keyword.equals(&quot;blue&quot;))
            blue = parameter;
        else
            return false;

        return true;
    }

    /* Colortbls don't understand any parameterless keywords */
    public boolean handleKeyword(String keyword) { return false; }

    /* Groups are irrelevant. */
    public void begingroup() {}
    public void endgroup(Dictionary oldState) {}

    /* Shouldn't see any binary blobs ... */
    public void handleBinaryBlob(byte[] data) {}
}

/** Handles the stylesheet keyword. Styles are read and sorted
 *  into the three style arrays in the RTFReader. */
class StylesheetDestination
    extends DiscardingDestination
    implements Destination
{
    Dictionary&lt;Integer, StyleDefiningDestination&gt; definedStyles;

    public StylesheetDestination()
    {
        definedStyles = new Hashtable&lt;Integer, StyleDefiningDestination&gt;();
    }

    public void begingroup()
    {
        setRTFDestination(new StyleDefiningDestination());
    }

    public void close()
    {
        Vector&lt;Style&gt; chrStyles = new Vector&lt;Style&gt;();
        Vector&lt;Style&gt; pgfStyles = new Vector&lt;Style&gt;();
        Vector&lt;Style&gt; secStyles = new Vector&lt;Style&gt;();
        Enumeration&lt;StyleDefiningDestination&gt; styles = definedStyles.elements();
        while(styles.hasMoreElements()) {
            StyleDefiningDestination style;
            Style defined;
            style = styles.nextElement();
            defined = style.realize();
            warning(&quot;Style &quot;+style.number+&quot; (&quot;+style.styleName+&quot;): &quot;+defined);
            String stype = (String)defined.getAttribute(Constants.StyleType);
            Vector&lt;Style&gt; toSet;
            if (stype.equals(Constants.STSection)) {
                toSet = secStyles;
            } else if (stype.equals(Constants.STCharacter)) {
                toSet = chrStyles;
            } else {
                toSet = pgfStyles;
            }
            if (toSet.size() &lt;= style.number)
                toSet.setSize(style.number + 1);
            toSet.setElementAt(defined, style.number);
        }
        if (!(chrStyles.isEmpty())) {
            Style[] styleArray = new Style[chrStyles.size()];
            chrStyles.copyInto(styleArray);
            characterStyles = styleArray;
        }
        if (!(pgfStyles.isEmpty())) {
            Style[] styleArray = new Style[pgfStyles.size()];
            pgfStyles.copyInto(styleArray);
            paragraphStyles = styleArray;
        }
        if (!(secStyles.isEmpty())) {
            Style[] styleArray = new Style[secStyles.size()];
            secStyles.copyInto(styleArray);
            sectionStyles = styleArray;
        }

/* (old debugging code)
        int i, m;
        if (characterStyles != null) {
          m = characterStyles.length;
          for(i=0;i&lt;m;i++)
            warnings.println(&quot;chrStyle[&quot;+i+&quot;]=&quot;+characterStyles[i]);
        } else warnings.println(&quot;No character styles.&quot;);
        if (paragraphStyles != null) {
          m = paragraphStyles.length;
          for(i=0;i&lt;m;i++)
            warnings.println(&quot;pgfStyle[&quot;+i+&quot;]=&quot;+paragraphStyles[i]);
        } else warnings.println(&quot;No paragraph styles.&quot;);
        if (sectionStyles != null) {
          m = characterStyles.length;
          for(i=0;i&lt;m;i++)
            warnings.println(&quot;secStyle[&quot;+i+&quot;]=&quot;+sectionStyles[i]);
        } else warnings.println(&quot;No section styles.&quot;);
*/
    }

    /** This subclass handles an individual style */
    class StyleDefiningDestination
        extends AttributeTrackingDestination
        implements Destination
    {
        final int STYLENUMBER_NONE = 222;
        boolean additive;
        boolean characterStyle;
        boolean sectionStyle;
        public String styleName;
        public int number;
        int basedOn;
        int nextStyle;
        boolean hidden;

        Style realizedStyle;

        public StyleDefiningDestination()
        {
            additive = false;
            characterStyle = false;
            sectionStyle = false;
            styleName = null;
            number = 0;
            basedOn = STYLENUMBER_NONE;
            nextStyle = STYLENUMBER_NONE;
            hidden = false;
        }

        public void handleText(String text)
        {
            if (styleName != null)
                styleName = styleName + text;
            else
                styleName = text;
        }

        public void close() {
            int semicolon = (styleName == null) ? 0 : styleName.indexOf(';');
            if (semicolon &gt; 0)
                styleName = styleName.substring(0, semicolon);
            definedStyles.put(Integer.valueOf(number), this);
            super.close();
        }

        public boolean handleKeyword(String keyword)
        {
            if (keyword.equals(&quot;additive&quot;)) {
                additive = true;
                return true;
            }
            if (keyword.equals(&quot;shidden&quot;)) {
                hidden = true;
                return true;
            }
            return super.handleKeyword(keyword);
        }

        public boolean handleKeyword(String keyword, int parameter)
        {
            if (keyword.equals(&quot;s&quot;)) {
                characterStyle = false;
                sectionStyle = false;
                number = parameter;
            } else if (keyword.equals(&quot;cs&quot;)) {
                characterStyle = true;
                sectionStyle = false;
                number = parameter;
            } else if (keyword.equals(&quot;ds&quot;)) {
                characterStyle = false;
                sectionStyle = true;
                number = parameter;
            } else if (keyword.equals(&quot;sbasedon&quot;)) {
                basedOn = parameter;
            } else if (keyword.equals(&quot;snext&quot;)) {
                nextStyle = parameter;
            } else {
                return super.handleKeyword(keyword, parameter);
            }
            return true;
        }

        public Style realize()
        {
            Style basis = null;
            Style next = null;

            if (realizedStyle != null)
                return realizedStyle;

            if (basedOn != STYLENUMBER_NONE) {
                StyleDefiningDestination styleDest;
                styleDest = definedStyles.get(Integer.valueOf(basedOn));
                if (styleDest != null &amp;&amp; styleDest != this) {
                    basis = styleDest.realize();
                }
            }

            /* NB: Swing StyleContext doesn't allow distinct styles with
               the same name; RTF apparently does. This may confuse the
               user. */
            realizedStyle = target.addStyle(styleName, basis);

            if (characterStyle) {
                realizedStyle.addAttributes(currentTextAttributes());
                realizedStyle.addAttribute(Constants.StyleType,
                                           Constants.STCharacter);
            } else if (sectionStyle) {
                realizedStyle.addAttributes(currentSectionAttributes());
                realizedStyle.addAttribute(Constants.StyleType,
                                           Constants.STSection);
            } else { /* must be a paragraph style */
                realizedStyle.addAttributes(currentParagraphAttributes());
                realizedStyle.addAttribute(Constants.StyleType,
                                           Constants.STParagraph);
            }

            if (nextStyle != STYLENUMBER_NONE) {
                StyleDefiningDestination styleDest;
                styleDest = definedStyles.get(Integer.valueOf(nextStyle));
                if (styleDest != null) {
                    next = styleDest.realize();
                }
            }

            if (next != null)
                realizedStyle.addAttribute(Constants.StyleNext, next);
            realizedStyle.addAttribute(Constants.StyleAdditive,
                                       Boolean.valueOf(additive));
            realizedStyle.addAttribute(Constants.StyleHidden,
                                       Boolean.valueOf(hidden));

            return realizedStyle;
        }
    }
}

/** Handles the info group. Currently no info keywords are recognized
 *  so this is a subclass of DiscardingDestination. */
class InfoDestination
    extends DiscardingDestination
    implements Destination
{
}

/** RTFReader.TextHandlingDestination is an abstract RTF destination
 *  which simply tracks the attributes specified by the RTF control words
 *  in internal form and can produce acceptable AttributeSets for the
 *  current character, paragraph, and section attributes. It is up
 *  to the subclasses to determine what is done with the actual text. */
abstract class AttributeTrackingDestination implements Destination
{
    /** This is the &quot;chr&quot; element of parserState, cached for
     *  more efficient use */
    MutableAttributeSet characterAttributes;
    /** This is the &quot;pgf&quot; element of parserState, cached for
     *  more efficient use */
    MutableAttributeSet paragraphAttributes;
    /** This is the &quot;sec&quot; element of parserState, cached for
     *  more efficient use */
    MutableAttributeSet sectionAttributes;

    public AttributeTrackingDestination()
    {
        characterAttributes = rootCharacterAttributes();
        parserState.put(&quot;chr&quot;, characterAttributes);
        paragraphAttributes = rootParagraphAttributes();
        parserState.put(&quot;pgf&quot;, paragraphAttributes);
        sectionAttributes = rootSectionAttributes();
        parserState.put(&quot;sec&quot;, sectionAttributes);
    }

    abstract public void handleText(String text);

    public void handleBinaryBlob(byte[] data)
    {
        /* This should really be in TextHandlingDestination, but
         * since *nobody* does anything with binary blobs, this
         * is more convenient. */
        warning(&quot;Unexpected binary data in RTF file.&quot;);
    }

    public void begingroup()
    {
        AttributeSet characterParent = currentTextAttributes();
        AttributeSet paragraphParent = currentParagraphAttributes();
        AttributeSet sectionParent = currentSectionAttributes();

        /* It would probably be more efficient to use the
         * resolver property of the attributes set for
         * implementing rtf groups,
         * but that's needed for styles. */

        /* update the cached attribute dictionaries */
        characterAttributes = new SimpleAttributeSet();
        characterAttributes.addAttributes(characterParent);
        parserState.put(&quot;chr&quot;, characterAttributes);

        paragraphAttributes = new SimpleAttributeSet();
        paragraphAttributes.addAttributes(paragraphParent);
        parserState.put(&quot;pgf&quot;, paragraphAttributes);

        sectionAttributes = new SimpleAttributeSet();
        sectionAttributes.addAttributes(sectionParent);
        parserState.put(&quot;sec&quot;, sectionAttributes);
    }

    public void endgroup(Dictionary oldState)
    {
        characterAttributes = (MutableAttributeSet)parserState.get(&quot;chr&quot;);
        paragraphAttributes = (MutableAttributeSet)parserState.get(&quot;pgf&quot;);
        sectionAttributes   = (MutableAttributeSet)parserState.get(&quot;sec&quot;);
    }

    public void close()
    {
    }

    public boolean handleKeyword(String keyword)
    {
        if (keyword.equals(&quot;ulnone&quot;)) {
            return handleKeyword(&quot;ul&quot;, 0);
        }

        {
            RTFAttribute attr = straightforwardAttributes.get(keyword);
            if (attr != null) {
                boolean ok;

                switch(attr.domain()) {
                  case RTFAttribute.D_CHARACTER:
                    ok = attr.set(characterAttributes);
                    break;
                  case RTFAttribute.D_PARAGRAPH:
                    ok = attr.set(paragraphAttributes);
                    break;
                  case RTFAttribute.D_SECTION:
                    ok = attr.set(sectionAttributes);
                    break;
                  case RTFAttribute.D_META:
                    mockery.backing = parserState;
                    ok = attr.set(mockery);
                    mockery.backing = null;
                    break;
                  case RTFAttribute.D_DOCUMENT:
                    ok = attr.set(documentAttributes);
                    break;
                  default:
                    /* should never happen */
                    ok = false;
                    break;
                }
                if (ok)
                    return true;
            }
        }


        if (keyword.equals(&quot;plain&quot;)) {
            resetCharacterAttributes();
            return true;
        }

        if (keyword.equals(&quot;pard&quot;)) {
            resetParagraphAttributes();
            return true;
        }

        if (keyword.equals(&quot;sectd&quot;)) {
            resetSectionAttributes();
            return true;
        }

        return false;
    }

    public boolean handleKeyword(String keyword, int parameter)
    {
        boolean booleanParameter = (parameter != 0);

        if (keyword.equals(&quot;fc&quot;))
            keyword = &quot;cf&quot;; /* whatEVER, dude. */

        if (keyword.equals(&quot;f&quot;)) {
            parserState.put(keyword, Integer.valueOf(parameter));
            return true;
        }
        if (keyword.equals(&quot;cf&quot;)) {
            parserState.put(keyword, Integer.valueOf(parameter));
            return true;
        }

        {
            RTFAttribute attr = straightforwardAttributes.get(keyword);
            if (attr != null) {
                boolean ok;

                switch(attr.domain()) {
                  case RTFAttribute.D_CHARACTER:
                    ok = attr.set(characterAttributes, parameter);
                    break;
                  case RTFAttribute.D_PARAGRAPH:
                    ok = attr.set(paragraphAttributes, parameter);
                    break;
                  case RTFAttribute.D_SECTION:
                    ok = attr.set(sectionAttributes, parameter);
                    break;
                  case RTFAttribute.D_META:
                    mockery.backing = parserState;
                    ok = attr.set(mockery, parameter);
                    mockery.backing = null;
                    break;
                  case RTFAttribute.D_DOCUMENT:
                    ok = attr.set(documentAttributes, parameter);
                    break;
                  default:
                    /* should never happen */
                    ok = false;
                    break;
                }
                if (ok)
                    return true;
            }
        }

        if (keyword.equals(&quot;fs&quot;)) {
            StyleConstants.setFontSize(characterAttributes, (parameter / 2));
            return true;
        }

        /* TODO: superscript/subscript */

        if (keyword.equals(&quot;sl&quot;)) {
            if (parameter == 1000) {  /* magic value! */
                characterAttributes.removeAttribute(StyleConstants.LineSpacing);
            } else {
                /* TODO: The RTF sl attribute has special meaning if it's
                   negative. Make sure that SwingText has the same special
                   meaning, or find a way to imitate that. When SwingText
                   handles this, also recognize the slmult keyword. */
                StyleConstants.setLineSpacing(characterAttributes,
                                              parameter / 20f);
            }
            return true;
        }

        /* TODO: Other kinds of underlining */

        if (keyword.equals(&quot;tx&quot;) || keyword.equals(&quot;tb&quot;)) {
            float tabPosition = parameter / 20f;
            int tabAlignment, tabLeader;
            Number item;

            tabAlignment = TabStop.ALIGN_LEFT;
            item = (Number)(parserState.get(&quot;tab_alignment&quot;));
            if (item != null)
                tabAlignment = item.intValue();
            tabLeader = TabStop.LEAD_NONE;
            item = (Number)(parserState.get(&quot;tab_leader&quot;));
            if (item != null)
                tabLeader = item.intValue();
            if (keyword.equals(&quot;tb&quot;))
                tabAlignment = TabStop.ALIGN_BAR;

            parserState.remove(&quot;tab_alignment&quot;);
            parserState.remove(&quot;tab_leader&quot;);

            TabStop newStop = new TabStop(tabPosition, tabAlignment, tabLeader);
            Dictionary&lt;Object, Object&gt; tabs;
            Integer stopCount;

            tabs = (Dictionary&lt;Object, Object&gt;)parserState.get(&quot;_tabs&quot;);
            if (tabs == null) {
                tabs = new Hashtable&lt;Object, Object&gt;();
                parserState.put(&quot;_tabs&quot;, tabs);
                stopCount = Integer.valueOf(1);
            } else {
                stopCount = (Integer)tabs.get(&quot;stop count&quot;);
                stopCount = Integer.valueOf(1 + stopCount.intValue());
            }
            tabs.put(stopCount, newStop);
            tabs.put(&quot;stop count&quot;, stopCount);
            parserState.remove(&quot;_tabs_immutable&quot;);

            return true;
        }

        if (keyword.equals(&quot;s&quot;) &amp;&amp;
            paragraphStyles != null) {
            parserState.put(&quot;paragraphStyle&quot;, paragraphStyles[parameter]);
            return true;
        }

        if (keyword.equals(&quot;cs&quot;) &amp;&amp;
            characterStyles != null) {
            parserState.put(&quot;characterStyle&quot;, characterStyles[parameter]);
            return true;
        }

        if (keyword.equals(&quot;ds&quot;) &amp;&amp;
            sectionStyles != null) {
            parserState.put(&quot;sectionStyle&quot;, sectionStyles[parameter]);
            return true;
        }

        return false;
    }

    /** Returns a new MutableAttributeSet containing the
     *  default character attributes */
    protected MutableAttributeSet rootCharacterAttributes()
    {
        MutableAttributeSet set = new SimpleAttributeSet();

        /* TODO: default font */

        StyleConstants.setItalic(set, false);
        StyleConstants.setBold(set, false);
        StyleConstants.setUnderline(set, false);
        StyleConstants.setForeground(set, defaultColor());

        return set;
    }

    /** Returns a new MutableAttributeSet containing the
     *  default paragraph attributes */
    protected MutableAttributeSet rootParagraphAttributes()
    {
        MutableAttributeSet set = new SimpleAttributeSet();

        StyleConstants.setLeftIndent(set, 0f);
        StyleConstants.setRightIndent(set, 0f);
        StyleConstants.setFirstLineIndent(set, 0f);

        /* TODO: what should this be, really? */
        set.setResolveParent(target.getStyle(StyleContext.DEFAULT_STYLE));

        return set;
    }

    /** Returns a new MutableAttributeSet containing the
     *  default section attributes */
    protected MutableAttributeSet rootSectionAttributes()
    {
        MutableAttributeSet set = new SimpleAttributeSet();

        return set;
    }

    /**
     * Calculates the current text (character) attributes in a form suitable
     * for SwingText from the current parser state.
     *
     * @returns a new MutableAttributeSet containing the text attributes.
     */
    MutableAttributeSet currentTextAttributes()
    {
        MutableAttributeSet attributes =
            new SimpleAttributeSet(characterAttributes);
        Integer fontnum;
        Integer stateItem;

        /* figure out the font name */
        /* TODO: catch exceptions for undefined attributes,
           bad font indices, etc.? (as it stands, it is the caller's
           job to clean up after corrupt RTF) */
        fontnum = (Integer)parserState.get(&quot;f&quot;);
        /* note setFontFamily() can not handle a null font */
        String fontFamily;
        if (fontnum != null)
            fontFamily = fontTable.get(fontnum);
        else
            fontFamily = null;
        if (fontFamily != null)
            StyleConstants.setFontFamily(attributes, fontFamily);
        else
            attributes.removeAttribute(StyleConstants.FontFamily);

        if (colorTable != null) {
            stateItem = (Integer)parserState.get(&quot;cf&quot;);
            if (stateItem != null) {
                Color fg = colorTable[stateItem.intValue()];
                StyleConstants.setForeground(attributes, fg);
            } else {
                /* AttributeSet dies if you set a value to null */
                attributes.removeAttribute(StyleConstants.Foreground);
            }
        }

        if (colorTable != null) {
            stateItem = (Integer)parserState.get(&quot;cb&quot;);
            if (stateItem != null) {
                Color bg = colorTable[stateItem.intValue()];
                attributes.addAttribute(StyleConstants.Background,
                                        bg);
            } else {
                /* AttributeSet dies if you set a value to null */
                attributes.removeAttribute(StyleConstants.Background);
            }
        }

        Style characterStyle = (Style)parserState.get(&quot;characterStyle&quot;);
        if (characterStyle != null)
            attributes.setResolveParent(characterStyle);

        /* Other attributes are maintained directly in &quot;attributes&quot; */

        return attributes;
    }

    /**
     * Calculates the current paragraph attributes (with keys
     * as given in StyleConstants) from the current parser state.
     *
     * @returns a newly created MutableAttributeSet.
     * @see StyleConstants
     */
    MutableAttributeSet currentParagraphAttributes()
    {
        /* NB if there were a mutableCopy() method we should use it */
        MutableAttributeSet bld = new SimpleAttributeSet(paragraphAttributes);

        Integer stateItem;

        /*** Tab stops ***/
        TabStop tabs[];

        tabs = (TabStop[])parserState.get(&quot;_tabs_immutable&quot;);
        if (tabs == null) {
            Dictionary workingTabs = (Dictionary)parserState.get(&quot;_tabs&quot;);
            if (workingTabs != null) {
                int count = ((Integer)workingTabs.get(&quot;stop count&quot;)).intValue();
                tabs = new TabStop[count];
                for (int ix = 1; ix &lt;= count; ix ++)
                    tabs[ix-1] = (TabStop)workingTabs.get(Integer.valueOf(ix));
                parserState.put(&quot;_tabs_immutable&quot;, tabs);
            }
        }
        if (tabs != null)
            bld.addAttribute(Constants.Tabs, tabs);

        Style paragraphStyle = (Style)parserState.get(&quot;paragraphStyle&quot;);
        if (paragraphStyle != null)
            bld.setResolveParent(paragraphStyle);

        return bld;
    }

    /**
     * Calculates the current section attributes
     * from the current parser state.
     *
     * @returns a newly created MutableAttributeSet.
     */
    public AttributeSet currentSectionAttributes()
    {
        MutableAttributeSet attributes = new SimpleAttributeSet(sectionAttributes);

        Style sectionStyle = (Style)parserState.get(&quot;sectionStyle&quot;);
        if (sectionStyle != null)
            attributes.setResolveParent(sectionStyle);

        return attributes;
    }

    /** Resets the filter's internal notion of the current character
     *  attributes to their default values. Invoked to handle the
     *  \plain keyword. */
    protected void resetCharacterAttributes()
    {
        handleKeyword(&quot;f&quot;, 0);
        handleKeyword(&quot;cf&quot;, 0);

        handleKeyword(&quot;fs&quot;, 24);  /* 12 pt. */

        Enumeration&lt;RTFAttribute&gt; attributes = straightforwardAttributes.elements();
        while(attributes.hasMoreElements()) {
            RTFAttribute attr = attributes.nextElement();
            if (attr.domain() == RTFAttribute.D_CHARACTER)
                attr.setDefault(characterAttributes);
        }

        handleKeyword(&quot;sl&quot;, 1000);

        parserState.remove(&quot;characterStyle&quot;);
    }

    /** Resets the filter's internal notion of the current paragraph's
     *  attributes to their default values. Invoked to handle the
     *  \pard keyword. */
    protected void resetParagraphAttributes()
    {
        parserState.remove(&quot;_tabs&quot;);
        parserState.remove(&quot;_tabs_immutable&quot;);
        parserState.remove(&quot;paragraphStyle&quot;);

        StyleConstants.setAlignment(paragraphAttributes,
                                    StyleConstants.ALIGN_LEFT);

        Enumeration&lt;RTFAttribute&gt; attributes = straightforwardAttributes.elements();
        while(attributes.hasMoreElements()) {
            RTFAttribute attr = attributes.nextElement();
            if (attr.domain() == RTFAttribute.D_PARAGRAPH)
                attr.setDefault(characterAttributes);
        }
    }

    /** Resets the filter's internal notion of the current section's
     *  attributes to their default values. Invoked to handle the
     *  \sectd keyword. */
    protected void resetSectionAttributes()
    {
        Enumeration&lt;RTFAttribute&gt; attributes = straightforwardAttributes.elements();
        while(attributes.hasMoreElements()) {
            RTFAttribute attr = attributes.nextElement();
            if (attr.domain() == RTFAttribute.D_SECTION)
                attr.setDefault(characterAttributes);
        }

        parserState.remove(&quot;sectionStyle&quot;);
    }
}

/** RTFReader.TextHandlingDestination provides basic text handling
 *  functionality. Subclasses must implement: &lt;dl&gt;
 *  &lt;dt&gt;deliverText()&lt;dd&gt;to handle a run of text with the same
 *                       attributes
 *  &lt;dt&gt;finishParagraph()&lt;dd&gt;to end the current paragraph and
 *                           set the paragraph's attributes
 *  &lt;dt&gt;endSection()&lt;dd&gt;to end the current section
 *  &lt;/dl&gt;
 */
abstract class TextHandlingDestination
    extends AttributeTrackingDestination
    implements Destination
{
    /** &lt;code&gt;true&lt;/code&gt; if the reader has not just finished
     *  a paragraph; false upon startup */
    boolean inParagraph;

    public TextHandlingDestination()
    {
        super();
        inParagraph = false;
    }

    public void handleText(String text)
    {
        if (! inParagraph)
            beginParagraph();

        deliverText(text, currentTextAttributes());
    }

    abstract void deliverText(String text, AttributeSet characterAttributes);

    public void close()
    {
        if (inParagraph)
            endParagraph();

        super.close();
    }

    public boolean handleKeyword(String keyword)
    {
        if (keyword.equals(&quot;\r&quot;) || keyword.equals(&quot;\n&quot;)) {
            keyword = &quot;par&quot;;
        }

        if (keyword.equals(&quot;par&quot;)) {
//          warnings.println(&quot;Ending paragraph.&quot;);
            endParagraph();
            return true;
        }

        if (keyword.equals(&quot;sect&quot;)) {
//          warnings.println(&quot;Ending section.&quot;);
            endSection();
            return true;
        }

        return super.handleKeyword(keyword);
    }

    protected void beginParagraph()
    {
        inParagraph = true;
    }

    protected void endParagraph()
    {
        AttributeSet pgfAttributes = currentParagraphAttributes();
        AttributeSet chrAttributes = currentTextAttributes();
        finishParagraph(pgfAttributes, chrAttributes);
        inParagraph = false;
    }

    abstract void finishParagraph(AttributeSet pgfA, AttributeSet chrA);

    abstract void endSection();
}

/** RTFReader.DocumentDestination is a concrete subclass of
 *  TextHandlingDestination which appends the text to the
 *  StyledDocument given by the &lt;code&gt;target&lt;/code&gt; ivar of the
 *  containing RTFReader.
 */
class DocumentDestination
    extends TextHandlingDestination
    implements Destination
{
    public void deliverText(String text, AttributeSet characterAttributes)
    {
        try {
            target.insertString(target.getLength(),
                                text,
                                currentTextAttributes());
        } catch (BadLocationException ble) {
            /* This shouldn't be able to happen, of course */
            /* TODO is InternalError the correct error to throw? */
            throw new InternalError(ble.getMessage(), ble);
        }
    }

    public void finishParagraph(AttributeSet pgfAttributes,
                                AttributeSet chrAttributes)
    {
        int pgfEndPosition = target.getLength();
        try {
            target.insertString(pgfEndPosition, &quot;\n&quot;, chrAttributes);
            target.setParagraphAttributes(pgfEndPosition, 1, pgfAttributes, true);
        } catch (BadLocationException ble) {
            /* This shouldn't be able to happen, of course */
            /* TODO is InternalError the correct error to throw? */
            throw new InternalError(ble.getMessage(), ble);
        }
    }

    public void endSection()
    {
        /* If we implemented sections, we'd end 'em here */
    }
}

}
</pre>
</body>
</html>
