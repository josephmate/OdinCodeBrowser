<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.text;

import java.io.Serializable;

/**
 * A TabSet is comprised of many TabStops. It offers methods for locating the
 * closest TabStop to a given position and finding all the potential TabStops.
 * It is also immutable.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @author  Scott Violet
 */
public class TabSet implements Serializable
{
    /** TabStops this TabSet contains. */
    private TabStop[]              tabs;
    /**
     * Since this class is immutable the hash code could be
     * calculated once. MAX_VALUE means that it was not initialized
     * yet. Hash code shouldn't has MAX_VALUE value.
     */
    private int hashCode = Integer.MAX_VALUE;

    /**
     * Creates and returns an instance of TabSet. The array of Tabs
     * passed in must be sorted in ascending order.
     */
    public TabSet(TabStop[] tabs) {
        // PENDING(sky): If this becomes a problem, make it sort.
        if(tabs != null) {
            int          tabCount = tabs.length;

            this.tabs = new TabStop[tabCount];
            System.arraycopy(tabs, 0, this.tabs, 0, tabCount);
        }
        else
            this.tabs = null;
    }

    /**
     * Returns the number of Tab instances the receiver contains.
     */
    public int getTabCount() {
        return (tabs == null) ? 0 : tabs.length;
    }

    /**
     * Returns the TabStop at index &lt;code&gt;index&lt;/code&gt;. This will throw an
     * IllegalArgumentException if &lt;code&gt;index&lt;/code&gt; is outside the range
     * of tabs.
     */
    public TabStop getTab(int index) {
        int          numTabs = getTabCount();

        if(index &lt; 0 || index &gt;= numTabs)
            throw new IllegalArgumentException(index +
                                              &quot; is outside the range of tabs&quot;);
        return tabs[index];
    }

    /**
     * Returns the Tab instance after &lt;code&gt;location&lt;/code&gt;. This will
     * return null if there are no tabs after &lt;code&gt;location&lt;/code&gt;.
     */
    public TabStop getTabAfter(float location) {
        int     index = getTabIndexAfter(location);

        return (index == -1) ? null : tabs[index];
    }

    /**
     * @return the index of the TabStop &lt;code&gt;tab&lt;/code&gt;, or -1 if
     * &lt;code&gt;tab&lt;/code&gt; is not contained in the receiver.
     */
    public int getTabIndex(TabStop tab) {
        for(int counter = getTabCount() - 1; counter &gt;= 0; counter--)
            // should this use .equals?
            if(getTab(counter) == tab)
                return counter;
        return -1;
    }

    /**
     * Returns the index of the Tab to be used after &lt;code&gt;location&lt;/code&gt;.
     * This will return -1 if there are no tabs after &lt;code&gt;location&lt;/code&gt;.
     */
    public int getTabIndexAfter(float location) {
        int     current, min, max;

        min = 0;
        max = getTabCount();
        while(min != max) {
            current = (max - min) / 2 + min;
            if(location &gt; tabs[current].getPosition()) {
                if(min == current)
                    min = max;
                else
                    min = current;
            }
            else {
                if(current == 0 || location &gt; tabs[current - 1].getPosition())
                    return current;
                max = current;
            }
        }
        // no tabs after the passed in location.
        return -1;
    }

    /**
     * Indicates whether this &lt;code&gt;TabSet&lt;/code&gt; is equal to another one.
     * @param o the &lt;code&gt;TabSet&lt;/code&gt; instance which this instance
     *  should be compared to.
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is the instance of
     * &lt;code&gt;TabSet&lt;/code&gt;, has the same number of &lt;code&gt;TabStop&lt;/code&gt;s
     * and they are all equal, &lt;code&gt;false&lt;/code&gt; otherwise.
     *
     * @since 1.5
     */
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if (o instanceof TabSet) {
            TabSet ts = (TabSet) o;
            int count = getTabCount();
            if (ts.getTabCount() != count) {
                return false;
            }
            for (int i=0; i &lt; count; i++) {
                TabStop ts1 = getTab(i);
                TabStop ts2 = ts.getTab(i);
                if ((ts1 == null &amp;&amp; ts2 != null) ||
                        (ts1 != null &amp;&amp; !getTab(i).equals(ts.getTab(i)))) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Returns a hashcode for this set of TabStops.
     * @return  a hashcode value for this set of TabStops.
     *
     * @since 1.5
     */
    public int hashCode() {
        if (hashCode == Integer.MAX_VALUE) {
            hashCode = 0;
            int len = getTabCount();
            for (int i = 0; i &lt; len; i++) {
                TabStop ts = getTab(i);
                hashCode ^= ts != null ? getTab(i).hashCode() : 0;
            }
            if (hashCode == Integer.MAX_VALUE) {
                hashCode -= 1;
            }
        }
        return hashCode;
    }

    /**
     * Returns the string representation of the set of tabs.
     */
    public String toString() {
        int            tabCount = getTabCount();
        StringBuilder buffer = new StringBuilder(&quot;[ &quot;);

        for(int counter = 0; counter &lt; tabCount; counter++) {
            if(counter &gt; 0)
                buffer.append(&quot; - &quot;);
            buffer.append(getTab(counter).toString());
        }
        buffer.append(&quot; ]&quot;);
        return buffer.toString();
    }
}
</pre>
</body>
</html>
