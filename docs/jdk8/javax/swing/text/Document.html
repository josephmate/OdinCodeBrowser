<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import javax.swing.event.*;

/**
 * &lt;p&gt;
 * The &lt;code&gt;Document&lt;/code&gt; is a container for text that serves
 * as the model for swing text components.  The goal for this
 * interface is to scale from very simple needs (a plain text textfield)
 * to complex needs (an HTML or XML document, for example).
 *
 * &lt;p&gt;&lt;b&gt;&lt;font size=+1&gt;Content&lt;/font&gt;&lt;/b&gt;
 * &lt;p&gt;
 * At the simplest level, text can be
 * modeled as a linear sequence of characters. To support
 * internationalization, the Swing text model uses
 * &lt;a href=&quot;http://www.unicode.org/&quot;&gt;unicode&lt;/a&gt; characters.
 * The sequence of characters displayed in a text component is
 * generally referred to as the component's &lt;em&gt;content&lt;/em&gt;.
 * &lt;p&gt;
 * To refer to locations within the sequence, the coordinates
 * used are the location between two characters.  As the diagram
 * below shows, a location in a text document can be referred to
 * as a position, or an offset. This position is zero-based.
 * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/Document-coord.gif&quot;
 * alt=&quot;The following text describes this graphic.&quot;&gt;
 * &lt;p&gt;
 * In the example, if the content of a document is the
 * sequence &quot;The quick brown fox,&quot; as shown in the preceding diagram,
 * the location just before the word &quot;The&quot; is 0, and the location after
 * the word &quot;The&quot; and before the whitespace that follows it is 3.
 * The entire sequence of characters in the sequence &quot;The&quot; is called a
 * &lt;em&gt;range&lt;/em&gt;.
 * &lt;p&gt;The following methods give access to the character data
 * that makes up the content.
 * &lt;ul&gt;
 * &lt;li&gt;{@link #getLength()}
 * &lt;li&gt;{@link #getText(int, int)}
 * &lt;li&gt;{@link #getText(int, int, javax.swing.text.Segment)}
 * &lt;/ul&gt;
 * &lt;p&gt;&lt;b&gt;&lt;font size=+1&gt;Structure&lt;/font&gt;&lt;/b&gt;
 * &lt;p&gt;
 * Text is rarely represented simply as featureless content. Rather,
 * text typically has some sort of structure associated with it.
 * Exactly what structure is modeled is up to a particular Document
 * implementation.  It might be as simple as no structure (i.e. a
 * simple text field), or it might be something like diagram below.
 * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/Document-structure.gif&quot;
 * alt=&quot;Diagram shows Book-&gt;Chapter-&gt;Paragraph&quot;&gt;
 * &lt;p&gt;
 * The unit of structure (i.e. a node of the tree) is referred to
 * by the &lt;a href=&quot;Element.html&quot;&gt;Element&lt;/a&gt; interface.  Each Element
 * can be tagged with a set of attributes.  These attributes
 * (name/value pairs) are defined by the
 * &lt;a href=&quot;AttributeSet.html&quot;&gt;AttributeSet&lt;/a&gt; interface.
 * &lt;p&gt;The following methods give access to the document structure.
 * &lt;ul&gt;
 * &lt;li&gt;{@link #getDefaultRootElement()}
 * &lt;li&gt;{@link #getRootElements()}
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;&lt;font size=+1&gt;Mutations&lt;/font&gt;&lt;/b&gt;
 * &lt;p&gt;
 * All documents need to be able to add and remove simple text.
 * Typically, text is inserted and removed via gestures from
 * a keyboard or a mouse.  What effect the insertion or removal
 * has upon the document structure is entirely up to the
 * implementation of the document.
 * &lt;p&gt;The following methods are related to mutation of the
 * document content:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #insertString(int, java.lang.String, javax.swing.text.AttributeSet)}
 * &lt;li&gt;{@link #remove(int, int)}
 * &lt;li&gt;{@link #createPosition(int)}
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;&lt;font size=+1&gt;Notification&lt;/font&gt;&lt;/b&gt;
 * &lt;p&gt;
 * Mutations to the &lt;code&gt;Document&lt;/code&gt; must be communicated to
 * interested observers.  The notification of change follows the event model
 * guidelines that are specified for JavaBeans.  In the JavaBeans
 * event model, once an event notification is dispatched, all listeners
 * must be notified before any further mutations occur to the source
 * of the event.  Further, order of delivery is not guaranteed.
 * &lt;p&gt;
 * Notification is provided as two separate events,
 * &lt;a href=&quot;../event/DocumentEvent.html&quot;&gt;DocumentEvent&lt;/a&gt;, and
 * &lt;a href=&quot;../event/UndoableEditEvent.html&quot;&gt;UndoableEditEvent&lt;/a&gt;.
 * If a mutation is made to a &lt;code&gt;Document&lt;/code&gt; through its api,
 * a &lt;code&gt;DocumentEvent&lt;/code&gt; will be sent to all of the registered
 * &lt;code&gt;DocumentListeners&lt;/code&gt;.  If the &lt;code&gt;Document&lt;/code&gt;
 * implementation supports undo/redo capabilities, an
 * &lt;code&gt;UndoableEditEvent&lt;/code&gt; will be sent
 * to all of the registered &lt;code&gt;UndoableEditListener&lt;/code&gt;s.
 * If an undoable edit is undone, a &lt;code&gt;DocumentEvent&lt;/code&gt; should be
 * fired from the Document to indicate it has changed again.
 * In this case however, there should be no &lt;code&gt;UndoableEditEvent&lt;/code&gt;
 * generated since that edit is actually the source of the change
 * rather than a mutation to the &lt;code&gt;Document&lt;/code&gt; made through its
 * api.
 * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/Document-notification.gif&quot;
 * alt=&quot;The preceding text describes this graphic.&quot;&gt;
 * &lt;p&gt;
 * Referring to the above diagram, suppose that the component shown
 * on the left mutates the document object represented by the blue
 * rectangle. The document responds by dispatching a DocumentEvent to
 * both component views and sends an UndoableEditEvent to the listening
 * logic, which maintains a history buffer.
 * &lt;p&gt;
 * Now suppose that the component shown on the right mutates the same
 * document.  Again, the document dispatches a DocumentEvent to both
 * component views and sends an UndoableEditEvent to the listening logic
 * that is maintaining the history buffer.
 * &lt;p&gt;
 * If the history buffer is then rolled back (i.e. the last UndoableEdit
 * undone), a DocumentEvent is sent to both views, causing both of them to
 * reflect the undone mutation to the document (that is, the
 * removal of the right component's mutation). If the history buffer again
 * rolls back another change, another DocumentEvent is sent to both views,
 * causing them to reflect the undone mutation to the document -- that is,
 * the removal of the left component's mutation.
 * &lt;p&gt;
 * The methods related to observing mutations to the document are:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;a href=&quot;#addDocumentListener(javax.swing.event.DocumentListener)&quot;&gt;addDocumentListener(DocumentListener)&lt;/a&gt;
 * &lt;li&gt;&lt;a href=&quot;#removeDocumentListener(javax.swing.event.DocumentListener)&quot;&gt;removeDocumentListener(DocumentListener)&lt;/a&gt;
 * &lt;li&gt;&lt;a href=&quot;#addUndoableEditListener(javax.swing.event.UndoableEditListener)&quot;&gt;addUndoableEditListener(UndoableEditListener)&lt;/a&gt;
 * &lt;li&gt;&lt;a href=&quot;#removeUndoableEditListener(javax.swing.event.UndoableEditListener)&quot;&gt;removeUndoableEditListener(UndoableEditListener)&lt;/a&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;&lt;font size=+1&gt;Properties&lt;/font&gt;&lt;/b&gt;
 * &lt;p&gt;
 * Document implementations will generally have some set of properties
 * associated with them at runtime.  Two well known properties are the
 * &lt;a href=&quot;#StreamDescriptionProperty&quot;&gt;StreamDescriptionProperty&lt;/a&gt;,
 * which can be used to describe where the &lt;code&gt;Document&lt;/code&gt; came from,
 * and the &lt;a href=&quot;#TitleProperty&quot;&gt;TitleProperty&lt;/a&gt;, which can be used to
 * name the &lt;code&gt;Document&lt;/code&gt;.  The methods related to the properties are:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #getProperty(java.lang.Object)}
 * &lt;li&gt;{@link #putProperty(java.lang.Object, java.lang.Object)}
 * &lt;/ul&gt;
 *
 * &lt;p&gt;For more information on the &lt;code&gt;Document&lt;/code&gt; class, see
 * &lt;a href=&quot;http://java.sun.com/products/jfc/tsc&quot;&gt;The Swing Connection&lt;/a&gt;
 * and most particularly the article,
 * &lt;a href=&quot;http://java.sun.com/products/jfc/tsc/articles/text/element_interface&quot;&gt;
 * The Element Interface&lt;/a&gt;.
 *
 * @author  Timothy Prinzing
 *
 * @see javax.swing.event.DocumentEvent
 * @see javax.swing.event.DocumentListener
 * @see javax.swing.event.UndoableEditEvent
 * @see javax.swing.event.UndoableEditListener
 * @see Element
 * @see Position
 * @see AttributeSet
 */
public interface Document {

    /**
     * Returns number of characters of content currently
     * in the document.
     *
     * @return number of characters &amp;gt;= 0
     */
    public int getLength();

    /**
     * Registers the given observer to begin receiving notifications
     * when changes are made to the document.
     *
     * @param listener the observer to register
     * @see Document#removeDocumentListener
     */
    public void addDocumentListener(DocumentListener listener);

    /**
     * Unregisters the given observer from the notification list
     * so it will no longer receive change updates.
     *
     * @param listener the observer to register
     * @see Document#addDocumentListener
     */
    public void removeDocumentListener(DocumentListener listener);

    /**
     * Registers the given observer to begin receiving notifications
     * when undoable edits are made to the document.
     *
     * @param listener the observer to register
     * @see javax.swing.event.UndoableEditEvent
     */
    public void addUndoableEditListener(UndoableEditListener listener);

    /**
     * Unregisters the given observer from the notification list
     * so it will no longer receive updates.
     *
     * @param listener the observer to register
     * @see javax.swing.event.UndoableEditEvent
     */
    public void removeUndoableEditListener(UndoableEditListener listener);

    /**
     * Gets the properties associated with the document.
     *
     * @param key a non-&lt;code&gt;null&lt;/code&gt; property key
     * @return the properties
     * @see #putProperty(Object, Object)
     */
    public Object getProperty(Object key);

    /**
     * Associates a property with the document.  Two standard
     * property keys provided are: &lt;a href=&quot;#StreamDescriptionProperty&quot;&gt;
     * &lt;code&gt;StreamDescriptionProperty&lt;/code&gt;&lt;/a&gt; and
     * &lt;a href=&quot;#TitleProperty&quot;&gt;&lt;code&gt;TitleProperty&lt;/code&gt;&lt;/a&gt;.
     * Other properties, such as author, may also be defined.
     *
     * @param key the non-&lt;code&gt;null&lt;/code&gt; property key
     * @param value the property value
     * @see #getProperty(Object)
     */
    public void putProperty(Object key, Object value);

    /**
     * Removes a portion of the content of the document.
     * This will cause a DocumentEvent of type
     * DocumentEvent.EventType.REMOVE to be sent to the
     * registered DocumentListeners, unless an exception
     * is thrown.  The notification will be sent to the
     * listeners by calling the removeUpdate method on the
     * DocumentListeners.
     * &lt;p&gt;
     * To ensure reasonable behavior in the face
     * of concurrency, the event is dispatched after the
     * mutation has occurred. This means that by the time a
     * notification of removal is dispatched, the document
     * has already been updated and any marks created by
     * &lt;code&gt;createPosition&lt;/code&gt; have already changed.
     * For a removal, the end of the removal range is collapsed
     * down to the start of the range, and any marks in the removal
     * range are collapsed down to the start of the range.
     * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/Document-remove.gif&quot;
     *  alt=&quot;Diagram shows removal of 'quick' from 'The quick brown fox.'&quot;&gt;
     * &lt;p&gt;
     * If the Document structure changed as result of the removal,
     * the details of what Elements were inserted and removed in
     * response to the change will also be contained in the generated
     * DocumentEvent. It is up to the implementation of a Document
     * to decide how the structure should change in response to a
     * remove.
     * &lt;p&gt;
     * If the Document supports undo/redo, an UndoableEditEvent will
     * also be generated.
     *
     * @param offs  the offset from the beginning &amp;gt;= 0
     * @param len   the number of characters to remove &amp;gt;= 0
     * @exception BadLocationException  some portion of the removal range
     *   was not a valid part of the document.  The location in the exception
     *   is the first bad position encountered.
     * @see javax.swing.event.DocumentEvent
     * @see javax.swing.event.DocumentListener
     * @see javax.swing.event.UndoableEditEvent
     * @see javax.swing.event.UndoableEditListener
     */
    public void remove(int offs, int len) throws BadLocationException;

    /**
     * Inserts a string of content.  This will cause a DocumentEvent
     * of type DocumentEvent.EventType.INSERT to be sent to the
     * registered DocumentListers, unless an exception is thrown.
     * The DocumentEvent will be delivered by calling the
     * insertUpdate method on the DocumentListener.
     * The offset and length of the generated DocumentEvent
     * will indicate what change was actually made to the Document.
     * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/Document-insert.gif&quot;
     *  alt=&quot;Diagram shows insertion of 'quick' in 'The quick brown fox'&quot;&gt;
     * &lt;p&gt;
     * If the Document structure changed as result of the insertion,
     * the details of what Elements were inserted and removed in
     * response to the change will also be contained in the generated
     * DocumentEvent.  It is up to the implementation of a Document
     * to decide how the structure should change in response to an
     * insertion.
     * &lt;p&gt;
     * If the Document supports undo/redo, an UndoableEditEvent will
     * also be generated.
     *
     * @param offset  the offset into the document to insert the content &amp;gt;= 0.
     *    All positions that track change at or after the given location
     *    will move.
     * @param str    the string to insert
     * @param a      the attributes to associate with the inserted
     *   content.  This may be null if there are no attributes.
     * @exception BadLocationException  the given insert position is not a valid
     * position within the document
     * @see javax.swing.event.DocumentEvent
     * @see javax.swing.event.DocumentListener
     * @see javax.swing.event.UndoableEditEvent
     * @see javax.swing.event.UndoableEditListener
     */
    public void insertString(int offset, String str, AttributeSet a) throws BadLocationException;

    /**
     * Fetches the text contained within the given portion
     * of the document.
     *
     * @param offset  the offset into the document representing the desired
     *   start of the text &amp;gt;= 0
     * @param length  the length of the desired string &amp;gt;= 0
     * @return the text, in a String of length &amp;gt;= 0
     * @exception BadLocationException  some portion of the given range
     *   was not a valid part of the document.  The location in the exception
     *   is the first bad position encountered.
     */
    public String getText(int offset, int length) throws BadLocationException;

    /**
     * Fetches the text contained within the given portion
     * of the document.
     * &lt;p&gt;
     * If the partialReturn property on the txt parameter is false, the
     * data returned in the Segment will be the entire length requested and
     * may or may not be a copy depending upon how the data was stored.
     * If the partialReturn property is true, only the amount of text that
     * can be returned without creating a copy is returned.  Using partial
     * returns will give better performance for situations where large
     * parts of the document are being scanned.  The following is an example
     * of using the partial return to access the entire document:
     *
     * &lt;pre&gt;&lt;code&gt;
     *
     * &amp;nbsp; int nleft = doc.getDocumentLength();
     * &amp;nbsp; Segment text = new Segment();
     * &amp;nbsp; int offs = 0;
     * &amp;nbsp; text.setPartialReturn(true);
     * &amp;nbsp; while (nleft &amp;gt; 0) {
     * &amp;nbsp;     doc.getText(offs, nleft, text);
     * &amp;nbsp;     // do someting with text
     * &amp;nbsp;     nleft -= text.count;
     * &amp;nbsp;     offs += text.count;
     * &amp;nbsp; }
     *
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param offset  the offset into the document representing the desired
     *   start of the text &amp;gt;= 0
     * @param length  the length of the desired string &amp;gt;= 0
     * @param txt the Segment object to return the text in
     *
     * @exception BadLocationException  Some portion of the given range
     *   was not a valid part of the document.  The location in the exception
     *   is the first bad position encountered.
     */
    public void getText(int offset, int length, Segment txt) throws BadLocationException;

    /**
     * Returns a position that represents the start of the document.  The
     * position returned can be counted on to track change and stay
     * located at the beginning of the document.
     *
     * @return the position
     */
    public Position getStartPosition();

    /**
     * Returns a position that represents the end of the document.  The
     * position returned can be counted on to track change and stay
     * located at the end of the document.
     *
     * @return the position
     */
    public Position getEndPosition();

    /**
     * This method allows an application to mark a place in
     * a sequence of character content. This mark can then be
     * used to tracks change as insertions and removals are made
     * in the content. The policy is that insertions always
     * occur prior to the current position (the most common case)
     * unless the insertion location is zero, in which case the
     * insertion is forced to a position that follows the
     * original position.
     *
     * @param offs  the offset from the start of the document &amp;gt;= 0
     * @return the position
     * @exception BadLocationException  if the given position does not
     *   represent a valid location in the associated document
     */
    public Position createPosition(int offs) throws BadLocationException;

    /**
     * Returns all of the root elements that are defined.
     * &lt;p&gt;
     * Typically there will be only one document structure, but the interface
     * supports building an arbitrary number of structural projections over the
     * text data. The document can have multiple root elements to support
     * multiple document structures.  Some examples might be:
     * &lt;/p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;Text direction.
     * &lt;li&gt;Lexical token streams.
     * &lt;li&gt;Parse trees.
     * &lt;li&gt;Conversions to formats other than the native format.
     * &lt;li&gt;Modification specifications.
     * &lt;li&gt;Annotations.
     * &lt;/ul&gt;
     *
     * @return the root element
     */
    public Element[] getRootElements();

    /**
     * Returns the root element that views should be based upon,
     * unless some other mechanism for assigning views to element
     * structures is provided.
     *
     * @return the root element
     */
    public Element getDefaultRootElement();

    /**
     * Allows the model to be safely rendered in the presence
     * of concurrency, if the model supports being updated asynchronously.
     * The given runnable will be executed in a way that allows it
     * to safely read the model with no changes while the runnable
     * is being executed.  The runnable itself may &lt;em&gt;not&lt;/em&gt;
     * make any mutations.
     *
     * @param r a &lt;code&gt;Runnable&lt;/code&gt; used to render the model
     */
    public void render(Runnable r);

    /**
     * The property name for the description of the stream
     * used to initialize the document.  This should be used
     * if the document was initialized from a stream and
     * anything is known about the stream.
     */
    public static final String StreamDescriptionProperty = &quot;stream&quot;;

    /**
     * The property name for the title of the document, if
     * there is one.
     */
    public static final String TitleProperty = &quot;title&quot;;


}
</pre>
</body>
</html>
