<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jdk.internal.org.objectweb.asm.util;

import java.io.FileInputStream;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;

import jdk.internal.org.objectweb.asm.Attribute;
import jdk.internal.org.objectweb.asm.ClassReader;
import jdk.internal.org.objectweb.asm.Handle;
import jdk.internal.org.objectweb.asm.Label;
import jdk.internal.org.objectweb.asm.Opcodes;
import jdk.internal.org.objectweb.asm.Type;
import jdk.internal.org.objectweb.asm.TypePath;

/**
 * A {@link Printer} that prints the ASM code to generate the classes if visits.
 *
 * @author Eric Bruneton
 */
public class ASMifier extends Printer {

    /**
     * The name of the visitor variable in the produced code.
     */
    protected final String name;

    /**
     * Identifier of the annotation visitor variable in the produced code.
     */
    protected final int id;

    /**
     * The label names. This map associates String values to Label keys. It is
     * used only in ASMifierMethodVisitor.
     */
    protected Map&lt;Label, String&gt; labelNames;

    /**
     * Pseudo access flag used to distinguish class access flags.
     */
    private static final int ACCESS_CLASS = 262144;

    /**
     * Pseudo access flag used to distinguish field access flags.
     */
    private static final int ACCESS_FIELD = 524288;

    /**
     * Pseudo access flag used to distinguish inner class flags.
     */
    private static final int ACCESS_INNER = 1048576;

    /**
     * Constructs a new {@link ASMifier}. &lt;i&gt;Subclasses must not use this
     * constructor&lt;/i&gt;. Instead, they must use the
     * {@link #ASMifier(int, String, int)} version.
     *
     * @throws IllegalStateException
     *             If a subclass calls this constructor.
     */
    public ASMifier() {
        this(Opcodes.ASM5, &quot;cw&quot;, 0);
        if (getClass() != ASMifier.class) {
            throw new IllegalStateException();
        }
    }

    /**
     * Constructs a new {@link ASMifier}.
     *
     * @param api
     *            the ASM API version implemented by this class. Must be one of
     *            {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     * @param name
     *            the name of the visitor variable in the produced code.
     * @param id
     *            identifier of the annotation visitor variable in the produced
     *            code.
     */
    protected ASMifier(final int api, final String name, final int id) {
        super(api);
        this.name = name;
        this.id = id;
    }

    /**
     * Prints the ASM source code to generate the given class to the standard
     * output.
     * &lt;p&gt;
     * Usage: ASMifier [-debug] &amp;lt;binary class name or class file name&amp;gt;
     *
     * @param args
     *            the command line arguments.
     *
     * @throws Exception
     *             if the class cannot be found, or if an IO exception occurs.
     */
    public static void main(final String[] args) throws Exception {
        int i = 0;
        int flags = ClassReader.SKIP_DEBUG;

        boolean ok = true;
        if (args.length &lt; 1 || args.length &gt; 2) {
            ok = false;
        }
        if (ok &amp;&amp; &quot;-debug&quot;.equals(args[0])) {
            i = 1;
            flags = 0;
            if (args.length != 2) {
                ok = false;
            }
        }
        if (!ok) {
            System.err
                    .println(&quot;Prints the ASM code to generate the given class.&quot;);
            System.err.println(&quot;Usage: ASMifier [-debug] &quot;
                    + &quot;&lt;fully qualified class name or class file name&gt;&quot;);
            return;
        }
        ClassReader cr;
        if (args[i].endsWith(&quot;.class&quot;) || args[i].indexOf('\\') &gt; -1
                || args[i].indexOf('/') &gt; -1) {
            cr = new ClassReader(new FileInputStream(args[i]));
        } else {
            cr = new ClassReader(args[i]);
        }
        cr.accept(new TraceClassVisitor(null, new ASMifier(), new PrintWriter(
                System.out)), flags);
    }

    // ------------------------------------------------------------------------
    // Classes
    // ------------------------------------------------------------------------

    @Override
    public void visit(final int version, final int access, final String name,
            final String signature, final String superName,
            final String[] interfaces) {
        String simpleName;
        int n = name.lastIndexOf('/');
        if (n == -1) {
            simpleName = name;
        } else {
            text.add(&quot;package asm.&quot; + name.substring(0, n).replace('/', '.')
                    + &quot;;\n&quot;);
            simpleName = name.substring(n + 1);
        }
        text.add(&quot;import java.util.*;\n&quot;);
        text.add(&quot;import jdk.internal.org.objectweb.asm.*;\n&quot;);
        text.add(&quot;import jdk.internal.org.objectweb.asm.attrs.*;\n&quot;);
        text.add(&quot;public class &quot; + simpleName + &quot;Dump implements Opcodes {\n\n&quot;);
        text.add(&quot;public static byte[] dump () throws Exception {\n\n&quot;);
        text.add(&quot;ClassWriter cw = new ClassWriter(0);\n&quot;);
        text.add(&quot;FieldVisitor fv;\n&quot;);
        text.add(&quot;MethodVisitor mv;\n&quot;);
        text.add(&quot;AnnotationVisitor av0;\n\n&quot;);

        buf.setLength(0);
        buf.append(&quot;cw.visit(&quot;);
        switch (version) {
        case Opcodes.V1_1:
            buf.append(&quot;V1_1&quot;);
            break;
        case Opcodes.V1_2:
            buf.append(&quot;V1_2&quot;);
            break;
        case Opcodes.V1_3:
            buf.append(&quot;V1_3&quot;);
            break;
        case Opcodes.V1_4:
            buf.append(&quot;V1_4&quot;);
            break;
        case Opcodes.V1_5:
            buf.append(&quot;V1_5&quot;);
            break;
        case Opcodes.V1_6:
            buf.append(&quot;V1_6&quot;);
            break;
        case Opcodes.V1_7:
            buf.append(&quot;V1_7&quot;);
            break;
        default:
            buf.append(version);
            break;
        }
        buf.append(&quot;, &quot;);
        appendAccess(access | ACCESS_CLASS);
        buf.append(&quot;, &quot;);
        appendConstant(name);
        buf.append(&quot;, &quot;);
        appendConstant(signature);
        buf.append(&quot;, &quot;);
        appendConstant(superName);
        buf.append(&quot;, &quot;);
        if (interfaces != null &amp;&amp; interfaces.length &gt; 0) {
            buf.append(&quot;new String[] {&quot;);
            for (int i = 0; i &lt; interfaces.length; ++i) {
                buf.append(i == 0 ? &quot; &quot; : &quot;, &quot;);
                appendConstant(interfaces[i]);
            }
            buf.append(&quot; }&quot;);
        } else {
            buf.append(&quot;null&quot;);
        }
        buf.append(&quot;);\n\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitSource(final String file, final String debug) {
        buf.setLength(0);
        buf.append(&quot;cw.visitSource(&quot;);
        appendConstant(file);
        buf.append(&quot;, &quot;);
        appendConstant(debug);
        buf.append(&quot;);\n\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitOuterClass(final String owner, final String name,
            final String desc) {
        buf.setLength(0);
        buf.append(&quot;cw.visitOuterClass(&quot;);
        appendConstant(owner);
        buf.append(&quot;, &quot;);
        appendConstant(name);
        buf.append(&quot;, &quot;);
        appendConstant(desc);
        buf.append(&quot;);\n\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public ASMifier visitClassAnnotation(final String desc,
            final boolean visible) {
        return visitAnnotation(desc, visible);
    }

    @Override
    public ASMifier visitClassTypeAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
        return visitTypeAnnotation(typeRef, typePath, desc, visible);
    }

    @Override
    public void visitClassAttribute(final Attribute attr) {
        visitAttribute(attr);
    }

    @Override
    public void visitInnerClass(final String name, final String outerName,
            final String innerName, final int access) {
        buf.setLength(0);
        buf.append(&quot;cw.visitInnerClass(&quot;);
        appendConstant(name);
        buf.append(&quot;, &quot;);
        appendConstant(outerName);
        buf.append(&quot;, &quot;);
        appendConstant(innerName);
        buf.append(&quot;, &quot;);
        appendAccess(access | ACCESS_INNER);
        buf.append(&quot;);\n\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public ASMifier visitField(final int access, final String name,
            final String desc, final String signature, final Object value) {
        buf.setLength(0);
        buf.append(&quot;{\n&quot;);
        buf.append(&quot;fv = cw.visitField(&quot;);
        appendAccess(access | ACCESS_FIELD);
        buf.append(&quot;, &quot;);
        appendConstant(name);
        buf.append(&quot;, &quot;);
        appendConstant(desc);
        buf.append(&quot;, &quot;);
        appendConstant(signature);
        buf.append(&quot;, &quot;);
        appendConstant(value);
        buf.append(&quot;);\n&quot;);
        text.add(buf.toString());
        ASMifier a = createASMifier(&quot;fv&quot;, 0);
        text.add(a.getText());
        text.add(&quot;}\n&quot;);
        return a;
    }

    @Override
    public ASMifier visitMethod(final int access, final String name,
            final String desc, final String signature, final String[] exceptions) {
        buf.setLength(0);
        buf.append(&quot;{\n&quot;);
        buf.append(&quot;mv = cw.visitMethod(&quot;);
        appendAccess(access);
        buf.append(&quot;, &quot;);
        appendConstant(name);
        buf.append(&quot;, &quot;);
        appendConstant(desc);
        buf.append(&quot;, &quot;);
        appendConstant(signature);
        buf.append(&quot;, &quot;);
        if (exceptions != null &amp;&amp; exceptions.length &gt; 0) {
            buf.append(&quot;new String[] {&quot;);
            for (int i = 0; i &lt; exceptions.length; ++i) {
                buf.append(i == 0 ? &quot; &quot; : &quot;, &quot;);
                appendConstant(exceptions[i]);
            }
            buf.append(&quot; }&quot;);
        } else {
            buf.append(&quot;null&quot;);
        }
        buf.append(&quot;);\n&quot;);
        text.add(buf.toString());
        ASMifier a = createASMifier(&quot;mv&quot;, 0);
        text.add(a.getText());
        text.add(&quot;}\n&quot;);
        return a;
    }

    @Override
    public void visitClassEnd() {
        text.add(&quot;cw.visitEnd();\n\n&quot;);
        text.add(&quot;return cw.toByteArray();\n&quot;);
        text.add(&quot;}\n&quot;);
        text.add(&quot;}\n&quot;);
    }

    // ------------------------------------------------------------------------
    // Annotations
    // ------------------------------------------------------------------------

    @Override
    public void visit(final String name, final Object value) {
        buf.setLength(0);
        buf.append(&quot;av&quot;).append(id).append(&quot;.visit(&quot;);
        appendConstant(buf, name);
        buf.append(&quot;, &quot;);
        appendConstant(buf, value);
        buf.append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitEnum(final String name, final String desc,
            final String value) {
        buf.setLength(0);
        buf.append(&quot;av&quot;).append(id).append(&quot;.visitEnum(&quot;);
        appendConstant(buf, name);
        buf.append(&quot;, &quot;);
        appendConstant(buf, desc);
        buf.append(&quot;, &quot;);
        appendConstant(buf, value);
        buf.append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public ASMifier visitAnnotation(final String name, final String desc) {
        buf.setLength(0);
        buf.append(&quot;{\n&quot;);
        buf.append(&quot;AnnotationVisitor av&quot;).append(id + 1).append(&quot; = av&quot;);
        buf.append(id).append(&quot;.visitAnnotation(&quot;);
        appendConstant(buf, name);
        buf.append(&quot;, &quot;);
        appendConstant(buf, desc);
        buf.append(&quot;);\n&quot;);
        text.add(buf.toString());
        ASMifier a = createASMifier(&quot;av&quot;, id + 1);
        text.add(a.getText());
        text.add(&quot;}\n&quot;);
        return a;
    }

    @Override
    public ASMifier visitArray(final String name) {
        buf.setLength(0);
        buf.append(&quot;{\n&quot;);
        buf.append(&quot;AnnotationVisitor av&quot;).append(id + 1).append(&quot; = av&quot;);
        buf.append(id).append(&quot;.visitArray(&quot;);
        appendConstant(buf, name);
        buf.append(&quot;);\n&quot;);
        text.add(buf.toString());
        ASMifier a = createASMifier(&quot;av&quot;, id + 1);
        text.add(a.getText());
        text.add(&quot;}\n&quot;);
        return a;
    }

    @Override
    public void visitAnnotationEnd() {
        buf.setLength(0);
        buf.append(&quot;av&quot;).append(id).append(&quot;.visitEnd();\n&quot;);
        text.add(buf.toString());
    }

    // ------------------------------------------------------------------------
    // Fields
    // ------------------------------------------------------------------------

    @Override
    public ASMifier visitFieldAnnotation(final String desc,
            final boolean visible) {
        return visitAnnotation(desc, visible);
    }

    @Override
    public ASMifier visitFieldTypeAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
        return visitTypeAnnotation(typeRef, typePath, desc, visible);
    }

    @Override
    public void visitFieldAttribute(final Attribute attr) {
        visitAttribute(attr);
    }

    @Override
    public void visitFieldEnd() {
        buf.setLength(0);
        buf.append(name).append(&quot;.visitEnd();\n&quot;);
        text.add(buf.toString());
    }

    // ------------------------------------------------------------------------
    // Methods
    // ------------------------------------------------------------------------

    @Override
    public void visitParameter(String parameterName, int access) {
        buf.setLength(0);
        buf.append(name).append(&quot;.visitParameter(&quot;);
        appendString(buf, parameterName);
        buf.append(&quot;, &quot;);
        appendAccess(access);
        text.add(buf.append(&quot;);\n&quot;).toString());
    }

    @Override
    public ASMifier visitAnnotationDefault() {
        buf.setLength(0);
        buf.append(&quot;{\n&quot;).append(&quot;av0 = &quot;).append(name)
                .append(&quot;.visitAnnotationDefault();\n&quot;);
        text.add(buf.toString());
        ASMifier a = createASMifier(&quot;av&quot;, 0);
        text.add(a.getText());
        text.add(&quot;}\n&quot;);
        return a;
    }

    @Override
    public ASMifier visitMethodAnnotation(final String desc,
            final boolean visible) {
        return visitAnnotation(desc, visible);
    }

    @Override
    public ASMifier visitMethodTypeAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
        return visitTypeAnnotation(typeRef, typePath, desc, visible);
    }

    @Override
    public ASMifier visitParameterAnnotation(final int parameter,
            final String desc, final boolean visible) {
        buf.setLength(0);
        buf.append(&quot;{\n&quot;).append(&quot;av0 = &quot;).append(name)
                .append(&quot;.visitParameterAnnotation(&quot;).append(parameter)
                .append(&quot;, &quot;);
        appendConstant(desc);
        buf.append(&quot;, &quot;).append(visible).append(&quot;);\n&quot;);
        text.add(buf.toString());
        ASMifier a = createASMifier(&quot;av&quot;, 0);
        text.add(a.getText());
        text.add(&quot;}\n&quot;);
        return a;
    }

    @Override
    public void visitMethodAttribute(final Attribute attr) {
        visitAttribute(attr);
    }

    @Override
    public void visitCode() {
        text.add(name + &quot;.visitCode();\n&quot;);
    }

    @Override
    public void visitFrame(final int type, final int nLocal,
            final Object[] local, final int nStack, final Object[] stack) {
        buf.setLength(0);
        switch (type) {
        case Opcodes.F_NEW:
        case Opcodes.F_FULL:
            declareFrameTypes(nLocal, local);
            declareFrameTypes(nStack, stack);
            if (type == Opcodes.F_NEW) {
                buf.append(name).append(&quot;.visitFrame(Opcodes.F_NEW, &quot;);
            } else {
                buf.append(name).append(&quot;.visitFrame(Opcodes.F_FULL, &quot;);
            }
            buf.append(nLocal).append(&quot;, new Object[] {&quot;);
            appendFrameTypes(nLocal, local);
            buf.append(&quot;}, &quot;).append(nStack).append(&quot;, new Object[] {&quot;);
            appendFrameTypes(nStack, stack);
            buf.append('}');
            break;
        case Opcodes.F_APPEND:
            declareFrameTypes(nLocal, local);
            buf.append(name).append(&quot;.visitFrame(Opcodes.F_APPEND,&quot;)
                    .append(nLocal).append(&quot;, new Object[] {&quot;);
            appendFrameTypes(nLocal, local);
            buf.append(&quot;}, 0, null&quot;);
            break;
        case Opcodes.F_CHOP:
            buf.append(name).append(&quot;.visitFrame(Opcodes.F_CHOP,&quot;)
                    .append(nLocal).append(&quot;, null, 0, null&quot;);
            break;
        case Opcodes.F_SAME:
            buf.append(name).append(
                    &quot;.visitFrame(Opcodes.F_SAME, 0, null, 0, null&quot;);
            break;
        case Opcodes.F_SAME1:
            declareFrameTypes(1, stack);
            buf.append(name).append(
                    &quot;.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] {&quot;);
            appendFrameTypes(1, stack);
            buf.append('}');
            break;
        }
        buf.append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitInsn(final int opcode) {
        buf.setLength(0);
        buf.append(name).append(&quot;.visitInsn(&quot;).append(OPCODES[opcode])
                .append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitIntInsn(final int opcode, final int operand) {
        buf.setLength(0);
        buf.append(name)
                .append(&quot;.visitIntInsn(&quot;)
                .append(OPCODES[opcode])
                .append(&quot;, &quot;)
                .append(opcode == Opcodes.NEWARRAY ? TYPES[operand] : Integer
                        .toString(operand)).append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitVarInsn(final int opcode, final int var) {
        buf.setLength(0);
        buf.append(name).append(&quot;.visitVarInsn(&quot;).append(OPCODES[opcode])
                .append(&quot;, &quot;).append(var).append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitTypeInsn(final int opcode, final String type) {
        buf.setLength(0);
        buf.append(name).append(&quot;.visitTypeInsn(&quot;).append(OPCODES[opcode])
                .append(&quot;, &quot;);
        appendConstant(type);
        buf.append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitFieldInsn(final int opcode, final String owner,
            final String name, final String desc) {
        buf.setLength(0);
        buf.append(this.name).append(&quot;.visitFieldInsn(&quot;)
                .append(OPCODES[opcode]).append(&quot;, &quot;);
        appendConstant(owner);
        buf.append(&quot;, &quot;);
        appendConstant(name);
        buf.append(&quot;, &quot;);
        appendConstant(desc);
        buf.append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Deprecated
    @Override
    public void visitMethodInsn(final int opcode, final String owner,
            final String name, final String desc) {
        if (api &gt;= Opcodes.ASM5) {
            super.visitMethodInsn(opcode, owner, name, desc);
            return;
        }
        doVisitMethodInsn(opcode, owner, name, desc,
                opcode == Opcodes.INVOKEINTERFACE);
    }

    @Override
    public void visitMethodInsn(final int opcode, final String owner,
            final String name, final String desc, final boolean itf) {
        if (api &lt; Opcodes.ASM5) {
            super.visitMethodInsn(opcode, owner, name, desc, itf);
            return;
        }
        doVisitMethodInsn(opcode, owner, name, desc, itf);
    }

    private void doVisitMethodInsn(final int opcode, final String owner,
            final String name, final String desc, final boolean itf) {
        buf.setLength(0);
        buf.append(this.name).append(&quot;.visitMethodInsn(&quot;)
                .append(OPCODES[opcode]).append(&quot;, &quot;);
        appendConstant(owner);
        buf.append(&quot;, &quot;);
        appendConstant(name);
        buf.append(&quot;, &quot;);
        appendConstant(desc);
        buf.append(&quot;, &quot;);
        buf.append(itf ? &quot;true&quot; : &quot;false&quot;);
        buf.append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitInvokeDynamicInsn(String name, String desc, Handle bsm,
            Object... bsmArgs) {
        buf.setLength(0);
        buf.append(this.name).append(&quot;.visitInvokeDynamicInsn(&quot;);
        appendConstant(name);
        buf.append(&quot;, &quot;);
        appendConstant(desc);
        buf.append(&quot;, &quot;);
        appendConstant(bsm);
        buf.append(&quot;, new Object[]{&quot;);
        for (int i = 0; i &lt; bsmArgs.length; ++i) {
            appendConstant(bsmArgs[i]);
            if (i != bsmArgs.length - 1) {
                buf.append(&quot;, &quot;);
            }
        }
        buf.append(&quot;});\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitJumpInsn(final int opcode, final Label label) {
        buf.setLength(0);
        declareLabel(label);
        buf.append(name).append(&quot;.visitJumpInsn(&quot;).append(OPCODES[opcode])
                .append(&quot;, &quot;);
        appendLabel(label);
        buf.append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitLabel(final Label label) {
        buf.setLength(0);
        declareLabel(label);
        buf.append(name).append(&quot;.visitLabel(&quot;);
        appendLabel(label);
        buf.append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitLdcInsn(final Object cst) {
        buf.setLength(0);
        buf.append(name).append(&quot;.visitLdcInsn(&quot;);
        appendConstant(cst);
        buf.append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitIincInsn(final int var, final int increment) {
        buf.setLength(0);
        buf.append(name).append(&quot;.visitIincInsn(&quot;).append(var).append(&quot;, &quot;)
                .append(increment).append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitTableSwitchInsn(final int min, final int max,
            final Label dflt, final Label... labels) {
        buf.setLength(0);
        for (int i = 0; i &lt; labels.length; ++i) {
            declareLabel(labels[i]);
        }
        declareLabel(dflt);

        buf.append(name).append(&quot;.visitTableSwitchInsn(&quot;).append(min)
                .append(&quot;, &quot;).append(max).append(&quot;, &quot;);
        appendLabel(dflt);
        buf.append(&quot;, new Label[] {&quot;);
        for (int i = 0; i &lt; labels.length; ++i) {
            buf.append(i == 0 ? &quot; &quot; : &quot;, &quot;);
            appendLabel(labels[i]);
        }
        buf.append(&quot; });\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitLookupSwitchInsn(final Label dflt, final int[] keys,
            final Label[] labels) {
        buf.setLength(0);
        for (int i = 0; i &lt; labels.length; ++i) {
            declareLabel(labels[i]);
        }
        declareLabel(dflt);

        buf.append(name).append(&quot;.visitLookupSwitchInsn(&quot;);
        appendLabel(dflt);
        buf.append(&quot;, new int[] {&quot;);
        for (int i = 0; i &lt; keys.length; ++i) {
            buf.append(i == 0 ? &quot; &quot; : &quot;, &quot;).append(keys[i]);
        }
        buf.append(&quot; }, new Label[] {&quot;);
        for (int i = 0; i &lt; labels.length; ++i) {
            buf.append(i == 0 ? &quot; &quot; : &quot;, &quot;);
            appendLabel(labels[i]);
        }
        buf.append(&quot; });\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitMultiANewArrayInsn(final String desc, final int dims) {
        buf.setLength(0);
        buf.append(name).append(&quot;.visitMultiANewArrayInsn(&quot;);
        appendConstant(desc);
        buf.append(&quot;, &quot;).append(dims).append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public ASMifier visitInsnAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
        return visitTypeAnnotation(&quot;visitInsnAnnotation&quot;, typeRef, typePath,
                desc, visible);
    }

    @Override
    public void visitTryCatchBlock(final Label start, final Label end,
            final Label handler, final String type) {
        buf.setLength(0);
        declareLabel(start);
        declareLabel(end);
        declareLabel(handler);
        buf.append(name).append(&quot;.visitTryCatchBlock(&quot;);
        appendLabel(start);
        buf.append(&quot;, &quot;);
        appendLabel(end);
        buf.append(&quot;, &quot;);
        appendLabel(handler);
        buf.append(&quot;, &quot;);
        appendConstant(type);
        buf.append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public ASMifier visitTryCatchAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
        return visitTypeAnnotation(&quot;visitTryCatchAnnotation&quot;, typeRef,
                typePath, desc, visible);
    }

    @Override
    public void visitLocalVariable(final String name, final String desc,
            final String signature, final Label start, final Label end,
            final int index) {
        buf.setLength(0);
        buf.append(this.name).append(&quot;.visitLocalVariable(&quot;);
        appendConstant(name);
        buf.append(&quot;, &quot;);
        appendConstant(desc);
        buf.append(&quot;, &quot;);
        appendConstant(signature);
        buf.append(&quot;, &quot;);
        appendLabel(start);
        buf.append(&quot;, &quot;);
        appendLabel(end);
        buf.append(&quot;, &quot;).append(index).append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public Printer visitLocalVariableAnnotation(int typeRef, TypePath typePath,
            Label[] start, Label[] end, int[] index, String desc,
            boolean visible) {
        buf.setLength(0);
        buf.append(&quot;{\n&quot;).append(&quot;av0 = &quot;).append(name)
                .append(&quot;.visitLocalVariableAnnotation(&quot;);
        buf.append(typeRef);
        buf.append(&quot;, TypePath.fromString(\&quot;&quot;).append(typePath).append(&quot;\&quot;), &quot;);
        buf.append(&quot;new Label[] {&quot;);
        for (int i = 0; i &lt; start.length; ++i) {
            buf.append(i == 0 ? &quot; &quot; : &quot;, &quot;);
            appendLabel(start[i]);
        }
        buf.append(&quot; }, new Label[] {&quot;);
        for (int i = 0; i &lt; end.length; ++i) {
            buf.append(i == 0 ? &quot; &quot; : &quot;, &quot;);
            appendLabel(end[i]);
        }
        buf.append(&quot; }, new int[] {&quot;);
        for (int i = 0; i &lt; index.length; ++i) {
            buf.append(i == 0 ? &quot; &quot; : &quot;, &quot;).append(index[i]);
        }
        buf.append(&quot; }, &quot;);
        appendConstant(desc);
        buf.append(&quot;, &quot;).append(visible).append(&quot;);\n&quot;);
        text.add(buf.toString());
        ASMifier a = createASMifier(&quot;av&quot;, 0);
        text.add(a.getText());
        text.add(&quot;}\n&quot;);
        return a;
    }

    @Override
    public void visitLineNumber(final int line, final Label start) {
        buf.setLength(0);
        buf.append(name).append(&quot;.visitLineNumber(&quot;).append(line).append(&quot;, &quot;);
        appendLabel(start);
        buf.append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitMaxs(final int maxStack, final int maxLocals) {
        buf.setLength(0);
        buf.append(name).append(&quot;.visitMaxs(&quot;).append(maxStack).append(&quot;, &quot;)
                .append(maxLocals).append(&quot;);\n&quot;);
        text.add(buf.toString());
    }

    @Override
    public void visitMethodEnd() {
        buf.setLength(0);
        buf.append(name).append(&quot;.visitEnd();\n&quot;);
        text.add(buf.toString());
    }

    // ------------------------------------------------------------------------
    // Common methods
    // ------------------------------------------------------------------------

    public ASMifier visitAnnotation(final String desc, final boolean visible) {
        buf.setLength(0);
        buf.append(&quot;{\n&quot;).append(&quot;av0 = &quot;).append(name)
                .append(&quot;.visitAnnotation(&quot;);
        appendConstant(desc);
        buf.append(&quot;, &quot;).append(visible).append(&quot;);\n&quot;);
        text.add(buf.toString());
        ASMifier a = createASMifier(&quot;av&quot;, 0);
        text.add(a.getText());
        text.add(&quot;}\n&quot;);
        return a;
    }

    public ASMifier visitTypeAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
        return visitTypeAnnotation(&quot;visitTypeAnnotation&quot;, typeRef, typePath,
                desc, visible);
    }

    public ASMifier visitTypeAnnotation(final String method, final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
        buf.setLength(0);
        buf.append(&quot;{\n&quot;).append(&quot;av0 = &quot;).append(name).append(&quot;.&quot;)
                .append(method).append(&quot;(&quot;);
        buf.append(typeRef);
        buf.append(&quot;, TypePath.fromString(\&quot;&quot;).append(typePath).append(&quot;\&quot;), &quot;);
        appendConstant(desc);
        buf.append(&quot;, &quot;).append(visible).append(&quot;);\n&quot;);
        text.add(buf.toString());
        ASMifier a = createASMifier(&quot;av&quot;, 0);
        text.add(a.getText());
        text.add(&quot;}\n&quot;);
        return a;
    }

    public void visitAttribute(final Attribute attr) {
        buf.setLength(0);
        buf.append(&quot;// ATTRIBUTE &quot;).append(attr.type).append('\n');
        if (attr instanceof ASMifiable) {
            if (labelNames == null) {
                labelNames = new HashMap&lt;Label, String&gt;();
            }
            buf.append(&quot;{\n&quot;);
            ((ASMifiable) attr).asmify(buf, &quot;attr&quot;, labelNames);
            buf.append(name).append(&quot;.visitAttribute(attr);\n&quot;);
            buf.append(&quot;}\n&quot;);
        }
        text.add(buf.toString());
    }

    // ------------------------------------------------------------------------
    // Utility methods
    // ------------------------------------------------------------------------

    protected ASMifier createASMifier(final String name, final int id) {
        return new ASMifier(Opcodes.ASM5, name, id);
    }

    /**
     * Appends a string representation of the given access modifiers to
     * {@link #buf buf}.
     *
     * @param access
     *            some access modifiers.
     */
    void appendAccess(final int access) {
        boolean first = true;
        if ((access &amp; Opcodes.ACC_PUBLIC) != 0) {
            buf.append(&quot;ACC_PUBLIC&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_PRIVATE) != 0) {
            buf.append(&quot;ACC_PRIVATE&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_PROTECTED) != 0) {
            buf.append(&quot;ACC_PROTECTED&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_FINAL) != 0) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            buf.append(&quot;ACC_FINAL&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_STATIC) != 0) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            buf.append(&quot;ACC_STATIC&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_SYNCHRONIZED) != 0) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            if ((access &amp; ACCESS_CLASS) == 0) {
                buf.append(&quot;ACC_SYNCHRONIZED&quot;);
            } else {
                buf.append(&quot;ACC_SUPER&quot;);
            }
            first = false;
        }
        if ((access &amp; Opcodes.ACC_VOLATILE) != 0
                &amp;&amp; (access &amp; ACCESS_FIELD) != 0) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            buf.append(&quot;ACC_VOLATILE&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_BRIDGE) != 0 &amp;&amp; (access &amp; ACCESS_CLASS) == 0
                &amp;&amp; (access &amp; ACCESS_FIELD) == 0) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            buf.append(&quot;ACC_BRIDGE&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_VARARGS) != 0 &amp;&amp; (access &amp; ACCESS_CLASS) == 0
                &amp;&amp; (access &amp; ACCESS_FIELD) == 0) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            buf.append(&quot;ACC_VARARGS&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_TRANSIENT) != 0
                &amp;&amp; (access &amp; ACCESS_FIELD) != 0) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            buf.append(&quot;ACC_TRANSIENT&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_NATIVE) != 0 &amp;&amp; (access &amp; ACCESS_CLASS) == 0
                &amp;&amp; (access &amp; ACCESS_FIELD) == 0) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            buf.append(&quot;ACC_NATIVE&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_ENUM) != 0
                &amp;&amp; ((access &amp; ACCESS_CLASS) != 0
                        || (access &amp; ACCESS_FIELD) != 0 || (access &amp; ACCESS_INNER) != 0)) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            buf.append(&quot;ACC_ENUM&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_ANNOTATION) != 0
                &amp;&amp; ((access &amp; ACCESS_CLASS) != 0 || (access &amp; ACCESS_INNER) != 0)) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            buf.append(&quot;ACC_ANNOTATION&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_ABSTRACT) != 0) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            buf.append(&quot;ACC_ABSTRACT&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_INTERFACE) != 0) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            buf.append(&quot;ACC_INTERFACE&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_STRICT) != 0) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            buf.append(&quot;ACC_STRICT&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_SYNTHETIC) != 0) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            buf.append(&quot;ACC_SYNTHETIC&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            buf.append(&quot;ACC_DEPRECATED&quot;);
            first = false;
        }
        if ((access &amp; Opcodes.ACC_MANDATED) != 0) {
            if (!first) {
                buf.append(&quot; + &quot;);
            }
            buf.append(&quot;ACC_MANDATED&quot;);
            first = false;
        }
        if (first) {
            buf.append('0');
        }
    }

    /**
     * Appends a string representation of the given constant to the given
     * buffer.
     *
     * @param cst
     *            an {@link Integer}, {@link Float}, {@link Long},
     *            {@link Double} or {@link String} object. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    protected void appendConstant(final Object cst) {
        appendConstant(buf, cst);
    }

    /**
     * Appends a string representation of the given constant to the given
     * buffer.
     *
     * @param buf
     *            a string buffer.
     * @param cst
     *            an {@link Integer}, {@link Float}, {@link Long},
     *            {@link Double} or {@link String} object. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    static void appendConstant(final StringBuffer buf, final Object cst) {
        if (cst == null) {
            buf.append(&quot;null&quot;);
        } else if (cst instanceof String) {
            appendString(buf, (String) cst);
        } else if (cst instanceof Type) {
            buf.append(&quot;Type.getType(\&quot;&quot;);
            buf.append(((Type) cst).getDescriptor());
            buf.append(&quot;\&quot;)&quot;);
        } else if (cst instanceof Handle) {
            buf.append(&quot;new Handle(&quot;);
            Handle h = (Handle) cst;
            buf.append(&quot;Opcodes.&quot;).append(HANDLE_TAG[h.getTag()])
                    .append(&quot;, \&quot;&quot;);
            buf.append(h.getOwner()).append(&quot;\&quot;, \&quot;&quot;);
            buf.append(h.getName()).append(&quot;\&quot;, \&quot;&quot;);
            buf.append(h.getDesc()).append(&quot;\&quot;)&quot;);
        } else if (cst instanceof Byte) {
            buf.append(&quot;new Byte((byte)&quot;).append(cst).append(')');
        } else if (cst instanceof Boolean) {
            buf.append(((Boolean) cst).booleanValue() ? &quot;Boolean.TRUE&quot;
                    : &quot;Boolean.FALSE&quot;);
        } else if (cst instanceof Short) {
            buf.append(&quot;new Short((short)&quot;).append(cst).append(')');
        } else if (cst instanceof Character) {
            int c = ((Character) cst).charValue();
            buf.append(&quot;new Character((char)&quot;).append(c).append(')');
        } else if (cst instanceof Integer) {
            buf.append(&quot;new Integer(&quot;).append(cst).append(')');
        } else if (cst instanceof Float) {
            buf.append(&quot;new Float(\&quot;&quot;).append(cst).append(&quot;\&quot;)&quot;);
        } else if (cst instanceof Long) {
            buf.append(&quot;new Long(&quot;).append(cst).append(&quot;L)&quot;);
        } else if (cst instanceof Double) {
            buf.append(&quot;new Double(\&quot;&quot;).append(cst).append(&quot;\&quot;)&quot;);
        } else if (cst instanceof byte[]) {
            byte[] v = (byte[]) cst;
            buf.append(&quot;new byte[] {&quot;);
            for (int i = 0; i &lt; v.length; i++) {
                buf.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(v[i]);
            }
            buf.append('}');
        } else if (cst instanceof boolean[]) {
            boolean[] v = (boolean[]) cst;
            buf.append(&quot;new boolean[] {&quot;);
            for (int i = 0; i &lt; v.length; i++) {
                buf.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(v[i]);
            }
            buf.append('}');
        } else if (cst instanceof short[]) {
            short[] v = (short[]) cst;
            buf.append(&quot;new short[] {&quot;);
            for (int i = 0; i &lt; v.length; i++) {
                buf.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(&quot;(short)&quot;).append(v[i]);
            }
            buf.append('}');
        } else if (cst instanceof char[]) {
            char[] v = (char[]) cst;
            buf.append(&quot;new char[] {&quot;);
            for (int i = 0; i &lt; v.length; i++) {
                buf.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(&quot;(char)&quot;)
                        .append((int) v[i]);
            }
            buf.append('}');
        } else if (cst instanceof int[]) {
            int[] v = (int[]) cst;
            buf.append(&quot;new int[] {&quot;);
            for (int i = 0; i &lt; v.length; i++) {
                buf.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(v[i]);
            }
            buf.append('}');
        } else if (cst instanceof long[]) {
            long[] v = (long[]) cst;
            buf.append(&quot;new long[] {&quot;);
            for (int i = 0; i &lt; v.length; i++) {
                buf.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(v[i]).append('L');
            }
            buf.append('}');
        } else if (cst instanceof float[]) {
            float[] v = (float[]) cst;
            buf.append(&quot;new float[] {&quot;);
            for (int i = 0; i &lt; v.length; i++) {
                buf.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(v[i]).append('f');
            }
            buf.append('}');
        } else if (cst instanceof double[]) {
            double[] v = (double[]) cst;
            buf.append(&quot;new double[] {&quot;);
            for (int i = 0; i &lt; v.length; i++) {
                buf.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(v[i]).append('d');
            }
            buf.append('}');
        }
    }

    private void declareFrameTypes(final int n, final Object[] o) {
        for (int i = 0; i &lt; n; ++i) {
            if (o[i] instanceof Label) {
                declareLabel((Label) o[i]);
            }
        }
    }

    private void appendFrameTypes(final int n, final Object[] o) {
        for (int i = 0; i &lt; n; ++i) {
            if (i &gt; 0) {
                buf.append(&quot;, &quot;);
            }
            if (o[i] instanceof String) {
                appendConstant(o[i]);
            } else if (o[i] instanceof Integer) {
                switch (((Integer) o[i]).intValue()) {
                case 0:
                    buf.append(&quot;Opcodes.TOP&quot;);
                    break;
                case 1:
                    buf.append(&quot;Opcodes.INTEGER&quot;);
                    break;
                case 2:
                    buf.append(&quot;Opcodes.FLOAT&quot;);
                    break;
                case 3:
                    buf.append(&quot;Opcodes.DOUBLE&quot;);
                    break;
                case 4:
                    buf.append(&quot;Opcodes.LONG&quot;);
                    break;
                case 5:
                    buf.append(&quot;Opcodes.NULL&quot;);
                    break;
                case 6:
                    buf.append(&quot;Opcodes.UNINITIALIZED_THIS&quot;);
                    break;
                }
            } else {
                appendLabel((Label) o[i]);
            }
        }
    }

    /**
     * Appends a declaration of the given label to {@link #buf buf}. This
     * declaration is of the form &quot;Label lXXX = new Label();&quot;. Does nothing if
     * the given label has already been declared.
     *
     * @param l
     *            a label.
     */
    protected void declareLabel(final Label l) {
        if (labelNames == null) {
            labelNames = new HashMap&lt;Label, String&gt;();
        }
        String name = labelNames.get(l);
        if (name == null) {
            name = &quot;l&quot; + labelNames.size();
            labelNames.put(l, name);
            buf.append(&quot;Label &quot;).append(name).append(&quot; = new Label();\n&quot;);
        }
    }

    /**
     * Appends the name of the given label to {@link #buf buf}. The given label
     * &lt;i&gt;must&lt;/i&gt; already have a name. One way to ensure this is to always call
     * {@link #declareLabel declared} before calling this method.
     *
     * @param l
     *            a label.
     */
    protected void appendLabel(final Label l) {
        buf.append(labelNames.get(l));
    }
}
</pre>
</body>
</html>
