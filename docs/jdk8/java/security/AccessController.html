<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;

import sun.security.util.Debug;
import sun.reflect.CallerSensitive;
import sun.reflect.Reflection;

/**
 * &lt;p&gt; The AccessController class is used for access control operations
 * and decisions.
 *
 * &lt;p&gt; More specifically, the AccessController class is used for
 * three purposes:
 *
 * &lt;ul&gt;
 * &lt;li&gt; to decide whether an access to a critical system
 * resource is to be allowed or denied, based on the security policy
 * currently in effect,
 * &lt;li&gt;to mark code as being &quot;privileged&quot;, thus affecting subsequent
 * access determinations, and
 * &lt;li&gt;to obtain a &quot;snapshot&quot; of the current calling context so
 * access-control decisions from a different context can be made with
 * respect to the saved context. &lt;/ul&gt;
 *
 * &lt;p&gt; The {@link #checkPermission(Permission) checkPermission} method
 * determines whether the access request indicated by a specified
 * permission should be granted or denied. A sample call appears
 * below. In this example, {@code checkPermission} will determine
 * whether or not to grant &quot;read&quot; access to the file named &quot;testFile&quot; in
 * the &quot;/temp&quot; directory.
 *
 * &lt;pre&gt;
 *
 * FilePermission perm = new FilePermission(&quot;/temp/testFile&quot;, &quot;read&quot;);
 * AccessController.checkPermission(perm);
 *
 * &lt;/pre&gt;
 *
 * &lt;p&gt; If a requested access is allowed,
 * {@code checkPermission} returns quietly. If denied, an
 * AccessControlException is
 * thrown. AccessControlException can also be thrown if the requested
 * permission is of an incorrect type or contains an invalid value.
 * Such information is given whenever possible.
 *
 * Suppose the current thread traversed m callers, in the order of caller 1
 * to caller 2 to caller m. Then caller m invoked the
 * {@code checkPermission} method.
 * The {@code checkPermission} method determines whether access
 * is granted or denied based on the following algorithm:
 *
 *  &lt;pre&gt; {@code
 * for (int i = m; i &gt; 0; i--) {
 *
 *     if (caller i's domain does not have the permission)
 *         throw AccessControlException
 *
 *     else if (caller i is marked as privileged) {
 *         if (a context was specified in the call to doPrivileged)
 *             context.checkPermission(permission)
 *         if (limited permissions were specified in the call to doPrivileged) {
 *             for (each limited permission) {
 *                 if (the limited permission implies the requested permission)
 *                     return;
 *             }
 *         } else
 *             return;
 *     }
 * }
 *
 * // Next, check the context inherited when the thread was created.
 * // Whenever a new thread is created, the AccessControlContext at
 * // that time is stored and associated with the new thread, as the
 * // &quot;inherited&quot; context.
 *
 * inheritedContext.checkPermission(permission);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt; A caller can be marked as being &quot;privileged&quot;
 * (see {@link #doPrivileged(PrivilegedAction) doPrivileged} and below).
 * When making access control decisions, the {@code checkPermission}
 * method stops checking if it reaches a caller that
 * was marked as &quot;privileged&quot; via a {@code doPrivileged}
 * call without a context argument (see below for information about a
 * context argument). If that caller's domain has the
 * specified permission and at least one limiting permission argument (if any)
 * implies the requested permission, no further checking is done and
 * {@code checkPermission}
 * returns quietly, indicating that the requested access is allowed.
 * If that domain does not have the specified permission, an exception
 * is thrown, as usual. If the caller's domain had the specified permission
 * but it was not implied by any limiting permission arguments given in the call
 * to {@code doPrivileged} then the permission checking continues
 * until there are no more callers or another {@code doPrivileged}
 * call matches the requested permission and returns normally.
 *
 * &lt;p&gt; The normal use of the &quot;privileged&quot; feature is as follows. If you
 * don't need to return a value from within the &quot;privileged&quot; block, do
 * the following:
 *
 *  &lt;pre&gt; {@code
 * somemethod() {
 *     ...normal code here...
 *     AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
 *         public Void run() {
 *             // privileged code goes here, for example:
 *             System.loadLibrary(&quot;awt&quot;);
 *             return null; // nothing to return
 *         }
 *     });
 *     ...normal code here...
 * }}&lt;/pre&gt;
 *
 * &lt;p&gt;
 * PrivilegedAction is an interface with a single method, named
 * {@code run}.
 * The above example shows creation of an implementation
 * of that interface; a concrete implementation of the
 * {@code run} method is supplied.
 * When the call to {@code doPrivileged} is made, an
 * instance of the PrivilegedAction implementation is passed
 * to it. The {@code doPrivileged} method calls the
 * {@code run} method from the PrivilegedAction
 * implementation after enabling privileges, and returns the
 * {@code run} method's return value as the
 * {@code doPrivileged} return value (which is
 * ignored in this example).
 *
 * &lt;p&gt; If you need to return a value, you can do something like the following:
 *
 *  &lt;pre&gt; {@code
 * somemethod() {
 *     ...normal code here...
 *     String user = AccessController.doPrivileged(
 *         new PrivilegedAction&lt;String&gt;() {
 *         public String run() {
 *             return System.getProperty(&quot;user.name&quot;);
 *             }
 *         });
 *     ...normal code here...
 * }}&lt;/pre&gt;
 *
 * &lt;p&gt;If the action performed in your {@code run} method could
 * throw a &quot;checked&quot; exception (those listed in the {@code throws} clause
 * of a method), then you need to use the
 * {@code PrivilegedExceptionAction} interface instead of the
 * {@code PrivilegedAction} interface:
 *
 *  &lt;pre&gt; {@code
 * somemethod() throws FileNotFoundException {
 *     ...normal code here...
 *     try {
 *         FileInputStream fis = AccessController.doPrivileged(
 *         new PrivilegedExceptionAction&lt;FileInputStream&gt;() {
 *             public FileInputStream run() throws FileNotFoundException {
 *                 return new FileInputStream(&quot;someFile&quot;);
 *             }
 *         });
 *     } catch (PrivilegedActionException e) {
 *         // e.getException() should be an instance of FileNotFoundException,
 *         // as only &quot;checked&quot; exceptions will be &quot;wrapped&quot; in a
 *         // PrivilegedActionException.
 *         throw (FileNotFoundException) e.getException();
 *     }
 *     ...normal code here...
 *  }}&lt;/pre&gt;
 *
 * &lt;p&gt; Be *very* careful in your use of the &quot;privileged&quot; construct, and
 * always remember to make the privileged code section as small as possible.
 * You can pass {@code Permission} arguments to further limit the
 * scope of the &quot;privilege&quot; (see below).
 *
 *
 * &lt;p&gt; Note that {@code checkPermission} always performs security checks
 * within the context of the currently executing thread.
 * Sometimes a security check that should be made within a given context
 * will actually need to be done from within a
 * &lt;i&gt;different&lt;/i&gt; context (for example, from within a worker thread).
 * The {@link #getContext() getContext} method and
 * AccessControlContext class are provided
 * for this situation. The {@code getContext} method takes a &quot;snapshot&quot;
 * of the current calling context, and places
 * it in an AccessControlContext object, which it returns. A sample call is
 * the following:
 *
 * &lt;pre&gt;
 *
 * AccessControlContext acc = AccessController.getContext()
 *
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * AccessControlContext itself has a {@code checkPermission} method
 * that makes access decisions based on the context &lt;i&gt;it&lt;/i&gt; encapsulates,
 * rather than that of the current execution thread.
 * Code within a different context can thus call that method on the
 * previously-saved AccessControlContext object. A sample call is the
 * following:
 *
 * &lt;pre&gt;
 *
 * acc.checkPermission(permission)
 *
 * &lt;/pre&gt;
 *
 * &lt;p&gt; There are also times where you don't know a priori which permissions
 * to check the context against. In these cases you can use the
 * doPrivileged method that takes a context. You can also limit the scope
 * of the privileged code by passing additional {@code Permission}
 * parameters.
 *
 *  &lt;pre&gt; {@code
 * somemethod() {
 *     AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
 *         public Object run() {
 *             // Code goes here. Any permission checks within this
 *             // run method will require that the intersection of the
 *             // caller's protection domain and the snapshot's
 *             // context have the desired permission. If a requested
 *             // permission is not implied by the limiting FilePermission
 *             // argument then checking of the thread continues beyond the
 *             // caller of doPrivileged.
 *         }
 *     }, acc, new FilePermission(&quot;/temp/*&quot;, read));
 *     ...normal code here...
 * }}&lt;/pre&gt;
 * &lt;p&gt; Passing a limiting {@code Permission} argument of an instance of
 * {@code AllPermission} is equivalent to calling the equivalent
 * {@code doPrivileged} method without limiting {@code Permission}
 * arguments. Passing a zero length array of {@code Permission} disables
 * the code privileges so that checking always continues beyond the caller of
 * that {@code doPrivileged} method.
 *
 * @see AccessControlContext
 *
 * @author Li Gong
 * @author Roland Schemers
 */

public final class AccessController {

    /**
     * Don't allow anyone to instantiate an AccessController
     */
    private AccessController() { }

    /**
     * Performs the specified {@code PrivilegedAction} with privileges
     * enabled. The action is performed with &lt;i&gt;all&lt;/i&gt; of the permissions
     * possessed by the caller's protection domain.
     *
     * &lt;p&gt; If the action's {@code run} method throws an (unchecked)
     * exception, it will propagate through this method.
     *
     * &lt;p&gt; Note that any DomainCombiner associated with the current
     * AccessControlContext will be ignored while the action is performed.
     *
     * @param &lt;T&gt; the type of the value returned by the PrivilegedAction's
     *                  {@code run} method.
     *
     * @param action the action to be performed.
     *
     * @return the value returned by the action's {@code run} method.
     *
     * @exception NullPointerException if the action is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction,AccessControlContext)
     * @see #doPrivileged(PrivilegedExceptionAction)
     * @see #doPrivilegedWithCombiner(PrivilegedAction)
     * @see java.security.DomainCombiner
     */

    @CallerSensitive
    public static native &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action);

    /**
     * Performs the specified {@code PrivilegedAction} with privileges
     * enabled. The action is performed with &lt;i&gt;all&lt;/i&gt; of the permissions
     * possessed by the caller's protection domain.
     *
     * &lt;p&gt; If the action's {@code run} method throws an (unchecked)
     * exception, it will propagate through this method.
     *
     * &lt;p&gt; This method preserves the current AccessControlContext's
     * DomainCombiner (which may be null) while the action is performed.
     *
     * @param &lt;T&gt; the type of the value returned by the PrivilegedAction's
     *                  {@code run} method.
     *
     * @param action the action to be performed.
     *
     * @return the value returned by the action's {@code run} method.
     *
     * @exception NullPointerException if the action is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see java.security.DomainCombiner
     *
     * @since 1.6
     */
    @CallerSensitive
    public static &lt;T&gt; T doPrivilegedWithCombiner(PrivilegedAction&lt;T&gt; action) {
        AccessControlContext acc = getStackAccessControlContext();
        if (acc == null) {
            return AccessController.doPrivileged(action);
        }
        DomainCombiner dc = acc.getAssignedCombiner();
        return AccessController.doPrivileged(action,
                                             preserveCombiner(dc, Reflection.getCallerClass()));
    }


    /**
     * Performs the specified {@code PrivilegedAction} with privileges
     * enabled and restricted by the specified {@code AccessControlContext}.
     * The action is performed with the intersection of the permissions
     * possessed by the caller's protection domain, and those possessed
     * by the domains represented by the specified {@code AccessControlContext}.
     * &lt;p&gt;
     * If the action's {@code run} method throws an (unchecked) exception,
     * it will propagate through this method.
     * &lt;p&gt;
     * If a security manager is installed and the specified
     * {@code AccessControlContext} was not created by system code and the
     * caller's {@code ProtectionDomain} has not been granted the
     * {@literal &quot;createAccessControlContext&quot;}
     * {@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @param &lt;T&gt; the type of the value returned by the PrivilegedAction's
     *                  {@code run} method.
     * @param action the action to be performed.
     * @param context an &lt;i&gt;access control context&lt;/i&gt;
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@code null}, then no additional restriction is applied.
     *
     * @return the value returned by the action's {@code run} method.
     *
     * @exception NullPointerException if the action is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
     */
    @CallerSensitive
    public static native &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action,
                                            AccessControlContext context);


    /**
     * Performs the specified {@code PrivilegedAction} with privileges
     * enabled and restricted by the specified
     * {@code AccessControlContext} and with a privilege scope limited
     * by specified {@code Permission} arguments.
     *
     * The action is performed with the intersection of the permissions
     * possessed by the caller's protection domain, and those possessed
     * by the domains represented by the specified
     * {@code AccessControlContext}.
     * &lt;p&gt;
     * If the action's {@code run} method throws an (unchecked) exception,
     * it will propagate through this method.
     * &lt;p&gt;
     * If a security manager is installed and the specified
     * {@code AccessControlContext} was not created by system code and the
     * caller's {@code ProtectionDomain} has not been granted the
     * {@literal &quot;createAccessControlContext&quot;}
     * {@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @param &lt;T&gt; the type of the value returned by the PrivilegedAction's
     *                  {@code run} method.
     * @param action the action to be performed.
     * @param context an &lt;i&gt;access control context&lt;/i&gt;
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@code null},
     *                then no additional restriction is applied.
     * @param perms the {@code Permission} arguments which limit the
     *              scope of the caller's privileges. The number of arguments
     *              is variable.
     *
     * @return the value returned by the action's {@code run} method.
     *
     * @throws NullPointerException if action or perms or any element of
     *         perms is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
     *
     * @since 1.8
     */
    @CallerSensitive
    public static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action,
        AccessControlContext context, Permission... perms) {

        AccessControlContext parent = getContext();
        if (perms == null) {
            throw new NullPointerException(&quot;null permissions parameter&quot;);
        }
        Class &lt;?&gt; caller = Reflection.getCallerClass();
        return AccessController.doPrivileged(action, createWrapper(null,
            caller, parent, context, perms));
    }


    /**
     * Performs the specified {@code PrivilegedAction} with privileges
     * enabled and restricted by the specified
     * {@code AccessControlContext} and with a privilege scope limited
     * by specified {@code Permission} arguments.
     *
     * The action is performed with the intersection of the permissions
     * possessed by the caller's protection domain, and those possessed
     * by the domains represented by the specified
     * {@code AccessControlContext}.
     * &lt;p&gt;
     * If the action's {@code run} method throws an (unchecked) exception,
     * it will propagate through this method.
     *
     * &lt;p&gt; This method preserves the current AccessControlContext's
     * DomainCombiner (which may be null) while the action is performed.
     * &lt;p&gt;
     * If a security manager is installed and the specified
     * {@code AccessControlContext} was not created by system code and the
     * caller's {@code ProtectionDomain} has not been granted the
     * {@literal &quot;createAccessControlContext&quot;}
     * {@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @param &lt;T&gt; the type of the value returned by the PrivilegedAction's
     *                  {@code run} method.
     * @param action the action to be performed.
     * @param context an &lt;i&gt;access control context&lt;/i&gt;
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@code null},
     *                then no additional restriction is applied.
     * @param perms the {@code Permission} arguments which limit the
     *              scope of the caller's privileges. The number of arguments
     *              is variable.
     *
     * @return the value returned by the action's {@code run} method.
     *
     * @throws NullPointerException if action or perms or any element of
     *         perms is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
     * @see java.security.DomainCombiner
     *
     * @since 1.8
     */
    @CallerSensitive
    public static &lt;T&gt; T doPrivilegedWithCombiner(PrivilegedAction&lt;T&gt; action,
        AccessControlContext context, Permission... perms) {

        AccessControlContext parent = getContext();
        DomainCombiner dc = parent.getCombiner();
        if (dc == null &amp;&amp; context != null) {
            dc = context.getCombiner();
        }
        if (perms == null) {
            throw new NullPointerException(&quot;null permissions parameter&quot;);
        }
        Class &lt;?&gt; caller = Reflection.getCallerClass();
        return AccessController.doPrivileged(action, createWrapper(dc, caller,
            parent, context, perms));
    }

    /**
     * Performs the specified {@code PrivilegedExceptionAction} with
     * privileges enabled.  The action is performed with &lt;i&gt;all&lt;/i&gt; of the
     * permissions possessed by the caller's protection domain.
     *
     * &lt;p&gt; If the action's {@code run} method throws an &lt;i&gt;unchecked&lt;/i&gt;
     * exception, it will propagate through this method.
     *
     * &lt;p&gt; Note that any DomainCombiner associated with the current
     * AccessControlContext will be ignored while the action is performed.
     *
     * @param &lt;T&gt; the type of the value returned by the
     *                  PrivilegedExceptionAction's {@code run} method.
     *
     * @param action the action to be performed
     *
     * @return the value returned by the action's {@code run} method
     *
     * @exception PrivilegedActionException if the specified action's
     *         {@code run} method threw a &lt;i&gt;checked&lt;/i&gt; exception
     * @exception NullPointerException if the action is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
     * @see #doPrivilegedWithCombiner(PrivilegedExceptionAction)
     * @see java.security.DomainCombiner
     */
    @CallerSensitive
    public static native &lt;T&gt; T
        doPrivileged(PrivilegedExceptionAction&lt;T&gt; action)
        throws PrivilegedActionException;


    /**
     * Performs the specified {@code PrivilegedExceptionAction} with
     * privileges enabled.  The action is performed with &lt;i&gt;all&lt;/i&gt; of the
     * permissions possessed by the caller's protection domain.
     *
     * &lt;p&gt; If the action's {@code run} method throws an &lt;i&gt;unchecked&lt;/i&gt;
     * exception, it will propagate through this method.
     *
     * &lt;p&gt; This method preserves the current AccessControlContext's
     * DomainCombiner (which may be null) while the action is performed.
     *
     * @param &lt;T&gt; the type of the value returned by the
     *                  PrivilegedExceptionAction's {@code run} method.
     *
     * @param action the action to be performed.
     *
     * @return the value returned by the action's {@code run} method
     *
     * @exception PrivilegedActionException if the specified action's
     *         {@code run} method threw a &lt;i&gt;checked&lt;/i&gt; exception
     * @exception NullPointerException if the action is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
     * @see java.security.DomainCombiner
     *
     * @since 1.6
     */
    @CallerSensitive
    public static &lt;T&gt; T doPrivilegedWithCombiner(PrivilegedExceptionAction&lt;T&gt; action)
        throws PrivilegedActionException
    {
        AccessControlContext acc = getStackAccessControlContext();
        if (acc == null) {
            return AccessController.doPrivileged(action);
        }
        DomainCombiner dc = acc.getAssignedCombiner();
        return AccessController.doPrivileged(action,
                                             preserveCombiner(dc, Reflection.getCallerClass()));
    }

    /**
     * preserve the combiner across the doPrivileged call
     */
    private static AccessControlContext preserveCombiner(DomainCombiner combiner,
                                                         Class&lt;?&gt; caller)
    {
        return createWrapper(combiner, caller, null, null, null);
    }

    /**
     * Create a wrapper to contain the limited privilege scope data.
     */
    private static AccessControlContext
        createWrapper(DomainCombiner combiner, Class&lt;?&gt; caller,
                      AccessControlContext parent, AccessControlContext context,
                      Permission[] perms)
    {
        ProtectionDomain callerPD = getCallerPD(caller);
        // check if caller is authorized to create context
        if (context != null &amp;&amp; !context.isAuthorized() &amp;&amp;
            System.getSecurityManager() != null &amp;&amp;
            !callerPD.impliesCreateAccessControlContext())
        {
            ProtectionDomain nullPD = new ProtectionDomain(null, null);
            return new AccessControlContext(new ProtectionDomain[] { nullPD });
        } else {
            return new AccessControlContext(callerPD, combiner, parent,
                                            context, perms);
        }
    }

    private static ProtectionDomain getCallerPD(final Class &lt;?&gt; caller) {
        ProtectionDomain callerPd = doPrivileged
            (new PrivilegedAction&lt;ProtectionDomain&gt;() {
            public ProtectionDomain run() {
                return caller.getProtectionDomain();
            }
        });

        return callerPd;
    }

    /**
     * Performs the specified {@code PrivilegedExceptionAction} with
     * privileges enabled and restricted by the specified
     * {@code AccessControlContext}.  The action is performed with the
     * intersection of the permissions possessed by the caller's
     * protection domain, and those possessed by the domains represented by the
     * specified {@code AccessControlContext}.
     * &lt;p&gt;
     * If the action's {@code run} method throws an &lt;i&gt;unchecked&lt;/i&gt;
     * exception, it will propagate through this method.
     * &lt;p&gt;
     * If a security manager is installed and the specified
     * {@code AccessControlContext} was not created by system code and the
     * caller's {@code ProtectionDomain} has not been granted the
     * {@literal &quot;createAccessControlContext&quot;}
     * {@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @param &lt;T&gt; the type of the value returned by the
     *                  PrivilegedExceptionAction's {@code run} method.
     * @param action the action to be performed
     * @param context an &lt;i&gt;access control context&lt;/i&gt;
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@code null}, then no additional restriction is applied.
     *
     * @return the value returned by the action's {@code run} method
     *
     * @exception PrivilegedActionException if the specified action's
     *         {@code run} method threw a &lt;i&gt;checked&lt;/i&gt; exception
     * @exception NullPointerException if the action is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedAction,AccessControlContext)
     */
    @CallerSensitive
    public static native &lt;T&gt; T
        doPrivileged(PrivilegedExceptionAction&lt;T&gt; action,
                     AccessControlContext context)
        throws PrivilegedActionException;


    /**
     * Performs the specified {@code PrivilegedExceptionAction} with
     * privileges enabled and restricted by the specified
     * {@code AccessControlContext} and with a privilege scope limited by
     * specified {@code Permission} arguments.
     *
     * The action is performed with the intersection of the permissions
     * possessed by the caller's protection domain, and those possessed
     * by the domains represented by the specified
     * {@code AccessControlContext}.
     * &lt;p&gt;
     * If the action's {@code run} method throws an (unchecked) exception,
     * it will propagate through this method.
     * &lt;p&gt;
     * If a security manager is installed and the specified
     * {@code AccessControlContext} was not created by system code and the
     * caller's {@code ProtectionDomain} has not been granted the
     * {@literal &quot;createAccessControlContext&quot;}
     * {@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @param &lt;T&gt; the type of the value returned by the
     *                  PrivilegedExceptionAction's {@code run} method.
     * @param action the action to be performed.
     * @param context an &lt;i&gt;access control context&lt;/i&gt;
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@code null},
     *                then no additional restriction is applied.
     * @param perms the {@code Permission} arguments which limit the
     *              scope of the caller's privileges. The number of arguments
     *              is variable.
     *
     * @return the value returned by the action's {@code run} method.
     *
     * @throws PrivilegedActionException if the specified action's
     *         {@code run} method threw a &lt;i&gt;checked&lt;/i&gt; exception
     * @throws NullPointerException if action or perms or any element of
     *         perms is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedAction,AccessControlContext)
     *
     * @since 1.8
     */
    @CallerSensitive
    public static &lt;T&gt; T doPrivileged(PrivilegedExceptionAction&lt;T&gt; action,
                                     AccessControlContext context, Permission... perms)
        throws PrivilegedActionException
    {
        AccessControlContext parent = getContext();
        if (perms == null) {
            throw new NullPointerException(&quot;null permissions parameter&quot;);
        }
        Class &lt;?&gt; caller = Reflection.getCallerClass();
        return AccessController.doPrivileged(action, createWrapper(null, caller, parent, context, perms));
    }


    /**
     * Performs the specified {@code PrivilegedExceptionAction} with
     * privileges enabled and restricted by the specified
     * {@code AccessControlContext} and with a privilege scope limited by
     * specified {@code Permission} arguments.
     *
     * The action is performed with the intersection of the permissions
     * possessed by the caller's protection domain, and those possessed
     * by the domains represented by the specified
     * {@code AccessControlContext}.
     * &lt;p&gt;
     * If the action's {@code run} method throws an (unchecked) exception,
     * it will propagate through this method.
     *
     * &lt;p&gt; This method preserves the current AccessControlContext's
     * DomainCombiner (which may be null) while the action is performed.
     * &lt;p&gt;
     * If a security manager is installed and the specified
     * {@code AccessControlContext} was not created by system code and the
     * caller's {@code ProtectionDomain} has not been granted the
     * {@literal &quot;createAccessControlContext&quot;}
     * {@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @param &lt;T&gt; the type of the value returned by the
     *                  PrivilegedExceptionAction's {@code run} method.
     * @param action the action to be performed.
     * @param context an &lt;i&gt;access control context&lt;/i&gt;
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@code null},
     *                then no additional restriction is applied.
     * @param perms the {@code Permission} arguments which limit the
     *              scope of the caller's privileges. The number of arguments
     *              is variable.
     *
     * @return the value returned by the action's {@code run} method.
     *
     * @throws PrivilegedActionException if the specified action's
     *         {@code run} method threw a &lt;i&gt;checked&lt;/i&gt; exception
     * @throws NullPointerException if action or perms or any element of
     *         perms is {@code null}
     *
     * @see #doPrivileged(PrivilegedAction)
     * @see #doPrivileged(PrivilegedAction,AccessControlContext)
     * @see java.security.DomainCombiner
     *
     * @since 1.8
     */
    @CallerSensitive
    public static &lt;T&gt; T doPrivilegedWithCombiner(PrivilegedExceptionAction&lt;T&gt; action,
                                                 AccessControlContext context,
                                                 Permission... perms)
        throws PrivilegedActionException
    {
        AccessControlContext parent = getContext();
        DomainCombiner dc = parent.getCombiner();
        if (dc == null &amp;&amp; context != null) {
            dc = context.getCombiner();
        }
        if (perms == null) {
            throw new NullPointerException(&quot;null permissions parameter&quot;);
        }
        Class &lt;?&gt; caller = Reflection.getCallerClass();
        return AccessController.doPrivileged(action, createWrapper(dc, caller,
            parent, context, perms));
    }

    /**
     * Returns the AccessControl context. i.e., it gets
     * the protection domains of all the callers on the stack,
     * starting at the first class with a non-null
     * ProtectionDomain.
     *
     * @return the access control context based on the current stack or
     *         null if there was only privileged system code.
     */

    private static native AccessControlContext getStackAccessControlContext();


    /**
     * Returns the &quot;inherited&quot; AccessControl context. This is the context
     * that existed when the thread was created. Package private so
     * AccessControlContext can use it.
     */

    static native AccessControlContext getInheritedAccessControlContext();

    /**
     * This method takes a &quot;snapshot&quot; of the current calling context, which
     * includes the current Thread's inherited AccessControlContext and any
     * limited privilege scope, and places it in an AccessControlContext object.
     * This context may then be checked at a later point, possibly in another thread.
     *
     * @see AccessControlContext
     *
     * @return the AccessControlContext based on the current context.
     */

    public static AccessControlContext getContext()
    {
        AccessControlContext acc = getStackAccessControlContext();
        if (acc == null) {
            // all we had was privileged system code. We don't want
            // to return null though, so we construct a real ACC.
            return new AccessControlContext(null, true);
        } else {
            return acc.optimize();
        }
    }

    /**
     * Determines whether the access request indicated by the
     * specified permission should be allowed or denied, based on
     * the current AccessControlContext and security policy.
     * This method quietly returns if the access request
     * is permitted, or throws an AccessControlException otherwise. The
     * getPermission method of the AccessControlException returns the
     * {@code perm} Permission object instance.
     *
     * @param perm the requested permission.
     *
     * @exception AccessControlException if the specified permission
     *            is not permitted, based on the current security policy.
     * @exception NullPointerException if the specified permission
     *            is {@code null} and is checked based on the
     *            security policy currently in effect.
     */

    public static void checkPermission(Permission perm)
        throws AccessControlException
    {
        //System.err.println(&quot;checkPermission &quot;+perm);
        //Thread.currentThread().dumpStack();

        if (perm == null) {
            throw new NullPointerException(&quot;permission can't be null&quot;);
        }

        AccessControlContext stack = getStackAccessControlContext();
        // if context is null, we had privileged system code on the stack.
        if (stack == null) {
            Debug debug = AccessControlContext.getDebug();
            boolean dumpDebug = false;
            if (debug != null) {
                dumpDebug = !Debug.isOn(&quot;codebase=&quot;);
                dumpDebug &amp;= !Debug.isOn(&quot;permission=&quot;) ||
                    Debug.isOn(&quot;permission=&quot; + perm.getClass().getCanonicalName());
            }

            if (dumpDebug &amp;&amp; Debug.isOn(&quot;stack&quot;)) {
                Thread.dumpStack();
            }

            if (dumpDebug &amp;&amp; Debug.isOn(&quot;domain&quot;)) {
                debug.println(&quot;domain (context is null)&quot;);
            }

            if (dumpDebug) {
                debug.println(&quot;access allowed &quot;+perm);
            }
            return;
        }

        AccessControlContext acc = stack.optimize();
        acc.checkPermission(perm);
    }
}
</pre>
</body>
</html>
