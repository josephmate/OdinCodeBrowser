<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<table>
<tr>
<td><a class="linenum-cell" data-linenum="1" href="#"></a></td>
<td><pre>/*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2" href="#"></a></td>
<td><pre> * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3" href="#"></a></td>
<td><pre> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5" href="#"></a></td>
<td><pre> * This code is free software; you can redistribute it and/or modify it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="6" href="#"></a></td>
<td><pre> * under the terms of the GNU General Public License version 2 only, as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="7" href="#"></a></td>
<td><pre> * published by the Free Software Foundation.  Oracle designates this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="8" href="#"></a></td>
<td><pre> * particular file as subject to the &quot;Classpath&quot; exception as provided</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="9" href="#"></a></td>
<td><pre> * by Oracle in the LICENSE file that accompanied this code.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="10" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="11" href="#"></a></td>
<td><pre> * This code is distributed in the hope that it will be useful, but WITHOUT</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="12" href="#"></a></td>
<td><pre> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="13" href="#"></a></td>
<td><pre> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="14" href="#"></a></td>
<td><pre> * version 2 for more details (a copy is included in the LICENSE file that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="15" href="#"></a></td>
<td><pre> * accompanied this code).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="16" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="17" href="#"></a></td>
<td><pre> * You should have received a copy of the GNU General Public License version</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="18" href="#"></a></td>
<td><pre> * 2 along with this work; if not, write to the Free Software Foundation,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="19" href="#"></a></td>
<td><pre> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="20" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="21" href="#"></a></td>
<td><pre> * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="22" href="#"></a></td>
<td><pre> * or visit www.oracle.com if you need additional information or have any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="23" href="#"></a></td>
<td><pre> * questions.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="24" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="25" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="26" href="#"></a></td>
<td><pre>package java.lang.invoke;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="27" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="28" href="#"></a></td>
<td><pre>import java.io.Serializable;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="29" href="#"></a></td>
<td><pre>import java.util.Arrays;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="30" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="31" href="#"></a></td>
<td><pre>/**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="32" href="#"></a></td>
<td><pre> * &lt;p&gt;Methods to facilitate the creation of simple &quot;function objects&quot; that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="33" href="#"></a></td>
<td><pre> * implement one or more interfaces by delegation to a provided {@link MethodHandle},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="34" href="#"></a></td>
<td><pre> * possibly after type adaptation and partial evaluation of arguments.  These</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="35" href="#"></a></td>
<td><pre> * methods are typically used as &lt;em&gt;bootstrap methods&lt;/em&gt; for {@code invokedynamic}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="36" href="#"></a></td>
<td><pre> * call sites, to support the &lt;em&gt;lambda expression&lt;/em&gt; and &lt;em&gt;method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="37" href="#"></a></td>
<td><pre> * reference expression&lt;/em&gt; features of the Java Programming Language.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="38" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="39" href="#"></a></td>
<td><pre> * &lt;p&gt;Indirect access to the behavior specified by the provided {@code MethodHandle}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="40" href="#"></a></td>
<td><pre> * proceeds in order through three phases:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="41" href="#"></a></td>
<td><pre> * &lt;ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="42" href="#"></a></td>
<td><pre> *     &lt;li&gt;&lt;em&gt;Linkage&lt;/em&gt; occurs when the methods in this class are invoked.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="43" href="#"></a></td>
<td><pre> *     They take as arguments an interface to be implemented (typically a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="44" href="#"></a></td>
<td><pre> *     &lt;em&gt;functional interface&lt;/em&gt;, one with a single abstract method), a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="45" href="#"></a></td>
<td><pre> *     name and signature of a method from that interface to be implemented, a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="46" href="#"></a></td>
<td><pre> *     method handle describing the desired implementation behavior</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="47" href="#"></a></td>
<td><pre> *     for that method, and possibly other additional metadata, and produce a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="48" href="#"></a></td>
<td><pre> *     {@link CallSite} whose target can be used to create suitable function</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="49" href="#"></a></td>
<td><pre> *     objects.  Linkage may involve dynamically loading a new class that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="50" href="#"></a></td>
<td><pre> *     implements the target interface. The {@code CallSite} can be considered a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="51" href="#"></a></td>
<td><pre> *     &quot;factory&quot; for function objects and so these linkage methods are referred</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="52" href="#"></a></td>
<td><pre> *     to as &quot;metafactories&quot;.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="53" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="54" href="#"></a></td>
<td><pre> *     &lt;li&gt;&lt;em&gt;Capture&lt;/em&gt; occurs when the {@code CallSite}'s target is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="55" href="#"></a></td>
<td><pre> *     invoked, typically through an {@code invokedynamic} call site,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="56" href="#"></a></td>
<td><pre> *     producing a function object.  This may occur many times for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="57" href="#"></a></td>
<td><pre> *     a single factory {@code CallSite}.  Capture may involve allocation of a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="58" href="#"></a></td>
<td><pre> *     new function object, or may return an existing function object.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="59" href="#"></a></td>
<td><pre> *     behavior {@code MethodHandle} may have additional parameters beyond those</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="60" href="#"></a></td>
<td><pre> *     of the specified interface method; these are referred to as &lt;em&gt;captured</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="61" href="#"></a></td>
<td><pre> *     parameters&lt;/em&gt;, which must be provided as arguments to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="62" href="#"></a></td>
<td><pre> *     {@code CallSite} target, and which may be early-bound to the behavior</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="63" href="#"></a></td>
<td><pre> *     {@code MethodHandle}.  The number of captured parameters and their types</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="64" href="#"></a></td>
<td><pre> *     are determined during linkage.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="65" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="66" href="#"></a></td>
<td><pre> *     &lt;li&gt;&lt;em&gt;Invocation&lt;/em&gt; occurs when an implemented interface method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="67" href="#"></a></td>
<td><pre> *     is invoked on a function object.  This may occur many times for a single</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="68" href="#"></a></td>
<td><pre> *     function object.  The method referenced by the behavior {@code MethodHandle}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="69" href="#"></a></td>
<td><pre> *     is invoked with the captured arguments and any additional arguments</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="70" href="#"></a></td>
<td><pre> *     provided on invocation, as if by {@link MethodHandle#invoke(Object...)}.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="71" href="#"></a></td>
<td><pre> * &lt;/ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="72" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="73" href="#"></a></td>
<td><pre> * &lt;p&gt;It is sometimes useful to restrict the set of inputs or results permitted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="74" href="#"></a></td>
<td><pre> * at invocation.  For example, when the generic interface {@code Predicate&lt;T&gt;}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="75" href="#"></a></td>
<td><pre> * is parameterized as {@code Predicate&lt;String&gt;}, the input must be a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="76" href="#"></a></td>
<td><pre> * {@code String}, even though the method to implement allows any {@code Object}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="77" href="#"></a></td>
<td><pre> * At linkage time, an additional {@link MethodType} parameter describes the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="78" href="#"></a></td>
<td><pre> * &quot;instantiated&quot; method type; on invocation, the arguments and eventual result</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="79" href="#"></a></td>
<td><pre> * are checked against this {@code MethodType}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="80" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="81" href="#"></a></td>
<td><pre> * &lt;p&gt;This class provides two forms of linkage methods: a standard version</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="82" href="#"></a></td>
<td><pre> * ({@link #metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)})</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="83" href="#"></a></td>
<td><pre> * using an optimized protocol, and an alternate version</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="84" href="#"></a></td>
<td><pre> * {@link #altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)}).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="85" href="#"></a></td>
<td><pre> * The alternate version is a generalization of the standard version, providing</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="86" href="#"></a></td>
<td><pre> * additional control over the behavior of the generated function objects via</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="87" href="#"></a></td>
<td><pre> * flags and additional arguments.  The alternate version adds the ability to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="88" href="#"></a></td>
<td><pre> * manage the following attributes of function objects:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="89" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="90" href="#"></a></td>
<td><pre> * &lt;ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="91" href="#"></a></td>
<td><pre> *     &lt;li&gt;&lt;em&gt;Bridging.&lt;/em&gt;  It is sometimes useful to implement multiple</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="92" href="#"></a></td>
<td><pre> *     variations of the method signature, involving argument or return type</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="93" href="#"></a></td>
<td><pre> *     adaptation.  This occurs when multiple distinct VM signatures for a method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="94" href="#"></a></td>
<td><pre> *     are logically considered to be the same method by the language.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="95" href="#"></a></td>
<td><pre> *     flag {@code FLAG_BRIDGES} indicates that a list of additional</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="96" href="#"></a></td>
<td><pre> *     {@code MethodType}s will be provided, each of which will be implemented</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="97" href="#"></a></td>
<td><pre> *     by the resulting function object.  These methods will share the same</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="98" href="#"></a></td>
<td><pre> *     name and instantiated type.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="99" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="100" href="#"></a></td>
<td><pre> *     &lt;li&gt;&lt;em&gt;Multiple interfaces.&lt;/em&gt;  If needed, more than one interface</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="101" href="#"></a></td>
<td><pre> *     can be implemented by the function object.  (These additional interfaces</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="102" href="#"></a></td>
<td><pre> *     are typically marker interfaces with no methods.)  The flag {@code FLAG_MARKERS}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="103" href="#"></a></td>
<td><pre> *     indicates that a list of additional interfaces will be provided, each of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="104" href="#"></a></td>
<td><pre> *     which should be implemented by the resulting function object.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="105" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="106" href="#"></a></td>
<td><pre> *     &lt;li&gt;&lt;em&gt;Serializability.&lt;/em&gt;  The generated function objects do not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="107" href="#"></a></td>
<td><pre> *     generally support serialization.  If desired, {@code FLAG_SERIALIZABLE}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="108" href="#"></a></td>
<td><pre> *     can be used to indicate that the function objects should be serializable.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="109" href="#"></a></td>
<td><pre> *     Serializable function objects will use, as their serialized form,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="110" href="#"></a></td>
<td><pre> *     instances of the class {@code SerializedLambda}, which requires additional</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="111" href="#"></a></td>
<td><pre> *     assistance from the capturing class (the class described by the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="112" href="#"></a></td>
<td><pre> *     {@link MethodHandles.Lookup} parameter {@code caller}); see</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="113" href="#"></a></td>
<td><pre> *     {@link SerializedLambda} for details.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="114" href="#"></a></td>
<td><pre> * &lt;/ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="115" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="116" href="#"></a></td>
<td><pre> * &lt;p&gt;Assume the linkage arguments are as follows:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="117" href="#"></a></td>
<td><pre> * &lt;ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="118" href="#"></a></td>
<td><pre> *      &lt;li&gt;{@code invokedType} (describing the {@code CallSite} signature) has</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="119" href="#"></a></td>
<td><pre> *      K parameters of types (D1..Dk) and return type Rd;&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="120" href="#"></a></td>
<td><pre> *      &lt;li&gt;{@code samMethodType} (describing the implemented method type) has N</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="121" href="#"></a></td>
<td><pre> *      parameters, of types (U1..Un) and return type Ru;&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="122" href="#"></a></td>
<td><pre> *      &lt;li&gt;{@code implMethod} (the {@code MethodHandle} providing the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="123" href="#"></a></td>
<td><pre> *      implementation has M parameters, of types (A1..Am) and return type Ra</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="124" href="#"></a></td>
<td><pre> *      (if the method describes an instance method, the method type of this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="125" href="#"></a></td>
<td><pre> *      method handle already includes an extra first argument corresponding to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="126" href="#"></a></td>
<td><pre> *      the receiver);&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="127" href="#"></a></td>
<td><pre> *      &lt;li&gt;{@code instantiatedMethodType} (allowing restrictions on invocation)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="128" href="#"></a></td>
<td><pre> *      has N parameters, of types (T1..Tn) and return type Rt.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="129" href="#"></a></td>
<td><pre> * &lt;/ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="130" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="131" href="#"></a></td>
<td><pre> * &lt;p&gt;Then the following linkage invariants must hold:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="132" href="#"></a></td>
<td><pre> * &lt;ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="133" href="#"></a></td>
<td><pre> *     &lt;li&gt;Rd is an interface&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="134" href="#"></a></td>
<td><pre> *     &lt;li&gt;{@code implMethod} is a &lt;em&gt;direct method handle&lt;/em&gt;&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="135" href="#"></a></td>
<td><pre> *     &lt;li&gt;{@code samMethodType} and {@code instantiatedMethodType} have the same</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="136" href="#"></a></td>
<td><pre> *     arity N, and for i=1..N, Ti and Ui are the same type, or Ti and Ui are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="137" href="#"></a></td>
<td><pre> *     both reference types and Ti is a subtype of Ui&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="138" href="#"></a></td>
<td><pre> *     &lt;li&gt;Either Rt and Ru are the same type, or both are reference types and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="139" href="#"></a></td>
<td><pre> *     Rt is a subtype of Ru&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="140" href="#"></a></td>
<td><pre> *     &lt;li&gt;K + N = M&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="141" href="#"></a></td>
<td><pre> *     &lt;li&gt;For i=1..K, Di = Ai&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="142" href="#"></a></td>
<td><pre> *     &lt;li&gt;For i=1..N, Ti is adaptable to Aj, where j=i+k&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="143" href="#"></a></td>
<td><pre> *     &lt;li&gt;The return type Rt is void, or the return type Ra is not void and is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="144" href="#"></a></td>
<td><pre> *     adaptable to Rt&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="145" href="#"></a></td>
<td><pre> * &lt;/ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="146" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="147" href="#"></a></td>
<td><pre> * &lt;p&gt;Further, at capture time, if {@code implMethod} corresponds to an instance</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="148" href="#"></a></td>
<td><pre> * method, and there are any capture arguments ({@code K &gt; 0}), then the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="149" href="#"></a></td>
<td><pre> * capture argument (corresponding to the receiver) must be non-null.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="150" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="151" href="#"></a></td>
<td><pre> * &lt;p&gt;A type Q is considered adaptable to S as follows:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="152" href="#"></a></td>
<td><pre> * &lt;table summary=&quot;adaptable types&quot;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="153" href="#"></a></td>
<td><pre> *     &lt;tr&gt;&lt;th&gt;Q&lt;/th&gt;&lt;th&gt;S&lt;/th&gt;&lt;th&gt;Link-time checks&lt;/th&gt;&lt;th&gt;Invocation-time checks&lt;/th&gt;&lt;/tr&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="154" href="#"></a></td>
<td><pre> *     &lt;tr&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="155" href="#"></a></td>
<td><pre> *         &lt;td&gt;Primitive&lt;/td&gt;&lt;td&gt;Primitive&lt;/td&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="156" href="#"></a></td>
<td><pre> *         &lt;td&gt;Q can be converted to S via a primitive widening conversion&lt;/td&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="157" href="#"></a></td>
<td><pre> *         &lt;td&gt;None&lt;/td&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="158" href="#"></a></td>
<td><pre> *     &lt;/tr&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="159" href="#"></a></td>
<td><pre> *     &lt;tr&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="160" href="#"></a></td>
<td><pre> *         &lt;td&gt;Primitive&lt;/td&gt;&lt;td&gt;Reference&lt;/td&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="161" href="#"></a></td>
<td><pre> *         &lt;td&gt;S is a supertype of the Wrapper(Q)&lt;/td&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="162" href="#"></a></td>
<td><pre> *         &lt;td&gt;Cast from Wrapper(Q) to S&lt;/td&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="163" href="#"></a></td>
<td><pre> *     &lt;/tr&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="164" href="#"></a></td>
<td><pre> *     &lt;tr&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="165" href="#"></a></td>
<td><pre> *         &lt;td&gt;Reference&lt;/td&gt;&lt;td&gt;Primitive&lt;/td&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="166" href="#"></a></td>
<td><pre> *         &lt;td&gt;for parameter types: Q is a primitive wrapper and Primitive(Q)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="167" href="#"></a></td>
<td><pre> *         can be widened to S</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="168" href="#"></a></td>
<td><pre> *         &lt;br&gt;for return types: If Q is a primitive wrapper, check that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="169" href="#"></a></td>
<td><pre> *         Primitive(Q) can be widened to S&lt;/td&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="170" href="#"></a></td>
<td><pre> *         &lt;td&gt;If Q is not a primitive wrapper, cast Q to the base Wrapper(S);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="171" href="#"></a></td>
<td><pre> *         for example Number for numeric types&lt;/td&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="172" href="#"></a></td>
<td><pre> *     &lt;/tr&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="173" href="#"></a></td>
<td><pre> *     &lt;tr&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="174" href="#"></a></td>
<td><pre> *         &lt;td&gt;Reference&lt;/td&gt;&lt;td&gt;Reference&lt;/td&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="175" href="#"></a></td>
<td><pre> *         &lt;td&gt;for parameter types: S is a supertype of Q</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="176" href="#"></a></td>
<td><pre> *         &lt;br&gt;for return types: none&lt;/td&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="177" href="#"></a></td>
<td><pre> *         &lt;td&gt;Cast from Q to S&lt;/td&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="178" href="#"></a></td>
<td><pre> *     &lt;/tr&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="179" href="#"></a></td>
<td><pre> * &lt;/table&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="180" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="181" href="#"></a></td>
<td><pre> * @apiNote These linkage methods are designed to support the evaluation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="182" href="#"></a></td>
<td><pre> * of &lt;em&gt;lambda expressions&lt;/em&gt; and &lt;em&gt;method references&lt;/em&gt; in the Java</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="183" href="#"></a></td>
<td><pre> * Language.  For every lambda expressions or method reference in the source code,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="184" href="#"></a></td>
<td><pre> * there is a target type which is a functional interface.  Evaluating a lambda</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="185" href="#"></a></td>
<td><pre> * expression produces an object of its target type. The recommended mechanism</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="186" href="#"></a></td>
<td><pre> * for evaluating lambda expressions is to desugar the lambda body to a method,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="187" href="#"></a></td>
<td><pre> * invoke an invokedynamic call site whose static argument list describes the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="188" href="#"></a></td>
<td><pre> * sole method of the functional interface and the desugared implementation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="189" href="#"></a></td>
<td><pre> * method, and returns an object (the lambda object) that implements the target</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="190" href="#"></a></td>
<td><pre> * type. (For method references, the implementation method is simply the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="191" href="#"></a></td>
<td><pre> * referenced method; no desugaring is needed.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="192" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="193" href="#"></a></td>
<td><pre> * &lt;p&gt;The argument list of the implementation method and the argument list of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="194" href="#"></a></td>
<td><pre> * the interface method(s) may differ in several ways.  The implementation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="195" href="#"></a></td>
<td><pre> * methods may have additional arguments to accommodate arguments captured by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="196" href="#"></a></td>
<td><pre> * the lambda expression; there may also be differences resulting from permitted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="197" href="#"></a></td>
<td><pre> * adaptations of arguments, such as casting, boxing, unboxing, and primitive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="198" href="#"></a></td>
<td><pre> * widening. (Varargs adaptations are not handled by the metafactories; these are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="199" href="#"></a></td>
<td><pre> * expected to be handled by the caller.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="200" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="201" href="#"></a></td>
<td><pre> * &lt;p&gt;Invokedynamic call sites have two argument lists: a static argument list</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="202" href="#"></a></td>
<td><pre> * and a dynamic argument list.  The static argument list is stored in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="203" href="#"></a></td>
<td><pre> * constant pool; the dynamic argument is pushed on the operand stack at capture</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="204" href="#"></a></td>
<td><pre> * time.  The bootstrap method has access to the entire static argument list</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="205" href="#"></a></td>
<td><pre> * (which in this case, includes information describing the implementation method,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="206" href="#"></a></td>
<td><pre> * the target interface, and the target interface method(s)), as well as a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="207" href="#"></a></td>
<td><pre> * method signature describing the number and static types (but not the values)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="208" href="#"></a></td>
<td><pre> * of the dynamic arguments and the static return type of the invokedynamic site.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="209" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="210" href="#"></a></td>
<td><pre> * @implNote The implementation method is described with a method handle. In</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="211" href="#"></a></td>
<td><pre> * theory, any method handle could be used. Currently supported are direct method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="212" href="#"></a></td>
<td><pre> * handles representing invocation of virtual, interface, constructor and static</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="213" href="#"></a></td>
<td><pre> * methods.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="214" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="215" href="#"></a></td>
<td><pre>public class LambdaMetafactory {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="216" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="217" href="#"></a></td>
<td><pre>    /** Flag for alternate metafactories indicating the lambda object</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="218" href="#"></a></td>
<td><pre>     * must be serializable */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="219" href="#"></a></td>
<td><pre>    public static final int FLAG_SERIALIZABLE = 1 &lt;&lt; 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="220" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="221" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="222" href="#"></a></td>
<td><pre>     * Flag for alternate metafactories indicating the lambda object implements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="223" href="#"></a></td>
<td><pre>     * other marker interfaces</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="224" href="#"></a></td>
<td><pre>     * besides Serializable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="225" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="226" href="#"></a></td>
<td><pre>    public static final int FLAG_MARKERS = 1 &lt;&lt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="227" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="228" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="229" href="#"></a></td>
<td><pre>     * Flag for alternate metafactories indicating the lambda object requires</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="230" href="#"></a></td>
<td><pre>     * additional bridge methods</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="231" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="232" href="#"></a></td>
<td><pre>    public static final int FLAG_BRIDGES = 1 &lt;&lt; 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="233" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="234" href="#"></a></td>
<td><pre>    private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="235" href="#"></a></td>
<td><pre>    private static final MethodType[] EMPTY_MT_ARRAY = new MethodType[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="236" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="237" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="238" href="#"></a></td>
<td><pre>     * Facilitates the creation of simple &quot;function objects&quot; that implement one</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="239" href="#"></a></td>
<td><pre>     * or more interfaces by delegation to a provided {@link MethodHandle},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="240" href="#"></a></td>
<td><pre>     * after appropriate type adaptation and partial evaluation of arguments.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="241" href="#"></a></td>
<td><pre>     * Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code invokedynamic}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="242" href="#"></a></td>
<td><pre>     * call sites, to support the &lt;em&gt;lambda expression&lt;/em&gt; and &lt;em&gt;method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="243" href="#"></a></td>
<td><pre>     * reference expression&lt;/em&gt; features of the Java Programming Language.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="244" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="245" href="#"></a></td>
<td><pre>     * &lt;p&gt;This is the standard, streamlined metafactory; additional flexibility</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="246" href="#"></a></td>
<td><pre>     * is provided by {@link #altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="247" href="#"></a></td>
<td><pre>     * A general description of the behavior of this method is provided</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="248" href="#"></a></td>
<td><pre>     * {@link LambdaMetafactory above}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="249" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="250" href="#"></a></td>
<td><pre>     * &lt;p&gt;When the target of the {@code CallSite} returned from this method is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="251" href="#"></a></td>
<td><pre>     * invoked, the resulting function objects are instances of a class which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="252" href="#"></a></td>
<td><pre>     * implements the interface named by the return type of {@code invokedType},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="253" href="#"></a></td>
<td><pre>     * declares a method with the name given by {@code invokedName} and the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="254" href="#"></a></td>
<td><pre>     * signature given by {@code samMethodType}.  It may also override additional</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="255" href="#"></a></td>
<td><pre>     * methods from {@code Object}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="256" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="257" href="#"></a></td>
<td><pre>     * @param caller Represents a lookup context with the accessibility</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="258" href="#"></a></td>
<td><pre>     *               privileges of the caller.  When used with {@code invokedynamic},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="259" href="#"></a></td>
<td><pre>     *               this is stacked automatically by the VM.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="260" href="#"></a></td>
<td><pre>     * @param invokedName The name of the method to implement.  When used with</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="261" href="#"></a></td>
<td><pre>     *                    {@code invokedynamic}, this is provided by the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="262" href="#"></a></td>
<td><pre>     *                    {@code NameAndType} of the {@code InvokeDynamic}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="263" href="#"></a></td>
<td><pre>     *                    structure and is stacked automatically by the VM.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="264" href="#"></a></td>
<td><pre>     * @param invokedType The expected signature of the {@code CallSite}.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="265" href="#"></a></td>
<td><pre>     *                    parameter types represent the types of capture variables;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="266" href="#"></a></td>
<td><pre>     *                    the return type is the interface to implement.   When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="267" href="#"></a></td>
<td><pre>     *                    used with {@code invokedynamic}, this is provided by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="268" href="#"></a></td>
<td><pre>     *                    the {@code NameAndType} of the {@code InvokeDynamic}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="269" href="#"></a></td>
<td><pre>     *                    structure and is stacked automatically by the VM.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="270" href="#"></a></td>
<td><pre>     *                    In the event that the implementation method is an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="271" href="#"></a></td>
<td><pre>     *                    instance method and this signature has any parameters,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="272" href="#"></a></td>
<td><pre>     *                    the first parameter in the invocation signature must</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="273" href="#"></a></td>
<td><pre>     *                    correspond to the receiver.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="274" href="#"></a></td>
<td><pre>     * @param samMethodType Signature and return type of method to be implemented</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="275" href="#"></a></td>
<td><pre>     *                      by the function object.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="276" href="#"></a></td>
<td><pre>     * @param implMethod A direct method handle describing the implementation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="277" href="#"></a></td>
<td><pre>     *                   method which should be called (with suitable adaptation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="278" href="#"></a></td>
<td><pre>     *                   of argument types, return types, and with captured</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="279" href="#"></a></td>
<td><pre>     *                   arguments prepended to the invocation arguments) at</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="280" href="#"></a></td>
<td><pre>     *                   invocation time.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="281" href="#"></a></td>
<td><pre>     * @param instantiatedMethodType The signature and return type that should</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="282" href="#"></a></td>
<td><pre>     *                               be enforced dynamically at invocation time.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="283" href="#"></a></td>
<td><pre>     *                               This may be the same as {@code samMethodType},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="284" href="#"></a></td>
<td><pre>     *                               or may be a specialization of it.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="285" href="#"></a></td>
<td><pre>     * @return a CallSite whose target can be used to perform capture, generating</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="286" href="#"></a></td>
<td><pre>     *         instances of the interface named by {@code invokedType}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="287" href="#"></a></td>
<td><pre>     * @throws LambdaConversionException If any of the linkage invariants</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="288" href="#"></a></td>
<td><pre>     *                                   described {@link LambdaMetafactory above}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="289" href="#"></a></td>
<td><pre>     *                                   are violated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="290" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="291" href="#"></a></td>
<td><pre>    public static CallSite metafactory(MethodHandles.Lookup caller,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="292" href="#"></a></td>
<td><pre>                                       String invokedName,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="293" href="#"></a></td>
<td><pre>                                       MethodType invokedType,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="294" href="#"></a></td>
<td><pre>                                       MethodType samMethodType,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="295" href="#"></a></td>
<td><pre>                                       MethodHandle implMethod,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="296" href="#"></a></td>
<td><pre>                                       MethodType instantiatedMethodType)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="297" href="#"></a></td>
<td><pre>            throws LambdaConversionException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="298" href="#"></a></td>
<td><pre>        AbstractValidatingLambdaMetafactory mf;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="299" href="#"></a></td>
<td><pre>        mf = new InnerClassLambdaMetafactory(caller, invokedType,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="300" href="#"></a></td>
<td><pre>                                             invokedName, samMethodType,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="301" href="#"></a></td>
<td><pre>                                             implMethod, instantiatedMethodType,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="302" href="#"></a></td>
<td><pre>                                             false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="303" href="#"></a></td>
<td><pre>        mf.validateMetafactoryArgs();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="304" href="#"></a></td>
<td><pre>        return mf.buildCallSite();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="305" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="306" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="307" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="308" href="#"></a></td>
<td><pre>     * Facilitates the creation of simple &quot;function objects&quot; that implement one</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="309" href="#"></a></td>
<td><pre>     * or more interfaces by delegation to a provided {@link MethodHandle},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="310" href="#"></a></td>
<td><pre>     * after appropriate type adaptation and partial evaluation of arguments.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="311" href="#"></a></td>
<td><pre>     * Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code invokedynamic}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="312" href="#"></a></td>
<td><pre>     * call sites, to support the &lt;em&gt;lambda expression&lt;/em&gt; and &lt;em&gt;method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="313" href="#"></a></td>
<td><pre>     * reference expression&lt;/em&gt; features of the Java Programming Language.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="314" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="315" href="#"></a></td>
<td><pre>     * &lt;p&gt;This is the general, more flexible metafactory; a streamlined version</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="316" href="#"></a></td>
<td><pre>     * is provided by {@link #altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="317" href="#"></a></td>
<td><pre>     * A general description of the behavior of this method is provided</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="318" href="#"></a></td>
<td><pre>     * {@link LambdaMetafactory above}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="319" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="320" href="#"></a></td>
<td><pre>     * &lt;p&gt;The argument list for this method includes three fixed parameters,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="321" href="#"></a></td>
<td><pre>     * corresponding to the parameters automatically stacked by the VM for the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="322" href="#"></a></td>
<td><pre>     * bootstrap method in an {@code invokedynamic} invocation, and an {@code Object[]}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="323" href="#"></a></td>
<td><pre>     * parameter that contains additional parameters.  The declared argument</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="324" href="#"></a></td>
<td><pre>     * list for this method is:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="325" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="326" href="#"></a></td>
<td><pre>     * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="327" href="#"></a></td>
<td><pre>     *  CallSite altMetafactory(MethodHandles.Lookup caller,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="328" href="#"></a></td>
<td><pre>     *                          String invokedName,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="329" href="#"></a></td>
<td><pre>     *                          MethodType invokedType,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="330" href="#"></a></td>
<td><pre>     *                          Object... args)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="331" href="#"></a></td>
<td><pre>     * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="332" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="333" href="#"></a></td>
<td><pre>     * &lt;p&gt;but it behaves as if the argument list is as follows:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="334" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="335" href="#"></a></td>
<td><pre>     * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="336" href="#"></a></td>
<td><pre>     *  CallSite altMetafactory(MethodHandles.Lookup caller,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="337" href="#"></a></td>
<td><pre>     *                          String invokedName,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="338" href="#"></a></td>
<td><pre>     *                          MethodType invokedType,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="339" href="#"></a></td>
<td><pre>     *                          MethodType samMethodType,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="340" href="#"></a></td>
<td><pre>     *                          MethodHandle implMethod,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="341" href="#"></a></td>
<td><pre>     *                          MethodType instantiatedMethodType,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="342" href="#"></a></td>
<td><pre>     *                          int flags,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="343" href="#"></a></td>
<td><pre>     *                          int markerInterfaceCount,  // IF flags has MARKERS set</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="344" href="#"></a></td>
<td><pre>     *                          Class... markerInterfaces, // IF flags has MARKERS set</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="345" href="#"></a></td>
<td><pre>     *                          int bridgeCount,           // IF flags has BRIDGES set</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="346" href="#"></a></td>
<td><pre>     *                          MethodType... bridges      // IF flags has BRIDGES set</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="347" href="#"></a></td>
<td><pre>     *                          )</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="348" href="#"></a></td>
<td><pre>     * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="349" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="350" href="#"></a></td>
<td><pre>     * &lt;p&gt;Arguments that appear in the argument list for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="351" href="#"></a></td>
<td><pre>     * {@link #metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="352" href="#"></a></td>
<td><pre>     * have the same specification as in that method.  The additional arguments</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="353" href="#"></a></td>
<td><pre>     * are interpreted as follows:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="354" href="#"></a></td>
<td><pre>     * &lt;ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="355" href="#"></a></td>
<td><pre>     *     &lt;li&gt;{@code flags} indicates additional options; this is a bitwise</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="356" href="#"></a></td>
<td><pre>     *     OR of desired flags.  Defined flags are {@link #FLAG_BRIDGES},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="357" href="#"></a></td>
<td><pre>     *     {@link #FLAG_MARKERS}, and {@link #FLAG_SERIALIZABLE}.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="358" href="#"></a></td>
<td><pre>     *     &lt;li&gt;{@code markerInterfaceCount} is the number of additional interfaces</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="359" href="#"></a></td>
<td><pre>     *     the function object should implement, and is present if and only if the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="360" href="#"></a></td>
<td><pre>     *     {@code FLAG_MARKERS} flag is set.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="361" href="#"></a></td>
<td><pre>     *     &lt;li&gt;{@code markerInterfaces} is a variable-length list of additional</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="362" href="#"></a></td>
<td><pre>     *     interfaces to implement, whose length equals {@code markerInterfaceCount},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="363" href="#"></a></td>
<td><pre>     *     and is present if and only if the {@code FLAG_MARKERS} flag is set.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="364" href="#"></a></td>
<td><pre>     *     &lt;li&gt;{@code bridgeCount} is the number of additional method signatures</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="365" href="#"></a></td>
<td><pre>     *     the function object should implement, and is present if and only if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="366" href="#"></a></td>
<td><pre>     *     the {@code FLAG_BRIDGES} flag is set.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="367" href="#"></a></td>
<td><pre>     *     &lt;li&gt;{@code bridges} is a variable-length list of additional</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="368" href="#"></a></td>
<td><pre>     *     methods signatures to implement, whose length equals {@code bridgeCount},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="369" href="#"></a></td>
<td><pre>     *     and is present if and only if the {@code FLAG_BRIDGES} flag is set.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="370" href="#"></a></td>
<td><pre>     * &lt;/ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="371" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="372" href="#"></a></td>
<td><pre>     * &lt;p&gt;Each class named by {@code markerInterfaces} is subject to the same</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="373" href="#"></a></td>
<td><pre>     * restrictions as {@code Rd}, the return type of {@code invokedType},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="374" href="#"></a></td>
<td><pre>     * as described {@link LambdaMetafactory above}.  Each {@code MethodType}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="375" href="#"></a></td>
<td><pre>     * named by {@code bridges} is subject to the same restrictions as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="376" href="#"></a></td>
<td><pre>     * {@code samMethodType}, as described {@link LambdaMetafactory above}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="377" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="378" href="#"></a></td>
<td><pre>     * &lt;p&gt;When FLAG_SERIALIZABLE is set in {@code flags}, the function objects</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="379" href="#"></a></td>
<td><pre>     * will implement {@code Serializable}, and will have a {@code writeReplace}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="380" href="#"></a></td>
<td><pre>     * method that returns an appropriate {@link SerializedLambda}.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="381" href="#"></a></td>
<td><pre>     * {@code caller} class must have an appropriate {@code $deserializeLambda$}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="382" href="#"></a></td>
<td><pre>     * method, as described in {@link SerializedLambda}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="383" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="384" href="#"></a></td>
<td><pre>     * &lt;p&gt;When the target of the {@code CallSite} returned from this method is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="385" href="#"></a></td>
<td><pre>     * invoked, the resulting function objects are instances of a class with</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="386" href="#"></a></td>
<td><pre>     * the following properties:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="387" href="#"></a></td>
<td><pre>     * &lt;ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="388" href="#"></a></td>
<td><pre>     *     &lt;li&gt;The class implements the interface named by the return type</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="389" href="#"></a></td>
<td><pre>     *     of {@code invokedType} and any interfaces named by {@code markerInterfaces}&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="390" href="#"></a></td>
<td><pre>     *     &lt;li&gt;The class declares methods with the name given by {@code invokedName},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="391" href="#"></a></td>
<td><pre>     *     and the signature given by {@code samMethodType} and additional signatures</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="392" href="#"></a></td>
<td><pre>     *     given by {@code bridges}&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="393" href="#"></a></td>
<td><pre>     *     &lt;li&gt;The class may override methods from {@code Object}, and may</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="394" href="#"></a></td>
<td><pre>     *     implement methods related to serialization.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="395" href="#"></a></td>
<td><pre>     * &lt;/ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="396" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="397" href="#"></a></td>
<td><pre>     * @param caller Represents a lookup context with the accessibility</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="398" href="#"></a></td>
<td><pre>     *               privileges of the caller.  When used with {@code invokedynamic},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="399" href="#"></a></td>
<td><pre>     *               this is stacked automatically by the VM.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="400" href="#"></a></td>
<td><pre>     * @param invokedName The name of the method to implement.  When used with</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="401" href="#"></a></td>
<td><pre>     *                    {@code invokedynamic}, this is provided by the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="402" href="#"></a></td>
<td><pre>     *                    {@code NameAndType} of the {@code InvokeDynamic}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="403" href="#"></a></td>
<td><pre>     *                    structure and is stacked automatically by the VM.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="404" href="#"></a></td>
<td><pre>     * @param invokedType The expected signature of the {@code CallSite}.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="405" href="#"></a></td>
<td><pre>     *                    parameter types represent the types of capture variables;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="406" href="#"></a></td>
<td><pre>     *                    the return type is the interface to implement.   When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="407" href="#"></a></td>
<td><pre>     *                    used with {@code invokedynamic}, this is provided by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="408" href="#"></a></td>
<td><pre>     *                    the {@code NameAndType} of the {@code InvokeDynamic}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="409" href="#"></a></td>
<td><pre>     *                    structure and is stacked automatically by the VM.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="410" href="#"></a></td>
<td><pre>     *                    In the event that the implementation method is an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="411" href="#"></a></td>
<td><pre>     *                    instance method and this signature has any parameters,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="412" href="#"></a></td>
<td><pre>     *                    the first parameter in the invocation signature must</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="413" href="#"></a></td>
<td><pre>     *                    correspond to the receiver.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="414" href="#"></a></td>
<td><pre>     * @param  args       An {@code Object[]} array containing the required</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="415" href="#"></a></td>
<td><pre>     *                    arguments {@code samMethodType}, {@code implMethod},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="416" href="#"></a></td>
<td><pre>     *                    {@code instantiatedMethodType}, {@code flags}, and any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="417" href="#"></a></td>
<td><pre>     *                    optional arguments, as described</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="418" href="#"></a></td>
<td><pre>     *                    {@link #altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)} above}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="419" href="#"></a></td>
<td><pre>     * @return a CallSite whose target can be used to perform capture, generating</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="420" href="#"></a></td>
<td><pre>     *         instances of the interface named by {@code invokedType}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="421" href="#"></a></td>
<td><pre>     * @throws LambdaConversionException If any of the linkage invariants</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="422" href="#"></a></td>
<td><pre>     *                                   described {@link LambdaMetafactory above}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="423" href="#"></a></td>
<td><pre>     *                                   are violated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="424" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="425" href="#"></a></td>
<td><pre>    public static CallSite altMetafactory(MethodHandles.Lookup caller,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="426" href="#"></a></td>
<td><pre>                                          String invokedName,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="427" href="#"></a></td>
<td><pre>                                          MethodType invokedType,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="428" href="#"></a></td>
<td><pre>                                          Object... args)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="429" href="#"></a></td>
<td><pre>            throws LambdaConversionException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="430" href="#"></a></td>
<td><pre>        MethodType samMethodType = (MethodType)args[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="431" href="#"></a></td>
<td><pre>        MethodHandle implMethod = (MethodHandle)args[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="432" href="#"></a></td>
<td><pre>        MethodType instantiatedMethodType = (MethodType)args[2];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="433" href="#"></a></td>
<td><pre>        int flags = (Integer) args[3];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="434" href="#"></a></td>
<td><pre>        Class&lt;?&gt;[] markerInterfaces;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="435" href="#"></a></td>
<td><pre>        MethodType[] bridges;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="436" href="#"></a></td>
<td><pre>        int argIndex = 4;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="437" href="#"></a></td>
<td><pre>        if ((flags &amp; FLAG_MARKERS) != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="438" href="#"></a></td>
<td><pre>            int markerCount = (Integer) args[argIndex++];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="439" href="#"></a></td>
<td><pre>            markerInterfaces = new Class&lt;?&gt;[markerCount];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="440" href="#"></a></td>
<td><pre>            System.arraycopy(args, argIndex, markerInterfaces, 0, markerCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="441" href="#"></a></td>
<td><pre>            argIndex += markerCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="442" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="443" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="444" href="#"></a></td>
<td><pre>            markerInterfaces = EMPTY_CLASS_ARRAY;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="445" href="#"></a></td>
<td><pre>        if ((flags &amp; FLAG_BRIDGES) != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="446" href="#"></a></td>
<td><pre>            int bridgeCount = (Integer) args[argIndex++];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="447" href="#"></a></td>
<td><pre>            bridges = new MethodType[bridgeCount];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="448" href="#"></a></td>
<td><pre>            System.arraycopy(args, argIndex, bridges, 0, bridgeCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="449" href="#"></a></td>
<td><pre>            argIndex += bridgeCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="450" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="451" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="452" href="#"></a></td>
<td><pre>            bridges = EMPTY_MT_ARRAY;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="453" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="454" href="#"></a></td>
<td><pre>        boolean isSerializable = ((flags &amp; FLAG_SERIALIZABLE) != 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="455" href="#"></a></td>
<td><pre>        if (isSerializable) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="456" href="#"></a></td>
<td><pre>            boolean foundSerializableSupertype = Serializable.class.isAssignableFrom(invokedType.returnType());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="457" href="#"></a></td>
<td><pre>            for (Class&lt;?&gt; c : markerInterfaces)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="458" href="#"></a></td>
<td><pre>                foundSerializableSupertype |= Serializable.class.isAssignableFrom(c);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="459" href="#"></a></td>
<td><pre>            if (!foundSerializableSupertype) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="460" href="#"></a></td>
<td><pre>                markerInterfaces = Arrays.copyOf(markerInterfaces, markerInterfaces.length + 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="461" href="#"></a></td>
<td><pre>                markerInterfaces[markerInterfaces.length-1] = Serializable.class;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="462" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="463" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="464" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="465" href="#"></a></td>
<td><pre>        AbstractValidatingLambdaMetafactory mf</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="466" href="#"></a></td>
<td><pre>                = new InnerClassLambdaMetafactory(caller, invokedType,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="467" href="#"></a></td>
<td><pre>                                                  invokedName, samMethodType,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="468" href="#"></a></td>
<td><pre>                                                  implMethod,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="469" href="#"></a></td>
<td><pre>                                                  instantiatedMethodType,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="470" href="#"></a></td>
<td><pre>                                                  isSerializable,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="471" href="#"></a></td>
<td><pre>                                                  markerInterfaces, bridges);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="472" href="#"></a></td>
<td><pre>        mf.validateMetafactoryArgs();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="473" href="#"></a></td>
<td><pre>        return mf.buildCallSite();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="474" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="475" href="#"></a></td>
<td><pre>}</pre></td>
</tr>
</table>
</body>
</html>
