<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang;

import java.security.*;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.StringTokenizer;

/**
 * This class is for runtime permissions. A RuntimePermission
 * contains a name (also referred to as a &quot;target name&quot;) but
 * no actions list; you either have the named permission
 * or you don't.
 *
 * &lt;P&gt;
 * The target name is the name of the runtime permission (see below). The
 * naming convention follows the  hierarchical property naming convention.
 * Also, an asterisk
 * may appear at the end of the name, following a &quot;.&quot;, or by itself, to
 * signify a wildcard match. For example: &quot;loadLibrary.*&quot; and &quot;*&quot; signify a
 * wildcard match, while &quot;*loadLibrary&quot; and &quot;a*b&quot; do not.
 * &lt;P&gt;
 * The following table lists all the possible RuntimePermission target names,
 * and for each provides a description of what the permission allows
 * and a discussion of the risks of granting code the permission.
 *
 * &lt;table border=1 cellpadding=5 summary=&quot;permission target name,
 *  what the target allows,and associated risks&quot;&gt;
 * &lt;tr&gt;
 * &lt;th&gt;Permission Target Name&lt;/th&gt;
 * &lt;th&gt;What the Permission Allows&lt;/th&gt;
 * &lt;th&gt;Risks of Allowing this Permission&lt;/th&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;createClassLoader&lt;/td&gt;
 *   &lt;td&gt;Creation of a class loader&lt;/td&gt;
 *   &lt;td&gt;This is an extremely dangerous permission to grant.
 * Malicious applications that can instantiate their own class
 * loaders could then load their own rogue classes into the system.
 * These newly loaded classes could be placed into any protection
 * domain by the class loader, thereby automatically granting the
 * classes the permissions for that domain.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;getClassLoader&lt;/td&gt;
 *   &lt;td&gt;Retrieval of a class loader (e.g., the class loader for the calling
 * class)&lt;/td&gt;
 *   &lt;td&gt;This would grant an attacker permission to get the
 * class loader for a particular class. This is dangerous because
 * having access to a class's class loader allows the attacker to
 * load other classes available to that class loader. The attacker
 * would typically otherwise not have access to those classes.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;setContextClassLoader&lt;/td&gt;
 *   &lt;td&gt;Setting of the context class loader used by a thread&lt;/td&gt;
 *   &lt;td&gt;The context class loader is used by system code and extensions
 * when they need to lookup resources that might not exist in the system
 * class loader. Granting setContextClassLoader permission would allow
 * code to change which context class loader is used
 * for a particular thread, including system threads.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;enableContextClassLoaderOverride&lt;/td&gt;
 *   &lt;td&gt;Subclass implementation of the thread context class loader methods&lt;/td&gt;
 *   &lt;td&gt;The context class loader is used by system code and extensions
 * when they need to lookup resources that might not exist in the system
 * class loader. Granting enableContextClassLoaderOverride permission would allow
 * a subclass of Thread to override the methods that are used
 * to get or set the context class loader for a particular thread.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;closeClassLoader&lt;/td&gt;
 *   &lt;td&gt;Closing of a ClassLoader&lt;/td&gt;
 *   &lt;td&gt;Granting this permission allows code to close any URLClassLoader
 * that it has a reference to.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;setSecurityManager&lt;/td&gt;
 *   &lt;td&gt;Setting of the security manager (possibly replacing an existing one)
 * &lt;/td&gt;
 *   &lt;td&gt;The security manager is a class that allows
 * applications to implement a security policy. Granting the setSecurityManager
 * permission would allow code to change which security manager is used by
 * installing a different, possibly less restrictive security manager,
 * thereby bypassing checks that would have been enforced by the original
 * security manager.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;createSecurityManager&lt;/td&gt;
 *   &lt;td&gt;Creation of a new security manager&lt;/td&gt;
 *   &lt;td&gt;This gives code access to protected, sensitive methods that may
 * disclose information about other classes or the execution stack.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;getenv.{variable name}&lt;/td&gt;
 *   &lt;td&gt;Reading of the value of the specified environment variable&lt;/td&gt;
 *   &lt;td&gt;This would allow code to read the value, or determine the
 *       existence, of a particular environment variable.  This is
 *       dangerous if the variable contains confidential data.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;exitVM.{exit status}&lt;/td&gt;
 *   &lt;td&gt;Halting of the Java Virtual Machine with the specified exit status&lt;/td&gt;
 *   &lt;td&gt;This allows an attacker to mount a denial-of-service attack
 * by automatically forcing the virtual machine to halt.
 * Note: The &quot;exitVM.*&quot; permission is automatically granted to all code
 * loaded from the application class path, thus enabling applications
 * to terminate themselves. Also, the &quot;exitVM&quot; permission is equivalent to
 * &quot;exitVM.*&quot;.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;shutdownHooks&lt;/td&gt;
 *   &lt;td&gt;Registration and cancellation of virtual-machine shutdown hooks&lt;/td&gt;
 *   &lt;td&gt;This allows an attacker to register a malicious shutdown
 * hook that interferes with the clean shutdown of the virtual machine.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;setFactory&lt;/td&gt;
 *   &lt;td&gt;Setting of the socket factory used by ServerSocket or Socket,
 * or of the stream handler factory used by URL&lt;/td&gt;
 *   &lt;td&gt;This allows code to set the actual implementation
 * for the socket, server socket, stream handler, or RMI socket factory.
 * An attacker may set a faulty implementation which mangles the data
 * stream.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;setIO&lt;/td&gt;
 *   &lt;td&gt;Setting of System.out, System.in, and System.err&lt;/td&gt;
 *   &lt;td&gt;This allows changing the value of the standard system streams.
 * An attacker may change System.in to monitor and
 * steal user input, or may set System.err to a &quot;null&quot; OutputStream,
 * which would hide any error messages sent to System.err. &lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;modifyThread&lt;/td&gt;
 *   &lt;td&gt;Modification of threads, e.g., via calls to Thread
 * &lt;tt&gt;interrupt&lt;/tt&gt;, &lt;tt&gt;stop&lt;/tt&gt;, &lt;tt&gt;suspend&lt;/tt&gt;,
 * &lt;tt&gt;resume&lt;/tt&gt;, &lt;tt&gt;setDaemon&lt;/tt&gt;, &lt;tt&gt;setPriority&lt;/tt&gt;,
 * &lt;tt&gt;setName&lt;/tt&gt; and &lt;tt&gt;setUncaughtExceptionHandler&lt;/tt&gt;
 * methods&lt;/td&gt;
 * &lt;td&gt;This allows an attacker to modify the behaviour of
 * any thread in the system.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;stopThread&lt;/td&gt;
 *   &lt;td&gt;Stopping of threads via calls to the Thread &lt;code&gt;stop&lt;/code&gt;
 * method&lt;/td&gt;
 *   &lt;td&gt;This allows code to stop any thread in the system provided that it is
 * already granted permission to access that thread.
 * This poses as a threat, because that code may corrupt the system by
 * killing existing threads.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;modifyThreadGroup&lt;/td&gt;
 *   &lt;td&gt;modification of thread groups, e.g., via calls to ThreadGroup
 * &lt;code&gt;destroy&lt;/code&gt;, &lt;code&gt;getParent&lt;/code&gt;, &lt;code&gt;resume&lt;/code&gt;,
 * &lt;code&gt;setDaemon&lt;/code&gt;, &lt;code&gt;setMaxPriority&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;,
 * and &lt;code&gt;suspend&lt;/code&gt; methods&lt;/td&gt;
 *   &lt;td&gt;This allows an attacker to create thread groups and
 * set their run priority.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;getProtectionDomain&lt;/td&gt;
 *   &lt;td&gt;Retrieval of the ProtectionDomain for a class&lt;/td&gt;
 *   &lt;td&gt;This allows code to obtain policy information
 * for a particular code source. While obtaining policy information
 * does not compromise the security of the system, it does give
 * attackers additional information, such as local file names for
 * example, to better aim an attack.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;getFileSystemAttributes&lt;/td&gt;
 *   &lt;td&gt;Retrieval of file system attributes&lt;/td&gt;
 *   &lt;td&gt;This allows code to obtain file system information such as disk usage
 *       or disk space available to the caller.  This is potentially dangerous
 *       because it discloses information about the system hardware
 *       configuration and some information about the caller's privilege to
 *       write files.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;readFileDescriptor&lt;/td&gt;
 *   &lt;td&gt;Reading of file descriptors&lt;/td&gt;
 *   &lt;td&gt;This would allow code to read the particular file associated
 *       with the file descriptor read. This is dangerous if the file
 *       contains confidential data.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;writeFileDescriptor&lt;/td&gt;
 *   &lt;td&gt;Writing to file descriptors&lt;/td&gt;
 *   &lt;td&gt;This allows code to write to a particular file associated
 *       with the descriptor. This is dangerous because it may allow
 *       malicious code to plant viruses or at the very least, fill up
 *       your entire disk.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;loadLibrary.{library name}&lt;/td&gt;
 *   &lt;td&gt;Dynamic linking of the specified library&lt;/td&gt;
 *   &lt;td&gt;It is dangerous to allow an applet permission to load native code
 * libraries, because the Java security architecture is not designed to and
 * does not prevent malicious behavior at the level of native code.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;accessClassInPackage.{package name}&lt;/td&gt;
 *   &lt;td&gt;Access to the specified package via a class loader's
 * &lt;code&gt;loadClass&lt;/code&gt; method when that class loader calls
 * the SecurityManager &lt;code&gt;checkPackageAccess&lt;/code&gt; method&lt;/td&gt;
 *   &lt;td&gt;This gives code access to classes in packages
 * to which it normally does not have access. Malicious code
 * may use these classes to help in its attempt to compromise
 * security in the system.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;defineClassInPackage.{package name}&lt;/td&gt;
 *   &lt;td&gt;Definition of classes in the specified package, via a class
 * loader's &lt;code&gt;defineClass&lt;/code&gt; method when that class loader calls
 * the SecurityManager &lt;code&gt;checkPackageDefinition&lt;/code&gt; method.&lt;/td&gt;
 *   &lt;td&gt;This grants code permission to define a class
 * in a particular package. This is dangerous because malicious
 * code with this permission may define rogue classes in
 * trusted packages like &lt;code&gt;java.security&lt;/code&gt; or &lt;code&gt;java.lang&lt;/code&gt;,
 * for example.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;accessDeclaredMembers&lt;/td&gt;
 *   &lt;td&gt;Access to the declared members of a class&lt;/td&gt;
 *   &lt;td&gt;This grants code permission to query a class for its public,
 * protected, default (package) access, and private fields and/or
 * methods. Although the code would have
 * access to the private and protected field and method names, it would not
 * have access to the private/protected field data and would not be able
 * to invoke any private methods. Nevertheless, malicious code
 * may use this information to better aim an attack.
 * Additionally, it may invoke any public methods and/or access public fields
 * in the class.  This could be dangerous if
 * the code would normally not be able to invoke those methods and/or
 * access the fields  because
 * it can't cast the object to the class/interface with those methods
 * and fields.
&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *   &lt;td&gt;queuePrintJob&lt;/td&gt;
 *   &lt;td&gt;Initiation of a print job request&lt;/td&gt;
 *   &lt;td&gt;This could print sensitive information to a printer,
 * or simply waste paper.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;getStackTrace&lt;/td&gt;
 *   &lt;td&gt;Retrieval of the stack trace information of another thread.&lt;/td&gt;
 *   &lt;td&gt;This allows retrieval of the stack trace information of
 * another thread.  This might allow malicious code to monitor the
 * execution of threads and discover vulnerabilities in applications.&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;setDefaultUncaughtExceptionHandler&lt;/td&gt;
 *   &lt;td&gt;Setting the default handler to be used when a thread
 *   terminates abruptly due to an uncaught exception&lt;/td&gt;
 *   &lt;td&gt;This allows an attacker to register a malicious
 *   uncaught exception handler that could interfere with termination
 *   of a thread&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;preferences&lt;/td&gt;
 *   &lt;td&gt;Represents the permission required to get access to the
 *   java.util.prefs.Preferences implementations user or system root
 *   which in turn allows retrieval or update operations within the
 *   Preferences persistent backing store.) &lt;/td&gt;
 *   &lt;td&gt;This permission allows the user to read from or write to the
 *   preferences backing store if the user running the code has
 *   sufficient OS privileges to read/write to that backing store.
 *   The actual backing store may reside within a traditional filesystem
 *   directory or within a registry depending on the platform OS&lt;/td&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;
 *   &lt;td&gt;usePolicy&lt;/td&gt;
 *   &lt;td&gt;Granting this permission disables the Java Plug-In's default
 *   security prompting behavior.&lt;/td&gt;
 *   &lt;td&gt;For more information, refer to Java Plug-In's guides, &lt;a href=
 *   &quot;../../../technotes/guides/plugin/developer_guide/security.html&quot;&gt;
 *   Applet Security Basics&lt;/a&gt; and &lt;a href=
 *   &quot;../../../technotes/guides/plugin/developer_guide/rsa_how.html#use&quot;&gt;
 *   usePolicy Permission&lt;/a&gt;.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;
 *
 * @see java.security.BasicPermission
 * @see java.security.Permission
 * @see java.security.Permissions
 * @see java.security.PermissionCollection
 * @see java.lang.SecurityManager
 *
 *
 * @author Marianne Mueller
 * @author Roland Schemers
 */

public final class RuntimePermission extends BasicPermission {

    private static final long serialVersionUID = 7399184964622342223L;

    /**
     * Creates a new RuntimePermission with the specified name.
     * The name is the symbolic name of the RuntimePermission, such as
     * &quot;exit&quot;, &quot;setFactory&quot;, etc. An asterisk
     * may appear at the end of the name, following a &quot;.&quot;, or by itself, to
     * signify a wildcard match.
     *
     * @param name the name of the RuntimePermission.
     *
     * @throws NullPointerException if &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; is empty.
     */

    public RuntimePermission(String name)
    {
        super(name);
    }

    /**
     * Creates a new RuntimePermission object with the specified name.
     * The name is the symbolic name of the RuntimePermission, and the
     * actions String is currently unused and should be null.
     *
     * @param name the name of the RuntimePermission.
     * @param actions should be null.
     *
     * @throws NullPointerException if &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; is empty.
     */

    public RuntimePermission(String name, String actions)
    {
        super(name, actions);
    }
}
</pre>
</body>
</html>
