<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang;

import java.security.*;
import java.io.FileDescriptor;
import java.io.File;
import java.io.FilePermission;
import java.awt.AWTPermission;
import java.util.PropertyPermission;
import java.lang.RuntimePermission;
import java.net.SocketPermission;
import java.net.NetPermission;
import java.util.Hashtable;
import java.net.InetAddress;
import java.lang.reflect.*;
import java.net.URL;

import sun.reflect.CallerSensitive;
import sun.security.util.SecurityConstants;

/**
 * The security manager is a class that allows
 * applications to implement a security policy. It allows an
 * application to determine, before performing a possibly unsafe or
 * sensitive operation, what the operation is and whether
 * it is being attempted in a security context that allows the
 * operation to be performed. The
 * application can allow or disallow the operation.
 * &lt;p&gt;
 * The &lt;code&gt;SecurityManager&lt;/code&gt; class contains many methods with
 * names that begin with the word &lt;code&gt;check&lt;/code&gt;. These methods
 * are called by various methods in the Java libraries before those
 * methods perform certain potentially sensitive operations. The
 * invocation of such a &lt;code&gt;check&lt;/code&gt; method typically looks like this:
 * &lt;blockquote&gt;&lt;pre&gt;
 *     SecurityManager security = System.getSecurityManager();
 *     if (security != null) {
 *         security.check&lt;i&gt;XXX&lt;/i&gt;(argument, &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.&amp;nbsp;);
 *     }
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;p&gt;
 * The security manager is thereby given an opportunity to prevent
 * completion of the operation by throwing an exception. A security
 * manager routine simply returns if the operation is permitted, but
 * throws a &lt;code&gt;SecurityException&lt;/code&gt; if the operation is not
 * permitted. The only exception to this convention is
 * &lt;code&gt;checkTopLevelWindow&lt;/code&gt;, which returns a
 * &lt;code&gt;boolean&lt;/code&gt; value.
 * &lt;p&gt;
 * The current security manager is set by the
 * &lt;code&gt;setSecurityManager&lt;/code&gt; method in class
 * &lt;code&gt;System&lt;/code&gt;. The current security manager is obtained
 * by the &lt;code&gt;getSecurityManager&lt;/code&gt; method.
 * &lt;p&gt;
 * The special method
 * {@link SecurityManager#checkPermission(java.security.Permission)}
 * determines whether an access request indicated by a specified
 * permission should be granted or denied. The
 * default implementation calls
 *
 * &lt;pre&gt;
 *   AccessController.checkPermission(perm);
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * If a requested access is allowed,
 * &lt;code&gt;checkPermission&lt;/code&gt; returns quietly. If denied, a
 * &lt;code&gt;SecurityException&lt;/code&gt; is thrown.
 * &lt;p&gt;
 * As of Java 2 SDK v1.2, the default implementation of each of the other
 * &lt;code&gt;check&lt;/code&gt; methods in &lt;code&gt;SecurityManager&lt;/code&gt; is to
 * call the &lt;code&gt;SecurityManager checkPermission&lt;/code&gt; method
 * to determine if the calling thread has permission to perform the requested
 * operation.
 * &lt;p&gt;
 * Note that the &lt;code&gt;checkPermission&lt;/code&gt; method with
 * just a single permission argument always performs security checks
 * within the context of the currently executing thread.
 * Sometimes a security check that should be made within a given context
 * will actually need to be done from within a
 * &lt;i&gt;different&lt;/i&gt; context (for example, from within a worker thread).
 * The {@link SecurityManager#getSecurityContext getSecurityContext} method
 * and the {@link SecurityManager#checkPermission(java.security.Permission,
 * java.lang.Object) checkPermission}
 * method that includes a context argument are provided
 * for this situation. The
 * &lt;code&gt;getSecurityContext&lt;/code&gt; method returns a &quot;snapshot&quot;
 * of the current calling context. (The default implementation
 * returns an AccessControlContext object.) A sample call is
 * the following:
 *
 * &lt;pre&gt;
 *   Object context = null;
 *   SecurityManager sm = System.getSecurityManager();
 *   if (sm != null) context = sm.getSecurityContext();
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * The &lt;code&gt;checkPermission&lt;/code&gt; method
 * that takes a context object in addition to a permission
 * makes access decisions based on that context,
 * rather than on that of the current execution thread.
 * Code within a different context can thus call that method,
 * passing the permission and the
 * previously-saved context object. A sample call, using the
 * SecurityManager &lt;code&gt;sm&lt;/code&gt; obtained as in the previous example,
 * is the following:
 *
 * &lt;pre&gt;
 *   if (sm != null) sm.checkPermission(permission, context);
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Permissions fall into these categories: File, Socket, Net,
 * Security, Runtime, Property, AWT, Reflect, and Serializable.
 * The classes managing these various
 * permission categories are &lt;code&gt;java.io.FilePermission&lt;/code&gt;,
 * &lt;code&gt;java.net.SocketPermission&lt;/code&gt;,
 * &lt;code&gt;java.net.NetPermission&lt;/code&gt;,
 * &lt;code&gt;java.security.SecurityPermission&lt;/code&gt;,
 * &lt;code&gt;java.lang.RuntimePermission&lt;/code&gt;,
 * &lt;code&gt;java.util.PropertyPermission&lt;/code&gt;,
 * &lt;code&gt;java.awt.AWTPermission&lt;/code&gt;,
 * &lt;code&gt;java.lang.reflect.ReflectPermission&lt;/code&gt;, and
 * &lt;code&gt;java.io.SerializablePermission&lt;/code&gt;.
 *
 * &lt;p&gt;All but the first two (FilePermission and SocketPermission) are
 * subclasses of &lt;code&gt;java.security.BasicPermission&lt;/code&gt;, which itself
 * is an abstract subclass of the
 * top-level class for permissions, which is
 * &lt;code&gt;java.security.Permission&lt;/code&gt;. BasicPermission defines the
 * functionality needed for all permissions that contain a name
 * that follows the hierarchical property naming convention
 * (for example, &quot;exitVM&quot;, &quot;setFactory&quot;, &quot;queuePrintJob&quot;, etc).
 * An asterisk
 * may appear at the end of the name, following a &quot;.&quot;, or by itself, to
 * signify a wildcard match. For example: &quot;a.*&quot; or &quot;*&quot; is valid,
 * &quot;*a&quot; or &quot;a*b&quot; is not valid.
 *
 * &lt;p&gt;FilePermission and SocketPermission are subclasses of the
 * top-level class for permissions
 * (&lt;code&gt;java.security.Permission&lt;/code&gt;). Classes like these
 * that have a more complicated name syntax than that used by
 * BasicPermission subclass directly from Permission rather than from
 * BasicPermission. For example,
 * for a &lt;code&gt;java.io.FilePermission&lt;/code&gt; object, the permission name is
 * the path name of a file (or directory).
 *
 * &lt;p&gt;Some of the permission classes have an &quot;actions&quot; list that tells
 * the actions that are permitted for the object.  For example,
 * for a &lt;code&gt;java.io.FilePermission&lt;/code&gt; object, the actions list
 * (such as &quot;read, write&quot;) specifies which actions are granted for the
 * specified file (or for files in the specified directory).
 *
 * &lt;p&gt;Other permission classes are for &quot;named&quot; permissions -
 * ones that contain a name but no actions list; you either have the
 * named permission or you don't.
 *
 * &lt;p&gt;Note: There is also a &lt;code&gt;java.security.AllPermission&lt;/code&gt;
 * permission that implies all permissions. It exists to simplify the work
 * of system administrators who might need to perform multiple
 * tasks that require all (or numerous) permissions.
 * &lt;p&gt;
 * See &lt;a href =&quot;../../../technotes/guides/security/permissions.html&quot;&gt;
 * Permissions in the JDK&lt;/a&gt; for permission-related information.
 * This document includes, for example, a table listing the various SecurityManager
 * &lt;code&gt;check&lt;/code&gt; methods and the permission(s) the default
 * implementation of each such method requires.
 * It also contains a table of all the version 1.2 methods
 * that require permissions, and for each such method tells
 * which permission it requires.
 * &lt;p&gt;
 * For more information about &lt;code&gt;SecurityManager&lt;/code&gt; changes made in
 * the JDK and advice regarding porting of 1.1-style security managers,
 * see the &lt;a href=&quot;../../../technotes/guides/security/index.html&quot;&gt;security documentation&lt;/a&gt;.
 *
 * @author  Arthur van Hoff
 * @author  Roland Schemers
 *
 * @see     java.lang.ClassLoader
 * @see     java.lang.SecurityException
 * @see     java.lang.SecurityManager#checkTopLevelWindow(java.lang.Object)
 *  checkTopLevelWindow
 * @see     java.lang.System#getSecurityManager() getSecurityManager
 * @see     java.lang.System#setSecurityManager(java.lang.SecurityManager)
 *  setSecurityManager
 * @see     java.security.AccessController AccessController
 * @see     java.security.AccessControlContext AccessControlContext
 * @see     java.security.AccessControlException AccessControlException
 * @see     java.security.Permission
 * @see     java.security.BasicPermission
 * @see     java.io.FilePermission
 * @see     java.net.SocketPermission
 * @see     java.util.PropertyPermission
 * @see     java.lang.RuntimePermission
 * @see     java.awt.AWTPermission
 * @see     java.security.Policy Policy
 * @see     java.security.SecurityPermission SecurityPermission
 * @see     java.security.ProtectionDomain
 *
 * @since   JDK1.0
 */
public
class SecurityManager {

    /**
     * This field is &lt;code&gt;true&lt;/code&gt; if there is a security check in
     * progress; &lt;code&gt;false&lt;/code&gt; otherwise.
     *
     * @deprecated This type of security checking is not recommended.
     *  It is recommended that the &lt;code&gt;checkPermission&lt;/code&gt;
     *  call be used instead.
     */
    @Deprecated
    protected boolean inCheck;

    /*
     * Have we been initialized. Effective against finalizer attacks.
     */
    private boolean initialized = false;


    /**
     * returns true if the current context has been granted AllPermission
     */
    private boolean hasAllPermission()
    {
        try {
            checkPermission(SecurityConstants.ALL_PERMISSION);
            return true;
        } catch (SecurityException se) {
            return false;
        }
    }

    /**
     * Tests if there is a security check in progress.
     *
     * @return the value of the &lt;code&gt;inCheck&lt;/code&gt; field. This field
     *          should contain &lt;code&gt;true&lt;/code&gt; if a security check is
     *          in progress,
     *          &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see     java.lang.SecurityManager#inCheck
     * @deprecated This type of security checking is not recommended.
     *  It is recommended that the &lt;code&gt;checkPermission&lt;/code&gt;
     *  call be used instead.
     */
    @Deprecated
    public boolean getInCheck() {
        return inCheck;
    }

    /**
     * Constructs a new &lt;code&gt;SecurityManager&lt;/code&gt;.
     *
     * &lt;p&gt; If there is a security manager already installed, this method first
     * calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method
     * with the &lt;code&gt;RuntimePermission(&quot;createSecurityManager&quot;)&lt;/code&gt;
     * permission to ensure the calling thread has permission to create a new
     * security manager.
     * This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.
     *
     * @exception  java.lang.SecurityException if a security manager already
     *             exists and its &lt;code&gt;checkPermission&lt;/code&gt; method
     *             doesn't allow creation of a new security manager.
     * @see        java.lang.System#getSecurityManager()
     * @see        #checkPermission(java.security.Permission) checkPermission
     * @see java.lang.RuntimePermission
     */
    public SecurityManager() {
        synchronized(SecurityManager.class) {
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                // ask the currently installed security manager if we
                // can create a new one.
                sm.checkPermission(new RuntimePermission
                                   (&quot;createSecurityManager&quot;));
            }
            initialized = true;
        }
    }

    /**
     * Returns the current execution stack as an array of classes.
     * &lt;p&gt;
     * The length of the array is the number of methods on the execution
     * stack. The element at index &lt;code&gt;0&lt;/code&gt; is the class of the
     * currently executing method, the element at index &lt;code&gt;1&lt;/code&gt; is
     * the class of that method's caller, and so on.
     *
     * @return  the execution stack.
     */
    protected native Class[] getClassContext();

    /**
     * Returns the class loader of the most recently executing method from
     * a class defined using a non-system class loader. A non-system
     * class loader is defined as being a class loader that is not equal to
     * the system class loader (as returned
     * by {@link ClassLoader#getSystemClassLoader}) or one of its ancestors.
     * &lt;p&gt;
     * This method will return
     * &lt;code&gt;null&lt;/code&gt; in the following three cases:
     * &lt;ol&gt;
     *   &lt;li&gt;All methods on the execution stack are from classes
     *   defined using the system class loader or one of its ancestors.
     *
     *   &lt;li&gt;All methods on the execution stack up to the first
     *   &quot;privileged&quot; caller
     *   (see {@link java.security.AccessController#doPrivileged})
     *   are from classes
     *   defined using the system class loader or one of its ancestors.
     *
     *   &lt;li&gt; A call to &lt;code&gt;checkPermission&lt;/code&gt; with
     *   &lt;code&gt;java.security.AllPermission&lt;/code&gt; does not
     *   result in a SecurityException.
     *
     * &lt;/ol&gt;
     *
     * @return  the class loader of the most recent occurrence on the stack
     *          of a method from a class defined using a non-system class
     *          loader.
     *
     * @deprecated This type of security checking is not recommended.
     *  It is recommended that the &lt;code&gt;checkPermission&lt;/code&gt;
     *  call be used instead.
     *
     * @see  java.lang.ClassLoader#getSystemClassLoader() getSystemClassLoader
     * @see  #checkPermission(java.security.Permission) checkPermission
     */
    @Deprecated
    protected ClassLoader currentClassLoader()
    {
        ClassLoader cl = currentClassLoader0();
        if ((cl != null) &amp;&amp; hasAllPermission())
            cl = null;
        return cl;
    }

    private native ClassLoader currentClassLoader0();

    /**
     * Returns the class of the most recently executing method from
     * a class defined using a non-system class loader. A non-system
     * class loader is defined as being a class loader that is not equal to
     * the system class loader (as returned
     * by {@link ClassLoader#getSystemClassLoader}) or one of its ancestors.
     * &lt;p&gt;
     * This method will return
     * &lt;code&gt;null&lt;/code&gt; in the following three cases:
     * &lt;ol&gt;
     *   &lt;li&gt;All methods on the execution stack are from classes
     *   defined using the system class loader or one of its ancestors.
     *
     *   &lt;li&gt;All methods on the execution stack up to the first
     *   &quot;privileged&quot; caller
     *   (see {@link java.security.AccessController#doPrivileged})
     *   are from classes
     *   defined using the system class loader or one of its ancestors.
     *
     *   &lt;li&gt; A call to &lt;code&gt;checkPermission&lt;/code&gt; with
     *   &lt;code&gt;java.security.AllPermission&lt;/code&gt; does not
     *   result in a SecurityException.
     *
     * &lt;/ol&gt;
     *
     * @return  the class  of the most recent occurrence on the stack
     *          of a method from a class defined using a non-system class
     *          loader.
     *
     * @deprecated This type of security checking is not recommended.
     *  It is recommended that the &lt;code&gt;checkPermission&lt;/code&gt;
     *  call be used instead.
     *
     * @see  java.lang.ClassLoader#getSystemClassLoader() getSystemClassLoader
     * @see  #checkPermission(java.security.Permission) checkPermission
     */
    @Deprecated
    protected Class&lt;?&gt; currentLoadedClass() {
        Class&lt;?&gt; c = currentLoadedClass0();
        if ((c != null) &amp;&amp; hasAllPermission())
            c = null;
        return c;
    }

    /**
     * Returns the stack depth of the specified class.
     *
     * @param   name   the fully qualified name of the class to search for.
     * @return  the depth on the stack frame of the first occurrence of a
     *          method from a class with the specified name;
     *          &lt;code&gt;-1&lt;/code&gt; if such a frame cannot be found.
     * @deprecated This type of security checking is not recommended.
     *  It is recommended that the &lt;code&gt;checkPermission&lt;/code&gt;
     *  call be used instead.
     *
     */
    @Deprecated
    protected native int classDepth(String name);

    /**
     * Returns the stack depth of the most recently executing method
     * from a class defined using a non-system class loader.  A non-system
     * class loader is defined as being a class loader that is not equal to
     * the system class loader (as returned
     * by {@link ClassLoader#getSystemClassLoader}) or one of its ancestors.
     * &lt;p&gt;
     * This method will return
     * -1 in the following three cases:
     * &lt;ol&gt;
     *   &lt;li&gt;All methods on the execution stack are from classes
     *   defined using the system class loader or one of its ancestors.
     *
     *   &lt;li&gt;All methods on the execution stack up to the first
     *   &quot;privileged&quot; caller
     *   (see {@link java.security.AccessController#doPrivileged})
     *   are from classes
     *   defined using the system class loader or one of its ancestors.
     *
     *   &lt;li&gt; A call to &lt;code&gt;checkPermission&lt;/code&gt; with
     *   &lt;code&gt;java.security.AllPermission&lt;/code&gt; does not
     *   result in a SecurityException.
     *
     * &lt;/ol&gt;
     *
     * @return the depth on the stack frame of the most recent occurrence of
     *          a method from a class defined using a non-system class loader.
     *
     * @deprecated This type of security checking is not recommended.
     *  It is recommended that the &lt;code&gt;checkPermission&lt;/code&gt;
     *  call be used instead.
     *
     * @see   java.lang.ClassLoader#getSystemClassLoader() getSystemClassLoader
     * @see   #checkPermission(java.security.Permission) checkPermission
     */
    @Deprecated
    protected int classLoaderDepth()
    {
        int depth = classLoaderDepth0();
        if (depth != -1) {
            if (hasAllPermission())
                depth = -1;
            else
                depth--; // make sure we don't include ourself
        }
        return depth;
    }

    private native int classLoaderDepth0();

    /**
     * Tests if a method from a class with the specified
     *         name is on the execution stack.
     *
     * @param  name   the fully qualified name of the class.
     * @return &lt;code&gt;true&lt;/code&gt; if a method from a class with the specified
     *         name is on the execution stack; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @deprecated This type of security checking is not recommended.
     *  It is recommended that the &lt;code&gt;checkPermission&lt;/code&gt;
     *  call be used instead.
     */
    @Deprecated
    protected boolean inClass(String name) {
        return classDepth(name) &gt;= 0;
    }

    /**
     * Basically, tests if a method from a class defined using a
     *          class loader is on the execution stack.
     *
     * @return  &lt;code&gt;true&lt;/code&gt; if a call to &lt;code&gt;currentClassLoader&lt;/code&gt;
     *          has a non-null return value.
     *
     * @deprecated This type of security checking is not recommended.
     *  It is recommended that the &lt;code&gt;checkPermission&lt;/code&gt;
     *  call be used instead.
     * @see        #currentClassLoader() currentClassLoader
     */
    @Deprecated
    protected boolean inClassLoader() {
        return currentClassLoader() != null;
    }

    /**
     * Creates an object that encapsulates the current execution
     * environment. The result of this method is used, for example, by the
     * three-argument &lt;code&gt;checkConnect&lt;/code&gt; method and by the
     * two-argument &lt;code&gt;checkRead&lt;/code&gt; method.
     * These methods are needed because a trusted method may be called
     * on to read a file or open a socket on behalf of another method.
     * The trusted method needs to determine if the other (possibly
     * untrusted) method would be allowed to perform the operation on its
     * own.
     * &lt;p&gt; The default implementation of this method is to return
     * an &lt;code&gt;AccessControlContext&lt;/code&gt; object.
     *
     * @return  an implementation-dependent object that encapsulates
     *          sufficient information about the current execution environment
     *          to perform some security checks later.
     * @see     java.lang.SecurityManager#checkConnect(java.lang.String, int,
     *   java.lang.Object) checkConnect
     * @see     java.lang.SecurityManager#checkRead(java.lang.String,
     *   java.lang.Object) checkRead
     * @see     java.security.AccessControlContext AccessControlContext
     */
    public Object getSecurityContext() {
        return AccessController.getContext();
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the requested
     * access, specified by the given permission, is not permitted based
     * on the security policy currently in effect.
     * &lt;p&gt;
     * This method calls &lt;code&gt;AccessController.checkPermission&lt;/code&gt;
     * with the given permission.
     *
     * @param     perm   the requested permission.
     * @exception SecurityException if access is not permitted based on
     *            the current security policy.
     * @exception NullPointerException if the permission argument is
     *            &lt;code&gt;null&lt;/code&gt;.
     * @since     1.2
     */
    public void checkPermission(Permission perm) {
        java.security.AccessController.checkPermission(perm);
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * specified security context is denied access to the resource
     * specified by the given permission.
     * The context must be a security
     * context returned by a previous call to
     * &lt;code&gt;getSecurityContext&lt;/code&gt; and the access control
     * decision is based upon the configured security policy for
     * that security context.
     * &lt;p&gt;
     * If &lt;code&gt;context&lt;/code&gt; is an instance of
     * &lt;code&gt;AccessControlContext&lt;/code&gt; then the
     * &lt;code&gt;AccessControlContext.checkPermission&lt;/code&gt; method is
     * invoked with the specified permission.
     * &lt;p&gt;
     * If &lt;code&gt;context&lt;/code&gt; is not an instance of
     * &lt;code&gt;AccessControlContext&lt;/code&gt; then a
     * &lt;code&gt;SecurityException&lt;/code&gt; is thrown.
     *
     * @param      perm      the specified permission
     * @param      context   a system-dependent security context.
     * @exception  SecurityException  if the specified security context
     *             is not an instance of &lt;code&gt;AccessControlContext&lt;/code&gt;
     *             (e.g., is &lt;code&gt;null&lt;/code&gt;), or is denied access to the
     *             resource specified by the given permission.
     * @exception  NullPointerException if the permission argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @see        java.lang.SecurityManager#getSecurityContext()
     * @see java.security.AccessControlContext#checkPermission(java.security.Permission)
     * @since      1.2
     */
    public void checkPermission(Permission perm, Object context) {
        if (context instanceof AccessControlContext) {
            ((AccessControlContext)context).checkPermission(perm);
        } else {
            throw new SecurityException();
        }
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to create a new class loader.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;RuntimePermission(&quot;createClassLoader&quot;)&lt;/code&gt;
     * permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkCreateClassLoader&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @exception SecurityException if the calling thread does not
     *             have permission
     *             to create a new class loader.
     * @see        java.lang.ClassLoader#ClassLoader()
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkCreateClassLoader() {
        checkPermission(SecurityConstants.CREATE_CLASSLOADER_PERMISSION);
    }

    /**
     * reference to the root thread group, used for the checkAccess
     * methods.
     */

    private static ThreadGroup rootGroup = getRootGroup();

    private static ThreadGroup getRootGroup() {
        ThreadGroup root =  Thread.currentThread().getThreadGroup();
        while (root.getParent() != null) {
            root = root.getParent();
        }
        return root;
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to modify the thread argument.
     * &lt;p&gt;
     * This method is invoked for the current security manager by the
     * &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;suspend&lt;/code&gt;, &lt;code&gt;resume&lt;/code&gt;,
     * &lt;code&gt;setPriority&lt;/code&gt;, &lt;code&gt;setName&lt;/code&gt;, and
     * &lt;code&gt;setDaemon&lt;/code&gt; methods of class &lt;code&gt;Thread&lt;/code&gt;.
     * &lt;p&gt;
     * If the thread argument is a system thread (belongs to
     * the thread group with a &lt;code&gt;null&lt;/code&gt; parent) then
     * this method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;RuntimePermission(&quot;modifyThread&quot;)&lt;/code&gt; permission.
     * If the thread argument is &lt;i&gt;not&lt;/i&gt; a system thread,
     * this method just returns silently.
     * &lt;p&gt;
     * Applications that want a stricter policy should override this
     * method. If this method is overridden, the method that overrides
     * it should additionally check to see if the calling thread has the
     * &lt;code&gt;RuntimePermission(&quot;modifyThread&quot;)&lt;/code&gt; permission, and
     * if so, return silently. This is to ensure that code granted
     * that permission (such as the JDK itself) is allowed to
     * manipulate any thread.
     * &lt;p&gt;
     * If this method is overridden, then
     * &lt;code&gt;super.checkAccess&lt;/code&gt; should
     * be called by the first statement in the overridden method, or the
     * equivalent security check should be placed in the overridden method.
     *
     * @param      t   the thread to be checked.
     * @exception  SecurityException  if the calling thread does not have
     *             permission to modify the thread.
     * @exception  NullPointerException if the thread argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @see        java.lang.Thread#resume() resume
     * @see        java.lang.Thread#setDaemon(boolean) setDaemon
     * @see        java.lang.Thread#setName(java.lang.String) setName
     * @see        java.lang.Thread#setPriority(int) setPriority
     * @see        java.lang.Thread#stop() stop
     * @see        java.lang.Thread#suspend() suspend
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkAccess(Thread t) {
        if (t == null) {
            throw new NullPointerException(&quot;thread can't be null&quot;);
        }
        if (t.getThreadGroup() == rootGroup) {
            checkPermission(SecurityConstants.MODIFY_THREAD_PERMISSION);
        } else {
            // just return
        }
    }
    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to modify the thread group argument.
     * &lt;p&gt;
     * This method is invoked for the current security manager when a
     * new child thread or child thread group is created, and by the
     * &lt;code&gt;setDaemon&lt;/code&gt;, &lt;code&gt;setMaxPriority&lt;/code&gt;,
     * &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;suspend&lt;/code&gt;, &lt;code&gt;resume&lt;/code&gt;, and
     * &lt;code&gt;destroy&lt;/code&gt; methods of class &lt;code&gt;ThreadGroup&lt;/code&gt;.
     * &lt;p&gt;
     * If the thread group argument is the system thread group (
     * has a &lt;code&gt;null&lt;/code&gt; parent) then
     * this method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; permission.
     * If the thread group argument is &lt;i&gt;not&lt;/i&gt; the system thread group,
     * this method just returns silently.
     * &lt;p&gt;
     * Applications that want a stricter policy should override this
     * method. If this method is overridden, the method that overrides
     * it should additionally check to see if the calling thread has the
     * &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; permission, and
     * if so, return silently. This is to ensure that code granted
     * that permission (such as the JDK itself) is allowed to
     * manipulate any thread.
     * &lt;p&gt;
     * If this method is overridden, then
     * &lt;code&gt;super.checkAccess&lt;/code&gt; should
     * be called by the first statement in the overridden method, or the
     * equivalent security check should be placed in the overridden method.
     *
     * @param      g   the thread group to be checked.
     * @exception  SecurityException  if the calling thread does not have
     *             permission to modify the thread group.
     * @exception  NullPointerException if the thread group argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @see        java.lang.ThreadGroup#destroy() destroy
     * @see        java.lang.ThreadGroup#resume() resume
     * @see        java.lang.ThreadGroup#setDaemon(boolean) setDaemon
     * @see        java.lang.ThreadGroup#setMaxPriority(int) setMaxPriority
     * @see        java.lang.ThreadGroup#stop() stop
     * @see        java.lang.ThreadGroup#suspend() suspend
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkAccess(ThreadGroup g) {
        if (g == null) {
            throw new NullPointerException(&quot;thread group can't be null&quot;);
        }
        if (g == rootGroup) {
            checkPermission(SecurityConstants.MODIFY_THREADGROUP_PERMISSION);
        } else {
            // just return
        }
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to cause the Java Virtual Machine to
     * halt with the specified status code.
     * &lt;p&gt;
     * This method is invoked for the current security manager by the
     * &lt;code&gt;exit&lt;/code&gt; method of class &lt;code&gt;Runtime&lt;/code&gt;. A status
     * of &lt;code&gt;0&lt;/code&gt; indicates success; other values indicate various
     * errors.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;RuntimePermission(&quot;exitVM.&quot;+status)&lt;/code&gt; permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkExit&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      status   the exit status.
     * @exception SecurityException if the calling thread does not have
     *              permission to halt the Java Virtual Machine with
     *              the specified status.
     * @see        java.lang.Runtime#exit(int) exit
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkExit(int status) {
        checkPermission(new RuntimePermission(&quot;exitVM.&quot;+status));
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to create a subprocess.
     * &lt;p&gt;
     * This method is invoked for the current security manager by the
     * &lt;code&gt;exec&lt;/code&gt; methods of class &lt;code&gt;Runtime&lt;/code&gt;.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;FilePermission(cmd,&quot;execute&quot;)&lt;/code&gt; permission
     * if cmd is an absolute path, otherwise it calls
     * &lt;code&gt;checkPermission&lt;/code&gt; with
     * &lt;code&gt;FilePermission(&quot;&amp;lt;&amp;lt;ALL FILES&amp;gt;&amp;gt;&quot;,&quot;execute&quot;)&lt;/code&gt;.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkExec&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      cmd   the specified system command.
     * @exception  SecurityException if the calling thread does not have
     *             permission to create a subprocess.
     * @exception  NullPointerException if the &lt;code&gt;cmd&lt;/code&gt; argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @see     java.lang.Runtime#exec(java.lang.String)
     * @see     java.lang.Runtime#exec(java.lang.String, java.lang.String[])
     * @see     java.lang.Runtime#exec(java.lang.String[])
     * @see     java.lang.Runtime#exec(java.lang.String[], java.lang.String[])
     * @see     #checkPermission(java.security.Permission) checkPermission
     */
    public void checkExec(String cmd) {
        File f = new File(cmd);
        if (f.isAbsolute()) {
            checkPermission(new FilePermission(cmd,
                SecurityConstants.FILE_EXECUTE_ACTION));
        } else {
            checkPermission(new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;,
                SecurityConstants.FILE_EXECUTE_ACTION));
        }
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to dynamic link the library code
     * specified by the string argument file. The argument is either a
     * simple library name or a complete filename.
     * &lt;p&gt;
     * This method is invoked for the current security manager by
     * methods &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;loadLibrary&lt;/code&gt; of class
     * &lt;code&gt;Runtime&lt;/code&gt;.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;RuntimePermission(&quot;loadLibrary.&quot;+lib)&lt;/code&gt; permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkLink&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      lib   the name of the library.
     * @exception  SecurityException if the calling thread does not have
     *             permission to dynamically link the library.
     * @exception  NullPointerException if the &lt;code&gt;lib&lt;/code&gt; argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @see        java.lang.Runtime#load(java.lang.String)
     * @see        java.lang.Runtime#loadLibrary(java.lang.String)
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkLink(String lib) {
        if (lib == null) {
            throw new NullPointerException(&quot;library can't be null&quot;);
        }
        checkPermission(new RuntimePermission(&quot;loadLibrary.&quot;+lib));
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to read from the specified file
     * descriptor.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;RuntimePermission(&quot;readFileDescriptor&quot;)&lt;/code&gt;
     * permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkRead&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      fd   the system-dependent file descriptor.
     * @exception  SecurityException  if the calling thread does not have
     *             permission to access the specified file descriptor.
     * @exception  NullPointerException if the file descriptor argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @see        java.io.FileDescriptor
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkRead(FileDescriptor fd) {
        if (fd == null) {
            throw new NullPointerException(&quot;file descriptor can't be null&quot;);
        }
        checkPermission(new RuntimePermission(&quot;readFileDescriptor&quot;));
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to read the file specified by the
     * string argument.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;FilePermission(file,&quot;read&quot;)&lt;/code&gt; permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkRead&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      file   the system-dependent file name.
     * @exception  SecurityException if the calling thread does not have
     *             permission to access the specified file.
     * @exception  NullPointerException if the &lt;code&gt;file&lt;/code&gt; argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkRead(String file) {
        checkPermission(new FilePermission(file,
            SecurityConstants.FILE_READ_ACTION));
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * specified security context is not allowed to read the file
     * specified by the string argument. The context must be a security
     * context returned by a previous call to
     * &lt;code&gt;getSecurityContext&lt;/code&gt;.
     * &lt;p&gt; If &lt;code&gt;context&lt;/code&gt; is an instance of
     * &lt;code&gt;AccessControlContext&lt;/code&gt; then the
     * &lt;code&gt;AccessControlContext.checkPermission&lt;/code&gt; method will
     * be invoked with the &lt;code&gt;FilePermission(file,&quot;read&quot;)&lt;/code&gt; permission.
     * &lt;p&gt; If &lt;code&gt;context&lt;/code&gt; is not an instance of
     * &lt;code&gt;AccessControlContext&lt;/code&gt; then a
     * &lt;code&gt;SecurityException&lt;/code&gt; is thrown.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkRead&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      file      the system-dependent filename.
     * @param      context   a system-dependent security context.
     * @exception  SecurityException  if the specified security context
     *             is not an instance of &lt;code&gt;AccessControlContext&lt;/code&gt;
     *             (e.g., is &lt;code&gt;null&lt;/code&gt;), or does not have permission
     *             to read the specified file.
     * @exception  NullPointerException if the &lt;code&gt;file&lt;/code&gt; argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @see        java.lang.SecurityManager#getSecurityContext()
     * @see        java.security.AccessControlContext#checkPermission(java.security.Permission)
     */
    public void checkRead(String file, Object context) {
        checkPermission(
            new FilePermission(file, SecurityConstants.FILE_READ_ACTION),
            context);
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to write to the specified file
     * descriptor.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;RuntimePermission(&quot;writeFileDescriptor&quot;)&lt;/code&gt;
     * permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkWrite&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      fd   the system-dependent file descriptor.
     * @exception SecurityException  if the calling thread does not have
     *             permission to access the specified file descriptor.
     * @exception  NullPointerException if the file descriptor argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @see        java.io.FileDescriptor
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkWrite(FileDescriptor fd) {
        if (fd == null) {
            throw new NullPointerException(&quot;file descriptor can't be null&quot;);
        }
        checkPermission(new RuntimePermission(&quot;writeFileDescriptor&quot;));

    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to write to the file specified by
     * the string argument.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;FilePermission(file,&quot;write&quot;)&lt;/code&gt; permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkWrite&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      file   the system-dependent filename.
     * @exception  SecurityException  if the calling thread does not
     *             have permission to access the specified file.
     * @exception  NullPointerException if the &lt;code&gt;file&lt;/code&gt; argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkWrite(String file) {
        checkPermission(new FilePermission(file,
            SecurityConstants.FILE_WRITE_ACTION));
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to delete the specified file.
     * &lt;p&gt;
     * This method is invoked for the current security manager by the
     * &lt;code&gt;delete&lt;/code&gt; method of class &lt;code&gt;File&lt;/code&gt;.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;FilePermission(file,&quot;delete&quot;)&lt;/code&gt; permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkDelete&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      file   the system-dependent filename.
     * @exception  SecurityException if the calling thread does not
     *             have permission to delete the file.
     * @exception  NullPointerException if the &lt;code&gt;file&lt;/code&gt; argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @see        java.io.File#delete()
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkDelete(String file) {
        checkPermission(new FilePermission(file,
            SecurityConstants.FILE_DELETE_ACTION));
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to open a socket connection to the
     * specified host and port number.
     * &lt;p&gt;
     * A port number of &lt;code&gt;-1&lt;/code&gt; indicates that the calling
     * method is attempting to determine the IP address of the specified
     * host name.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;SocketPermission(host+&quot;:&quot;+port,&quot;connect&quot;)&lt;/code&gt; permission if
     * the port is not equal to -1. If the port is equal to -1, then
     * it calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;SocketPermission(host,&quot;resolve&quot;)&lt;/code&gt; permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkConnect&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      host   the host name port to connect to.
     * @param      port   the protocol port to connect to.
     * @exception  SecurityException  if the calling thread does not have
     *             permission to open a socket connection to the specified
     *               &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;.
     * @exception  NullPointerException if the &lt;code&gt;host&lt;/code&gt; argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkConnect(String host, int port) {
        if (host == null) {
            throw new NullPointerException(&quot;host can't be null&quot;);
        }
        if (!host.startsWith(&quot;[&quot;) &amp;&amp; host.indexOf(':') != -1) {
            host = &quot;[&quot; + host + &quot;]&quot;;
        }
        if (port == -1) {
            checkPermission(new SocketPermission(host,
                SecurityConstants.SOCKET_RESOLVE_ACTION));
        } else {
            checkPermission(new SocketPermission(host+&quot;:&quot;+port,
                SecurityConstants.SOCKET_CONNECT_ACTION));
        }
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * specified security context is not allowed to open a socket
     * connection to the specified host and port number.
     * &lt;p&gt;
     * A port number of &lt;code&gt;-1&lt;/code&gt; indicates that the calling
     * method is attempting to determine the IP address of the specified
     * host name.
     * &lt;p&gt; If &lt;code&gt;context&lt;/code&gt; is not an instance of
     * &lt;code&gt;AccessControlContext&lt;/code&gt; then a
     * &lt;code&gt;SecurityException&lt;/code&gt; is thrown.
     * &lt;p&gt;
     * Otherwise, the port number is checked. If it is not equal
     * to -1, the &lt;code&gt;context&lt;/code&gt;'s &lt;code&gt;checkPermission&lt;/code&gt;
     * method is called with a
     * &lt;code&gt;SocketPermission(host+&quot;:&quot;+port,&quot;connect&quot;)&lt;/code&gt; permission.
     * If the port is equal to -1, then
     * the &lt;code&gt;context&lt;/code&gt;'s &lt;code&gt;checkPermission&lt;/code&gt; method
     * is called with a
     * &lt;code&gt;SocketPermission(host,&quot;resolve&quot;)&lt;/code&gt; permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkConnect&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      host      the host name port to connect to.
     * @param      port      the protocol port to connect to.
     * @param      context   a system-dependent security context.
     * @exception  SecurityException if the specified security context
     *             is not an instance of &lt;code&gt;AccessControlContext&lt;/code&gt;
     *             (e.g., is &lt;code&gt;null&lt;/code&gt;), or does not have permission
     *             to open a socket connection to the specified
     *             &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;.
     * @exception  NullPointerException if the &lt;code&gt;host&lt;/code&gt; argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @see        java.lang.SecurityManager#getSecurityContext()
     * @see        java.security.AccessControlContext#checkPermission(java.security.Permission)
     */
    public void checkConnect(String host, int port, Object context) {
        if (host == null) {
            throw new NullPointerException(&quot;host can't be null&quot;);
        }
        if (!host.startsWith(&quot;[&quot;) &amp;&amp; host.indexOf(':') != -1) {
            host = &quot;[&quot; + host + &quot;]&quot;;
        }
        if (port == -1)
            checkPermission(new SocketPermission(host,
                SecurityConstants.SOCKET_RESOLVE_ACTION),
                context);
        else
            checkPermission(new SocketPermission(host+&quot;:&quot;+port,
                SecurityConstants.SOCKET_CONNECT_ACTION),
                context);
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to wait for a connection request on
     * the specified local port number.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;SocketPermission(&quot;localhost:&quot;+port,&quot;listen&quot;)&lt;/code&gt;.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkListen&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      port   the local port.
     * @exception  SecurityException  if the calling thread does not have
     *             permission to listen on the specified port.
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkListen(int port) {
        checkPermission(new SocketPermission(&quot;localhost:&quot;+port,
            SecurityConstants.SOCKET_LISTEN_ACTION));
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not permitted to accept a socket connection from
     * the specified host and port number.
     * &lt;p&gt;
     * This method is invoked for the current security manager by the
     * &lt;code&gt;accept&lt;/code&gt; method of class &lt;code&gt;ServerSocket&lt;/code&gt;.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;SocketPermission(host+&quot;:&quot;+port,&quot;accept&quot;)&lt;/code&gt; permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkAccept&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      host   the host name of the socket connection.
     * @param      port   the port number of the socket connection.
     * @exception  SecurityException  if the calling thread does not have
     *             permission to accept the connection.
     * @exception  NullPointerException if the &lt;code&gt;host&lt;/code&gt; argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @see        java.net.ServerSocket#accept()
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkAccept(String host, int port) {
        if (host == null) {
            throw new NullPointerException(&quot;host can't be null&quot;);
        }
        if (!host.startsWith(&quot;[&quot;) &amp;&amp; host.indexOf(':') != -1) {
            host = &quot;[&quot; + host + &quot;]&quot;;
        }
        checkPermission(new SocketPermission(host+&quot;:&quot;+port,
            SecurityConstants.SOCKET_ACCEPT_ACTION));
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to use
     * (join/leave/send/receive) IP multicast.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;java.net.SocketPermission(maddr.getHostAddress(),
     * &quot;accept,connect&quot;)&lt;/code&gt; permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkMulticast&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      maddr  Internet group address to be used.
     * @exception  SecurityException  if the calling thread is not allowed to
     *  use (join/leave/send/receive) IP multicast.
     * @exception  NullPointerException if the address argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @since      JDK1.1
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkMulticast(InetAddress maddr) {
        String host = maddr.getHostAddress();
        if (!host.startsWith(&quot;[&quot;) &amp;&amp; host.indexOf(':') != -1) {
            host = &quot;[&quot; + host + &quot;]&quot;;
        }
        checkPermission(new SocketPermission(host,
            SecurityConstants.SOCKET_CONNECT_ACCEPT_ACTION));
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to use
     * (join/leave/send/receive) IP multicast.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;java.net.SocketPermission(maddr.getHostAddress(),
     * &quot;accept,connect&quot;)&lt;/code&gt; permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkMulticast&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      maddr  Internet group address to be used.
     * @param      ttl        value in use, if it is multicast send.
     * Note: this particular implementation does not use the ttl
     * parameter.
     * @exception  SecurityException  if the calling thread is not allowed to
     *  use (join/leave/send/receive) IP multicast.
     * @exception  NullPointerException if the address argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @since      JDK1.1
     * @deprecated Use #checkPermission(java.security.Permission) instead
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    @Deprecated
    public void checkMulticast(InetAddress maddr, byte ttl) {
        String host = maddr.getHostAddress();
        if (!host.startsWith(&quot;[&quot;) &amp;&amp; host.indexOf(':') != -1) {
            host = &quot;[&quot; + host + &quot;]&quot;;
        }
        checkPermission(new SocketPermission(host,
            SecurityConstants.SOCKET_CONNECT_ACCEPT_ACTION));
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to access or modify the system
     * properties.
     * &lt;p&gt;
     * This method is used by the &lt;code&gt;getProperties&lt;/code&gt; and
     * &lt;code&gt;setProperties&lt;/code&gt; methods of class &lt;code&gt;System&lt;/code&gt;.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;PropertyPermission(&quot;*&quot;, &quot;read,write&quot;)&lt;/code&gt; permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkPropertiesAccess&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     * &lt;p&gt;
     *
     * @exception  SecurityException  if the calling thread does not have
     *             permission to access or modify the system properties.
     * @see        java.lang.System#getProperties()
     * @see        java.lang.System#setProperties(java.util.Properties)
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkPropertiesAccess() {
        checkPermission(new PropertyPermission(&quot;*&quot;,
            SecurityConstants.PROPERTY_RW_ACTION));
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to access the system property with
     * the specified &lt;code&gt;key&lt;/code&gt; name.
     * &lt;p&gt;
     * This method is used by the &lt;code&gt;getProperty&lt;/code&gt; method of
     * class &lt;code&gt;System&lt;/code&gt;.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;PropertyPermission(key, &quot;read&quot;)&lt;/code&gt; permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkPropertyAccess&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param      key   a system property key.
     *
     * @exception  SecurityException  if the calling thread does not have
     *             permission to access the specified system property.
     * @exception  NullPointerException if the &lt;code&gt;key&lt;/code&gt; argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;/code&gt; is empty.
     *
     * @see        java.lang.System#getProperty(java.lang.String)
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkPropertyAccess(String key) {
        checkPermission(new PropertyPermission(key,
            SecurityConstants.PROPERTY_READ_ACTION));
    }

    /**
     * Returns &lt;code&gt;false&lt;/code&gt; if the calling
     * thread is not trusted to bring up the top-level window indicated
     * by the &lt;code&gt;window&lt;/code&gt; argument. In this case, the caller can
     * still decide to show the window, but the window should include
     * some sort of visual warning. If the method returns
     * &lt;code&gt;true&lt;/code&gt;, then the window can be shown without any
     * special restrictions.
     * &lt;p&gt;
     * See class &lt;code&gt;Window&lt;/code&gt; for more information on trusted and
     * untrusted windows.
     * &lt;p&gt;
     * This method calls
     * &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)&lt;/code&gt; permission,
     * and returns &lt;code&gt;true&lt;/code&gt; if a SecurityException is not thrown,
     * otherwise it returns &lt;code&gt;false&lt;/code&gt;.
     * In the case of subset Profiles of Java SE that do not include the
     * {@code java.awt} package, {@code checkPermission} is instead called
     * to check the permission {@code java.security.AllPermission}.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkTopLevelWindow&lt;/code&gt;
     * at the point the overridden method would normally return
     * &lt;code&gt;false&lt;/code&gt;, and the value of
     * &lt;code&gt;super.checkTopLevelWindow&lt;/code&gt; should
     * be returned.
     *
     * @param      window   the new window that is being created.
     * @return     &lt;code&gt;true&lt;/code&gt; if the calling thread is trusted to put up
     *             top-level windows; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @exception  NullPointerException if the &lt;code&gt;window&lt;/code&gt; argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @deprecated The dependency on {@code AWTPermission} creates an
     *             impediment to future modularization of the Java platform.
     *             Users of this method should instead invoke
     *             {@link #checkPermission} directly.
     *             This method will be changed in a future release to check
     *             the permission {@code java.security.AllPermission}.
     * @see        java.awt.Window
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    @Deprecated
    public boolean checkTopLevelWindow(Object window) {
        if (window == null) {
            throw new NullPointerException(&quot;window can't be null&quot;);
        }
        Permission perm = SecurityConstants.AWT.TOPLEVEL_WINDOW_PERMISSION;
        if (perm == null) {
            perm = SecurityConstants.ALL_PERMISSION;
        }
        try {
            checkPermission(perm);
            return true;
        } catch (SecurityException se) {
            // just return false
        }
        return false;
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to initiate a print job request.
     * &lt;p&gt;
     * This method calls
     * &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;RuntimePermission(&quot;queuePrintJob&quot;)&lt;/code&gt; permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkPrintJobAccess&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     * &lt;p&gt;
     *
     * @exception  SecurityException  if the calling thread does not have
     *             permission to initiate a print job request.
     * @since   JDK1.1
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkPrintJobAccess() {
        checkPermission(new RuntimePermission(&quot;queuePrintJob&quot;));
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to access the system clipboard.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;AWTPermission(&quot;accessClipboard&quot;)&lt;/code&gt;
     * permission.
     * In the case of subset Profiles of Java SE that do not include the
     * {@code java.awt} package, {@code checkPermission} is instead called
     * to check the permission {@code java.security.AllPermission}.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkSystemClipboardAccess&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @since   JDK1.1
     * @exception  SecurityException  if the calling thread does not have
     *             permission to access the system clipboard.
     * @deprecated The dependency on {@code AWTPermission} creates an
     *             impediment to future modularization of the Java platform.
     *             Users of this method should instead invoke
     *             {@link #checkPermission} directly.
     *             This method will be changed in a future release to check
     *             the permission {@code java.security.AllPermission}.
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    @Deprecated
    public void checkSystemClipboardAccess() {
        Permission perm = SecurityConstants.AWT.ACCESS_CLIPBOARD_PERMISSION;
        if (perm == null) {
            perm = SecurityConstants.ALL_PERMISSION;
        }
        checkPermission(perm);
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to access the AWT event queue.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;AWTPermission(&quot;accessEventQueue&quot;)&lt;/code&gt; permission.
     * In the case of subset Profiles of Java SE that do not include the
     * {@code java.awt} package, {@code checkPermission} is instead called
     * to check the permission {@code java.security.AllPermission}.
     *
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkAwtEventQueueAccess&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @since   JDK1.1
     * @exception  SecurityException  if the calling thread does not have
     *             permission to access the AWT event queue.
     * @deprecated The dependency on {@code AWTPermission} creates an
     *             impediment to future modularization of the Java platform.
     *             Users of this method should instead invoke
     *             {@link #checkPermission} directly.
     *             This method will be changed in a future release to check
     *             the permission {@code java.security.AllPermission}.
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    @Deprecated
    public void checkAwtEventQueueAccess() {
        Permission perm = SecurityConstants.AWT.CHECK_AWT_EVENTQUEUE_PERMISSION;
        if (perm == null) {
            perm = SecurityConstants.ALL_PERMISSION;
        }
        checkPermission(perm);
    }

    /*
     * We have an initial invalid bit (initially false) for the class
     * variables which tell if the cache is valid.  If the underlying
     * java.security.Security property changes via setProperty(), the
     * Security class uses reflection to change the variable and thus
     * invalidate the cache.
     *
     * Locking is handled by synchronization to the
     * packageAccessLock/packageDefinitionLock objects.  They are only
     * used in this class.
     *
     * Note that cache invalidation as a result of the property change
     * happens without using these locks, so there may be a delay between
     * when a thread updates the property and when other threads updates
     * the cache.
     */
    private static boolean packageAccessValid = false;
    private static String[] packageAccess;
    private static final Object packageAccessLock = new Object();

    private static boolean packageDefinitionValid = false;
    private static String[] packageDefinition;
    private static final Object packageDefinitionLock = new Object();

    private static String[] getPackages(String p) {
        String packages[] = null;
        if (p != null &amp;&amp; !p.equals(&quot;&quot;)) {
            java.util.StringTokenizer tok =
                new java.util.StringTokenizer(p, &quot;,&quot;);
            int n = tok.countTokens();
            if (n &gt; 0) {
                packages = new String[n];
                int i = 0;
                while (tok.hasMoreElements()) {
                    String s = tok.nextToken().trim();
                    packages[i++] = s;
                }
            }
        }

        if (packages == null)
            packages = new String[0];
        return packages;
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to access the package specified by
     * the argument.
     * &lt;p&gt;
     * This method is used by the &lt;code&gt;loadClass&lt;/code&gt; method of class
     * loaders.
     * &lt;p&gt;
     * This method first gets a list of
     * restricted packages by obtaining a comma-separated list from
     * a call to
     * &lt;code&gt;java.security.Security.getProperty(&quot;package.access&quot;)&lt;/code&gt;,
     * and checks to see if &lt;code&gt;pkg&lt;/code&gt; starts with or equals
     * any of the restricted packages. If it does, then
     * &lt;code&gt;checkPermission&lt;/code&gt; gets called with the
     * &lt;code&gt;RuntimePermission(&quot;accessClassInPackage.&quot;+pkg)&lt;/code&gt;
     * permission.
     * &lt;p&gt;
     * If this method is overridden, then
     * &lt;code&gt;super.checkPackageAccess&lt;/code&gt; should be called
     * as the first line in the overridden method.
     *
     * @param      pkg   the package name.
     * @exception  SecurityException  if the calling thread does not have
     *             permission to access the specified package.
     * @exception  NullPointerException if the package name argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @see        java.lang.ClassLoader#loadClass(java.lang.String, boolean)
     *  loadClass
     * @see        java.security.Security#getProperty getProperty
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkPackageAccess(String pkg) {
        if (pkg == null) {
            throw new NullPointerException(&quot;package name can't be null&quot;);
        }

        String[] pkgs;
        synchronized (packageAccessLock) {
            /*
             * Do we need to update our property array?
             */
            if (!packageAccessValid) {
                String tmpPropertyStr =
                    AccessController.doPrivileged(
                        new PrivilegedAction&lt;String&gt;() {
                            public String run() {
                                return java.security.Security.getProperty(
                                    &quot;package.access&quot;);
                            }
                        }
                    );
                packageAccess = getPackages(tmpPropertyStr);
                packageAccessValid = true;
            }

            // Using a snapshot of packageAccess -- don't care if static field
            // changes afterwards; array contents won't change.
            pkgs = packageAccess;
        }

        /*
         * Traverse the list of packages, check for any matches.
         */
        for (int i = 0; i &lt; pkgs.length; i++) {
            if (pkg.startsWith(pkgs[i]) || pkgs[i].equals(pkg + &quot;.&quot;)) {
                checkPermission(
                    new RuntimePermission(&quot;accessClassInPackage.&quot;+pkg));
                break;  // No need to continue; only need to check this once
            }
        }
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to define classes in the package
     * specified by the argument.
     * &lt;p&gt;
     * This method is used by the &lt;code&gt;loadClass&lt;/code&gt; method of some
     * class loaders.
     * &lt;p&gt;
     * This method first gets a list of restricted packages by
     * obtaining a comma-separated list from a call to
     * &lt;code&gt;java.security.Security.getProperty(&quot;package.definition&quot;)&lt;/code&gt;,
     * and checks to see if &lt;code&gt;pkg&lt;/code&gt; starts with or equals
     * any of the restricted packages. If it does, then
     * &lt;code&gt;checkPermission&lt;/code&gt; gets called with the
     * &lt;code&gt;RuntimePermission(&quot;defineClassInPackage.&quot;+pkg)&lt;/code&gt;
     * permission.
     * &lt;p&gt;
     * If this method is overridden, then
     * &lt;code&gt;super.checkPackageDefinition&lt;/code&gt; should be called
     * as the first line in the overridden method.
     *
     * @param      pkg   the package name.
     * @exception  SecurityException  if the calling thread does not have
     *             permission to define classes in the specified package.
     * @see        java.lang.ClassLoader#loadClass(java.lang.String, boolean)
     * @see        java.security.Security#getProperty getProperty
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkPackageDefinition(String pkg) {
        if (pkg == null) {
            throw new NullPointerException(&quot;package name can't be null&quot;);
        }

        String[] pkgs;
        synchronized (packageDefinitionLock) {
            /*
             * Do we need to update our property array?
             */
            if (!packageDefinitionValid) {
                String tmpPropertyStr =
                    AccessController.doPrivileged(
                        new PrivilegedAction&lt;String&gt;() {
                            public String run() {
                                return java.security.Security.getProperty(
                                    &quot;package.definition&quot;);
                            }
                        }
                    );
                packageDefinition = getPackages(tmpPropertyStr);
                packageDefinitionValid = true;
            }
            // Using a snapshot of packageDefinition -- don't care if static
            // field changes afterwards; array contents won't change.
            pkgs = packageDefinition;
        }

        /*
         * Traverse the list of packages, check for any matches.
         */
        for (int i = 0; i &lt; pkgs.length; i++) {
            if (pkg.startsWith(pkgs[i]) || pkgs[i].equals(pkg + &quot;.&quot;)) {
                checkPermission(
                    new RuntimePermission(&quot;defineClassInPackage.&quot;+pkg));
                break; // No need to continue; only need to check this once
            }
        }
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to set the socket factory used by
     * &lt;code&gt;ServerSocket&lt;/code&gt; or &lt;code&gt;Socket&lt;/code&gt;, or the stream
     * handler factory used by &lt;code&gt;URL&lt;/code&gt;.
     * &lt;p&gt;
     * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the
     * &lt;code&gt;RuntimePermission(&quot;setFactory&quot;)&lt;/code&gt; permission.
     * &lt;p&gt;
     * If you override this method, then you should make a call to
     * &lt;code&gt;super.checkSetFactory&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     * &lt;p&gt;
     *
     * @exception  SecurityException  if the calling thread does not have
     *             permission to specify a socket factory or a stream
     *             handler factory.
     *
     * @see        java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory) setSocketFactory
     * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory) setSocketImplFactory
     * @see        java.net.URL#setURLStreamHandlerFactory(java.net.URLStreamHandlerFactory) setURLStreamHandlerFactory
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkSetFactory() {
        checkPermission(new RuntimePermission(&quot;setFactory&quot;));
    }

    /**
     * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the
     * calling thread is not allowed to access members.
     * &lt;p&gt;
     * The default policy is to allow access to PUBLIC members, as well
     * as access to classes that have the same class loader as the caller.
     * In all other cases, this method calls &lt;code&gt;checkPermission&lt;/code&gt;
     * with the &lt;code&gt;RuntimePermission(&quot;accessDeclaredMembers&quot;)
     * &lt;/code&gt; permission.
     * &lt;p&gt;
     * If this method is overridden, then a call to
     * &lt;code&gt;super.checkMemberAccess&lt;/code&gt; cannot be made,
     * as the default implementation of &lt;code&gt;checkMemberAccess&lt;/code&gt;
     * relies on the code being checked being at a stack depth of
     * 4.
     *
     * @param clazz the class that reflection is to be performed on.
     *
     * @param which type of access, PUBLIC or DECLARED.
     *
     * @exception  SecurityException if the caller does not have
     *             permission to access members.
     * @exception  NullPointerException if the &lt;code&gt;clazz&lt;/code&gt; argument is
     *             &lt;code&gt;null&lt;/code&gt;.
     *
     * @deprecated This method relies on the caller being at a stack depth
     *             of 4 which is error-prone and cannot be enforced by the runtime.
     *             Users of this method should instead invoke {@link #checkPermission}
     *             directly.  This method will be changed in a future release
     *             to check the permission {@code java.security.AllPermission}.
     *
     * @see java.lang.reflect.Member
     * @since JDK1.1
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    @Deprecated
    @CallerSensitive
    public void checkMemberAccess(Class&lt;?&gt; clazz, int which) {
        if (clazz == null) {
            throw new NullPointerException(&quot;class can't be null&quot;);
        }
        if (which != Member.PUBLIC) {
            Class&lt;?&gt; stack[] = getClassContext();
            /*
             * stack depth of 4 should be the caller of one of the
             * methods in java.lang.Class that invoke checkMember
             * access. The stack should look like:
             *
             * someCaller                        [3]
             * java.lang.Class.someReflectionAPI [2]
             * java.lang.Class.checkMemberAccess [1]
             * SecurityManager.checkMemberAccess [0]
             *
             */
            if ((stack.length&lt;4) ||
                (stack[3].getClassLoader() != clazz.getClassLoader())) {
                checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
            }
        }
    }

    /**
     * Determines whether the permission with the specified permission target
     * name should be granted or denied.
     *
     * &lt;p&gt; If the requested permission is allowed, this method returns
     * quietly. If denied, a SecurityException is raised.
     *
     * &lt;p&gt; This method creates a &lt;code&gt;SecurityPermission&lt;/code&gt; object for
     * the given permission target name and calls &lt;code&gt;checkPermission&lt;/code&gt;
     * with it.
     *
     * &lt;p&gt; See the documentation for
     * &lt;code&gt;{@link java.security.SecurityPermission}&lt;/code&gt; for
     * a list of possible permission target names.
     *
     * &lt;p&gt; If you override this method, then you should make a call to
     * &lt;code&gt;super.checkSecurityAccess&lt;/code&gt;
     * at the point the overridden method would normally throw an
     * exception.
     *
     * @param target the target name of the &lt;code&gt;SecurityPermission&lt;/code&gt;.
     *
     * @exception SecurityException if the calling thread does not have
     * permission for the requested access.
     * @exception NullPointerException if &lt;code&gt;target&lt;/code&gt; is null.
     * @exception IllegalArgumentException if &lt;code&gt;target&lt;/code&gt; is empty.
     *
     * @since   JDK1.1
     * @see        #checkPermission(java.security.Permission) checkPermission
     */
    public void checkSecurityAccess(String target) {
        checkPermission(new SecurityPermission(target));
    }

    private native Class&lt;?&gt; currentLoadedClass0();

    /**
     * Returns the thread group into which to instantiate any new
     * thread being created at the time this is being called.
     * By default, it returns the thread group of the current
     * thread. This should be overridden by a specific security
     * manager to return the appropriate thread group.
     *
     * @return  ThreadGroup that new threads are instantiated into
     * @since   JDK1.1
     * @see     java.lang.ThreadGroup
     */
    public ThreadGroup getThreadGroup() {
        return Thread.currentThread().getThreadGroup();
    }

}
</pre>
</body>
</html>
