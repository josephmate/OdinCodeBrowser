<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.management;

import javax.management.openmbean.CompositeData;

/**
 * The management interface for the memory system of
 * the Java virtual machine.
 *
 * &lt;p&gt; A Java virtual machine has a single instance of the implementation
 * class of this interface.  This instance implementing this interface is
 * an &lt;a href=&quot;ManagementFactory.html#MXBean&quot;&gt;MXBean&lt;/a&gt;
 * that can be obtained by calling
 * the {@link ManagementFactory#getMemoryMXBean} method or
 * from the {@link ManagementFactory#getPlatformMBeanServer
 * platform &lt;tt&gt;MBeanServer&lt;/tt&gt;} method.
 *
 * &lt;p&gt;The &lt;tt&gt;ObjectName&lt;/tt&gt; for uniquely identifying the MXBean for
 * the memory system within an MBeanServer is:
 * &lt;blockquote&gt;
 *    {@link ManagementFactory#MEMORY_MXBEAN_NAME
 *           &lt;tt&gt;java.lang:type=Memory&lt;/tt&gt;}
 * &lt;/blockquote&gt;
 *
 * It can be obtained by calling the
 * {@link PlatformManagedObject#getObjectName} method.
 *
 * &lt;h3&gt; Memory &lt;/h3&gt;
 * The memory system of the Java virtual machine manages
 * the following kinds of memory:
 *
 * &lt;h3&gt; 1. Heap &lt;/h3&gt;
 * The Java virtual machine has a &lt;i&gt;heap&lt;/i&gt; that is the runtime
 * data area from which memory for all class instances and arrays
 * are allocated.  It is created at the Java virtual machine start-up.
 * Heap memory for objects is reclaimed by an automatic memory management
 * system which is known as a &lt;i&gt;garbage collector&lt;/i&gt;.
 *
 * &lt;p&gt;The heap may be of a fixed size or may be expanded and shrunk.
 * The memory for the heap does not need to be contiguous.
 *
 * &lt;h3&gt; 2. Non-Heap Memory&lt;/h3&gt;
 * The Java virtual machine manages memory other than the heap
 * (referred as &lt;i&gt;non-heap memory&lt;/i&gt;).
 *
 * &lt;p&gt; The Java virtual machine has a &lt;i&gt;method area&lt;/i&gt; that is shared
 * among all threads.
 * The method area belongs to non-heap memory.  It stores per-class structures
 * such as a runtime constant pool, field and method data, and the code for
 * methods and constructors.  It is created at the Java virtual machine
 * start-up.
 *
 * &lt;p&gt; The method area is logically part of the heap but a Java virtual
 * machine implementation may choose not to either garbage collect
 * or compact it.  Similar to the heap, the method area may be of a
 * fixed size or may be expanded and shrunk.  The memory for the
 * method area does not need to be contiguous.
 *
 * &lt;p&gt;In addition to the method area, a Java virtual machine
 * implementation may require memory for internal processing or
 * optimization which also belongs to non-heap memory.
 * For example, the JIT compiler requires memory for storing the native
 * machine code translated from the Java virtual machine code for
 * high performance.
 *
 * &lt;h3&gt;Memory Pools and Memory Managers&lt;/h3&gt;
 * {@link MemoryPoolMXBean Memory pools} and
 * {@link MemoryManagerMXBean memory managers} are the abstract entities
 * that monitor and manage the memory system
 * of the Java virtual machine.
 *
 * &lt;p&gt;A memory pool represents a memory area that the Java virtual machine
 * manages.  The Java virtual machine has at least one memory pool
 * and it may create or remove memory pools during execution.
 * A memory pool can belong to either the heap or the non-heap memory.
 *
 * &lt;p&gt;A memory manager is responsible for managing one or more memory pools.
 * The garbage collector is one type of memory manager responsible
 * for reclaiming memory occupied by unreachable objects.  A Java virtual
 * machine may have one or more memory managers.   It may
 * add or remove memory managers during execution.
 * A memory pool can be managed by more than one memory manager.
 *
 * &lt;h3&gt;Memory Usage Monitoring&lt;/h3&gt;
 *
 * Memory usage is a very important monitoring attribute for the memory system.
 * The memory usage, for example, could indicate:
 * &lt;ul&gt;
 *   &lt;li&gt;the memory usage of an application,&lt;/li&gt;
 *   &lt;li&gt;the workload being imposed on the automatic memory management system,&lt;/li&gt;
 *   &lt;li&gt;potential memory leakage.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * The memory usage can be monitored in three ways:
 * &lt;ul&gt;
 *   &lt;li&gt;Polling&lt;/li&gt;
 *   &lt;li&gt;Usage Threshold Notification&lt;/li&gt;
 *   &lt;li&gt;Collection Usage Threshold Notification&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Details are specified in the {@link MemoryPoolMXBean} interface.
 *
 * &lt;p&gt;The memory usage monitoring mechanism is intended for load-balancing
 * or workload distribution use.  For example, an application would stop
 * receiving any new workload when its memory usage exceeds a
 * certain threshold. It is not intended for an application to detect
 * and recover from a low memory condition.
 *
 * &lt;h3&gt;Notifications&lt;/h3&gt;
 *
 * &lt;p&gt;This &lt;tt&gt;MemoryMXBean&lt;/tt&gt; is a
 * {@link javax.management.NotificationEmitter NotificationEmitter}
 * that emits two types of memory {@link javax.management.Notification
 * notifications} if any one of the memory pools
 * supports a &lt;a href=&quot;MemoryPoolMXBean.html#UsageThreshold&quot;&gt;usage threshold&lt;/a&gt;
 * or a &lt;a href=&quot;MemoryPoolMXBean.html#CollectionThreshold&quot;&gt;collection usage
 * threshold&lt;/a&gt; which can be determined by calling the
 * {@link MemoryPoolMXBean#isUsageThresholdSupported} and
 * {@link MemoryPoolMXBean#isCollectionUsageThresholdSupported} methods.
 * &lt;ul&gt;
 *   &lt;li&gt;{@link MemoryNotificationInfo#MEMORY_THRESHOLD_EXCEEDED
 *       usage threshold exceeded notification} - for notifying that
 *       the memory usage of a memory pool is increased and has reached
 *       or exceeded its
 *       &lt;a href=&quot;MemoryPoolMXBean.html#UsageThreshold&quot;&gt; usage threshold&lt;/a&gt; value.
 *       &lt;/li&gt;
 *   &lt;li&gt;{@link MemoryNotificationInfo#MEMORY_COLLECTION_THRESHOLD_EXCEEDED
 *       collection usage threshold exceeded notification} - for notifying that
 *       the memory usage of a memory pool is greater than or equal to its
 *       &lt;a href=&quot;MemoryPoolMXBean.html#CollectionThreshold&quot;&gt;
 *       collection usage threshold&lt;/a&gt; after the Java virtual machine
 *       has expended effort in recycling unused objects in that
 *       memory pool.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * The notification emitted is a {@link javax.management.Notification}
 * instance whose {@link javax.management.Notification#setUserData
 * user data} is set to a {@link CompositeData CompositeData}
 * that represents a {@link MemoryNotificationInfo} object
 * containing information about the memory pool when the notification
 * was constructed. The &lt;tt&gt;CompositeData&lt;/tt&gt; contains the attributes
 * as described in {@link MemoryNotificationInfo#from
 * MemoryNotificationInfo}.
 *
 * &lt;hr&gt;
 * &lt;h3&gt;NotificationEmitter&lt;/h3&gt;
 * The &lt;tt&gt;MemoryMXBean&lt;/tt&gt; object returned by
 * {@link ManagementFactory#getMemoryMXBean} implements
 * the {@link javax.management.NotificationEmitter NotificationEmitter}
 * interface that allows a listener to be registered within the
 * &lt;tt&gt;MemoryMXBean&lt;/tt&gt; as a notification listener.
 *
 * Below is an example code that registers a &lt;tt&gt;MyListener&lt;/tt&gt; to handle
 * notification emitted by the &lt;tt&gt;MemoryMXBean&lt;/tt&gt;.
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * class MyListener implements javax.management.NotificationListener {
 *     public void handleNotification(Notification notif, Object handback) {
 *         // handle notification
 *         ....
 *     }
 * }
 *
 * MemoryMXBean mbean = ManagementFactory.getMemoryMXBean();
 * NotificationEmitter emitter = (NotificationEmitter) mbean;
 * MyListener listener = new MyListener();
 * emitter.addNotificationListener(listener, null, null);
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * @see ManagementFactory#getPlatformMXBeans(Class)
 * @see &lt;a href=&quot;../../../javax/management/package-summary.html&quot;&gt;
 *      JMX Specification.&lt;/a&gt;
 * @see &lt;a href=&quot;package-summary.html#examples&quot;&gt;
 *      Ways to Access MXBeans&lt;/a&gt;
 *
 * @author  Mandy Chung
 * @since   1.5
 */
public interface MemoryMXBean extends PlatformManagedObject {
    /**
     * Returns the approximate number of objects for which
     * finalization is pending.
     *
     * @return the approximate number objects for which finalization
     * is pending.
     */
    public int getObjectPendingFinalizationCount();

    /**
     * Returns the current memory usage of the heap that
     * is used for object allocation.  The heap consists
     * of one or more memory pools.  The &lt;tt&gt;used&lt;/tt&gt;
     * and &lt;tt&gt;committed&lt;/tt&gt; size of the returned memory
     * usage is the sum of those values of all heap memory pools
     * whereas the &lt;tt&gt;init&lt;/tt&gt; and &lt;tt&gt;max&lt;/tt&gt; size of the
     * returned memory usage represents the setting of the heap
     * memory which may not be the sum of those of all heap
     * memory pools.
     * &lt;p&gt;
     * The amount of used memory in the returned memory usage
     * is the amount of memory occupied by both live objects
     * and garbage objects that have not been collected, if any.
     *
     * &lt;p&gt;
     * &lt;b&gt;MBeanServer access&lt;/b&gt;:&lt;br&gt;
     * The mapped type of &lt;tt&gt;MemoryUsage&lt;/tt&gt; is
     * &lt;tt&gt;CompositeData&lt;/tt&gt; with attributes as specified in
     * {@link MemoryUsage#from MemoryUsage}.
     *
     * @return a {@link MemoryUsage} object representing
     * the heap memory usage.
     */
    public MemoryUsage getHeapMemoryUsage();

    /**
     * Returns the current memory usage of non-heap memory that
     * is used by the Java virtual machine.
     * The non-heap memory consists of one or more memory pools.
     * The &lt;tt&gt;used&lt;/tt&gt; and &lt;tt&gt;committed&lt;/tt&gt; size of the
     * returned memory usage is the sum of those values of
     * all non-heap memory pools whereas the &lt;tt&gt;init&lt;/tt&gt;
     * and &lt;tt&gt;max&lt;/tt&gt; size of the returned memory usage
     * represents the setting of the non-heap
     * memory which may not be the sum of those of all non-heap
     * memory pools.
     *
     * &lt;p&gt;
     * &lt;b&gt;MBeanServer access&lt;/b&gt;:&lt;br&gt;
     * The mapped type of &lt;tt&gt;MemoryUsage&lt;/tt&gt; is
     * &lt;tt&gt;CompositeData&lt;/tt&gt; with attributes as specified in
     * {@link MemoryUsage#from MemoryUsage}.
     *
     * @return a {@link MemoryUsage} object representing
     * the non-heap memory usage.
     */
    public MemoryUsage getNonHeapMemoryUsage();

    /**
     * Tests if verbose output for the memory system is enabled.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if verbose output for the memory
     * system is enabled; &lt;tt&gt;false&lt;/tt&gt; otherwise.
     */
    public boolean isVerbose();

    /**
     * Enables or disables verbose output for the memory
     * system.  The verbose output information and the output stream
     * to which the verbose information is emitted are implementation
     * dependent.  Typically, a Java virtual machine implementation
     * prints a message whenever it frees memory at garbage collection.
     *
     * &lt;p&gt;
     * Each invocation of this method enables or disables verbose
     * output globally.
     *
     * @param value &lt;tt&gt;true&lt;/tt&gt; to enable verbose output;
     *              &lt;tt&gt;false&lt;/tt&gt; to disable.
     *
     * @exception  java.lang.SecurityException if a security manager
     *             exists and the caller does not have
     *             ManagementPermission(&quot;control&quot;).
     */
    public void setVerbose(boolean value);

    /**
     * Runs the garbage collector.
     * The call &lt;code&gt;gc()&lt;/code&gt; is effectively equivalent to the
     * call:
     * &lt;blockquote&gt;&lt;pre&gt;
     * System.gc()
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @see     java.lang.System#gc()
     */
    public void gc();

}
</pre>
</body>
</html>
