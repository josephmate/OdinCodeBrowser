<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.management;

import java.util.Map;

/**
 * The management interface for the thread system of
 * the Java virtual machine.
 *
 * &lt;p&gt; A Java virtual machine has a single instance of the implementation
 * class of this interface.  This instance implementing this interface is
 * an &lt;a href=&quot;ManagementFactory.html#MXBean&quot;&gt;MXBean&lt;/a&gt;
 * that can be obtained by calling
 * the {@link ManagementFactory#getThreadMXBean} method or
 * from the {@link ManagementFactory#getPlatformMBeanServer
 * platform &lt;tt&gt;MBeanServer&lt;/tt&gt;} method.
 *
 * &lt;p&gt;The &lt;tt&gt;ObjectName&lt;/tt&gt; for uniquely identifying the MXBean for
 * the thread system within an MBeanServer is:
 * &lt;blockquote&gt;
 *    {@link ManagementFactory#THREAD_MXBEAN_NAME
 *           &lt;tt&gt;java.lang:type=Threading&lt;/tt&gt;}
 * &lt;/blockquote&gt;
 *
 * It can be obtained by calling the
 * {@link PlatformManagedObject#getObjectName} method.
 *
 * &lt;h3&gt;Thread ID&lt;/h3&gt;
 * Thread ID is a positive long value returned by calling the
 * {@link java.lang.Thread#getId} method for a thread.
 * The thread ID is unique during its lifetime.  When a thread
 * is terminated, this thread ID may be reused.
 *
 * &lt;p&gt; Some methods in this interface take a thread ID or an array
 * of thread IDs as the input parameter and return per-thread information.
 *
 * &lt;h3&gt;Thread CPU time&lt;/h3&gt;
 * A Java virtual machine implementation may support measuring
 * the CPU time for the current thread, for any thread, or for no threads.
 *
 * &lt;p&gt;
 * The {@link #isThreadCpuTimeSupported} method can be used to determine
 * if a Java virtual machine supports measuring of the CPU time for any
 * thread.  The {@link #isCurrentThreadCpuTimeSupported} method can
 * be used to determine if a Java virtual machine supports measuring of
 * the CPU time for the current  thread.
 * A Java virtual machine implementation that supports CPU time measurement
 * for any thread will also support that for the current thread.
 *
 * &lt;p&gt; The CPU time provided by this interface has nanosecond precision
 * but not necessarily nanosecond accuracy.
 *
 * &lt;p&gt;
 * A Java virtual machine may disable CPU time measurement
 * by default.
 * The {@link #isThreadCpuTimeEnabled} and {@link #setThreadCpuTimeEnabled}
 * methods can be used to test if CPU time measurement is enabled
 * and to enable/disable this support respectively.
 * Enabling thread CPU measurement could be expensive in some
 * Java virtual machine implementations.
 *
 * &lt;h3&gt;Thread Contention Monitoring&lt;/h3&gt;
 * Some Java virtual machines may support thread contention monitoring.
 * When thread contention monitoring is enabled, the accumulated elapsed
 * time that the thread has blocked for synchronization or waited for
 * notification will be collected and returned in the
 * &lt;a href=&quot;ThreadInfo.html#SyncStats&quot;&gt;&lt;tt&gt;ThreadInfo&lt;/tt&gt;&lt;/a&gt; object.
 * &lt;p&gt;
 * The {@link #isThreadContentionMonitoringSupported} method can be used to
 * determine if a Java virtual machine supports thread contention monitoring.
 * The thread contention monitoring is disabled by default.  The
 * {@link #setThreadContentionMonitoringEnabled} method can be used to enable
 * thread contention monitoring.
 *
 * &lt;h3&gt;Synchronization Information and Deadlock Detection&lt;/h3&gt;
 * Some Java virtual machines may support monitoring of
 * {@linkplain #isObjectMonitorUsageSupported object monitor usage} and
 * {@linkplain #isSynchronizerUsageSupported ownable synchronizer usage}.
 * The {@link #getThreadInfo(long[], boolean, boolean)} and
 * {@link #dumpAllThreads} methods can be used to obtain the thread stack trace
 * and synchronization information including which
 * {@linkplain LockInfo &lt;i&gt;lock&lt;/i&gt;} a thread is blocked to
 * acquire or waiting on and which locks the thread currently owns.
 * &lt;p&gt;
 * The &lt;tt&gt;ThreadMXBean&lt;/tt&gt; interface provides the
 * {@link #findMonitorDeadlockedThreads} and
 * {@link #findDeadlockedThreads} methods to find deadlocks in
 * the running application.
 *
 * @see ManagementFactory#getPlatformMXBeans(Class)
 * @see &lt;a href=&quot;../../../javax/management/package-summary.html&quot;&gt;
 *      JMX Specification.&lt;/a&gt;
 * @see &lt;a href=&quot;package-summary.html#examples&quot;&gt;
 *      Ways to Access MXBeans&lt;/a&gt;
 *
 * @author  Mandy Chung
 * @since   1.5
 */

public interface ThreadMXBean extends PlatformManagedObject {
    /**
     * Returns the current number of live threads including both
     * daemon and non-daemon threads.
     *
     * @return the current number of live threads.
     */
    public int getThreadCount();

    /**
     * Returns the peak live thread count since the Java virtual machine
     * started or peak was reset.
     *
     * @return the peak live thread count.
     */
    public int getPeakThreadCount();

    /**
     * Returns the total number of threads created and also started
     * since the Java virtual machine started.
     *
     * @return the total number of threads started.
     */
    public long getTotalStartedThreadCount();

    /**
     * Returns the current number of live daemon threads.
     *
     * @return the current number of live daemon threads.
     */
    public int getDaemonThreadCount();

    /**
     * Returns all live thread IDs.
     * Some threads included in the returned array
     * may have been terminated when this method returns.
     *
     * @return an array of &lt;tt&gt;long&lt;/tt&gt;, each is a thread ID.
     *
     * @throws java.lang.SecurityException if a security manager
     *         exists and the caller does not have
     *         ManagementPermission(&quot;monitor&quot;).
     */
    public long[] getAllThreadIds();

    /**
     * Returns the thread info for a thread of the specified
     * &lt;tt&gt;id&lt;/tt&gt; with no stack trace.
     * This method is equivalent to calling:
     * &lt;blockquote&gt;
     *   {@link #getThreadInfo(long, int) getThreadInfo(id, 0);}
     * &lt;/blockquote&gt;
     *
     * &lt;p&gt;
     * This method returns a &lt;tt&gt;ThreadInfo&lt;/tt&gt; object representing
     * the thread information for the thread of the specified ID.
     * The stack trace, locked monitors, and locked synchronizers
     * in the returned &lt;tt&gt;ThreadInfo&lt;/tt&gt; object will
     * be empty.
     *
     * If a thread of the given ID is not alive or does not exist,
     * this method will return &lt;tt&gt;null&lt;/tt&gt;.  A thread is alive if
     * it has been started and has not yet died.
     *
     * &lt;p&gt;
     * &lt;b&gt;MBeanServer access&lt;/b&gt;:&lt;br&gt;
     * The mapped type of &lt;tt&gt;ThreadInfo&lt;/tt&gt; is
     * &lt;tt&gt;CompositeData&lt;/tt&gt; with attributes as specified in the
     * {@link ThreadInfo#from ThreadInfo.from} method.
     *
     * @param id the thread ID of the thread. Must be positive.
     *
     * @return a {@link ThreadInfo} object for the thread of the given ID
     * with no stack trace, no locked monitor and no synchronizer info;
     * &lt;tt&gt;null&lt;/tt&gt; if the thread of the given ID is not alive or
     * it does not exist.
     *
     * @throws IllegalArgumentException if {@code id &lt;= 0}.
     * @throws java.lang.SecurityException if a security manager
     *         exists and the caller does not have
     *         ManagementPermission(&quot;monitor&quot;).
     */
    public ThreadInfo getThreadInfo(long id);

    /**
     * Returns the thread info for each thread
     * whose ID is in the input array &lt;tt&gt;ids&lt;/tt&gt; with no stack trace.
     * This method is equivalent to calling:
     * &lt;blockquote&gt;&lt;pre&gt;
     *   {@link #getThreadInfo(long[], int) getThreadInfo}(ids, 0);
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * &lt;p&gt;
     * This method returns an array of the &lt;tt&gt;ThreadInfo&lt;/tt&gt; objects.
     * The stack trace, locked monitors, and locked synchronizers
     * in each &lt;tt&gt;ThreadInfo&lt;/tt&gt; object will be empty.
     *
     * If a thread of a given ID is not alive or does not exist,
     * the corresponding element in the returned array will
     * contain &lt;tt&gt;null&lt;/tt&gt;.  A thread is alive if
     * it has been started and has not yet died.
     *
     * &lt;p&gt;
     * &lt;b&gt;MBeanServer access&lt;/b&gt;:&lt;br&gt;
     * The mapped type of &lt;tt&gt;ThreadInfo&lt;/tt&gt; is
     * &lt;tt&gt;CompositeData&lt;/tt&gt; with attributes as specified in the
     * {@link ThreadInfo#from ThreadInfo.from} method.
     *
     * @param ids an array of thread IDs.
     * @return an array of the {@link ThreadInfo} objects, each containing
     * information about a thread whose ID is in the corresponding
     * element of the input array of IDs
     * with no stack trace, no locked monitor and no synchronizer info.
     *
     * @throws IllegalArgumentException if any element in the input array
     *         &lt;tt&gt;ids&lt;/tt&gt; is {@code &lt;= 0}.
     * @throws java.lang.SecurityException if a security manager
     *         exists and the caller does not have
     *         ManagementPermission(&quot;monitor&quot;).
     */
    public ThreadInfo[] getThreadInfo(long[] ids);

    /**
     * Returns a thread info for a thread of the specified &lt;tt&gt;id&lt;/tt&gt;,
     * with stack trace of a specified number of stack trace elements.
     * The &lt;tt&gt;maxDepth&lt;/tt&gt; parameter indicates the maximum number of
     * {@link StackTraceElement} to be retrieved from the stack trace.
     * If &lt;tt&gt;maxDepth == Integer.MAX_VALUE&lt;/tt&gt;, the entire stack trace of
     * the thread will be dumped.
     * If &lt;tt&gt;maxDepth == 0&lt;/tt&gt;, no stack trace of the thread
     * will be dumped.
     * This method does not obtain the locked monitors and locked
     * synchronizers of the thread.
     * &lt;p&gt;
     * When the Java virtual machine has no stack trace information
     * about a thread or &lt;tt&gt;maxDepth == 0&lt;/tt&gt;,
     * the stack trace in the
     * &lt;tt&gt;ThreadInfo&lt;/tt&gt; object will be an empty array of
     * &lt;tt&gt;StackTraceElement&lt;/tt&gt;.
     *
     * &lt;p&gt;
     * If a thread of the given ID is not alive or does not exist,
     * this method will return &lt;tt&gt;null&lt;/tt&gt;.  A thread is alive if
     * it has been started and has not yet died.
     *
     * &lt;p&gt;
     * &lt;b&gt;MBeanServer access&lt;/b&gt;:&lt;br&gt;
     * The mapped type of &lt;tt&gt;ThreadInfo&lt;/tt&gt; is
     * &lt;tt&gt;CompositeData&lt;/tt&gt; with attributes as specified in the
     * {@link ThreadInfo#from ThreadInfo.from} method.
     *
     * @param id the thread ID of the thread. Must be positive.
     * @param maxDepth the maximum number of entries in the stack trace
     * to be dumped. &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; could be used to request
     * the entire stack to be dumped.
     *
     * @return a {@link ThreadInfo} of the thread of the given ID
     * with no locked monitor and synchronizer info.
     * &lt;tt&gt;null&lt;/tt&gt; if the thread of the given ID is not alive or
     * it does not exist.
     *
     * @throws IllegalArgumentException if {@code id &lt;= 0}.
     * @throws IllegalArgumentException if &lt;tt&gt;maxDepth is negative&lt;/tt&gt;.
     * @throws java.lang.SecurityException if a security manager
     *         exists and the caller does not have
     *         ManagementPermission(&quot;monitor&quot;).
     *
     */
    public ThreadInfo getThreadInfo(long id, int maxDepth);

    /**
     * Returns the thread info for each thread
     * whose ID is in the input array &lt;tt&gt;ids&lt;/tt&gt;,
     * with stack trace of a specified number of stack trace elements.
     * The &lt;tt&gt;maxDepth&lt;/tt&gt; parameter indicates the maximum number of
     * {@link StackTraceElement} to be retrieved from the stack trace.
     * If &lt;tt&gt;maxDepth == Integer.MAX_VALUE&lt;/tt&gt;, the entire stack trace of
     * the thread will be dumped.
     * If &lt;tt&gt;maxDepth == 0&lt;/tt&gt;, no stack trace of the thread
     * will be dumped.
     * This method does not obtain the locked monitors and locked
     * synchronizers of the threads.
     * &lt;p&gt;
     * When the Java virtual machine has no stack trace information
     * about a thread or &lt;tt&gt;maxDepth == 0&lt;/tt&gt;,
     * the stack trace in the
     * &lt;tt&gt;ThreadInfo&lt;/tt&gt; object will be an empty array of
     * &lt;tt&gt;StackTraceElement&lt;/tt&gt;.
     * &lt;p&gt;
     * This method returns an array of the &lt;tt&gt;ThreadInfo&lt;/tt&gt; objects,
     * each is the thread information about the thread with the same index
     * as in the &lt;tt&gt;ids&lt;/tt&gt; array.
     * If a thread of the given ID is not alive or does not exist,
     * &lt;tt&gt;null&lt;/tt&gt; will be set in the corresponding element
     * in the returned array.  A thread is alive if
     * it has been started and has not yet died.
     *
     * &lt;p&gt;
     * &lt;b&gt;MBeanServer access&lt;/b&gt;:&lt;br&gt;
     * The mapped type of &lt;tt&gt;ThreadInfo&lt;/tt&gt; is
     * &lt;tt&gt;CompositeData&lt;/tt&gt; with attributes as specified in the
     * {@link ThreadInfo#from ThreadInfo.from} method.
     *
     * @param ids an array of thread IDs
     * @param maxDepth the maximum number of entries in the stack trace
     * to be dumped. &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; could be used to request
     * the entire stack to be dumped.
     *
     * @return an array of the {@link ThreadInfo} objects, each containing
     * information about a thread whose ID is in the corresponding
     * element of the input array of IDs with no locked monitor and
     * synchronizer info.
     *
     * @throws IllegalArgumentException if &lt;tt&gt;maxDepth is negative&lt;/tt&gt;.
     * @throws IllegalArgumentException if any element in the input array
     *      &lt;tt&gt;ids&lt;/tt&gt; is {@code &lt;= 0}.
     * @throws java.lang.SecurityException if a security manager
     *         exists and the caller does not have
     *         ManagementPermission(&quot;monitor&quot;).
     *
     */
    public ThreadInfo[] getThreadInfo(long[] ids, int maxDepth);

    /**
     * Tests if the Java virtual machine supports thread contention monitoring.
     *
     * @return
     *   &lt;tt&gt;true&lt;/tt&gt;
     *     if the Java virtual machine supports thread contention monitoring;
     *   &lt;tt&gt;false&lt;/tt&gt; otherwise.
     */
    public boolean isThreadContentionMonitoringSupported();

    /**
     * Tests if thread contention monitoring is enabled.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if thread contention monitoring is enabled;
     *         &lt;tt&gt;false&lt;/tt&gt; otherwise.
     *
     * @throws java.lang.UnsupportedOperationException if the Java virtual
     * machine does not support thread contention monitoring.
     *
     * @see #isThreadContentionMonitoringSupported
     */
    public boolean isThreadContentionMonitoringEnabled();

    /**
     * Enables or disables thread contention monitoring.
     * Thread contention monitoring is disabled by default.
     *
     * @param enable &lt;tt&gt;true&lt;/tt&gt; to enable;
     *               &lt;tt&gt;false&lt;/tt&gt; to disable.
     *
     * @throws java.lang.UnsupportedOperationException if the Java
     * virtual machine does not support thread contention monitoring.
     *
     * @throws java.lang.SecurityException if a security manager
     *         exists and the caller does not have
     *         ManagementPermission(&quot;control&quot;).
     *
     * @see #isThreadContentionMonitoringSupported
     */
    public void setThreadContentionMonitoringEnabled(boolean enable);

    /**
     * Returns the total CPU time for the current thread in nanoseconds.
     * The returned value is of nanoseconds precision but
     * not necessarily nanoseconds accuracy.
     * If the implementation distinguishes between user mode time and system
     * mode time, the returned CPU time is the amount of time that
     * the current thread has executed in user mode or system mode.
     *
     * &lt;p&gt;
     * This is a convenient method for local management use and is
     * equivalent to calling:
     * &lt;blockquote&gt;&lt;pre&gt;
     *   {@link #getThreadCpuTime getThreadCpuTime}(Thread.currentThread().getId());
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @return the total CPU time for the current thread if CPU time
     * measurement is enabled; &lt;tt&gt;-1&lt;/tt&gt; otherwise.
     *
     * @throws java.lang.UnsupportedOperationException if the Java
     * virtual machine does not support CPU time measurement for
     * the current thread.
     *
     * @see #getCurrentThreadUserTime
     * @see #isCurrentThreadCpuTimeSupported
     * @see #isThreadCpuTimeEnabled
     * @see #setThreadCpuTimeEnabled
     */
    public long getCurrentThreadCpuTime();

    /**
     * Returns the CPU time that the current thread has executed
     * in user mode in nanoseconds.
     * The returned value is of nanoseconds precision but
     * not necessarily nanoseconds accuracy.
     *
     * &lt;p&gt;
     * This is a convenient method for local management use and is
     * equivalent to calling:
     * &lt;blockquote&gt;&lt;pre&gt;
     *   {@link #getThreadUserTime getThreadUserTime}(Thread.currentThread().getId());
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @return the user-level CPU time for the current thread if CPU time
     * measurement is enabled; &lt;tt&gt;-1&lt;/tt&gt; otherwise.
     *
     * @throws java.lang.UnsupportedOperationException if the Java
     * virtual machine does not support CPU time measurement for
     * the current thread.
     *
     * @see #getCurrentThreadCpuTime
     * @see #isCurrentThreadCpuTimeSupported
     * @see #isThreadCpuTimeEnabled
     * @see #setThreadCpuTimeEnabled
     */
    public long getCurrentThreadUserTime();

    /**
     * Returns the total CPU time for a thread of the specified ID in nanoseconds.
     * The returned value is of nanoseconds precision but
     * not necessarily nanoseconds accuracy.
     * If the implementation distinguishes between user mode time and system
     * mode time, the returned CPU time is the amount of time that
     * the thread has executed in user mode or system mode.
     *
     * &lt;p&gt;
     * If the thread of the specified ID is not alive or does not exist,
     * this method returns &lt;tt&gt;-1&lt;/tt&gt;. If CPU time measurement
     * is disabled, this method returns &lt;tt&gt;-1&lt;/tt&gt;.
     * A thread is alive if it has been started and has not yet died.
     * &lt;p&gt;
     * If CPU time measurement is enabled after the thread has started,
     * the Java virtual machine implementation may choose any time up to
     * and including the time that the capability is enabled as the point
     * where CPU time measurement starts.
     *
     * @param id the thread ID of a thread
     * @return the total CPU time for a thread of the specified ID
     * if the thread of the specified ID exists, the thread is alive,
     * and CPU time measurement is enabled;
     * &lt;tt&gt;-1&lt;/tt&gt; otherwise.
     *
     * @throws IllegalArgumentException if {@code id &lt;= 0}.
     * @throws java.lang.UnsupportedOperationException if the Java
     * virtual machine does not support CPU time measurement for
     * other threads.
     *
     * @see #getThreadUserTime
     * @see #isThreadCpuTimeSupported
     * @see #isThreadCpuTimeEnabled
     * @see #setThreadCpuTimeEnabled
     */
    public long getThreadCpuTime(long id);

    /**
     * Returns the CPU time that a thread of the specified ID
     * has executed in user mode in nanoseconds.
     * The returned value is of nanoseconds precision but
     * not necessarily nanoseconds accuracy.
     *
     * &lt;p&gt;
     * If the thread of the specified ID is not alive or does not exist,
     * this method returns &lt;tt&gt;-1&lt;/tt&gt;. If CPU time measurement
     * is disabled, this method returns &lt;tt&gt;-1&lt;/tt&gt;.
     * A thread is alive if it has been started and has not yet died.
     * &lt;p&gt;
     * If CPU time measurement is enabled after the thread has started,
     * the Java virtual machine implementation may choose any time up to
     * and including the time that the capability is enabled as the point
     * where CPU time measurement starts.
     *
     * @param id the thread ID of a thread
     * @return the user-level CPU time for a thread of the specified ID
     * if the thread of the specified ID exists, the thread is alive,
     * and CPU time measurement is enabled;
     * &lt;tt&gt;-1&lt;/tt&gt; otherwise.
     *
     * @throws IllegalArgumentException if {@code id &lt;= 0}.
     * @throws java.lang.UnsupportedOperationException if the Java
     * virtual machine does not support CPU time measurement for
     * other threads.
     *
     * @see #getThreadCpuTime
     * @see #isThreadCpuTimeSupported
     * @see #isThreadCpuTimeEnabled
     * @see #setThreadCpuTimeEnabled
     */
    public long getThreadUserTime(long id);

    /**
     * Tests if the Java virtual machine implementation supports CPU time
     * measurement for any thread.
     * A Java virtual machine implementation that supports CPU time
     * measurement for any thread will also support CPU time
     * measurement for the current thread.
     *
     * @return
     *   &lt;tt&gt;true&lt;/tt&gt;
     *     if the Java virtual machine supports CPU time
     *     measurement for any thread;
     *   &lt;tt&gt;false&lt;/tt&gt; otherwise.
     */
    public boolean isThreadCpuTimeSupported();

    /**
     * Tests if the Java virtual machine supports CPU time
     * measurement for the current thread.
     * This method returns &lt;tt&gt;true&lt;/tt&gt; if {@link #isThreadCpuTimeSupported}
     * returns &lt;tt&gt;true&lt;/tt&gt;.
     *
     * @return
     *   &lt;tt&gt;true&lt;/tt&gt;
     *     if the Java virtual machine supports CPU time
     *     measurement for current thread;
     *   &lt;tt&gt;false&lt;/tt&gt; otherwise.
     */
    public boolean isCurrentThreadCpuTimeSupported();

    /**
     * Tests if thread CPU time measurement is enabled.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if thread CPU time measurement is enabled;
     *         &lt;tt&gt;false&lt;/tt&gt; otherwise.
     *
     * @throws java.lang.UnsupportedOperationException if the Java virtual
     * machine does not support CPU time measurement for other threads
     * nor for the current thread.
     *
     * @see #isThreadCpuTimeSupported
     * @see #isCurrentThreadCpuTimeSupported
     */
    public boolean isThreadCpuTimeEnabled();

    /**
     * Enables or disables thread CPU time measurement.  The default
     * is platform dependent.
     *
     * @param enable &lt;tt&gt;true&lt;/tt&gt; to enable;
     *               &lt;tt&gt;false&lt;/tt&gt; to disable.
     *
     * @throws java.lang.UnsupportedOperationException if the Java
     * virtual machine does not support CPU time measurement for
     * any threads nor for the current thread.
     *
     * @throws java.lang.SecurityException if a security manager
     *         exists and the caller does not have
     *         ManagementPermission(&quot;control&quot;).
     *
     * @see #isThreadCpuTimeSupported
     * @see #isCurrentThreadCpuTimeSupported
     */
    public void setThreadCpuTimeEnabled(boolean enable);

    /**
     * Finds cycles of threads that are in deadlock waiting to acquire
     * object monitors. That is, threads that are blocked waiting to enter a
     * synchronization block or waiting to reenter a synchronization block
     * after an {@link Object#wait Object.wait} call,
     * where each thread owns one monitor while
     * trying to obtain another monitor already held by another thread
     * in a cycle.
     * &lt;p&gt;
     * More formally, a thread is &lt;em&gt;monitor deadlocked&lt;/em&gt; if it is
     * part of a cycle in the relation &quot;is waiting for an object monitor
     * owned by&quot;.  In the simplest case, thread A is blocked waiting
     * for a monitor owned by thread B, and thread B is blocked waiting
     * for a monitor owned by thread A.
     * &lt;p&gt;
     * This method is designed for troubleshooting use, but not for
     * synchronization control.  It might be an expensive operation.
     * &lt;p&gt;
     * This method finds deadlocks involving only object monitors.
     * To find deadlocks involving both object monitors and
     * &lt;a href=&quot;LockInfo.html#OwnableSynchronizer&quot;&gt;ownable synchronizers&lt;/a&gt;,
     * the {@link #findDeadlockedThreads findDeadlockedThreads} method
     * should be used.
     *
     * @return an array of IDs of the threads that are monitor
     * deadlocked, if any; &lt;tt&gt;null&lt;/tt&gt; otherwise.
     *
     * @throws java.lang.SecurityException if a security manager
     *         exists and the caller does not have
     *         ManagementPermission(&quot;monitor&quot;).
     *
     * @see #findDeadlockedThreads
     */
    public long[] findMonitorDeadlockedThreads();

    /**
     * Resets the peak thread count to the current number of
     * live threads.
     *
     * @throws java.lang.SecurityException if a security manager
     *         exists and the caller does not have
     *         ManagementPermission(&quot;control&quot;).
     *
     * @see #getPeakThreadCount
     * @see #getThreadCount
     */
    public void resetPeakThreadCount();

    /**
     * Finds cycles of threads that are in deadlock waiting to acquire
     * object monitors or
     * &lt;a href=&quot;LockInfo.html#OwnableSynchronizer&quot;&gt;ownable synchronizers&lt;/a&gt;.
     *
     * Threads are &lt;em&gt;deadlocked&lt;/em&gt; in a cycle waiting for a lock of
     * these two types if each thread owns one lock while
     * trying to acquire another lock already held
     * by another thread in the cycle.
     * &lt;p&gt;
     * This method is designed for troubleshooting use, but not for
     * synchronization control.  It might be an expensive operation.
     *
     * @return an array of IDs of the threads that are
     * deadlocked waiting for object monitors or ownable synchronizers, if any;
     * &lt;tt&gt;null&lt;/tt&gt; otherwise.
     *
     * @throws java.lang.SecurityException if a security manager
     *         exists and the caller does not have
     *         ManagementPermission(&quot;monitor&quot;).
     * @throws java.lang.UnsupportedOperationException if the Java virtual
     * machine does not support monitoring of ownable synchronizer usage.
     *
     * @see #isSynchronizerUsageSupported
     * @see #findMonitorDeadlockedThreads
     * @since 1.6
     */
    public long[] findDeadlockedThreads();

    /**
     * Tests if the Java virtual machine supports monitoring of
     * object monitor usage.
     *
     * @return
     *   &lt;tt&gt;true&lt;/tt&gt;
     *     if the Java virtual machine supports monitoring of
     *     object monitor usage;
     *   &lt;tt&gt;false&lt;/tt&gt; otherwise.
     *
     * @see #dumpAllThreads
     * @since 1.6
     */
    public boolean isObjectMonitorUsageSupported();

    /**
     * Tests if the Java virtual machine supports monitoring of
     * &lt;a href=&quot;LockInfo.html#OwnableSynchronizer&quot;&gt;
     * ownable synchronizer&lt;/a&gt; usage.
     *
     * @return
     *   &lt;tt&gt;true&lt;/tt&gt;
     *     if the Java virtual machine supports monitoring of ownable
     *     synchronizer usage;
     *   &lt;tt&gt;false&lt;/tt&gt; otherwise.
     *
     * @see #dumpAllThreads
     * @since 1.6
     */
    public boolean isSynchronizerUsageSupported();

    /**
     * Returns the thread info for each thread
     * whose ID is in the input array &lt;tt&gt;ids&lt;/tt&gt;, with stack trace
     * and synchronization information.
     *
     * &lt;p&gt;
     * This method obtains a snapshot of the thread information
     * for each thread including:
     * &lt;ul&gt;
     *    &lt;li&gt;the entire stack trace,&lt;/li&gt;
     *    &lt;li&gt;the object monitors currently locked by the thread
     *        if &lt;tt&gt;lockedMonitors&lt;/tt&gt; is &lt;tt&gt;true&lt;/tt&gt;, and&lt;/li&gt;
     *    &lt;li&gt;the &lt;a href=&quot;LockInfo.html#OwnableSynchronizer&quot;&gt;
     *        ownable synchronizers&lt;/a&gt; currently locked by the thread
     *        if &lt;tt&gt;lockedSynchronizers&lt;/tt&gt; is &lt;tt&gt;true&lt;/tt&gt;.&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * This method returns an array of the &lt;tt&gt;ThreadInfo&lt;/tt&gt; objects,
     * each is the thread information about the thread with the same index
     * as in the &lt;tt&gt;ids&lt;/tt&gt; array.
     * If a thread of the given ID is not alive or does not exist,
     * &lt;tt&gt;null&lt;/tt&gt; will be set in the corresponding element
     * in the returned array.  A thread is alive if
     * it has been started and has not yet died.
     * &lt;p&gt;
     * If a thread does not lock any object monitor or &lt;tt&gt;lockedMonitors&lt;/tt&gt;
     * is &lt;tt&gt;false&lt;/tt&gt;, the returned &lt;tt&gt;ThreadInfo&lt;/tt&gt; object will have an
     * empty &lt;tt&gt;MonitorInfo&lt;/tt&gt; array.  Similarly, if a thread does not
     * lock any synchronizer or &lt;tt&gt;lockedSynchronizers&lt;/tt&gt; is &lt;tt&gt;false&lt;/tt&gt;,
     * the returned &lt;tt&gt;ThreadInfo&lt;/tt&gt; object
     * will have an empty &lt;tt&gt;LockInfo&lt;/tt&gt; array.
     *
     * &lt;p&gt;
     * When both &lt;tt&gt;lockedMonitors&lt;/tt&gt; and &lt;tt&gt;lockedSynchronizers&lt;/tt&gt;
     * parameters are &lt;tt&gt;false&lt;/tt&gt;, it is equivalent to calling:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     {@link #getThreadInfo(long[], int)  getThreadInfo(ids, Integer.MAX_VALUE)}
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * &lt;p&gt;
     * This method is designed for troubleshooting use, but not for
     * synchronization control.  It might be an expensive operation.
     *
     * &lt;p&gt;
     * &lt;b&gt;MBeanServer access&lt;/b&gt;:&lt;br&gt;
     * The mapped type of &lt;tt&gt;ThreadInfo&lt;/tt&gt; is
     * &lt;tt&gt;CompositeData&lt;/tt&gt; with attributes as specified in the
     * {@link ThreadInfo#from ThreadInfo.from} method.
     *
     * @param  ids an array of thread IDs.
     * @param  lockedMonitors if &lt;tt&gt;true&lt;/tt&gt;, retrieves all locked monitors.
     * @param  lockedSynchronizers if &lt;tt&gt;true&lt;/tt&gt;, retrieves all locked
     *             ownable synchronizers.
     *
     * @return an array of the {@link ThreadInfo} objects, each containing
     * information about a thread whose ID is in the corresponding
     * element of the input array of IDs.
     *
     * @throws java.lang.SecurityException if a security manager
     *         exists and the caller does not have
     *         ManagementPermission(&quot;monitor&quot;).
     * @throws java.lang.UnsupportedOperationException
     *         &lt;ul&gt;
     *           &lt;li&gt;if &lt;tt&gt;lockedMonitors&lt;/tt&gt; is &lt;tt&gt;true&lt;/tt&gt; but
     *               the Java virtual machine does not support monitoring
     *               of {@linkplain #isObjectMonitorUsageSupported
     *               object monitor usage}; or&lt;/li&gt;
     *           &lt;li&gt;if &lt;tt&gt;lockedSynchronizers&lt;/tt&gt; is &lt;tt&gt;true&lt;/tt&gt; but
     *               the Java virtual machine does not support monitoring
     *               of {@linkplain #isSynchronizerUsageSupported
     *               ownable synchronizer usage}.&lt;/li&gt;
     *         &lt;/ul&gt;
     *
     * @see #isObjectMonitorUsageSupported
     * @see #isSynchronizerUsageSupported
     *
     * @since 1.6
     */
    public ThreadInfo[] getThreadInfo(long[] ids, boolean lockedMonitors, boolean lockedSynchronizers);

    /**
     * Returns the thread info for all live threads with stack trace
     * and synchronization information.
     * Some threads included in the returned array
     * may have been terminated when this method returns.
     *
     * &lt;p&gt;
     * This method returns an array of {@link ThreadInfo} objects
     * as specified in the {@link #getThreadInfo(long[], boolean, boolean)}
     * method.
     *
     * @param  lockedMonitors if &lt;tt&gt;true&lt;/tt&gt;, dump all locked monitors.
     * @param  lockedSynchronizers if &lt;tt&gt;true&lt;/tt&gt;, dump all locked
     *             ownable synchronizers.
     *
     * @return an array of {@link ThreadInfo} for all live threads.
     *
     * @throws java.lang.SecurityException if a security manager
     *         exists and the caller does not have
     *         ManagementPermission(&quot;monitor&quot;).
     * @throws java.lang.UnsupportedOperationException
     *         &lt;ul&gt;
     *           &lt;li&gt;if &lt;tt&gt;lockedMonitors&lt;/tt&gt; is &lt;tt&gt;true&lt;/tt&gt; but
     *               the Java virtual machine does not support monitoring
     *               of {@linkplain #isObjectMonitorUsageSupported
     *               object monitor usage}; or&lt;/li&gt;
     *           &lt;li&gt;if &lt;tt&gt;lockedSynchronizers&lt;/tt&gt; is &lt;tt&gt;true&lt;/tt&gt; but
     *               the Java virtual machine does not support monitoring
     *               of {@linkplain #isSynchronizerUsageSupported
     *               ownable synchronizer usage}.&lt;/li&gt;
     *         &lt;/ul&gt;
     *
     * @see #isObjectMonitorUsageSupported
     * @see #isSynchronizerUsageSupported
     *
     * @since 1.6
     */
    public ThreadInfo[] dumpAllThreads(boolean lockedMonitors, boolean lockedSynchronizers);
}
</pre>
</body>
</html>
