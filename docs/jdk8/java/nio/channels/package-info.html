<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/**
 * Defines channels, which represent connections to entities that are capable of
 * performing I/O operations, such as files and sockets; defines selectors, for
 * multiplexed, non-blocking I/O operations.
 *
 * &lt;a name=&quot;channels&quot;&gt;&lt;/a&gt;
 *
 * &lt;blockquote&gt;&lt;table cellspacing=1 cellpadding=0 summary=&quot;Lists channels and their descriptions&quot;&gt;
 * &lt;tr&gt;&lt;th align=&quot;left&quot;&gt;Channels&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;{@link java.nio.channels.Channel}&lt;/i&gt;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A nexus for I/O operations&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&amp;nbsp;&amp;nbsp;&lt;i&gt;{@link java.nio.channels.ReadableByteChannel}&lt;/i&gt;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Can read into a buffer&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;i&gt;{@link java.nio.channels.ScatteringByteChannel}&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Can read into a sequence of&amp;nbsp;buffers&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&amp;nbsp;&amp;nbsp;&lt;i&gt;{@link java.nio.channels.WritableByteChannel}&lt;/i&gt;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Can write from a buffer&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;i&gt;{@link java.nio.channels.GatheringByteChannel}&lt;/i&gt;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Can write from a sequence of&amp;nbsp;buffers&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&amp;nbsp;&amp;nbsp;&lt;i&gt;{@link java.nio.channels.ByteChannel}&lt;/i&gt;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Can read/write to/from a&amp;nbsp;buffer&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;i&gt;{@link java.nio.channels.SeekableByteChannel}&lt;/i&gt;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A {@code ByteChannel} connected to an entity that contains a variable-length sequence of bytes&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&amp;nbsp;&amp;nbsp;&lt;i&gt;{@link java.nio.channels.AsynchronousChannel}&lt;/i&gt;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Supports asynchronous I/O operations.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;i&gt;{@link java.nio.channels.AsynchronousByteChannel}&lt;/i&gt;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Can read and write bytes asynchronously&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&amp;nbsp;&amp;nbsp;&lt;i&gt;{@link java.nio.channels.NetworkChannel}&lt;/i&gt;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A channel to a network socket&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;i&gt;{@link java.nio.channels.MulticastChannel}&lt;/i&gt;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Can join Internet Protocol (IP) multicast groups&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;{@link java.nio.channels.Channels}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Utility methods for channel/stream interoperation&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; A &lt;i&gt;channel&lt;/i&gt; represents an open connection to an entity such as a
 * hardware device, a file, a network socket, or a program component that is
 * capable of performing one or more distinct I/O operations, for example reading
 * or writing.  As specified in the {@link java.nio.channels.Channel} interface,
 * channels are either open or closed, and they are both &lt;i&gt;asynchronously
 * closeable&lt;/i&gt; and &lt;i&gt;interruptible&lt;/i&gt;.
 *
 * &lt;p&gt; The {@link java.nio.channels.Channel} interface is extended by several
 * other interfaces.
 *
 * &lt;p&gt; The {@link java.nio.channels.ReadableByteChannel} interface specifies a
 * {@link java.nio.channels.ReadableByteChannel#read read} method that reads bytes
 * from the channel into a buffer; similarly, the {@link
 * java.nio.channels.WritableByteChannel} interface specifies a {@link
 * java.nio.channels.WritableByteChannel#write write} method that writes bytes
 * from a buffer to the channel. The {@link java.nio.channels.ByteChannel}
 * interface unifies these two interfaces for the common case of channels that can
 * both read and write bytes. The {@link java.nio.channels.SeekableByteChannel}
 * interface extends the {@code ByteChannel} interface with methods to {@link
 * java.nio.channels.SeekableByteChannel#position() query} and {@link
 * java.nio.channels.SeekableByteChannel#position(long) modify} the channel's
 * current position, and its {@link java.nio.channels.SeekableByteChannel#size
 * size}.
 *
 * &lt;p&gt; The {@link java.nio.channels.ScatteringByteChannel} and {@link
 * java.nio.channels.GatheringByteChannel} interfaces extend the {@link
 * java.nio.channels.ReadableByteChannel} and {@link
 * java.nio.channels.WritableByteChannel} interfaces, respectively, adding {@link
 * java.nio.channels.ScatteringByteChannel#read read} and {@link
 * java.nio.channels.GatheringByteChannel#write write} methods that take a
 * sequence of buffers rather than a single buffer.
 *
 * &lt;p&gt; The {@link java.nio.channels.NetworkChannel} interface specifies methods
 * to {@link java.nio.channels.NetworkChannel#bind bind} the channel's socket,
 * obtain the address to which the socket is bound, and methods to {@link
 * java.nio.channels.NetworkChannel#getOption get} and {@link
 * java.nio.channels.NetworkChannel#setOption set} socket options. The {@link
 * java.nio.channels.MulticastChannel} interface specifies methods to join
 * Internet Protocol (IP) multicast groups.
 *
 * &lt;p&gt; The {@link java.nio.channels.Channels} utility class defines static methods
 * that support the interoperation of the stream classes of the &lt;tt&gt;{@link
 * java.io}&lt;/tt&gt; package with the channel classes of this package.  An appropriate
 * channel can be constructed from an {@link java.io.InputStream} or an {@link
 * java.io.OutputStream}, and conversely an {@link java.io.InputStream} or an
 * {@link java.io.OutputStream} can be constructed from a channel.  A {@link
 * java.io.Reader} can be constructed that uses a given charset to decode bytes
 * from a given readable byte channel, and conversely a {@link java.io.Writer} can
 * be constructed that uses a given charset to encode characters into bytes and
 * write them to a given writable byte channel.
 *
 * &lt;blockquote&gt;&lt;table cellspacing=1 cellpadding=0 summary=&quot;Lists file channels and their descriptions&quot;&gt;
 * &lt;tr&gt;&lt;th align=&quot;left&quot;&gt;File channels&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;{@link java.nio.channels.FileChannel}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Reads, writes, maps, and manipulates files&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;{@link java.nio.channels.FileLock}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A lock on a (region of a) file&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;{@link java.nio.MappedByteBuffer}&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A direct byte buffer mapped to a region of a&amp;nbsp;file&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; The {@link java.nio.channels.FileChannel} class supports the usual
 * operations of reading bytes from, and writing bytes to, a channel connected to
 * a file, as well as those of querying and modifying the current file position
 * and truncating the file to a specific size.  It defines methods for acquiring
 * locks on the whole file or on a specific region of a file; these methods return
 * instances of the {@link java.nio.channels.FileLock} class.  Finally, it defines
 * methods for forcing updates to the file to be written to the storage device that
 * contains it, for efficiently transferring bytes between the file and other
 * channels, and for mapping a region of the file directly into memory.
 *
 * &lt;p&gt; A {@code FileChannel} is created by invoking one of its static {@link
 * java.nio.channels.FileChannel#open open} methods, or by invoking the {@code
 * getChannel} method of a {@link java.io.FileInputStream}, {@link
 * java.io.FileOutputStream}, or {@link java.io.RandomAccessFile} to return a
 * file channel connected to the same underlying file as the &lt;tt&gt;{@link java.io}&lt;/tt&gt;
 * class.
 *
 * &lt;a name=&quot;multiplex&quot;&gt;&lt;/a&gt;
 * &lt;blockquote&gt;&lt;table cellspacing=1 cellpadding=0 summary=&quot;Lists multiplexed, non-blocking channels and their descriptions&quot;&gt;
 * &lt;tr&gt;&lt;th align=&quot;left&quot;&gt;Multiplexed, non-blocking I/O&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;&lt;p&gt;Description&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;{@link java.nio.channels.SelectableChannel}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A channel that can be multiplexed&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&amp;nbsp;&amp;nbsp;{@link java.nio.channels.DatagramChannel}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A channel to a datagram-oriented socket&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&amp;nbsp;&amp;nbsp;{@link java.nio.channels.Pipe.SinkChannel}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;The write end of a pipe&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&amp;nbsp;&amp;nbsp;{@link java.nio.channels.Pipe.SourceChannel}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;The read end of a pipe&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&amp;nbsp;&amp;nbsp;{@link java.nio.channels.ServerSocketChannel}&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A channel to a stream-oriented listening socket&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&amp;nbsp;&amp;nbsp;{@link java.nio.channels.SocketChannel}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A channel for a stream-oriented connecting socket&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;{@link java.nio.channels.Selector}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A multiplexor of selectable channels&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;{@link java.nio.channels.SelectionKey}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A token representing the registration &lt;br&gt; of a channel
 *     with&amp;nbsp;a&amp;nbsp;selector&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;{@link java.nio.channels.Pipe}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Two channels that form a unidirectional&amp;nbsp;pipe&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; Multiplexed, non-blocking I/O, which is much more scalable than
 * thread-oriented, blocking I/O, is provided by &lt;i&gt;selectors&lt;/i&gt;, &lt;i&gt;selectable
 * channels&lt;/i&gt;, and &lt;i&gt;selection keys&lt;/i&gt;.
 *
 * &lt;p&gt; A &lt;a href=&quot;Selector.html&quot;&gt;&lt;i&gt;selector&lt;/i&gt;&lt;/a&gt; is a multiplexor of &lt;a
 * href=&quot;SelectableChannel.html&quot;&gt;&lt;i&gt;selectable channels&lt;/i&gt;&lt;/a&gt;, which in turn are
 * a special type of channel that can be put into &lt;a
 * href=&quot;SelectableChannel.html#bm&quot;&gt;&lt;i&gt;non-blocking mode&lt;/i&gt;&lt;/a&gt;.  To perform
 * multiplexed I/O operations, one or more selectable channels are first created,
 * put into non-blocking mode, and {@link
 * java.nio.channels.SelectableChannel#register &lt;i&gt;registered&lt;/i&gt;}
 * with a selector.  Registering a channel specifies the set of I/O operations
 * that will be tested for readiness by the selector, and returns a &lt;a
 * href=&quot;SelectionKey.html&quot;&gt;&lt;i&gt;selection key&lt;/i&gt;&lt;/a&gt; that represents the
 * registration.
 *
 * &lt;p&gt; Once some channels have been registered with a selector, a &lt;a
 * href=&quot;Selector.html#selop&quot;&gt;&lt;i&gt;selection operation&lt;/i&gt;&lt;/a&gt; can be performed in
 * order to discover which channels, if any, have become ready to perform one or
 * more of the operations in which interest was previously declared.  If a channel
 * is ready then the key returned when it was registered will be added to the
 * selector's &lt;i&gt;selected-key set&lt;/i&gt;.  The key set, and the keys within it, can
 * be examined in order to determine the operations for which each channel is
 * ready.  From each key one can retrieve the corresponding channel in order to
 * perform whatever I/O operations are required.
 *
 * &lt;p&gt; That a selection key indicates that its channel is ready for some operation
 * is a hint, but not a guarantee, that such an operation can be performed by a
 * thread without causing the thread to block.  It is imperative that code that
 * performs multiplexed I/O be written so as to ignore these hints when they prove
 * to be incorrect.
 *
 * &lt;p&gt; This package defines selectable-channel classes corresponding to the {@link
 * java.net.DatagramSocket}, {@link java.net.ServerSocket}, and {@link
 * java.net.Socket} classes defined in the &lt;tt&gt;{@link java.net}&lt;/tt&gt; package.
 * Minor changes to these classes have been made in order to support sockets that
 * are associated with channels.  This package also defines a simple class that
 * implements unidirectional pipes.  In all cases, a new selectable channel is
 * created by invoking the static &lt;tt&gt;open&lt;/tt&gt; method of the corresponding class.
 * If a channel needs an associated socket then a socket will be created as a side
 * effect of this operation.
 *
 * &lt;p&gt; The implementation of selectors, selectable channels, and selection keys
 * can be replaced by &quot;plugging in&quot; an alternative definition or instance of the
 * {@link java.nio.channels.spi.SelectorProvider} class defined in the &lt;tt&gt;{@link
 * java.nio.channels.spi}&lt;/tt&gt; package.  It is not expected that many developers
 * will actually make use of this facility; it is provided primarily so that
 * sophisticated users can take advantage of operating-system-specific
 * I/O-multiplexing mechanisms when very high performance is required.
 *
 * &lt;p&gt; Much of the bookkeeping and synchronization required to implement the
 * multiplexed-I/O abstractions is performed by the {@link
 * java.nio.channels.spi.AbstractInterruptibleChannel}, {@link
 * java.nio.channels.spi.AbstractSelectableChannel}, {@link
 * java.nio.channels.spi.AbstractSelectionKey}, and {@link
 * java.nio.channels.spi.AbstractSelector} classes in the &lt;tt&gt;{@link
 * java.nio.channels.spi}&lt;/tt&gt; package.  When defining a custom selector provider,
 * only the {@link java.nio.channels.spi.AbstractSelector} and {@link
 * java.nio.channels.spi.AbstractSelectionKey} classes should be subclassed
 * directly; custom channel classes should extend the appropriate {@link
 * java.nio.channels.SelectableChannel} subclasses defined in this package.
 *
 * &lt;a name=&quot;async&quot;&gt;&lt;/a&gt;
 *
 * &lt;blockquote&gt;&lt;table cellspacing=1 cellpadding=0 summary=&quot;Lists asynchronous channels and their descriptions&quot;&gt;
 * &lt;tr&gt;&lt;th align=&quot;left&quot;&gt;Asynchronous I/O&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;{@link java.nio.channels.AsynchronousFileChannel}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;An asynchronous channel for reading, writing, and manipulating a file&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;{@link java.nio.channels.AsynchronousSocketChannel}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;An asynchronous channel to a stream-oriented connecting socket&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;{@link java.nio.channels.AsynchronousServerSocketChannel}&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;An asynchronous channel to a stream-oriented listening socket&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;{@link java.nio.channels.CompletionHandler}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A handler for consuming the result of an asynchronous operation&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;{@link java.nio.channels.AsynchronousChannelGroup}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A grouping of asynchronous channels for the purpose of resource sharing&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; {@link java.nio.channels.AsynchronousChannel Asynchronous channels} are a
 * special type of channel capable of asynchronous I/O operations. Asynchronous
 * channels are non-blocking and define methods to initiate asynchronous
 * operations, returning a {@link java.util.concurrent.Future} representing the
 * pending result of each operation. The {@code Future} can be used to poll or
 * wait for the result of the operation. Asynchronous I/O operations can also
 * specify a {@link java.nio.channels.CompletionHandler} to invoke when the
 * operation completes. A completion handler is user provided code that is executed
 * to consume the result of I/O operation.
 *
 * &lt;p&gt; This package defines asynchronous-channel classes that are connected to
 * a stream-oriented connecting or listening socket, or a datagram-oriented socket.
 * It also defines the {@link java.nio.channels.AsynchronousFileChannel} class
 * for asynchronous reading, writing, and manipulating a file. As with the {@link
 * java.nio.channels.FileChannel} it supports operations to truncate the file
 * to a specific size, force updates to the file to be written to the storage
 * device, or acquire locks on the whole file or on a specific region of the file.
 * Unlike the {@code FileChannel} it does not define methods for mapping a
 * region of the file directly into memory. Where memory mapped I/O is required,
 * then a {@code FileChannel} can be used.
 *
 * &lt;p&gt; Asynchronous channels are bound to an asynchronous channel group for the
 * purpose of resource sharing. A group has an associated {@link
 * java.util.concurrent.ExecutorService} to which tasks are submitted to handle
 * I/O events and dispatch to completion handlers that consume the result of
 * asynchronous operations performed on channels in the group. The group can
 * optionally be specified when creating the channel or the channel can be bound
 * to a &lt;em&gt;default group&lt;/em&gt;. Sophisticated users may wish to create their
 * own asynchronous channel groups or configure the {@code ExecutorService}
 * that will be used for the default group.
 *
 * &lt;p&gt; As with selectors, the implementation of asynchronous channels can be
 * replaced by &quot;plugging in&quot; an alternative definition or instance of the {@link
 * java.nio.channels.spi.AsynchronousChannelProvider} class defined in the
 * &lt;tt&gt;{@link java.nio.channels.spi}&lt;/tt&gt; package.  It is not expected that many
 * developers will actually make use of this facility; it is provided primarily
 * so that sophisticated users can take advantage of operating-system-specific
 * asynchronous I/O mechanisms when very high performance is required.
 *
 * &lt;hr width=&quot;80%&quot;&gt;
 * &lt;p&gt; Unless otherwise noted, passing a &lt;tt&gt;null&lt;/tt&gt; argument to a constructor
 * or method in any class or interface in this package will cause a {@link
 * java.lang.NullPointerException NullPointerException} to be thrown.
 *
 * @since 1.4
 * @author Mark Reinhold
 * @author JSR-51 Expert Group
 */

package java.nio.channels;
</pre>
</body>
</html>
