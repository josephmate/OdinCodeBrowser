<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.beans;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Proxy;
import java.lang.reflect.Method;
import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;

import sun.reflect.misc.MethodUtil;
import sun.reflect.misc.ReflectUtil;

/**
 * The &lt;code&gt;EventHandler&lt;/code&gt; class provides
 * support for dynamically generating event listeners whose methods
 * execute a simple statement involving an incoming event object
 * and a target object.
 * &lt;p&gt;
 * The &lt;code&gt;EventHandler&lt;/code&gt; class is intended to be used by interactive tools, such as
 * application builders, that allow developers to make connections between
 * beans. Typically connections are made from a user interface bean
 * (the event &lt;em&gt;source&lt;/em&gt;)
 * to an application logic bean (the &lt;em&gt;target&lt;/em&gt;). The most effective
 * connections of this kind isolate the application logic from the user
 * interface.  For example, the &lt;code&gt;EventHandler&lt;/code&gt; for a
 * connection from a &lt;code&gt;JCheckBox&lt;/code&gt; to a method
 * that accepts a boolean value can deal with extracting the state
 * of the check box and passing it directly to the method so that
 * the method is isolated from the user interface layer.
 * &lt;p&gt;
 * Inner classes are another, more general way to handle events from
 * user interfaces.  The &lt;code&gt;EventHandler&lt;/code&gt; class
 * handles only a subset of what is possible using inner
 * classes. However, &lt;code&gt;EventHandler&lt;/code&gt; works better
 * with the long-term persistence scheme than inner classes.
 * Also, using &lt;code&gt;EventHandler&lt;/code&gt; in large applications in
 * which the same interface is implemented many times can
 * reduce the disk and memory footprint of the application.
 * &lt;p&gt;
 * The reason that listeners created with &lt;code&gt;EventHandler&lt;/code&gt;
 * have such a small
 * footprint is that the &lt;code&gt;Proxy&lt;/code&gt; class, on which
 * the &lt;code&gt;EventHandler&lt;/code&gt; relies, shares implementations
 * of identical
 * interfaces. For example, if you use
 * the &lt;code&gt;EventHandler&lt;/code&gt; &lt;code&gt;create&lt;/code&gt; methods to make
 * all the &lt;code&gt;ActionListener&lt;/code&gt;s in an application,
 * all the action listeners will be instances of a single class
 * (one created by the &lt;code&gt;Proxy&lt;/code&gt; class).
 * In general, listeners based on
 * the &lt;code&gt;Proxy&lt;/code&gt; class require one listener class
 * to be created per &lt;em&gt;listener type&lt;/em&gt; (interface),
 * whereas the inner class
 * approach requires one class to be created per &lt;em&gt;listener&lt;/em&gt;
 * (object that implements the interface).
 *
 * &lt;p&gt;
 * You don't generally deal directly with &lt;code&gt;EventHandler&lt;/code&gt;
 * instances.
 * Instead, you use one of the &lt;code&gt;EventHandler&lt;/code&gt;
 * &lt;code&gt;create&lt;/code&gt; methods to create
 * an object that implements a given listener interface.
 * This listener object uses an &lt;code&gt;EventHandler&lt;/code&gt; object
 * behind the scenes to encapsulate information about the
 * event, the object to be sent a message when the event occurs,
 * the message (method) to be sent, and any argument
 * to the method.
 * The following section gives examples of how to create listener
 * objects using the &lt;code&gt;create&lt;/code&gt; methods.
 *
 * &lt;h2&gt;Examples of Using EventHandler&lt;/h2&gt;
 *
 * The simplest use of &lt;code&gt;EventHandler&lt;/code&gt; is to install
 * a listener that calls a method on the target object with no arguments.
 * In the following example we create an &lt;code&gt;ActionListener&lt;/code&gt;
 * that invokes the &lt;code&gt;toFront&lt;/code&gt; method on an instance
 * of &lt;code&gt;javax.swing.JFrame&lt;/code&gt;.
 *
 * &lt;blockquote&gt;
 *&lt;pre&gt;
 *myButton.addActionListener(
 *    (ActionListener)EventHandler.create(ActionListener.class, frame, &quot;toFront&quot;));
 *&lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * When &lt;code&gt;myButton&lt;/code&gt; is pressed, the statement
 * &lt;code&gt;frame.toFront()&lt;/code&gt; will be executed.  One could get
 * the same effect, with some additional compile-time type safety,
 * by defining a new implementation of the &lt;code&gt;ActionListener&lt;/code&gt;
 * interface and adding an instance of it to the button:
 *
 * &lt;blockquote&gt;
 *&lt;pre&gt;
//Equivalent code using an inner class instead of EventHandler.
 *myButton.addActionListener(new ActionListener() {
 *    public void actionPerformed(ActionEvent e) {
 *        frame.toFront();
 *    }
 *});
 *&lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * The next simplest use of &lt;code&gt;EventHandler&lt;/code&gt; is
 * to extract a property value from the first argument
 * of the method in the listener interface (typically an event object)
 * and use it to set the value of a property in the target object.
 * In the following example we create an &lt;code&gt;ActionListener&lt;/code&gt; that
 * sets the &lt;code&gt;nextFocusableComponent&lt;/code&gt; property of the target
 * (myButton) object to the value of the &quot;source&quot; property of the event.
 *
 * &lt;blockquote&gt;
 *&lt;pre&gt;
 *EventHandler.create(ActionListener.class, myButton, &quot;nextFocusableComponent&quot;, &quot;source&quot;)
 *&lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * This would correspond to the following inner class implementation:
 *
 * &lt;blockquote&gt;
 *&lt;pre&gt;
//Equivalent code using an inner class instead of EventHandler.
 *new ActionListener() {
 *    public void actionPerformed(ActionEvent e) {
 *        myButton.setNextFocusableComponent((Component)e.getSource());
 *    }
 *}
 *&lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * It's also possible to create an &lt;code&gt;EventHandler&lt;/code&gt; that
 * just passes the incoming event object to the target's action.
 * If the fourth &lt;code&gt;EventHandler.create&lt;/code&gt; argument is
 * an empty string, then the event is just passed along:
 *
 * &lt;blockquote&gt;
 *&lt;pre&gt;
 *EventHandler.create(ActionListener.class, target, &quot;doActionEvent&quot;, &quot;&quot;)
 *&lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * This would correspond to the following inner class implementation:
 *
 * &lt;blockquote&gt;
 *&lt;pre&gt;
//Equivalent code using an inner class instead of EventHandler.
 *new ActionListener() {
 *    public void actionPerformed(ActionEvent e) {
 *        target.doActionEvent(e);
 *    }
 *}
 *&lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * Probably the most common use of &lt;code&gt;EventHandler&lt;/code&gt;
 * is to extract a property value from the
 * &lt;em&gt;source&lt;/em&gt; of the event object and set this value as
 * the value of a property of the target object.
 * In the following example we create an &lt;code&gt;ActionListener&lt;/code&gt; that
 * sets the &quot;label&quot; property of the target
 * object to the value of the &quot;text&quot; property of the
 * source (the value of the &quot;source&quot; property) of the event.
 *
 * &lt;blockquote&gt;
 *&lt;pre&gt;
 *EventHandler.create(ActionListener.class, myButton, &quot;label&quot;, &quot;source.text&quot;)
 *&lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * This would correspond to the following inner class implementation:
 *
 * &lt;blockquote&gt;
 *&lt;pre&gt;
//Equivalent code using an inner class instead of EventHandler.
 *new ActionListener {
 *    public void actionPerformed(ActionEvent e) {
 *        myButton.setLabel(((JTextField)e.getSource()).getText());
 *    }
 *}
 *&lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * The event property may be &quot;qualified&quot; with an arbitrary number
 * of property prefixes delimited with the &quot;.&quot; character. The &quot;qualifying&quot;
 * names that appear before the &quot;.&quot; characters are taken as the names of
 * properties that should be applied, left-most first, to
 * the event object.
 * &lt;p&gt;
 * For example, the following action listener
 *
 * &lt;blockquote&gt;
 *&lt;pre&gt;
 *EventHandler.create(ActionListener.class, target, &quot;a&quot;, &quot;b.c.d&quot;)
 *&lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * might be written as the following inner class
 * (assuming all the properties had canonical getter methods and
 * returned the appropriate types):
 *
 * &lt;blockquote&gt;
 *&lt;pre&gt;
//Equivalent code using an inner class instead of EventHandler.
 *new ActionListener {
 *    public void actionPerformed(ActionEvent e) {
 *        target.setA(e.getB().getC().isD());
 *    }
 *}
 *&lt;/pre&gt;
 * &lt;/blockquote&gt;
 * The target property may also be &quot;qualified&quot; with an arbitrary number
 * of property prefixs delimited with the &quot;.&quot; character.  For example, the
 * following action listener:
 * &lt;pre&gt;
 *   EventHandler.create(ActionListener.class, target, &quot;a.b&quot;, &quot;c.d&quot;)
 * &lt;/pre&gt;
 * might be written as the following inner class
 * (assuming all the properties had canonical getter methods and
 * returned the appropriate types):
 * &lt;pre&gt;
 *   //Equivalent code using an inner class instead of EventHandler.
 *   new ActionListener {
 *     public void actionPerformed(ActionEvent e) {
 *         target.getA().setB(e.getC().isD());
 *    }
 *}
 *&lt;/pre&gt;
 * &lt;p&gt;
 * As &lt;code&gt;EventHandler&lt;/code&gt; ultimately relies on reflection to invoke
 * a method we recommend against targeting an overloaded method.  For example,
 * if the target is an instance of the class &lt;code&gt;MyTarget&lt;/code&gt; which is
 * defined as:
 * &lt;pre&gt;
 *   public class MyTarget {
 *     public void doIt(String);
 *     public void doIt(Object);
 *   }
 * &lt;/pre&gt;
 * Then the method &lt;code&gt;doIt&lt;/code&gt; is overloaded.  EventHandler will invoke
 * the method that is appropriate based on the source.  If the source is
 * null, then either method is appropriate and the one that is invoked is
 * undefined.  For that reason we recommend against targeting overloaded
 * methods.
 *
 * @see java.lang.reflect.Proxy
 * @see java.util.EventObject
 *
 * @since 1.4
 *
 * @author Mark Davidson
 * @author Philip Milne
 * @author Hans Muller
 *
 */
public class EventHandler implements InvocationHandler {
    private Object target;
    private String action;
    private final String eventPropertyName;
    private final String listenerMethodName;
    private final AccessControlContext acc = AccessController.getContext();

    /**
     * Creates a new &lt;code&gt;EventHandler&lt;/code&gt; object;
     * you generally use one of the &lt;code&gt;create&lt;/code&gt; methods
     * instead of invoking this constructor directly.  Refer to
     * {@link java.beans.EventHandler#create(Class, Object, String, String)
     * the general version of create} for a complete description of
     * the &lt;code&gt;eventPropertyName&lt;/code&gt; and &lt;code&gt;listenerMethodName&lt;/code&gt;
     * parameter.
     *
     * @param target the object that will perform the action
     * @param action the name of a (possibly qualified) property or method on
     *        the target
     * @param eventPropertyName the (possibly qualified) name of a readable property of the incoming event
     * @param listenerMethodName the name of the method in the listener interface that should trigger the action
     *
     * @throws NullPointerException if &lt;code&gt;target&lt;/code&gt; is null
     * @throws NullPointerException if &lt;code&gt;action&lt;/code&gt; is null
     *
     * @see EventHandler
     * @see #create(Class, Object, String, String, String)
     * @see #getTarget
     * @see #getAction
     * @see #getEventPropertyName
     * @see #getListenerMethodName
     */
    @ConstructorProperties({&quot;target&quot;, &quot;action&quot;, &quot;eventPropertyName&quot;, &quot;listenerMethodName&quot;})
    public EventHandler(Object target, String action, String eventPropertyName, String listenerMethodName) {
        this.target = target;
        this.action = action;
        if (target == null) {
            throw new NullPointerException(&quot;target must be non-null&quot;);
        }
        if (action == null) {
            throw new NullPointerException(&quot;action must be non-null&quot;);
        }
        this.eventPropertyName = eventPropertyName;
        this.listenerMethodName = listenerMethodName;
    }

    /**
     * Returns the object to which this event handler will send a message.
     *
     * @return the target of this event handler
     * @see #EventHandler(Object, String, String, String)
     */
    public Object getTarget()  {
        return target;
    }

    /**
     * Returns the name of the target's writable property
     * that this event handler will set,
     * or the name of the method that this event handler
     * will invoke on the target.
     *
     * @return the action of this event handler
     * @see #EventHandler(Object, String, String, String)
     */
    public String getAction()  {
        return action;
    }

    /**
     * Returns the property of the event that should be
     * used in the action applied to the target.
     *
     * @return the property of the event
     *
     * @see #EventHandler(Object, String, String, String)
     */
    public String getEventPropertyName()  {
        return eventPropertyName;
    }

    /**
     * Returns the name of the method that will trigger the action.
     * A return value of &lt;code&gt;null&lt;/code&gt; signifies that all methods in the
     * listener interface trigger the action.
     *
     * @return the name of the method that will trigger the action
     *
     * @see #EventHandler(Object, String, String, String)
     */
    public String getListenerMethodName()  {
        return listenerMethodName;
    }

    private Object applyGetters(Object target, String getters) {
        if (getters == null || getters.equals(&quot;&quot;)) {
            return target;
        }
        int firstDot = getters.indexOf('.');
        if (firstDot == -1) {
            firstDot = getters.length();
        }
        String first = getters.substring(0, firstDot);
        String rest = getters.substring(Math.min(firstDot + 1, getters.length()));

        try {
            Method getter = null;
            if (target != null) {
                getter = Statement.getMethod(target.getClass(),
                                      &quot;get&quot; + NameGenerator.capitalize(first),
                                      new Class&lt;?&gt;[]{});
                if (getter == null) {
                    getter = Statement.getMethod(target.getClass(),
                                   &quot;is&quot; + NameGenerator.capitalize(first),
                                   new Class&lt;?&gt;[]{});
                }
                if (getter == null) {
                    getter = Statement.getMethod(target.getClass(), first, new Class&lt;?&gt;[]{});
                }
            }
            if (getter == null) {
                throw new RuntimeException(&quot;No method called: &quot; + first +
                                           &quot; defined on &quot; + target);
            }
            Object newTarget = MethodUtil.invoke(getter, target, new Object[]{});
            return applyGetters(newTarget, rest);
        }
        catch (Exception e) {
            throw new RuntimeException(&quot;Failed to call method: &quot; + first +
                                       &quot; on &quot; + target, e);
        }
    }

    /**
     * Extract the appropriate property value from the event and
     * pass it to the action associated with
     * this &lt;code&gt;EventHandler&lt;/code&gt;.
     *
     * @param proxy the proxy object
     * @param method the method in the listener interface
     * @return the result of applying the action to the target
     *
     * @see EventHandler
     */
    public Object invoke(final Object proxy, final Method method, final Object[] arguments) {
        AccessControlContext acc = this.acc;
        if ((acc == null) &amp;&amp; (System.getSecurityManager() != null)) {
            throw new SecurityException(&quot;AccessControlContext is not set&quot;);
        }
        return AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
            public Object run() {
                return invokeInternal(proxy, method, arguments);
            }
        }, acc);
    }

    private Object invokeInternal(Object proxy, Method method, Object[] arguments) {
        String methodName = method.getName();
        if (method.getDeclaringClass() == Object.class)  {
            // Handle the Object public methods.
            if (methodName.equals(&quot;hashCode&quot;))  {
                return new Integer(System.identityHashCode(proxy));
            } else if (methodName.equals(&quot;equals&quot;)) {
                return (proxy == arguments[0] ? Boolean.TRUE : Boolean.FALSE);
            } else if (methodName.equals(&quot;toString&quot;)) {
                return proxy.getClass().getName() + '@' + Integer.toHexString(proxy.hashCode());
            }
        }

        if (listenerMethodName == null || listenerMethodName.equals(methodName)) {
            Class[] argTypes = null;
            Object[] newArgs = null;

            if (eventPropertyName == null) {     // Nullary method.
                newArgs = new Object[]{};
                argTypes = new Class&lt;?&gt;[]{};
            }
            else {
                Object input = applyGetters(arguments[0], getEventPropertyName());
                newArgs = new Object[]{input};
                argTypes = new Class&lt;?&gt;[]{input == null ? null :
                                       input.getClass()};
            }
            try {
                int lastDot = action.lastIndexOf('.');
                if (lastDot != -1) {
                    target = applyGetters(target, action.substring(0, lastDot));
                    action = action.substring(lastDot + 1);
                }
                Method targetMethod = Statement.getMethod(
                             target.getClass(), action, argTypes);
                if (targetMethod == null) {
                    targetMethod = Statement.getMethod(target.getClass(),
                             &quot;set&quot; + NameGenerator.capitalize(action), argTypes);
                }
                if (targetMethod == null) {
                    String argTypeString = (argTypes.length == 0)
                        ? &quot; with no arguments&quot;
                        : &quot; with argument &quot; + argTypes[0];
                    throw new RuntimeException(
                        &quot;No method called &quot; + action + &quot; on &quot; +
                        target.getClass() + argTypeString);
                }
                return MethodUtil.invoke(targetMethod, target, newArgs);
            }
            catch (IllegalAccessException ex) {
                throw new RuntimeException(ex);
            }
            catch (InvocationTargetException ex) {
                Throwable th = ex.getTargetException();
                throw (th instanceof RuntimeException)
                        ? (RuntimeException) th
                        : new RuntimeException(th);
            }
        }
        return null;
    }

    /**
     * Creates an implementation of &lt;code&gt;listenerInterface&lt;/code&gt; in which
     * &lt;em&gt;all&lt;/em&gt; of the methods in the listener interface apply
     * the handler's &lt;code&gt;action&lt;/code&gt; to the &lt;code&gt;target&lt;/code&gt;. This
     * method is implemented by calling the other, more general,
     * implementation of the &lt;code&gt;create&lt;/code&gt; method with both
     * the &lt;code&gt;eventPropertyName&lt;/code&gt; and the &lt;code&gt;listenerMethodName&lt;/code&gt;
     * taking the value &lt;code&gt;null&lt;/code&gt;. Refer to
     * {@link java.beans.EventHandler#create(Class, Object, String, String)
     * the general version of create} for a complete description of
     * the &lt;code&gt;action&lt;/code&gt; parameter.
     * &lt;p&gt;
     * To create an &lt;code&gt;ActionListener&lt;/code&gt; that shows a
     * &lt;code&gt;JDialog&lt;/code&gt; with &lt;code&gt;dialog.show()&lt;/code&gt;,
     * one can write:
     *
     *&lt;blockquote&gt;
     *&lt;pre&gt;
     *EventHandler.create(ActionListener.class, dialog, &quot;show&quot;)
     *&lt;/pre&gt;
     *&lt;/blockquote&gt;
     *
     * @param &lt;T&gt; the type to create
     * @param listenerInterface the listener interface to create a proxy for
     * @param target the object that will perform the action
     * @param action the name of a (possibly qualified) property or method on
     *        the target
     * @return an object that implements &lt;code&gt;listenerInterface&lt;/code&gt;
     *
     * @throws NullPointerException if &lt;code&gt;listenerInterface&lt;/code&gt; is null
     * @throws NullPointerException if &lt;code&gt;target&lt;/code&gt; is null
     * @throws NullPointerException if &lt;code&gt;action&lt;/code&gt; is null
     *
     * @see #create(Class, Object, String, String)
     */
    public static &lt;T&gt; T create(Class&lt;T&gt; listenerInterface,
                               Object target, String action)
    {
        return create(listenerInterface, target, action, null, null);
    }

    /**
    /**
     * Creates an implementation of &lt;code&gt;listenerInterface&lt;/code&gt; in which
     * &lt;em&gt;all&lt;/em&gt; of the methods pass the value of the event
     * expression, &lt;code&gt;eventPropertyName&lt;/code&gt;, to the final method in the
     * statement, &lt;code&gt;action&lt;/code&gt;, which is applied to the &lt;code&gt;target&lt;/code&gt;.
     * This method is implemented by calling the
     * more general, implementation of the &lt;code&gt;create&lt;/code&gt; method with
     * the &lt;code&gt;listenerMethodName&lt;/code&gt; taking the value &lt;code&gt;null&lt;/code&gt;.
     * Refer to
     * {@link java.beans.EventHandler#create(Class, Object, String, String)
     * the general version of create} for a complete description of
     * the &lt;code&gt;action&lt;/code&gt; and &lt;code&gt;eventPropertyName&lt;/code&gt; parameters.
     * &lt;p&gt;
     * To create an &lt;code&gt;ActionListener&lt;/code&gt; that sets the
     * the text of a &lt;code&gt;JLabel&lt;/code&gt; to the text value of
     * the &lt;code&gt;JTextField&lt;/code&gt; source of the incoming event,
     * you can use the following code:
     *
     *&lt;blockquote&gt;
     *&lt;pre&gt;
     *EventHandler.create(ActionListener.class, label, &quot;text&quot;, &quot;source.text&quot;);
     *&lt;/pre&gt;
     *&lt;/blockquote&gt;
     *
     * This is equivalent to the following code:
     *&lt;blockquote&gt;
     *&lt;pre&gt;
//Equivalent code using an inner class instead of EventHandler.
     *new ActionListener() {
     *    public void actionPerformed(ActionEvent event) {
     *        label.setText(((JTextField)(event.getSource())).getText());
     *     }
     *};
     *&lt;/pre&gt;
     *&lt;/blockquote&gt;
     *
     * @param &lt;T&gt; the type to create
     * @param listenerInterface the listener interface to create a proxy for
     * @param target the object that will perform the action
     * @param action the name of a (possibly qualified) property or method on
     *        the target
     * @param eventPropertyName the (possibly qualified) name of a readable property of the incoming event
     *
     * @return an object that implements &lt;code&gt;listenerInterface&lt;/code&gt;
     *
     * @throws NullPointerException if &lt;code&gt;listenerInterface&lt;/code&gt; is null
     * @throws NullPointerException if &lt;code&gt;target&lt;/code&gt; is null
     * @throws NullPointerException if &lt;code&gt;action&lt;/code&gt; is null
     *
     * @see #create(Class, Object, String, String, String)
     */
    public static &lt;T&gt; T create(Class&lt;T&gt; listenerInterface,
                               Object target, String action,
                               String eventPropertyName)
    {
        return create(listenerInterface, target, action, eventPropertyName, null);
    }

    /**
     * Creates an implementation of &lt;code&gt;listenerInterface&lt;/code&gt; in which
     * the method named &lt;code&gt;listenerMethodName&lt;/code&gt;
     * passes the value of the event expression, &lt;code&gt;eventPropertyName&lt;/code&gt;,
     * to the final method in the statement, &lt;code&gt;action&lt;/code&gt;, which
     * is applied to the &lt;code&gt;target&lt;/code&gt;. All of the other listener
     * methods do nothing.
     * &lt;p&gt;
     * The &lt;code&gt;eventPropertyName&lt;/code&gt; string is used to extract a value
     * from the incoming event object that is passed to the target
     * method.  The common case is the target method takes no arguments, in
     * which case a value of null should be used for the
     * &lt;code&gt;eventPropertyName&lt;/code&gt;.  Alternatively if you want
     * the incoming event object passed directly to the target method use
     * the empty string.
     * The format of the &lt;code&gt;eventPropertyName&lt;/code&gt; string is a sequence of
     * methods or properties where each method or
     * property is applied to the value returned by the preceding method
     * starting from the incoming event object.
     * The syntax is: &lt;code&gt;propertyName{.propertyName}*&lt;/code&gt;
     * where &lt;code&gt;propertyName&lt;/code&gt; matches a method or
     * property.  For example, to extract the &lt;code&gt;point&lt;/code&gt;
     * property from a &lt;code&gt;MouseEvent&lt;/code&gt;, you could use either
     * &lt;code&gt;&quot;point&quot;&lt;/code&gt; or &lt;code&gt;&quot;getPoint&quot;&lt;/code&gt; as the
     * &lt;code&gt;eventPropertyName&lt;/code&gt;.  To extract the &quot;text&quot; property from
     * a &lt;code&gt;MouseEvent&lt;/code&gt; with a &lt;code&gt;JLabel&lt;/code&gt; source use any
     * of the following as &lt;code&gt;eventPropertyName&lt;/code&gt;:
     * &lt;code&gt;&quot;source.text&quot;&lt;/code&gt;,
     * &lt;code&gt;&quot;getSource.text&quot;&lt;/code&gt; &lt;code&gt;&quot;getSource.getText&quot;&lt;/code&gt; or
     * &lt;code&gt;&quot;source.getText&quot;&lt;/code&gt;.  If a method can not be found, or an
     * exception is generated as part of invoking a method a
     * &lt;code&gt;RuntimeException&lt;/code&gt; will be thrown at dispatch time.  For
     * example, if the incoming event object is null, and
     * &lt;code&gt;eventPropertyName&lt;/code&gt; is non-null and not empty, a
     * &lt;code&gt;RuntimeException&lt;/code&gt; will be thrown.
     * &lt;p&gt;
     * The &lt;code&gt;action&lt;/code&gt; argument is of the same format as the
     * &lt;code&gt;eventPropertyName&lt;/code&gt; argument where the last property name
     * identifies either a method name or writable property.
     * &lt;p&gt;
     * If the &lt;code&gt;listenerMethodName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * &lt;em&gt;all&lt;/em&gt; methods in the interface trigger the &lt;code&gt;action&lt;/code&gt; to be
     * executed on the &lt;code&gt;target&lt;/code&gt;.
     * &lt;p&gt;
     * For example, to create a &lt;code&gt;MouseListener&lt;/code&gt; that sets the target
     * object's &lt;code&gt;origin&lt;/code&gt; property to the incoming &lt;code&gt;MouseEvent&lt;/code&gt;'s
     * location (that's the value of &lt;code&gt;mouseEvent.getPoint()&lt;/code&gt;) each
     * time a mouse button is pressed, one would write:
     *&lt;blockquote&gt;
     *&lt;pre&gt;
     *EventHandler.create(MouseListener.class, target, &quot;origin&quot;, &quot;point&quot;, &quot;mousePressed&quot;);
     *&lt;/pre&gt;
     *&lt;/blockquote&gt;
     *
     * This is comparable to writing a &lt;code&gt;MouseListener&lt;/code&gt; in which all
     * of the methods except &lt;code&gt;mousePressed&lt;/code&gt; are no-ops:
     *
     *&lt;blockquote&gt;
     *&lt;pre&gt;
//Equivalent code using an inner class instead of EventHandler.
     *new MouseAdapter() {
     *    public void mousePressed(MouseEvent e) {
     *        target.setOrigin(e.getPoint());
     *    }
     *};
     * &lt;/pre&gt;
     *&lt;/blockquote&gt;
     *
     * @param &lt;T&gt; the type to create
     * @param listenerInterface the listener interface to create a proxy for
     * @param target the object that will perform the action
     * @param action the name of a (possibly qualified) property or method on
     *        the target
     * @param eventPropertyName the (possibly qualified) name of a readable property of the incoming event
     * @param listenerMethodName the name of the method in the listener interface that should trigger the action
     *
     * @return an object that implements &lt;code&gt;listenerInterface&lt;/code&gt;
     *
     * @throws NullPointerException if &lt;code&gt;listenerInterface&lt;/code&gt; is null
     * @throws NullPointerException if &lt;code&gt;target&lt;/code&gt; is null
     * @throws NullPointerException if &lt;code&gt;action&lt;/code&gt; is null
     *
     * @see EventHandler
     */
    public static &lt;T&gt; T create(Class&lt;T&gt; listenerInterface,
                               Object target, String action,
                               String eventPropertyName,
                               String listenerMethodName)
    {
        // Create this first to verify target/action are non-null
        final EventHandler handler = new EventHandler(target, action,
                                                     eventPropertyName,
                                                     listenerMethodName);
        if (listenerInterface == null) {
            throw new NullPointerException(
                          &quot;listenerInterface must be non-null&quot;);
        }
        final ClassLoader loader = getClassLoader(listenerInterface);
        final Class&lt;?&gt;[] interfaces = {listenerInterface};
        return AccessController.doPrivileged(new PrivilegedAction&lt;T&gt;() {
            @SuppressWarnings(&quot;unchecked&quot;)
            public T run() {
                return (T) Proxy.newProxyInstance(loader, interfaces, handler);
            }
        });
    }

    private static ClassLoader getClassLoader(Class&lt;?&gt; type) {
        ReflectUtil.checkPackageAccess(type);
        ClassLoader loader = type.getClassLoader();
        if (loader == null) {
            loader = Thread.currentThread().getContextClassLoader(); // avoid use of BCP
            if (loader == null) {
                loader = ClassLoader.getSystemClassLoader();
            }
        }
        return loader;
    }
}
</pre>
</body>
</html>
