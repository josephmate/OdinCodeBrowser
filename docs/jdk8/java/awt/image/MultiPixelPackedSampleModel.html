<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/* ****************************************************************
 ******************************************************************
 ******************************************************************
 *** COPYRIGHT (c) Eastman Kodak Company, 1997
 *** As  an unpublished  work pursuant to Title 17 of the United
 *** States Code.  All rights reserved.
 ******************************************************************
 ******************************************************************
 ******************************************************************/

package java.awt.image;

/**
 * The &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; class represents
 * one-banded images and can pack multiple one-sample
 * pixels into one data element.  Pixels are not allowed to span data elements.
 * The data type can be DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT,
 * or DataBuffer.TYPE_INT.  Each pixel must be a power of 2 number of bits
 * and a power of 2 number of pixels must fit exactly in one data element.
 * Pixel bit stride is equal to the number of bits per pixel.  Scanline
 * stride is in data elements and the last several data elements might be
 * padded with unused pixels.  Data bit offset is the offset in bits from
 * the beginning of the {@link DataBuffer} to the first pixel and must be
 * a multiple of pixel bit stride.
 * &lt;p&gt;
 * The following code illustrates extracting the bits for pixel
 * &lt;code&gt;x,&amp;nbsp;y&lt;/code&gt; from &lt;code&gt;DataBuffer&lt;/code&gt; &lt;code&gt;data&lt;/code&gt;
 * and storing the pixel data in data elements of type
 * &lt;code&gt;dataType&lt;/code&gt;:
 * &lt;pre&gt;{@code
 *      int dataElementSize = DataBuffer.getDataTypeSize(dataType);
 *      int bitnum = dataBitOffset + x*pixelBitStride;
 *      int element = data.getElem(y*scanlineStride + bitnum/dataElementSize);
 *      int shift = dataElementSize - (bitnum &amp; (dataElementSize-1))
 *                  - pixelBitStride;
 *      int pixel = (element &gt;&gt; shift) &amp; ((1 &lt;&lt; pixelBitStride) - 1);
 * }&lt;/pre&gt;
 */

public class MultiPixelPackedSampleModel extends SampleModel
{
    /** The number of bits from one pixel to the next. */
    int pixelBitStride;

    /** Bitmask that extracts the rightmost pixel of a data element. */
    int bitMask;

    /**
      * The number of pixels that fit in a data element.  Also used
      * as the number of bits per pixel.
      */
    int pixelsPerDataElement;

    /** The size of a data element in bits. */
    int dataElementSize;

    /** The bit offset into the data array where the first pixel begins.
     */
    int dataBitOffset;

    /** ScanlineStride of the data buffer described in data array elements. */
    int scanlineStride;

    /**
     * Constructs a &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; with the
     * specified data type, width, height and number of bits per pixel.
     * @param dataType  the data type for storing samples
     * @param w         the width, in pixels, of the region of
     *                  image data described
     * @param h         the height, in pixels, of the region of
     *                  image data described
     * @param numberOfBits the number of bits per pixel
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         either &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     *         &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;, or
     *         &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;
     */
    public MultiPixelPackedSampleModel(int dataType,
                                       int w,
                                       int h,
                                       int numberOfBits) {
        this(dataType,w,h,
             numberOfBits,
            (w*numberOfBits+DataBuffer.getDataTypeSize(dataType)-1)/
                DataBuffer.getDataTypeSize(dataType),
             0);
        if (dataType != DataBuffer.TYPE_BYTE &amp;&amp;
            dataType != DataBuffer.TYPE_USHORT &amp;&amp;
            dataType != DataBuffer.TYPE_INT) {
            throw new IllegalArgumentException(&quot;Unsupported data type &quot;+
                                               dataType);
        }
    }

    /**
     * Constructs a &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; with
     * specified data type, width, height, number of bits per pixel,
     * scanline stride and data bit offset.
     * @param dataType  the data type for storing samples
     * @param w         the width, in pixels, of the region of
     *                  image data described
     * @param h         the height, in pixels, of the region of
     *                  image data described
     * @param numberOfBits the number of bits per pixel
     * @param scanlineStride the line stride of the image data
     * @param dataBitOffset the data bit offset for the region of image
     *                  data described
     * @exception RasterFormatException if the number of bits per pixel
     *                  is not a power of 2 or if a power of 2 number of
     *                  pixels do not fit in one data element.
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt; is not greater than 0
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         either &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     *         &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;, or
     *         &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;
     */
    public MultiPixelPackedSampleModel(int dataType, int w, int h,
                                       int numberOfBits,
                                       int scanlineStride,
                                       int dataBitOffset) {
        super(dataType, w, h, 1);
        if (dataType != DataBuffer.TYPE_BYTE &amp;&amp;
            dataType != DataBuffer.TYPE_USHORT &amp;&amp;
            dataType != DataBuffer.TYPE_INT) {
            throw new IllegalArgumentException(&quot;Unsupported data type &quot;+
                                               dataType);
        }
        this.dataType = dataType;
        this.pixelBitStride = numberOfBits;
        this.scanlineStride = scanlineStride;
        this.dataBitOffset = dataBitOffset;
        this.dataElementSize = DataBuffer.getDataTypeSize(dataType);
        this.pixelsPerDataElement = dataElementSize/numberOfBits;
        if (pixelsPerDataElement*numberOfBits != dataElementSize) {
           throw new RasterFormatException(&quot;MultiPixelPackedSampleModel &quot; +
                                             &quot;does not allow pixels to &quot; +
                                             &quot;span data element boundaries&quot;);
        }
        this.bitMask = (1 &lt;&lt; numberOfBits) - 1;
    }


    /**
     * Creates a new &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; with the
     * specified width and height.  The new
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; has the
     * same storage data type and number of bits per pixel as this
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     * @param w the specified width
     * @param h the specified height
     * @return a {@link SampleModel} with the specified width and height
     * and with the same storage data type and number of bits per pixel
     * as this &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt; is not greater than 0
     */
    public SampleModel createCompatibleSampleModel(int w, int h) {
      SampleModel sampleModel =
            new MultiPixelPackedSampleModel(dataType, w, h, pixelBitStride);
      return sampleModel;
    }

    /**
     * Creates a &lt;code&gt;DataBuffer&lt;/code&gt; that corresponds to this
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.  The
     * &lt;code&gt;DataBuffer&lt;/code&gt; object's data type and size
     * is consistent with this &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     * The &lt;code&gt;DataBuffer&lt;/code&gt; has a single bank.
     * @return a &lt;code&gt;DataBuffer&lt;/code&gt; with the same data type and
     * size as this &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     */
    public DataBuffer createDataBuffer() {
        DataBuffer dataBuffer = null;

        int size = (int)scanlineStride*height;
        switch (dataType) {
        case DataBuffer.TYPE_BYTE:
            dataBuffer = new DataBufferByte(size+(dataBitOffset+7)/8);
            break;
        case DataBuffer.TYPE_USHORT:
            dataBuffer = new DataBufferUShort(size+(dataBitOffset+15)/16);
            break;
        case DataBuffer.TYPE_INT:
            dataBuffer = new DataBufferInt(size+(dataBitOffset+31)/32);
            break;
        }
        return dataBuffer;
    }

    /**
     * Returns the number of data elements needed to transfer one pixel
     * via the {@link #getDataElements} and {@link #setDataElements}
     * methods.  For a &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;, this is
     * one.
     * @return the number of data elements.
     */
    public int getNumDataElements() {
        return 1;
    }

    /**
     * Returns the number of bits per sample for all bands.
     * @return the number of bits per sample.
     */
    public int[] getSampleSize() {
        int sampleSize[] = {pixelBitStride};
        return sampleSize;
    }

    /**
     * Returns the number of bits per sample for the specified band.
     * @param band the specified band
     * @return the number of bits per sample for the specified band.
     */
    public int getSampleSize(int band) {
        return pixelBitStride;
    }

    /**
     * Returns the offset of pixel (x,&amp;nbsp;y) in data array elements.
     * @param x the X coordinate of the specified pixel
     * @param y the Y coordinate of the specified pixel
     * @return the offset of the specified pixel.
     */
    public int getOffset(int x, int y) {
        int offset = y * scanlineStride;
        offset +=  (x*pixelBitStride+dataBitOffset)/dataElementSize;
        return offset;
    }

    /**
     *  Returns the offset, in bits, into the data element in which it is
     *  stored for the &lt;code&gt;x&lt;/code&gt;th pixel of a scanline.
     *  This offset is the same for all scanlines.
     *  @param x the specified pixel
     *  @return the bit offset of the specified pixel.
     */
    public int getBitOffset(int x){
       return  (x*pixelBitStride+dataBitOffset)%dataElementSize;
    }

    /**
     * Returns the scanline stride.
     * @return the scanline stride of this
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     */
    public int getScanlineStride() {
        return scanlineStride;
    }

    /**
     * Returns the pixel bit stride in bits.  This value is the same as
     * the number of bits per pixel.
     * @return the &lt;code&gt;pixelBitStride&lt;/code&gt; of this
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     */
    public int getPixelBitStride() {
        return pixelBitStride;
    }

    /**
     * Returns the data bit offset in bits.
     * @return the &lt;code&gt;dataBitOffset&lt;/code&gt; of this
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     */
    public int getDataBitOffset() {
        return dataBitOffset;
    }

    /**
     *  Returns the TransferType used to transfer pixels by way of the
     *  &lt;code&gt;getDataElements&lt;/code&gt; and &lt;code&gt;setDataElements&lt;/code&gt;
     *  methods. The TransferType might or might not be the same as the
     *  storage DataType.  The TransferType is one of
     *  DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT,
     *  or DataBuffer.TYPE_INT.
     *  @return the transfertype.
     */
    public int getTransferType() {
        if (pixelBitStride &gt; 16)
            return DataBuffer.TYPE_INT;
        else if (pixelBitStride &gt; 8)
            return DataBuffer.TYPE_USHORT;
        else
            return DataBuffer.TYPE_BYTE;
    }

    /**
     * Creates a new &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; with a
     * subset of the bands of this
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.  Since a
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; only has one band, the
     * bands argument must have a length of one and indicate the zeroth
     * band.
     * @param bands the specified bands
     * @return a new &lt;code&gt;SampleModel&lt;/code&gt; with a subset of bands of
     * this &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     * @exception RasterFormatException if the number of bands requested
     * is not one.
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt; is not greater than 0
     */
    public SampleModel createSubsetSampleModel(int bands[]) {
        if (bands != null) {
           if (bands.length != 1)
            throw new RasterFormatException(&quot;MultiPixelPackedSampleModel has &quot;
                                            + &quot;only one band.&quot;);
        }
        SampleModel sm = createCompatibleSampleModel(width, height);
        return sm;
    }

    /**
     * Returns as &lt;code&gt;int&lt;/code&gt; the sample in a specified band for the
     * pixel located at (x,&amp;nbsp;y).  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if the
     * coordinates are not in bounds.
     * @param x         the X coordinate of the specified pixel
     * @param y         the Y coordinate of the specified pixel
     * @param b         the band to return, which is assumed to be 0
     * @param data      the &lt;code&gt;DataBuffer&lt;/code&gt; containing the image
     *                  data
     * @return the specified band containing the sample of the specified
     * pixel.
     * @exception ArrayIndexOutOfBoundsException if the specified
     *          coordinates are not in bounds.
     * @see #setSample(int, int, int, int, DataBuffer)
     */
    public int getSample(int x, int y, int b, DataBuffer data) {
        // 'b' must be 0
        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height) ||
            (b != 0)) {
            throw new ArrayIndexOutOfBoundsException
                (&quot;Coordinate out of bounds!&quot;);
        }
        int bitnum = dataBitOffset + x*pixelBitStride;
        int element = data.getElem(y*scanlineStride + bitnum/dataElementSize);
        int shift = dataElementSize - (bitnum &amp; (dataElementSize-1))
                    - pixelBitStride;
        return (element &gt;&gt; shift) &amp; bitMask;
    }

    /**
     * Sets a sample in the specified band for the pixel located at
     * (x,&amp;nbsp;y) in the &lt;code&gt;DataBuffer&lt;/code&gt; using an
     * &lt;code&gt;int&lt;/code&gt; for input.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if the
     * coordinates are not in bounds.
     * @param x the X coordinate of the specified pixel
     * @param y the Y coordinate of the specified pixel
     * @param b the band to return, which is assumed to be 0
     * @param s the input sample as an &lt;code&gt;int&lt;/code&gt;
     * @param data the &lt;code&gt;DataBuffer&lt;/code&gt; where image data is stored
     * @exception ArrayIndexOutOfBoundsException if the coordinates are
     * not in bounds.
     * @see #getSample(int, int, int, DataBuffer)
     */
    public void setSample(int x, int y, int b, int s,
                          DataBuffer data) {
        // 'b' must be 0
        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height) ||
            (b != 0)) {
            throw new ArrayIndexOutOfBoundsException
                (&quot;Coordinate out of bounds!&quot;);
        }
        int bitnum = dataBitOffset + x * pixelBitStride;
        int index = y * scanlineStride + (bitnum / dataElementSize);
        int shift = dataElementSize - (bitnum &amp; (dataElementSize-1))
                    - pixelBitStride;
        int element = data.getElem(index);
        element &amp;= ~(bitMask &lt;&lt; shift);
        element |= (s &amp; bitMask) &lt;&lt; shift;
        data.setElem(index,element);
    }

    /**
     * Returns data for a single pixel in a primitive array of type
     * TransferType.  For a &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;,
     * the array has one element, and the type is the smallest of
     * DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, or DataBuffer.TYPE_INT
     * that can hold a single pixel.  Generally, &lt;code&gt;obj&lt;/code&gt;
     * should be passed in as &lt;code&gt;null&lt;/code&gt;, so that the
     * &lt;code&gt;Object&lt;/code&gt; is created automatically and is the
     * correct primitive data type.
     * &lt;p&gt;
     * The following code illustrates transferring data for one pixel from
     * &lt;code&gt;DataBuffer&lt;/code&gt; &lt;code&gt;db1&lt;/code&gt;, whose storage layout is
     * described by &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;
     * &lt;code&gt;mppsm1&lt;/code&gt;, to &lt;code&gt;DataBuffer&lt;/code&gt; &lt;code&gt;db2&lt;/code&gt;,
     * whose storage layout is described by
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; &lt;code&gt;mppsm2&lt;/code&gt;.
     * The transfer is generally more efficient than using
     * &lt;code&gt;getPixel&lt;/code&gt; or &lt;code&gt;setPixel&lt;/code&gt;.
     * &lt;pre&gt;
     *       MultiPixelPackedSampleModel mppsm1, mppsm2;
     *       DataBufferInt db1, db2;
     *       mppsm2.setDataElements(x, y, mppsm1.getDataElements(x, y, null,
     *                              db1), db2);
     * &lt;/pre&gt;
     * Using &lt;code&gt;getDataElements&lt;/code&gt; or &lt;code&gt;setDataElements&lt;/code&gt;
     * to transfer between two &lt;code&gt;DataBuffer/SampleModel&lt;/code&gt; pairs
     * is legitimate if the &lt;code&gt;SampleModels&lt;/code&gt; have the same number
     * of bands, corresponding bands have the same number of
     * bits per sample, and the TransferTypes are the same.
     * &lt;p&gt;
     * If &lt;code&gt;obj&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should be a
     * primitive array of type TransferType.  Otherwise, a
     * &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if the
     * coordinates are not in bounds, or if &lt;code&gt;obj&lt;/code&gt; is not
     * &lt;code&gt;null&lt;/code&gt; and is not large enough to hold the pixel data.
     * @param x the X coordinate of the specified pixel
     * @param y the Y coordinate of the specified pixel
     * @param obj a primitive array in which to return the pixel data or
     *          &lt;code&gt;null&lt;/code&gt;.
     * @param data the &lt;code&gt;DataBuffer&lt;/code&gt; containing the image data.
     * @return an &lt;code&gt;Object&lt;/code&gt; containing data for the specified
     *  pixel.
     * @exception ClassCastException if &lt;code&gt;obj&lt;/code&gt; is not a
     *  primitive array of type TransferType or is not &lt;code&gt;null&lt;/code&gt;
     * @exception ArrayIndexOutOfBoundsException if the coordinates are
     * not in bounds, or if &lt;code&gt;obj&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; or
     * not large enough to hold the pixel data
     * @see #setDataElements(int, int, Object, DataBuffer)
     */
    public Object getDataElements(int x, int y, Object obj, DataBuffer data) {
        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {
            throw new ArrayIndexOutOfBoundsException
                (&quot;Coordinate out of bounds!&quot;);
        }

        int type = getTransferType();
        int bitnum = dataBitOffset + x*pixelBitStride;
        int shift = dataElementSize - (bitnum &amp; (dataElementSize-1))
                    - pixelBitStride;
        int element = 0;

        switch(type) {

        case DataBuffer.TYPE_BYTE:

            byte[] bdata;

            if (obj == null)
                bdata = new byte[1];
            else
                bdata = (byte[])obj;

            element = data.getElem(y*scanlineStride +
                                    bitnum/dataElementSize);
            bdata[0] = (byte)((element &gt;&gt; shift) &amp; bitMask);

            obj = (Object)bdata;
            break;

        case DataBuffer.TYPE_USHORT:

            short[] sdata;

            if (obj == null)
                sdata = new short[1];
            else
                sdata = (short[])obj;

            element = data.getElem(y*scanlineStride +
                                   bitnum/dataElementSize);
            sdata[0] = (short)((element &gt;&gt; shift) &amp; bitMask);

            obj = (Object)sdata;
            break;

        case DataBuffer.TYPE_INT:

            int[] idata;

            if (obj == null)
                idata = new int[1];
            else
                idata = (int[])obj;

            element = data.getElem(y*scanlineStride +
                                   bitnum/dataElementSize);
            idata[0] = (element &gt;&gt; shift) &amp; bitMask;

            obj = (Object)idata;
            break;
        }

        return obj;
    }

    /**
     * Returns the specified single band pixel in the first element
     * of an &lt;code&gt;int&lt;/code&gt; array.
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if the
     * coordinates are not in bounds.
     * @param x the X coordinate of the specified pixel
     * @param y the Y coordinate of the specified pixel
     * @param iArray the array containing the pixel to be returned or
     *  &lt;code&gt;null&lt;/code&gt;
     * @param data the &lt;code&gt;DataBuffer&lt;/code&gt; where image data is stored
     * @return an array containing the specified pixel.
     * @exception ArrayIndexOutOfBoundsException if the coordinates
     *  are not in bounds
     * @see #setPixel(int, int, int[], DataBuffer)
     */
    public int[] getPixel(int x, int y, int iArray[], DataBuffer data) {
        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {
            throw new ArrayIndexOutOfBoundsException
                (&quot;Coordinate out of bounds!&quot;);
        }
        int pixels[];
        if (iArray != null) {
           pixels = iArray;
        } else {
           pixels = new int [numBands];
        }
        int bitnum = dataBitOffset + x*pixelBitStride;
        int element = data.getElem(y*scanlineStride + bitnum/dataElementSize);
        int shift = dataElementSize - (bitnum &amp; (dataElementSize-1))
                    - pixelBitStride;
        pixels[0] = (element &gt;&gt; shift) &amp; bitMask;
        return pixels;
    }

    /**
     * Sets the data for a single pixel in the specified
     * &lt;code&gt;DataBuffer&lt;/code&gt; from a primitive array of type
     * TransferType.  For a &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;,
     * only the first element of the array holds valid data,
     * and the type must be the smallest of
     * DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, or DataBuffer.TYPE_INT
     * that can hold a single pixel.
     * &lt;p&gt;
     * The following code illustrates transferring data for one pixel from
     * &lt;code&gt;DataBuffer&lt;/code&gt; &lt;code&gt;db1&lt;/code&gt;, whose storage layout is
     * described by &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;
     * &lt;code&gt;mppsm1&lt;/code&gt;, to &lt;code&gt;DataBuffer&lt;/code&gt; &lt;code&gt;db2&lt;/code&gt;,
     * whose storage layout is described by
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; &lt;code&gt;mppsm2&lt;/code&gt;.
     * The transfer is generally more efficient than using
     * &lt;code&gt;getPixel&lt;/code&gt; or &lt;code&gt;setPixel&lt;/code&gt;.
     * &lt;pre&gt;
     *       MultiPixelPackedSampleModel mppsm1, mppsm2;
     *       DataBufferInt db1, db2;
     *       mppsm2.setDataElements(x, y, mppsm1.getDataElements(x, y, null,
     *                              db1), db2);
     * &lt;/pre&gt;
     * Using &lt;code&gt;getDataElements&lt;/code&gt; or &lt;code&gt;setDataElements&lt;/code&gt; to
     * transfer between two &lt;code&gt;DataBuffer/SampleModel&lt;/code&gt; pairs is
     * legitimate if the &lt;code&gt;SampleModel&lt;/code&gt; objects have
     * the same number of bands, corresponding bands have the same number of
     * bits per sample, and the TransferTypes are the same.
     * &lt;p&gt;
     * &lt;code&gt;obj&lt;/code&gt; must be a primitive array of type TransferType.
     * Otherwise, a &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if the
     * coordinates are not in bounds, or if &lt;code&gt;obj&lt;/code&gt; is not large
     * enough to hold the pixel data.
     * @param x the X coordinate of the pixel location
     * @param y the Y coordinate of the pixel location
     * @param obj a primitive array containing pixel data
     * @param data the &lt;code&gt;DataBuffer&lt;/code&gt; containing the image data
     * @see #getDataElements(int, int, Object, DataBuffer)
     */
    public void setDataElements(int x, int y, Object obj, DataBuffer data) {
        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {
            throw new ArrayIndexOutOfBoundsException
                (&quot;Coordinate out of bounds!&quot;);
        }

        int type = getTransferType();
        int bitnum = dataBitOffset + x * pixelBitStride;
        int index = y * scanlineStride + (bitnum / dataElementSize);
        int shift = dataElementSize - (bitnum &amp; (dataElementSize-1))
                    - pixelBitStride;
        int element = data.getElem(index);
        element &amp;= ~(bitMask &lt;&lt; shift);

        switch(type) {

        case DataBuffer.TYPE_BYTE:

            byte[] barray = (byte[])obj;
            element |= ( ((int)(barray[0])&amp;0xff) &amp; bitMask) &lt;&lt; shift;
            data.setElem(index, element);
            break;

        case DataBuffer.TYPE_USHORT:

            short[] sarray = (short[])obj;
            element |= ( ((int)(sarray[0])&amp;0xffff) &amp; bitMask) &lt;&lt; shift;
            data.setElem(index, element);
            break;

        case DataBuffer.TYPE_INT:

            int[] iarray = (int[])obj;
            element |= (iarray[0] &amp; bitMask) &lt;&lt; shift;
            data.setElem(index, element);
            break;
        }
    }

    /**
     * Sets a pixel in the &lt;code&gt;DataBuffer&lt;/code&gt; using an
     * &lt;code&gt;int&lt;/code&gt; array for input.
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if
     * the coordinates are not in bounds.
     * @param x the X coordinate of the pixel location
     * @param y the Y coordinate of the pixel location
     * @param iArray the input pixel in an &lt;code&gt;int&lt;/code&gt; array
     * @param data the &lt;code&gt;DataBuffer&lt;/code&gt; containing the image data
     * @see #getPixel(int, int, int[], DataBuffer)
     */
    public void setPixel(int x, int y, int[] iArray, DataBuffer data) {
        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {
            throw new ArrayIndexOutOfBoundsException
                (&quot;Coordinate out of bounds!&quot;);
        }
        int bitnum = dataBitOffset + x * pixelBitStride;
        int index = y * scanlineStride + (bitnum / dataElementSize);
        int shift = dataElementSize - (bitnum &amp; (dataElementSize-1))
                    - pixelBitStride;
        int element = data.getElem(index);
        element &amp;= ~(bitMask &lt;&lt; shift);
        element |= (iArray[0] &amp; bitMask) &lt;&lt; shift;
        data.setElem(index,element);
    }

    public boolean equals(Object o) {
        if ((o == null) || !(o instanceof MultiPixelPackedSampleModel)) {
            return false;
        }

        MultiPixelPackedSampleModel that = (MultiPixelPackedSampleModel)o;
        return this.width == that.width &amp;&amp;
            this.height == that.height &amp;&amp;
            this.numBands == that.numBands &amp;&amp;
            this.dataType == that.dataType &amp;&amp;
            this.pixelBitStride == that.pixelBitStride &amp;&amp;
            this.bitMask == that.bitMask &amp;&amp;
            this.pixelsPerDataElement == that.pixelsPerDataElement &amp;&amp;
            this.dataElementSize == that.dataElementSize &amp;&amp;
            this.dataBitOffset == that.dataBitOffset &amp;&amp;
            this.scanlineStride == that.scanlineStride;
    }

    // If we implement equals() we must also implement hashCode
    public int hashCode() {
        int hash = 0;
        hash = width;
        hash &lt;&lt;= 8;
        hash ^= height;
        hash &lt;&lt;= 8;
        hash ^= numBands;
        hash &lt;&lt;= 8;
        hash ^= dataType;
        hash &lt;&lt;= 8;
        hash ^= pixelBitStride;
        hash &lt;&lt;= 8;
        hash ^= bitMask;
        hash &lt;&lt;= 8;
        hash ^= pixelsPerDataElement;
        hash &lt;&lt;= 8;
        hash ^= dataElementSize;
        hash &lt;&lt;= 8;
        hash ^= dataBitOffset;
        hash &lt;&lt;= 8;
        hash ^= scanlineStride;
        return hash;
    }
}
</pre>
</body>
</html>
