<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.Transparency;
import java.awt.color.ColorSpace;
import java.math.BigInteger;

/**
 * The &lt;code&gt;IndexColorModel&lt;/code&gt; class is a &lt;code&gt;ColorModel&lt;/code&gt;
 * class that works with pixel values consisting of a
 * single sample that is an index into a fixed colormap in the default
 * sRGB color space.  The colormap specifies red, green, blue, and
 * optional alpha components corresponding to each index.  All components
 * are represented in the colormap as 8-bit unsigned integral values.
 * Some constructors allow the caller to specify &quot;holes&quot; in the colormap
 * by indicating which colormap entries are valid and which represent
 * unusable colors via the bits set in a &lt;code&gt;BigInteger&lt;/code&gt; object.
 * This color model is similar to an X11 PseudoColor visual.
 * &lt;p&gt;
 * Some constructors provide a means to specify an alpha component
 * for each pixel in the colormap, while others either provide no
 * such means or, in some cases, a flag to indicate whether the
 * colormap data contains alpha values.  If no alpha is supplied to
 * the constructor, an opaque alpha component (alpha = 1.0) is
 * assumed for each entry.
 * An optional transparent pixel value can be supplied that indicates a
 * pixel to be made completely transparent, regardless of any alpha
 * component supplied or assumed for that pixel value.
 * Note that the color components in the colormap of an
 * &lt;code&gt;IndexColorModel&lt;/code&gt; objects are never pre-multiplied with
 * the alpha components.
 * &lt;p&gt;
 * &lt;a name=&quot;transparency&quot;&gt;
 * The transparency of an &lt;code&gt;IndexColorModel&lt;/code&gt; object is
 * determined by examining the alpha components of the colors in the
 * colormap and choosing the most specific value after considering
 * the optional alpha values and any transparent index specified.
 * The transparency value is &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;
 * only if all valid colors in
 * the colormap are opaque and there is no valid transparent pixel.
 * If all valid colors
 * in the colormap are either completely opaque (alpha = 1.0) or
 * completely transparent (alpha = 0.0), which typically occurs when
 * a valid transparent pixel is specified,
 * the value is &lt;code&gt;Transparency.BITMASK&lt;/code&gt;.
 * Otherwise, the value is &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt;, indicating
 * that some valid color has an alpha component that is
 * neither completely transparent nor completely opaque
 * (0.0 &amp;lt; alpha &amp;lt; 1.0).
 * &lt;/a&gt;
 *
 * &lt;p&gt;
 * If an &lt;code&gt;IndexColorModel&lt;/code&gt; object has
 * a transparency value of &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;,
 * then the &lt;code&gt;hasAlpha&lt;/code&gt;
 * and &lt;code&gt;getNumComponents&lt;/code&gt; methods
 * (both inherited from &lt;code&gt;ColorModel&lt;/code&gt;)
 * return false and 3, respectively.
 * For any other transparency value,
 * &lt;code&gt;hasAlpha&lt;/code&gt; returns true
 * and &lt;code&gt;getNumComponents&lt;/code&gt; returns 4.
 *
 * &lt;p&gt;
 * &lt;a name=&quot;index_values&quot;&gt;
 * The values used to index into the colormap are taken from the least
 * significant &lt;em&gt;n&lt;/em&gt; bits of pixel representations where
 * &lt;em&gt;n&lt;/em&gt; is based on the pixel size specified in the constructor.
 * For pixel sizes smaller than 8 bits, &lt;em&gt;n&lt;/em&gt; is rounded up to a
 * power of two (3 becomes 4 and 5,6,7 become 8).
 * For pixel sizes between 8 and 16 bits, &lt;em&gt;n&lt;/em&gt; is equal to the
 * pixel size.
 * Pixel sizes larger than 16 bits are not supported by this class.
 * Higher order bits beyond &lt;em&gt;n&lt;/em&gt; are ignored in pixel representations.
 * Index values greater than or equal to the map size, but less than
 * 2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;, are undefined and return 0 for all color and
 * alpha components.
 * &lt;/a&gt;
 * &lt;p&gt;
 * For those methods that use a primitive array pixel representation of
 * type &lt;code&gt;transferType&lt;/code&gt;, the array length is always one.
 * The transfer types supported are &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt; and
 * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;.  A single int pixel
 * representation is valid for all objects of this class, since it is
 * always possible to represent pixel values used with this class in a
 * single int.  Therefore, methods that use this representation do
 * not throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; due to an invalid
 * pixel value.
 * &lt;p&gt;
 * Many of the methods in this class are final.  The reason for
 * this is that the underlying native graphics code makes assumptions
 * about the layout and operation of this class and those assumptions
 * are reflected in the implementations of the methods here that are
 * marked final.  You can subclass this class for other reasons, but
 * you cannot override or modify the behaviour of those methods.
 *
 * @see ColorModel
 * @see ColorSpace
 * @see DataBuffer
 *
 */
public class IndexColorModel extends ColorModel {
    private int rgb[];
    private int map_size;
    private int pixel_mask;
    private int transparent_index = -1;
    private boolean allgrayopaque;
    private BigInteger validBits;

    private sun.awt.image.BufImgSurfaceData.ICMColorData colorData = null;

    private static int[] opaqueBits = {8, 8, 8};
    private static int[] alphaBits = {8, 8, 8, 8};

    static private native void initIDs();
    static {
        ColorModel.loadLibraries();
        initIDs();
    }
    /**
     * Constructs an &lt;code&gt;IndexColorModel&lt;/code&gt; from the specified
     * arrays of red, green, and blue components.  Pixels described
     * by this color model all have alpha components of 255
     * unnormalized (1.0&amp;nbsp;normalized), which means they
     * are fully opaque.  All of the arrays specifying the color
     * components must have at least the specified number of entries.
     * The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space.
     * Since there is no alpha information in any of the arguments
     * to this constructor, the transparency value is always
     * &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;.
     * The transfer type is the smallest of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;
     * or &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt; that can hold a single pixel.
     * @param bits      the number of bits each pixel occupies
     * @param size      the size of the color component arrays
     * @param r         the array of red color components
     * @param g         the array of green color components
     * @param b         the array of blue color components
     * @throws IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is less
     *         than 1 or greater than 16
     * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; is less
     *         than 1
     */
    public IndexColorModel(int bits, int size,
                           byte r[], byte g[], byte b[]) {
        super(bits, opaqueBits,
              ColorSpace.getInstance(ColorSpace.CS_sRGB),
              false, false, OPAQUE,
              ColorModel.getDefaultTransferType(bits));
        if (bits &lt; 1 || bits &gt; 16) {
            throw new IllegalArgumentException(&quot;Number of bits must be between&quot;
                                               +&quot; 1 and 16.&quot;);
        }
        setRGBs(size, r, g, b, null);
        calculatePixelMask();
    }

    /**
     * Constructs an &lt;code&gt;IndexColorModel&lt;/code&gt; from the given arrays
     * of red, green, and blue components.  Pixels described by this color
     * model all have alpha components of 255 unnormalized
     * (1.0&amp;nbsp;normalized), which means they are fully opaque, except
     * for the indicated pixel to be made transparent.  All of the arrays
     * specifying the color components must have at least the specified
     * number of entries.
     * The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space.
     * The transparency value may be &lt;code&gt;Transparency.OPAQUE&lt;/code&gt; or
     * &lt;code&gt;Transparency.BITMASK&lt;/code&gt; depending on the arguments, as
     * specified in the &lt;a href=&quot;#transparency&quot;&gt;class description&lt;/a&gt; above.
     * The transfer type is the smallest of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;
     * or &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt; that can hold a
     * single pixel.
     * @param bits      the number of bits each pixel occupies
     * @param size      the size of the color component arrays
     * @param r         the array of red color components
     * @param g         the array of green color components
     * @param b         the array of blue color components
     * @param trans     the index of the transparent pixel
     * @throws IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is less than
     *          1 or greater than 16
     * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; is less than
     *          1
     */
    public IndexColorModel(int bits, int size,
                           byte r[], byte g[], byte b[], int trans) {
        super(bits, opaqueBits,
              ColorSpace.getInstance(ColorSpace.CS_sRGB),
              false, false, OPAQUE,
              ColorModel.getDefaultTransferType(bits));
        if (bits &lt; 1 || bits &gt; 16) {
            throw new IllegalArgumentException(&quot;Number of bits must be between&quot;
                                               +&quot; 1 and 16.&quot;);
        }
        setRGBs(size, r, g, b, null);
        setTransparentPixel(trans);
        calculatePixelMask();
    }

    /**
     * Constructs an &lt;code&gt;IndexColorModel&lt;/code&gt; from the given
     * arrays of red, green, blue and alpha components.  All of the
     * arrays specifying the components must have at least the specified
     * number of entries.
     * The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space.
     * The transparency value may be any of &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;,
     * &lt;code&gt;Transparency.BITMASK&lt;/code&gt;,
     * or &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt;
     * depending on the arguments, as specified
     * in the &lt;a href=&quot;#transparency&quot;&gt;class description&lt;/a&gt; above.
     * The transfer type is the smallest of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;
     * or &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt; that can hold a single pixel.
     * @param bits      the number of bits each pixel occupies
     * @param size      the size of the color component arrays
     * @param r         the array of red color components
     * @param g         the array of green color components
     * @param b         the array of blue color components
     * @param a         the array of alpha value components
     * @throws IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is less
     *           than 1 or greater than 16
     * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; is less
     *           than 1
     */
    public IndexColorModel(int bits, int size,
                           byte r[], byte g[], byte b[], byte a[]) {
        super (bits, alphaBits,
               ColorSpace.getInstance(ColorSpace.CS_sRGB),
               true, false, TRANSLUCENT,
               ColorModel.getDefaultTransferType(bits));
        if (bits &lt; 1 || bits &gt; 16) {
            throw new IllegalArgumentException(&quot;Number of bits must be between&quot;
                                               +&quot; 1 and 16.&quot;);
        }
        setRGBs (size, r, g, b, a);
        calculatePixelMask();
    }

    /**
     * Constructs an &lt;code&gt;IndexColorModel&lt;/code&gt; from a single
     * array of interleaved red, green, blue and optional alpha
     * components.  The array must have enough values in it to
     * fill all of the needed component arrays of the specified
     * size.  The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space.
     * The transparency value may be any of &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;,
     * &lt;code&gt;Transparency.BITMASK&lt;/code&gt;,
     * or &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt;
     * depending on the arguments, as specified
     * in the &lt;a href=&quot;#transparency&quot;&gt;class description&lt;/a&gt; above.
     * The transfer type is the smallest of
     * &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt; or &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;
     * that can hold a single pixel.
     *
     * @param bits      the number of bits each pixel occupies
     * @param size      the size of the color component arrays
     * @param cmap      the array of color components
     * @param start     the starting offset of the first color component
     * @param hasalpha  indicates whether alpha values are contained in
     *                  the &lt;code&gt;cmap&lt;/code&gt; array
     * @throws IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is less
     *           than 1 or greater than 16
     * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; is less
     *           than 1
     */
    public IndexColorModel(int bits, int size, byte cmap[], int start,
                           boolean hasalpha) {
        this(bits, size, cmap, start, hasalpha, -1);
        if (bits &lt; 1 || bits &gt; 16) {
            throw new IllegalArgumentException(&quot;Number of bits must be between&quot;
                                               +&quot; 1 and 16.&quot;);
        }
    }

    /**
     * Constructs an &lt;code&gt;IndexColorModel&lt;/code&gt; from a single array of
     * interleaved red, green, blue and optional alpha components.  The
     * specified transparent index represents a pixel that is made
     * entirely transparent regardless of any alpha value specified
     * for it.  The array must have enough values in it to fill all
     * of the needed component arrays of the specified size.
     * The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space.
     * The transparency value may be any of &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;,
     * &lt;code&gt;Transparency.BITMASK&lt;/code&gt;,
     * or &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt;
     * depending on the arguments, as specified
     * in the &lt;a href=&quot;#transparency&quot;&gt;class description&lt;/a&gt; above.
     * The transfer type is the smallest of
     * &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt; or &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;
     * that can hold a single pixel.
     * @param bits      the number of bits each pixel occupies
     * @param size      the size of the color component arrays
     * @param cmap      the array of color components
     * @param start     the starting offset of the first color component
     * @param hasalpha  indicates whether alpha values are contained in
     *                  the &lt;code&gt;cmap&lt;/code&gt; array
     * @param trans     the index of the fully transparent pixel
     * @throws IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is less than
     *               1 or greater than 16
     * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; is less than
     *               1
     */
    public IndexColorModel(int bits, int size, byte cmap[], int start,
                           boolean hasalpha, int trans) {
        // REMIND: This assumes the ordering: RGB[A]
        super(bits, opaqueBits,
              ColorSpace.getInstance(ColorSpace.CS_sRGB),
              false, false, OPAQUE,
              ColorModel.getDefaultTransferType(bits));

        if (bits &lt; 1 || bits &gt; 16) {
            throw new IllegalArgumentException(&quot;Number of bits must be between&quot;
                                               +&quot; 1 and 16.&quot;);
        }
        if (size &lt; 1) {
            throw new IllegalArgumentException(&quot;Map size (&quot;+size+
                                               &quot;) must be &gt;= 1&quot;);
        }
        map_size = size;
        rgb = new int[calcRealMapSize(bits, size)];
        int j = start;
        int alpha = 0xff;
        boolean allgray = true;
        int transparency = OPAQUE;
        for (int i = 0; i &lt; size; i++) {
            int r = cmap[j++] &amp; 0xff;
            int g = cmap[j++] &amp; 0xff;
            int b = cmap[j++] &amp; 0xff;
            allgray = allgray &amp;&amp; (r == g) &amp;&amp; (g == b);
            if (hasalpha) {
                alpha = cmap[j++] &amp; 0xff;
                if (alpha != 0xff) {
                    if (alpha == 0x00) {
                        if (transparency == OPAQUE) {
                            transparency = BITMASK;
                        }
                        if (transparent_index &lt; 0) {
                            transparent_index = i;
                        }
                    } else {
                        transparency = TRANSLUCENT;
                    }
                    allgray = false;
                }
            }
            rgb[i] = (alpha &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
        }
        this.allgrayopaque = allgray;
        setTransparency(transparency);
        setTransparentPixel(trans);
        calculatePixelMask();
    }

    /**
     * Constructs an &lt;code&gt;IndexColorModel&lt;/code&gt; from an array of
     * ints where each int is comprised of red, green, blue, and
     * optional alpha components in the default RGB color model format.
     * The specified transparent index represents a pixel that is made
     * entirely transparent regardless of any alpha value specified
     * for it.  The array must have enough values in it to fill all
     * of the needed component arrays of the specified size.
     * The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space.
     * The transparency value may be any of &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;,
     * &lt;code&gt;Transparency.BITMASK&lt;/code&gt;,
     * or &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt;
     * depending on the arguments, as specified
     * in the &lt;a href=&quot;#transparency&quot;&gt;class description&lt;/a&gt; above.
     * @param bits      the number of bits each pixel occupies
     * @param size      the size of the color component arrays
     * @param cmap      the array of color components
     * @param start     the starting offset of the first color component
     * @param hasalpha  indicates whether alpha values are contained in
     *                  the &lt;code&gt;cmap&lt;/code&gt; array
     * @param trans     the index of the fully transparent pixel
     * @param transferType the data type of the array used to represent
     *           pixel values.  The data type must be either
     *           &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt; or
     *           &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;.
     * @throws IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is less
     *           than 1 or greater than 16
     * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; is less
     *           than 1
     * @throws IllegalArgumentException if &lt;code&gt;transferType&lt;/code&gt; is not
     *           one of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt; or
     *           &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;
     */
    public IndexColorModel(int bits, int size,
                           int cmap[], int start,
                           boolean hasalpha, int trans, int transferType) {
        // REMIND: This assumes the ordering: RGB[A]
        super(bits, opaqueBits,
              ColorSpace.getInstance(ColorSpace.CS_sRGB),
              false, false, OPAQUE,
              transferType);

        if (bits &lt; 1 || bits &gt; 16) {
            throw new IllegalArgumentException(&quot;Number of bits must be between&quot;
                                               +&quot; 1 and 16.&quot;);
        }
        if (size &lt; 1) {
            throw new IllegalArgumentException(&quot;Map size (&quot;+size+
                                               &quot;) must be &gt;= 1&quot;);
        }
        if ((transferType != DataBuffer.TYPE_BYTE) &amp;&amp;
            (transferType != DataBuffer.TYPE_USHORT)) {
            throw new IllegalArgumentException(&quot;transferType must be either&quot; +
                &quot;DataBuffer.TYPE_BYTE or DataBuffer.TYPE_USHORT&quot;);
        }

        setRGBs(size, cmap, start, hasalpha);
        setTransparentPixel(trans);
        calculatePixelMask();
    }

    /**
     * Constructs an &lt;code&gt;IndexColorModel&lt;/code&gt; from an
     * &lt;code&gt;int&lt;/code&gt; array where each &lt;code&gt;int&lt;/code&gt; is
     * comprised of red, green, blue, and alpha
     * components in the default RGB color model format.
     * The array must have enough values in it to fill all
     * of the needed component arrays of the specified size.
     * The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space.
     * The transparency value may be any of &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;,
     * &lt;code&gt;Transparency.BITMASK&lt;/code&gt;,
     * or &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt;
     * depending on the arguments, as specified
     * in the &lt;a href=&quot;#transparency&quot;&gt;class description&lt;/a&gt; above.
     * The transfer type must be one of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;
     * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;.
     * The &lt;code&gt;BigInteger&lt;/code&gt; object specifies the valid/invalid pixels
     * in the &lt;code&gt;cmap&lt;/code&gt; array.  A pixel is valid if the
     * &lt;code&gt;BigInteger&lt;/code&gt; value at that index is set, and is invalid
     * if the &lt;code&gt;BigInteger&lt;/code&gt; bit  at that index is not set.
     * @param bits the number of bits each pixel occupies
     * @param size the size of the color component array
     * @param cmap the array of color components
     * @param start the starting offset of the first color component
     * @param transferType the specified data type
     * @param validBits a &lt;code&gt;BigInteger&lt;/code&gt; object.  If a bit is
     *    set in the BigInteger, the pixel at that index is valid.
     *    If a bit is not set, the pixel at that index
     *    is considered invalid.  If null, all pixels are valid.
     *    Only bits from 0 to the map size are considered.
     * @throws IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is less
     *           than 1 or greater than 16
     * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; is less
     *           than 1
     * @throws IllegalArgumentException if &lt;code&gt;transferType&lt;/code&gt; is not
     *           one of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt; or
     *           &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;
     *
     * @since 1.3
     */
    public IndexColorModel(int bits, int size, int cmap[], int start,
                           int transferType, BigInteger validBits) {
        super (bits, alphaBits,
               ColorSpace.getInstance(ColorSpace.CS_sRGB),
               true, false, TRANSLUCENT,
               transferType);

        if (bits &lt; 1 || bits &gt; 16) {
            throw new IllegalArgumentException(&quot;Number of bits must be between&quot;
                                               +&quot; 1 and 16.&quot;);
        }
        if (size &lt; 1) {
            throw new IllegalArgumentException(&quot;Map size (&quot;+size+
                                               &quot;) must be &gt;= 1&quot;);
        }
        if ((transferType != DataBuffer.TYPE_BYTE) &amp;&amp;
            (transferType != DataBuffer.TYPE_USHORT)) {
            throw new IllegalArgumentException(&quot;transferType must be either&quot; +
                &quot;DataBuffer.TYPE_BYTE or DataBuffer.TYPE_USHORT&quot;);
        }

        if (validBits != null) {
            // Check to see if it is all valid
            for (int i=0; i &lt; size; i++) {
                if (!validBits.testBit(i)) {
                    this.validBits = validBits;
                    break;
                }
            }
        }

        setRGBs(size, cmap, start, true);
        calculatePixelMask();
    }

    private void setRGBs(int size, byte r[], byte g[], byte b[], byte a[]) {
        if (size &lt; 1) {
            throw new IllegalArgumentException(&quot;Map size (&quot;+size+
                                               &quot;) must be &gt;= 1&quot;);
        }
        map_size = size;
        rgb = new int[calcRealMapSize(pixel_bits, size)];
        int alpha = 0xff;
        int transparency = OPAQUE;
        boolean allgray = true;
        for (int i = 0; i &lt; size; i++) {
            int rc = r[i] &amp; 0xff;
            int gc = g[i] &amp; 0xff;
            int bc = b[i] &amp; 0xff;
            allgray = allgray &amp;&amp; (rc == gc) &amp;&amp; (gc == bc);
            if (a != null) {
                alpha = a[i] &amp; 0xff;
                if (alpha != 0xff) {
                    if (alpha == 0x00) {
                        if (transparency == OPAQUE) {
                            transparency = BITMASK;
                        }
                        if (transparent_index &lt; 0) {
                            transparent_index = i;
                        }
                    } else {
                        transparency = TRANSLUCENT;
                    }
                    allgray = false;
                }
            }
            rgb[i] = (alpha &lt;&lt; 24) | (rc &lt;&lt; 16) | (gc &lt;&lt; 8) | bc;
        }
        this.allgrayopaque = allgray;
        setTransparency(transparency);
    }

    private void setRGBs(int size, int cmap[], int start, boolean hasalpha) {
        map_size = size;
        rgb = new int[calcRealMapSize(pixel_bits, size)];
        int j = start;
        int transparency = OPAQUE;
        boolean allgray = true;
        BigInteger validBits = this.validBits;
        for (int i = 0; i &lt; size; i++, j++) {
            if (validBits != null &amp;&amp; !validBits.testBit(i)) {
                continue;
            }
            int cmaprgb = cmap[j];
            int r = (cmaprgb &gt;&gt; 16) &amp; 0xff;
            int g = (cmaprgb &gt;&gt;  8) &amp; 0xff;
            int b = (cmaprgb      ) &amp; 0xff;
            allgray = allgray &amp;&amp; (r == g) &amp;&amp; (g == b);
            if (hasalpha) {
                int alpha = cmaprgb &gt;&gt;&gt; 24;
                if (alpha != 0xff) {
                    if (alpha == 0x00) {
                        if (transparency == OPAQUE) {
                            transparency = BITMASK;
                        }
                        if (transparent_index &lt; 0) {
                            transparent_index = i;
                        }
                    } else {
                        transparency = TRANSLUCENT;
                    }
                    allgray = false;
                }
            } else {
                cmaprgb |= 0xff000000;
            }
            rgb[i] = cmaprgb;
        }
        this.allgrayopaque = allgray;
        setTransparency(transparency);
    }

    private int calcRealMapSize(int bits, int size) {
        int newSize = Math.max(1 &lt;&lt; bits, size);
        return Math.max(newSize, 256);
    }

    private BigInteger getAllValid() {
        int numbytes = (map_size+7)/8;
        byte[] valid = new byte[numbytes];
        java.util.Arrays.fill(valid, (byte)0xff);
        valid[0] = (byte)(0xff &gt;&gt;&gt; (numbytes*8 - map_size));

        return new BigInteger(1, valid);
    }

    /**
     * Returns the transparency.  Returns either OPAQUE, BITMASK,
     * or TRANSLUCENT
     * @return the transparency of this &lt;code&gt;IndexColorModel&lt;/code&gt;
     * @see Transparency#OPAQUE
     * @see Transparency#BITMASK
     * @see Transparency#TRANSLUCENT
     */
    public int getTransparency() {
        return transparency;
    }

    /**
     * Returns an array of the number of bits for each color/alpha component.
     * The array contains the color components in the order red, green,
     * blue, followed by the alpha component, if present.
     * @return an array containing the number of bits of each color
     *         and alpha component of this &lt;code&gt;IndexColorModel&lt;/code&gt;
     */
    public int[] getComponentSize() {
        if (nBits == null) {
            if (supportsAlpha) {
                nBits = new int[4];
                nBits[3] = 8;
            }
            else {
                nBits = new int[3];
            }
            nBits[0] = nBits[1] = nBits[2] = 8;
        }
        return nBits.clone();
    }

    /**
     * Returns the size of the color/alpha component arrays in this
     * &lt;code&gt;IndexColorModel&lt;/code&gt;.
     * @return the size of the color and alpha component arrays.
     */
    final public int getMapSize() {
        return map_size;
    }

    /**
     * Returns the index of a transparent pixel in this
     * &lt;code&gt;IndexColorModel&lt;/code&gt; or -1 if there is no pixel
     * with an alpha value of 0.  If a transparent pixel was
     * explicitly specified in one of the constructors by its
     * index, then that index will be preferred, otherwise,
     * the index of any pixel which happens to be fully transparent
     * may be returned.
     * @return the index of a transparent pixel in this
     *         &lt;code&gt;IndexColorModel&lt;/code&gt; object, or -1 if there
     *         is no such pixel
     */
    final public int getTransparentPixel() {
        return transparent_index;
    }

    /**
     * Copies the array of red color components into the specified array.
     * Only the initial entries of the array as specified by
     * {@link #getMapSize() getMapSize} are written.
     * @param r the specified array into which the elements of the
     *      array of red color components are copied
     */
    final public void getReds(byte r[]) {
        for (int i = 0; i &lt; map_size; i++) {
            r[i] = (byte) (rgb[i] &gt;&gt; 16);
        }
    }

    /**
     * Copies the array of green color components into the specified array.
     * Only the initial entries of the array as specified by
     * &lt;code&gt;getMapSize&lt;/code&gt; are written.
     * @param g the specified array into which the elements of the
     *      array of green color components are copied
     */
    final public void getGreens(byte g[]) {
        for (int i = 0; i &lt; map_size; i++) {
            g[i] = (byte) (rgb[i] &gt;&gt; 8);
        }
    }

    /**
     * Copies the array of blue color components into the specified array.
     * Only the initial entries of the array as specified by
     * &lt;code&gt;getMapSize&lt;/code&gt; are written.
     * @param b the specified array into which the elements of the
     *      array of blue color components are copied
     */
    final public void getBlues(byte b[]) {
        for (int i = 0; i &lt; map_size; i++) {
            b[i] = (byte) rgb[i];
        }
    }

    /**
     * Copies the array of alpha transparency components into the
     * specified array.  Only the initial entries of the array as specified
     * by &lt;code&gt;getMapSize&lt;/code&gt; are written.
     * @param a the specified array into which the elements of the
     *      array of alpha components are copied
     */
    final public void getAlphas(byte a[]) {
        for (int i = 0; i &lt; map_size; i++) {
            a[i] = (byte) (rgb[i] &gt;&gt; 24);
        }
    }

    /**
     * Converts data for each index from the color and alpha component
     * arrays to an int in the default RGB ColorModel format and copies
     * the resulting 32-bit ARGB values into the specified array.  Only
     * the initial entries of the array as specified by
     * &lt;code&gt;getMapSize&lt;/code&gt; are
     * written.
     * @param rgb the specified array into which the converted ARGB
     *        values from this array of color and alpha components
     *        are copied.
     */
    final public void getRGBs(int rgb[]) {
        System.arraycopy(this.rgb, 0, rgb, 0, map_size);
    }

    private void setTransparentPixel(int trans) {
        if (trans &gt;= 0 &amp;&amp; trans &lt; map_size) {
            rgb[trans] &amp;= 0x00ffffff;
            transparent_index = trans;
            allgrayopaque = false;
            if (this.transparency == OPAQUE) {
                setTransparency(BITMASK);
            }
        }
    }

    private void setTransparency(int transparency) {
        if (this.transparency != transparency) {
            this.transparency = transparency;
            if (transparency == OPAQUE) {
                supportsAlpha = false;
                numComponents = 3;
                nBits = opaqueBits;
            } else {
                supportsAlpha = true;
                numComponents = 4;
                nBits = alphaBits;
            }
        }
    }

    /**
     * This method is called from the constructors to set the pixel_mask
     * value, which is based on the value of pixel_bits.  The pixel_mask
     * value is used to mask off the pixel parameters for methods such
     * as getRed(), getGreen(), getBlue(), getAlpha(), and getRGB().
     */
    private final void calculatePixelMask() {
        // Note that we adjust the mask so that our masking behavior here
        // is consistent with that of our native rendering loops.
        int maskbits = pixel_bits;
        if (maskbits == 3) {
            maskbits = 4;
        } else if (maskbits &gt; 4 &amp;&amp; maskbits &lt; 8) {
            maskbits = 8;
        }
        pixel_mask = (1 &lt;&lt; maskbits) - 1;
    }

    /**
     * Returns the red color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB ColorSpace, sRGB.  The pixel value
     * is specified as an int.
     * Only the lower &lt;em&gt;n&lt;/em&gt; bits of the pixel value, as specified in the
     * &lt;a href=&quot;#index_values&quot;&gt;class description&lt;/a&gt; above, are used to
     * calculate the returned value.
     * The returned value is a non pre-multiplied value.
     * @param pixel the specified pixel
     * @return the value of the red color component for the specified pixel
     */
    final public int getRed(int pixel) {
        return (rgb[pixel &amp; pixel_mask] &gt;&gt; 16) &amp; 0xff;
    }

    /**
     * Returns the green color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB ColorSpace, sRGB.  The pixel value
     * is specified as an int.
     * Only the lower &lt;em&gt;n&lt;/em&gt; bits of the pixel value, as specified in the
     * &lt;a href=&quot;#index_values&quot;&gt;class description&lt;/a&gt; above, are used to
     * calculate the returned value.
     * The returned value is a non pre-multiplied value.
     * @param pixel the specified pixel
     * @return the value of the green color component for the specified pixel
     */
    final public int getGreen(int pixel) {
        return (rgb[pixel &amp; pixel_mask] &gt;&gt; 8) &amp; 0xff;
    }

    /**
     * Returns the blue color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB ColorSpace, sRGB.  The pixel value
     * is specified as an int.
     * Only the lower &lt;em&gt;n&lt;/em&gt; bits of the pixel value, as specified in the
     * &lt;a href=&quot;#index_values&quot;&gt;class description&lt;/a&gt; above, are used to
     * calculate the returned value.
     * The returned value is a non pre-multiplied value.
     * @param pixel the specified pixel
     * @return the value of the blue color component for the specified pixel
     */
    final public int getBlue(int pixel) {
        return rgb[pixel &amp; pixel_mask] &amp; 0xff;
    }

    /**
     * Returns the alpha component for the specified pixel, scaled
     * from 0 to 255.  The pixel value is specified as an int.
     * Only the lower &lt;em&gt;n&lt;/em&gt; bits of the pixel value, as specified in the
     * &lt;a href=&quot;#index_values&quot;&gt;class description&lt;/a&gt; above, are used to
     * calculate the returned value.
     * @param pixel the specified pixel
     * @return the value of the alpha component for the specified pixel
     */
    final public int getAlpha(int pixel) {
        return (rgb[pixel &amp; pixel_mask] &gt;&gt; 24) &amp; 0xff;
    }

    /**
     * Returns the color/alpha components of the pixel in the default
     * RGB color model format.  The pixel value is specified as an int.
     * Only the lower &lt;em&gt;n&lt;/em&gt; bits of the pixel value, as specified in the
     * &lt;a href=&quot;#index_values&quot;&gt;class description&lt;/a&gt; above, are used to
     * calculate the returned value.
     * The returned value is in a non pre-multiplied format.
     * @param pixel the specified pixel
     * @return the color and alpha components of the specified pixel
     * @see ColorModel#getRGBdefault
     */
    final public int getRGB(int pixel) {
        return rgb[pixel &amp; pixel_mask];
    }

    private static final int CACHESIZE = 40;
    private int lookupcache[] = new int[CACHESIZE];

    /**
     * Returns a data element array representation of a pixel in this
     * ColorModel, given an integer pixel representation in the
     * default RGB color model.  This array can then be passed to the
     * {@link WritableRaster#setDataElements(int, int, java.lang.Object) setDataElements}
     * method of a {@link WritableRaster} object.  If the pixel variable is
     * &lt;code&gt;null&lt;/code&gt;, a new array is allocated.  If &lt;code&gt;pixel&lt;/code&gt;
     * is not &lt;code&gt;null&lt;/code&gt;, it must be
     * a primitive array of type &lt;code&gt;transferType&lt;/code&gt;; otherwise, a
     * &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is
     * thrown if &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a pixel
     * value for this &lt;code&gt;ColorModel&lt;/code&gt;.  The pixel array is returned.
     * &lt;p&gt;
     * Since &lt;code&gt;IndexColorModel&lt;/code&gt; can be subclassed, subclasses
     * inherit the implementation of this method and if they don't
     * override it then they throw an exception if they use an
     * unsupported &lt;code&gt;transferType&lt;/code&gt;.
     *
     * @param rgb the integer pixel representation in the default RGB
     * color model
     * @param pixel the specified pixel
     * @return an array representation of the specified pixel in this
     *  &lt;code&gt;IndexColorModel&lt;/code&gt;.
     * @throws ClassCastException if &lt;code&gt;pixel&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt;
     * @throws UnsupportedOperationException if &lt;code&gt;transferType&lt;/code&gt;
     *         is invalid
     * @see WritableRaster#setDataElements
     * @see SampleModel#setDataElements
     */
    public synchronized Object getDataElements(int rgb, Object pixel) {
        int red = (rgb&gt;&gt;16) &amp; 0xff;
        int green = (rgb&gt;&gt;8) &amp; 0xff;
        int blue  = rgb &amp; 0xff;
        int alpha = (rgb&gt;&gt;&gt;24);
        int pix = 0;

        // Note that pixels are stored at lookupcache[2*i]
        // and the rgb that was searched is stored at
        // lookupcache[2*i+1].  Also, the pixel is first
        // inverted using the unary complement operator
        // before storing in the cache so it can never be 0.
        for (int i = CACHESIZE - 2; i &gt;= 0; i -= 2) {
            if ((pix = lookupcache[i]) == 0) {
                break;
            }
            if (rgb == lookupcache[i+1]) {
                return installpixel(pixel, ~pix);
            }
        }

        if (allgrayopaque) {
            // IndexColorModel objects are all tagged as
            // non-premultiplied so ignore the alpha value
            // of the incoming color, convert the
            // non-premultiplied color components to a
            // grayscale value and search for the closest
            // gray value in the palette.  Since all colors
            // in the palette are gray, we only need compare
            // to one of the color components for a match
            // using a simple linear distance formula.

            int minDist = 256;
            int d;
            int gray = (int) (red*77 + green*150 + blue*29 + 128)/256;

            for (int i = 0; i &lt; map_size; i++) {
                if (this.rgb[i] == 0x0) {
                    // For allgrayopaque colormaps, entries are 0
                    // iff they are an invalid color and should be
                    // ignored during color searches.
                    continue;
                }
                d = (this.rgb[i] &amp; 0xff) - gray;
                if (d &lt; 0) d = -d;
                if (d &lt; minDist) {
                    pix = i;
                    if (d == 0) {
                        break;
                    }
                    minDist = d;
                }
            }
        } else if (transparency == OPAQUE) {
            // IndexColorModel objects are all tagged as
            // non-premultiplied so ignore the alpha value
            // of the incoming color and search for closest
            // color match independently using a 3 component
            // Euclidean distance formula.
            // For opaque colormaps, palette entries are 0
            // iff they are an invalid color and should be
            // ignored during color searches.
            // As an optimization, exact color searches are
            // likely to be fairly common in opaque colormaps
            // so first we will do a quick search for an
            // exact match.

            int smallestError = Integer.MAX_VALUE;
            int lut[] = this.rgb;
            int lutrgb;
            for (int i=0; i &lt; map_size; i++) {
                lutrgb = lut[i];
                if (lutrgb == rgb &amp;&amp; lutrgb != 0) {
                    pix = i;
                    smallestError = 0;
                    break;
                }
            }

            if (smallestError != 0) {
                for (int i=0; i &lt; map_size; i++) {
                    lutrgb = lut[i];
                    if (lutrgb == 0) {
                        continue;
                    }

                    int tmp = ((lutrgb &gt;&gt; 16) &amp; 0xff) - red;
                    int currentError = tmp*tmp;
                    if (currentError &lt; smallestError) {
                        tmp = ((lutrgb &gt;&gt; 8) &amp; 0xff) - green;
                        currentError += tmp * tmp;
                        if (currentError &lt; smallestError) {
                            tmp = (lutrgb &amp; 0xff) - blue;
                            currentError += tmp * tmp;
                            if (currentError &lt; smallestError) {
                                pix = i;
                                smallestError = currentError;
                            }
                        }
                    }
                }
            }
        } else if (alpha == 0 &amp;&amp; transparent_index &gt;= 0) {
            // Special case - transparent color maps to the
            // specified transparent pixel, if there is one

            pix = transparent_index;
        } else {
            // IndexColorModel objects are all tagged as
            // non-premultiplied so use non-premultiplied
            // color components in the distance calculations.
            // Look for closest match using a 4 component
            // Euclidean distance formula.

            int smallestError = Integer.MAX_VALUE;
            int lut[] = this.rgb;
            for (int i=0; i &lt; map_size; i++) {
                int lutrgb = lut[i];
                if (lutrgb == rgb) {
                    if (validBits != null &amp;&amp; !validBits.testBit(i)) {
                        continue;
                    }
                    pix = i;
                    break;
                }

                int tmp = ((lutrgb &gt;&gt; 16) &amp; 0xff) - red;
                int currentError = tmp*tmp;
                if (currentError &lt; smallestError) {
                    tmp = ((lutrgb &gt;&gt; 8) &amp; 0xff) - green;
                    currentError += tmp * tmp;
                    if (currentError &lt; smallestError) {
                        tmp = (lutrgb &amp; 0xff) - blue;
                        currentError += tmp * tmp;
                        if (currentError &lt; smallestError) {
                            tmp = (lutrgb &gt;&gt;&gt; 24) - alpha;
                            currentError += tmp * tmp;
                            if (currentError &lt; smallestError &amp;&amp;
                                (validBits == null || validBits.testBit(i)))
                            {
                                pix = i;
                                smallestError = currentError;
                            }
                        }
                    }
                }
            }
        }
        System.arraycopy(lookupcache, 2, lookupcache, 0, CACHESIZE - 2);
        lookupcache[CACHESIZE - 1] = rgb;
        lookupcache[CACHESIZE - 2] = ~pix;
        return installpixel(pixel, pix);
    }

    private Object installpixel(Object pixel, int pix) {
        switch (transferType) {
        case DataBuffer.TYPE_INT:
            int[] intObj;
            if (pixel == null) {
                pixel = intObj = new int[1];
            } else {
                intObj = (int[]) pixel;
            }
            intObj[0] = pix;
            break;
        case DataBuffer.TYPE_BYTE:
            byte[] byteObj;
            if (pixel == null) {
                pixel = byteObj = new byte[1];
            } else {
                byteObj = (byte[]) pixel;
            }
            byteObj[0] = (byte) pix;
            break;
        case DataBuffer.TYPE_USHORT:
            short[] shortObj;
            if (pixel == null) {
                pixel = shortObj = new short[1];
            } else {
                shortObj = (short[]) pixel;
            }
            shortObj[0] = (short) pix;
            break;
        default:
            throw new UnsupportedOperationException(&quot;This method has not been &quot;+
                             &quot;implemented for transferType &quot; + transferType);
        }
        return pixel;
    }

    /**
     * Returns an array of unnormalized color/alpha components for a
     * specified pixel in this &lt;code&gt;ColorModel&lt;/code&gt;.  The pixel value
     * is specified as an int.  If the &lt;code&gt;components&lt;/code&gt; array is &lt;code&gt;null&lt;/code&gt;,
     * a new array is allocated that contains
     * &lt;code&gt;offset + getNumComponents()&lt;/code&gt; elements.
     * The &lt;code&gt;components&lt;/code&gt; array is returned,
     * with the alpha component included
     * only if &lt;code&gt;hasAlpha&lt;/code&gt; returns true.
     * Color/alpha components are stored in the &lt;code&gt;components&lt;/code&gt; array starting
     * at &lt;code&gt;offset&lt;/code&gt; even if the array is allocated by this method.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;
     * is thrown if  the &lt;code&gt;components&lt;/code&gt; array is not &lt;code&gt;null&lt;/code&gt; and is
     * not large enough to hold all the color and alpha components
     * starting at &lt;code&gt;offset&lt;/code&gt;.
     * @param pixel the specified pixel
     * @param components the array to receive the color and alpha
     * components of the specified pixel
     * @param offset the offset into the &lt;code&gt;components&lt;/code&gt; array at
     * which to start storing the color and alpha components
     * @return an array containing the color and alpha components of the
     * specified pixel starting at the specified offset.
     * @see ColorModel#hasAlpha
     * @see ColorModel#getNumComponents
     */
    public int[] getComponents(int pixel, int[] components, int offset) {
        if (components == null) {
            components = new int[offset+numComponents];
        }

        // REMIND: Needs to change if different color space
        components[offset+0] = getRed(pixel);
        components[offset+1] = getGreen(pixel);
        components[offset+2] = getBlue(pixel);
        if (supportsAlpha &amp;&amp; (components.length-offset) &gt; 3) {
            components[offset+3] = getAlpha(pixel);
        }

        return components;
    }

    /**
     * Returns an array of unnormalized color/alpha components for
     * a specified pixel in this &lt;code&gt;ColorModel&lt;/code&gt;.  The pixel
     * value is specified by an array of data elements of type
     * &lt;code&gt;transferType&lt;/code&gt; passed in as an object reference.
     * If &lt;code&gt;pixel&lt;/code&gt; is not a primitive array of type
     * &lt;code&gt;transferType&lt;/code&gt;, a &lt;code&gt;ClassCastException&lt;/code&gt;
     * is thrown.  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;
     * is thrown if &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold
     * a pixel value for this &lt;code&gt;ColorModel&lt;/code&gt;.  If the
     * &lt;code&gt;components&lt;/code&gt; array is &lt;code&gt;null&lt;/code&gt;, a new array
     * is allocated that contains
     * &lt;code&gt;offset + getNumComponents()&lt;/code&gt; elements.
     * The &lt;code&gt;components&lt;/code&gt; array is returned,
     * with the alpha component included
     * only if &lt;code&gt;hasAlpha&lt;/code&gt; returns true.
     * Color/alpha components are stored in the &lt;code&gt;components&lt;/code&gt;
     * array starting at &lt;code&gt;offset&lt;/code&gt; even if the array is
     * allocated by this method.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is also
     * thrown if  the &lt;code&gt;components&lt;/code&gt; array is not
     * &lt;code&gt;null&lt;/code&gt; and is not large enough to hold all the color
     * and alpha components starting at &lt;code&gt;offset&lt;/code&gt;.
     * &lt;p&gt;
     * Since &lt;code&gt;IndexColorModel&lt;/code&gt; can be subclassed, subclasses
     * inherit the implementation of this method and if they don't
     * override it then they throw an exception if they use an
     * unsupported &lt;code&gt;transferType&lt;/code&gt;.
     *
     * @param pixel the specified pixel
     * @param components an array that receives the color and alpha
     * components of the specified pixel
     * @param offset the index into the &lt;code&gt;components&lt;/code&gt; array at
     * which to begin storing the color and alpha components of the
     * specified pixel
     * @return an array containing the color and alpha components of the
     * specified pixel starting at the specified offset.
     * @throws ArrayIndexOutOfBoundsException if &lt;code&gt;pixel&lt;/code&gt;
     *            is not large enough to hold a pixel value for this
     *            &lt;code&gt;ColorModel&lt;/code&gt; or if the
     *            &lt;code&gt;components&lt;/code&gt; array is not &lt;code&gt;null&lt;/code&gt;
     *            and is not large enough to hold all the color
     *            and alpha components starting at &lt;code&gt;offset&lt;/code&gt;
     * @throws ClassCastException if &lt;code&gt;pixel&lt;/code&gt; is not a
     *            primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws UnsupportedOperationException if &lt;code&gt;transferType&lt;/code&gt;
     *         is not one of the supported transfer types
     * @see ColorModel#hasAlpha
     * @see ColorModel#getNumComponents
     */
    public int[] getComponents(Object pixel, int[] components, int offset) {
        int intpixel;
        switch (transferType) {
            case DataBuffer.TYPE_BYTE:
               byte bdata[] = (byte[])pixel;
               intpixel = bdata[0] &amp; 0xff;
            break;
            case DataBuffer.TYPE_USHORT:
               short sdata[] = (short[])pixel;
               intpixel = sdata[0] &amp; 0xffff;
            break;
            case DataBuffer.TYPE_INT:
               int idata[] = (int[])pixel;
               intpixel = idata[0];
            break;
            default:
               throw new UnsupportedOperationException(&quot;This method has not been &quot;+
                   &quot;implemented for transferType &quot; + transferType);
        }
        return getComponents(intpixel, components, offset);
    }

    /**
     * Returns a pixel value represented as an int in this
     * &lt;code&gt;ColorModel&lt;/code&gt; given an array of unnormalized
     * color/alpha components.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;
     * is thrown if the &lt;code&gt;components&lt;/code&gt; array is not large
     * enough to hold all of the color and alpha components starting
     * at &lt;code&gt;offset&lt;/code&gt;.  Since
     * &lt;code&gt;ColorModel&lt;/code&gt; can be subclassed, subclasses inherit the
     * implementation of this method and if they don't override it then
     * they throw an exception if they use an unsupported transferType.
     * @param components an array of unnormalized color and alpha
     * components
     * @param offset the index into &lt;code&gt;components&lt;/code&gt; at which to
     * begin retrieving the color and alpha components
     * @return an &lt;code&gt;int&lt;/code&gt; pixel value in this
     * &lt;code&gt;ColorModel&lt;/code&gt; corresponding to the specified components.
     * @throws ArrayIndexOutOfBoundsException if
     *  the &lt;code&gt;components&lt;/code&gt; array is not large enough to
     *  hold all of the color and alpha components starting at
     *  &lt;code&gt;offset&lt;/code&gt;
     * @throws UnsupportedOperationException if &lt;code&gt;transferType&lt;/code&gt;
     *         is invalid
     */
    public int getDataElement(int[] components, int offset) {
        int rgb = (components[offset+0]&lt;&lt;16)
            | (components[offset+1]&lt;&lt;8) | (components[offset+2]);
        if (supportsAlpha) {
            rgb |= (components[offset+3]&lt;&lt;24);
        }
        else {
            rgb |= 0xff000000;
        }
        Object inData = getDataElements(rgb, null);
        int pixel;
        switch (transferType) {
            case DataBuffer.TYPE_BYTE:
               byte bdata[] = (byte[])inData;
               pixel = bdata[0] &amp; 0xff;
            break;
            case DataBuffer.TYPE_USHORT:
               short sdata[] = (short[])inData;
               pixel = sdata[0];
            break;
            case DataBuffer.TYPE_INT:
               int idata[] = (int[])inData;
               pixel = idata[0];
            break;
            default:
               throw new UnsupportedOperationException(&quot;This method has not been &quot;+
                   &quot;implemented for transferType &quot; + transferType);
        }
        return pixel;
    }

    /**
     * Returns a data element array representation of a pixel in this
     * &lt;code&gt;ColorModel&lt;/code&gt; given an array of unnormalized color/alpha
     * components.  This array can then be passed to the
     * &lt;code&gt;setDataElements&lt;/code&gt; method of a &lt;code&gt;WritableRaster&lt;/code&gt;
     * object.  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is
     * thrown if the
     * &lt;code&gt;components&lt;/code&gt; array is not large enough to hold all of the
     * color and alpha components starting at &lt;code&gt;offset&lt;/code&gt;.
     * If the pixel variable is &lt;code&gt;null&lt;/code&gt;, a new array
     * is allocated.  If &lt;code&gt;pixel&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;,
     * it must be a primitive array of type &lt;code&gt;transferType&lt;/code&gt;;
     * otherwise, a &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if pixel
     * is not large enough to hold a pixel value for this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * &lt;p&gt;
     * Since &lt;code&gt;IndexColorModel&lt;/code&gt; can be subclassed, subclasses
     * inherit the implementation of this method and if they don't
     * override it then they throw an exception if they use an
     * unsupported &lt;code&gt;transferType&lt;/code&gt;
     *
     * @param components an array of unnormalized color and alpha
     * components
     * @param offset the index into &lt;code&gt;components&lt;/code&gt; at which to
     * begin retrieving color and alpha components
     * @param pixel the &lt;code&gt;Object&lt;/code&gt; representing an array of color
     * and alpha components
     * @return an &lt;code&gt;Object&lt;/code&gt; representing an array of color and
     * alpha components.
     * @throws ClassCastException if &lt;code&gt;pixel&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt; or the &lt;code&gt;components&lt;/code&gt;
     *  array is not large enough to hold all of the color and alpha
     *  components starting at &lt;code&gt;offset&lt;/code&gt;
     * @throws UnsupportedOperationException if &lt;code&gt;transferType&lt;/code&gt;
     *         is not one of the supported transfer types
     * @see WritableRaster#setDataElements
     * @see SampleModel#setDataElements
     */
    public Object getDataElements(int[] components, int offset, Object pixel) {
        int rgb = (components[offset+0]&lt;&lt;16) | (components[offset+1]&lt;&lt;8)
            | (components[offset+2]);
        if (supportsAlpha) {
            rgb |= (components[offset+3]&lt;&lt;24);
        }
        else {
            rgb &amp;= 0xff000000;
        }
        return getDataElements(rgb, pixel);
    }

    /**
     * Creates a &lt;code&gt;WritableRaster&lt;/code&gt; with the specified width
     * and height that has a data layout (&lt;code&gt;SampleModel&lt;/code&gt;)
     * compatible with this &lt;code&gt;ColorModel&lt;/code&gt;.  This method
     * only works for color models with 16 or fewer bits per pixel.
     * &lt;p&gt;
     * Since &lt;code&gt;IndexColorModel&lt;/code&gt; can be subclassed, any
     * subclass that supports greater than 16 bits per pixel must
     * override this method.
     *
     * @param w the width to apply to the new &lt;code&gt;WritableRaster&lt;/code&gt;
     * @param h the height to apply to the new &lt;code&gt;WritableRaster&lt;/code&gt;
     * @return a &lt;code&gt;WritableRaster&lt;/code&gt; object with the specified
     * width and height.
     * @throws UnsupportedOperationException if the number of bits in a
     *         pixel is greater than 16
     * @see WritableRaster
     * @see SampleModel
     */
    public WritableRaster createCompatibleWritableRaster(int w, int h) {
        WritableRaster raster;

        if (pixel_bits == 1 || pixel_bits == 2 || pixel_bits == 4) {
            // TYPE_BINARY
            raster = Raster.createPackedRaster(DataBuffer.TYPE_BYTE,
                                               w, h, 1, pixel_bits, null);
        }
        else if (pixel_bits &lt;= 8) {
            raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,
                                                  w,h,1,null);
        }
        else if (pixel_bits &lt;= 16) {
            raster = Raster.createInterleavedRaster(DataBuffer.TYPE_USHORT,
                                                  w,h,1,null);
        }
        else {
            throw new
                UnsupportedOperationException(&quot;This method is not supported &quot;+
                                              &quot; for pixel bits &gt; 16.&quot;);
        }
        return raster;
    }

    /**
      * Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;raster&lt;/code&gt; is compatible
      * with this &lt;code&gt;ColorModel&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; if it
      * is not compatible with this &lt;code&gt;ColorModel&lt;/code&gt;.
      * @param raster the {@link Raster} object to test for compatibility
      * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;raster&lt;/code&gt; is compatible
      * with this &lt;code&gt;ColorModel&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise.
      *
      */
    public boolean isCompatibleRaster(Raster raster) {

        int size = raster.getSampleModel().getSampleSize(0);
        return ((raster.getTransferType() == transferType) &amp;&amp;
                (raster.getNumBands() == 1) &amp;&amp; ((1 &lt;&lt; size) &gt;= map_size));
    }

    /**
     * Creates a &lt;code&gt;SampleModel&lt;/code&gt; with the specified
     * width and height that has a data layout compatible with
     * this &lt;code&gt;ColorModel&lt;/code&gt;.
     * @param w the width to apply to the new &lt;code&gt;SampleModel&lt;/code&gt;
     * @param h the height to apply to the new &lt;code&gt;SampleModel&lt;/code&gt;
     * @return a &lt;code&gt;SampleModel&lt;/code&gt; object with the specified
     * width and height.
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt; is not greater than 0
     * @see SampleModel
     */
    public SampleModel createCompatibleSampleModel(int w, int h) {
        int[] off = new int[1];
        off[0] = 0;
        if (pixel_bits == 1 || pixel_bits == 2 || pixel_bits == 4) {
            return new MultiPixelPackedSampleModel(transferType, w, h,
                                                   pixel_bits);
        }
        else {
            return new ComponentSampleModel(transferType, w, h, 1, w,
                                            off);
        }
    }

    /**
     * Checks if the specified &lt;code&gt;SampleModel&lt;/code&gt; is compatible
     * with this &lt;code&gt;ColorModel&lt;/code&gt;.  If &lt;code&gt;sm&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;, this method returns &lt;code&gt;false&lt;/code&gt;.
     * @param sm the specified &lt;code&gt;SampleModel&lt;/code&gt;,
     *           or &lt;code&gt;null&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if the specified &lt;code&gt;SampleModel&lt;/code&gt;
     * is compatible with this &lt;code&gt;ColorModel&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt;
     * otherwise.
     * @see SampleModel
     */
    public boolean isCompatibleSampleModel(SampleModel sm) {
        // fix 4238629
        if (! (sm instanceof ComponentSampleModel) &amp;&amp;
            ! (sm instanceof MultiPixelPackedSampleModel)   ) {
            return false;
        }

        // Transfer type must be the same
        if (sm.getTransferType() != transferType) {
            return false;
        }

        if (sm.getNumBands() != 1) {
            return false;
        }

        return true;
    }

    /**
     * Returns a new &lt;code&gt;BufferedImage&lt;/code&gt; of TYPE_INT_ARGB or
     * TYPE_INT_RGB that has a &lt;code&gt;Raster&lt;/code&gt; with pixel data
     * computed by expanding the indices in the source &lt;code&gt;Raster&lt;/code&gt;
     * using the color/alpha component arrays of this &lt;code&gt;ColorModel&lt;/code&gt;.
     * Only the lower &lt;em&gt;n&lt;/em&gt; bits of each index value in the source
     * &lt;code&gt;Raster&lt;/code&gt;, as specified in the
     * &lt;a href=&quot;#index_values&quot;&gt;class description&lt;/a&gt; above, are used to
     * compute the color/alpha values in the returned image.
     * If &lt;code&gt;forceARGB&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, a TYPE_INT_ARGB image is
     * returned regardless of whether or not this &lt;code&gt;ColorModel&lt;/code&gt;
     * has an alpha component array or a transparent pixel.
     * @param raster the specified &lt;code&gt;Raster&lt;/code&gt;
     * @param forceARGB if &lt;code&gt;true&lt;/code&gt;, the returned
     *     &lt;code&gt;BufferedImage&lt;/code&gt; is TYPE_INT_ARGB; otherwise it is
     *     TYPE_INT_RGB
     * @return a &lt;code&gt;BufferedImage&lt;/code&gt; created with the specified
     *     &lt;code&gt;Raster&lt;/code&gt;
     * @throws IllegalArgumentException if the raster argument is not
     *           compatible with this IndexColorModel
     */
    public BufferedImage convertToIntDiscrete(Raster raster,
                                              boolean forceARGB) {
        ColorModel cm;

        if (!isCompatibleRaster(raster)) {
            throw new IllegalArgumentException(&quot;This raster is not compatible&quot; +
                 &quot;with this IndexColorModel.&quot;);
        }
        if (forceARGB || transparency == TRANSLUCENT) {
            cm = ColorModel.getRGBdefault();
        }
        else if (transparency == BITMASK) {
            cm = new DirectColorModel(25, 0xff0000, 0x00ff00, 0x0000ff,
                                      0x1000000);
        }
        else {
            cm = new DirectColorModel(24, 0xff0000, 0x00ff00, 0x0000ff);
        }

        int w = raster.getWidth();
        int h = raster.getHeight();
        WritableRaster discreteRaster =
                  cm.createCompatibleWritableRaster(w, h);
        Object obj = null;
        int[] data = null;

        int rX = raster.getMinX();
        int rY = raster.getMinY();

        for (int y=0; y &lt; h; y++, rY++) {
            obj = raster.getDataElements(rX, rY, w, 1, obj);
            if (obj instanceof int[]) {
                data = (int[])obj;
            } else {
                data = DataBuffer.toIntArray(obj);
            }
            for (int x=0; x &lt; w; x++) {
                data[x] = rgb[data[x] &amp; pixel_mask];
            }
            discreteRaster.setDataElements(0, y, w, 1, data);
        }

        return new BufferedImage(cm, discreteRaster, false, null);
    }

    /**
     * Returns whether or not the pixel is valid.
     * @param pixel the specified pixel value
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;pixel&lt;/code&gt;
     * is valid; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since 1.3
     */
    public boolean isValid(int pixel) {
        return ((pixel &gt;= 0 &amp;&amp; pixel &lt; map_size) &amp;&amp;
                (validBits == null || validBits.testBit(pixel)));
    }

    /**
     * Returns whether or not all of the pixels are valid.
     * @return &lt;code&gt;true&lt;/code&gt; if all pixels are valid;
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since 1.3
     */
    public boolean isValid() {
        return (validBits == null);
    }

    /**
     * Returns a &lt;code&gt;BigInteger&lt;/code&gt; that indicates the valid/invalid
     * pixels in the colormap.  A bit is valid if the
     * &lt;code&gt;BigInteger&lt;/code&gt; value at that index is set, and is invalid
     * if the &lt;code&gt;BigInteger&lt;/code&gt; value at that index is not set.
     * The only valid ranges to query in the &lt;code&gt;BigInteger&lt;/code&gt; are
     * between 0 and the map size.
     * @return a &lt;code&gt;BigInteger&lt;/code&gt; indicating the valid/invalid pixels.
     * @since 1.3
     */
    public BigInteger getValidPixels() {
        if (validBits == null) {
            return getAllValid();
        }
        else {
            return validBits;
        }
    }

    /**
     * Disposes of system resources associated with this
     * &lt;code&gt;ColorModel&lt;/code&gt; once this &lt;code&gt;ColorModel&lt;/code&gt; is no
     * longer referenced.
     */
    public void finalize() {
    }

    /**
     * Returns the &lt;code&gt;String&lt;/code&gt; representation of the contents of
     * this &lt;code&gt;ColorModel&lt;/code&gt;object.
     * @return a &lt;code&gt;String&lt;/code&gt; representing the contents of this
     * &lt;code&gt;ColorModel&lt;/code&gt; object.
     */
    public String toString() {
       return new String(&quot;IndexColorModel: #pixelBits = &quot;+pixel_bits
                         + &quot; numComponents = &quot;+numComponents
                         + &quot; color space = &quot;+colorSpace
                         + &quot; transparency = &quot;+transparency
                         + &quot; transIndex   = &quot;+transparent_index
                         + &quot; has alpha = &quot;+supportsAlpha
                         + &quot; isAlphaPre = &quot;+isAlphaPremultiplied
                         );
    }
}
</pre>
</body>
</html>
