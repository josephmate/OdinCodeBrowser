<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Point2D;
import java.awt.AlphaComposite;
import java.awt.GraphicsEnvironment;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Transparency;
import java.lang.annotation.Native;
import sun.awt.image.ImagingLib;

/**
 * This class uses an affine transform to perform a linear mapping from
 * 2D coordinates in the source image or &lt;CODE&gt;Raster&lt;/CODE&gt; to 2D coordinates
 * in the destination image or &lt;CODE&gt;Raster&lt;/CODE&gt;.
 * The type of interpolation that is used is specified through a constructor,
 * either by a &lt;CODE&gt;RenderingHints&lt;/CODE&gt; object or by one of the integer
 * interpolation types defined in this class.
 * &lt;p&gt;
 * If a &lt;CODE&gt;RenderingHints&lt;/CODE&gt; object is specified in the constructor, the
 * interpolation hint and the rendering quality hint are used to set
 * the interpolation type for this operation.  The color rendering hint
 * and the dithering hint can be used when color conversion is required.
 * &lt;p&gt;
 * Note that the following constraints have to be met:
 * &lt;ul&gt;
 * &lt;li&gt;The source and destination must be different.
 * &lt;li&gt;For &lt;CODE&gt;Raster&lt;/CODE&gt; objects, the number of bands in the source must
 * be equal to the number of bands in the destination.
 * &lt;/ul&gt;
 * @see AffineTransform
 * @see BufferedImageFilter
 * @see java.awt.RenderingHints#KEY_INTERPOLATION
 * @see java.awt.RenderingHints#KEY_RENDERING
 * @see java.awt.RenderingHints#KEY_COLOR_RENDERING
 * @see java.awt.RenderingHints#KEY_DITHERING
 */
public class AffineTransformOp implements BufferedImageOp, RasterOp {
    private AffineTransform xform;
    RenderingHints hints;

    /**
     * Nearest-neighbor interpolation type.
     */
    @Native public static final int TYPE_NEAREST_NEIGHBOR = 1;

    /**
     * Bilinear interpolation type.
     */
    @Native public static final int TYPE_BILINEAR = 2;

    /**
     * Bicubic interpolation type.
     */
    @Native public static final int TYPE_BICUBIC = 3;

    int interpolationType = TYPE_NEAREST_NEIGHBOR;

    /**
     * Constructs an &lt;CODE&gt;AffineTransformOp&lt;/CODE&gt; given an affine transform.
     * The interpolation type is determined from the
     * &lt;CODE&gt;RenderingHints&lt;/CODE&gt; object.  If the interpolation hint is
     * defined, it will be used. Otherwise, if the rendering quality hint is
     * defined, the interpolation type is determined from its value.  If no
     * hints are specified (&lt;CODE&gt;hints&lt;/CODE&gt; is null),
     * the interpolation type is {@link #TYPE_NEAREST_NEIGHBOR
     * TYPE_NEAREST_NEIGHBOR}.
     *
     * @param xform The &lt;CODE&gt;AffineTransform&lt;/CODE&gt; to use for the
     * operation.
     *
     * @param hints The &lt;CODE&gt;RenderingHints&lt;/CODE&gt; object used to specify
     * the interpolation type for the operation.
     *
     * @throws ImagingOpException if the transform is non-invertible.
     * @see java.awt.RenderingHints#KEY_INTERPOLATION
     * @see java.awt.RenderingHints#KEY_RENDERING
     */
    public AffineTransformOp(AffineTransform xform, RenderingHints hints){
        validateTransform(xform);
        this.xform = (AffineTransform) xform.clone();
        this.hints = hints;

        if (hints != null) {
            Object value = hints.get(hints.KEY_INTERPOLATION);
            if (value == null) {
                value = hints.get(hints.KEY_RENDERING);
                if (value == hints.VALUE_RENDER_SPEED) {
                    interpolationType = TYPE_NEAREST_NEIGHBOR;
                }
                else if (value == hints.VALUE_RENDER_QUALITY) {
                    interpolationType = TYPE_BILINEAR;
                }
            }
            else if (value == hints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR) {
                interpolationType = TYPE_NEAREST_NEIGHBOR;
            }
            else if (value == hints.VALUE_INTERPOLATION_BILINEAR) {
                interpolationType = TYPE_BILINEAR;
            }
            else if (value == hints.VALUE_INTERPOLATION_BICUBIC) {
                interpolationType = TYPE_BICUBIC;
            }
        }
        else {
            interpolationType = TYPE_NEAREST_NEIGHBOR;
        }
    }

    /**
     * Constructs an &lt;CODE&gt;AffineTransformOp&lt;/CODE&gt; given an affine transform
     * and the interpolation type.
     *
     * @param xform The &lt;CODE&gt;AffineTransform&lt;/CODE&gt; to use for the operation.
     * @param interpolationType One of the integer
     * interpolation type constants defined by this class:
     * {@link #TYPE_NEAREST_NEIGHBOR TYPE_NEAREST_NEIGHBOR},
     * {@link #TYPE_BILINEAR TYPE_BILINEAR},
     * {@link #TYPE_BICUBIC TYPE_BICUBIC}.
     * @throws ImagingOpException if the transform is non-invertible.
     */
    public AffineTransformOp(AffineTransform xform, int interpolationType) {
        validateTransform(xform);
        this.xform = (AffineTransform)xform.clone();
        switch(interpolationType) {
            case TYPE_NEAREST_NEIGHBOR:
            case TYPE_BILINEAR:
            case TYPE_BICUBIC:
                break;
        default:
            throw new IllegalArgumentException(&quot;Unknown interpolation type: &quot;+
                                               interpolationType);
        }
        this.interpolationType = interpolationType;
    }

    /**
     * Returns the interpolation type used by this op.
     * @return the interpolation type.
     * @see #TYPE_NEAREST_NEIGHBOR
     * @see #TYPE_BILINEAR
     * @see #TYPE_BICUBIC
     */
    public final int getInterpolationType() {
        return interpolationType;
    }

    /**
     * Transforms the source &lt;CODE&gt;BufferedImage&lt;/CODE&gt; and stores the results
     * in the destination &lt;CODE&gt;BufferedImage&lt;/CODE&gt;.
     * If the color models for the two images do not match, a color
     * conversion into the destination color model is performed.
     * If the destination image is null,
     * a &lt;CODE&gt;BufferedImage&lt;/CODE&gt; is created with the source
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * &lt;p&gt;
     * The coordinates of the rectangle returned by
     * &lt;code&gt;getBounds2D(BufferedImage)&lt;/code&gt;
     * are not necessarily the same as the coordinates of the
     * &lt;code&gt;BufferedImage&lt;/code&gt; returned by this method.  If the
     * upper-left corner coordinates of the rectangle are
     * negative then this part of the rectangle is not drawn.  If the
     * upper-left corner coordinates of the  rectangle are positive
     * then the filtered image is drawn at that position in the
     * destination &lt;code&gt;BufferedImage&lt;/code&gt;.
     * &lt;p&gt;
     * An &lt;CODE&gt;IllegalArgumentException&lt;/CODE&gt; is thrown if the source is
     * the same as the destination.
     *
     * @param src The &lt;CODE&gt;BufferedImage&lt;/CODE&gt; to transform.
     * @param dst The &lt;CODE&gt;BufferedImage&lt;/CODE&gt; in which to store the results
     * of the transformation.
     *
     * @return The filtered &lt;CODE&gt;BufferedImage&lt;/CODE&gt;.
     * @throws IllegalArgumentException if &lt;code&gt;src&lt;/code&gt; and
     *         &lt;code&gt;dst&lt;/code&gt; are the same
     * @throws ImagingOpException if the image cannot be transformed
     *         because of a data-processing error that might be
     *         caused by an invalid image format, tile format, or
     *         image-processing operation, or any other unsupported
     *         operation.
     */
    public final BufferedImage filter(BufferedImage src, BufferedImage dst) {

        if (src == null) {
            throw new NullPointerException(&quot;src image is null&quot;);
        }
        if (src == dst) {
            throw new IllegalArgumentException(&quot;src image cannot be the &quot;+
                                               &quot;same as the dst image&quot;);
        }

        boolean needToConvert = false;
        ColorModel srcCM = src.getColorModel();
        ColorModel dstCM;
        BufferedImage origDst = dst;

        if (dst == null) {
            dst = createCompatibleDestImage(src, null);
            dstCM = srcCM;
            origDst = dst;
        }
        else {
            dstCM = dst.getColorModel();
            if (srcCM.getColorSpace().getType() !=
                dstCM.getColorSpace().getType())
            {
                int type = xform.getType();
                boolean needTrans = ((type&amp;
                                      (xform.TYPE_MASK_ROTATION|
                                       xform.TYPE_GENERAL_TRANSFORM))
                                     != 0);
                if (! needTrans &amp;&amp; type != xform.TYPE_TRANSLATION &amp;&amp; type != xform.TYPE_IDENTITY)
                {
                    double[] mtx = new double[4];
                    xform.getMatrix(mtx);
                    // Check out the matrix.  A non-integral scale will force ARGB
                    // since the edge conditions can't be guaranteed.
                    needTrans = (mtx[0] != (int)mtx[0] || mtx[3] != (int)mtx[3]);
                }

                if (needTrans &amp;&amp;
                    srcCM.getTransparency() == Transparency.OPAQUE)
                {
                    // Need to convert first
                    ColorConvertOp ccop = new ColorConvertOp(hints);
                    BufferedImage tmpSrc = null;
                    int sw = src.getWidth();
                    int sh = src.getHeight();
                    if (dstCM.getTransparency() == Transparency.OPAQUE) {
                        tmpSrc = new BufferedImage(sw, sh,
                                                  BufferedImage.TYPE_INT_ARGB);
                    }
                    else {
                        WritableRaster r =
                            dstCM.createCompatibleWritableRaster(sw, sh);
                        tmpSrc = new BufferedImage(dstCM, r,
                                                  dstCM.isAlphaPremultiplied(),
                                                  null);
                    }
                    src = ccop.filter(src, tmpSrc);
                }
                else {
                    needToConvert = true;
                    dst = createCompatibleDestImage(src, null);
                }
            }

        }

        if (interpolationType != TYPE_NEAREST_NEIGHBOR &amp;&amp;
            dst.getColorModel() instanceof IndexColorModel) {
            dst = new BufferedImage(dst.getWidth(), dst.getHeight(),
                                    BufferedImage.TYPE_INT_ARGB);
        }
        if (ImagingLib.filter(this, src, dst) == null) {
            throw new ImagingOpException (&quot;Unable to transform src image&quot;);
        }

        if (needToConvert) {
            ColorConvertOp ccop = new ColorConvertOp(hints);
            ccop.filter(dst, origDst);
        }
        else if (origDst != dst) {
            java.awt.Graphics2D g = origDst.createGraphics();
            try {
                g.setComposite(AlphaComposite.Src);
                g.drawImage(dst, 0, 0, null);
            } finally {
                g.dispose();
            }
        }

        return origDst;
    }

    /**
     * Transforms the source &lt;CODE&gt;Raster&lt;/CODE&gt; and stores the results in
     * the destination &lt;CODE&gt;Raster&lt;/CODE&gt;.  This operation performs the
     * transform band by band.
     * &lt;p&gt;
     * If the destination &lt;CODE&gt;Raster&lt;/CODE&gt; is null, a new
     * &lt;CODE&gt;Raster&lt;/CODE&gt; is created.
     * An &lt;CODE&gt;IllegalArgumentException&lt;/CODE&gt; may be thrown if the source is
     * the same as the destination or if the number of bands in
     * the source is not equal to the number of bands in the
     * destination.
     * &lt;p&gt;
     * The coordinates of the rectangle returned by
     * &lt;code&gt;getBounds2D(Raster)&lt;/code&gt;
     * are not necessarily the same as the coordinates of the
     * &lt;code&gt;WritableRaster&lt;/code&gt; returned by this method.  If the
     * upper-left corner coordinates of rectangle are negative then
     * this part of the rectangle is not drawn.  If the coordinates
     * of the rectangle are positive then the filtered image is drawn at
     * that position in the destination &lt;code&gt;Raster&lt;/code&gt;.
     * &lt;p&gt;
     * @param src The &lt;CODE&gt;Raster&lt;/CODE&gt; to transform.
     * @param dst The &lt;CODE&gt;Raster&lt;/CODE&gt; in which to store the results of the
     * transformation.
     *
     * @return The transformed &lt;CODE&gt;Raster&lt;/CODE&gt;.
     *
     * @throws ImagingOpException if the raster cannot be transformed
     *         because of a data-processing error that might be
     *         caused by an invalid image format, tile format, or
     *         image-processing operation, or any other unsupported
     *         operation.
     */
    public final WritableRaster filter(Raster src, WritableRaster dst) {
        if (src == null) {
            throw new NullPointerException(&quot;src image is null&quot;);
        }
        if (dst == null) {
            dst = createCompatibleDestRaster(src);
        }
        if (src == dst) {
            throw new IllegalArgumentException(&quot;src image cannot be the &quot;+
                                               &quot;same as the dst image&quot;);
        }
        if (src.getNumBands() != dst.getNumBands()) {
            throw new IllegalArgumentException(&quot;Number of src bands (&quot;+
                                               src.getNumBands()+
                                               &quot;) does not match number of &quot;+
                                               &quot; dst bands (&quot;+
                                               dst.getNumBands()+&quot;)&quot;);
        }

        if (ImagingLib.filter(this, src, dst) == null) {
            throw new ImagingOpException (&quot;Unable to transform src image&quot;);
        }
        return dst;
    }

    /**
     * Returns the bounding box of the transformed destination.  The
     * rectangle returned is the actual bounding box of the
     * transformed points.  The coordinates of the upper-left corner
     * of the returned rectangle might not be (0,&amp;nbsp;0).
     *
     * @param src The &lt;CODE&gt;BufferedImage&lt;/CODE&gt; to be transformed.
     *
     * @return The &lt;CODE&gt;Rectangle2D&lt;/CODE&gt; representing the destination's
     * bounding box.
     */
    public final Rectangle2D getBounds2D (BufferedImage src) {
        return getBounds2D(src.getRaster());
    }

    /**
     * Returns the bounding box of the transformed destination.  The
     * rectangle returned will be the actual bounding box of the
     * transformed points.  The coordinates of the upper-left corner
     * of the returned rectangle might not be (0,&amp;nbsp;0).
     *
     * @param src The &lt;CODE&gt;Raster&lt;/CODE&gt; to be transformed.
     *
     * @return The &lt;CODE&gt;Rectangle2D&lt;/CODE&gt; representing the destination's
     * bounding box.
     */
    public final Rectangle2D getBounds2D (Raster src) {
        int w = src.getWidth();
        int h = src.getHeight();

        // Get the bounding box of the src and transform the corners
        float[] pts = {0, 0, w, 0, w, h, 0, h};
        xform.transform(pts, 0, pts, 0, 4);

        // Get the min, max of the dst
        float fmaxX = pts[0];
        float fmaxY = pts[1];
        float fminX = pts[0];
        float fminY = pts[1];
        for (int i=2; i &lt; 8; i+=2) {
            if (pts[i] &gt; fmaxX) {
                fmaxX = pts[i];
            }
            else if (pts[i] &lt; fminX) {
                fminX = pts[i];
            }
            if (pts[i+1] &gt; fmaxY) {
                fmaxY = pts[i+1];
            }
            else if (pts[i+1] &lt; fminY) {
                fminY = pts[i+1];
            }
        }

        return new Rectangle2D.Float(fminX, fminY, fmaxX-fminX, fmaxY-fminY);
    }

    /**
     * Creates a zeroed destination image with the correct size and number of
     * bands.  A &lt;CODE&gt;RasterFormatException&lt;/CODE&gt; may be thrown if the
     * transformed width or height is equal to 0.
     * &lt;p&gt;
     * If &lt;CODE&gt;destCM&lt;/CODE&gt; is null,
     * an appropriate &lt;CODE&gt;ColorModel&lt;/CODE&gt; is used; this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt; may have
     * an alpha channel even if the source &lt;CODE&gt;ColorModel&lt;/CODE&gt; is opaque.
     *
     * @param src  The &lt;CODE&gt;BufferedImage&lt;/CODE&gt; to be transformed.
     * @param destCM  &lt;CODE&gt;ColorModel&lt;/CODE&gt; of the destination.  If null,
     * an appropriate &lt;CODE&gt;ColorModel&lt;/CODE&gt; is used.
     *
     * @return The zeroed destination image.
     */
    public BufferedImage createCompatibleDestImage (BufferedImage src,
                                                    ColorModel destCM) {
        BufferedImage image;
        Rectangle r = getBounds2D(src).getBounds();

        // If r.x (or r.y) is &lt; 0, then we want to only create an image
        // that is in the positive range.
        // If r.x (or r.y) is &gt; 0, then we need to create an image that
        // includes the translation.
        int w = r.x + r.width;
        int h = r.y + r.height;
        if (w &lt;= 0) {
            throw new RasterFormatException(&quot;Transformed width (&quot;+w+
                                            &quot;) is less than or equal to 0.&quot;);
        }
        if (h &lt;= 0) {
            throw new RasterFormatException(&quot;Transformed height (&quot;+h+
                                            &quot;) is less than or equal to 0.&quot;);
        }

        if (destCM == null) {
            ColorModel cm = src.getColorModel();
            if (interpolationType != TYPE_NEAREST_NEIGHBOR &amp;&amp;
                (cm instanceof IndexColorModel ||
                 cm.getTransparency() == Transparency.OPAQUE))
            {
                image = new BufferedImage(w, h,
                                          BufferedImage.TYPE_INT_ARGB);
            }
            else {
                image = new BufferedImage(cm,
                          src.getRaster().createCompatibleWritableRaster(w,h),
                          cm.isAlphaPremultiplied(), null);
            }
        }
        else {
            image = new BufferedImage(destCM,
                                    destCM.createCompatibleWritableRaster(w,h),
                                    destCM.isAlphaPremultiplied(), null);
        }

        return image;
    }

    /**
     * Creates a zeroed destination &lt;CODE&gt;Raster&lt;/CODE&gt; with the correct size
     * and number of bands.  A &lt;CODE&gt;RasterFormatException&lt;/CODE&gt; may be thrown
     * if the transformed width or height is equal to 0.
     *
     * @param src The &lt;CODE&gt;Raster&lt;/CODE&gt; to be transformed.
     *
     * @return The zeroed destination &lt;CODE&gt;Raster&lt;/CODE&gt;.
     */
    public WritableRaster createCompatibleDestRaster (Raster src) {
        Rectangle2D r = getBounds2D(src);

        return src.createCompatibleWritableRaster((int)r.getX(),
                                                  (int)r.getY(),
                                                  (int)r.getWidth(),
                                                  (int)r.getHeight());
    }

    /**
     * Returns the location of the corresponding destination point given a
     * point in the source.  If &lt;CODE&gt;dstPt&lt;/CODE&gt; is specified, it
     * is used to hold the return value.
     *
     * @param srcPt The &lt;code&gt;Point2D&lt;/code&gt; that represents the source
     *              point.
     * @param dstPt The &lt;CODE&gt;Point2D&lt;/CODE&gt; in which to store the result.
     *
     * @return The &lt;CODE&gt;Point2D&lt;/CODE&gt; in the destination that corresponds to
     * the specified point in the source.
     */
    public final Point2D getPoint2D (Point2D srcPt, Point2D dstPt) {
        return xform.transform (srcPt, dstPt);
    }

    /**
     * Returns the affine transform used by this transform operation.
     *
     * @return The &lt;CODE&gt;AffineTransform&lt;/CODE&gt; associated with this op.
     */
    public final AffineTransform getTransform() {
        return (AffineTransform) xform.clone();
    }

    /**
     * Returns the rendering hints used by this transform operation.
     *
     * @return The &lt;CODE&gt;RenderingHints&lt;/CODE&gt; object associated with this op.
     */
    public final RenderingHints getRenderingHints() {
        if (hints == null) {
            Object val;
            switch(interpolationType) {
            case TYPE_NEAREST_NEIGHBOR:
                val = RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR;
                break;
            case TYPE_BILINEAR:
                val = RenderingHints.VALUE_INTERPOLATION_BILINEAR;
                break;
            case TYPE_BICUBIC:
                val = RenderingHints.VALUE_INTERPOLATION_BICUBIC;
                break;
            default:
                // Should never get here
                throw new InternalError(&quot;Unknown interpolation type &quot;+
                                         interpolationType);

            }
            hints = new RenderingHints(RenderingHints.KEY_INTERPOLATION, val);
        }

        return hints;
    }

    // We need to be able to invert the transform if we want to
    // transform the image.  If the determinant of the matrix is 0,
    // then we can't invert the transform.
    void validateTransform(AffineTransform xform) {
        if (Math.abs(xform.getDeterminant()) &lt;= Double.MIN_VALUE) {
            throw new ImagingOpException(&quot;Unable to invert transform &quot;+xform);
        }
    }
}
</pre>
</body>
</html>
