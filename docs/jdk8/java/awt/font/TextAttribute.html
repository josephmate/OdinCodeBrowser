<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996 - 1997, All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - 1998, All Rights Reserved
 *
 * The original version of this source code and documentation is
 * copyrighted and owned by Taligent, Inc., a wholly-owned subsidiary
 * of IBM. These materials are provided under terms of a License
 * Agreement between Taligent and Sun. This technology is protected
 * by multiple US and International patents.
 *
 * This notice and attribution to Taligent may not be removed.
 * Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.awt.font;

import java.io.InvalidObjectException;
import java.text.AttributedCharacterIterator.Attribute;
import java.util.Map;
import java.util.HashMap;

/**
 * The &lt;code&gt;TextAttribute&lt;/code&gt; class defines attribute keys and
 * attribute values used for text rendering.
 * &lt;p&gt;
 * &lt;code&gt;TextAttribute&lt;/code&gt; instances are used as attribute keys to
 * identify attributes in
 * {@link java.awt.Font Font},
 * {@link java.awt.font.TextLayout TextLayout},
 * {@link java.text.AttributedCharacterIterator AttributedCharacterIterator},
 * and other classes handling text attributes. Other constants defined
 * in this class can be used as attribute values.
 * &lt;p&gt;
 * For each text attribute, the documentation provides:
 * &lt;UL&gt;
 *   &lt;LI&gt;the type of its value,
 *   &lt;LI&gt;the relevant predefined constants, if any
 *   &lt;LI&gt;the default effect if the attribute is absent
 *   &lt;LI&gt;the valid values if there are limitations
 *   &lt;LI&gt;a description of the effect.
 * &lt;/UL&gt;
 * &lt;p&gt;
 * &lt;H3&gt;Values&lt;/H3&gt;
 * &lt;UL&gt;
 *   &lt;LI&gt;The values of attributes must always be immutable.
 *   &lt;LI&gt;Where value limitations are given, any value outside of that
 *   set is reserved for future use; the value will be treated as
 *   the default.
 *   &lt;LI&gt;The value &lt;code&gt;null&lt;/code&gt; is treated the same as the
 *   default value and results in the default behavior.
 *   &lt;li&gt;If the value is not of the proper type, the attribute
 *   will be ignored.
 *   &lt;li&gt;The identity of the value does not matter, only the actual
 *   value.  For example, &lt;code&gt;TextAttribute.WEIGHT_BOLD&lt;/code&gt; and
 *   &lt;code&gt;new Float(2.0)&lt;/code&gt;
 *   indicate the same &lt;code&gt;WEIGHT&lt;/code&gt;.
 *   &lt;li&gt;Attribute values of type &lt;code&gt;Number&lt;/code&gt; (used for
 *   &lt;code&gt;WEIGHT&lt;/code&gt;, &lt;code&gt;WIDTH&lt;/code&gt;, &lt;code&gt;POSTURE&lt;/code&gt;,
 *   &lt;code&gt;SIZE&lt;/code&gt;, &lt;code&gt;JUSTIFICATION&lt;/code&gt;, and
 *   &lt;code&gt;TRACKING&lt;/code&gt;) can vary along their natural range and are
 *   not restricted to the predefined constants.
 *   &lt;code&gt;Number.floatValue()&lt;/code&gt; is used to get the actual value
 *   from the &lt;code&gt;Number&lt;/code&gt;.
 *   &lt;li&gt;The values for &lt;code&gt;WEIGHT&lt;/code&gt;, &lt;code&gt;WIDTH&lt;/code&gt;, and
 *   &lt;code&gt;POSTURE&lt;/code&gt; are interpolated by the system, which
 *   can select the 'nearest available' font or use other techniques to
 *   approximate the user's request.
 *
 * &lt;/UL&gt;
 *
 * &lt;h4&gt;Summary of attributes&lt;/h4&gt;
 * &lt;p&gt;
 * &lt;table style=&quot;float:center&quot; border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;%95&quot;
 *     summary=&quot;Key, value type, principal constants, and default value
 *     behavior of all TextAttributes&quot;&gt;
 * &lt;tr style=&quot;background-color:#ccccff&quot;&gt;
 * &lt;th valign=&quot;TOP&quot; align=&quot;CENTER&quot;&gt;Key&lt;/th&gt;
 * &lt;th valign=&quot;TOP&quot; align=&quot;CENTER&quot;&gt;Value Type&lt;/th&gt;
 * &lt;th valign=&quot;TOP&quot; align=&quot;CENTER&quot;&gt;Principal Constants&lt;/th&gt;
 * &lt;th valign=&quot;TOP&quot; align=&quot;CENTER&quot;&gt;Default Value&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #FAMILY}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;String&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;See Font {@link java.awt.Font#DIALOG DIALOG},
 * {@link java.awt.Font#DIALOG_INPUT DIALOG_INPUT},&lt;br&gt; {@link java.awt.Font#SERIF SERIF},
 * {@link java.awt.Font#SANS_SERIF SANS_SERIF}, and {@link java.awt.Font#MONOSPACED MONOSPACED}.
 * &lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;&quot;Default&quot; (use platform default)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr style=&quot;background-color:#eeeeff&quot;&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #WEIGHT}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;Number&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;WEIGHT_REGULAR, WEIGHT_BOLD&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;WEIGHT_REGULAR&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #WIDTH}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;Number&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;WIDTH_CONDENSED, WIDTH_REGULAR,&lt;br&gt;WIDTH_EXTENDED&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;WIDTH_REGULAR&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr style=&quot;background-color:#eeeeff&quot;&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #POSTURE}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;Number&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;POSTURE_REGULAR, POSTURE_OBLIQUE&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;POSTURE_REGULAR&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #SIZE}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;Number&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;none&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;12.0&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr style=&quot;background-color:#eeeeff&quot;&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #TRANSFORM}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link TransformAttribute}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;See TransformAttribute {@link TransformAttribute#IDENTITY IDENTITY}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;TransformAttribute.IDENTITY&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #SUPERSCRIPT}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;Integer&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;SUPERSCRIPT_SUPER, SUPERSCRIPT_SUB&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;0 (use the standard glyphs and metrics)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr style=&quot;background-color:#eeeeff&quot;&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #FONT}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link java.awt.Font}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;none&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;null (do not override font resolution)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #CHAR_REPLACEMENT}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link GraphicAttribute}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;none&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;null (draw text using font glyphs)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr style=&quot;background-color:#eeeeff&quot;&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #FOREGROUND}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link java.awt.Paint}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;none&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;null (use current graphics paint)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #BACKGROUND}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link java.awt.Paint}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;none&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;null (do not render background)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr style=&quot;background-color:#eeeeff&quot;&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #UNDERLINE}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;Integer&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;UNDERLINE_ON&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;-1 (do not render underline)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #STRIKETHROUGH}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;Boolean&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;STRIKETHROUGH_ON&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;false (do not render strikethrough)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr style=&quot;background-color:#eeeeff&quot;&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #RUN_DIRECTION}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;Boolean&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;RUN_DIRECTION_LTR&lt;br&gt;RUN_DIRECTION_RTL&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;null (use {@link java.text.Bidi} standard default)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #BIDI_EMBEDDING}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;Integer&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;none&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;0 (use base line direction)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr style=&quot;background-color:#eeeeff&quot;&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #JUSTIFICATION}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;Number&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;JUSTIFICATION_FULL&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;JUSTIFICATION_FULL&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #INPUT_METHOD_HIGHLIGHT}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link java.awt.im.InputMethodHighlight},&lt;br&gt;{@link java.text.Annotation}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;(see class)&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;null (do not apply input highlighting)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr style=&quot;background-color:#eeeeff&quot;&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #INPUT_METHOD_UNDERLINE}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;Integer&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;UNDERLINE_LOW_ONE_PIXEL,&lt;br&gt;UNDERLINE_LOW_TWO_PIXEL&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;-1 (do not render underline)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #SWAP_COLORS}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;Boolean&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;SWAP_COLORS_ON&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;false (do not swap colors)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr style=&quot;background-color:#eeeeff&quot;&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #NUMERIC_SHAPING}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link java.awt.font.NumericShaper}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;none&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;null (do not shape digits)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #KERNING}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;Integer&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;KERNING_ON&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;0 (do not request kerning)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr style=&quot;background-color:#eeeeff&quot;&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #LIGATURES}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;Integer&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;LIGATURES_ON&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;0 (do not form optional ligatures)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;{@link #TRACKING}&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;Number&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;TRACKING_LOOSE, TRACKING_TIGHT&lt;/td&gt;
 * &lt;td valign=&quot;TOP&quot;&gt;0 (do not add tracking)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;
 *
 * @see java.awt.Font
 * @see java.awt.font.TextLayout
 * @see java.text.AttributedCharacterIterator
 */
public final class TextAttribute extends Attribute {

    // table of all instances in this class, used by readResolve
    private static final Map&lt;String, TextAttribute&gt;
            instanceMap = new HashMap&lt;String, TextAttribute&gt;(29);

    /**
     * Constructs a &lt;code&gt;TextAttribute&lt;/code&gt; with the specified name.
     * @param name the attribute name to assign to this
     * &lt;code&gt;TextAttribute&lt;/code&gt;
     */
    protected TextAttribute(String name) {
        super(name);
        if (this.getClass() == TextAttribute.class) {
            instanceMap.put(name, this);
        }
    }

    /**
     * Resolves instances being deserialized to the predefined constants.
     */
    protected Object readResolve() throws InvalidObjectException {
        if (this.getClass() != TextAttribute.class) {
            throw new InvalidObjectException(
                &quot;subclass didn't correctly implement readResolve&quot;);
        }

        TextAttribute instance = instanceMap.get(getName());
        if (instance != null) {
            return instance;
        } else {
            throw new InvalidObjectException(&quot;unknown attribute name&quot;);
        }
    }

    // Serialization compatibility with Java 2 platform v1.2.
    // 1.2 will throw an InvalidObjectException if ever asked to
    // deserialize INPUT_METHOD_UNDERLINE.
    // This shouldn't happen in real life.
    static final long serialVersionUID = 7744112784117861702L;

    //
    // For use with Font.
    //

    /**
     * Attribute key for the font name.  Values are instances of
     * &lt;b&gt;&lt;code&gt;String&lt;/code&gt;&lt;/b&gt;.  The default value is
     * &lt;code&gt;&quot;Default&quot;&lt;/code&gt;, which causes the platform default font
     * family to be used.
     *
     * &lt;p&gt; The &lt;code&gt;Font&lt;/code&gt; class defines constants for the logical
     * font names
     * {@link java.awt.Font#DIALOG DIALOG},
     * {@link java.awt.Font#DIALOG_INPUT DIALOG_INPUT},
     * {@link java.awt.Font#SANS_SERIF SANS_SERIF},
     * {@link java.awt.Font#SERIF SERIF}, and
     * {@link java.awt.Font#MONOSPACED MONOSPACED}.
     *
     * &lt;p&gt;This defines the value passed as &lt;code&gt;name&lt;/code&gt; to the
     * &lt;code&gt;Font&lt;/code&gt; constructor.  Both logical and physical
     * font names are allowed. If a font with the requested name
     * is not found, the default font is used.
     *
     * &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This attribute is unfortunately misnamed, as
     * it specifies the face name and not just the family.  Thus
     * values such as &quot;Lucida Sans Bold&quot; will select that face if it
     * exists.  Note, though, that if the requested face does not
     * exist, the default will be used with &lt;em&gt;regular&lt;/em&gt; weight.
     * The &quot;Bold&quot; in the name is part of the face name, not a separate
     * request that the font's weight be bold.&lt;/p&gt;
     */
    public static final TextAttribute FAMILY =
        new TextAttribute(&quot;family&quot;);

    /**
     * Attribute key for the weight of a font.  Values are instances
     * of &lt;b&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/b&gt;.  The default value is
     * &lt;code&gt;WEIGHT_REGULAR&lt;/code&gt;.
     *
     * &lt;p&gt;Several constant values are provided, see {@link
     * #WEIGHT_EXTRA_LIGHT}, {@link #WEIGHT_LIGHT}, {@link
     * #WEIGHT_DEMILIGHT}, {@link #WEIGHT_REGULAR}, {@link
     * #WEIGHT_SEMIBOLD}, {@link #WEIGHT_MEDIUM}, {@link
     * #WEIGHT_DEMIBOLD}, {@link #WEIGHT_BOLD}, {@link #WEIGHT_HEAVY},
     * {@link #WEIGHT_EXTRABOLD}, and {@link #WEIGHT_ULTRABOLD}.  The
     * value &lt;code&gt;WEIGHT_BOLD&lt;/code&gt; corresponds to the
     * style value &lt;code&gt;Font.BOLD&lt;/code&gt; as passed to the
     * &lt;code&gt;Font&lt;/code&gt; constructor.
     *
     * &lt;p&gt;The value is roughly the ratio of the stem width to that of
     * the regular weight.
     *
     * &lt;p&gt;The system can interpolate the provided value.
     */
    public static final TextAttribute WEIGHT =
        new TextAttribute(&quot;weight&quot;);

    /**
     * The lightest predefined weight.
     * @see #WEIGHT
     */
    public static final Float WEIGHT_EXTRA_LIGHT =
        Float.valueOf(0.5f);

    /**
     * The standard light weight.
     * @see #WEIGHT
     */
    public static final Float WEIGHT_LIGHT =
        Float.valueOf(0.75f);

    /**
     * An intermediate weight between &lt;code&gt;WEIGHT_LIGHT&lt;/code&gt; and
     * &lt;code&gt;WEIGHT_STANDARD&lt;/code&gt;.
     * @see #WEIGHT
     */
    public static final Float WEIGHT_DEMILIGHT =
        Float.valueOf(0.875f);

    /**
     * The standard weight. This is the default value for &lt;code&gt;WEIGHT&lt;/code&gt;.
     * @see #WEIGHT
     */
    public static final Float WEIGHT_REGULAR =
        Float.valueOf(1.0f);

    /**
     * A moderately heavier weight than &lt;code&gt;WEIGHT_REGULAR&lt;/code&gt;.
     * @see #WEIGHT
     */
    public static final Float WEIGHT_SEMIBOLD =
        Float.valueOf(1.25f);

    /**
     * An intermediate weight between &lt;code&gt;WEIGHT_REGULAR&lt;/code&gt; and
     * &lt;code&gt;WEIGHT_BOLD&lt;/code&gt;.
     * @see #WEIGHT
     */
    public static final Float WEIGHT_MEDIUM =
        Float.valueOf(1.5f);

    /**
     * A moderately lighter weight than &lt;code&gt;WEIGHT_BOLD&lt;/code&gt;.
     * @see #WEIGHT
     */
    public static final Float WEIGHT_DEMIBOLD =
        Float.valueOf(1.75f);

    /**
     * The standard bold weight.
     * @see #WEIGHT
     */
    public static final Float WEIGHT_BOLD =
        Float.valueOf(2.0f);

    /**
     * A moderately heavier weight than &lt;code&gt;WEIGHT_BOLD&lt;/code&gt;.
     * @see #WEIGHT
     */
    public static final Float WEIGHT_HEAVY =
        Float.valueOf(2.25f);

    /**
     * An extra heavy weight.
     * @see #WEIGHT
     */
    public static final Float WEIGHT_EXTRABOLD =
        Float.valueOf(2.5f);

    /**
     * The heaviest predefined weight.
     * @see #WEIGHT
     */
    public static final Float WEIGHT_ULTRABOLD =
        Float.valueOf(2.75f);

    /**
     * Attribute key for the width of a font.  Values are instances of
     * &lt;b&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/b&gt;.  The default value is
     * &lt;code&gt;WIDTH_REGULAR&lt;/code&gt;.
     *
     * &lt;p&gt;Several constant values are provided, see {@link
     * #WIDTH_CONDENSED}, {@link #WIDTH_SEMI_CONDENSED}, {@link
     * #WIDTH_REGULAR}, {@link #WIDTH_SEMI_EXTENDED}, {@link
     * #WIDTH_EXTENDED}.
     *
     * &lt;p&gt;The value is roughly the ratio of the advance width to that
     * of the regular width.
     *
     * &lt;p&gt;The system can interpolate the provided value.
     */
    public static final TextAttribute WIDTH =
        new TextAttribute(&quot;width&quot;);

    /**
     * The most condensed predefined width.
     * @see #WIDTH
     */
    public static final Float WIDTH_CONDENSED =
        Float.valueOf(0.75f);

    /**
     * A moderately condensed width.
     * @see #WIDTH
     */
    public static final Float WIDTH_SEMI_CONDENSED =
        Float.valueOf(0.875f);

    /**
     * The standard width. This is the default value for
     * &lt;code&gt;WIDTH&lt;/code&gt;.
     * @see #WIDTH
     */
    public static final Float WIDTH_REGULAR =
        Float.valueOf(1.0f);

    /**
     * A moderately extended width.
     * @see #WIDTH
     */
    public static final Float WIDTH_SEMI_EXTENDED =
        Float.valueOf(1.25f);

    /**
     * The most extended predefined width.
     * @see #WIDTH
     */
    public static final Float WIDTH_EXTENDED =
        Float.valueOf(1.5f);

    /**
     * Attribute key for the posture of a font.  Values are instances
     * of &lt;b&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/b&gt;. The default value is
     * &lt;code&gt;POSTURE_REGULAR&lt;/code&gt;.
     *
     * &lt;p&gt;Two constant values are provided, {@link #POSTURE_REGULAR}
     * and {@link #POSTURE_OBLIQUE}. The value
     * &lt;code&gt;POSTURE_OBLIQUE&lt;/code&gt; corresponds to the style value
     * &lt;code&gt;Font.ITALIC&lt;/code&gt; as passed to the &lt;code&gt;Font&lt;/code&gt;
     * constructor.
     *
     * &lt;p&gt;The value is roughly the slope of the stems of the font,
     * expressed as the run over the rise.  Positive values lean right.
     *
     * &lt;p&gt;The system can interpolate the provided value.
     *
     * &lt;p&gt;This will affect the font's italic angle as returned by
     * &lt;code&gt;Font.getItalicAngle&lt;/code&gt;.
     *
     * @see java.awt.Font#getItalicAngle()
     */
    public static final TextAttribute POSTURE =
        new TextAttribute(&quot;posture&quot;);

    /**
     * The standard posture, upright.  This is the default value for
     * &lt;code&gt;POSTURE&lt;/code&gt;.
     * @see #POSTURE
     */
    public static final Float POSTURE_REGULAR =
        Float.valueOf(0.0f);

    /**
     * The standard italic posture.
     * @see #POSTURE
     */
    public static final Float POSTURE_OBLIQUE =
        Float.valueOf(0.20f);

    /**
     * Attribute key for the font size.  Values are instances of
     * &lt;b&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/b&gt;.  The default value is 12pt.
     *
     * &lt;p&gt;This corresponds to the &lt;code&gt;size&lt;/code&gt; parameter to the
     * &lt;code&gt;Font&lt;/code&gt; constructor.
     *
     * &lt;p&gt;Very large or small sizes will impact rendering performance,
     * and the rendering system might not render text at these sizes.
     * Negative sizes are illegal and result in the default size.
     *
     * &lt;p&gt;Note that the appearance and metrics of a 12pt font with a
     * 2x transform might be different than that of a 24 point font
     * with no transform.
     */
    public static final TextAttribute SIZE =
        new TextAttribute(&quot;size&quot;);

    /**
     * Attribute key for the transform of a font.  Values are
     * instances of &lt;b&gt;&lt;code&gt;TransformAttribute&lt;/code&gt;&lt;/b&gt;.  The
     * default value is &lt;code&gt;TransformAttribute.IDENTITY&lt;/code&gt;.
     *
     * &lt;p&gt;The &lt;code&gt;TransformAttribute&lt;/code&gt; class defines the
     * constant {@link TransformAttribute#IDENTITY IDENTITY}.
     *
     * &lt;p&gt;This corresponds to the transform passed to
     * &lt;code&gt;Font.deriveFont(AffineTransform)&lt;/code&gt;.  Since that
     * transform is mutable and &lt;code&gt;TextAttribute&lt;/code&gt; values must
     * not be, the &lt;code&gt;TransformAttribute&lt;/code&gt; wrapper class is
     * used.
     *
     * &lt;p&gt;The primary intent is to support scaling and skewing, though
     * other effects are possible.&lt;/p&gt;
     *
     * &lt;p&gt;Some transforms will cause the baseline to be rotated and/or
     * shifted.  The text and the baseline are transformed together so
     * that the text follows the new baseline.  For example, with text
     * on a horizontal baseline, the new baseline follows the
     * direction of the unit x vector passed through the
     * transform. Text metrics are measured against this new baseline.
     * So, for example, with other things being equal, text rendered
     * with a rotated TRANSFORM and an unrotated TRANSFORM will measure as
     * having the same ascent, descent, and advance.&lt;/p&gt;
     *
     * &lt;p&gt;In styled text, the baselines for each such run are aligned
     * one after the other to potentially create a non-linear baseline
     * for the entire run of text. For more information, see {@link
     * TextLayout#getLayoutPath}.&lt;/p&gt;
     *
     * @see TransformAttribute
     * @see java.awt.geom.AffineTransform
     */
     public static final TextAttribute TRANSFORM =
        new TextAttribute(&quot;transform&quot;);

    /**
     * Attribute key for superscripting and subscripting.  Values are
     * instances of &lt;b&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/b&gt;.  The default value is
     * 0, which means that no superscript or subscript is used.
     *
     * &lt;p&gt;Two constant values are provided, see {@link
     * #SUPERSCRIPT_SUPER} and {@link #SUPERSCRIPT_SUB}.  These have
     * the values 1 and -1 respectively.  Values of
     * greater magnitude define greater levels of superscript or
     * subscripting, for example, 2 corresponds to super-superscript,
     * 3 to super-super-superscript, and similarly for negative values
     * and subscript, up to a level of 7 (or -7).  Values beyond this
     * range are reserved; behavior is platform-dependent.
     *
     * &lt;p&gt;&lt;code&gt;SUPERSCRIPT&lt;/code&gt; can
     * impact the ascent and descent of a font.  The ascent
     * and descent can never become negative, however.
     */
    public static final TextAttribute SUPERSCRIPT =
        new TextAttribute(&quot;superscript&quot;);

    /**
     * Standard superscript.
     * @see #SUPERSCRIPT
     */
    public static final Integer SUPERSCRIPT_SUPER =
        Integer.valueOf(1);

    /**
     * Standard subscript.
     * @see #SUPERSCRIPT
     */
    public static final Integer SUPERSCRIPT_SUB =
        Integer.valueOf(-1);

    /**
     * Attribute key used to provide the font to use to render text.
     * Values are instances of {@link java.awt.Font}.  The default
     * value is null, indicating that normal resolution of a
     * &lt;code&gt;Font&lt;/code&gt; from attributes should be performed.
     *
     * &lt;p&gt;&lt;code&gt;TextLayout&lt;/code&gt; and
     * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; work in terms of
     * &lt;code&gt;Maps&lt;/code&gt; of &lt;code&gt;TextAttributes&lt;/code&gt;.  Normally,
     * all the attributes are examined and used to select and
     * configure a &lt;code&gt;Font&lt;/code&gt; instance.  If a &lt;code&gt;FONT&lt;/code&gt;
     * attribute is present, though, its associated &lt;code&gt;Font&lt;/code&gt;
     * will be used.  This provides a way for users to override the
     * resolution of font attributes into a &lt;code&gt;Font&lt;/code&gt;, or
     * force use of a particular &lt;code&gt;Font&lt;/code&gt; instance.  This
     * also allows users to specify subclasses of &lt;code&gt;Font&lt;/code&gt; in
     * cases where a &lt;code&gt;Font&lt;/code&gt; can be subclassed.
     *
     * &lt;p&gt;&lt;code&gt;FONT&lt;/code&gt; is used for special situations where
     * clients already have a &lt;code&gt;Font&lt;/code&gt; instance but still
     * need to use &lt;code&gt;Map&lt;/code&gt;-based APIs.  Typically, there will
     * be no other attributes in the &lt;code&gt;Map&lt;/code&gt; except the
     * &lt;code&gt;FONT&lt;/code&gt; attribute.  With &lt;code&gt;Map&lt;/code&gt;-based APIs
     * the common case is to specify all attributes individually, so
     * &lt;code&gt;FONT&lt;/code&gt; is not needed or desireable.
     *
     * &lt;p&gt;However, if both &lt;code&gt;FONT&lt;/code&gt; and other attributes are
     * present in the &lt;code&gt;Map&lt;/code&gt;, the rendering system will
     * merge the attributes defined in the &lt;code&gt;Font&lt;/code&gt; with the
     * additional attributes.  This merging process classifies
     * &lt;code&gt;TextAttributes&lt;/code&gt; into two groups.  One group, the
     * 'primary' group, is considered fundamental to the selection and
     * metric behavior of a font.  These attributes are
     * &lt;code&gt;FAMILY&lt;/code&gt;, &lt;code&gt;WEIGHT&lt;/code&gt;, &lt;code&gt;WIDTH&lt;/code&gt;,
     * &lt;code&gt;POSTURE&lt;/code&gt;, &lt;code&gt;SIZE&lt;/code&gt;,
     * &lt;code&gt;TRANSFORM&lt;/code&gt;, &lt;code&gt;SUPERSCRIPT&lt;/code&gt;, and
     * &lt;code&gt;TRACKING&lt;/code&gt;. The other group, the 'secondary' group,
     * consists of all other defined attributes, with the exception of
     * &lt;code&gt;FONT&lt;/code&gt; itself.
     *
     * &lt;p&gt;To generate the new &lt;code&gt;Map&lt;/code&gt;, first the
     * &lt;code&gt;Font&lt;/code&gt; is obtained from the &lt;code&gt;FONT&lt;/code&gt;
     * attribute, and &lt;em&gt;all&lt;/em&gt; of its attributes extracted into a
     * new &lt;code&gt;Map&lt;/code&gt;.  Then only the &lt;em&gt;secondary&lt;/em&gt;
     * attributes from the original &lt;code&gt;Map&lt;/code&gt; are added to
     * those in the new &lt;code&gt;Map&lt;/code&gt;.  Thus the values of primary
     * attributes come solely from the &lt;code&gt;Font&lt;/code&gt;, and the
     * values of secondary attributes originate with the
     * &lt;code&gt;Font&lt;/code&gt; but can be overridden by other values in the
     * &lt;code&gt;Map&lt;/code&gt;.
     *
     * &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;code&gt;Font's&lt;/code&gt; &lt;code&gt;Map&lt;/code&gt;-based
     * constructor and &lt;code&gt;deriveFont&lt;/code&gt; methods do not process
     * the &lt;code&gt;FONT&lt;/code&gt; attribute, as these are used to create
     * new &lt;code&gt;Font&lt;/code&gt; objects.  Instead, {@link
     * java.awt.Font#getFont(Map) Font.getFont(Map)} should be used to
     * handle the &lt;code&gt;FONT&lt;/code&gt; attribute.
     *
     * @see java.awt.Font
     */
    public static final TextAttribute FONT =
        new TextAttribute(&quot;font&quot;);

    /**
     * Attribute key for a user-defined glyph to display in lieu
     * of the font's standard glyph for a character.  Values are
     * intances of GraphicAttribute.  The default value is null,
     * indicating that the standard glyphs provided by the font
     * should be used.
     *
     * &lt;p&gt;This attribute is used to reserve space for a graphic or
     * other component embedded in a line of text.  It is required for
     * correct positioning of 'inline' components within a line when
     * bidirectional reordering (see {@link java.text.Bidi}) is
     * performed.  Each character (Unicode code point) will be
     * rendered using the provided GraphicAttribute. Typically, the
     * characters to which this attribute is applied should be
     * &lt;code&gt;&amp;#92;uFFFC&lt;/code&gt;.
     *
     * &lt;p&gt;The GraphicAttribute determines the logical and visual
     * bounds of the text; the actual Font values are ignored.
     *
     * @see GraphicAttribute
     */
    public static final TextAttribute CHAR_REPLACEMENT =
        new TextAttribute(&quot;char_replacement&quot;);

    //
    // Adornments added to text.
    //

    /**
     * Attribute key for the paint used to render the text.  Values are
     * instances of &lt;b&gt;&lt;code&gt;Paint&lt;/code&gt;&lt;/b&gt;.  The default value is
     * null, indicating that the &lt;code&gt;Paint&lt;/code&gt; set on the
     * &lt;code&gt;Graphics2D&lt;/code&gt; at the time of rendering is used.
     *
     * &lt;p&gt;Glyphs will be rendered using this
     * &lt;code&gt;Paint&lt;/code&gt; regardless of the &lt;code&gt;Paint&lt;/code&gt; value
     * set on the &lt;code&gt;Graphics&lt;/code&gt; (but see {@link #SWAP_COLORS}).
     *
     * @see java.awt.Paint
     * @see #SWAP_COLORS
     */
    public static final TextAttribute FOREGROUND =
        new TextAttribute(&quot;foreground&quot;);

    /**
     * Attribute key for the paint used to render the background of
     * the text.  Values are instances of &lt;b&gt;&lt;code&gt;Paint&lt;/code&gt;&lt;/b&gt;.
     * The default value is null, indicating that the background
     * should not be rendered.
     *
     * &lt;p&gt;The logical bounds of the text will be filled using this
     * &lt;code&gt;Paint&lt;/code&gt;, and then the text will be rendered on top
     * of it (but see {@link #SWAP_COLORS}).
     *
     * &lt;p&gt;The visual bounds of the text is extended to include the
     * logical bounds, if necessary.  The outline is not affected.
     *
     * @see java.awt.Paint
     * @see #SWAP_COLORS
     */
    public static final TextAttribute BACKGROUND =
        new TextAttribute(&quot;background&quot;);

    /**
     * Attribute key for underline.  Values are instances of
     * &lt;b&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/b&gt;.  The default value is -1, which
     * means no underline.
     *
     * &lt;p&gt;The constant value {@link #UNDERLINE_ON} is provided.
     *
     * &lt;p&gt;The underline affects both the visual bounds and the outline
     * of the text.
     */
    public static final TextAttribute UNDERLINE =
        new TextAttribute(&quot;underline&quot;);

    /**
     * Standard underline.
     *
     * @see #UNDERLINE
     */
    public static final Integer UNDERLINE_ON =
        Integer.valueOf(0);

    /**
     * Attribute key for strikethrough.  Values are instances of
     * &lt;b&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/b&gt;.  The default value is
     * &lt;code&gt;false&lt;/code&gt;, which means no strikethrough.
     *
     * &lt;p&gt;The constant value {@link #STRIKETHROUGH_ON} is provided.
     *
     * &lt;p&gt;The strikethrough affects both the visual bounds and the
     * outline of the text.
     */
    public static final TextAttribute STRIKETHROUGH =
        new TextAttribute(&quot;strikethrough&quot;);

    /**
     * A single strikethrough.
     *
     * @see #STRIKETHROUGH
     */
    public static final Boolean STRIKETHROUGH_ON =
        Boolean.TRUE;

    //
    // Attributes use to control layout of text on a line.
    //

    /**
     * Attribute key for the run direction of the line.  Values are
     * instances of &lt;b&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/b&gt;.  The default value is
     * null, which indicates that the standard Bidi algorithm for
     * determining run direction should be used with the value {@link
     * java.text.Bidi#DIRECTION_DEFAULT_LEFT_TO_RIGHT}.
     *
     * &lt;p&gt;The constants {@link #RUN_DIRECTION_RTL} and {@link
     * #RUN_DIRECTION_LTR} are provided.
     *
     * &lt;p&gt;This determines the value passed to the {@link
     * java.text.Bidi} constructor to select the primary direction of
     * the text in the paragraph.
     *
     * &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This attribute should have the same value for
     * all the text in a paragraph, otherwise the behavior is
     * undetermined.
     *
     * @see java.text.Bidi
     */
    public static final TextAttribute RUN_DIRECTION =
        new TextAttribute(&quot;run_direction&quot;);

    /**
     * Left-to-right run direction.
     * @see #RUN_DIRECTION
     */
    public static final Boolean RUN_DIRECTION_LTR =
        Boolean.FALSE;

    /**
     * Right-to-left run direction.
     * @see #RUN_DIRECTION
     */
    public static final Boolean RUN_DIRECTION_RTL =
        Boolean.TRUE;

    /**
     * Attribute key for the embedding level of the text.  Values are
     * instances of &lt;b&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/b&gt;.  The default value is
     * &lt;code&gt;null&lt;/code&gt;, indicating that the the Bidirectional
     * algorithm should run without explicit embeddings.
     *
     * &lt;p&gt;Positive values 1 through 61 are &lt;em&gt;embedding&lt;/em&gt; levels,
     * negative values -1 through -61 are &lt;em&gt;override&lt;/em&gt; levels.
     * The value 0 means that the base line direction is used.  These
     * levels are passed in the embedding levels array to the {@link
     * java.text.Bidi} constructor.
     *
     * &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; When this attribute is present anywhere in
     * a paragraph, then any Unicode bidi control characters (RLO,
     * LRO, RLE, LRE, and PDF) in the paragraph are
     * disregarded, and runs of text where this attribute is not
     * present are treated as though it were present and had the value
     * 0.
     *
     * @see java.text.Bidi
     */
    public static final TextAttribute BIDI_EMBEDDING =
        new TextAttribute(&quot;bidi_embedding&quot;);

    /**
     * Attribute key for the justification of a paragraph.  Values are
     * instances of &lt;b&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/b&gt;.  The default value is
     * 1, indicating that justification should use the full width
     * provided.  Values are pinned to the range [0..1].
     *
     * &lt;p&gt;The constants {@link #JUSTIFICATION_FULL} and {@link
     * #JUSTIFICATION_NONE} are provided.
     *
     * &lt;p&gt;Specifies the fraction of the extra space to use when
     * justification is requested on a &lt;code&gt;TextLayout&lt;/code&gt;. For
     * example, if the line is 50 points wide and it is requested to
     * justify to 70 points, a value of 0.75 will pad to use
     * three-quarters of the remaining space, or 15 points, so that
     * the resulting line will be 65 points in length.
     *
     * &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This should have the same value for all the
     * text in a paragraph, otherwise the behavior is undetermined.
     *
     * @see TextLayout#getJustifiedLayout
     */
    public static final TextAttribute JUSTIFICATION =
        new TextAttribute(&quot;justification&quot;);

    /**
     * Justify the line to the full requested width.  This is the
     * default value for &lt;code&gt;JUSTIFICATION&lt;/code&gt;.
     * @see #JUSTIFICATION
     */
    public static final Float JUSTIFICATION_FULL =
        Float.valueOf(1.0f);

    /**
     * Do not allow the line to be justified.
     * @see #JUSTIFICATION
     */
    public static final Float JUSTIFICATION_NONE =
        Float.valueOf(0.0f);

    //
    // For use by input method.
    //

    /**
     * Attribute key for input method highlight styles.
     *
     * &lt;p&gt;Values are instances of {@link
     * java.awt.im.InputMethodHighlight} or {@link
     * java.text.Annotation}.  The default value is &lt;code&gt;null&lt;/code&gt;,
     * which means that input method styles should not be applied
     * before rendering.
     *
     * &lt;p&gt;If adjacent runs of text with the same
     * &lt;code&gt;InputMethodHighlight&lt;/code&gt; need to be rendered
     * separately, the &lt;code&gt;InputMethodHighlights&lt;/code&gt; should be
     * wrapped in &lt;code&gt;Annotation&lt;/code&gt; instances.
     *
     * &lt;p&gt;Input method highlights are used while text is being
     * composed by an input method. Text editing components should
     * retain them even if they generally only deal with unstyled
     * text, and make them available to the drawing routines.
     *
     * @see java.awt.Font
     * @see java.awt.im.InputMethodHighlight
     * @see java.text.Annotation
     */
    public static final TextAttribute INPUT_METHOD_HIGHLIGHT =
        new TextAttribute(&quot;input method highlight&quot;);

    /**
     * Attribute key for input method underlines.  Values
     * are instances of &lt;b&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/b&gt;.  The default
     * value is &lt;code&gt;-1&lt;/code&gt;, which means no underline.
     *
     * &lt;p&gt;Several constant values are provided, see {@link
     * #UNDERLINE_LOW_ONE_PIXEL}, {@link #UNDERLINE_LOW_TWO_PIXEL},
     * {@link #UNDERLINE_LOW_DOTTED}, {@link #UNDERLINE_LOW_GRAY}, and
     * {@link #UNDERLINE_LOW_DASHED}.
     *
     * &lt;p&gt;This may be used in conjunction with {@link #UNDERLINE} if
     * desired.  The primary purpose is for use by input methods.
     * Other use of these underlines for simple ornamentation might
     * confuse users.
     *
     * &lt;p&gt;The input method underline affects both the visual bounds and
     * the outline of the text.
     *
     * @since 1.3
     */
    public static final TextAttribute INPUT_METHOD_UNDERLINE =
        new TextAttribute(&quot;input method underline&quot;);

    /**
     * Single pixel solid low underline.
     * @see #INPUT_METHOD_UNDERLINE
     * @since 1.3
     */
    public static final Integer UNDERLINE_LOW_ONE_PIXEL =
        Integer.valueOf(1);

    /**
     * Double pixel solid low underline.
     * @see #INPUT_METHOD_UNDERLINE
     * @since 1.3
     */
    public static final Integer UNDERLINE_LOW_TWO_PIXEL =
        Integer.valueOf(2);

    /**
     * Single pixel dotted low underline.
     * @see #INPUT_METHOD_UNDERLINE
     * @since 1.3
     */
    public static final Integer UNDERLINE_LOW_DOTTED =
        Integer.valueOf(3);

    /**
     * Double pixel gray low underline.
     * @see #INPUT_METHOD_UNDERLINE
     * @since 1.3
     */
    public static final Integer UNDERLINE_LOW_GRAY =
        Integer.valueOf(4);

    /**
     * Single pixel dashed low underline.
     * @see #INPUT_METHOD_UNDERLINE
     * @since 1.3
     */
    public static final Integer UNDERLINE_LOW_DASHED =
        Integer.valueOf(5);

    /**
     * Attribute key for swapping foreground and background
     * &lt;code&gt;Paints&lt;/code&gt;.  Values are instances of
     * &lt;b&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/b&gt;.  The default value is
     * &lt;code&gt;false&lt;/code&gt;, which means do not swap colors.
     *
     * &lt;p&gt;The constant value {@link #SWAP_COLORS_ON} is defined.
     *
     * &lt;p&gt;If the {@link #FOREGROUND} attribute is set, its
     * &lt;code&gt;Paint&lt;/code&gt; will be used as the background, otherwise
     * the &lt;code&gt;Paint&lt;/code&gt; currently on the &lt;code&gt;Graphics&lt;/code&gt;
     * will be used.  If the {@link #BACKGROUND} attribute is set, its
     * &lt;code&gt;Paint&lt;/code&gt; will be used as the foreground, otherwise
     * the system will find a contrasting color to the
     * (resolved) background so that the text will be visible.
     *
     * @see #FOREGROUND
     * @see #BACKGROUND
     */
    public static final TextAttribute SWAP_COLORS =
        new TextAttribute(&quot;swap_colors&quot;);

    /**
     * Swap foreground and background.
     * @see #SWAP_COLORS
     * @since 1.3
     */
    public static final Boolean SWAP_COLORS_ON =
        Boolean.TRUE;

    /**
     * Attribute key for converting ASCII decimal digits to other
     * decimal ranges.  Values are instances of {@link NumericShaper}.
     * The default is &lt;code&gt;null&lt;/code&gt;, which means do not perform
     * numeric shaping.
     *
     * &lt;p&gt;When a numeric shaper is defined, the text is first
     * processed by the shaper before any other analysis of the text
     * is performed.
     *
     * &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This should have the same value for all the
     * text in the paragraph, otherwise the behavior is undetermined.
     *
     * @see NumericShaper
     * @since 1.4
     */
    public static final TextAttribute NUMERIC_SHAPING =
        new TextAttribute(&quot;numeric_shaping&quot;);

    /**
     * Attribute key to request kerning. Values are instances of
     * &lt;b&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/b&gt;.  The default value is
     * &lt;code&gt;0&lt;/code&gt;, which does not request kerning.
     *
     * &lt;p&gt;The constant value {@link #KERNING_ON} is provided.
     *
     * &lt;p&gt;The default advances of single characters are not
     * appropriate for some character sequences, for example &quot;To&quot; or
     * &quot;AWAY&quot;.  Without kerning the adjacent characters appear to be
     * separated by too much space.  Kerning causes selected sequences
     * of characters to be spaced differently for a more pleasing
     * visual appearance.
     *
     * @since 1.6
     */
    public static final TextAttribute KERNING =
        new TextAttribute(&quot;kerning&quot;);

    /**
     * Request standard kerning.
     * @see #KERNING
     * @since 1.6
     */
    public static final Integer KERNING_ON =
        Integer.valueOf(1);


    /**
     * Attribute key for enabling optional ligatures. Values are
     * instances of &lt;b&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/b&gt;.  The default value is
     * &lt;code&gt;0&lt;/code&gt;, which means do not use optional ligatures.
     *
     * &lt;p&gt;The constant value {@link #LIGATURES_ON} is defined.
     *
     * &lt;p&gt;Ligatures required by the writing system are always enabled.
     *
     * @since 1.6
     */
    public static final TextAttribute LIGATURES =
        new TextAttribute(&quot;ligatures&quot;);

    /**
     * Request standard optional ligatures.
     * @see #LIGATURES
     * @since 1.6
     */
    public static final Integer LIGATURES_ON =
        Integer.valueOf(1);

    /**
     * Attribute key to control tracking.  Values are instances of
     * &lt;b&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/b&gt;.  The default value is
     * &lt;code&gt;0&lt;/code&gt;, which means no additional tracking.
     *
     * &lt;p&gt;The constant values {@link #TRACKING_TIGHT} and {@link
     * #TRACKING_LOOSE} are provided.
     *
     * &lt;p&gt;The tracking value is multiplied by the font point size and
     * passed through the font transform to determine an additional
     * amount to add to the advance of each glyph cluster.  Positive
     * tracking values will inhibit formation of optional ligatures.
     * Tracking values are typically between &lt;code&gt;-0.1&lt;/code&gt; and
     * &lt;code&gt;0.3&lt;/code&gt;; values outside this range are generally not
     * desireable.
     *
     * @since 1.6
     */
    public static final TextAttribute TRACKING =
        new TextAttribute(&quot;tracking&quot;);

    /**
     * Perform tight tracking.
     * @see #TRACKING
     * @since 1.6
     */
    public static final Float TRACKING_TIGHT =
        Float.valueOf(-.04f);

    /**
     * Perform loose tracking.
     * @see #TRACKING
     * @since 1.6
     */
    public static final Float TRACKING_LOOSE =
        Float.valueOf(.04f);
}
</pre>
</body>
</html>
