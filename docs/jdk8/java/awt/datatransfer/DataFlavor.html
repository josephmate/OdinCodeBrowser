<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.datatransfer;

import java.io.*;
import java.nio.*;
import java.util.*;

import sun.awt.datatransfer.DataTransferer;
import sun.reflect.misc.ReflectUtil;

import static sun.security.util.SecurityConstants.GET_CLASSLOADER_PERMISSION;

/**
 * A {@code DataFlavor} provides meta information about data. {@code DataFlavor}
 * is typically used to access data on the clipboard, or during
 * a drag and drop operation.
 * &lt;p&gt;
 * An instance of {@code DataFlavor} encapsulates a content type as
 * defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;
 * and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;RFC 2046&lt;/a&gt;.
 * A content type is typically referred to as a MIME type.
 * &lt;p&gt;
 * A content type consists of a media type (referred
 * to as the primary type), a subtype, and optional parameters. See
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;
 * for details on the syntax of a MIME type.
 * &lt;p&gt;
 * The JRE data transfer implementation interprets the parameter &amp;quot;class&amp;quot;
 * of a MIME type as &lt;B&gt;a representation class&lt;/b&gt;.
 * The representation class reflects the class of the object being
 * transferred. In other words, the representation class is the type of
 * object returned by {@link Transferable#getTransferData}.
 * For example, the MIME type of {@link #imageFlavor} is
 * {@code &quot;image/x-java-image;class=java.awt.Image&quot;},
 * the primary type is {@code image}, the subtype is
 * {@code x-java-image}, and the representation class is
 * {@code java.awt.Image}. When {@code getTransferData} is invoked
 * with a {@code DataFlavor} of {@code imageFlavor}, an instance of
 * {@code java.awt.Image} is returned.
 * It's important to note that {@code DataFlavor} does no error checking
 * against the representation class. It is up to consumers of
 * {@code DataFlavor}, such as {@code Transferable}, to honor the representation
 * class.
 * &lt;br&gt;
 * Note, if you do not specify a representation class when
 * creating a {@code DataFlavor}, the default
 * representation class is used. See appropriate documentation for
 * {@code DataFlavor}'s constructors.
 * &lt;p&gt;
 * Also, {@code DataFlavor} instances with the &amp;quot;text&amp;quot; primary
 * MIME type may have a &amp;quot;charset&amp;quot; parameter. Refer to
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;RFC 2046&lt;/a&gt; and
 * {@link #selectBestTextFlavor} for details on &amp;quot;text&amp;quot; MIME types
 * and the &amp;quot;charset&amp;quot; parameter.
 * &lt;p&gt;
 * Equality of {@code DataFlavors} is determined by the primary type,
 * subtype, and representation class. Refer to {@link #equals(DataFlavor)} for
 * details. When determining equality, any optional parameters are ignored.
 * For example, the following produces two {@code DataFlavors} that
 * are considered identical:
 * &lt;pre&gt;
 *   DataFlavor flavor1 = new DataFlavor(Object.class, &amp;quot;X-test/test; class=&amp;lt;java.lang.Object&amp;gt;; foo=bar&amp;quot;);
 *   DataFlavor flavor2 = new DataFlavor(Object.class, &amp;quot;X-test/test; class=&amp;lt;java.lang.Object&amp;gt;; x=y&amp;quot;);
 *   // The following returns true.
 *   flavor1.equals(flavor2);
 * &lt;/pre&gt;
 * As mentioned, {@code flavor1} and {@code flavor2} are considered identical.
 * As such, asking a {@code Transferable} for either {@code DataFlavor} returns
 * the same results.
 * &lt;p&gt;
 * For more information on the using data transfer with Swing see
 * the &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/dnd/index.html&quot;&gt;
 * How to Use Drag and Drop and Data Transfer&lt;/a&gt;,
 * section in &lt;em&gt;Java Tutorial&lt;/em&gt;.
 *
 * @author      Blake Sullivan
 * @author      Laurence P. G. Cable
 * @author      Jeff Dunn
 */
public class DataFlavor implements Externalizable, Cloneable {

    private static final long serialVersionUID = 8367026044764648243L;
    private static final Class&lt;InputStream&gt; ioInputStreamClass = InputStream.class;

    /**
     * Tries to load a class from: the bootstrap loader, the system loader,
     * the context loader (if one is present) and finally the loader specified.
     *
     * @param className the name of the class to be loaded
     * @param fallback the fallback loader
     * @return the class loaded
     * @exception ClassNotFoundException if class is not found
     */
    protected final static Class&lt;?&gt; tryToLoadClass(String className,
                                                   ClassLoader fallback)
        throws ClassNotFoundException
    {
        ReflectUtil.checkPackageAccess(className);
        try {
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                sm.checkPermission(GET_CLASSLOADER_PERMISSION);
            }
            ClassLoader loader = ClassLoader.getSystemClassLoader();
            try {
                // bootstrap class loader and system class loader if present
                return Class.forName(className, true, loader);
            }
            catch (ClassNotFoundException exception) {
                // thread context class loader if and only if present
                loader = Thread.currentThread().getContextClassLoader();
                if (loader != null) {
                    try {
                        return Class.forName(className, true, loader);
                    }
                    catch (ClassNotFoundException e) {
                        // fallback to user's class loader
                    }
                }
            }
        } catch (SecurityException exception) {
            // ignore secured class loaders
        }
        return Class.forName(className, true, fallback);
    }

    /*
     * private initializer
     */
    static private DataFlavor createConstant(Class&lt;?&gt; rc, String prn) {
        try {
            return new DataFlavor(rc, prn);
        } catch (Exception e) {
            return null;
        }
    }

    /*
     * private initializer
     */
    static private DataFlavor createConstant(String mt, String prn) {
        try {
            return new DataFlavor(mt, prn);
        } catch (Exception e) {
            return null;
        }
    }

    /*
     * private initializer
     */
    static private DataFlavor initHtmlDataFlavor(String htmlFlavorType) {
        try {
            return new DataFlavor (&quot;text/html; class=java.lang.String;document=&quot; +
                                       htmlFlavorType + &quot;;charset=Unicode&quot;);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * The &lt;code&gt;DataFlavor&lt;/code&gt; representing a Java Unicode String class,
     * where:
     * &lt;pre&gt;
     *     representationClass = java.lang.String
     *     mimeType           = &quot;application/x-java-serialized-object&quot;
     * &lt;/pre&gt;
     */
    public static final DataFlavor stringFlavor = createConstant(java.lang.String.class, &quot;Unicode String&quot;);

    /**
     * The &lt;code&gt;DataFlavor&lt;/code&gt; representing a Java Image class,
     * where:
     * &lt;pre&gt;
     *     representationClass = java.awt.Image
     *     mimeType            = &quot;image/x-java-image&quot;
     * &lt;/pre&gt;
     */
    public static final DataFlavor imageFlavor = createConstant(&quot;image/x-java-image; class=java.awt.Image&quot;, &quot;Image&quot;);

    /**
     * The &lt;code&gt;DataFlavor&lt;/code&gt; representing plain text with Unicode
     * encoding, where:
     * &lt;pre&gt;
     *     representationClass = InputStream
     *     mimeType            = &quot;text/plain; charset=unicode&quot;
     * &lt;/pre&gt;
     * This &lt;code&gt;DataFlavor&lt;/code&gt; has been &lt;b&gt;deprecated&lt;/b&gt; because
     * (1) Its representation is an InputStream, an 8-bit based representation,
     * while Unicode is a 16-bit character set; and (2) The charset &quot;unicode&quot;
     * is not well-defined. &quot;unicode&quot; implies a particular platform's
     * implementation of Unicode, not a cross-platform implementation.
     *
     * @deprecated as of 1.3. Use &lt;code&gt;DataFlavor.getReaderForText(Transferable)&lt;/code&gt;
     *             instead of &lt;code&gt;Transferable.getTransferData(DataFlavor.plainTextFlavor)&lt;/code&gt;.
     */
    @Deprecated
    public static final DataFlavor plainTextFlavor = createConstant(&quot;text/plain; charset=unicode; class=java.io.InputStream&quot;, &quot;Plain Text&quot;);

    /**
     * A MIME Content-Type of application/x-java-serialized-object represents
     * a graph of Java object(s) that have been made persistent.
     *
     * The representation class associated with this &lt;code&gt;DataFlavor&lt;/code&gt;
     * identifies the Java type of an object returned as a reference
     * from an invocation &lt;code&gt;java.awt.datatransfer.getTransferData&lt;/code&gt;.
     */
    public static final String javaSerializedObjectMimeType = &quot;application/x-java-serialized-object&quot;;

    /**
     * To transfer a list of files to/from Java (and the underlying
     * platform) a &lt;code&gt;DataFlavor&lt;/code&gt; of this type/subtype and
     * representation class of &lt;code&gt;java.util.List&lt;/code&gt; is used.
     * Each element of the list is required/guaranteed to be of type
     * &lt;code&gt;java.io.File&lt;/code&gt;.
     */
    public static final DataFlavor javaFileListFlavor = createConstant(&quot;application/x-java-file-list;class=java.util.List&quot;, null);

    /**
     * To transfer a reference to an arbitrary Java object reference that
     * has no associated MIME Content-type, across a &lt;code&gt;Transferable&lt;/code&gt;
     * interface WITHIN THE SAME JVM, a &lt;code&gt;DataFlavor&lt;/code&gt;
     * with this type/subtype is used, with a &lt;code&gt;representationClass&lt;/code&gt;
     * equal to the type of the class/interface being passed across the
     * &lt;code&gt;Transferable&lt;/code&gt;.
     * &lt;p&gt;
     * The object reference returned from
     * &lt;code&gt;Transferable.getTransferData&lt;/code&gt; for a &lt;code&gt;DataFlavor&lt;/code&gt;
     * with this MIME Content-Type is required to be
     * an instance of the representation Class of the &lt;code&gt;DataFlavor&lt;/code&gt;.
     */
    public static final String javaJVMLocalObjectMimeType = &quot;application/x-java-jvm-local-objectref&quot;;

    /**
     * In order to pass a live link to a Remote object via a Drag and Drop
     * &lt;code&gt;ACTION_LINK&lt;/code&gt; operation a Mime Content Type of
     * application/x-java-remote-object should be used,
     * where the representation class of the &lt;code&gt;DataFlavor&lt;/code&gt;
     * represents the type of the &lt;code&gt;Remote&lt;/code&gt; interface to be
     * transferred.
     */
    public static final String javaRemoteObjectMimeType = &quot;application/x-java-remote-object&quot;;

    /**
     * Represents a piece of an HTML markup. The markup consists of the part
     * selected on the source side. Therefore some tags in the markup may be
     * unpaired. If the flavor is used to represent the data in
     * a {@link Transferable} instance, no additional changes will be made.
     * This DataFlavor instance represents the same HTML markup as DataFlavor
     * instances which content MIME type does not contain document parameter
     * and representation class is the String class.
     * &lt;pre&gt;
     *     representationClass = String
     *     mimeType           = &quot;text/html&quot;
     * &lt;/pre&gt;
     */
    public static DataFlavor selectionHtmlFlavor = initHtmlDataFlavor(&quot;selection&quot;);

    /**
     * Represents a piece of an HTML markup. If possible, the markup received
     * from a native system is supplemented with pair tags to be
     * a well-formed HTML markup. If the flavor is used to represent the data in
     * a {@link Transferable} instance, no additional changes will be made.
     * &lt;pre&gt;
     *     representationClass = String
     *     mimeType           = &quot;text/html&quot;
     * &lt;/pre&gt;
     */
    public static DataFlavor fragmentHtmlFlavor = initHtmlDataFlavor(&quot;fragment&quot;);

    /**
     * Represents a piece of an HTML markup. If possible, the markup
     * received from a native system is supplemented with additional
     * tags to make up a well-formed HTML document. If the flavor is used to
     * represent the data in a {@link Transferable} instance,
     * no additional changes will be made.
     * &lt;pre&gt;
     *     representationClass = String
     *     mimeType           = &quot;text/html&quot;
     * &lt;/pre&gt;
     */
    public static  DataFlavor allHtmlFlavor = initHtmlDataFlavor(&quot;all&quot;);

    /**
     * Constructs a new &lt;code&gt;DataFlavor&lt;/code&gt;.  This constructor is
     * provided only for the purpose of supporting the
     * &lt;code&gt;Externalizable&lt;/code&gt; interface.  It is not
     * intended for public (client) use.
     *
     * @since 1.2
     */
    public DataFlavor() {
        super();
    }

    /**
     * Constructs a fully specified &lt;code&gt;DataFlavor&lt;/code&gt;.
     *
     * @exception NullPointerException if either &lt;code&gt;primaryType&lt;/code&gt;,
     *            &lt;code&gt;subType&lt;/code&gt; or &lt;code&gt;representationClass&lt;/code&gt; is null
     */
    private DataFlavor(String primaryType, String subType, MimeTypeParameterList params, Class&lt;?&gt; representationClass, String humanPresentableName) {
        super();
        if (primaryType == null) {
            throw new NullPointerException(&quot;primaryType&quot;);
        }
        if (subType == null) {
            throw new NullPointerException(&quot;subType&quot;);
        }
        if (representationClass == null) {
            throw new NullPointerException(&quot;representationClass&quot;);
        }

        if (params == null) params = new MimeTypeParameterList();

        params.set(&quot;class&quot;, representationClass.getName());

        if (humanPresentableName == null) {
            humanPresentableName = params.get(&quot;humanPresentableName&quot;);

            if (humanPresentableName == null)
                humanPresentableName = primaryType + &quot;/&quot; + subType;
        }

        try {
            mimeType = new MimeType(primaryType, subType, params);
        } catch (MimeTypeParseException mtpe) {
            throw new IllegalArgumentException(&quot;MimeType Parse Exception: &quot; + mtpe.getMessage());
        }

        this.representationClass  = representationClass;
        this.humanPresentableName = humanPresentableName;

        mimeType.removeParameter(&quot;humanPresentableName&quot;);
    }

    /**
     * Constructs a &lt;code&gt;DataFlavor&lt;/code&gt; that represents a Java class.
     * &lt;p&gt;
     * The returned &lt;code&gt;DataFlavor&lt;/code&gt; will have the following
     * characteristics:
     * &lt;pre&gt;
     *    representationClass = representationClass
     *    mimeType            = application/x-java-serialized-object
     * &lt;/pre&gt;
     * @param representationClass the class used to transfer data in this flavor
     * @param humanPresentableName the human-readable string used to identify
     *                 this flavor; if this parameter is &lt;code&gt;null&lt;/code&gt;
     *                 then the value of the the MIME Content Type is used
     * @exception NullPointerException if &lt;code&gt;representationClass&lt;/code&gt; is null
     */
    public DataFlavor(Class&lt;?&gt; representationClass, String humanPresentableName) {
        this(&quot;application&quot;, &quot;x-java-serialized-object&quot;, null, representationClass, humanPresentableName);
        if (representationClass == null) {
            throw new NullPointerException(&quot;representationClass&quot;);
        }
    }

    /**
     * Constructs a &lt;code&gt;DataFlavor&lt;/code&gt; that represents a
     * &lt;code&gt;MimeType&lt;/code&gt;.
     * &lt;p&gt;
     * The returned &lt;code&gt;DataFlavor&lt;/code&gt; will have the following
     * characteristics:
     * &lt;p&gt;
     * If the &lt;code&gt;mimeType&lt;/code&gt; is
     * &quot;application/x-java-serialized-object; class=&amp;lt;representation class&amp;gt;&quot;,
     * the result is the same as calling
     * &lt;code&gt;new DataFlavor(Class:forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt;.
     * &lt;p&gt;
     * Otherwise:
     * &lt;pre&gt;
     *     representationClass = InputStream
     *     mimeType            = mimeType
     * &lt;/pre&gt;
     * @param mimeType the string used to identify the MIME type for this flavor;
     *                 if the the &lt;code&gt;mimeType&lt;/code&gt; does not specify a
     *                 &quot;class=&quot; parameter, or if the class is not successfully
     *                 loaded, then an &lt;code&gt;IllegalArgumentException&lt;/code&gt;
     *                 is thrown
     * @param humanPresentableName the human-readable string used to identify
     *                 this flavor; if this parameter is &lt;code&gt;null&lt;/code&gt;
     *                 then the value of the the MIME Content Type is used
     * @exception IllegalArgumentException if &lt;code&gt;mimeType&lt;/code&gt; is
     *                 invalid or if the class is not successfully loaded
     * @exception NullPointerException if &lt;code&gt;mimeType&lt;/code&gt; is null
     */
    public DataFlavor(String mimeType, String humanPresentableName) {
        super();
        if (mimeType == null) {
            throw new NullPointerException(&quot;mimeType&quot;);
        }
        try {
            initialize(mimeType, humanPresentableName, this.getClass().getClassLoader());
        } catch (MimeTypeParseException mtpe) {
            throw new IllegalArgumentException(&quot;failed to parse:&quot; + mimeType);
        } catch (ClassNotFoundException cnfe) {
            throw new IllegalArgumentException(&quot;can't find specified class: &quot; + cnfe.getMessage());
        }
    }

    /**
     * Constructs a &lt;code&gt;DataFlavor&lt;/code&gt; that represents a
     * &lt;code&gt;MimeType&lt;/code&gt;.
     * &lt;p&gt;
     * The returned &lt;code&gt;DataFlavor&lt;/code&gt; will have the following
     * characteristics:
     * &lt;p&gt;
     * If the mimeType is
     * &quot;application/x-java-serialized-object; class=&amp;lt;representation class&amp;gt;&quot;,
     * the result is the same as calling
     * &lt;code&gt;new DataFlavor(Class:forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt;.
     * &lt;p&gt;
     * Otherwise:
     * &lt;pre&gt;
     *     representationClass = InputStream
     *     mimeType            = mimeType
     * &lt;/pre&gt;
     * @param mimeType the string used to identify the MIME type for this flavor
     * @param humanPresentableName the human-readable string used to
     *          identify this flavor
     * @param classLoader the class loader to use
     * @exception ClassNotFoundException if the class is not loaded
     * @exception IllegalArgumentException if &lt;code&gt;mimeType&lt;/code&gt; is
     *                 invalid
     * @exception NullPointerException if &lt;code&gt;mimeType&lt;/code&gt; is null
     */
    public DataFlavor(String mimeType, String humanPresentableName, ClassLoader classLoader) throws ClassNotFoundException {
        super();
        if (mimeType == null) {
            throw new NullPointerException(&quot;mimeType&quot;);
        }
        try {
            initialize(mimeType, humanPresentableName, classLoader);
        } catch (MimeTypeParseException mtpe) {
            throw new IllegalArgumentException(&quot;failed to parse:&quot; + mimeType);
        }
    }

    /**
     * Constructs a &lt;code&gt;DataFlavor&lt;/code&gt; from a &lt;code&gt;mimeType&lt;/code&gt; string.
     * The string can specify a &quot;class=&amp;lt;fully specified Java class name&amp;gt;&quot;
     * parameter to create a &lt;code&gt;DataFlavor&lt;/code&gt; with the desired
     * representation class. If the string does not contain &quot;class=&quot; parameter,
     * &lt;code&gt;java.io.InputStream&lt;/code&gt; is used as default.
     *
     * @param mimeType the string used to identify the MIME type for this flavor;
     *                 if the class specified by &quot;class=&quot; parameter is not
     *                 successfully loaded, then an
     *                 &lt;code&gt;ClassNotFoundException&lt;/code&gt; is thrown
     * @exception ClassNotFoundException if the class is not loaded
     * @exception IllegalArgumentException if &lt;code&gt;mimeType&lt;/code&gt; is
     *                 invalid
     * @exception NullPointerException if &lt;code&gt;mimeType&lt;/code&gt; is null
     */
    public DataFlavor(String mimeType) throws ClassNotFoundException {
        super();
        if (mimeType == null) {
            throw new NullPointerException(&quot;mimeType&quot;);
        }
        try {
            initialize(mimeType, null, this.getClass().getClassLoader());
        } catch (MimeTypeParseException mtpe) {
            throw new IllegalArgumentException(&quot;failed to parse:&quot; + mimeType);
        }
    }

   /**
    * Common initialization code called from various constructors.
    *
    * @param mimeType the MIME Content Type (must have a class= param)
    * @param humanPresentableName the human Presentable Name or
    *                 &lt;code&gt;null&lt;/code&gt;
    * @param classLoader the fallback class loader to resolve against
    *
    * @throws MimeTypeParseException
    * @throws ClassNotFoundException
    * @throws  NullPointerException if &lt;code&gt;mimeType&lt;/code&gt; is null
    *
    * @see tryToLoadClass
    */
    private void initialize(String mimeType, String humanPresentableName, ClassLoader classLoader) throws MimeTypeParseException, ClassNotFoundException {
        if (mimeType == null) {
            throw new NullPointerException(&quot;mimeType&quot;);
        }

        this.mimeType = new MimeType(mimeType); // throws

        String rcn = getParameter(&quot;class&quot;);

        if (rcn == null) {
            if (&quot;application/x-java-serialized-object&quot;.equals(this.mimeType.getBaseType()))

                throw new IllegalArgumentException(&quot;no representation class specified for:&quot; + mimeType);
            else
                representationClass = java.io.InputStream.class; // default
        } else { // got a class name
            representationClass = DataFlavor.tryToLoadClass(rcn, classLoader);
        }

        this.mimeType.setParameter(&quot;class&quot;, representationClass.getName());

        if (humanPresentableName == null) {
            humanPresentableName = this.mimeType.getParameter(&quot;humanPresentableName&quot;);
            if (humanPresentableName == null)
                humanPresentableName = this.mimeType.getPrimaryType() + &quot;/&quot; + this.mimeType.getSubType();
        }

        this.humanPresentableName = humanPresentableName; // set it.

        this.mimeType.removeParameter(&quot;humanPresentableName&quot;); // just in case
    }

    /**
     * String representation of this &lt;code&gt;DataFlavor&lt;/code&gt; and its
     * parameters. The resulting &lt;code&gt;String&lt;/code&gt; contains the name of
     * the &lt;code&gt;DataFlavor&lt;/code&gt; class, this flavor's MIME type, and its
     * representation class. If this flavor has a primary MIME type of &quot;text&quot;,
     * supports the charset parameter, and has an encoded representation, the
     * flavor's charset is also included. See &lt;code&gt;selectBestTextFlavor&lt;/code&gt;
     * for a list of text flavors which support the charset parameter.
     *
     * @return  string representation of this &lt;code&gt;DataFlavor&lt;/code&gt;
     * @see #selectBestTextFlavor
     */
    public String toString() {
        String string = getClass().getName();
        string += &quot;[&quot;+paramString()+&quot;]&quot;;
        return string;
    }

    private String paramString() {
        String params = &quot;&quot;;
        params += &quot;mimetype=&quot;;
        if (mimeType == null) {
            params += &quot;null&quot;;
        } else {
            params += mimeType.getBaseType();
        }
        params += &quot;;representationclass=&quot;;
        if (representationClass == null) {
           params += &quot;null&quot;;
        } else {
           params += representationClass.getName();
        }
        if (DataTransferer.isFlavorCharsetTextType(this) &amp;&amp;
            (isRepresentationClassInputStream() ||
             isRepresentationClassByteBuffer() ||
             DataTransferer.byteArrayClass.equals(representationClass)))
        {
            params += &quot;;charset=&quot; + DataTransferer.getTextCharset(this);
        }
        return params;
    }

    /**
     * Returns a &lt;code&gt;DataFlavor&lt;/code&gt; representing plain text with Unicode
     * encoding, where:
     * &lt;pre&gt;
     *     representationClass = java.io.InputStream
     *     mimeType            = &quot;text/plain;
     *                            charset=&amp;lt;platform default Unicode encoding&amp;gt;&quot;
     * &lt;/pre&gt;
     * Sun's implementation for Microsoft Windows uses the encoding &lt;code&gt;utf-16le&lt;/code&gt;.
     * Sun's implementation for Solaris and Linux uses the encoding
     * &lt;code&gt;iso-10646-ucs-2&lt;/code&gt;.
     *
     * @return a &lt;code&gt;DataFlavor&lt;/code&gt; representing plain text
     *    with Unicode encoding
     * @since 1.3
     */
    public static final DataFlavor getTextPlainUnicodeFlavor() {
        String encoding = null;
        DataTransferer transferer = DataTransferer.getInstance();
        if (transferer != null) {
            encoding = transferer.getDefaultUnicodeEncoding();
        }
        return new DataFlavor(
            &quot;text/plain;charset=&quot;+encoding
            +&quot;;class=java.io.InputStream&quot;, &quot;Plain Text&quot;);
    }

    /**
     * Selects the best text &lt;code&gt;DataFlavor&lt;/code&gt; from an array of &lt;code&gt;
     * DataFlavor&lt;/code&gt;s. Only &lt;code&gt;DataFlavor.stringFlavor&lt;/code&gt;, and
     * equivalent flavors, and flavors that have a primary MIME type of &quot;text&quot;,
     * are considered for selection.
     * &lt;p&gt;
     * Flavors are first sorted by their MIME types in the following order:
     * &lt;ul&gt;
     * &lt;li&gt;&quot;text/sgml&quot;
     * &lt;li&gt;&quot;text/xml&quot;
     * &lt;li&gt;&quot;text/html&quot;
     * &lt;li&gt;&quot;text/rtf&quot;
     * &lt;li&gt;&quot;text/enriched&quot;
     * &lt;li&gt;&quot;text/richtext&quot;
     * &lt;li&gt;&quot;text/uri-list&quot;
     * &lt;li&gt;&quot;text/tab-separated-values&quot;
     * &lt;li&gt;&quot;text/t140&quot;
     * &lt;li&gt;&quot;text/rfc822-headers&quot;
     * &lt;li&gt;&quot;text/parityfec&quot;
     * &lt;li&gt;&quot;text/directory&quot;
     * &lt;li&gt;&quot;text/css&quot;
     * &lt;li&gt;&quot;text/calendar&quot;
     * &lt;li&gt;&quot;application/x-java-serialized-object&quot;
     * &lt;li&gt;&quot;text/plain&quot;
     * &lt;li&gt;&quot;text/&amp;lt;other&amp;gt;&quot;
     * &lt;/ul&gt;
     * &lt;p&gt;For example, &quot;text/sgml&quot; will be selected over
     * &quot;text/html&quot;, and &lt;code&gt;DataFlavor.stringFlavor&lt;/code&gt; will be chosen
     * over &lt;code&gt;DataFlavor.plainTextFlavor&lt;/code&gt;.
     * &lt;p&gt;
     * If two or more flavors share the best MIME type in the array, then that
     * MIME type will be checked to see if it supports the charset parameter.
     * &lt;p&gt;
     * The following MIME types support, or are treated as though they support,
     * the charset parameter:
     * &lt;ul&gt;
     * &lt;li&gt;&quot;text/sgml&quot;
     * &lt;li&gt;&quot;text/xml&quot;
     * &lt;li&gt;&quot;text/html&quot;
     * &lt;li&gt;&quot;text/enriched&quot;
     * &lt;li&gt;&quot;text/richtext&quot;
     * &lt;li&gt;&quot;text/uri-list&quot;
     * &lt;li&gt;&quot;text/directory&quot;
     * &lt;li&gt;&quot;text/css&quot;
     * &lt;li&gt;&quot;text/calendar&quot;
     * &lt;li&gt;&quot;application/x-java-serialized-object&quot;
     * &lt;li&gt;&quot;text/plain&quot;
     * &lt;/ul&gt;
     * The following MIME types do not support, or are treated as though they
     * do not support, the charset parameter:
     * &lt;ul&gt;
     * &lt;li&gt;&quot;text/rtf&quot;
     * &lt;li&gt;&quot;text/tab-separated-values&quot;
     * &lt;li&gt;&quot;text/t140&quot;
     * &lt;li&gt;&quot;text/rfc822-headers&quot;
     * &lt;li&gt;&quot;text/parityfec&quot;
     * &lt;/ul&gt;
     * For &quot;text/&amp;lt;other&amp;gt;&quot; MIME types, the first time the JRE needs to
     * determine whether the MIME type supports the charset parameter, it will
     * check whether the parameter is explicitly listed in an arbitrarily
     * chosen &lt;code&gt;DataFlavor&lt;/code&gt; which uses that MIME type. If so, the JRE
     * will assume from that point on that the MIME type supports the charset
     * parameter and will not check again. If the parameter is not explicitly
     * listed, the JRE will assume from that point on that the MIME type does
     * not support the charset parameter and will not check again. Because
     * this check is performed on an arbitrarily chosen
     * &lt;code&gt;DataFlavor&lt;/code&gt;, developers must ensure that all
     * &lt;code&gt;DataFlavor&lt;/code&gt;s with a &quot;text/&amp;lt;other&amp;gt;&quot; MIME type specify
     * the charset parameter if it is supported by that MIME type. Developers
     * should never rely on the JRE to substitute the platform's default
     * charset for a &quot;text/&amp;lt;other&amp;gt;&quot; DataFlavor. Failure to adhere to this
     * restriction will lead to undefined behavior.
     * &lt;p&gt;
     * If the best MIME type in the array does not support the charset
     * parameter, the flavors which share that MIME type will then be sorted by
     * their representation classes in the following order:
     * &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;,
     * &lt;code&gt;[B&lt;/code&gt;, &amp;lt;all others&amp;gt;.
     * &lt;p&gt;
     * If two or more flavors share the best representation class, or if no
     * flavor has one of the three specified representations, then one of those
     * flavors will be chosen non-deterministically.
     * &lt;p&gt;
     * If the best MIME type in the array does support the charset parameter,
     * the flavors which share that MIME type will then be sorted by their
     * representation classes in the following order:
     * &lt;code&gt;java.io.Reader&lt;/code&gt;, &lt;code&gt;java.lang.String&lt;/code&gt;,
     * &lt;code&gt;java.nio.CharBuffer&lt;/code&gt;, &lt;code&gt;[C&lt;/code&gt;, &amp;lt;all others&amp;gt;.
     * &lt;p&gt;
     * If two or more flavors share the best representation class, and that
     * representation is one of the four explicitly listed, then one of those
     * flavors will be chosen non-deterministically. If, however, no flavor has
     * one of the four specified representations, the flavors will then be
     * sorted by their charsets. Unicode charsets, such as &quot;UTF-16&quot;, &quot;UTF-8&quot;,
     * &quot;UTF-16BE&quot;, &quot;UTF-16LE&quot;, and their aliases, are considered best. After
     * them, the platform default charset and its aliases are selected.
     * &quot;US-ASCII&quot; and its aliases are worst. All other charsets are chosen in
     * alphabetical order, but only charsets supported by this implementation
     * of the Java platform will be considered.
     * &lt;p&gt;
     * If two or more flavors share the best charset, the flavors will then
     * again be sorted by their representation classes in the following order:
     * &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;,
     * &lt;code&gt;[B&lt;/code&gt;, &amp;lt;all others&amp;gt;.
     * &lt;p&gt;
     * If two or more flavors share the best representation class, or if no
     * flavor has one of the three specified representations, then one of those
     * flavors will be chosen non-deterministically.
     *
     * @param availableFlavors an array of available &lt;code&gt;DataFlavor&lt;/code&gt;s
     * @return the best (highest fidelity) flavor according to the rules
     *         specified above, or &lt;code&gt;null&lt;/code&gt;,
     *         if &lt;code&gt;availableFlavors&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     *         has zero length, or contains no text flavors
     * @since 1.3
     */
    public static final DataFlavor selectBestTextFlavor(
                                       DataFlavor[] availableFlavors) {
        if (availableFlavors == null || availableFlavors.length == 0) {
            return null;
        }

        if (textFlavorComparator == null) {
            textFlavorComparator = new TextFlavorComparator();
        }

        DataFlavor bestFlavor =
            (DataFlavor)Collections.max(Arrays.asList(availableFlavors),
                                        textFlavorComparator);

        if (!bestFlavor.isFlavorTextType()) {
            return null;
        }

        return bestFlavor;
    }

    private static Comparator&lt;DataFlavor&gt; textFlavorComparator;

    static class TextFlavorComparator
        extends DataTransferer.DataFlavorComparator {

        /**
         * Compares two &lt;code&gt;DataFlavor&lt;/code&gt; objects. Returns a negative
         * integer, zero, or a positive integer as the first
         * &lt;code&gt;DataFlavor&lt;/code&gt; is worse than, equal to, or better than the
         * second.
         * &lt;p&gt;
         * &lt;code&gt;DataFlavor&lt;/code&gt;s are ordered according to the rules outlined
         * for &lt;code&gt;selectBestTextFlavor&lt;/code&gt;.
         *
         * @param obj1 the first &lt;code&gt;DataFlavor&lt;/code&gt; to be compared
         * @param obj2 the second &lt;code&gt;DataFlavor&lt;/code&gt; to be compared
         * @return a negative integer, zero, or a positive integer as the first
         *         argument is worse, equal to, or better than the second
         * @throws ClassCastException if either of the arguments is not an
         *         instance of &lt;code&gt;DataFlavor&lt;/code&gt;
         * @throws NullPointerException if either of the arguments is
         *         &lt;code&gt;null&lt;/code&gt;
         *
         * @see #selectBestTextFlavor
         */
        public int compare(Object obj1, Object obj2) {
            DataFlavor flavor1 = (DataFlavor)obj1;
            DataFlavor flavor2 = (DataFlavor)obj2;

            if (flavor1.isFlavorTextType()) {
                if (flavor2.isFlavorTextType()) {
                    return super.compare(obj1, obj2);
                } else {
                    return 1;
                }
            } else if (flavor2.isFlavorTextType()) {
                return -1;
            } else {
                return 0;
            }
        }
    }

    /**
     * Gets a Reader for a text flavor, decoded, if necessary, for the expected
     * charset (encoding). The supported representation classes are
     * &lt;code&gt;java.io.Reader&lt;/code&gt;, &lt;code&gt;java.lang.String&lt;/code&gt;,
     * &lt;code&gt;java.nio.CharBuffer&lt;/code&gt;, &lt;code&gt;[C&lt;/code&gt;,
     * &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;,
     * and &lt;code&gt;[B&lt;/code&gt;.
     * &lt;p&gt;
     * Because text flavors which do not support the charset parameter are
     * encoded in a non-standard format, this method should not be called for
     * such flavors. However, in order to maintain backward-compatibility,
     * if this method is called for such a flavor, this method will treat the
     * flavor as though it supports the charset parameter and attempt to
     * decode it accordingly. See &lt;code&gt;selectBestTextFlavor&lt;/code&gt; for a list
     * of text flavors which do not support the charset parameter.
     *
     * @param transferable the &lt;code&gt;Transferable&lt;/code&gt; whose data will be
     *        requested in this flavor
     *
     * @return a &lt;code&gt;Reader&lt;/code&gt; to read the &lt;code&gt;Transferable&lt;/code&gt;'s
     *         data
     *
     * @exception IllegalArgumentException if the representation class
     *            is not one of the seven listed above
     * @exception IllegalArgumentException if the &lt;code&gt;Transferable&lt;/code&gt;
     *            has &lt;code&gt;null&lt;/code&gt; data
     * @exception NullPointerException if the &lt;code&gt;Transferable&lt;/code&gt; is
     *            &lt;code&gt;null&lt;/code&gt;
     * @exception UnsupportedEncodingException if this flavor's representation
     *            is &lt;code&gt;java.io.InputStream&lt;/code&gt;,
     *            &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, or &lt;code&gt;[B&lt;/code&gt; and
     *            this flavor's encoding is not supported by this
     *            implementation of the Java platform
     * @exception UnsupportedFlavorException if the &lt;code&gt;Transferable&lt;/code&gt;
     *            does not support this flavor
     * @exception IOException if the data cannot be read because of an
     *            I/O error
     * @see #selectBestTextFlavor
     * @since 1.3
     */
    public Reader getReaderForText(Transferable transferable)
        throws UnsupportedFlavorException, IOException
    {
        Object transferObject = transferable.getTransferData(this);
        if (transferObject == null) {
            throw new IllegalArgumentException
                (&quot;getTransferData() returned null&quot;);
        }

        if (transferObject instanceof Reader) {
            return (Reader)transferObject;
        } else if (transferObject instanceof String) {
            return new StringReader((String)transferObject);
        } else if (transferObject instanceof CharBuffer) {
            CharBuffer buffer = (CharBuffer)transferObject;
            int size = buffer.remaining();
            char[] chars = new char[size];
            buffer.get(chars, 0, size);
            return new CharArrayReader(chars);
        } else if (transferObject instanceof char[]) {
            return new CharArrayReader((char[])transferObject);
        }

        InputStream stream = null;

        if (transferObject instanceof InputStream) {
            stream = (InputStream)transferObject;
        } else if (transferObject instanceof ByteBuffer) {
            ByteBuffer buffer = (ByteBuffer)transferObject;
            int size = buffer.remaining();
            byte[] bytes = new byte[size];
            buffer.get(bytes, 0, size);
            stream = new ByteArrayInputStream(bytes);
        } else if (transferObject instanceof byte[]) {
            stream = new ByteArrayInputStream((byte[])transferObject);
        }

        if (stream == null) {
            throw new IllegalArgumentException(&quot;transfer data is not Reader, String, CharBuffer, char array, InputStream, ByteBuffer, or byte array&quot;);
        }

        String encoding = getParameter(&quot;charset&quot;);
        return (encoding == null)
            ? new InputStreamReader(stream)
            : new InputStreamReader(stream, encoding);
    }

    /**
     * Returns the MIME type string for this &lt;code&gt;DataFlavor&lt;/code&gt;.
     * @return the MIME type string for this flavor
     */
    public String getMimeType() {
        return (mimeType != null) ? mimeType.toString() : null;
    }

    /**
     * Returns the &lt;code&gt;Class&lt;/code&gt; which objects supporting this
     * &lt;code&gt;DataFlavor&lt;/code&gt; will return when this &lt;code&gt;DataFlavor&lt;/code&gt;
     * is requested.
     * @return the &lt;code&gt;Class&lt;/code&gt; which objects supporting this
     * &lt;code&gt;DataFlavor&lt;/code&gt; will return when this &lt;code&gt;DataFlavor&lt;/code&gt;
     * is requested
     */
    public Class&lt;?&gt; getRepresentationClass() {
        return representationClass;
    }

    /**
     * Returns the human presentable name for the data format that this
     * &lt;code&gt;DataFlavor&lt;/code&gt; represents.  This name would be localized
     * for different countries.
     * @return the human presentable name for the data format that this
     *    &lt;code&gt;DataFlavor&lt;/code&gt; represents
     */
    public String getHumanPresentableName() {
        return humanPresentableName;
    }

    /**
     * Returns the primary MIME type for this &lt;code&gt;DataFlavor&lt;/code&gt;.
     * @return the primary MIME type of this &lt;code&gt;DataFlavor&lt;/code&gt;
     */
    public String getPrimaryType() {
        return (mimeType != null) ? mimeType.getPrimaryType() : null;
    }

    /**
     * Returns the sub MIME type of this &lt;code&gt;DataFlavor&lt;/code&gt;.
     * @return the Sub MIME type of this &lt;code&gt;DataFlavor&lt;/code&gt;
     */
    public String getSubType() {
        return (mimeType != null) ? mimeType.getSubType() : null;
    }

    /**
     * Returns the human presentable name for this &lt;code&gt;DataFlavor&lt;/code&gt;
     * if &lt;code&gt;paramName&lt;/code&gt; equals &quot;humanPresentableName&quot;.  Otherwise
     * returns the MIME type value associated with &lt;code&gt;paramName&lt;/code&gt;.
     *
     * @param paramName the parameter name requested
     * @return the value of the name parameter, or &lt;code&gt;null&lt;/code&gt;
     *  if there is no associated value
     */
    public String getParameter(String paramName) {
        if (paramName.equals(&quot;humanPresentableName&quot;)) {
            return humanPresentableName;
        } else {
            return (mimeType != null)
                ? mimeType.getParameter(paramName) : null;
        }
    }

    /**
     * Sets the human presentable name for the data format that this
     * &lt;code&gt;DataFlavor&lt;/code&gt; represents. This name would be localized
     * for different countries.
     * @param humanPresentableName the new human presentable name
     */
    public void setHumanPresentableName(String humanPresentableName) {
        this.humanPresentableName = humanPresentableName;
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * The equals comparison for the {@code DataFlavor} class is implemented
     * as follows: Two &lt;code&gt;DataFlavor&lt;/code&gt;s are considered equal if and
     * only if their MIME primary type and subtype and representation class are
     * equal. Additionally, if the primary type is &quot;text&quot;, the subtype denotes
     * a text flavor which supports the charset parameter, and the
     * representation class is not &lt;code&gt;java.io.Reader&lt;/code&gt;,
     * &lt;code&gt;java.lang.String&lt;/code&gt;, &lt;code&gt;java.nio.CharBuffer&lt;/code&gt;, or
     * &lt;code&gt;[C&lt;/code&gt;, the &lt;code&gt;charset&lt;/code&gt; parameter must also be equal.
     * If a charset is not explicitly specified for one or both
     * &lt;code&gt;DataFlavor&lt;/code&gt;s, the platform default encoding is assumed. See
     * &lt;code&gt;selectBestTextFlavor&lt;/code&gt; for a list of text flavors which
     * support the charset parameter.
     *
     * @param o the &lt;code&gt;Object&lt;/code&gt; to compare with &lt;code&gt;this&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;that&lt;/code&gt; is equivalent to this
     *         &lt;code&gt;DataFlavor&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise
     * @see #selectBestTextFlavor
     */
    public boolean equals(Object o) {
        return ((o instanceof DataFlavor) &amp;&amp; equals((DataFlavor)o));
    }

    /**
     * This method has the same behavior as {@link #equals(Object)}.
     * The only difference being that it takes a {@code DataFlavor} instance
     * as a parameter.
     *
     * @param that the &lt;code&gt;DataFlavor&lt;/code&gt; to compare with
     *        &lt;code&gt;this&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;that&lt;/code&gt; is equivalent to this
     *         &lt;code&gt;DataFlavor&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise
     * @see #selectBestTextFlavor
     */
    public boolean equals(DataFlavor that) {
        if (that == null) {
            return false;
        }
        if (this == that) {
            return true;
        }

        if (representationClass == null) {
            if (that.getRepresentationClass() != null) {
                return false;
            }
        } else {
            if (!representationClass.equals(that.getRepresentationClass())) {
                return false;
            }
        }

        if (mimeType == null) {
            if (that.mimeType != null) {
                return false;
            }
        } else {
            if (!mimeType.match(that.mimeType)) {
                return false;
            }

            if (&quot;text&quot;.equals(getPrimaryType())) {
                if (DataTransferer.doesSubtypeSupportCharset(this) &amp;&amp;
                    representationClass != null &amp;&amp;
                    !(isRepresentationClassReader() ||
                        String.class.equals(representationClass) ||
                        isRepresentationClassCharBuffer() ||
                        DataTransferer.charArrayClass.equals(representationClass)))
                {
                    String thisCharset =
                        DataTransferer.canonicalName(getParameter(&quot;charset&quot;));
                    String thatCharset =
                        DataTransferer.canonicalName(that.getParameter(&quot;charset&quot;));
                    if (thisCharset == null) {
                        if (thatCharset != null) {
                            return false;
                        }
                    } else {
                        if (!thisCharset.equals(thatCharset)) {
                            return false;
                        }
                    }
                }

                if (&quot;html&quot;.equals(getSubType()) &amp;&amp;
                        this.getParameter(&quot;document&quot;) != null )
                {
                   if (!this.getParameter(&quot;document&quot;).
                            equals(that.getParameter(&quot;document&quot;)))
                    {
                        return false;
                    }
                }
            }
        }

        return true;
    }

    /**
     * Compares only the &lt;code&gt;mimeType&lt;/code&gt; against the passed in
     * &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;representationClass&lt;/code&gt; is
     * not considered in the comparison.
     *
     * If &lt;code&gt;representationClass&lt;/code&gt; needs to be compared, then
     * &lt;code&gt;equals(new DataFlavor(s))&lt;/code&gt; may be used.
     * @deprecated As inconsistent with &lt;code&gt;hashCode()&lt;/code&gt; contract,
     *             use &lt;code&gt;isMimeTypeEqual(String)&lt;/code&gt; instead.
     * @param s the {@code mimeType} to compare.
     * @return true if the String (MimeType) is equal; false otherwise or if
     *         {@code s} is {@code null}
     */
    @Deprecated
    public boolean equals(String s) {
        if (s == null || mimeType == null)
            return false;
        return isMimeTypeEqual(s);
    }

    /**
     * Returns hash code for this &lt;code&gt;DataFlavor&lt;/code&gt;.
     * For two equal &lt;code&gt;DataFlavor&lt;/code&gt;s, hash codes are equal.
     * For the &lt;code&gt;String&lt;/code&gt;
     * that matches &lt;code&gt;DataFlavor.equals(String)&lt;/code&gt;, it is not
     * guaranteed that &lt;code&gt;DataFlavor&lt;/code&gt;'s hash code is equal
     * to the hash code of the &lt;code&gt;String&lt;/code&gt;.
     *
     * @return a hash code for this &lt;code&gt;DataFlavor&lt;/code&gt;
     */
    public int hashCode() {
        int total = 0;

        if (representationClass != null) {
            total += representationClass.hashCode();
        }

        if (mimeType != null) {
            String primaryType = mimeType.getPrimaryType();
            if (primaryType != null) {
                total += primaryType.hashCode();
            }

            // Do not add subType.hashCode() to the total. equals uses
            // MimeType.match which reports a match if one or both of the
            // subTypes is '*', regardless of the other subType.

            if (&quot;text&quot;.equals(primaryType) &amp;&amp;
                DataTransferer.doesSubtypeSupportCharset(this) &amp;&amp;
                representationClass != null &amp;&amp;
                !(isRepresentationClassReader() ||
                  String.class.equals(representationClass) ||
                  isRepresentationClassCharBuffer() ||
                  DataTransferer.charArrayClass.equals
                  (representationClass)))
            {
                String charset =
                    DataTransferer.canonicalName(getParameter(&quot;charset&quot;));
                if (charset != null) {
                    total += charset.hashCode();
                }
            }
        }

        return total;
    }

    /**
     * Identical to {@link #equals(DataFlavor)}.
     *
     * @param that the &lt;code&gt;DataFlavor&lt;/code&gt; to compare with
     *        &lt;code&gt;this&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;that&lt;/code&gt; is equivalent to this
     *         &lt;code&gt;DataFlavor&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise
     * @see #selectBestTextFlavor
     * @since 1.3
     */
    public boolean match(DataFlavor that) {
        return equals(that);
    }

    /**
     * Returns whether the string representation of the MIME type passed in
     * is equivalent to the MIME type of this &lt;code&gt;DataFlavor&lt;/code&gt;.
     * Parameters are not included in the comparison.
     *
     * @param mimeType the string representation of the MIME type
     * @return true if the string representation of the MIME type passed in is
     *         equivalent to the MIME type of this &lt;code&gt;DataFlavor&lt;/code&gt;;
     *         false otherwise
     * @throws NullPointerException if mimeType is &lt;code&gt;null&lt;/code&gt;
     */
    public boolean isMimeTypeEqual(String mimeType) {
        // JCK Test DataFlavor0117: if 'mimeType' is null, throw NPE
        if (mimeType == null) {
            throw new NullPointerException(&quot;mimeType&quot;);
        }
        if (this.mimeType == null) {
            return false;
        }
        try {
            return this.mimeType.match(new MimeType(mimeType));
        } catch (MimeTypeParseException mtpe) {
            return false;
        }
    }

    /**
     * Compares the &lt;code&gt;mimeType&lt;/code&gt; of two &lt;code&gt;DataFlavor&lt;/code&gt;
     * objects. No parameters are considered.
     *
     * @param dataFlavor the &lt;code&gt;DataFlavor&lt;/code&gt; to be compared
     * @return true if the &lt;code&gt;MimeType&lt;/code&gt;s are equal,
     *  otherwise false
     */

    public final boolean isMimeTypeEqual(DataFlavor dataFlavor) {
        return isMimeTypeEqual(dataFlavor.mimeType);
    }

    /**
     * Compares the &lt;code&gt;mimeType&lt;/code&gt; of two &lt;code&gt;DataFlavor&lt;/code&gt;
     * objects.  No parameters are considered.
     *
     * @return true if the &lt;code&gt;MimeType&lt;/code&gt;s are equal,
     *  otherwise false
     */

    private boolean isMimeTypeEqual(MimeType mtype) {
        if (this.mimeType == null) {
            return (mtype == null);
        }
        return mimeType.match(mtype);
    }

   /**
    * Does the &lt;code&gt;DataFlavor&lt;/code&gt; represent a serialized object?
    */

    public boolean isMimeTypeSerializedObject() {
        return isMimeTypeEqual(javaSerializedObjectMimeType);
    }

    public final Class&lt;?&gt; getDefaultRepresentationClass() {
        return ioInputStreamClass;
    }

    public final String getDefaultRepresentationClassAsString() {
        return getDefaultRepresentationClass().getName();
    }

   /**
    * Does the &lt;code&gt;DataFlavor&lt;/code&gt; represent a
    * &lt;code&gt;java.io.InputStream&lt;/code&gt;?
    */

    public boolean isRepresentationClassInputStream() {
        return ioInputStreamClass.isAssignableFrom(representationClass);
    }

    /**
     * Returns whether the representation class for this
     * &lt;code&gt;DataFlavor&lt;/code&gt; is &lt;code&gt;java.io.Reader&lt;/code&gt; or a subclass
     * thereof.
     *
     * @since 1.4
     */
    public boolean isRepresentationClassReader() {
        return java.io.Reader.class.isAssignableFrom(representationClass);
    }

    /**
     * Returns whether the representation class for this
     * &lt;code&gt;DataFlavor&lt;/code&gt; is &lt;code&gt;java.nio.CharBuffer&lt;/code&gt; or a
     * subclass thereof.
     *
     * @since 1.4
     */
    public boolean isRepresentationClassCharBuffer() {
        return java.nio.CharBuffer.class.isAssignableFrom(representationClass);
    }

    /**
     * Returns whether the representation class for this
     * &lt;code&gt;DataFlavor&lt;/code&gt; is &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt; or a
     * subclass thereof.
     *
     * @since 1.4
     */
    public boolean isRepresentationClassByteBuffer() {
        return java.nio.ByteBuffer.class.isAssignableFrom(representationClass);
    }

   /**
    * Returns true if the representation class can be serialized.
    * @return true if the representation class can be serialized
    */

    public boolean isRepresentationClassSerializable() {
        return java.io.Serializable.class.isAssignableFrom(representationClass);
    }

   /**
    * Returns true if the representation class is &lt;code&gt;Remote&lt;/code&gt;.
    * @return true if the representation class is &lt;code&gt;Remote&lt;/code&gt;
    */

    public boolean isRepresentationClassRemote() {
        return DataTransferer.isRemote(representationClass);
    }

   /**
    * Returns true if the &lt;code&gt;DataFlavor&lt;/code&gt; specified represents
    * a serialized object.
    * @return true if the &lt;code&gt;DataFlavor&lt;/code&gt; specified represents
    *   a Serialized Object
    */

    public boolean isFlavorSerializedObjectType() {
        return isRepresentationClassSerializable() &amp;&amp; isMimeTypeEqual(javaSerializedObjectMimeType);
    }

    /**
     * Returns true if the &lt;code&gt;DataFlavor&lt;/code&gt; specified represents
     * a remote object.
     * @return true if the &lt;code&gt;DataFlavor&lt;/code&gt; specified represents
     *  a Remote Object
     */

    public boolean isFlavorRemoteObjectType() {
        return isRepresentationClassRemote()
            &amp;&amp; isRepresentationClassSerializable()
            &amp;&amp; isMimeTypeEqual(javaRemoteObjectMimeType);
    }


   /**
    * Returns true if the &lt;code&gt;DataFlavor&lt;/code&gt; specified represents
    * a list of file objects.
    * @return true if the &lt;code&gt;DataFlavor&lt;/code&gt; specified represents
    *   a List of File objects
    */

   public boolean isFlavorJavaFileListType() {
        if (mimeType == null || representationClass == null)
            return false;
        return java.util.List.class.isAssignableFrom(representationClass) &amp;&amp;
               mimeType.match(javaFileListFlavor.mimeType);

   }

    /**
     * Returns whether this &lt;code&gt;DataFlavor&lt;/code&gt; is a valid text flavor for
     * this implementation of the Java platform. Only flavors equivalent to
     * &lt;code&gt;DataFlavor.stringFlavor&lt;/code&gt; and &lt;code&gt;DataFlavor&lt;/code&gt;s with
     * a primary MIME type of &quot;text&quot; can be valid text flavors.
     * &lt;p&gt;
     * If this flavor supports the charset parameter, it must be equivalent to
     * &lt;code&gt;DataFlavor.stringFlavor&lt;/code&gt;, or its representation must be
     * &lt;code&gt;java.io.Reader&lt;/code&gt;, &lt;code&gt;java.lang.String&lt;/code&gt;,
     * &lt;code&gt;java.nio.CharBuffer&lt;/code&gt;, &lt;code&gt;[C&lt;/code&gt;,
     * &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, or
     * &lt;code&gt;[B&lt;/code&gt;. If the representation is
     * &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, or
     * &lt;code&gt;[B&lt;/code&gt;, then this flavor's &lt;code&gt;charset&lt;/code&gt; parameter must
     * be supported by this implementation of the Java platform. If a charset
     * is not specified, then the platform default charset, which is always
     * supported, is assumed.
     * &lt;p&gt;
     * If this flavor does not support the charset parameter, its
     * representation must be &lt;code&gt;java.io.InputStream&lt;/code&gt;,
     * &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, or &lt;code&gt;[B&lt;/code&gt;.
     * &lt;p&gt;
     * See &lt;code&gt;selectBestTextFlavor&lt;/code&gt; for a list of text flavors which
     * support the charset parameter.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;DataFlavor&lt;/code&gt; is a valid
     *         text flavor as described above; &lt;code&gt;false&lt;/code&gt; otherwise
     * @see #selectBestTextFlavor
     * @since 1.4
     */
    public boolean isFlavorTextType() {
        return (DataTransferer.isFlavorCharsetTextType(this) ||
                DataTransferer.isFlavorNoncharsetTextType(this));
    }

   /**
    * Serializes this &lt;code&gt;DataFlavor&lt;/code&gt;.
    */

   public synchronized void writeExternal(ObjectOutput os) throws IOException {
       if (mimeType != null) {
           mimeType.setParameter(&quot;humanPresentableName&quot;, humanPresentableName);
           os.writeObject(mimeType);
           mimeType.removeParameter(&quot;humanPresentableName&quot;);
       } else {
           os.writeObject(null);
       }

       os.writeObject(representationClass);
   }

   /**
    * Restores this &lt;code&gt;DataFlavor&lt;/code&gt; from a Serialized state.
    */

   public synchronized void readExternal(ObjectInput is) throws IOException , ClassNotFoundException {
       String rcn = null;
        mimeType = (MimeType)is.readObject();

        if (mimeType != null) {
            humanPresentableName =
                mimeType.getParameter(&quot;humanPresentableName&quot;);
            mimeType.removeParameter(&quot;humanPresentableName&quot;);
            rcn = mimeType.getParameter(&quot;class&quot;);
            if (rcn == null) {
                throw new IOException(&quot;no class parameter specified in: &quot; +
                                      mimeType);
            }
        }

        try {
            representationClass = (Class)is.readObject();
        } catch (OptionalDataException ode) {
            if (!ode.eof || ode.length != 0) {
                throw ode;
            }
            // Ensure backward compatibility.
            // Old versions didn't write the representation class to the stream.
            if (rcn != null) {
                representationClass =
                    DataFlavor.tryToLoadClass(rcn, getClass().getClassLoader());
            }
        }
   }

   /**
    * Returns a clone of this &lt;code&gt;DataFlavor&lt;/code&gt;.
    * @return a clone of this &lt;code&gt;DataFlavor&lt;/code&gt;
    */

    public Object clone() throws CloneNotSupportedException {
        Object newObj = super.clone();
        if (mimeType != null) {
            ((DataFlavor)newObj).mimeType = (MimeType)mimeType.clone();
        }
        return newObj;
    } // clone()

   /**
    * Called on &lt;code&gt;DataFlavor&lt;/code&gt; for every MIME Type parameter
    * to allow &lt;code&gt;DataFlavor&lt;/code&gt; subclasses to handle special
    * parameters like the text/plain &lt;code&gt;charset&lt;/code&gt;
    * parameters, whose values are case insensitive.  (MIME type parameter
    * values are supposed to be case sensitive.
    * &lt;p&gt;
    * This method is called for each parameter name/value pair and should
    * return the normalized representation of the &lt;code&gt;parameterValue&lt;/code&gt;.
    *
    * This method is never invoked by this implementation from 1.1 onwards.
    *
    * @deprecated
    */
    @Deprecated
    protected String normalizeMimeTypeParameter(String parameterName, String parameterValue) {
        return parameterValue;
    }

   /**
    * Called for each MIME type string to give &lt;code&gt;DataFlavor&lt;/code&gt; subtypes
    * the opportunity to change how the normalization of MIME types is
    * accomplished.  One possible use would be to add default
    * parameter/value pairs in cases where none are present in the MIME
    * type string passed in.
    *
    * This method is never invoked by this implementation from 1.1 onwards.
    *
    * @deprecated
    */
    @Deprecated
    protected String normalizeMimeType(String mimeType) {
        return mimeType;
    }

    /*
     * fields
     */

    /* placeholder for caching any platform-specific data for flavor */

    transient int       atom;

    /* Mime Type of DataFlavor */

    MimeType            mimeType;

    private String      humanPresentableName;

    /** Java class of objects this DataFlavor represents **/

    private Class&lt;?&gt;       representationClass;

} // class DataFlavor
</pre>
</body>
</html>
