<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/OdinCodeBrowser/css/styles.css"/>
    </head>
<body>
<table>
<tr>
<td><a class="linenum-cell" data-linenum="1" href="#"></a></td>
<td><pre>/*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2" href="#"></a></td>
<td><pre> * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3" href="#"></a></td>
<td><pre> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5" href="#"></a></td>
<td><pre> * This code is free software; you can redistribute it and/or modify it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="6" href="#"></a></td>
<td><pre> * under the terms of the GNU General Public License version 2 only, as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="7" href="#"></a></td>
<td><pre> * published by the Free Software Foundation.  Oracle designates this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="8" href="#"></a></td>
<td><pre> * particular file as subject to the &quot;Classpath&quot; exception as provided</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="9" href="#"></a></td>
<td><pre> * by Oracle in the LICENSE file that accompanied this code.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="10" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="11" href="#"></a></td>
<td><pre> * This code is distributed in the hope that it will be useful, but WITHOUT</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="12" href="#"></a></td>
<td><pre> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="13" href="#"></a></td>
<td><pre> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="14" href="#"></a></td>
<td><pre> * version 2 for more details (a copy is included in the LICENSE file that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="15" href="#"></a></td>
<td><pre> * accompanied this code).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="16" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="17" href="#"></a></td>
<td><pre> * You should have received a copy of the GNU General Public License version</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="18" href="#"></a></td>
<td><pre> * 2 along with this work; if not, write to the Free Software Foundation,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="19" href="#"></a></td>
<td><pre> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="20" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="21" href="#"></a></td>
<td><pre> * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="22" href="#"></a></td>
<td><pre> * or visit www.oracle.com if you need additional information or have any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="23" href="#"></a></td>
<td><pre> * questions.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="24" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="25" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="26" href="#"></a></td>
<td><pre>/*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="27" href="#"></a></td>
<td><pre> * Portions Copyright (c) 1995  Colin Plumb.  All rights reserved.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="28" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="29" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="30" href="#"></a></td>
<td><pre>package java.math;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="31" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="32" href="#"></a></td>
<td><pre>import java.io.IOException;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="33" href="#"></a></td>
<td><pre>import java.io.ObjectInputStream;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="34" href="#"></a></td>
<td><pre>import java.io.ObjectOutputStream;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="35" href="#"></a></td>
<td><pre>import java.io.ObjectStreamField;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="36" href="#"></a></td>
<td><pre>import java.util.Arrays;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="37" href="#"></a></td>
<td><pre>import java.util.Random;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="38" href="#"></a></td>
<td><pre>import java.util.concurrent.ThreadLocalRandom;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="39" href="#"></a></td>
<td><pre>import sun.misc.DoubleConsts;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="40" href="#"></a></td>
<td><pre>import sun.misc.FloatConsts;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="41" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="42" href="#"></a></td>
<td><pre>/**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="43" href="#"></a></td>
<td><pre> * Immutable arbitrary-precision integers.  All operations behave as if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="44" href="#"></a></td>
<td><pre> * BigIntegers were represented in two's-complement notation (like Java's</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="45" href="#"></a></td>
<td><pre> * primitive integer types).  BigInteger provides analogues to all of Java's</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="46" href="#"></a></td>
<td><pre> * primitive integer operators, and all relevant methods from java.lang.Math.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="47" href="#"></a></td>
<td><pre> * Additionally, BigInteger provides operations for modular arithmetic, GCD</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="48" href="#"></a></td>
<td><pre> * calculation, primality testing, prime generation, bit manipulation,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="49" href="#"></a></td>
<td><pre> * and a few other miscellaneous operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="50" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="51" href="#"></a></td>
<td><pre> * &lt;p&gt;Semantics of arithmetic operations exactly mimic those of Java's integer</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="52" href="#"></a></td>
<td><pre> * arithmetic operators, as defined in &lt;i&gt;The Java Language Specification&lt;/i&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="53" href="#"></a></td>
<td><pre> * For example, division by zero throws an {@code ArithmeticException}, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="54" href="#"></a></td>
<td><pre> * division of a negative by a positive yields a negative (or zero) remainder.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="55" href="#"></a></td>
<td><pre> * All of the details in the Spec concerning overflow are ignored, as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="56" href="#"></a></td>
<td><pre> * BigIntegers are made as large as necessary to accommodate the results of an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="57" href="#"></a></td>
<td><pre> * operation.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="58" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="59" href="#"></a></td>
<td><pre> * &lt;p&gt;Semantics of shift operations extend those of Java's shift operators</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="60" href="#"></a></td>
<td><pre> * to allow for negative shift distances.  A right-shift with a negative</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="61" href="#"></a></td>
<td><pre> * shift distance results in a left shift, and vice-versa.  The unsigned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="62" href="#"></a></td>
<td><pre> * right shift operator ({@code &gt;&gt;&gt;}) is omitted, as this operation makes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="63" href="#"></a></td>
<td><pre> * little sense in combination with the &quot;infinite word size&quot; abstraction</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="64" href="#"></a></td>
<td><pre> * provided by this class.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="65" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="66" href="#"></a></td>
<td><pre> * &lt;p&gt;Semantics of bitwise logical operations exactly mimic those of Java's</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="67" href="#"></a></td>
<td><pre> * bitwise integer operators.  The binary operators ({@code and},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="68" href="#"></a></td>
<td><pre> * {@code or}, {@code xor}) implicitly perform sign extension on the shorter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="69" href="#"></a></td>
<td><pre> * of the two operands prior to performing the operation.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="70" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="71" href="#"></a></td>
<td><pre> * &lt;p&gt;Comparison operations perform signed integer comparisons, analogous to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="72" href="#"></a></td>
<td><pre> * those performed by Java's relational and equality operators.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="73" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="74" href="#"></a></td>
<td><pre> * &lt;p&gt;Modular arithmetic operations are provided to compute residues, perform</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="75" href="#"></a></td>
<td><pre> * exponentiation, and compute multiplicative inverses.  These methods always</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="76" href="#"></a></td>
<td><pre> * return a non-negative result, between {@code 0} and {@code (modulus - 1)},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="77" href="#"></a></td>
<td><pre> * inclusive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="78" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="79" href="#"></a></td>
<td><pre> * &lt;p&gt;Bit operations operate on a single bit of the two's-complement</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="80" href="#"></a></td>
<td><pre> * representation of their operand.  If necessary, the operand is sign-</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="81" href="#"></a></td>
<td><pre> * extended so that it contains the designated bit.  None of the single-bit</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="82" href="#"></a></td>
<td><pre> * operations can produce a BigInteger with a different sign from the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="83" href="#"></a></td>
<td><pre> * BigInteger being operated on, as they affect only a single bit, and the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="84" href="#"></a></td>
<td><pre> * &quot;infinite word size&quot; abstraction provided by this class ensures that there</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="85" href="#"></a></td>
<td><pre> * are infinitely many &quot;virtual sign bits&quot; preceding each BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="86" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="87" href="#"></a></td>
<td><pre> * &lt;p&gt;For the sake of brevity and clarity, pseudo-code is used throughout the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="88" href="#"></a></td>
<td><pre> * descriptions of BigInteger methods.  The pseudo-code expression</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="89" href="#"></a></td>
<td><pre> * {@code (i + j)} is shorthand for &quot;a BigInteger whose value is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="90" href="#"></a></td>
<td><pre> * that of the BigInteger {@code i} plus that of the BigInteger {@code j}.&quot;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="91" href="#"></a></td>
<td><pre> * The pseudo-code expression {@code (i == j)} is shorthand for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="92" href="#"></a></td>
<td><pre> * &quot;{@code true} if and only if the BigInteger {@code i} represents the same</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="93" href="#"></a></td>
<td><pre> * value as the BigInteger {@code j}.&quot;  Other pseudo-code expressions are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="94" href="#"></a></td>
<td><pre> * interpreted similarly.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="95" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="96" href="#"></a></td>
<td><pre> * &lt;p&gt;All methods and constructors in this class throw</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="97" href="#"></a></td>
<td><pre> * {@code NullPointerException} when passed</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="98" href="#"></a></td>
<td><pre> * a null object reference for any input parameter.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="99" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="100" href="#"></a></td>
<td><pre> * BigInteger must support values in the range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="101" href="#"></a></td>
<td><pre> * -2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive) to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="102" href="#"></a></td>
<td><pre> * +2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="103" href="#"></a></td>
<td><pre> * and may support values outside of that range.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="104" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="105" href="#"></a></td>
<td><pre> * The range of probable prime values is limited and may be less than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="106" href="#"></a></td>
<td><pre> * the full supported positive range of {@code BigInteger}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="107" href="#"></a></td>
<td><pre> * The range must be at least 1 to 2&lt;sup&gt;500000000&lt;/sup&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="108" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="109" href="#"></a></td>
<td><pre> * @implNote</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="110" href="#"></a></td>
<td><pre> * BigInteger constructors and operations throw {@code ArithmeticException} when</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="111" href="#"></a></td>
<td><pre> * the result is out of the supported range of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="112" href="#"></a></td>
<td><pre> * -2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive) to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="113" href="#"></a></td>
<td><pre> * +2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="114" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="115" href="#"></a></td>
<td><pre> * @see     BigDecimal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="116" href="#"></a></td>
<td><pre> * @author  Josh Bloch</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="117" href="#"></a></td>
<td><pre> * @author  Michael McCloskey</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="118" href="#"></a></td>
<td><pre> * @author  Alan Eliasen</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="119" href="#"></a></td>
<td><pre> * @author  Timothy Buktu</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="120" href="#"></a></td>
<td><pre> * @since JDK1.1</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="121" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="122" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="123" href="#"></a></td>
<td><pre>public class BigInteger extends Number implements Comparable&lt;BigInteger&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="124" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="125" href="#"></a></td>
<td><pre>     * The signum of this BigInteger: -1 for negative, 0 for zero, or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="126" href="#"></a></td>
<td><pre>     * 1 for positive.  Note that the BigInteger zero &lt;i&gt;must&lt;/i&gt; have</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="127" href="#"></a></td>
<td><pre>     * a signum of 0.  This is necessary to ensures that there is exactly one</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="128" href="#"></a></td>
<td><pre>     * representation for each BigInteger value.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="129" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="130" href="#"></a></td>
<td><pre>     * @serial</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="131" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="132" href="#"></a></td>
<td><pre>    final int signum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="133" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="134" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="135" href="#"></a></td>
<td><pre>     * The magnitude of this BigInteger, in &lt;i&gt;big-endian&lt;/i&gt; order: the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="136" href="#"></a></td>
<td><pre>     * zeroth element of this array is the most-significant int of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="137" href="#"></a></td>
<td><pre>     * magnitude.  The magnitude must be &quot;minimal&quot; in that the most-significant</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="138" href="#"></a></td>
<td><pre>     * int ({@code mag[0]}) must be non-zero.  This is necessary to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="139" href="#"></a></td>
<td><pre>     * ensure that there is exactly one representation for each BigInteger</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="140" href="#"></a></td>
<td><pre>     * value.  Note that this implies that the BigInteger zero has a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="141" href="#"></a></td>
<td><pre>     * zero-length mag array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="142" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="143" href="#"></a></td>
<td><pre>    final int[] mag;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="144" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="145" href="#"></a></td>
<td><pre>    // These &quot;redundant fields&quot; are initialized with recognizable nonsense</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="146" href="#"></a></td>
<td><pre>    // values, and cached the first time they are needed (or never, if they</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="147" href="#"></a></td>
<td><pre>    // aren't needed).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="148" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="149" href="#"></a></td>
<td><pre>     /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="150" href="#"></a></td>
<td><pre>     * One plus the bitCount of this BigInteger. Zeros means unitialized.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="151" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="152" href="#"></a></td>
<td><pre>     * @serial</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="153" href="#"></a></td>
<td><pre>     * @see #bitCount</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="154" href="#"></a></td>
<td><pre>     * @deprecated Deprecated since logical value is offset from stored</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="155" href="#"></a></td>
<td><pre>     * value and correction factor is applied in accessor method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="156" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="157" href="#"></a></td>
<td><pre>    @Deprecated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="158" href="#"></a></td>
<td><pre>    private int bitCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="159" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="160" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="161" href="#"></a></td>
<td><pre>     * One plus the bitLength of this BigInteger. Zeros means unitialized.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="162" href="#"></a></td>
<td><pre>     * (either value is acceptable).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="163" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="164" href="#"></a></td>
<td><pre>     * @serial</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="165" href="#"></a></td>
<td><pre>     * @see #bitLength()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="166" href="#"></a></td>
<td><pre>     * @deprecated Deprecated since logical value is offset from stored</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="167" href="#"></a></td>
<td><pre>     * value and correction factor is applied in accessor method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="168" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="169" href="#"></a></td>
<td><pre>    @Deprecated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="170" href="#"></a></td>
<td><pre>    private int bitLength;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="171" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="172" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="173" href="#"></a></td>
<td><pre>     * Two plus the lowest set bit of this BigInteger, as returned by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="174" href="#"></a></td>
<td><pre>     * getLowestSetBit().</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="175" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="176" href="#"></a></td>
<td><pre>     * @serial</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="177" href="#"></a></td>
<td><pre>     * @see #getLowestSetBit</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="178" href="#"></a></td>
<td><pre>     * @deprecated Deprecated since logical value is offset from stored</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="179" href="#"></a></td>
<td><pre>     * value and correction factor is applied in accessor method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="180" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="181" href="#"></a></td>
<td><pre>    @Deprecated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="182" href="#"></a></td>
<td><pre>    private int lowestSetBit;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="183" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="184" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="185" href="#"></a></td>
<td><pre>     * Two plus the index of the lowest-order int in the magnitude of this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="186" href="#"></a></td>
<td><pre>     * BigInteger that contains a nonzero int, or -2 (either value is acceptable).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="187" href="#"></a></td>
<td><pre>     * The least significant int has int-number 0, the next int in order of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="188" href="#"></a></td>
<td><pre>     * increasing significance has int-number 1, and so forth.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="189" href="#"></a></td>
<td><pre>     * @deprecated Deprecated since logical value is offset from stored</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="190" href="#"></a></td>
<td><pre>     * value and correction factor is applied in accessor method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="191" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="192" href="#"></a></td>
<td><pre>    @Deprecated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="193" href="#"></a></td>
<td><pre>    private int firstNonzeroIntNum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="194" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="195" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="196" href="#"></a></td>
<td><pre>     * This mask is used to obtain the value of an int as if it were unsigned.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="197" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="198" href="#"></a></td>
<td><pre>    final static long LONG_MASK = 0xffffffffL;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="199" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="200" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="201" href="#"></a></td>
<td><pre>     * This constant limits {@code mag.length} of BigIntegers to the supported</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="202" href="#"></a></td>
<td><pre>     * range.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="203" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="204" href="#"></a></td>
<td><pre>    private static final int MAX_MAG_LENGTH = Integer.MAX_VALUE / Integer.SIZE + 1; // (1 &lt;&lt; 26)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="205" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="206" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="207" href="#"></a></td>
<td><pre>     * Bit lengths larger than this constant can cause overflow in searchLen</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="208" href="#"></a></td>
<td><pre>     * calculation and in BitSieve.singleSearch method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="209" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="210" href="#"></a></td>
<td><pre>    private static final  int PRIME_SEARCH_BIT_LENGTH_LIMIT = 500000000;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="211" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="212" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="213" href="#"></a></td>
<td><pre>     * The threshold value for using Karatsuba multiplication.  If the number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="214" href="#"></a></td>
<td><pre>     * of ints in both mag arrays are greater than this number, then</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="215" href="#"></a></td>
<td><pre>     * Karatsuba multiplication will be used.   This value is found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="216" href="#"></a></td>
<td><pre>     * experimentally to work well.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="217" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="218" href="#"></a></td>
<td><pre>    private static final int KARATSUBA_THRESHOLD = 80;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="219" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="220" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="221" href="#"></a></td>
<td><pre>     * The threshold value for using 3-way Toom-Cook multiplication.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="222" href="#"></a></td>
<td><pre>     * If the number of ints in each mag array is greater than the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="223" href="#"></a></td>
<td><pre>     * Karatsuba threshold, and the number of ints in at least one of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="224" href="#"></a></td>
<td><pre>     * the mag arrays is greater than this threshold, then Toom-Cook</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="225" href="#"></a></td>
<td><pre>     * multiplication will be used.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="226" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="227" href="#"></a></td>
<td><pre>    private static final int TOOM_COOK_THRESHOLD = 240;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="228" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="229" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="230" href="#"></a></td>
<td><pre>     * The threshold value for using Karatsuba squaring.  If the number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="231" href="#"></a></td>
<td><pre>     * of ints in the number are larger than this value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="232" href="#"></a></td>
<td><pre>     * Karatsuba squaring will be used.   This value is found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="233" href="#"></a></td>
<td><pre>     * experimentally to work well.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="234" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="235" href="#"></a></td>
<td><pre>    private static final int KARATSUBA_SQUARE_THRESHOLD = 128;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="236" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="237" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="238" href="#"></a></td>
<td><pre>     * The threshold value for using Toom-Cook squaring.  If the number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="239" href="#"></a></td>
<td><pre>     * of ints in the number are larger than this value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="240" href="#"></a></td>
<td><pre>     * Toom-Cook squaring will be used.   This value is found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="241" href="#"></a></td>
<td><pre>     * experimentally to work well.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="242" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="243" href="#"></a></td>
<td><pre>    private static final int TOOM_COOK_SQUARE_THRESHOLD = 216;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="244" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="245" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="246" href="#"></a></td>
<td><pre>     * The threshold value for using Burnikel-Ziegler division.  If the number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="247" href="#"></a></td>
<td><pre>     * of ints in the divisor are larger than this value, Burnikel-Ziegler</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="248" href="#"></a></td>
<td><pre>     * division may be used.  This value is found experimentally to work well.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="249" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="250" href="#"></a></td>
<td><pre>    static final int BURNIKEL_ZIEGLER_THRESHOLD = 80;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="251" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="252" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="253" href="#"></a></td>
<td><pre>     * The offset value for using Burnikel-Ziegler division.  If the number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="254" href="#"></a></td>
<td><pre>     * of ints in the divisor exceeds the Burnikel-Ziegler threshold, and the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="255" href="#"></a></td>
<td><pre>     * number of ints in the dividend is greater than the number of ints in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="256" href="#"></a></td>
<td><pre>     * divisor plus this value, Burnikel-Ziegler division will be used.  This</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="257" href="#"></a></td>
<td><pre>     * value is found experimentally to work well.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="258" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="259" href="#"></a></td>
<td><pre>    static final int BURNIKEL_ZIEGLER_OFFSET = 40;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="260" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="261" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="262" href="#"></a></td>
<td><pre>     * The threshold value for using Schoenhage recursive base conversion. If</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="263" href="#"></a></td>
<td><pre>     * the number of ints in the number are larger than this value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="264" href="#"></a></td>
<td><pre>     * the Schoenhage algorithm will be used.  In practice, it appears that the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="265" href="#"></a></td>
<td><pre>     * Schoenhage routine is faster for any threshold down to 2, and is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="266" href="#"></a></td>
<td><pre>     * relatively flat for thresholds between 2-25, so this choice may be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="267" href="#"></a></td>
<td><pre>     * varied within this range for very small effect.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="268" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="269" href="#"></a></td>
<td><pre>    private static final int SCHOENHAGE_BASE_CONVERSION_THRESHOLD = 20;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="270" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="271" href="#"></a></td>
<td><pre>    //Constructors</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="272" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="273" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="274" href="#"></a></td>
<td><pre>     * Translates a byte array containing the two's-complement binary</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="275" href="#"></a></td>
<td><pre>     * representation of a BigInteger into a BigInteger.  The input array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="276" href="#"></a></td>
<td><pre>     * assumed to be in &lt;i&gt;big-endian&lt;/i&gt; byte-order: the most significant</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="277" href="#"></a></td>
<td><pre>     * byte is in the zeroth element.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="278" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="279" href="#"></a></td>
<td><pre>     * @param  val big-endian two's-complement binary representation of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="280" href="#"></a></td>
<td><pre>     *         BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="281" href="#"></a></td>
<td><pre>     * @throws NumberFormatException {@code val} is zero bytes long.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="282" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="283" href="#"></a></td>
<td><pre>    public BigInteger(byte[] val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="284" href="#"></a></td>
<td><pre>        if (val.length == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="285" href="#"></a></td>
<td><pre>            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="286" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="287" href="#"></a></td>
<td><pre>        if (val[0] &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="288" href="#"></a></td>
<td><pre>            mag = makePositive(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="289" href="#"></a></td>
<td><pre>            signum = -1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="290" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="291" href="#"></a></td>
<td><pre>            mag = stripLeadingZeroBytes(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="292" href="#"></a></td>
<td><pre>            signum = (mag.length == 0 ? 0 : 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="293" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="294" href="#"></a></td>
<td><pre>        if (mag.length &gt;= MAX_MAG_LENGTH) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="295" href="#"></a></td>
<td><pre>            checkRange();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="296" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="297" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="298" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="299" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="300" href="#"></a></td>
<td><pre>     * This private constructor translates an int array containing the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="301" href="#"></a></td>
<td><pre>     * two's-complement binary representation of a BigInteger into a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="302" href="#"></a></td>
<td><pre>     * BigInteger. The input array is assumed to be in &lt;i&gt;big-endian&lt;/i&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="303" href="#"></a></td>
<td><pre>     * int-order: the most significant int is in the zeroth element.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="304" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="305" href="#"></a></td>
<td><pre>    private BigInteger(int[] val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="306" href="#"></a></td>
<td><pre>        if (val.length == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="307" href="#"></a></td>
<td><pre>            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="308" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="309" href="#"></a></td>
<td><pre>        if (val[0] &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="310" href="#"></a></td>
<td><pre>            mag = makePositive(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="311" href="#"></a></td>
<td><pre>            signum = -1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="312" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="313" href="#"></a></td>
<td><pre>            mag = trustedStripLeadingZeroInts(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="314" href="#"></a></td>
<td><pre>            signum = (mag.length == 0 ? 0 : 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="315" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="316" href="#"></a></td>
<td><pre>        if (mag.length &gt;= MAX_MAG_LENGTH) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="317" href="#"></a></td>
<td><pre>            checkRange();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="318" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="319" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="320" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="321" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="322" href="#"></a></td>
<td><pre>     * Translates the sign-magnitude representation of a BigInteger into a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="323" href="#"></a></td>
<td><pre>     * BigInteger.  The sign is represented as an integer signum value: -1 for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="324" href="#"></a></td>
<td><pre>     * negative, 0 for zero, or 1 for positive.  The magnitude is a byte array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="325" href="#"></a></td>
<td><pre>     * in &lt;i&gt;big-endian&lt;/i&gt; byte-order: the most significant byte is in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="326" href="#"></a></td>
<td><pre>     * zeroth element.  A zero-length magnitude array is permissible, and will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="327" href="#"></a></td>
<td><pre>     * result in a BigInteger value of 0, whether signum is -1, 0 or 1.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="328" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="329" href="#"></a></td>
<td><pre>     * @param  signum signum of the number (-1 for negative, 0 for zero, 1</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="330" href="#"></a></td>
<td><pre>     *         for positive).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="331" href="#"></a></td>
<td><pre>     * @param  magnitude big-endian binary representation of the magnitude of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="332" href="#"></a></td>
<td><pre>     *         the number.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="333" href="#"></a></td>
<td><pre>     * @throws NumberFormatException {@code signum} is not one of the three</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="334" href="#"></a></td>
<td><pre>     *         legal values (-1, 0, and 1), or {@code signum} is 0 and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="335" href="#"></a></td>
<td><pre>     *         {@code magnitude} contains one or more non-zero bytes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="336" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="337" href="#"></a></td>
<td><pre>    public BigInteger(int signum, byte[] magnitude) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="338" href="#"></a></td>
<td><pre>        this.mag = stripLeadingZeroBytes(magnitude);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="339" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="340" href="#"></a></td>
<td><pre>        if (signum &lt; -1 || signum &gt; 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="341" href="#"></a></td>
<td><pre>            throw(new NumberFormatException(&quot;Invalid signum value&quot;));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="342" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="343" href="#"></a></td>
<td><pre>        if (this.mag.length == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="344" href="#"></a></td>
<td><pre>            this.signum = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="345" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="346" href="#"></a></td>
<td><pre>            if (signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="347" href="#"></a></td>
<td><pre>                throw(new NumberFormatException(&quot;signum-magnitude mismatch&quot;));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="348" href="#"></a></td>
<td><pre>            this.signum = signum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="349" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="350" href="#"></a></td>
<td><pre>        if (mag.length &gt;= MAX_MAG_LENGTH) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="351" href="#"></a></td>
<td><pre>            checkRange();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="352" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="353" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="354" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="355" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="356" href="#"></a></td>
<td><pre>     * A constructor for internal use that translates the sign-magnitude</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="357" href="#"></a></td>
<td><pre>     * representation of a BigInteger into a BigInteger. It checks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="358" href="#"></a></td>
<td><pre>     * arguments and copies the magnitude so this constructor would be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="359" href="#"></a></td>
<td><pre>     * safe for external use.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="360" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="361" href="#"></a></td>
<td><pre>    private BigInteger(int signum, int[] magnitude) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="362" href="#"></a></td>
<td><pre>        this.mag = stripLeadingZeroInts(magnitude);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="363" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="364" href="#"></a></td>
<td><pre>        if (signum &lt; -1 || signum &gt; 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="365" href="#"></a></td>
<td><pre>            throw(new NumberFormatException(&quot;Invalid signum value&quot;));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="366" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="367" href="#"></a></td>
<td><pre>        if (this.mag.length == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="368" href="#"></a></td>
<td><pre>            this.signum = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="369" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="370" href="#"></a></td>
<td><pre>            if (signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="371" href="#"></a></td>
<td><pre>                throw(new NumberFormatException(&quot;signum-magnitude mismatch&quot;));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="372" href="#"></a></td>
<td><pre>            this.signum = signum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="373" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="374" href="#"></a></td>
<td><pre>        if (mag.length &gt;= MAX_MAG_LENGTH) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="375" href="#"></a></td>
<td><pre>            checkRange();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="376" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="377" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="378" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="379" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="380" href="#"></a></td>
<td><pre>     * Translates the String representation of a BigInteger in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="381" href="#"></a></td>
<td><pre>     * specified radix into a BigInteger.  The String representation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="382" href="#"></a></td>
<td><pre>     * consists of an optional minus or plus sign followed by a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="383" href="#"></a></td>
<td><pre>     * sequence of one or more digits in the specified radix.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="384" href="#"></a></td>
<td><pre>     * character-to-digit mapping is provided by {@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="385" href="#"></a></td>
<td><pre>     * Character.digit}.  The String may not contain any extraneous</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="386" href="#"></a></td>
<td><pre>     * characters (whitespace, for example).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="387" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="388" href="#"></a></td>
<td><pre>     * @param val String representation of BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="389" href="#"></a></td>
<td><pre>     * @param radix radix to be used in interpreting {@code val}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="390" href="#"></a></td>
<td><pre>     * @throws NumberFormatException {@code val} is not a valid representation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="391" href="#"></a></td>
<td><pre>     *         of a BigInteger in the specified radix, or {@code radix} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="392" href="#"></a></td>
<td><pre>     *         outside the range from {@link Character#MIN_RADIX} to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="393" href="#"></a></td>
<td><pre>     *         {@link Character#MAX_RADIX}, inclusive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="394" href="#"></a></td>
<td><pre>     * @see    Character#digit</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="395" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="396" href="#"></a></td>
<td><pre>    public BigInteger(String val, int radix) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="397" href="#"></a></td>
<td><pre>        int cursor = 0, numDigits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="398" href="#"></a></td>
<td><pre>        final int len = val.length();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="399" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="400" href="#"></a></td>
<td><pre>        if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="401" href="#"></a></td>
<td><pre>            throw new NumberFormatException(&quot;Radix out of range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="402" href="#"></a></td>
<td><pre>        if (len == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="403" href="#"></a></td>
<td><pre>            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="404" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="405" href="#"></a></td>
<td><pre>        // Check for at most one leading sign</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="406" href="#"></a></td>
<td><pre>        int sign = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="407" href="#"></a></td>
<td><pre>        int index1 = val.lastIndexOf('-');</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="408" href="#"></a></td>
<td><pre>        int index2 = val.lastIndexOf('+');</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="409" href="#"></a></td>
<td><pre>        if (index1 &gt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="410" href="#"></a></td>
<td><pre>            if (index1 != 0 || index2 &gt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="411" href="#"></a></td>
<td><pre>                throw new NumberFormatException(&quot;Illegal embedded sign character&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="412" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="413" href="#"></a></td>
<td><pre>            sign = -1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="414" href="#"></a></td>
<td><pre>            cursor = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="415" href="#"></a></td>
<td><pre>        } else if (index2 &gt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="416" href="#"></a></td>
<td><pre>            if (index2 != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="417" href="#"></a></td>
<td><pre>                throw new NumberFormatException(&quot;Illegal embedded sign character&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="418" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="419" href="#"></a></td>
<td><pre>            cursor = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="420" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="421" href="#"></a></td>
<td><pre>        if (cursor == len)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="422" href="#"></a></td>
<td><pre>            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="423" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="424" href="#"></a></td>
<td><pre>        // Skip leading zeros and compute number of digits in magnitude</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="425" href="#"></a></td>
<td><pre>        while (cursor &lt; len &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="426" href="#"></a></td>
<td><pre>               Character.digit(val.charAt(cursor), radix) == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="427" href="#"></a></td>
<td><pre>            cursor++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="428" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="429" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="430" href="#"></a></td>
<td><pre>        if (cursor == len) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="431" href="#"></a></td>
<td><pre>            signum = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="432" href="#"></a></td>
<td><pre>            mag = ZERO.mag;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="433" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="434" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="435" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="436" href="#"></a></td>
<td><pre>        numDigits = len - cursor;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="437" href="#"></a></td>
<td><pre>        signum = sign;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="438" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="439" href="#"></a></td>
<td><pre>        // Pre-allocate array of expected size. May be too large but can</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="440" href="#"></a></td>
<td><pre>        // never be too small. Typically exact.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="441" href="#"></a></td>
<td><pre>        long numBits = ((numDigits * bitsPerDigit[radix]) &gt;&gt;&gt; 10) + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="442" href="#"></a></td>
<td><pre>        if (numBits + 31 &gt;= (1L &lt;&lt; 32)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="443" href="#"></a></td>
<td><pre>            reportOverflow();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="444" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="445" href="#"></a></td>
<td><pre>        int numWords = (int) (numBits + 31) &gt;&gt;&gt; 5;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="446" href="#"></a></td>
<td><pre>        int[] magnitude = new int[numWords];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="447" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="448" href="#"></a></td>
<td><pre>        // Process first (potentially short) digit group</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="449" href="#"></a></td>
<td><pre>        int firstGroupLen = numDigits % digitsPerInt[radix];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="450" href="#"></a></td>
<td><pre>        if (firstGroupLen == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="451" href="#"></a></td>
<td><pre>            firstGroupLen = digitsPerInt[radix];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="452" href="#"></a></td>
<td><pre>        String group = val.substring(cursor, cursor += firstGroupLen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="453" href="#"></a></td>
<td><pre>        magnitude[numWords - 1] = Integer.parseInt(group, radix);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="454" href="#"></a></td>
<td><pre>        if (magnitude[numWords - 1] &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="455" href="#"></a></td>
<td><pre>            throw new NumberFormatException(&quot;Illegal digit&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="456" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="457" href="#"></a></td>
<td><pre>        // Process remaining digit groups</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="458" href="#"></a></td>
<td><pre>        int superRadix = intRadix[radix];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="459" href="#"></a></td>
<td><pre>        int groupVal = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="460" href="#"></a></td>
<td><pre>        while (cursor &lt; len) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="461" href="#"></a></td>
<td><pre>            group = val.substring(cursor, cursor += digitsPerInt[radix]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="462" href="#"></a></td>
<td><pre>            groupVal = Integer.parseInt(group, radix);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="463" href="#"></a></td>
<td><pre>            if (groupVal &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="464" href="#"></a></td>
<td><pre>                throw new NumberFormatException(&quot;Illegal digit&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="465" href="#"></a></td>
<td><pre>            destructiveMulAdd(magnitude, superRadix, groupVal);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="466" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="467" href="#"></a></td>
<td><pre>        // Required for cases where the array was overallocated.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="468" href="#"></a></td>
<td><pre>        mag = trustedStripLeadingZeroInts(magnitude);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="469" href="#"></a></td>
<td><pre>        if (mag.length &gt;= MAX_MAG_LENGTH) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="470" href="#"></a></td>
<td><pre>            checkRange();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="471" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="472" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="473" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="474" href="#"></a></td>
<td><pre>    /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="475" href="#"></a></td>
<td><pre>     * Constructs a new BigInteger using a char array with radix=10.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="476" href="#"></a></td>
<td><pre>     * Sign is precalculated outside and not allowed in the val.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="477" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="478" href="#"></a></td>
<td><pre>    BigInteger(char[] val, int sign, int len) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="479" href="#"></a></td>
<td><pre>        int cursor = 0, numDigits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="480" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="481" href="#"></a></td>
<td><pre>        // Skip leading zeros and compute number of digits in magnitude</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="482" href="#"></a></td>
<td><pre>        while (cursor &lt; len &amp;&amp; Character.digit(val[cursor], 10) == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="483" href="#"></a></td>
<td><pre>            cursor++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="484" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="485" href="#"></a></td>
<td><pre>        if (cursor == len) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="486" href="#"></a></td>
<td><pre>            signum = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="487" href="#"></a></td>
<td><pre>            mag = ZERO.mag;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="488" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="489" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="490" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="491" href="#"></a></td>
<td><pre>        numDigits = len - cursor;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="492" href="#"></a></td>
<td><pre>        signum = sign;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="493" href="#"></a></td>
<td><pre>        // Pre-allocate array of expected size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="494" href="#"></a></td>
<td><pre>        int numWords;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="495" href="#"></a></td>
<td><pre>        if (len &lt; 10) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="496" href="#"></a></td>
<td><pre>            numWords = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="497" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="498" href="#"></a></td>
<td><pre>            long numBits = ((numDigits * bitsPerDigit[10]) &gt;&gt;&gt; 10) + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="499" href="#"></a></td>
<td><pre>            if (numBits + 31 &gt;= (1L &lt;&lt; 32)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="500" href="#"></a></td>
<td><pre>                reportOverflow();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="501" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="502" href="#"></a></td>
<td><pre>            numWords = (int) (numBits + 31) &gt;&gt;&gt; 5;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="503" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="504" href="#"></a></td>
<td><pre>        int[] magnitude = new int[numWords];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="505" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="506" href="#"></a></td>
<td><pre>        // Process first (potentially short) digit group</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="507" href="#"></a></td>
<td><pre>        int firstGroupLen = numDigits % digitsPerInt[10];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="508" href="#"></a></td>
<td><pre>        if (firstGroupLen == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="509" href="#"></a></td>
<td><pre>            firstGroupLen = digitsPerInt[10];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="510" href="#"></a></td>
<td><pre>        magnitude[numWords - 1] = parseInt(val, cursor,  cursor += firstGroupLen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="511" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="512" href="#"></a></td>
<td><pre>        // Process remaining digit groups</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="513" href="#"></a></td>
<td><pre>        while (cursor &lt; len) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="514" href="#"></a></td>
<td><pre>            int groupVal = parseInt(val, cursor, cursor += digitsPerInt[10]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="515" href="#"></a></td>
<td><pre>            destructiveMulAdd(magnitude, intRadix[10], groupVal);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="516" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="517" href="#"></a></td>
<td><pre>        mag = trustedStripLeadingZeroInts(magnitude);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="518" href="#"></a></td>
<td><pre>        if (mag.length &gt;= MAX_MAG_LENGTH) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="519" href="#"></a></td>
<td><pre>            checkRange();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="520" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="521" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="522" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="523" href="#"></a></td>
<td><pre>    // Create an integer with the digits between the two indexes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="524" href="#"></a></td>
<td><pre>    // Assumes start &lt; end. The result may be negative, but it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="525" href="#"></a></td>
<td><pre>    // is to be treated as an unsigned value.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="526" href="#"></a></td>
<td><pre>    private int parseInt(char[] source, int start, int end) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="527" href="#"></a></td>
<td><pre>        int result = Character.digit(source[start++], 10);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="528" href="#"></a></td>
<td><pre>        if (result == -1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="529" href="#"></a></td>
<td><pre>            throw new NumberFormatException(new String(source));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="530" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="531" href="#"></a></td>
<td><pre>        for (int index = start; index &lt; end; index++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="532" href="#"></a></td>
<td><pre>            int nextVal = Character.digit(source[index], 10);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="533" href="#"></a></td>
<td><pre>            if (nextVal == -1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="534" href="#"></a></td>
<td><pre>                throw new NumberFormatException(new String(source));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="535" href="#"></a></td>
<td><pre>            result = 10*result + nextVal;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="536" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="537" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="538" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="539" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="540" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="541" href="#"></a></td>
<td><pre>    // bitsPerDigit in the given radix times 1024</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="542" href="#"></a></td>
<td><pre>    // Rounded up to avoid underallocation.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="543" href="#"></a></td>
<td><pre>    private static long bitsPerDigit[] = { 0, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="544" href="#"></a></td>
<td><pre>        1024, 1624, 2048, 2378, 2648, 2875, 3072, 3247, 3402, 3543, 3672,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="545" href="#"></a></td>
<td><pre>        3790, 3899, 4001, 4096, 4186, 4271, 4350, 4426, 4498, 4567, 4633,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="546" href="#"></a></td>
<td><pre>        4696, 4756, 4814, 4870, 4923, 4975, 5025, 5074, 5120, 5166, 5210,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="547" href="#"></a></td>
<td><pre>                                           5253, 5295};</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="548" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="549" href="#"></a></td>
<td><pre>    // Multiply x array times word y in place, and add word z</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="550" href="#"></a></td>
<td><pre>    private static void destructiveMulAdd(int[] x, int y, int z) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="551" href="#"></a></td>
<td><pre>        // Perform the multiplication word by word</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="552" href="#"></a></td>
<td><pre>        long ylong = y &amp; LONG_MASK;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="553" href="#"></a></td>
<td><pre>        long zlong = z &amp; LONG_MASK;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="554" href="#"></a></td>
<td><pre>        int len = x.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="555" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="556" href="#"></a></td>
<td><pre>        long product = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="557" href="#"></a></td>
<td><pre>        long carry = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="558" href="#"></a></td>
<td><pre>        for (int i = len-1; i &gt;= 0; i--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="559" href="#"></a></td>
<td><pre>            product = ylong * (x[i] &amp; LONG_MASK) + carry;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="560" href="#"></a></td>
<td><pre>            x[i] = (int)product;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="561" href="#"></a></td>
<td><pre>            carry = product &gt;&gt;&gt; 32;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="562" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="563" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="564" href="#"></a></td>
<td><pre>        // Perform the addition</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="565" href="#"></a></td>
<td><pre>        long sum = (x[len-1] &amp; LONG_MASK) + zlong;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="566" href="#"></a></td>
<td><pre>        x[len-1] = (int)sum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="567" href="#"></a></td>
<td><pre>        carry = sum &gt;&gt;&gt; 32;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="568" href="#"></a></td>
<td><pre>        for (int i = len-2; i &gt;= 0; i--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="569" href="#"></a></td>
<td><pre>            sum = (x[i] &amp; LONG_MASK) + carry;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="570" href="#"></a></td>
<td><pre>            x[i] = (int)sum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="571" href="#"></a></td>
<td><pre>            carry = sum &gt;&gt;&gt; 32;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="572" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="573" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="574" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="575" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="576" href="#"></a></td>
<td><pre>     * Translates the decimal String representation of a BigInteger into a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="577" href="#"></a></td>
<td><pre>     * BigInteger.  The String representation consists of an optional minus</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="578" href="#"></a></td>
<td><pre>     * sign followed by a sequence of one or more decimal digits.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="579" href="#"></a></td>
<td><pre>     * character-to-digit mapping is provided by {@code Character.digit}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="580" href="#"></a></td>
<td><pre>     * The String may not contain any extraneous characters (whitespace, for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="581" href="#"></a></td>
<td><pre>     * example).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="582" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="583" href="#"></a></td>
<td><pre>     * @param val decimal String representation of BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="584" href="#"></a></td>
<td><pre>     * @throws NumberFormatException {@code val} is not a valid representation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="585" href="#"></a></td>
<td><pre>     *         of a BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="586" href="#"></a></td>
<td><pre>     * @see    Character#digit</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="587" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="588" href="#"></a></td>
<td><pre>    public BigInteger(String val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="589" href="#"></a></td>
<td><pre>        this(val, 10);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="590" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="591" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="592" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="593" href="#"></a></td>
<td><pre>     * Constructs a randomly generated BigInteger, uniformly distributed over</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="594" href="#"></a></td>
<td><pre>     * the range 0 to (2&lt;sup&gt;{@code numBits}&lt;/sup&gt; - 1), inclusive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="595" href="#"></a></td>
<td><pre>     * The uniformity of the distribution assumes that a fair source of random</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="596" href="#"></a></td>
<td><pre>     * bits is provided in {@code rnd}.  Note that this constructor always</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="597" href="#"></a></td>
<td><pre>     * constructs a non-negative BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="598" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="599" href="#"></a></td>
<td><pre>     * @param  numBits maximum bitLength of the new BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="600" href="#"></a></td>
<td><pre>     * @param  rnd source of randomness to be used in computing the new</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="601" href="#"></a></td>
<td><pre>     *         BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="602" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException {@code numBits} is negative.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="603" href="#"></a></td>
<td><pre>     * @see #bitLength()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="604" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="605" href="#"></a></td>
<td><pre>    public BigInteger(int numBits, Random rnd) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="606" href="#"></a></td>
<td><pre>        this(1, randomBits(numBits, rnd));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="607" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="608" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="609" href="#"></a></td>
<td><pre>    private static byte[] randomBits(int numBits, Random rnd) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="610" href="#"></a></td>
<td><pre>        if (numBits &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="611" href="#"></a></td>
<td><pre>            throw new IllegalArgumentException(&quot;numBits must be non-negative&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="612" href="#"></a></td>
<td><pre>        int numBytes = (int)(((long)numBits+7)/8); // avoid overflow</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="613" href="#"></a></td>
<td><pre>        byte[] randomBits = new byte[numBytes];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="614" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="615" href="#"></a></td>
<td><pre>        // Generate random bytes and mask out any excess bits</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="616" href="#"></a></td>
<td><pre>        if (numBytes &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="617" href="#"></a></td>
<td><pre>            rnd.nextBytes(randomBits);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="618" href="#"></a></td>
<td><pre>            int excessBits = 8*numBytes - numBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="619" href="#"></a></td>
<td><pre>            randomBits[0] &amp;= (1 &lt;&lt; (8-excessBits)) - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="620" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="621" href="#"></a></td>
<td><pre>        return randomBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="622" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="623" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="624" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="625" href="#"></a></td>
<td><pre>     * Constructs a randomly generated positive BigInteger that is probably</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="626" href="#"></a></td>
<td><pre>     * prime, with the specified bitLength.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="627" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="628" href="#"></a></td>
<td><pre>     * &lt;p&gt;It is recommended that the {@link #probablePrime probablePrime}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="629" href="#"></a></td>
<td><pre>     * method be used in preference to this constructor unless there</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="630" href="#"></a></td>
<td><pre>     * is a compelling need to specify a certainty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="631" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="632" href="#"></a></td>
<td><pre>     * @param  bitLength bitLength of the returned BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="633" href="#"></a></td>
<td><pre>     * @param  certainty a measure of the uncertainty that the caller is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="634" href="#"></a></td>
<td><pre>     *         willing to tolerate.  The probability that the new BigInteger</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="635" href="#"></a></td>
<td><pre>     *         represents a prime number will exceed</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="636" href="#"></a></td>
<td><pre>     *         (1 - 1/2&lt;sup&gt;{@code certainty}&lt;/sup&gt;).  The execution time of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="637" href="#"></a></td>
<td><pre>     *         this constructor is proportional to the value of this parameter.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="638" href="#"></a></td>
<td><pre>     * @param  rnd source of random bits used to select candidates to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="639" href="#"></a></td>
<td><pre>     *         tested for primality.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="640" href="#"></a></td>
<td><pre>     * @throws ArithmeticException {@code bitLength &lt; 2} or {@code bitLength} is too large.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="641" href="#"></a></td>
<td><pre>     * @see    #bitLength()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="642" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="643" href="#"></a></td>
<td><pre>    public BigInteger(int bitLength, int certainty, Random rnd) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="644" href="#"></a></td>
<td><pre>        BigInteger prime;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="645" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="646" href="#"></a></td>
<td><pre>        if (bitLength &lt; 2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="647" href="#"></a></td>
<td><pre>            throw new ArithmeticException(&quot;bitLength &lt; 2&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="648" href="#"></a></td>
<td><pre>        prime = (bitLength &lt; SMALL_PRIME_THRESHOLD</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="649" href="#"></a></td>
<td><pre>                                ? smallPrime(bitLength, certainty, rnd)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="650" href="#"></a></td>
<td><pre>                                : largePrime(bitLength, certainty, rnd));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="651" href="#"></a></td>
<td><pre>        signum = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="652" href="#"></a></td>
<td><pre>        mag = prime.mag;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="653" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="654" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="655" href="#"></a></td>
<td><pre>    // Minimum size in bits that the requested prime number has</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="656" href="#"></a></td>
<td><pre>    // before we use the large prime number generating algorithms.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="657" href="#"></a></td>
<td><pre>    // The cutoff of 95 was chosen empirically for best performance.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="658" href="#"></a></td>
<td><pre>    private static final int SMALL_PRIME_THRESHOLD = 95;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="659" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="660" href="#"></a></td>
<td><pre>    // Certainty required to meet the spec of probablePrime</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="661" href="#"></a></td>
<td><pre>    private static final int DEFAULT_PRIME_CERTAINTY = 100;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="662" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="663" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="664" href="#"></a></td>
<td><pre>     * Returns a positive BigInteger that is probably prime, with the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="665" href="#"></a></td>
<td><pre>     * specified bitLength. The probability that a BigInteger returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="666" href="#"></a></td>
<td><pre>     * by this method is composite does not exceed 2&lt;sup&gt;-100&lt;/sup&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="667" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="668" href="#"></a></td>
<td><pre>     * @param  bitLength bitLength of the returned BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="669" href="#"></a></td>
<td><pre>     * @param  rnd source of random bits used to select candidates to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="670" href="#"></a></td>
<td><pre>     *         tested for primality.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="671" href="#"></a></td>
<td><pre>     * @return a BigInteger of {@code bitLength} bits that is probably prime</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="672" href="#"></a></td>
<td><pre>     * @throws ArithmeticException {@code bitLength &lt; 2} or {@code bitLength} is too large.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="673" href="#"></a></td>
<td><pre>     * @see    #bitLength()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="674" href="#"></a></td>
<td><pre>     * @since 1.4</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="675" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="676" href="#"></a></td>
<td><pre>    public static BigInteger probablePrime(int bitLength, Random rnd) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="677" href="#"></a></td>
<td><pre>        if (bitLength &lt; 2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="678" href="#"></a></td>
<td><pre>            throw new ArithmeticException(&quot;bitLength &lt; 2&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="679" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="680" href="#"></a></td>
<td><pre>        return (bitLength &lt; SMALL_PRIME_THRESHOLD ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="681" href="#"></a></td>
<td><pre>                smallPrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd) :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="682" href="#"></a></td>
<td><pre>                largePrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="683" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="684" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="685" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="686" href="#"></a></td>
<td><pre>     * Find a random number of the specified bitLength that is probably prime.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="687" href="#"></a></td>
<td><pre>     * This method is used for smaller primes, its performance degrades on</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="688" href="#"></a></td>
<td><pre>     * larger bitlengths.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="689" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="690" href="#"></a></td>
<td><pre>     * This method assumes bitLength &gt; 1.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="691" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="692" href="#"></a></td>
<td><pre>    private static BigInteger smallPrime(int bitLength, int certainty, Random rnd) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="693" href="#"></a></td>
<td><pre>        int magLen = (bitLength + 31) &gt;&gt;&gt; 5;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="694" href="#"></a></td>
<td><pre>        int temp[] = new int[magLen];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="695" href="#"></a></td>
<td><pre>        int highBit = 1 &lt;&lt; ((bitLength+31) &amp; 0x1f);  // High bit of high int</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="696" href="#"></a></td>
<td><pre>        int highMask = (highBit &lt;&lt; 1) - 1;  // Bits to keep in high int</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="697" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="698" href="#"></a></td>
<td><pre>        while (true) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="699" href="#"></a></td>
<td><pre>            // Construct a candidate</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="700" href="#"></a></td>
<td><pre>            for (int i=0; i &lt; magLen; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="701" href="#"></a></td>
<td><pre>                temp[i] = rnd.nextInt();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="702" href="#"></a></td>
<td><pre>            temp[0] = (temp[0] &amp; highMask) | highBit;  // Ensure exact length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="703" href="#"></a></td>
<td><pre>            if (bitLength &gt; 2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="704" href="#"></a></td>
<td><pre>                temp[magLen-1] |= 1;  // Make odd if bitlen &gt; 2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="705" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="706" href="#"></a></td>
<td><pre>            BigInteger p = new BigInteger(temp, 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="707" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="708" href="#"></a></td>
<td><pre>            // Do cheap &quot;pre-test&quot; if applicable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="709" href="#"></a></td>
<td><pre>            if (bitLength &gt; 6) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="710" href="#"></a></td>
<td><pre>                long r = p.remainder(SMALL_PRIME_PRODUCT).longValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="711" href="#"></a></td>
<td><pre>                if ((r%3==0)  || (r%5==0)  || (r%7==0)  || (r%11==0) ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="712" href="#"></a></td>
<td><pre>                    (r%13==0) || (r%17==0) || (r%19==0) || (r%23==0) ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="713" href="#"></a></td>
<td><pre>                    (r%29==0) || (r%31==0) || (r%37==0) || (r%41==0))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="714" href="#"></a></td>
<td><pre>                    continue; // Candidate is composite; try another</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="715" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="716" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="717" href="#"></a></td>
<td><pre>            // All candidates of bitLength 2 and 3 are prime by this point</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="718" href="#"></a></td>
<td><pre>            if (bitLength &lt; 4)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="719" href="#"></a></td>
<td><pre>                return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="720" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="721" href="#"></a></td>
<td><pre>            // Do expensive test if we survive pre-test (or it's inapplicable)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="722" href="#"></a></td>
<td><pre>            if (p.primeToCertainty(certainty, rnd))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="723" href="#"></a></td>
<td><pre>                return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="724" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="725" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="726" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="727" href="#"></a></td>
<td><pre>    private static final BigInteger SMALL_PRIME_PRODUCT</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="728" href="#"></a></td>
<td><pre>                       = valueOf(3L*5*7*11*13*17*19*23*29*31*37*41);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="729" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="730" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="731" href="#"></a></td>
<td><pre>     * Find a random number of the specified bitLength that is probably prime.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="732" href="#"></a></td>
<td><pre>     * This method is more appropriate for larger bitlengths since it uses</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="733" href="#"></a></td>
<td><pre>     * a sieve to eliminate most composites before using a more expensive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="734" href="#"></a></td>
<td><pre>     * test.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="735" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="736" href="#"></a></td>
<td><pre>    private static BigInteger largePrime(int bitLength, int certainty, Random rnd) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="737" href="#"></a></td>
<td><pre>        BigInteger p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="738" href="#"></a></td>
<td><pre>        p = new BigInteger(bitLength, rnd).setBit(bitLength-1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="739" href="#"></a></td>
<td><pre>        p.mag[p.mag.length-1] &amp;= 0xfffffffe;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="740" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="741" href="#"></a></td>
<td><pre>        // Use a sieve length likely to contain the next prime number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="742" href="#"></a></td>
<td><pre>        int searchLen = getPrimeSearchLen(bitLength);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="743" href="#"></a></td>
<td><pre>        BitSieve searchSieve = new BitSieve(p, searchLen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="744" href="#"></a></td>
<td><pre>        BigInteger candidate = searchSieve.retrieve(p, certainty, rnd);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="745" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="746" href="#"></a></td>
<td><pre>        while ((candidate == null) || (candidate.bitLength() != bitLength)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="747" href="#"></a></td>
<td><pre>            p = p.add(BigInteger.valueOf(2*searchLen));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="748" href="#"></a></td>
<td><pre>            if (p.bitLength() != bitLength)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="749" href="#"></a></td>
<td><pre>                p = new BigInteger(bitLength, rnd).setBit(bitLength-1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="750" href="#"></a></td>
<td><pre>            p.mag[p.mag.length-1] &amp;= 0xfffffffe;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="751" href="#"></a></td>
<td><pre>            searchSieve = new BitSieve(p, searchLen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="752" href="#"></a></td>
<td><pre>            candidate = searchSieve.retrieve(p, certainty, rnd);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="753" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="754" href="#"></a></td>
<td><pre>        return candidate;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="755" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="756" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="757" href="#"></a></td>
<td><pre>   /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="758" href="#"></a></td>
<td><pre>    * Returns the first integer greater than this {@code BigInteger} that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="759" href="#"></a></td>
<td><pre>    * is probably prime.  The probability that the number returned by this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="760" href="#"></a></td>
<td><pre>    * method is composite does not exceed 2&lt;sup&gt;-100&lt;/sup&gt;. This method will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="761" href="#"></a></td>
<td><pre>    * never skip over a prime when searching: if it returns {@code p}, there</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="762" href="#"></a></td>
<td><pre>    * is no prime {@code q} such that {@code this &lt; q &lt; p}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="763" href="#"></a></td>
<td><pre>    *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="764" href="#"></a></td>
<td><pre>    * @return the first integer greater than this {@code BigInteger} that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="765" href="#"></a></td>
<td><pre>    *         is probably prime.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="766" href="#"></a></td>
<td><pre>    * @throws ArithmeticException {@code this &lt; 0} or {@code this} is too large.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="767" href="#"></a></td>
<td><pre>    * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="768" href="#"></a></td>
<td><pre>    */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="769" href="#"></a></td>
<td><pre>    public BigInteger nextProbablePrime() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="770" href="#"></a></td>
<td><pre>        if (this.signum &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="771" href="#"></a></td>
<td><pre>            throw new ArithmeticException(&quot;start &lt; 0: &quot; + this);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="772" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="773" href="#"></a></td>
<td><pre>        // Handle trivial cases</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="774" href="#"></a></td>
<td><pre>        if ((this.signum == 0) || this.equals(ONE))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="775" href="#"></a></td>
<td><pre>            return TWO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="776" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="777" href="#"></a></td>
<td><pre>        BigInteger result = this.add(ONE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="778" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="779" href="#"></a></td>
<td><pre>        // Fastpath for small numbers</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="780" href="#"></a></td>
<td><pre>        if (result.bitLength() &lt; SMALL_PRIME_THRESHOLD) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="781" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="782" href="#"></a></td>
<td><pre>            // Ensure an odd number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="783" href="#"></a></td>
<td><pre>            if (!result.testBit(0))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="784" href="#"></a></td>
<td><pre>                result = result.add(ONE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="785" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="786" href="#"></a></td>
<td><pre>            while (true) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="787" href="#"></a></td>
<td><pre>                // Do cheap &quot;pre-test&quot; if applicable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="788" href="#"></a></td>
<td><pre>                if (result.bitLength() &gt; 6) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="789" href="#"></a></td>
<td><pre>                    long r = result.remainder(SMALL_PRIME_PRODUCT).longValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="790" href="#"></a></td>
<td><pre>                    if ((r%3==0)  || (r%5==0)  || (r%7==0)  || (r%11==0) ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="791" href="#"></a></td>
<td><pre>                        (r%13==0) || (r%17==0) || (r%19==0) || (r%23==0) ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="792" href="#"></a></td>
<td><pre>                        (r%29==0) || (r%31==0) || (r%37==0) || (r%41==0)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="793" href="#"></a></td>
<td><pre>                        result = result.add(TWO);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="794" href="#"></a></td>
<td><pre>                        continue; // Candidate is composite; try another</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="795" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="796" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="797" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="798" href="#"></a></td>
<td><pre>                // All candidates of bitLength 2 and 3 are prime by this point</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="799" href="#"></a></td>
<td><pre>                if (result.bitLength() &lt; 4)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="800" href="#"></a></td>
<td><pre>                    return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="801" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="802" href="#"></a></td>
<td><pre>                // The expensive test</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="803" href="#"></a></td>
<td><pre>                if (result.primeToCertainty(DEFAULT_PRIME_CERTAINTY, null))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="804" href="#"></a></td>
<td><pre>                    return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="805" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="806" href="#"></a></td>
<td><pre>                result = result.add(TWO);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="807" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="808" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="809" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="810" href="#"></a></td>
<td><pre>        // Start at previous even number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="811" href="#"></a></td>
<td><pre>        if (result.testBit(0))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="812" href="#"></a></td>
<td><pre>            result = result.subtract(ONE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="813" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="814" href="#"></a></td>
<td><pre>        // Looking for the next large prime</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="815" href="#"></a></td>
<td><pre>        int searchLen = getPrimeSearchLen(result.bitLength());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="816" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="817" href="#"></a></td>
<td><pre>        while (true) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="818" href="#"></a></td>
<td><pre>           BitSieve searchSieve = new BitSieve(result, searchLen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="819" href="#"></a></td>
<td><pre>           BigInteger candidate = searchSieve.retrieve(result,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="820" href="#"></a></td>
<td><pre>                                                 DEFAULT_PRIME_CERTAINTY, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="821" href="#"></a></td>
<td><pre>           if (candidate != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="822" href="#"></a></td>
<td><pre>               return candidate;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="823" href="#"></a></td>
<td><pre>           result = result.add(BigInteger.valueOf(2 * searchLen));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="824" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="825" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="826" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="827" href="#"></a></td>
<td><pre>    private static int getPrimeSearchLen(int bitLength) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="828" href="#"></a></td>
<td><pre>        if (bitLength &gt; PRIME_SEARCH_BIT_LENGTH_LIMIT + 1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="829" href="#"></a></td>
<td><pre>            throw new ArithmeticException(&quot;Prime search implementation restriction on bitLength&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="830" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="831" href="#"></a></td>
<td><pre>        return bitLength / 20 * 64;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="832" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="833" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="834" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="835" href="#"></a></td>
<td><pre>     * Returns {@code true} if this BigInteger is probably prime,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="836" href="#"></a></td>
<td><pre>     * {@code false} if it's definitely composite.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="837" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="838" href="#"></a></td>
<td><pre>     * This method assumes bitLength &gt; 2.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="839" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="840" href="#"></a></td>
<td><pre>     * @param  certainty a measure of the uncertainty that the caller is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="841" href="#"></a></td>
<td><pre>     *         willing to tolerate: if the call returns {@code true}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="842" href="#"></a></td>
<td><pre>     *         the probability that this BigInteger is prime exceeds</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="843" href="#"></a></td>
<td><pre>     *         {@code (1 - 1/2&lt;sup&gt;certainty&lt;/sup&gt;)}.  The execution time of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="844" href="#"></a></td>
<td><pre>     *         this method is proportional to the value of this parameter.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="845" href="#"></a></td>
<td><pre>     * @return {@code true} if this BigInteger is probably prime,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="846" href="#"></a></td>
<td><pre>     *         {@code false} if it's definitely composite.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="847" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="848" href="#"></a></td>
<td><pre>    boolean primeToCertainty(int certainty, Random random) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="849" href="#"></a></td>
<td><pre>        int rounds = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="850" href="#"></a></td>
<td><pre>        int n = (Math.min(certainty, Integer.MAX_VALUE-1)+1)/2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="851" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="852" href="#"></a></td>
<td><pre>        // The relationship between the certainty and the number of rounds</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="853" href="#"></a></td>
<td><pre>        // we perform is given in the draft standard ANSI X9.80, &quot;PRIME</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="854" href="#"></a></td>
<td><pre>        // NUMBER GENERATION, PRIMALITY TESTING, AND PRIMALITY CERTIFICATES&quot;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="855" href="#"></a></td>
<td><pre>        int sizeInBits = this.bitLength();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="856" href="#"></a></td>
<td><pre>        if (sizeInBits &lt; 100) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="857" href="#"></a></td>
<td><pre>            rounds = 50;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="858" href="#"></a></td>
<td><pre>            rounds = n &lt; rounds ? n : rounds;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="859" href="#"></a></td>
<td><pre>            return passesMillerRabin(rounds, random);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="860" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="861" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="862" href="#"></a></td>
<td><pre>        if (sizeInBits &lt; 256) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="863" href="#"></a></td>
<td><pre>            rounds = 27;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="864" href="#"></a></td>
<td><pre>        } else if (sizeInBits &lt; 512) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="865" href="#"></a></td>
<td><pre>            rounds = 15;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="866" href="#"></a></td>
<td><pre>        } else if (sizeInBits &lt; 768) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="867" href="#"></a></td>
<td><pre>            rounds = 8;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="868" href="#"></a></td>
<td><pre>        } else if (sizeInBits &lt; 1024) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="869" href="#"></a></td>
<td><pre>            rounds = 4;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="870" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="871" href="#"></a></td>
<td><pre>            rounds = 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="872" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="873" href="#"></a></td>
<td><pre>        rounds = n &lt; rounds ? n : rounds;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="874" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="875" href="#"></a></td>
<td><pre>        return passesMillerRabin(rounds, random) &amp;&amp; passesLucasLehmer();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="876" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="877" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="878" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="879" href="#"></a></td>
<td><pre>     * Returns true iff this BigInteger is a Lucas-Lehmer probable prime.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="880" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="881" href="#"></a></td>
<td><pre>     * The following assumptions are made:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="882" href="#"></a></td>
<td><pre>     * This BigInteger is a positive, odd number.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="883" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="884" href="#"></a></td>
<td><pre>    private boolean passesLucasLehmer() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="885" href="#"></a></td>
<td><pre>        BigInteger thisPlusOne = this.add(ONE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="886" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="887" href="#"></a></td>
<td><pre>        // Step 1</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="888" href="#"></a></td>
<td><pre>        int d = 5;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="889" href="#"></a></td>
<td><pre>        while (jacobiSymbol(d, this) != -1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="890" href="#"></a></td>
<td><pre>            // 5, -7, 9, -11, ...</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="891" href="#"></a></td>
<td><pre>            d = (d &lt; 0) ? Math.abs(d)+2 : -(d+2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="892" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="893" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="894" href="#"></a></td>
<td><pre>        // Step 2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="895" href="#"></a></td>
<td><pre>        BigInteger u = lucasLehmerSequence(d, thisPlusOne, this);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="896" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="897" href="#"></a></td>
<td><pre>        // Step 3</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="898" href="#"></a></td>
<td><pre>        return u.mod(this).equals(ZERO);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="899" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="900" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="901" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="902" href="#"></a></td>
<td><pre>     * Computes Jacobi(p,n).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="903" href="#"></a></td>
<td><pre>     * Assumes n positive, odd, n&gt;=3.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="904" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="905" href="#"></a></td>
<td><pre>    private static int jacobiSymbol(int p, BigInteger n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="906" href="#"></a></td>
<td><pre>        if (p == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="907" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="908" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="909" href="#"></a></td>
<td><pre>        // Algorithm and comments adapted from Colin Plumb's C library.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="910" href="#"></a></td>
<td><pre>        int j = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="911" href="#"></a></td>
<td><pre>        int u = n.mag[n.mag.length-1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="912" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="913" href="#"></a></td>
<td><pre>        // Make p positive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="914" href="#"></a></td>
<td><pre>        if (p &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="915" href="#"></a></td>
<td><pre>            p = -p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="916" href="#"></a></td>
<td><pre>            int n8 = u &amp; 7;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="917" href="#"></a></td>
<td><pre>            if ((n8 == 3) || (n8 == 7))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="918" href="#"></a></td>
<td><pre>                j = -j; // 3 (011) or 7 (111) mod 8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="919" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="920" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="921" href="#"></a></td>
<td><pre>        // Get rid of factors of 2 in p</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="922" href="#"></a></td>
<td><pre>        while ((p &amp; 3) == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="923" href="#"></a></td>
<td><pre>            p &gt;&gt;= 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="924" href="#"></a></td>
<td><pre>        if ((p &amp; 1) == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="925" href="#"></a></td>
<td><pre>            p &gt;&gt;= 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="926" href="#"></a></td>
<td><pre>            if (((u ^ (u&gt;&gt;1)) &amp; 2) != 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="927" href="#"></a></td>
<td><pre>                j = -j; // 3 (011) or 5 (101) mod 8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="928" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="929" href="#"></a></td>
<td><pre>        if (p == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="930" href="#"></a></td>
<td><pre>            return j;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="931" href="#"></a></td>
<td><pre>        // Then, apply quadratic reciprocity</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="932" href="#"></a></td>
<td><pre>        if ((p &amp; u &amp; 2) != 0)   // p = u = 3 (mod 4)?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="933" href="#"></a></td>
<td><pre>            j = -j;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="934" href="#"></a></td>
<td><pre>        // And reduce u mod p</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="935" href="#"></a></td>
<td><pre>        u = n.mod(BigInteger.valueOf(p)).intValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="936" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="937" href="#"></a></td>
<td><pre>        // Now compute Jacobi(u,p), u &lt; p</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="938" href="#"></a></td>
<td><pre>        while (u != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="939" href="#"></a></td>
<td><pre>            while ((u &amp; 3) == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="940" href="#"></a></td>
<td><pre>                u &gt;&gt;= 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="941" href="#"></a></td>
<td><pre>            if ((u &amp; 1) == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="942" href="#"></a></td>
<td><pre>                u &gt;&gt;= 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="943" href="#"></a></td>
<td><pre>                if (((p ^ (p&gt;&gt;1)) &amp; 2) != 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="944" href="#"></a></td>
<td><pre>                    j = -j;     // 3 (011) or 5 (101) mod 8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="945" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="946" href="#"></a></td>
<td><pre>            if (u == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="947" href="#"></a></td>
<td><pre>                return j;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="948" href="#"></a></td>
<td><pre>            // Now both u and p are odd, so use quadratic reciprocity</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="949" href="#"></a></td>
<td><pre>            assert (u &lt; p);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="950" href="#"></a></td>
<td><pre>            int t = u; u = p; p = t;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="951" href="#"></a></td>
<td><pre>            if ((u &amp; p &amp; 2) != 0) // u = p = 3 (mod 4)?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="952" href="#"></a></td>
<td><pre>                j = -j;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="953" href="#"></a></td>
<td><pre>            // Now u &gt;= p, so it can be reduced</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="954" href="#"></a></td>
<td><pre>            u %= p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="955" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="956" href="#"></a></td>
<td><pre>        return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="957" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="958" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="959" href="#"></a></td>
<td><pre>    private static BigInteger lucasLehmerSequence(int z, BigInteger k, BigInteger n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="960" href="#"></a></td>
<td><pre>        BigInteger d = BigInteger.valueOf(z);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="961" href="#"></a></td>
<td><pre>        BigInteger u = ONE; BigInteger u2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="962" href="#"></a></td>
<td><pre>        BigInteger v = ONE; BigInteger v2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="963" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="964" href="#"></a></td>
<td><pre>        for (int i=k.bitLength()-2; i &gt;= 0; i--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="965" href="#"></a></td>
<td><pre>            u2 = u.multiply(v).mod(n);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="966" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="967" href="#"></a></td>
<td><pre>            v2 = v.square().add(d.multiply(u.square())).mod(n);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="968" href="#"></a></td>
<td><pre>            if (v2.testBit(0))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="969" href="#"></a></td>
<td><pre>                v2 = v2.subtract(n);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="970" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="971" href="#"></a></td>
<td><pre>            v2 = v2.shiftRight(1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="972" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="973" href="#"></a></td>
<td><pre>            u = u2; v = v2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="974" href="#"></a></td>
<td><pre>            if (k.testBit(i)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="975" href="#"></a></td>
<td><pre>                u2 = u.add(v).mod(n);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="976" href="#"></a></td>
<td><pre>                if (u2.testBit(0))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="977" href="#"></a></td>
<td><pre>                    u2 = u2.subtract(n);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="978" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="979" href="#"></a></td>
<td><pre>                u2 = u2.shiftRight(1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="980" href="#"></a></td>
<td><pre>                v2 = v.add(d.multiply(u)).mod(n);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="981" href="#"></a></td>
<td><pre>                if (v2.testBit(0))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="982" href="#"></a></td>
<td><pre>                    v2 = v2.subtract(n);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="983" href="#"></a></td>
<td><pre>                v2 = v2.shiftRight(1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="984" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="985" href="#"></a></td>
<td><pre>                u = u2; v = v2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="986" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="987" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="988" href="#"></a></td>
<td><pre>        return u;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="989" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="990" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="991" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="992" href="#"></a></td>
<td><pre>     * Returns true iff this BigInteger passes the specified number of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="993" href="#"></a></td>
<td><pre>     * Miller-Rabin tests. This test is taken from the DSA spec (NIST FIPS</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="994" href="#"></a></td>
<td><pre>     * 186-2).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="995" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="996" href="#"></a></td>
<td><pre>     * The following assumptions are made:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="997" href="#"></a></td>
<td><pre>     * This BigInteger is a positive, odd number greater than 2.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="998" href="#"></a></td>
<td><pre>     * iterations&lt;=50.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="999" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1000" href="#"></a></td>
<td><pre>    private boolean passesMillerRabin(int iterations, Random rnd) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1001" href="#"></a></td>
<td><pre>        // Find a and m such that m is odd and this == 1 + 2**a * m</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1002" href="#"></a></td>
<td><pre>        BigInteger thisMinusOne = this.subtract(ONE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1003" href="#"></a></td>
<td><pre>        BigInteger m = thisMinusOne;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1004" href="#"></a></td>
<td><pre>        int a = m.getLowestSetBit();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1005" href="#"></a></td>
<td><pre>        m = m.shiftRight(a);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1006" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1007" href="#"></a></td>
<td><pre>        // Do the tests</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1008" href="#"></a></td>
<td><pre>        if (rnd == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1009" href="#"></a></td>
<td><pre>            rnd = ThreadLocalRandom.current();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1010" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1011" href="#"></a></td>
<td><pre>        for (int i=0; i &lt; iterations; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1012" href="#"></a></td>
<td><pre>            // Generate a uniform random on (1, this)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1013" href="#"></a></td>
<td><pre>            BigInteger b;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1014" href="#"></a></td>
<td><pre>            do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1015" href="#"></a></td>
<td><pre>                b = new BigInteger(this.bitLength(), rnd);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1016" href="#"></a></td>
<td><pre>            } while (b.compareTo(ONE) &lt;= 0 || b.compareTo(this) &gt;= 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1017" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1018" href="#"></a></td>
<td><pre>            int j = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1019" href="#"></a></td>
<td><pre>            BigInteger z = b.modPow(m, this);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1020" href="#"></a></td>
<td><pre>            while (!((j == 0 &amp;&amp; z.equals(ONE)) || z.equals(thisMinusOne))) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1021" href="#"></a></td>
<td><pre>                if (j &gt; 0 &amp;&amp; z.equals(ONE) || ++j == a)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1022" href="#"></a></td>
<td><pre>                    return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1023" href="#"></a></td>
<td><pre>                z = z.modPow(TWO, this);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1024" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1025" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1026" href="#"></a></td>
<td><pre>        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1027" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1028" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1029" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1030" href="#"></a></td>
<td><pre>     * This internal constructor differs from its public cousin</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1031" href="#"></a></td>
<td><pre>     * with the arguments reversed in two ways: it assumes that its</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1032" href="#"></a></td>
<td><pre>     * arguments are correct, and it doesn't copy the magnitude array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1033" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1034" href="#"></a></td>
<td><pre>    BigInteger(int[] magnitude, int signum) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1035" href="#"></a></td>
<td><pre>        this.signum = (magnitude.length == 0 ? 0 : signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1036" href="#"></a></td>
<td><pre>        this.mag = magnitude;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1037" href="#"></a></td>
<td><pre>        if (mag.length &gt;= MAX_MAG_LENGTH) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1038" href="#"></a></td>
<td><pre>            checkRange();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1039" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1040" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1041" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1042" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1043" href="#"></a></td>
<td><pre>     * This private constructor is for internal use and assumes that its</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1044" href="#"></a></td>
<td><pre>     * arguments are correct.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1045" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1046" href="#"></a></td>
<td><pre>    private BigInteger(byte[] magnitude, int signum) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1047" href="#"></a></td>
<td><pre>        this.signum = (magnitude.length == 0 ? 0 : signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1048" href="#"></a></td>
<td><pre>        this.mag = stripLeadingZeroBytes(magnitude);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1049" href="#"></a></td>
<td><pre>        if (mag.length &gt;= MAX_MAG_LENGTH) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1050" href="#"></a></td>
<td><pre>            checkRange();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1051" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1052" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1053" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1054" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1055" href="#"></a></td>
<td><pre>     * Throws an {@code ArithmeticException} if the {@code BigInteger} would be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1056" href="#"></a></td>
<td><pre>     * out of the supported range.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1057" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1058" href="#"></a></td>
<td><pre>     * @throws ArithmeticException if {@code this} exceeds the supported range.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1059" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1060" href="#"></a></td>
<td><pre>    private void checkRange() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1061" href="#"></a></td>
<td><pre>        if (mag.length &gt; MAX_MAG_LENGTH || mag.length == MAX_MAG_LENGTH &amp;&amp; mag[0] &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1062" href="#"></a></td>
<td><pre>            reportOverflow();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1063" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1064" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1065" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1066" href="#"></a></td>
<td><pre>    private static void reportOverflow() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1067" href="#"></a></td>
<td><pre>        throw new ArithmeticException(&quot;BigInteger would overflow supported range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1068" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1069" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1070" href="#"></a></td>
<td><pre>    //Static Factory Methods</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1071" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1072" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1073" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is equal to that of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1074" href="#"></a></td>
<td><pre>     * specified {@code long}.  This &quot;static factory method&quot; is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1075" href="#"></a></td>
<td><pre>     * provided in preference to a ({@code long}) constructor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1076" href="#"></a></td>
<td><pre>     * because it allows for reuse of frequently used BigIntegers.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1077" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1078" href="#"></a></td>
<td><pre>     * @param  val value of the BigInteger to return.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1079" href="#"></a></td>
<td><pre>     * @return a BigInteger with the specified value.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1080" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1081" href="#"></a></td>
<td><pre>    public static BigInteger valueOf(long val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1082" href="#"></a></td>
<td><pre>        // If -MAX_CONSTANT &lt; val &lt; MAX_CONSTANT, return stashed constant</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1083" href="#"></a></td>
<td><pre>        if (val == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1084" href="#"></a></td>
<td><pre>            return ZERO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1085" href="#"></a></td>
<td><pre>        if (val &gt; 0 &amp;&amp; val &lt;= MAX_CONSTANT)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1086" href="#"></a></td>
<td><pre>            return posConst[(int) val];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1087" href="#"></a></td>
<td><pre>        else if (val &lt; 0 &amp;&amp; val &gt;= -MAX_CONSTANT)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1088" href="#"></a></td>
<td><pre>            return negConst[(int) -val];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1089" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1090" href="#"></a></td>
<td><pre>        return new BigInteger(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1091" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1092" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1093" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1094" href="#"></a></td>
<td><pre>     * Constructs a BigInteger with the specified value, which may not be zero.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1095" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1096" href="#"></a></td>
<td><pre>    private BigInteger(long val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1097" href="#"></a></td>
<td><pre>        if (val &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1098" href="#"></a></td>
<td><pre>            val = -val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1099" href="#"></a></td>
<td><pre>            signum = -1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1100" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1101" href="#"></a></td>
<td><pre>            signum = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1102" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1103" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1104" href="#"></a></td>
<td><pre>        int highWord = (int)(val &gt;&gt;&gt; 32);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1105" href="#"></a></td>
<td><pre>        if (highWord == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1106" href="#"></a></td>
<td><pre>            mag = new int[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1107" href="#"></a></td>
<td><pre>            mag[0] = (int)val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1108" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1109" href="#"></a></td>
<td><pre>            mag = new int[2];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1110" href="#"></a></td>
<td><pre>            mag[0] = highWord;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1111" href="#"></a></td>
<td><pre>            mag[1] = (int)val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1112" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1113" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1114" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1115" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1116" href="#"></a></td>
<td><pre>     * Returns a BigInteger with the given two's complement representation.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1117" href="#"></a></td>
<td><pre>     * Assumes that the input array will not be modified (the returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1118" href="#"></a></td>
<td><pre>     * BigInteger will reference the input array if feasible).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1119" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1120" href="#"></a></td>
<td><pre>    private static BigInteger valueOf(int val[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1121" href="#"></a></td>
<td><pre>        return (val[0] &gt; 0 ? new BigInteger(val, 1) : new BigInteger(val));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1122" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1123" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1124" href="#"></a></td>
<td><pre>    // Constants</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1125" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1126" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1127" href="#"></a></td>
<td><pre>     * Initialize static constant array when class is loaded.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1128" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1129" href="#"></a></td>
<td><pre>    private final static int MAX_CONSTANT = 16;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1130" href="#"></a></td>
<td><pre>    private static BigInteger posConst[] = new BigInteger[MAX_CONSTANT+1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1131" href="#"></a></td>
<td><pre>    private static BigInteger negConst[] = new BigInteger[MAX_CONSTANT+1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1132" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1133" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1134" href="#"></a></td>
<td><pre>     * The cache of powers of each radix.  This allows us to not have to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1135" href="#"></a></td>
<td><pre>     * recalculate powers of radix^(2^n) more than once.  This speeds</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1136" href="#"></a></td>
<td><pre>     * Schoenhage recursive base conversion significantly.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1137" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1138" href="#"></a></td>
<td><pre>    private static volatile BigInteger[][] powerCache;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1139" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1140" href="#"></a></td>
<td><pre>    /** The cache of logarithms of radices for base conversion. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1141" href="#"></a></td>
<td><pre>    private static final double[] logCache;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1142" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1143" href="#"></a></td>
<td><pre>    /** The natural log of 2.  This is used in computing cache indices. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1144" href="#"></a></td>
<td><pre>    private static final double LOG_TWO = Math.log(2.0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1145" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1146" href="#"></a></td>
<td><pre>    static {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1147" href="#"></a></td>
<td><pre>        for (int i = 1; i &lt;= MAX_CONSTANT; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1148" href="#"></a></td>
<td><pre>            int[] magnitude = new int[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1149" href="#"></a></td>
<td><pre>            magnitude[0] = i;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1150" href="#"></a></td>
<td><pre>            posConst[i] = new BigInteger(magnitude,  1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1151" href="#"></a></td>
<td><pre>            negConst[i] = new BigInteger(magnitude, -1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1152" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1153" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1154" href="#"></a></td>
<td><pre>        /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1155" href="#"></a></td>
<td><pre>         * Initialize the cache of radix^(2^x) values used for base conversion</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1156" href="#"></a></td>
<td><pre>         * with just the very first value.  Additional values will be created</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1157" href="#"></a></td>
<td><pre>         * on demand.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1158" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1159" href="#"></a></td>
<td><pre>        powerCache = new BigInteger[Character.MAX_RADIX+1][];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1160" href="#"></a></td>
<td><pre>        logCache = new double[Character.MAX_RADIX+1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1161" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1162" href="#"></a></td>
<td><pre>        for (int i=Character.MIN_RADIX; i &lt;= Character.MAX_RADIX; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1163" href="#"></a></td>
<td><pre>            powerCache[i] = new BigInteger[] { BigInteger.valueOf(i) };</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1164" href="#"></a></td>
<td><pre>            logCache[i] = Math.log(i);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1165" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1166" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1167" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1168" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1169" href="#"></a></td>
<td><pre>     * The BigInteger constant zero.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1170" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1171" href="#"></a></td>
<td><pre>     * @since   1.2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1172" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1173" href="#"></a></td>
<td><pre>    public static final BigInteger ZERO = new BigInteger(new int[0], 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1174" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1175" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1176" href="#"></a></td>
<td><pre>     * The BigInteger constant one.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1177" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1178" href="#"></a></td>
<td><pre>     * @since   1.2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1179" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1180" href="#"></a></td>
<td><pre>    public static final BigInteger ONE = valueOf(1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1181" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1182" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1183" href="#"></a></td>
<td><pre>     * The BigInteger constant two.  (Not exported.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1184" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1185" href="#"></a></td>
<td><pre>    private static final BigInteger TWO = valueOf(2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1186" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1187" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1188" href="#"></a></td>
<td><pre>     * The BigInteger constant -1.  (Not exported.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1189" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1190" href="#"></a></td>
<td><pre>    private static final BigInteger NEGATIVE_ONE = valueOf(-1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1191" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1192" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1193" href="#"></a></td>
<td><pre>     * The BigInteger constant ten.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1194" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1195" href="#"></a></td>
<td><pre>     * @since   1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1196" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1197" href="#"></a></td>
<td><pre>    public static final BigInteger TEN = valueOf(10);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1198" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1199" href="#"></a></td>
<td><pre>    // Arithmetic Operations</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1200" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1201" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1202" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this + val)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1203" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1204" href="#"></a></td>
<td><pre>     * @param  val value to be added to this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1205" href="#"></a></td>
<td><pre>     * @return {@code this + val}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1206" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1207" href="#"></a></td>
<td><pre>    public BigInteger add(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1208" href="#"></a></td>
<td><pre>        if (val.signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1209" href="#"></a></td>
<td><pre>            return this;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1210" href="#"></a></td>
<td><pre>        if (signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1211" href="#"></a></td>
<td><pre>            return val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1212" href="#"></a></td>
<td><pre>        if (val.signum == signum)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1213" href="#"></a></td>
<td><pre>            return new BigInteger(add(mag, val.mag), signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1214" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1215" href="#"></a></td>
<td><pre>        int cmp = compareMagnitude(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1216" href="#"></a></td>
<td><pre>        if (cmp == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1217" href="#"></a></td>
<td><pre>            return ZERO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1218" href="#"></a></td>
<td><pre>        int[] resultMag = (cmp &gt; 0 ? subtract(mag, val.mag)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1219" href="#"></a></td>
<td><pre>                           : subtract(val.mag, mag));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1220" href="#"></a></td>
<td><pre>        resultMag = trustedStripLeadingZeroInts(resultMag);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1221" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1222" href="#"></a></td>
<td><pre>        return new BigInteger(resultMag, cmp == signum ? 1 : -1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1223" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1224" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1225" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1226" href="#"></a></td>
<td><pre>     * Package private methods used by BigDecimal code to add a BigInteger</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1227" href="#"></a></td>
<td><pre>     * with a long. Assumes val is not equal to INFLATED.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1228" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1229" href="#"></a></td>
<td><pre>    BigInteger add(long val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1230" href="#"></a></td>
<td><pre>        if (val == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1231" href="#"></a></td>
<td><pre>            return this;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1232" href="#"></a></td>
<td><pre>        if (signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1233" href="#"></a></td>
<td><pre>            return valueOf(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1234" href="#"></a></td>
<td><pre>        if (Long.signum(val) == signum)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1235" href="#"></a></td>
<td><pre>            return new BigInteger(add(mag, Math.abs(val)), signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1236" href="#"></a></td>
<td><pre>        int cmp = compareMagnitude(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1237" href="#"></a></td>
<td><pre>        if (cmp == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1238" href="#"></a></td>
<td><pre>            return ZERO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1239" href="#"></a></td>
<td><pre>        int[] resultMag = (cmp &gt; 0 ? subtract(mag, Math.abs(val)) : subtract(Math.abs(val), mag));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1240" href="#"></a></td>
<td><pre>        resultMag = trustedStripLeadingZeroInts(resultMag);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1241" href="#"></a></td>
<td><pre>        return new BigInteger(resultMag, cmp == signum ? 1 : -1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1242" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1243" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1244" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1245" href="#"></a></td>
<td><pre>     * Adds the contents of the int array x and long value val. This</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1246" href="#"></a></td>
<td><pre>     * method allocates a new int array to hold the answer and returns</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1247" href="#"></a></td>
<td><pre>     * a reference to that array.  Assumes x.length &amp;gt; 0 and val is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1248" href="#"></a></td>
<td><pre>     * non-negative</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1249" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1250" href="#"></a></td>
<td><pre>    private static int[] add(int[] x, long val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1251" href="#"></a></td>
<td><pre>        int[] y;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1252" href="#"></a></td>
<td><pre>        long sum = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1253" href="#"></a></td>
<td><pre>        int xIndex = x.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1254" href="#"></a></td>
<td><pre>        int[] result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1255" href="#"></a></td>
<td><pre>        int highWord = (int)(val &gt;&gt;&gt; 32);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1256" href="#"></a></td>
<td><pre>        if (highWord == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1257" href="#"></a></td>
<td><pre>            result = new int[xIndex];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1258" href="#"></a></td>
<td><pre>            sum = (x[--xIndex] &amp; LONG_MASK) + val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1259" href="#"></a></td>
<td><pre>            result[xIndex] = (int)sum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1260" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1261" href="#"></a></td>
<td><pre>            if (xIndex == 1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1262" href="#"></a></td>
<td><pre>                result = new int[2];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1263" href="#"></a></td>
<td><pre>                sum = val  + (x[0] &amp; LONG_MASK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1264" href="#"></a></td>
<td><pre>                result[1] = (int)sum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1265" href="#"></a></td>
<td><pre>                result[0] = (int)(sum &gt;&gt;&gt; 32);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1266" href="#"></a></td>
<td><pre>                return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1267" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1268" href="#"></a></td>
<td><pre>                result = new int[xIndex];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1269" href="#"></a></td>
<td><pre>                sum = (x[--xIndex] &amp; LONG_MASK) + (val &amp; LONG_MASK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1270" href="#"></a></td>
<td><pre>                result[xIndex] = (int)sum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1271" href="#"></a></td>
<td><pre>                sum = (x[--xIndex] &amp; LONG_MASK) + (highWord &amp; LONG_MASK) + (sum &gt;&gt;&gt; 32);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1272" href="#"></a></td>
<td><pre>                result[xIndex] = (int)sum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1273" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1274" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1275" href="#"></a></td>
<td><pre>        // Copy remainder of longer number while carry propagation is required</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1276" href="#"></a></td>
<td><pre>        boolean carry = (sum &gt;&gt;&gt; 32 != 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1277" href="#"></a></td>
<td><pre>        while (xIndex &gt; 0 &amp;&amp; carry)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1278" href="#"></a></td>
<td><pre>            carry = ((result[--xIndex] = x[xIndex] + 1) == 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1279" href="#"></a></td>
<td><pre>        // Copy remainder of longer number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1280" href="#"></a></td>
<td><pre>        while (xIndex &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1281" href="#"></a></td>
<td><pre>            result[--xIndex] = x[xIndex];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1282" href="#"></a></td>
<td><pre>        // Grow result if necessary</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1283" href="#"></a></td>
<td><pre>        if (carry) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1284" href="#"></a></td>
<td><pre>            int bigger[] = new int[result.length + 1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1285" href="#"></a></td>
<td><pre>            System.arraycopy(result, 0, bigger, 1, result.length);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1286" href="#"></a></td>
<td><pre>            bigger[0] = 0x01;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1287" href="#"></a></td>
<td><pre>            return bigger;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1288" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1289" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1290" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1291" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1292" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1293" href="#"></a></td>
<td><pre>     * Adds the contents of the int arrays x and y. This method allocates</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1294" href="#"></a></td>
<td><pre>     * a new int array to hold the answer and returns a reference to that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1295" href="#"></a></td>
<td><pre>     * array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1296" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1297" href="#"></a></td>
<td><pre>    private static int[] add(int[] x, int[] y) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1298" href="#"></a></td>
<td><pre>        // If x is shorter, swap the two arrays</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1299" href="#"></a></td>
<td><pre>        if (x.length &lt; y.length) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1300" href="#"></a></td>
<td><pre>            int[] tmp = x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1301" href="#"></a></td>
<td><pre>            x = y;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1302" href="#"></a></td>
<td><pre>            y = tmp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1303" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1304" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1305" href="#"></a></td>
<td><pre>        int xIndex = x.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1306" href="#"></a></td>
<td><pre>        int yIndex = y.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1307" href="#"></a></td>
<td><pre>        int result[] = new int[xIndex];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1308" href="#"></a></td>
<td><pre>        long sum = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1309" href="#"></a></td>
<td><pre>        if (yIndex == 1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1310" href="#"></a></td>
<td><pre>            sum = (x[--xIndex] &amp; LONG_MASK) + (y[0] &amp; LONG_MASK) ;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1311" href="#"></a></td>
<td><pre>            result[xIndex] = (int)sum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1312" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1313" href="#"></a></td>
<td><pre>            // Add common parts of both numbers</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1314" href="#"></a></td>
<td><pre>            while (yIndex &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1315" href="#"></a></td>
<td><pre>                sum = (x[--xIndex] &amp; LONG_MASK) +</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1316" href="#"></a></td>
<td><pre>                      (y[--yIndex] &amp; LONG_MASK) + (sum &gt;&gt;&gt; 32);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1317" href="#"></a></td>
<td><pre>                result[xIndex] = (int)sum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1318" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1319" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1320" href="#"></a></td>
<td><pre>        // Copy remainder of longer number while carry propagation is required</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1321" href="#"></a></td>
<td><pre>        boolean carry = (sum &gt;&gt;&gt; 32 != 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1322" href="#"></a></td>
<td><pre>        while (xIndex &gt; 0 &amp;&amp; carry)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1323" href="#"></a></td>
<td><pre>            carry = ((result[--xIndex] = x[xIndex] + 1) == 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1324" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1325" href="#"></a></td>
<td><pre>        // Copy remainder of longer number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1326" href="#"></a></td>
<td><pre>        while (xIndex &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1327" href="#"></a></td>
<td><pre>            result[--xIndex] = x[xIndex];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1328" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1329" href="#"></a></td>
<td><pre>        // Grow result if necessary</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1330" href="#"></a></td>
<td><pre>        if (carry) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1331" href="#"></a></td>
<td><pre>            int bigger[] = new int[result.length + 1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1332" href="#"></a></td>
<td><pre>            System.arraycopy(result, 0, bigger, 1, result.length);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1333" href="#"></a></td>
<td><pre>            bigger[0] = 0x01;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1334" href="#"></a></td>
<td><pre>            return bigger;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1335" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1336" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1337" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1338" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1339" href="#"></a></td>
<td><pre>    private static int[] subtract(long val, int[] little) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1340" href="#"></a></td>
<td><pre>        int highWord = (int)(val &gt;&gt;&gt; 32);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1341" href="#"></a></td>
<td><pre>        if (highWord == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1342" href="#"></a></td>
<td><pre>            int result[] = new int[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1343" href="#"></a></td>
<td><pre>            result[0] = (int)(val - (little[0] &amp; LONG_MASK));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1344" href="#"></a></td>
<td><pre>            return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1345" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1346" href="#"></a></td>
<td><pre>            int result[] = new int[2];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1347" href="#"></a></td>
<td><pre>            if (little.length == 1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1348" href="#"></a></td>
<td><pre>                long difference = ((int)val &amp; LONG_MASK) - (little[0] &amp; LONG_MASK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1349" href="#"></a></td>
<td><pre>                result[1] = (int)difference;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1350" href="#"></a></td>
<td><pre>                // Subtract remainder of longer number while borrow propagates</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1351" href="#"></a></td>
<td><pre>                boolean borrow = (difference &gt;&gt; 32 != 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1352" href="#"></a></td>
<td><pre>                if (borrow) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1353" href="#"></a></td>
<td><pre>                    result[0] = highWord - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1354" href="#"></a></td>
<td><pre>                } else {        // Copy remainder of longer number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1355" href="#"></a></td>
<td><pre>                    result[0] = highWord;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1356" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1357" href="#"></a></td>
<td><pre>                return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1358" href="#"></a></td>
<td><pre>            } else { // little.length == 2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1359" href="#"></a></td>
<td><pre>                long difference = ((int)val &amp; LONG_MASK) - (little[1] &amp; LONG_MASK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1360" href="#"></a></td>
<td><pre>                result[1] = (int)difference;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1361" href="#"></a></td>
<td><pre>                difference = (highWord &amp; LONG_MASK) - (little[0] &amp; LONG_MASK) + (difference &gt;&gt; 32);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1362" href="#"></a></td>
<td><pre>                result[0] = (int)difference;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1363" href="#"></a></td>
<td><pre>                return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1364" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1365" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1366" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1367" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1368" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1369" href="#"></a></td>
<td><pre>     * Subtracts the contents of the second argument (val) from the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1370" href="#"></a></td>
<td><pre>     * first (big).  The first int array (big) must represent a larger number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1371" href="#"></a></td>
<td><pre>     * than the second.  This method allocates the space necessary to hold the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1372" href="#"></a></td>
<td><pre>     * answer.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1373" href="#"></a></td>
<td><pre>     * assumes val &amp;gt;= 0</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1374" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1375" href="#"></a></td>
<td><pre>    private static int[] subtract(int[] big, long val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1376" href="#"></a></td>
<td><pre>        int highWord = (int)(val &gt;&gt;&gt; 32);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1377" href="#"></a></td>
<td><pre>        int bigIndex = big.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1378" href="#"></a></td>
<td><pre>        int result[] = new int[bigIndex];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1379" href="#"></a></td>
<td><pre>        long difference = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1380" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1381" href="#"></a></td>
<td><pre>        if (highWord == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1382" href="#"></a></td>
<td><pre>            difference = (big[--bigIndex] &amp; LONG_MASK) - val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1383" href="#"></a></td>
<td><pre>            result[bigIndex] = (int)difference;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1384" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1385" href="#"></a></td>
<td><pre>            difference = (big[--bigIndex] &amp; LONG_MASK) - (val &amp; LONG_MASK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1386" href="#"></a></td>
<td><pre>            result[bigIndex] = (int)difference;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1387" href="#"></a></td>
<td><pre>            difference = (big[--bigIndex] &amp; LONG_MASK) - (highWord &amp; LONG_MASK) + (difference &gt;&gt; 32);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1388" href="#"></a></td>
<td><pre>            result[bigIndex] = (int)difference;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1389" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1390" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1391" href="#"></a></td>
<td><pre>        // Subtract remainder of longer number while borrow propagates</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1392" href="#"></a></td>
<td><pre>        boolean borrow = (difference &gt;&gt; 32 != 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1393" href="#"></a></td>
<td><pre>        while (bigIndex &gt; 0 &amp;&amp; borrow)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1394" href="#"></a></td>
<td><pre>            borrow = ((result[--bigIndex] = big[bigIndex] - 1) == -1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1395" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1396" href="#"></a></td>
<td><pre>        // Copy remainder of longer number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1397" href="#"></a></td>
<td><pre>        while (bigIndex &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1398" href="#"></a></td>
<td><pre>            result[--bigIndex] = big[bigIndex];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1399" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1400" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1401" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1402" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1403" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1404" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this - val)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1405" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1406" href="#"></a></td>
<td><pre>     * @param  val value to be subtracted from this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1407" href="#"></a></td>
<td><pre>     * @return {@code this - val}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1408" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1409" href="#"></a></td>
<td><pre>    public BigInteger subtract(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1410" href="#"></a></td>
<td><pre>        if (val.signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1411" href="#"></a></td>
<td><pre>            return this;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1412" href="#"></a></td>
<td><pre>        if (signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1413" href="#"></a></td>
<td><pre>            return val.negate();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1414" href="#"></a></td>
<td><pre>        if (val.signum != signum)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1415" href="#"></a></td>
<td><pre>            return new BigInteger(add(mag, val.mag), signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1416" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1417" href="#"></a></td>
<td><pre>        int cmp = compareMagnitude(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1418" href="#"></a></td>
<td><pre>        if (cmp == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1419" href="#"></a></td>
<td><pre>            return ZERO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1420" href="#"></a></td>
<td><pre>        int[] resultMag = (cmp &gt; 0 ? subtract(mag, val.mag)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1421" href="#"></a></td>
<td><pre>                           : subtract(val.mag, mag));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1422" href="#"></a></td>
<td><pre>        resultMag = trustedStripLeadingZeroInts(resultMag);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1423" href="#"></a></td>
<td><pre>        return new BigInteger(resultMag, cmp == signum ? 1 : -1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1424" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1425" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1426" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1427" href="#"></a></td>
<td><pre>     * Subtracts the contents of the second int arrays (little) from the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1428" href="#"></a></td>
<td><pre>     * first (big).  The first int array (big) must represent a larger number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1429" href="#"></a></td>
<td><pre>     * than the second.  This method allocates the space necessary to hold the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1430" href="#"></a></td>
<td><pre>     * answer.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1431" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1432" href="#"></a></td>
<td><pre>    private static int[] subtract(int[] big, int[] little) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1433" href="#"></a></td>
<td><pre>        int bigIndex = big.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1434" href="#"></a></td>
<td><pre>        int result[] = new int[bigIndex];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1435" href="#"></a></td>
<td><pre>        int littleIndex = little.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1436" href="#"></a></td>
<td><pre>        long difference = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1437" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1438" href="#"></a></td>
<td><pre>        // Subtract common parts of both numbers</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1439" href="#"></a></td>
<td><pre>        while (littleIndex &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1440" href="#"></a></td>
<td><pre>            difference = (big[--bigIndex] &amp; LONG_MASK) -</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1441" href="#"></a></td>
<td><pre>                         (little[--littleIndex] &amp; LONG_MASK) +</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1442" href="#"></a></td>
<td><pre>                         (difference &gt;&gt; 32);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1443" href="#"></a></td>
<td><pre>            result[bigIndex] = (int)difference;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1444" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1445" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1446" href="#"></a></td>
<td><pre>        // Subtract remainder of longer number while borrow propagates</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1447" href="#"></a></td>
<td><pre>        boolean borrow = (difference &gt;&gt; 32 != 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1448" href="#"></a></td>
<td><pre>        while (bigIndex &gt; 0 &amp;&amp; borrow)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1449" href="#"></a></td>
<td><pre>            borrow = ((result[--bigIndex] = big[bigIndex] - 1) == -1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1450" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1451" href="#"></a></td>
<td><pre>        // Copy remainder of longer number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1452" href="#"></a></td>
<td><pre>        while (bigIndex &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1453" href="#"></a></td>
<td><pre>            result[--bigIndex] = big[bigIndex];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1454" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1455" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1456" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1457" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1458" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1459" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this * val)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1460" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1461" href="#"></a></td>
<td><pre>     * @param  val value to be multiplied by this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1462" href="#"></a></td>
<td><pre>     * @return {@code this * val}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1463" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1464" href="#"></a></td>
<td><pre>    public BigInteger multiply(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1465" href="#"></a></td>
<td><pre>        if (val.signum == 0 || signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1466" href="#"></a></td>
<td><pre>            return ZERO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1467" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1468" href="#"></a></td>
<td><pre>        int xlen = mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1469" href="#"></a></td>
<td><pre>        int ylen = val.mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1470" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1471" href="#"></a></td>
<td><pre>        if ((xlen &lt; KARATSUBA_THRESHOLD) || (ylen &lt; KARATSUBA_THRESHOLD)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1472" href="#"></a></td>
<td><pre>            int resultSign = signum == val.signum ? 1 : -1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1473" href="#"></a></td>
<td><pre>            if (val.mag.length == 1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1474" href="#"></a></td>
<td><pre>                return multiplyByInt(mag,val.mag[0], resultSign);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1475" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1476" href="#"></a></td>
<td><pre>            if (mag.length == 1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1477" href="#"></a></td>
<td><pre>                return multiplyByInt(val.mag,mag[0], resultSign);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1478" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1479" href="#"></a></td>
<td><pre>            int[] result = multiplyToLen(mag, xlen,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1480" href="#"></a></td>
<td><pre>                                         val.mag, ylen, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1481" href="#"></a></td>
<td><pre>            result = trustedStripLeadingZeroInts(result);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1482" href="#"></a></td>
<td><pre>            return new BigInteger(result, resultSign);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1483" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1484" href="#"></a></td>
<td><pre>            if ((xlen &lt; TOOM_COOK_THRESHOLD) &amp;&amp; (ylen &lt; TOOM_COOK_THRESHOLD)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1485" href="#"></a></td>
<td><pre>                return multiplyKaratsuba(this, val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1486" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1487" href="#"></a></td>
<td><pre>                return multiplyToomCook3(this, val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1488" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1489" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1490" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1491" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1492" href="#"></a></td>
<td><pre>    private static BigInteger multiplyByInt(int[] x, int y, int sign) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1493" href="#"></a></td>
<td><pre>        if (Integer.bitCount(y) == 1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1494" href="#"></a></td>
<td><pre>            return new BigInteger(shiftLeft(x,Integer.numberOfTrailingZeros(y)), sign);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1495" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1496" href="#"></a></td>
<td><pre>        int xlen = x.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1497" href="#"></a></td>
<td><pre>        int[] rmag =  new int[xlen + 1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1498" href="#"></a></td>
<td><pre>        long carry = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1499" href="#"></a></td>
<td><pre>        long yl = y &amp; LONG_MASK;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1500" href="#"></a></td>
<td><pre>        int rstart = rmag.length - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1501" href="#"></a></td>
<td><pre>        for (int i = xlen - 1; i &gt;= 0; i--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1502" href="#"></a></td>
<td><pre>            long product = (x[i] &amp; LONG_MASK) * yl + carry;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1503" href="#"></a></td>
<td><pre>            rmag[rstart--] = (int)product;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1504" href="#"></a></td>
<td><pre>            carry = product &gt;&gt;&gt; 32;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1505" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1506" href="#"></a></td>
<td><pre>        if (carry == 0L) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1507" href="#"></a></td>
<td><pre>            rmag = java.util.Arrays.copyOfRange(rmag, 1, rmag.length);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1508" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1509" href="#"></a></td>
<td><pre>            rmag[rstart] = (int)carry;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1510" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1511" href="#"></a></td>
<td><pre>        return new BigInteger(rmag, sign);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1512" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1513" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1514" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1515" href="#"></a></td>
<td><pre>     * Package private methods used by BigDecimal code to multiply a BigInteger</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1516" href="#"></a></td>
<td><pre>     * with a long. Assumes v is not equal to INFLATED.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1517" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1518" href="#"></a></td>
<td><pre>    BigInteger multiply(long v) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1519" href="#"></a></td>
<td><pre>        if (v == 0 || signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1520" href="#"></a></td>
<td><pre>          return ZERO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1521" href="#"></a></td>
<td><pre>        if (v == BigDecimal.INFLATED)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1522" href="#"></a></td>
<td><pre>            return multiply(BigInteger.valueOf(v));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1523" href="#"></a></td>
<td><pre>        int rsign = (v &gt; 0 ? signum : -signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1524" href="#"></a></td>
<td><pre>        if (v &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1525" href="#"></a></td>
<td><pre>            v = -v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1526" href="#"></a></td>
<td><pre>        long dh = v &gt;&gt;&gt; 32;      // higher order bits</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1527" href="#"></a></td>
<td><pre>        long dl = v &amp; LONG_MASK; // lower order bits</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1528" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1529" href="#"></a></td>
<td><pre>        int xlen = mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1530" href="#"></a></td>
<td><pre>        int[] value = mag;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1531" href="#"></a></td>
<td><pre>        int[] rmag = (dh == 0L) ? (new int[xlen + 1]) : (new int[xlen + 2]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1532" href="#"></a></td>
<td><pre>        long carry = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1533" href="#"></a></td>
<td><pre>        int rstart = rmag.length - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1534" href="#"></a></td>
<td><pre>        for (int i = xlen - 1; i &gt;= 0; i--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1535" href="#"></a></td>
<td><pre>            long product = (value[i] &amp; LONG_MASK) * dl + carry;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1536" href="#"></a></td>
<td><pre>            rmag[rstart--] = (int)product;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1537" href="#"></a></td>
<td><pre>            carry = product &gt;&gt;&gt; 32;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1538" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1539" href="#"></a></td>
<td><pre>        rmag[rstart] = (int)carry;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1540" href="#"></a></td>
<td><pre>        if (dh != 0L) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1541" href="#"></a></td>
<td><pre>            carry = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1542" href="#"></a></td>
<td><pre>            rstart = rmag.length - 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1543" href="#"></a></td>
<td><pre>            for (int i = xlen - 1; i &gt;= 0; i--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1544" href="#"></a></td>
<td><pre>                long product = (value[i] &amp; LONG_MASK) * dh +</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1545" href="#"></a></td>
<td><pre>                    (rmag[rstart] &amp; LONG_MASK) + carry;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1546" href="#"></a></td>
<td><pre>                rmag[rstart--] = (int)product;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1547" href="#"></a></td>
<td><pre>                carry = product &gt;&gt;&gt; 32;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1548" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1549" href="#"></a></td>
<td><pre>            rmag[0] = (int)carry;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1550" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1551" href="#"></a></td>
<td><pre>        if (carry == 0L)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1552" href="#"></a></td>
<td><pre>            rmag = java.util.Arrays.copyOfRange(rmag, 1, rmag.length);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1553" href="#"></a></td>
<td><pre>        return new BigInteger(rmag, rsign);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1554" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1555" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1556" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1557" href="#"></a></td>
<td><pre>     * Multiplies int arrays x and y to the specified lengths and places</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1558" href="#"></a></td>
<td><pre>     * the result into z. There will be no leading zeros in the resultant array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1559" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1560" href="#"></a></td>
<td><pre>    private int[] multiplyToLen(int[] x, int xlen, int[] y, int ylen, int[] z) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1561" href="#"></a></td>
<td><pre>        int xstart = xlen - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1562" href="#"></a></td>
<td><pre>        int ystart = ylen - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1563" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1564" href="#"></a></td>
<td><pre>        if (z == null || z.length &lt; (xlen+ ylen))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1565" href="#"></a></td>
<td><pre>            z = new int[xlen+ylen];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1566" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1567" href="#"></a></td>
<td><pre>        long carry = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1568" href="#"></a></td>
<td><pre>        for (int j=ystart, k=ystart+1+xstart; j &gt;= 0; j--, k--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1569" href="#"></a></td>
<td><pre>            long product = (y[j] &amp; LONG_MASK) *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1570" href="#"></a></td>
<td><pre>                           (x[xstart] &amp; LONG_MASK) + carry;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1571" href="#"></a></td>
<td><pre>            z[k] = (int)product;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1572" href="#"></a></td>
<td><pre>            carry = product &gt;&gt;&gt; 32;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1573" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1574" href="#"></a></td>
<td><pre>        z[xstart] = (int)carry;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1575" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1576" href="#"></a></td>
<td><pre>        for (int i = xstart-1; i &gt;= 0; i--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1577" href="#"></a></td>
<td><pre>            carry = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1578" href="#"></a></td>
<td><pre>            for (int j=ystart, k=ystart+1+i; j &gt;= 0; j--, k--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1579" href="#"></a></td>
<td><pre>                long product = (y[j] &amp; LONG_MASK) *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1580" href="#"></a></td>
<td><pre>                               (x[i] &amp; LONG_MASK) +</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1581" href="#"></a></td>
<td><pre>                               (z[k] &amp; LONG_MASK) + carry;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1582" href="#"></a></td>
<td><pre>                z[k] = (int)product;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1583" href="#"></a></td>
<td><pre>                carry = product &gt;&gt;&gt; 32;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1584" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1585" href="#"></a></td>
<td><pre>            z[i] = (int)carry;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1586" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1587" href="#"></a></td>
<td><pre>        return z;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1588" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1589" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1590" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1591" href="#"></a></td>
<td><pre>     * Multiplies two BigIntegers using the Karatsuba multiplication</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1592" href="#"></a></td>
<td><pre>     * algorithm.  This is a recursive divide-and-conquer algorithm which is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1593" href="#"></a></td>
<td><pre>     * more efficient for large numbers than what is commonly called the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1594" href="#"></a></td>
<td><pre>     * &quot;grade-school&quot; algorithm used in multiplyToLen.  If the numbers to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1595" href="#"></a></td>
<td><pre>     * multiplied have length n, the &quot;grade-school&quot; algorithm has an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1596" href="#"></a></td>
<td><pre>     * asymptotic complexity of O(n^2).  In contrast, the Karatsuba algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1597" href="#"></a></td>
<td><pre>     * has complexity of O(n^(log2(3))), or O(n^1.585).  It achieves this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1598" href="#"></a></td>
<td><pre>     * increased performance by doing 3 multiplies instead of 4 when</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1599" href="#"></a></td>
<td><pre>     * evaluating the product.  As it has some overhead, should be used when</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1600" href="#"></a></td>
<td><pre>     * both numbers are larger than a certain threshold (found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1601" href="#"></a></td>
<td><pre>     * experimentally).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1602" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1603" href="#"></a></td>
<td><pre>     * See:  http://en.wikipedia.org/wiki/Karatsuba_algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1604" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1605" href="#"></a></td>
<td><pre>    private static BigInteger multiplyKaratsuba(BigInteger x, BigInteger y) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1606" href="#"></a></td>
<td><pre>        int xlen = x.mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1607" href="#"></a></td>
<td><pre>        int ylen = y.mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1608" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1609" href="#"></a></td>
<td><pre>        // The number of ints in each half of the number.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1610" href="#"></a></td>
<td><pre>        int half = (Math.max(xlen, ylen)+1) / 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1611" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1612" href="#"></a></td>
<td><pre>        // xl and yl are the lower halves of x and y respectively,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1613" href="#"></a></td>
<td><pre>        // xh and yh are the upper halves.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1614" href="#"></a></td>
<td><pre>        BigInteger xl = x.getLower(half);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1615" href="#"></a></td>
<td><pre>        BigInteger xh = x.getUpper(half);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1616" href="#"></a></td>
<td><pre>        BigInteger yl = y.getLower(half);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1617" href="#"></a></td>
<td><pre>        BigInteger yh = y.getUpper(half);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1618" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1619" href="#"></a></td>
<td><pre>        BigInteger p1 = xh.multiply(yh);  // p1 = xh*yh</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1620" href="#"></a></td>
<td><pre>        BigInteger p2 = xl.multiply(yl);  // p2 = xl*yl</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1621" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1622" href="#"></a></td>
<td><pre>        // p3=(xh+xl)*(yh+yl)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1623" href="#"></a></td>
<td><pre>        BigInteger p3 = xh.add(xl).multiply(yh.add(yl));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1624" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1625" href="#"></a></td>
<td><pre>        // result = p1 * 2^(32*2*half) + (p3 - p1 - p2) * 2^(32*half) + p2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1626" href="#"></a></td>
<td><pre>        BigInteger result = p1.shiftLeft(32*half).add(p3.subtract(p1).subtract(p2)).shiftLeft(32*half).add(p2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1627" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1628" href="#"></a></td>
<td><pre>        if (x.signum != y.signum) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1629" href="#"></a></td>
<td><pre>            return result.negate();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1630" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1631" href="#"></a></td>
<td><pre>            return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1632" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1633" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1634" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1635" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1636" href="#"></a></td>
<td><pre>     * Multiplies two BigIntegers using a 3-way Toom-Cook multiplication</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1637" href="#"></a></td>
<td><pre>     * algorithm.  This is a recursive divide-and-conquer algorithm which is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1638" href="#"></a></td>
<td><pre>     * more efficient for large numbers than what is commonly called the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1639" href="#"></a></td>
<td><pre>     * &quot;grade-school&quot; algorithm used in multiplyToLen.  If the numbers to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1640" href="#"></a></td>
<td><pre>     * multiplied have length n, the &quot;grade-school&quot; algorithm has an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1641" href="#"></a></td>
<td><pre>     * asymptotic complexity of O(n^2).  In contrast, 3-way Toom-Cook has a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1642" href="#"></a></td>
<td><pre>     * complexity of about O(n^1.465).  It achieves this increased asymptotic</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1643" href="#"></a></td>
<td><pre>     * performance by breaking each number into three parts and by doing 5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1644" href="#"></a></td>
<td><pre>     * multiplies instead of 9 when evaluating the product.  Due to overhead</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1645" href="#"></a></td>
<td><pre>     * (additions, shifts, and one division) in the Toom-Cook algorithm, it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1646" href="#"></a></td>
<td><pre>     * should only be used when both numbers are larger than a certain</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1647" href="#"></a></td>
<td><pre>     * threshold (found experimentally).  This threshold is generally larger</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1648" href="#"></a></td>
<td><pre>     * than that for Karatsuba multiplication, so this algorithm is generally</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1649" href="#"></a></td>
<td><pre>     * only used when numbers become significantly larger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1650" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1651" href="#"></a></td>
<td><pre>     * The algorithm used is the &quot;optimal&quot; 3-way Toom-Cook algorithm outlined</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1652" href="#"></a></td>
<td><pre>     * by Marco Bodrato.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1653" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1654" href="#"></a></td>
<td><pre>     *  See: http://bodrato.it/toom-cook/</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1655" href="#"></a></td>
<td><pre>     *       http://bodrato.it/papers/#WAIFI2007</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1656" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1657" href="#"></a></td>
<td><pre>     * &quot;Towards Optimal Toom-Cook Multiplication for Univariate and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1658" href="#"></a></td>
<td><pre>     * Multivariate Polynomials in Characteristic 2 and 0.&quot; by Marco BODRATO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1659" href="#"></a></td>
<td><pre>     * In C.Carlet and B.Sunar, Eds., &quot;WAIFI'07 proceedings&quot;, p. 116-133,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1660" href="#"></a></td>
<td><pre>     * LNCS #4547. Springer, Madrid, Spain, June 21-22, 2007.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1661" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1662" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1663" href="#"></a></td>
<td><pre>    private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1664" href="#"></a></td>
<td><pre>        int alen = a.mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1665" href="#"></a></td>
<td><pre>        int blen = b.mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1666" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1667" href="#"></a></td>
<td><pre>        int largest = Math.max(alen, blen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1668" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1669" href="#"></a></td>
<td><pre>        // k is the size (in ints) of the lower-order slices.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1670" href="#"></a></td>
<td><pre>        int k = (largest+2)/3;   // Equal to ceil(largest/3)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1671" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1672" href="#"></a></td>
<td><pre>        // r is the size (in ints) of the highest-order slice.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1673" href="#"></a></td>
<td><pre>        int r = largest - 2*k;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1674" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1675" href="#"></a></td>
<td><pre>        // Obtain slices of the numbers. a2 and b2 are the most significant</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1676" href="#"></a></td>
<td><pre>        // bits of the numbers a and b, and a0 and b0 the least significant.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1677" href="#"></a></td>
<td><pre>        BigInteger a0, a1, a2, b0, b1, b2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1678" href="#"></a></td>
<td><pre>        a2 = a.getToomSlice(k, r, 0, largest);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1679" href="#"></a></td>
<td><pre>        a1 = a.getToomSlice(k, r, 1, largest);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1680" href="#"></a></td>
<td><pre>        a0 = a.getToomSlice(k, r, 2, largest);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1681" href="#"></a></td>
<td><pre>        b2 = b.getToomSlice(k, r, 0, largest);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1682" href="#"></a></td>
<td><pre>        b1 = b.getToomSlice(k, r, 1, largest);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1683" href="#"></a></td>
<td><pre>        b0 = b.getToomSlice(k, r, 2, largest);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1684" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1685" href="#"></a></td>
<td><pre>        BigInteger v0, v1, v2, vm1, vinf, t1, t2, tm1, da1, db1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1686" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1687" href="#"></a></td>
<td><pre>        v0 = a0.multiply(b0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1688" href="#"></a></td>
<td><pre>        da1 = a2.add(a0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1689" href="#"></a></td>
<td><pre>        db1 = b2.add(b0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1690" href="#"></a></td>
<td><pre>        vm1 = da1.subtract(a1).multiply(db1.subtract(b1));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1691" href="#"></a></td>
<td><pre>        da1 = da1.add(a1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1692" href="#"></a></td>
<td><pre>        db1 = db1.add(b1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1693" href="#"></a></td>
<td><pre>        v1 = da1.multiply(db1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1694" href="#"></a></td>
<td><pre>        v2 = da1.add(a2).shiftLeft(1).subtract(a0).multiply(</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1695" href="#"></a></td>
<td><pre>             db1.add(b2).shiftLeft(1).subtract(b0));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1696" href="#"></a></td>
<td><pre>        vinf = a2.multiply(b2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1697" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1698" href="#"></a></td>
<td><pre>        // The algorithm requires two divisions by 2 and one by 3.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1699" href="#"></a></td>
<td><pre>        // All divisions are known to be exact, that is, they do not produce</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1700" href="#"></a></td>
<td><pre>        // remainders, and all results are positive.  The divisions by 2 are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1701" href="#"></a></td>
<td><pre>        // implemented as right shifts which are relatively efficient, leaving</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1702" href="#"></a></td>
<td><pre>        // only an exact division by 3, which is done by a specialized</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1703" href="#"></a></td>
<td><pre>        // linear-time algorithm.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1704" href="#"></a></td>
<td><pre>        t2 = v2.subtract(vm1).exactDivideBy3();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1705" href="#"></a></td>
<td><pre>        tm1 = v1.subtract(vm1).shiftRight(1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1706" href="#"></a></td>
<td><pre>        t1 = v1.subtract(v0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1707" href="#"></a></td>
<td><pre>        t2 = t2.subtract(t1).shiftRight(1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1708" href="#"></a></td>
<td><pre>        t1 = t1.subtract(tm1).subtract(vinf);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1709" href="#"></a></td>
<td><pre>        t2 = t2.subtract(vinf.shiftLeft(1));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1710" href="#"></a></td>
<td><pre>        tm1 = tm1.subtract(t2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1711" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1712" href="#"></a></td>
<td><pre>        // Number of bits to shift left.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1713" href="#"></a></td>
<td><pre>        int ss = k*32;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1714" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1715" href="#"></a></td>
<td><pre>        BigInteger result = vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1716" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1717" href="#"></a></td>
<td><pre>        if (a.signum != b.signum) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1718" href="#"></a></td>
<td><pre>            return result.negate();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1719" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1720" href="#"></a></td>
<td><pre>            return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1721" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1722" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1723" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1724" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1725" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1726" href="#"></a></td>
<td><pre>     * Returns a slice of a BigInteger for use in Toom-Cook multiplication.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1727" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1728" href="#"></a></td>
<td><pre>     * @param lowerSize The size of the lower-order bit slices.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1729" href="#"></a></td>
<td><pre>     * @param upperSize The size of the higher-order bit slices.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1730" href="#"></a></td>
<td><pre>     * @param slice The index of which slice is requested, which must be a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1731" href="#"></a></td>
<td><pre>     * number from 0 to size-1. Slice 0 is the highest-order bits, and slice</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1732" href="#"></a></td>
<td><pre>     * size-1 are the lowest-order bits. Slice 0 may be of different size than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1733" href="#"></a></td>
<td><pre>     * the other slices.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1734" href="#"></a></td>
<td><pre>     * @param fullsize The size of the larger integer array, used to align</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1735" href="#"></a></td>
<td><pre>     * slices to the appropriate position when multiplying different-sized</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1736" href="#"></a></td>
<td><pre>     * numbers.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1737" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1738" href="#"></a></td>
<td><pre>    private BigInteger getToomSlice(int lowerSize, int upperSize, int slice,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1739" href="#"></a></td>
<td><pre>                                    int fullsize) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1740" href="#"></a></td>
<td><pre>        int start, end, sliceSize, len, offset;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1741" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1742" href="#"></a></td>
<td><pre>        len = mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1743" href="#"></a></td>
<td><pre>        offset = fullsize - len;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1744" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1745" href="#"></a></td>
<td><pre>        if (slice == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1746" href="#"></a></td>
<td><pre>            start = 0 - offset;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1747" href="#"></a></td>
<td><pre>            end = upperSize - 1 - offset;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1748" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1749" href="#"></a></td>
<td><pre>            start = upperSize + (slice-1)*lowerSize - offset;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1750" href="#"></a></td>
<td><pre>            end = start + lowerSize - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1751" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1752" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1753" href="#"></a></td>
<td><pre>        if (start &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1754" href="#"></a></td>
<td><pre>            start = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1755" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1756" href="#"></a></td>
<td><pre>        if (end &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1757" href="#"></a></td>
<td><pre>           return ZERO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1758" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1759" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1760" href="#"></a></td>
<td><pre>        sliceSize = (end-start) + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1761" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1762" href="#"></a></td>
<td><pre>        if (sliceSize &lt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1763" href="#"></a></td>
<td><pre>            return ZERO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1764" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1765" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1766" href="#"></a></td>
<td><pre>        // While performing Toom-Cook, all slices are positive and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1767" href="#"></a></td>
<td><pre>        // the sign is adjusted when the final number is composed.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1768" href="#"></a></td>
<td><pre>        if (start == 0 &amp;&amp; sliceSize &gt;= len) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1769" href="#"></a></td>
<td><pre>            return this.abs();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1770" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1771" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1772" href="#"></a></td>
<td><pre>        int intSlice[] = new int[sliceSize];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1773" href="#"></a></td>
<td><pre>        System.arraycopy(mag, start, intSlice, 0, sliceSize);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1774" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1775" href="#"></a></td>
<td><pre>        return new BigInteger(trustedStripLeadingZeroInts(intSlice), 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1776" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1777" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1778" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1779" href="#"></a></td>
<td><pre>     * Does an exact division (that is, the remainder is known to be zero)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1780" href="#"></a></td>
<td><pre>     * of the specified number by 3.  This is used in Toom-Cook</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1781" href="#"></a></td>
<td><pre>     * multiplication.  This is an efficient algorithm that runs in linear</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1782" href="#"></a></td>
<td><pre>     * time.  If the argument is not exactly divisible by 3, results are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1783" href="#"></a></td>
<td><pre>     * undefined.  Note that this is expected to be called with positive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1784" href="#"></a></td>
<td><pre>     * arguments only.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1785" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1786" href="#"></a></td>
<td><pre>    private BigInteger exactDivideBy3() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1787" href="#"></a></td>
<td><pre>        int len = mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1788" href="#"></a></td>
<td><pre>        int[] result = new int[len];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1789" href="#"></a></td>
<td><pre>        long x, w, q, borrow;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1790" href="#"></a></td>
<td><pre>        borrow = 0L;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1791" href="#"></a></td>
<td><pre>        for (int i=len-1; i &gt;= 0; i--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1792" href="#"></a></td>
<td><pre>            x = (mag[i] &amp; LONG_MASK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1793" href="#"></a></td>
<td><pre>            w = x - borrow;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1794" href="#"></a></td>
<td><pre>            if (borrow &gt; x) {      // Did we make the number go negative?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1795" href="#"></a></td>
<td><pre>                borrow = 1L;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1796" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1797" href="#"></a></td>
<td><pre>                borrow = 0L;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1798" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1799" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1800" href="#"></a></td>
<td><pre>            // 0xAAAAAAAB is the modular inverse of 3 (mod 2^32).  Thus,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1801" href="#"></a></td>
<td><pre>            // the effect of this is to divide by 3 (mod 2^32).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1802" href="#"></a></td>
<td><pre>            // This is much faster than division on most architectures.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1803" href="#"></a></td>
<td><pre>            q = (w * 0xAAAAAAABL) &amp; LONG_MASK;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1804" href="#"></a></td>
<td><pre>            result[i] = (int) q;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1805" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1806" href="#"></a></td>
<td><pre>            // Now check the borrow. The second check can of course be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1807" href="#"></a></td>
<td><pre>            // eliminated if the first fails.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1808" href="#"></a></td>
<td><pre>            if (q &gt;= 0x55555556L) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1809" href="#"></a></td>
<td><pre>                borrow++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1810" href="#"></a></td>
<td><pre>                if (q &gt;= 0xAAAAAAABL)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1811" href="#"></a></td>
<td><pre>                    borrow++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1812" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1813" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1814" href="#"></a></td>
<td><pre>        result = trustedStripLeadingZeroInts(result);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1815" href="#"></a></td>
<td><pre>        return new BigInteger(result, signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1816" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1817" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1818" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1819" href="#"></a></td>
<td><pre>     * Returns a new BigInteger representing n lower ints of the number.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1820" href="#"></a></td>
<td><pre>     * This is used by Karatsuba multiplication and Karatsuba squaring.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1821" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1822" href="#"></a></td>
<td><pre>    private BigInteger getLower(int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1823" href="#"></a></td>
<td><pre>        int len = mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1824" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1825" href="#"></a></td>
<td><pre>        if (len &lt;= n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1826" href="#"></a></td>
<td><pre>            return abs();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1827" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1828" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1829" href="#"></a></td>
<td><pre>        int lowerInts[] = new int[n];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1830" href="#"></a></td>
<td><pre>        System.arraycopy(mag, len-n, lowerInts, 0, n);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1831" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1832" href="#"></a></td>
<td><pre>        return new BigInteger(trustedStripLeadingZeroInts(lowerInts), 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1833" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1834" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1835" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1836" href="#"></a></td>
<td><pre>     * Returns a new BigInteger representing mag.length-n upper</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1837" href="#"></a></td>
<td><pre>     * ints of the number.  This is used by Karatsuba multiplication and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1838" href="#"></a></td>
<td><pre>     * Karatsuba squaring.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1839" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1840" href="#"></a></td>
<td><pre>    private BigInteger getUpper(int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1841" href="#"></a></td>
<td><pre>        int len = mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1842" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1843" href="#"></a></td>
<td><pre>        if (len &lt;= n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1844" href="#"></a></td>
<td><pre>            return ZERO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1845" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1846" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1847" href="#"></a></td>
<td><pre>        int upperLen = len - n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1848" href="#"></a></td>
<td><pre>        int upperInts[] = new int[upperLen];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1849" href="#"></a></td>
<td><pre>        System.arraycopy(mag, 0, upperInts, 0, upperLen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1850" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1851" href="#"></a></td>
<td><pre>        return new BigInteger(trustedStripLeadingZeroInts(upperInts), 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1852" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1853" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1854" href="#"></a></td>
<td><pre>    // Squaring</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1855" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1856" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1857" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this&lt;sup&gt;2&lt;/sup&gt;)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1858" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1859" href="#"></a></td>
<td><pre>     * @return {@code this&lt;sup&gt;2&lt;/sup&gt;}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1860" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1861" href="#"></a></td>
<td><pre>    private BigInteger square() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1862" href="#"></a></td>
<td><pre>        if (signum == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1863" href="#"></a></td>
<td><pre>            return ZERO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1864" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1865" href="#"></a></td>
<td><pre>        int len = mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1866" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1867" href="#"></a></td>
<td><pre>        if (len &lt; KARATSUBA_SQUARE_THRESHOLD) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1868" href="#"></a></td>
<td><pre>            int[] z = squareToLen(mag, len, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1869" href="#"></a></td>
<td><pre>            return new BigInteger(trustedStripLeadingZeroInts(z), 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1870" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1871" href="#"></a></td>
<td><pre>            if (len &lt; TOOM_COOK_SQUARE_THRESHOLD) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1872" href="#"></a></td>
<td><pre>                return squareKaratsuba();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1873" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1874" href="#"></a></td>
<td><pre>                return squareToomCook3();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1875" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1876" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1877" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1878" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1879" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1880" href="#"></a></td>
<td><pre>     * Squares the contents of the int array x. The result is placed into the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1881" href="#"></a></td>
<td><pre>     * int array z.  The contents of x are not changed.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1882" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1883" href="#"></a></td>
<td><pre>    private static final int[] squareToLen(int[] x, int len, int[] z) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1884" href="#"></a></td>
<td><pre>        /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1885" href="#"></a></td>
<td><pre>         * The algorithm used here is adapted from Colin Plumb's C library.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1886" href="#"></a></td>
<td><pre>         * Technique: Consider the partial products in the multiplication</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1887" href="#"></a></td>
<td><pre>         * of &quot;abcde&quot; by itself:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1888" href="#"></a></td>
<td><pre>         *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1889" href="#"></a></td>
<td><pre>         *               a  b  c  d  e</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1890" href="#"></a></td>
<td><pre>         *            *  a  b  c  d  e</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1891" href="#"></a></td>
<td><pre>         *          ==================</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1892" href="#"></a></td>
<td><pre>         *              ae be ce de ee</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1893" href="#"></a></td>
<td><pre>         *           ad bd cd dd de</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1894" href="#"></a></td>
<td><pre>         *        ac bc cc cd ce</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1895" href="#"></a></td>
<td><pre>         *     ab bb bc bd be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1896" href="#"></a></td>
<td><pre>         *  aa ab ac ad ae</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1897" href="#"></a></td>
<td><pre>         *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1898" href="#"></a></td>
<td><pre>         * Note that everything above the main diagonal:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1899" href="#"></a></td>
<td><pre>         *              ae be ce de = (abcd) * e</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1900" href="#"></a></td>
<td><pre>         *           ad bd cd       = (abc) * d</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1901" href="#"></a></td>
<td><pre>         *        ac bc             = (ab) * c</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1902" href="#"></a></td>
<td><pre>         *     ab                   = (a) * b</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1903" href="#"></a></td>
<td><pre>         *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1904" href="#"></a></td>
<td><pre>         * is a copy of everything below the main diagonal:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1905" href="#"></a></td>
<td><pre>         *                       de</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1906" href="#"></a></td>
<td><pre>         *                 cd ce</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1907" href="#"></a></td>
<td><pre>         *           bc bd be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1908" href="#"></a></td>
<td><pre>         *     ab ac ad ae</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1909" href="#"></a></td>
<td><pre>         *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1910" href="#"></a></td>
<td><pre>         * Thus, the sum is 2 * (off the diagonal) + diagonal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1911" href="#"></a></td>
<td><pre>         *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1912" href="#"></a></td>
<td><pre>         * This is accumulated beginning with the diagonal (which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1913" href="#"></a></td>
<td><pre>         * consist of the squares of the digits of the input), which is then</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1914" href="#"></a></td>
<td><pre>         * divided by two, the off-diagonal added, and multiplied by two</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1915" href="#"></a></td>
<td><pre>         * again.  The low bit is simply a copy of the low bit of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1916" href="#"></a></td>
<td><pre>         * input, so it doesn't need special care.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1917" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1918" href="#"></a></td>
<td><pre>        int zlen = len &lt;&lt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1919" href="#"></a></td>
<td><pre>        if (z == null || z.length &lt; zlen)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1920" href="#"></a></td>
<td><pre>            z = new int[zlen];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1921" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1922" href="#"></a></td>
<td><pre>        // Store the squares, right shifted one bit (i.e., divided by 2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1923" href="#"></a></td>
<td><pre>        int lastProductLowWord = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1924" href="#"></a></td>
<td><pre>        for (int j=0, i=0; j &lt; len; j++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1925" href="#"></a></td>
<td><pre>            long piece = (x[j] &amp; LONG_MASK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1926" href="#"></a></td>
<td><pre>            long product = piece * piece;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1927" href="#"></a></td>
<td><pre>            z[i++] = (lastProductLowWord &lt;&lt; 31) | (int)(product &gt;&gt;&gt; 33);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1928" href="#"></a></td>
<td><pre>            z[i++] = (int)(product &gt;&gt;&gt; 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1929" href="#"></a></td>
<td><pre>            lastProductLowWord = (int)product;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1930" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1931" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1932" href="#"></a></td>
<td><pre>        // Add in off-diagonal sums</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1933" href="#"></a></td>
<td><pre>        for (int i=len, offset=1; i &gt; 0; i--, offset+=2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1934" href="#"></a></td>
<td><pre>            int t = x[i-1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1935" href="#"></a></td>
<td><pre>            t = mulAdd(z, x, offset, i-1, t);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1936" href="#"></a></td>
<td><pre>            addOne(z, offset-1, i, t);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1937" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1938" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1939" href="#"></a></td>
<td><pre>        // Shift back up and set low bit</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1940" href="#"></a></td>
<td><pre>        primitiveLeftShift(z, zlen, 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1941" href="#"></a></td>
<td><pre>        z[zlen-1] |= x[len-1] &amp; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1942" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1943" href="#"></a></td>
<td><pre>        return z;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1944" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1945" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1946" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1947" href="#"></a></td>
<td><pre>     * Squares a BigInteger using the Karatsuba squaring algorithm.  It should</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1948" href="#"></a></td>
<td><pre>     * be used when both numbers are larger than a certain threshold (found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1949" href="#"></a></td>
<td><pre>     * experimentally).  It is a recursive divide-and-conquer algorithm that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1950" href="#"></a></td>
<td><pre>     * has better asymptotic performance than the algorithm used in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1951" href="#"></a></td>
<td><pre>     * squareToLen.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1952" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1953" href="#"></a></td>
<td><pre>    private BigInteger squareKaratsuba() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1954" href="#"></a></td>
<td><pre>        int half = (mag.length+1) / 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1955" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1956" href="#"></a></td>
<td><pre>        BigInteger xl = getLower(half);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1957" href="#"></a></td>
<td><pre>        BigInteger xh = getUpper(half);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1958" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1959" href="#"></a></td>
<td><pre>        BigInteger xhs = xh.square();  // xhs = xh^2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1960" href="#"></a></td>
<td><pre>        BigInteger xls = xl.square();  // xls = xl^2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1961" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1962" href="#"></a></td>
<td><pre>        // xh^2 &lt;&lt; 64  +  (((xl+xh)^2 - (xh^2 + xl^2)) &lt;&lt; 32) + xl^2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1963" href="#"></a></td>
<td><pre>        return xhs.shiftLeft(half*32).add(xl.add(xh).square().subtract(xhs.add(xls))).shiftLeft(half*32).add(xls);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1964" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1965" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1966" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1967" href="#"></a></td>
<td><pre>     * Squares a BigInteger using the 3-way Toom-Cook squaring algorithm.  It</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1968" href="#"></a></td>
<td><pre>     * should be used when both numbers are larger than a certain threshold</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1969" href="#"></a></td>
<td><pre>     * (found experimentally).  It is a recursive divide-and-conquer algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1970" href="#"></a></td>
<td><pre>     * that has better asymptotic performance than the algorithm used in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1971" href="#"></a></td>
<td><pre>     * squareToLen or squareKaratsuba.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1972" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1973" href="#"></a></td>
<td><pre>    private BigInteger squareToomCook3() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1974" href="#"></a></td>
<td><pre>        int len = mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1975" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1976" href="#"></a></td>
<td><pre>        // k is the size (in ints) of the lower-order slices.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1977" href="#"></a></td>
<td><pre>        int k = (len+2)/3;   // Equal to ceil(largest/3)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1978" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1979" href="#"></a></td>
<td><pre>        // r is the size (in ints) of the highest-order slice.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1980" href="#"></a></td>
<td><pre>        int r = len - 2*k;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1981" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1982" href="#"></a></td>
<td><pre>        // Obtain slices of the numbers. a2 is the most significant</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1983" href="#"></a></td>
<td><pre>        // bits of the number, and a0 the least significant.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1984" href="#"></a></td>
<td><pre>        BigInteger a0, a1, a2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1985" href="#"></a></td>
<td><pre>        a2 = getToomSlice(k, r, 0, len);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1986" href="#"></a></td>
<td><pre>        a1 = getToomSlice(k, r, 1, len);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1987" href="#"></a></td>
<td><pre>        a0 = getToomSlice(k, r, 2, len);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1988" href="#"></a></td>
<td><pre>        BigInteger v0, v1, v2, vm1, vinf, t1, t2, tm1, da1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1989" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1990" href="#"></a></td>
<td><pre>        v0 = a0.square();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1991" href="#"></a></td>
<td><pre>        da1 = a2.add(a0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1992" href="#"></a></td>
<td><pre>        vm1 = da1.subtract(a1).square();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1993" href="#"></a></td>
<td><pre>        da1 = da1.add(a1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1994" href="#"></a></td>
<td><pre>        v1 = da1.square();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1995" href="#"></a></td>
<td><pre>        vinf = a2.square();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1996" href="#"></a></td>
<td><pre>        v2 = da1.add(a2).shiftLeft(1).subtract(a0).square();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1997" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1998" href="#"></a></td>
<td><pre>        // The algorithm requires two divisions by 2 and one by 3.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1999" href="#"></a></td>
<td><pre>        // All divisions are known to be exact, that is, they do not produce</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2000" href="#"></a></td>
<td><pre>        // remainders, and all results are positive.  The divisions by 2 are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2001" href="#"></a></td>
<td><pre>        // implemented as right shifts which are relatively efficient, leaving</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2002" href="#"></a></td>
<td><pre>        // only a division by 3.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2003" href="#"></a></td>
<td><pre>        // The division by 3 is done by an optimized algorithm for this case.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2004" href="#"></a></td>
<td><pre>        t2 = v2.subtract(vm1).exactDivideBy3();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2005" href="#"></a></td>
<td><pre>        tm1 = v1.subtract(vm1).shiftRight(1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2006" href="#"></a></td>
<td><pre>        t1 = v1.subtract(v0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2007" href="#"></a></td>
<td><pre>        t2 = t2.subtract(t1).shiftRight(1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2008" href="#"></a></td>
<td><pre>        t1 = t1.subtract(tm1).subtract(vinf);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2009" href="#"></a></td>
<td><pre>        t2 = t2.subtract(vinf.shiftLeft(1));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2010" href="#"></a></td>
<td><pre>        tm1 = tm1.subtract(t2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2011" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2012" href="#"></a></td>
<td><pre>        // Number of bits to shift left.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2013" href="#"></a></td>
<td><pre>        int ss = k*32;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2014" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2015" href="#"></a></td>
<td><pre>        return vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2016" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2017" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2018" href="#"></a></td>
<td><pre>    // Division</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2019" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2020" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2021" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this / val)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2022" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2023" href="#"></a></td>
<td><pre>     * @param  val value by which this BigInteger is to be divided.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2024" href="#"></a></td>
<td><pre>     * @return {@code this / val}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2025" href="#"></a></td>
<td><pre>     * @throws ArithmeticException if {@code val} is zero.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2026" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2027" href="#"></a></td>
<td><pre>    public BigInteger divide(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2028" href="#"></a></td>
<td><pre>        if (val.mag.length &lt; BURNIKEL_ZIEGLER_THRESHOLD ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2029" href="#"></a></td>
<td><pre>                mag.length - val.mag.length &lt; BURNIKEL_ZIEGLER_OFFSET) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2030" href="#"></a></td>
<td><pre>            return divideKnuth(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2031" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2032" href="#"></a></td>
<td><pre>            return divideBurnikelZiegler(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2033" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2034" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2035" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2036" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2037" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this / val)} using an O(n^2) algorithm from Knuth.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2038" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2039" href="#"></a></td>
<td><pre>     * @param  val value by which this BigInteger is to be divided.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2040" href="#"></a></td>
<td><pre>     * @return {@code this / val}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2041" href="#"></a></td>
<td><pre>     * @throws ArithmeticException if {@code val} is zero.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2042" href="#"></a></td>
<td><pre>     * @see MutableBigInteger#divideKnuth(MutableBigInteger, MutableBigInteger, boolean)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2043" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2044" href="#"></a></td>
<td><pre>    private BigInteger divideKnuth(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2045" href="#"></a></td>
<td><pre>        MutableBigInteger q = new MutableBigInteger(),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2046" href="#"></a></td>
<td><pre>                          a = new MutableBigInteger(this.mag),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2047" href="#"></a></td>
<td><pre>                          b = new MutableBigInteger(val.mag);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2048" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2049" href="#"></a></td>
<td><pre>        a.divideKnuth(b, q, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2050" href="#"></a></td>
<td><pre>        return q.toBigInteger(this.signum * val.signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2051" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2052" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2053" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2054" href="#"></a></td>
<td><pre>     * Returns an array of two BigIntegers containing {@code (this / val)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2055" href="#"></a></td>
<td><pre>     * followed by {@code (this % val)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2056" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2057" href="#"></a></td>
<td><pre>     * @param  val value by which this BigInteger is to be divided, and the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2058" href="#"></a></td>
<td><pre>     *         remainder computed.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2059" href="#"></a></td>
<td><pre>     * @return an array of two BigIntegers: the quotient {@code (this / val)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2060" href="#"></a></td>
<td><pre>     *         is the initial element, and the remainder {@code (this % val)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2061" href="#"></a></td>
<td><pre>     *         is the final element.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2062" href="#"></a></td>
<td><pre>     * @throws ArithmeticException if {@code val} is zero.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2063" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2064" href="#"></a></td>
<td><pre>    public BigInteger[] divideAndRemainder(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2065" href="#"></a></td>
<td><pre>        if (val.mag.length &lt; BURNIKEL_ZIEGLER_THRESHOLD ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2066" href="#"></a></td>
<td><pre>                mag.length - val.mag.length &lt; BURNIKEL_ZIEGLER_OFFSET) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2067" href="#"></a></td>
<td><pre>            return divideAndRemainderKnuth(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2068" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2069" href="#"></a></td>
<td><pre>            return divideAndRemainderBurnikelZiegler(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2070" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2071" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2072" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2073" href="#"></a></td>
<td><pre>    /** Long division */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2074" href="#"></a></td>
<td><pre>    private BigInteger[] divideAndRemainderKnuth(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2075" href="#"></a></td>
<td><pre>        BigInteger[] result = new BigInteger[2];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2076" href="#"></a></td>
<td><pre>        MutableBigInteger q = new MutableBigInteger(),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2077" href="#"></a></td>
<td><pre>                          a = new MutableBigInteger(this.mag),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2078" href="#"></a></td>
<td><pre>                          b = new MutableBigInteger(val.mag);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2079" href="#"></a></td>
<td><pre>        MutableBigInteger r = a.divideKnuth(b, q);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2080" href="#"></a></td>
<td><pre>        result[0] = q.toBigInteger(this.signum == val.signum ? 1 : -1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2081" href="#"></a></td>
<td><pre>        result[1] = r.toBigInteger(this.signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2082" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2083" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2084" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2085" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2086" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this % val)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2087" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2088" href="#"></a></td>
<td><pre>     * @param  val value by which this BigInteger is to be divided, and the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2089" href="#"></a></td>
<td><pre>     *         remainder computed.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2090" href="#"></a></td>
<td><pre>     * @return {@code this % val}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2091" href="#"></a></td>
<td><pre>     * @throws ArithmeticException if {@code val} is zero.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2092" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2093" href="#"></a></td>
<td><pre>    public BigInteger remainder(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2094" href="#"></a></td>
<td><pre>        if (val.mag.length &lt; BURNIKEL_ZIEGLER_THRESHOLD ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2095" href="#"></a></td>
<td><pre>                mag.length - val.mag.length &lt; BURNIKEL_ZIEGLER_OFFSET) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2096" href="#"></a></td>
<td><pre>            return remainderKnuth(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2097" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2098" href="#"></a></td>
<td><pre>            return remainderBurnikelZiegler(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2099" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2100" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2101" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2102" href="#"></a></td>
<td><pre>    /** Long division */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2103" href="#"></a></td>
<td><pre>    private BigInteger remainderKnuth(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2104" href="#"></a></td>
<td><pre>        MutableBigInteger q = new MutableBigInteger(),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2105" href="#"></a></td>
<td><pre>                          a = new MutableBigInteger(this.mag),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2106" href="#"></a></td>
<td><pre>                          b = new MutableBigInteger(val.mag);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2107" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2108" href="#"></a></td>
<td><pre>        return a.divideKnuth(b, q).toBigInteger(this.signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2109" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2110" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2111" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2112" href="#"></a></td>
<td><pre>     * Calculates {@code this / val} using the Burnikel-Ziegler algorithm.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2113" href="#"></a></td>
<td><pre>     * @param  val the divisor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2114" href="#"></a></td>
<td><pre>     * @return {@code this / val}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2115" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2116" href="#"></a></td>
<td><pre>    private BigInteger divideBurnikelZiegler(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2117" href="#"></a></td>
<td><pre>        return divideAndRemainderBurnikelZiegler(val)[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2118" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2119" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2120" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2121" href="#"></a></td>
<td><pre>     * Calculates {@code this % val} using the Burnikel-Ziegler algorithm.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2122" href="#"></a></td>
<td><pre>     * @param val the divisor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2123" href="#"></a></td>
<td><pre>     * @return {@code this % val}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2124" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2125" href="#"></a></td>
<td><pre>    private BigInteger remainderBurnikelZiegler(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2126" href="#"></a></td>
<td><pre>        return divideAndRemainderBurnikelZiegler(val)[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2127" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2128" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2129" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2130" href="#"></a></td>
<td><pre>     * Computes {@code this / val} and {@code this % val} using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2131" href="#"></a></td>
<td><pre>     * Burnikel-Ziegler algorithm.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2132" href="#"></a></td>
<td><pre>     * @param val the divisor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2133" href="#"></a></td>
<td><pre>     * @return an array containing the quotient and remainder</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2134" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2135" href="#"></a></td>
<td><pre>    private BigInteger[] divideAndRemainderBurnikelZiegler(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2136" href="#"></a></td>
<td><pre>        MutableBigInteger q = new MutableBigInteger();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2137" href="#"></a></td>
<td><pre>        MutableBigInteger r = new MutableBigInteger(this).divideAndRemainderBurnikelZiegler(new MutableBigInteger(val), q);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2138" href="#"></a></td>
<td><pre>        BigInteger qBigInt = q.isZero() ? ZERO : q.toBigInteger(signum*val.signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2139" href="#"></a></td>
<td><pre>        BigInteger rBigInt = r.isZero() ? ZERO : r.toBigInteger(signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2140" href="#"></a></td>
<td><pre>        return new BigInteger[] {qBigInt, rBigInt};</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2141" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2142" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2143" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2144" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is &lt;tt&gt;(this&lt;sup&gt;exponent&lt;/sup&gt;)&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2145" href="#"></a></td>
<td><pre>     * Note that {@code exponent} is an integer rather than a BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2146" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2147" href="#"></a></td>
<td><pre>     * @param  exponent exponent to which this BigInteger is to be raised.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2148" href="#"></a></td>
<td><pre>     * @return &lt;tt&gt;this&lt;sup&gt;exponent&lt;/sup&gt;&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2149" href="#"></a></td>
<td><pre>     * @throws ArithmeticException {@code exponent} is negative.  (This would</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2150" href="#"></a></td>
<td><pre>     *         cause the operation to yield a non-integer value.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2151" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2152" href="#"></a></td>
<td><pre>    public BigInteger pow(int exponent) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2153" href="#"></a></td>
<td><pre>        if (exponent &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2154" href="#"></a></td>
<td><pre>            throw new ArithmeticException(&quot;Negative exponent&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2155" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2156" href="#"></a></td>
<td><pre>        if (signum == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2157" href="#"></a></td>
<td><pre>            return (exponent == 0 ? ONE : this);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2158" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2159" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2160" href="#"></a></td>
<td><pre>        BigInteger partToSquare = this.abs();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2161" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2162" href="#"></a></td>
<td><pre>        // Factor out powers of two from the base, as the exponentiation of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2163" href="#"></a></td>
<td><pre>        // these can be done by left shifts only.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2164" href="#"></a></td>
<td><pre>        // The remaining part can then be exponentiated faster.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2165" href="#"></a></td>
<td><pre>        // powers of two will be multiplied back at the end.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2166" href="#"></a></td>
<td><pre>        int powersOfTwo = partToSquare.getLowestSetBit();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2167" href="#"></a></td>
<td><pre>        long bitsToShift = (long)powersOfTwo * exponent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2168" href="#"></a></td>
<td><pre>        if (bitsToShift &gt; Integer.MAX_VALUE) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2169" href="#"></a></td>
<td><pre>            reportOverflow();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2170" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2171" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2172" href="#"></a></td>
<td><pre>        int remainingBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2173" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2174" href="#"></a></td>
<td><pre>        // Factor the powers of two out quickly by shifting right, if needed.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2175" href="#"></a></td>
<td><pre>        if (powersOfTwo &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2176" href="#"></a></td>
<td><pre>            partToSquare = partToSquare.shiftRight(powersOfTwo);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2177" href="#"></a></td>
<td><pre>            remainingBits = partToSquare.bitLength();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2178" href="#"></a></td>
<td><pre>            if (remainingBits == 1) {  // Nothing left but +/- 1?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2179" href="#"></a></td>
<td><pre>                if (signum &lt; 0 &amp;&amp; (exponent&amp;1) == 1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2180" href="#"></a></td>
<td><pre>                    return NEGATIVE_ONE.shiftLeft(powersOfTwo*exponent);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2181" href="#"></a></td>
<td><pre>                } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2182" href="#"></a></td>
<td><pre>                    return ONE.shiftLeft(powersOfTwo*exponent);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2183" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2184" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2185" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2186" href="#"></a></td>
<td><pre>            remainingBits = partToSquare.bitLength();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2187" href="#"></a></td>
<td><pre>            if (remainingBits == 1) { // Nothing left but +/- 1?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2188" href="#"></a></td>
<td><pre>                if (signum &lt; 0  &amp;&amp; (exponent&amp;1) == 1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2189" href="#"></a></td>
<td><pre>                    return NEGATIVE_ONE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2190" href="#"></a></td>
<td><pre>                } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2191" href="#"></a></td>
<td><pre>                    return ONE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2192" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2193" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2194" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2195" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2196" href="#"></a></td>
<td><pre>        // This is a quick way to approximate the size of the result,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2197" href="#"></a></td>
<td><pre>        // similar to doing log2[n] * exponent.  This will give an upper bound</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2198" href="#"></a></td>
<td><pre>        // of how big the result can be, and which algorithm to use.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2199" href="#"></a></td>
<td><pre>        long scaleFactor = (long)remainingBits * exponent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2200" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2201" href="#"></a></td>
<td><pre>        // Use slightly different algorithms for small and large operands.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2202" href="#"></a></td>
<td><pre>        // See if the result will safely fit into a long. (Largest 2^63-1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2203" href="#"></a></td>
<td><pre>        if (partToSquare.mag.length == 1 &amp;&amp; scaleFactor &lt;= 62) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2204" href="#"></a></td>
<td><pre>            // Small number algorithm.  Everything fits into a long.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2205" href="#"></a></td>
<td><pre>            int newSign = (signum &lt;0  &amp;&amp; (exponent&amp;1) == 1 ? -1 : 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2206" href="#"></a></td>
<td><pre>            long result = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2207" href="#"></a></td>
<td><pre>            long baseToPow2 = partToSquare.mag[0] &amp; LONG_MASK;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2208" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2209" href="#"></a></td>
<td><pre>            int workingExponent = exponent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2210" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2211" href="#"></a></td>
<td><pre>            // Perform exponentiation using repeated squaring trick</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2212" href="#"></a></td>
<td><pre>            while (workingExponent != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2213" href="#"></a></td>
<td><pre>                if ((workingExponent &amp; 1) == 1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2214" href="#"></a></td>
<td><pre>                    result = result * baseToPow2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2215" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2216" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2217" href="#"></a></td>
<td><pre>                if ((workingExponent &gt;&gt;&gt;= 1) != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2218" href="#"></a></td>
<td><pre>                    baseToPow2 = baseToPow2 * baseToPow2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2219" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2220" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2221" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2222" href="#"></a></td>
<td><pre>            // Multiply back the powers of two (quickly, by shifting left)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2223" href="#"></a></td>
<td><pre>            if (powersOfTwo &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2224" href="#"></a></td>
<td><pre>                if (bitsToShift + scaleFactor &lt;= 62) { // Fits in long?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2225" href="#"></a></td>
<td><pre>                    return valueOf((result &lt;&lt; bitsToShift) * newSign);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2226" href="#"></a></td>
<td><pre>                } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2227" href="#"></a></td>
<td><pre>                    return valueOf(result*newSign).shiftLeft((int) bitsToShift);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2228" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2229" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2230" href="#"></a></td>
<td><pre>            else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2231" href="#"></a></td>
<td><pre>                return valueOf(result*newSign);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2232" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2233" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2234" href="#"></a></td>
<td><pre>            // Large number algorithm.  This is basically identical to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2235" href="#"></a></td>
<td><pre>            // the algorithm above, but calls multiply() and square()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2236" href="#"></a></td>
<td><pre>            // which may use more efficient algorithms for large numbers.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2237" href="#"></a></td>
<td><pre>            BigInteger answer = ONE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2238" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2239" href="#"></a></td>
<td><pre>            int workingExponent = exponent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2240" href="#"></a></td>
<td><pre>            // Perform exponentiation using repeated squaring trick</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2241" href="#"></a></td>
<td><pre>            while (workingExponent != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2242" href="#"></a></td>
<td><pre>                if ((workingExponent &amp; 1) == 1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2243" href="#"></a></td>
<td><pre>                    answer = answer.multiply(partToSquare);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2244" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2245" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2246" href="#"></a></td>
<td><pre>                if ((workingExponent &gt;&gt;&gt;= 1) != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2247" href="#"></a></td>
<td><pre>                    partToSquare = partToSquare.square();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2248" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2249" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2250" href="#"></a></td>
<td><pre>            // Multiply back the (exponentiated) powers of two (quickly,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2251" href="#"></a></td>
<td><pre>            // by shifting left)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2252" href="#"></a></td>
<td><pre>            if (powersOfTwo &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2253" href="#"></a></td>
<td><pre>                answer = answer.shiftLeft(powersOfTwo*exponent);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2254" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2255" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2256" href="#"></a></td>
<td><pre>            if (signum &lt; 0 &amp;&amp; (exponent&amp;1) == 1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2257" href="#"></a></td>
<td><pre>                return answer.negate();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2258" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2259" href="#"></a></td>
<td><pre>                return answer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2260" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2261" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2262" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2263" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2264" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2265" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is the greatest common divisor of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2266" href="#"></a></td>
<td><pre>     * {@code abs(this)} and {@code abs(val)}.  Returns 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2267" href="#"></a></td>
<td><pre>     * {@code this == 0 &amp;&amp; val == 0}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2268" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2269" href="#"></a></td>
<td><pre>     * @param  val value with which the GCD is to be computed.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2270" href="#"></a></td>
<td><pre>     * @return {@code GCD(abs(this), abs(val))}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2271" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2272" href="#"></a></td>
<td><pre>    public BigInteger gcd(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2273" href="#"></a></td>
<td><pre>        if (val.signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2274" href="#"></a></td>
<td><pre>            return this.abs();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2275" href="#"></a></td>
<td><pre>        else if (this.signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2276" href="#"></a></td>
<td><pre>            return val.abs();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2277" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2278" href="#"></a></td>
<td><pre>        MutableBigInteger a = new MutableBigInteger(this);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2279" href="#"></a></td>
<td><pre>        MutableBigInteger b = new MutableBigInteger(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2280" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2281" href="#"></a></td>
<td><pre>        MutableBigInteger result = a.hybridGCD(b);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2282" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2283" href="#"></a></td>
<td><pre>        return result.toBigInteger(1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2284" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2285" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2286" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2287" href="#"></a></td>
<td><pre>     * Package private method to return bit length for an integer.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2288" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2289" href="#"></a></td>
<td><pre>    static int bitLengthForInt(int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2290" href="#"></a></td>
<td><pre>        return 32 - Integer.numberOfLeadingZeros(n);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2291" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2292" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2293" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2294" href="#"></a></td>
<td><pre>     * Left shift int array a up to len by n bits. Returns the array that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2295" href="#"></a></td>
<td><pre>     * results from the shift since space may have to be reallocated.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2296" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2297" href="#"></a></td>
<td><pre>    private static int[] leftShift(int[] a, int len, int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2298" href="#"></a></td>
<td><pre>        int nInts = n &gt;&gt;&gt; 5;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2299" href="#"></a></td>
<td><pre>        int nBits = n&amp;0x1F;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2300" href="#"></a></td>
<td><pre>        int bitsInHighWord = bitLengthForInt(a[0]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2301" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2302" href="#"></a></td>
<td><pre>        // If shift can be done without recopy, do so</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2303" href="#"></a></td>
<td><pre>        if (n &lt;= (32-bitsInHighWord)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2304" href="#"></a></td>
<td><pre>            primitiveLeftShift(a, len, nBits);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2305" href="#"></a></td>
<td><pre>            return a;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2306" href="#"></a></td>
<td><pre>        } else { // Array must be resized</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2307" href="#"></a></td>
<td><pre>            if (nBits &lt;= (32-bitsInHighWord)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2308" href="#"></a></td>
<td><pre>                int result[] = new int[nInts+len];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2309" href="#"></a></td>
<td><pre>                System.arraycopy(a, 0, result, 0, len);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2310" href="#"></a></td>
<td><pre>                primitiveLeftShift(result, result.length, nBits);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2311" href="#"></a></td>
<td><pre>                return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2312" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2313" href="#"></a></td>
<td><pre>                int result[] = new int[nInts+len+1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2314" href="#"></a></td>
<td><pre>                System.arraycopy(a, 0, result, 0, len);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2315" href="#"></a></td>
<td><pre>                primitiveRightShift(result, result.length, 32 - nBits);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2316" href="#"></a></td>
<td><pre>                return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2317" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2318" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2319" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2320" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2321" href="#"></a></td>
<td><pre>    // shifts a up to len right n bits assumes no leading zeros, 0&lt;n&lt;32</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2322" href="#"></a></td>
<td><pre>    static void primitiveRightShift(int[] a, int len, int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2323" href="#"></a></td>
<td><pre>        int n2 = 32 - n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2324" href="#"></a></td>
<td><pre>        for (int i=len-1, c=a[i]; i &gt; 0; i--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2325" href="#"></a></td>
<td><pre>            int b = c;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2326" href="#"></a></td>
<td><pre>            c = a[i-1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2327" href="#"></a></td>
<td><pre>            a[i] = (c &lt;&lt; n2) | (b &gt;&gt;&gt; n);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2328" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2329" href="#"></a></td>
<td><pre>        a[0] &gt;&gt;&gt;= n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2330" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2331" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2332" href="#"></a></td>
<td><pre>    // shifts a up to len left n bits assumes no leading zeros, 0&lt;=n&lt;32</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2333" href="#"></a></td>
<td><pre>    static void primitiveLeftShift(int[] a, int len, int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2334" href="#"></a></td>
<td><pre>        if (len == 0 || n == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2335" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2336" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2337" href="#"></a></td>
<td><pre>        int n2 = 32 - n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2338" href="#"></a></td>
<td><pre>        for (int i=0, c=a[i], m=i+len-1; i &lt; m; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2339" href="#"></a></td>
<td><pre>            int b = c;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2340" href="#"></a></td>
<td><pre>            c = a[i+1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2341" href="#"></a></td>
<td><pre>            a[i] = (b &lt;&lt; n) | (c &gt;&gt;&gt; n2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2342" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2343" href="#"></a></td>
<td><pre>        a[len-1] &lt;&lt;= n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2344" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2345" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2346" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2347" href="#"></a></td>
<td><pre>     * Calculate bitlength of contents of the first len elements an int array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2348" href="#"></a></td>
<td><pre>     * assuming there are no leading zero ints.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2349" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2350" href="#"></a></td>
<td><pre>    private static int bitLength(int[] val, int len) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2351" href="#"></a></td>
<td><pre>        if (len == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2352" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2353" href="#"></a></td>
<td><pre>        return ((len - 1) &lt;&lt; 5) + bitLengthForInt(val[0]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2354" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2355" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2356" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2357" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is the absolute value of this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2358" href="#"></a></td>
<td><pre>     * BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2359" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2360" href="#"></a></td>
<td><pre>     * @return {@code abs(this)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2361" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2362" href="#"></a></td>
<td><pre>    public BigInteger abs() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2363" href="#"></a></td>
<td><pre>        return (signum &gt;= 0 ? this : this.negate());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2364" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2365" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2366" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2367" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (-this)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2368" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2369" href="#"></a></td>
<td><pre>     * @return {@code -this}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2370" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2371" href="#"></a></td>
<td><pre>    public BigInteger negate() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2372" href="#"></a></td>
<td><pre>        return new BigInteger(this.mag, -this.signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2373" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2374" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2375" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2376" href="#"></a></td>
<td><pre>     * Returns the signum function of this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2377" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2378" href="#"></a></td>
<td><pre>     * @return -1, 0 or 1 as the value of this BigInteger is negative, zero or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2379" href="#"></a></td>
<td><pre>     *         positive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2380" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2381" href="#"></a></td>
<td><pre>    public int signum() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2382" href="#"></a></td>
<td><pre>        return this.signum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2383" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2384" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2385" href="#"></a></td>
<td><pre>    // Modular Arithmetic Operations</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2386" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2387" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2388" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this mod m}).  This method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2389" href="#"></a></td>
<td><pre>     * differs from {@code remainder} in that it always returns a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2390" href="#"></a></td>
<td><pre>     * &lt;i&gt;non-negative&lt;/i&gt; BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2391" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2392" href="#"></a></td>
<td><pre>     * @param  m the modulus.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2393" href="#"></a></td>
<td><pre>     * @return {@code this mod m}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2394" href="#"></a></td>
<td><pre>     * @throws ArithmeticException {@code m} &amp;le; 0</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2395" href="#"></a></td>
<td><pre>     * @see    #remainder</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2396" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2397" href="#"></a></td>
<td><pre>    public BigInteger mod(BigInteger m) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2398" href="#"></a></td>
<td><pre>        if (m.signum &lt;= 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2399" href="#"></a></td>
<td><pre>            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2400" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2401" href="#"></a></td>
<td><pre>        BigInteger result = this.remainder(m);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2402" href="#"></a></td>
<td><pre>        return (result.signum &gt;= 0 ? result : result.add(m));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2403" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2404" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2405" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2406" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2407" href="#"></a></td>
<td><pre>     * &lt;tt&gt;(this&lt;sup&gt;exponent&lt;/sup&gt; mod m)&lt;/tt&gt;.  (Unlike {@code pow}, this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2408" href="#"></a></td>
<td><pre>     * method permits negative exponents.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2409" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2410" href="#"></a></td>
<td><pre>     * @param  exponent the exponent.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2411" href="#"></a></td>
<td><pre>     * @param  m the modulus.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2412" href="#"></a></td>
<td><pre>     * @return &lt;tt&gt;this&lt;sup&gt;exponent&lt;/sup&gt; mod m&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2413" href="#"></a></td>
<td><pre>     * @throws ArithmeticException {@code m} &amp;le; 0 or the exponent is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2414" href="#"></a></td>
<td><pre>     *         negative and this BigInteger is not &lt;i&gt;relatively</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2415" href="#"></a></td>
<td><pre>     *         prime&lt;/i&gt; to {@code m}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2416" href="#"></a></td>
<td><pre>     * @see    #modInverse</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2417" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2418" href="#"></a></td>
<td><pre>    public BigInteger modPow(BigInteger exponent, BigInteger m) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2419" href="#"></a></td>
<td><pre>        if (m.signum &lt;= 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2420" href="#"></a></td>
<td><pre>            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2421" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2422" href="#"></a></td>
<td><pre>        // Trivial cases</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2423" href="#"></a></td>
<td><pre>        if (exponent.signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2424" href="#"></a></td>
<td><pre>            return (m.equals(ONE) ? ZERO : ONE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2425" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2426" href="#"></a></td>
<td><pre>        if (this.equals(ONE))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2427" href="#"></a></td>
<td><pre>            return (m.equals(ONE) ? ZERO : ONE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2428" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2429" href="#"></a></td>
<td><pre>        if (this.equals(ZERO) &amp;&amp; exponent.signum &gt;= 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2430" href="#"></a></td>
<td><pre>            return ZERO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2431" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2432" href="#"></a></td>
<td><pre>        if (this.equals(negConst[1]) &amp;&amp; (!exponent.testBit(0)))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2433" href="#"></a></td>
<td><pre>            return (m.equals(ONE) ? ZERO : ONE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2434" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2435" href="#"></a></td>
<td><pre>        boolean invertResult;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2436" href="#"></a></td>
<td><pre>        if ((invertResult = (exponent.signum &lt; 0)))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2437" href="#"></a></td>
<td><pre>            exponent = exponent.negate();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2438" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2439" href="#"></a></td>
<td><pre>        BigInteger base = (this.signum &lt; 0 || this.compareTo(m) &gt;= 0</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2440" href="#"></a></td>
<td><pre>                           ? this.mod(m) : this);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2441" href="#"></a></td>
<td><pre>        BigInteger result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2442" href="#"></a></td>
<td><pre>        if (m.testBit(0)) { // odd modulus</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2443" href="#"></a></td>
<td><pre>            result = base.oddModPow(exponent, m);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2444" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2445" href="#"></a></td>
<td><pre>            /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2446" href="#"></a></td>
<td><pre>             * Even modulus.  Tear it into an &quot;odd part&quot; (m1) and power of two</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2447" href="#"></a></td>
<td><pre>             * (m2), exponentiate mod m1, manually exponentiate mod m2, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2448" href="#"></a></td>
<td><pre>             * use Chinese Remainder Theorem to combine results.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2449" href="#"></a></td>
<td><pre>             */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2450" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2451" href="#"></a></td>
<td><pre>            // Tear m apart into odd part (m1) and power of 2 (m2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2452" href="#"></a></td>
<td><pre>            int p = m.getLowestSetBit();   // Max pow of 2 that divides m</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2453" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2454" href="#"></a></td>
<td><pre>            BigInteger m1 = m.shiftRight(p);  // m/2**p</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2455" href="#"></a></td>
<td><pre>            BigInteger m2 = ONE.shiftLeft(p); // 2**p</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2456" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2457" href="#"></a></td>
<td><pre>            // Calculate new base from m1</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2458" href="#"></a></td>
<td><pre>            BigInteger base2 = (this.signum &lt; 0 || this.compareTo(m1) &gt;= 0</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2459" href="#"></a></td>
<td><pre>                                ? this.mod(m1) : this);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2460" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2461" href="#"></a></td>
<td><pre>            // Caculate (base ** exponent) mod m1.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2462" href="#"></a></td>
<td><pre>            BigInteger a1 = (m1.equals(ONE) ? ZERO :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2463" href="#"></a></td>
<td><pre>                             base2.oddModPow(exponent, m1));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2464" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2465" href="#"></a></td>
<td><pre>            // Calculate (this ** exponent) mod m2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2466" href="#"></a></td>
<td><pre>            BigInteger a2 = base.modPow2(exponent, p);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2467" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2468" href="#"></a></td>
<td><pre>            // Combine results using Chinese Remainder Theorem</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2469" href="#"></a></td>
<td><pre>            BigInteger y1 = m2.modInverse(m1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2470" href="#"></a></td>
<td><pre>            BigInteger y2 = m1.modInverse(m2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2471" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2472" href="#"></a></td>
<td><pre>            if (m.mag.length &lt; MAX_MAG_LENGTH / 2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2473" href="#"></a></td>
<td><pre>                result = a1.multiply(m2).multiply(y1).add(a2.multiply(m1).multiply(y2)).mod(m);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2474" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2475" href="#"></a></td>
<td><pre>                MutableBigInteger t1 = new MutableBigInteger();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2476" href="#"></a></td>
<td><pre>                new MutableBigInteger(a1.multiply(m2)).multiply(new MutableBigInteger(y1), t1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2477" href="#"></a></td>
<td><pre>                MutableBigInteger t2 = new MutableBigInteger();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2478" href="#"></a></td>
<td><pre>                new MutableBigInteger(a2.multiply(m1)).multiply(new MutableBigInteger(y2), t2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2479" href="#"></a></td>
<td><pre>                t1.add(t2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2480" href="#"></a></td>
<td><pre>                MutableBigInteger q = new MutableBigInteger();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2481" href="#"></a></td>
<td><pre>                result = t1.divide(new MutableBigInteger(m), q).toBigInteger();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2482" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2483" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2484" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2485" href="#"></a></td>
<td><pre>        return (invertResult ? result.modInverse(m) : result);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2486" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2487" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2488" href="#"></a></td>
<td><pre>    static int[] bnExpModThreshTable = {7, 25, 81, 241, 673, 1793,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2489" href="#"></a></td>
<td><pre>                                                Integer.MAX_VALUE}; // Sentinel</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2490" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2491" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2492" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is x to the power of y mod z.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2493" href="#"></a></td>
<td><pre>     * Assumes: z is odd &amp;&amp; x &lt; z.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2494" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2495" href="#"></a></td>
<td><pre>    private BigInteger oddModPow(BigInteger y, BigInteger z) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2496" href="#"></a></td>
<td><pre>    /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2497" href="#"></a></td>
<td><pre>     * The algorithm is adapted from Colin Plumb's C library.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2498" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2499" href="#"></a></td>
<td><pre>     * The window algorithm:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2500" href="#"></a></td>
<td><pre>     * The idea is to keep a running product of b1 = n^(high-order bits of exp)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2501" href="#"></a></td>
<td><pre>     * and then keep appending exponent bits to it.  The following patterns</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2502" href="#"></a></td>
<td><pre>     * apply to a 3-bit window (k = 3):</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2503" href="#"></a></td>
<td><pre>     * To append   0: square</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2504" href="#"></a></td>
<td><pre>     * To append   1: square, multiply by n^1</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2505" href="#"></a></td>
<td><pre>     * To append  10: square, multiply by n^1, square</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2506" href="#"></a></td>
<td><pre>     * To append  11: square, square, multiply by n^3</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2507" href="#"></a></td>
<td><pre>     * To append 100: square, multiply by n^1, square, square</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2508" href="#"></a></td>
<td><pre>     * To append 101: square, square, square, multiply by n^5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2509" href="#"></a></td>
<td><pre>     * To append 110: square, square, multiply by n^3, square</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2510" href="#"></a></td>
<td><pre>     * To append 111: square, square, square, multiply by n^7</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2511" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2512" href="#"></a></td>
<td><pre>     * Since each pattern involves only one multiply, the longer the pattern</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2513" href="#"></a></td>
<td><pre>     * the better, except that a 0 (no multiplies) can be appended directly.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2514" href="#"></a></td>
<td><pre>     * We precompute a table of odd powers of n, up to 2^k, and can then</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2515" href="#"></a></td>
<td><pre>     * multiply k bits of exponent at a time.  Actually, assuming random</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2516" href="#"></a></td>
<td><pre>     * exponents, there is on average one zero bit between needs to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2517" href="#"></a></td>
<td><pre>     * multiply (1/2 of the time there's none, 1/4 of the time there's 1,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2518" href="#"></a></td>
<td><pre>     * 1/8 of the time, there's 2, 1/32 of the time, there's 3, etc.), so</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2519" href="#"></a></td>
<td><pre>     * you have to do one multiply per k+1 bits of exponent.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2520" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2521" href="#"></a></td>
<td><pre>     * The loop walks down the exponent, squaring the result buffer as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2522" href="#"></a></td>
<td><pre>     * it goes.  There is a wbits+1 bit lookahead buffer, buf, that is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2523" href="#"></a></td>
<td><pre>     * filled with the upcoming exponent bits.  (What is read after the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2524" href="#"></a></td>
<td><pre>     * end of the exponent is unimportant, but it is filled with zero here.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2525" href="#"></a></td>
<td><pre>     * When the most-significant bit of this buffer becomes set, i.e.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2526" href="#"></a></td>
<td><pre>     * (buf &amp; tblmask) != 0, we have to decide what pattern to multiply</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2527" href="#"></a></td>
<td><pre>     * by, and when to do it.  We decide, remember to do it in future</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2528" href="#"></a></td>
<td><pre>     * after a suitable number of squarings have passed (e.g. a pattern</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2529" href="#"></a></td>
<td><pre>     * of &quot;100&quot; in the buffer requires that we multiply by n^1 immediately;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2530" href="#"></a></td>
<td><pre>     * a pattern of &quot;110&quot; calls for multiplying by n^3 after one more</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2531" href="#"></a></td>
<td><pre>     * squaring), clear the buffer, and continue.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2532" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2533" href="#"></a></td>
<td><pre>     * When we start, there is one more optimization: the result buffer</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2534" href="#"></a></td>
<td><pre>     * is implcitly one, so squaring it or multiplying by it can be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2535" href="#"></a></td>
<td><pre>     * optimized away.  Further, if we start with a pattern like &quot;100&quot;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2536" href="#"></a></td>
<td><pre>     * in the lookahead window, rather than placing n into the buffer</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2537" href="#"></a></td>
<td><pre>     * and then starting to square it, we have already computed n^2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2538" href="#"></a></td>
<td><pre>     * to compute the odd-powers table, so we can place that into</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2539" href="#"></a></td>
<td><pre>     * the buffer and save a squaring.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2540" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2541" href="#"></a></td>
<td><pre>     * This means that if you have a k-bit window, to compute n^z,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2542" href="#"></a></td>
<td><pre>     * where z is the high k bits of the exponent, 1/2 of the time</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2543" href="#"></a></td>
<td><pre>     * it requires no squarings.  1/4 of the time, it requires 1</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2544" href="#"></a></td>
<td><pre>     * squaring, ... 1/2^(k-1) of the time, it reqires k-2 squarings.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2545" href="#"></a></td>
<td><pre>     * And the remaining 1/2^(k-1) of the time, the top k bits are a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2546" href="#"></a></td>
<td><pre>     * 1 followed by k-1 0 bits, so it again only requires k-2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2547" href="#"></a></td>
<td><pre>     * squarings, not k-1.  The average of these is 1.  Add that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2548" href="#"></a></td>
<td><pre>     * to the one squaring we have to do to compute the table,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2549" href="#"></a></td>
<td><pre>     * and you'll see that a k-bit window saves k-2 squarings</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2550" href="#"></a></td>
<td><pre>     * as well as reducing the multiplies.  (It actually doesn't</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2551" href="#"></a></td>
<td><pre>     * hurt in the case k = 1, either.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2552" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2553" href="#"></a></td>
<td><pre>        // Special case for exponent of one</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2554" href="#"></a></td>
<td><pre>        if (y.equals(ONE))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2555" href="#"></a></td>
<td><pre>            return this;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2556" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2557" href="#"></a></td>
<td><pre>        // Special case for base of zero</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2558" href="#"></a></td>
<td><pre>        if (signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2559" href="#"></a></td>
<td><pre>            return ZERO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2560" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2561" href="#"></a></td>
<td><pre>        int[] base = mag.clone();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2562" href="#"></a></td>
<td><pre>        int[] exp = y.mag;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2563" href="#"></a></td>
<td><pre>        int[] mod = z.mag;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2564" href="#"></a></td>
<td><pre>        int modLen = mod.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2565" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2566" href="#"></a></td>
<td><pre>        // Select an appropriate window size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2567" href="#"></a></td>
<td><pre>        int wbits = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2568" href="#"></a></td>
<td><pre>        int ebits = bitLength(exp, exp.length);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2569" href="#"></a></td>
<td><pre>        // if exponent is 65537 (0x10001), use minimum window size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2570" href="#"></a></td>
<td><pre>        if ((ebits != 17) || (exp[0] != 65537)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2571" href="#"></a></td>
<td><pre>            while (ebits &gt; bnExpModThreshTable[wbits]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2572" href="#"></a></td>
<td><pre>                wbits++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2573" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2574" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2575" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2576" href="#"></a></td>
<td><pre>        // Calculate appropriate table size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2577" href="#"></a></td>
<td><pre>        int tblmask = 1 &lt;&lt; wbits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2578" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2579" href="#"></a></td>
<td><pre>        // Allocate table for precomputed odd powers of base in Montgomery form</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2580" href="#"></a></td>
<td><pre>        int[][] table = new int[tblmask][];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2581" href="#"></a></td>
<td><pre>        for (int i=0; i &lt; tblmask; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2582" href="#"></a></td>
<td><pre>            table[i] = new int[modLen];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2583" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2584" href="#"></a></td>
<td><pre>        // Compute the modular inverse</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2585" href="#"></a></td>
<td><pre>        int inv = -MutableBigInteger.inverseMod32(mod[modLen-1]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2586" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2587" href="#"></a></td>
<td><pre>        // Convert base to Montgomery form</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2588" href="#"></a></td>
<td><pre>        int[] a = leftShift(base, base.length, modLen &lt;&lt; 5);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2589" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2590" href="#"></a></td>
<td><pre>        MutableBigInteger q = new MutableBigInteger(),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2591" href="#"></a></td>
<td><pre>                          a2 = new MutableBigInteger(a),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2592" href="#"></a></td>
<td><pre>                          b2 = new MutableBigInteger(mod);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2593" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2594" href="#"></a></td>
<td><pre>        MutableBigInteger r= a2.divide(b2, q);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2595" href="#"></a></td>
<td><pre>        table[0] = r.toIntArray();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2596" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2597" href="#"></a></td>
<td><pre>        // Pad table[0] with leading zeros so its length is at least modLen</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2598" href="#"></a></td>
<td><pre>        if (table[0].length &lt; modLen) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2599" href="#"></a></td>
<td><pre>           int offset = modLen - table[0].length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2600" href="#"></a></td>
<td><pre>           int[] t2 = new int[modLen];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2601" href="#"></a></td>
<td><pre>           for (int i=0; i &lt; table[0].length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2602" href="#"></a></td>
<td><pre>               t2[i+offset] = table[0][i];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2603" href="#"></a></td>
<td><pre>           table[0] = t2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2604" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2605" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2606" href="#"></a></td>
<td><pre>        // Set b to the square of the base</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2607" href="#"></a></td>
<td><pre>        int[] b = squareToLen(table[0], modLen, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2608" href="#"></a></td>
<td><pre>        b = montReduce(b, mod, modLen, inv);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2609" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2610" href="#"></a></td>
<td><pre>        // Set t to high half of b</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2611" href="#"></a></td>
<td><pre>        int[] t = Arrays.copyOf(b, modLen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2612" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2613" href="#"></a></td>
<td><pre>        // Fill in the table with odd powers of the base</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2614" href="#"></a></td>
<td><pre>        for (int i=1; i &lt; tblmask; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2615" href="#"></a></td>
<td><pre>            int[] prod = multiplyToLen(t, modLen, table[i-1], modLen, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2616" href="#"></a></td>
<td><pre>            table[i] = montReduce(prod, mod, modLen, inv);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2617" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2618" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2619" href="#"></a></td>
<td><pre>        // Pre load the window that slides over the exponent</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2620" href="#"></a></td>
<td><pre>        int bitpos = 1 &lt;&lt; ((ebits-1) &amp; (32-1));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2621" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2622" href="#"></a></td>
<td><pre>        int buf = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2623" href="#"></a></td>
<td><pre>        int elen = exp.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2624" href="#"></a></td>
<td><pre>        int eIndex = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2625" href="#"></a></td>
<td><pre>        for (int i = 0; i &lt;= wbits; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2626" href="#"></a></td>
<td><pre>            buf = (buf &lt;&lt; 1) | (((exp[eIndex] &amp; bitpos) != 0)?1:0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2627" href="#"></a></td>
<td><pre>            bitpos &gt;&gt;&gt;= 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2628" href="#"></a></td>
<td><pre>            if (bitpos == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2629" href="#"></a></td>
<td><pre>                eIndex++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2630" href="#"></a></td>
<td><pre>                bitpos = 1 &lt;&lt; (32-1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2631" href="#"></a></td>
<td><pre>                elen--;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2632" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2633" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2634" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2635" href="#"></a></td>
<td><pre>        int multpos = ebits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2636" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2637" href="#"></a></td>
<td><pre>        // The first iteration, which is hoisted out of the main loop</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2638" href="#"></a></td>
<td><pre>        ebits--;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2639" href="#"></a></td>
<td><pre>        boolean isone = true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2640" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2641" href="#"></a></td>
<td><pre>        multpos = ebits - wbits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2642" href="#"></a></td>
<td><pre>        while ((buf &amp; 1) == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2643" href="#"></a></td>
<td><pre>            buf &gt;&gt;&gt;= 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2644" href="#"></a></td>
<td><pre>            multpos++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2645" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2646" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2647" href="#"></a></td>
<td><pre>        int[] mult = table[buf &gt;&gt;&gt; 1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2648" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2649" href="#"></a></td>
<td><pre>        buf = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2650" href="#"></a></td>
<td><pre>        if (multpos == ebits)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2651" href="#"></a></td>
<td><pre>            isone = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2652" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2653" href="#"></a></td>
<td><pre>        // The main loop</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2654" href="#"></a></td>
<td><pre>        while (true) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2655" href="#"></a></td>
<td><pre>            ebits--;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2656" href="#"></a></td>
<td><pre>            // Advance the window</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2657" href="#"></a></td>
<td><pre>            buf &lt;&lt;= 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2658" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2659" href="#"></a></td>
<td><pre>            if (elen != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2660" href="#"></a></td>
<td><pre>                buf |= ((exp[eIndex] &amp; bitpos) != 0) ? 1 : 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2661" href="#"></a></td>
<td><pre>                bitpos &gt;&gt;&gt;= 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2662" href="#"></a></td>
<td><pre>                if (bitpos == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2663" href="#"></a></td>
<td><pre>                    eIndex++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2664" href="#"></a></td>
<td><pre>                    bitpos = 1 &lt;&lt; (32-1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2665" href="#"></a></td>
<td><pre>                    elen--;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2666" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2667" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2668" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2669" href="#"></a></td>
<td><pre>            // Examine the window for pending multiplies</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2670" href="#"></a></td>
<td><pre>            if ((buf &amp; tblmask) != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2671" href="#"></a></td>
<td><pre>                multpos = ebits - wbits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2672" href="#"></a></td>
<td><pre>                while ((buf &amp; 1) == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2673" href="#"></a></td>
<td><pre>                    buf &gt;&gt;&gt;= 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2674" href="#"></a></td>
<td><pre>                    multpos++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2675" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2676" href="#"></a></td>
<td><pre>                mult = table[buf &gt;&gt;&gt; 1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2677" href="#"></a></td>
<td><pre>                buf = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2678" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2679" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2680" href="#"></a></td>
<td><pre>            // Perform multiply</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2681" href="#"></a></td>
<td><pre>            if (ebits == multpos) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2682" href="#"></a></td>
<td><pre>                if (isone) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2683" href="#"></a></td>
<td><pre>                    b = mult.clone();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2684" href="#"></a></td>
<td><pre>                    isone = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2685" href="#"></a></td>
<td><pre>                } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2686" href="#"></a></td>
<td><pre>                    t = b;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2687" href="#"></a></td>
<td><pre>                    a = multiplyToLen(t, modLen, mult, modLen, a);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2688" href="#"></a></td>
<td><pre>                    a = montReduce(a, mod, modLen, inv);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2689" href="#"></a></td>
<td><pre>                    t = a; a = b; b = t;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2690" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2691" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2692" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2693" href="#"></a></td>
<td><pre>            // Check if done</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2694" href="#"></a></td>
<td><pre>            if (ebits == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2695" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2696" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2697" href="#"></a></td>
<td><pre>            // Square the input</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2698" href="#"></a></td>
<td><pre>            if (!isone) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2699" href="#"></a></td>
<td><pre>                t = b;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2700" href="#"></a></td>
<td><pre>                a = squareToLen(t, modLen, a);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2701" href="#"></a></td>
<td><pre>                a = montReduce(a, mod, modLen, inv);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2702" href="#"></a></td>
<td><pre>                t = a; a = b; b = t;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2703" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2704" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2705" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2706" href="#"></a></td>
<td><pre>        // Convert result out of Montgomery form and return</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2707" href="#"></a></td>
<td><pre>        int[] t2 = new int[2*modLen];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2708" href="#"></a></td>
<td><pre>        System.arraycopy(b, 0, t2, modLen, modLen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2709" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2710" href="#"></a></td>
<td><pre>        b = montReduce(t2, mod, modLen, inv);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2711" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2712" href="#"></a></td>
<td><pre>        t2 = Arrays.copyOf(b, modLen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2713" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2714" href="#"></a></td>
<td><pre>        return new BigInteger(1, t2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2715" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2716" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2717" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2718" href="#"></a></td>
<td><pre>     * Montgomery reduce n, modulo mod.  This reduces modulo mod and divides</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2719" href="#"></a></td>
<td><pre>     * by 2^(32*mlen). Adapted from Colin Plumb's C library.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2720" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2721" href="#"></a></td>
<td><pre>    private static int[] montReduce(int[] n, int[] mod, int mlen, int inv) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2722" href="#"></a></td>
<td><pre>        int c=0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2723" href="#"></a></td>
<td><pre>        int len = mlen;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2724" href="#"></a></td>
<td><pre>        int offset=0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2725" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2726" href="#"></a></td>
<td><pre>        do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2727" href="#"></a></td>
<td><pre>            int nEnd = n[n.length-1-offset];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2728" href="#"></a></td>
<td><pre>            int carry = mulAdd(n, mod, offset, mlen, inv * nEnd);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2729" href="#"></a></td>
<td><pre>            c += addOne(n, offset, mlen, carry);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2730" href="#"></a></td>
<td><pre>            offset++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2731" href="#"></a></td>
<td><pre>        } while (--len &gt; 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2732" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2733" href="#"></a></td>
<td><pre>        while (c &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2734" href="#"></a></td>
<td><pre>            c += subN(n, mod, mlen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2735" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2736" href="#"></a></td>
<td><pre>        while (intArrayCmpToLen(n, mod, mlen) &gt;= 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2737" href="#"></a></td>
<td><pre>            subN(n, mod, mlen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2738" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2739" href="#"></a></td>
<td><pre>        return n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2740" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2741" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2742" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2743" href="#"></a></td>
<td><pre>    /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2744" href="#"></a></td>
<td><pre>     * Returns -1, 0 or +1 as big-endian unsigned int array arg1 is less than,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2745" href="#"></a></td>
<td><pre>     * equal to, or greater than arg2 up to length len.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2746" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2747" href="#"></a></td>
<td><pre>    private static int intArrayCmpToLen(int[] arg1, int[] arg2, int len) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2748" href="#"></a></td>
<td><pre>        for (int i=0; i &lt; len; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2749" href="#"></a></td>
<td><pre>            long b1 = arg1[i] &amp; LONG_MASK;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2750" href="#"></a></td>
<td><pre>            long b2 = arg2[i] &amp; LONG_MASK;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2751" href="#"></a></td>
<td><pre>            if (b1 &lt; b2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2752" href="#"></a></td>
<td><pre>                return -1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2753" href="#"></a></td>
<td><pre>            if (b1 &gt; b2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2754" href="#"></a></td>
<td><pre>                return 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2755" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2756" href="#"></a></td>
<td><pre>        return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2757" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2758" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2759" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2760" href="#"></a></td>
<td><pre>     * Subtracts two numbers of same length, returning borrow.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2761" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2762" href="#"></a></td>
<td><pre>    private static int subN(int[] a, int[] b, int len) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2763" href="#"></a></td>
<td><pre>        long sum = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2764" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2765" href="#"></a></td>
<td><pre>        while (--len &gt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2766" href="#"></a></td>
<td><pre>            sum = (a[len] &amp; LONG_MASK) -</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2767" href="#"></a></td>
<td><pre>                 (b[len] &amp; LONG_MASK) + (sum &gt;&gt; 32);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2768" href="#"></a></td>
<td><pre>            a[len] = (int)sum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2769" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2770" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2771" href="#"></a></td>
<td><pre>        return (int)(sum &gt;&gt; 32);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2772" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2773" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2774" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2775" href="#"></a></td>
<td><pre>     * Multiply an array by one word k and add to result, return the carry</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2776" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2777" href="#"></a></td>
<td><pre>    static int mulAdd(int[] out, int[] in, int offset, int len, int k) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2778" href="#"></a></td>
<td><pre>        long kLong = k &amp; LONG_MASK;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2779" href="#"></a></td>
<td><pre>        long carry = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2780" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2781" href="#"></a></td>
<td><pre>        offset = out.length-offset - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2782" href="#"></a></td>
<td><pre>        for (int j=len-1; j &gt;= 0; j--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2783" href="#"></a></td>
<td><pre>            long product = (in[j] &amp; LONG_MASK) * kLong +</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2784" href="#"></a></td>
<td><pre>                           (out[offset] &amp; LONG_MASK) + carry;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2785" href="#"></a></td>
<td><pre>            out[offset--] = (int)product;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2786" href="#"></a></td>
<td><pre>            carry = product &gt;&gt;&gt; 32;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2787" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2788" href="#"></a></td>
<td><pre>        return (int)carry;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2789" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2790" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2791" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2792" href="#"></a></td>
<td><pre>     * Add one word to the number a mlen words into a. Return the resulting</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2793" href="#"></a></td>
<td><pre>     * carry.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2794" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2795" href="#"></a></td>
<td><pre>    static int addOne(int[] a, int offset, int mlen, int carry) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2796" href="#"></a></td>
<td><pre>        offset = a.length-1-mlen-offset;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2797" href="#"></a></td>
<td><pre>        long t = (a[offset] &amp; LONG_MASK) + (carry &amp; LONG_MASK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2798" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2799" href="#"></a></td>
<td><pre>        a[offset] = (int)t;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2800" href="#"></a></td>
<td><pre>        if ((t &gt;&gt;&gt; 32) == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2801" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2802" href="#"></a></td>
<td><pre>        while (--mlen &gt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2803" href="#"></a></td>
<td><pre>            if (--offset &lt; 0) { // Carry out of number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2804" href="#"></a></td>
<td><pre>                return 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2805" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2806" href="#"></a></td>
<td><pre>                a[offset]++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2807" href="#"></a></td>
<td><pre>                if (a[offset] != 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2808" href="#"></a></td>
<td><pre>                    return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2809" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2810" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2811" href="#"></a></td>
<td><pre>        return 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2812" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2813" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2814" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2815" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is (this ** exponent) mod (2**p)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2816" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2817" href="#"></a></td>
<td><pre>    private BigInteger modPow2(BigInteger exponent, int p) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2818" href="#"></a></td>
<td><pre>        /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2819" href="#"></a></td>
<td><pre>         * Perform exponentiation using repeated squaring trick, chopping off</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2820" href="#"></a></td>
<td><pre>         * high order bits as indicated by modulus.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2821" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2822" href="#"></a></td>
<td><pre>        BigInteger result = ONE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2823" href="#"></a></td>
<td><pre>        BigInteger baseToPow2 = this.mod2(p);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2824" href="#"></a></td>
<td><pre>        int expOffset = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2825" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2826" href="#"></a></td>
<td><pre>        int limit = exponent.bitLength();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2827" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2828" href="#"></a></td>
<td><pre>        if (this.testBit(0))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2829" href="#"></a></td>
<td><pre>           limit = (p-1) &lt; limit ? (p-1) : limit;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2830" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2831" href="#"></a></td>
<td><pre>        while (expOffset &lt; limit) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2832" href="#"></a></td>
<td><pre>            if (exponent.testBit(expOffset))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2833" href="#"></a></td>
<td><pre>                result = result.multiply(baseToPow2).mod2(p);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2834" href="#"></a></td>
<td><pre>            expOffset++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2835" href="#"></a></td>
<td><pre>            if (expOffset &lt; limit)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2836" href="#"></a></td>
<td><pre>                baseToPow2 = baseToPow2.square().mod2(p);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2837" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2838" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2839" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2840" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2841" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2842" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2843" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is this mod(2**p).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2844" href="#"></a></td>
<td><pre>     * Assumes that this {@code BigInteger &gt;= 0} and {@code p &gt; 0}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2845" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2846" href="#"></a></td>
<td><pre>    private BigInteger mod2(int p) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2847" href="#"></a></td>
<td><pre>        if (bitLength() &lt;= p)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2848" href="#"></a></td>
<td><pre>            return this;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2849" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2850" href="#"></a></td>
<td><pre>        // Copy remaining ints of mag</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2851" href="#"></a></td>
<td><pre>        int numInts = (p + 31) &gt;&gt;&gt; 5;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2852" href="#"></a></td>
<td><pre>        int[] mag = new int[numInts];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2853" href="#"></a></td>
<td><pre>        System.arraycopy(this.mag, (this.mag.length - numInts), mag, 0, numInts);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2854" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2855" href="#"></a></td>
<td><pre>        // Mask out any excess bits</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2856" href="#"></a></td>
<td><pre>        int excessBits = (numInts &lt;&lt; 5) - p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2857" href="#"></a></td>
<td><pre>        mag[0] &amp;= (1L &lt;&lt; (32-excessBits)) - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2858" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2859" href="#"></a></td>
<td><pre>        return (mag[0] == 0 ? new BigInteger(1, mag) : new BigInteger(mag, 1));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2860" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2861" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2862" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2863" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this}&lt;sup&gt;-1&lt;/sup&gt; {@code mod m)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2864" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2865" href="#"></a></td>
<td><pre>     * @param  m the modulus.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2866" href="#"></a></td>
<td><pre>     * @return {@code this}&lt;sup&gt;-1&lt;/sup&gt; {@code mod m}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2867" href="#"></a></td>
<td><pre>     * @throws ArithmeticException {@code  m} &amp;le; 0, or this BigInteger</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2868" href="#"></a></td>
<td><pre>     *         has no multiplicative inverse mod m (that is, this BigInteger</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2869" href="#"></a></td>
<td><pre>     *         is not &lt;i&gt;relatively prime&lt;/i&gt; to m).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2870" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2871" href="#"></a></td>
<td><pre>    public BigInteger modInverse(BigInteger m) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2872" href="#"></a></td>
<td><pre>        if (m.signum != 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2873" href="#"></a></td>
<td><pre>            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2874" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2875" href="#"></a></td>
<td><pre>        if (m.equals(ONE))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2876" href="#"></a></td>
<td><pre>            return ZERO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2877" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2878" href="#"></a></td>
<td><pre>        // Calculate (this mod m)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2879" href="#"></a></td>
<td><pre>        BigInteger modVal = this;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2880" href="#"></a></td>
<td><pre>        if (signum &lt; 0 || (this.compareMagnitude(m) &gt;= 0))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2881" href="#"></a></td>
<td><pre>            modVal = this.mod(m);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2882" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2883" href="#"></a></td>
<td><pre>        if (modVal.equals(ONE))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2884" href="#"></a></td>
<td><pre>            return ONE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2885" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2886" href="#"></a></td>
<td><pre>        MutableBigInteger a = new MutableBigInteger(modVal);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2887" href="#"></a></td>
<td><pre>        MutableBigInteger b = new MutableBigInteger(m);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2888" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2889" href="#"></a></td>
<td><pre>        MutableBigInteger result = a.mutableModInverse(b);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2890" href="#"></a></td>
<td><pre>        return result.toBigInteger(1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2891" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2892" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2893" href="#"></a></td>
<td><pre>    // Shift Operations</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2894" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2895" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2896" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this &lt;&lt; n)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2897" href="#"></a></td>
<td><pre>     * The shift distance, {@code n}, may be negative, in which case</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2898" href="#"></a></td>
<td><pre>     * this method performs a right shift.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2899" href="#"></a></td>
<td><pre>     * (Computes &lt;tt&gt;floor(this * 2&lt;sup&gt;n&lt;/sup&gt;)&lt;/tt&gt;.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2900" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2901" href="#"></a></td>
<td><pre>     * @param  n shift distance, in bits.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2902" href="#"></a></td>
<td><pre>     * @return {@code this &lt;&lt; n}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2903" href="#"></a></td>
<td><pre>     * @see #shiftRight</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2904" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2905" href="#"></a></td>
<td><pre>    public BigInteger shiftLeft(int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2906" href="#"></a></td>
<td><pre>        if (signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2907" href="#"></a></td>
<td><pre>            return ZERO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2908" href="#"></a></td>
<td><pre>        if (n &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2909" href="#"></a></td>
<td><pre>            return new BigInteger(shiftLeft(mag, n), signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2910" href="#"></a></td>
<td><pre>        } else if (n == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2911" href="#"></a></td>
<td><pre>            return this;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2912" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2913" href="#"></a></td>
<td><pre>            // Possible int overflow in (-n) is not a trouble,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2914" href="#"></a></td>
<td><pre>            // because shiftRightImpl considers its argument unsigned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2915" href="#"></a></td>
<td><pre>            return shiftRightImpl(-n);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2916" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2917" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2918" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2919" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2920" href="#"></a></td>
<td><pre>     * Returns a magnitude array whose value is {@code (mag &lt;&lt; n)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2921" href="#"></a></td>
<td><pre>     * The shift distance, {@code n}, is considered unnsigned.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2922" href="#"></a></td>
<td><pre>     * (Computes &lt;tt&gt;this * 2&lt;sup&gt;n&lt;/sup&gt;&lt;/tt&gt;.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2923" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2924" href="#"></a></td>
<td><pre>     * @param mag magnitude, the most-significant int ({@code mag[0]}) must be non-zero.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2925" href="#"></a></td>
<td><pre>     * @param  n unsigned shift distance, in bits.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2926" href="#"></a></td>
<td><pre>     * @return {@code mag &lt;&lt; n}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2927" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2928" href="#"></a></td>
<td><pre>    private static int[] shiftLeft(int[] mag, int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2929" href="#"></a></td>
<td><pre>        int nInts = n &gt;&gt;&gt; 5;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2930" href="#"></a></td>
<td><pre>        int nBits = n &amp; 0x1f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2931" href="#"></a></td>
<td><pre>        int magLen = mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2932" href="#"></a></td>
<td><pre>        int newMag[] = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2933" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2934" href="#"></a></td>
<td><pre>        if (nBits == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2935" href="#"></a></td>
<td><pre>            newMag = new int[magLen + nInts];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2936" href="#"></a></td>
<td><pre>            System.arraycopy(mag, 0, newMag, 0, magLen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2937" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2938" href="#"></a></td>
<td><pre>            int i = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2939" href="#"></a></td>
<td><pre>            int nBits2 = 32 - nBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2940" href="#"></a></td>
<td><pre>            int highBits = mag[0] &gt;&gt;&gt; nBits2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2941" href="#"></a></td>
<td><pre>            if (highBits != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2942" href="#"></a></td>
<td><pre>                newMag = new int[magLen + nInts + 1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2943" href="#"></a></td>
<td><pre>                newMag[i++] = highBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2944" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2945" href="#"></a></td>
<td><pre>                newMag = new int[magLen + nInts];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2946" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2947" href="#"></a></td>
<td><pre>            int j=0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2948" href="#"></a></td>
<td><pre>            while (j &lt; magLen-1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2949" href="#"></a></td>
<td><pre>                newMag[i++] = mag[j++] &lt;&lt; nBits | mag[j] &gt;&gt;&gt; nBits2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2950" href="#"></a></td>
<td><pre>            newMag[i] = mag[j] &lt;&lt; nBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2951" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2952" href="#"></a></td>
<td><pre>        return newMag;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2953" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2954" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2955" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2956" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this &gt;&gt; n)}.  Sign</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2957" href="#"></a></td>
<td><pre>     * extension is performed.  The shift distance, {@code n}, may be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2958" href="#"></a></td>
<td><pre>     * negative, in which case this method performs a left shift.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2959" href="#"></a></td>
<td><pre>     * (Computes &lt;tt&gt;floor(this / 2&lt;sup&gt;n&lt;/sup&gt;)&lt;/tt&gt;.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2960" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2961" href="#"></a></td>
<td><pre>     * @param  n shift distance, in bits.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2962" href="#"></a></td>
<td><pre>     * @return {@code this &gt;&gt; n}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2963" href="#"></a></td>
<td><pre>     * @see #shiftLeft</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2964" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2965" href="#"></a></td>
<td><pre>    public BigInteger shiftRight(int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2966" href="#"></a></td>
<td><pre>        if (signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2967" href="#"></a></td>
<td><pre>            return ZERO;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2968" href="#"></a></td>
<td><pre>        if (n &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2969" href="#"></a></td>
<td><pre>            return shiftRightImpl(n);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2970" href="#"></a></td>
<td><pre>        } else if (n == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2971" href="#"></a></td>
<td><pre>            return this;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2972" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2973" href="#"></a></td>
<td><pre>            // Possible int overflow in {@code -n} is not a trouble,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2974" href="#"></a></td>
<td><pre>            // because shiftLeft considers its argument unsigned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2975" href="#"></a></td>
<td><pre>            return new BigInteger(shiftLeft(mag, -n), signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2976" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2977" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2978" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2979" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2980" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this &gt;&gt; n)}. The shift</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2981" href="#"></a></td>
<td><pre>     * distance, {@code n}, is considered unsigned.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2982" href="#"></a></td>
<td><pre>     * (Computes &lt;tt&gt;floor(this * 2&lt;sup&gt;-n&lt;/sup&gt;)&lt;/tt&gt;.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2983" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2984" href="#"></a></td>
<td><pre>     * @param  n unsigned shift distance, in bits.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2985" href="#"></a></td>
<td><pre>     * @return {@code this &gt;&gt; n}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2986" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2987" href="#"></a></td>
<td><pre>    private BigInteger shiftRightImpl(int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2988" href="#"></a></td>
<td><pre>        int nInts = n &gt;&gt;&gt; 5;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2989" href="#"></a></td>
<td><pre>        int nBits = n &amp; 0x1f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2990" href="#"></a></td>
<td><pre>        int magLen = mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2991" href="#"></a></td>
<td><pre>        int newMag[] = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2992" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2993" href="#"></a></td>
<td><pre>        // Special case: entire contents shifted off the end</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2994" href="#"></a></td>
<td><pre>        if (nInts &gt;= magLen)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2995" href="#"></a></td>
<td><pre>            return (signum &gt;= 0 ? ZERO : negConst[1]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2996" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2997" href="#"></a></td>
<td><pre>        if (nBits == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2998" href="#"></a></td>
<td><pre>            int newMagLen = magLen - nInts;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2999" href="#"></a></td>
<td><pre>            newMag = Arrays.copyOf(mag, newMagLen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3000" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3001" href="#"></a></td>
<td><pre>            int i = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3002" href="#"></a></td>
<td><pre>            int highBits = mag[0] &gt;&gt;&gt; nBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3003" href="#"></a></td>
<td><pre>            if (highBits != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3004" href="#"></a></td>
<td><pre>                newMag = new int[magLen - nInts];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3005" href="#"></a></td>
<td><pre>                newMag[i++] = highBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3006" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3007" href="#"></a></td>
<td><pre>                newMag = new int[magLen - nInts -1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3008" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3009" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3010" href="#"></a></td>
<td><pre>            int nBits2 = 32 - nBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3011" href="#"></a></td>
<td><pre>            int j=0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3012" href="#"></a></td>
<td><pre>            while (j &lt; magLen - nInts - 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3013" href="#"></a></td>
<td><pre>                newMag[i++] = (mag[j++] &lt;&lt; nBits2) | (mag[j] &gt;&gt;&gt; nBits);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3014" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3015" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3016" href="#"></a></td>
<td><pre>        if (signum &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3017" href="#"></a></td>
<td><pre>            // Find out whether any one-bits were shifted off the end.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3018" href="#"></a></td>
<td><pre>            boolean onesLost = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3019" href="#"></a></td>
<td><pre>            for (int i=magLen-1, j=magLen-nInts; i &gt;= j &amp;&amp; !onesLost; i--)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3020" href="#"></a></td>
<td><pre>                onesLost = (mag[i] != 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3021" href="#"></a></td>
<td><pre>            if (!onesLost &amp;&amp; nBits != 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3022" href="#"></a></td>
<td><pre>                onesLost = (mag[magLen - nInts - 1] &lt;&lt; (32 - nBits) != 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3023" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3024" href="#"></a></td>
<td><pre>            if (onesLost)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3025" href="#"></a></td>
<td><pre>                newMag = javaIncrement(newMag);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3026" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3027" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3028" href="#"></a></td>
<td><pre>        return new BigInteger(newMag, signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3029" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3030" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3031" href="#"></a></td>
<td><pre>    int[] javaIncrement(int[] val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3032" href="#"></a></td>
<td><pre>        int lastSum = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3033" href="#"></a></td>
<td><pre>        for (int i=val.length-1;  i &gt;= 0 &amp;&amp; lastSum == 0; i--)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3034" href="#"></a></td>
<td><pre>            lastSum = (val[i] += 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3035" href="#"></a></td>
<td><pre>        if (lastSum == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3036" href="#"></a></td>
<td><pre>            val = new int[val.length+1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3037" href="#"></a></td>
<td><pre>            val[0] = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3038" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3039" href="#"></a></td>
<td><pre>        return val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3040" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3041" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3042" href="#"></a></td>
<td><pre>    // Bitwise Operations</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3043" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3044" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3045" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this &amp; val)}.  (This</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3046" href="#"></a></td>
<td><pre>     * method returns a negative BigInteger if and only if this and val are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3047" href="#"></a></td>
<td><pre>     * both negative.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3048" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3049" href="#"></a></td>
<td><pre>     * @param val value to be AND'ed with this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3050" href="#"></a></td>
<td><pre>     * @return {@code this &amp; val}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3051" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3052" href="#"></a></td>
<td><pre>    public BigInteger and(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3053" href="#"></a></td>
<td><pre>        int[] result = new int[Math.max(intLength(), val.intLength())];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3054" href="#"></a></td>
<td><pre>        for (int i=0; i &lt; result.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3055" href="#"></a></td>
<td><pre>            result[i] = (getInt(result.length-i-1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3056" href="#"></a></td>
<td><pre>                         &amp; val.getInt(result.length-i-1));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3057" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3058" href="#"></a></td>
<td><pre>        return valueOf(result);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3059" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3060" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3061" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3062" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this | val)}.  (This method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3063" href="#"></a></td>
<td><pre>     * returns a negative BigInteger if and only if either this or val is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3064" href="#"></a></td>
<td><pre>     * negative.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3065" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3066" href="#"></a></td>
<td><pre>     * @param val value to be OR'ed with this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3067" href="#"></a></td>
<td><pre>     * @return {@code this | val}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3068" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3069" href="#"></a></td>
<td><pre>    public BigInteger or(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3070" href="#"></a></td>
<td><pre>        int[] result = new int[Math.max(intLength(), val.intLength())];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3071" href="#"></a></td>
<td><pre>        for (int i=0; i &lt; result.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3072" href="#"></a></td>
<td><pre>            result[i] = (getInt(result.length-i-1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3073" href="#"></a></td>
<td><pre>                         | val.getInt(result.length-i-1));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3074" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3075" href="#"></a></td>
<td><pre>        return valueOf(result);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3076" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3077" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3078" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3079" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this ^ val)}.  (This method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3080" href="#"></a></td>
<td><pre>     * returns a negative BigInteger if and only if exactly one of this and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3081" href="#"></a></td>
<td><pre>     * val are negative.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3082" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3083" href="#"></a></td>
<td><pre>     * @param val value to be XOR'ed with this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3084" href="#"></a></td>
<td><pre>     * @return {@code this ^ val}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3085" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3086" href="#"></a></td>
<td><pre>    public BigInteger xor(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3087" href="#"></a></td>
<td><pre>        int[] result = new int[Math.max(intLength(), val.intLength())];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3088" href="#"></a></td>
<td><pre>        for (int i=0; i &lt; result.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3089" href="#"></a></td>
<td><pre>            result[i] = (getInt(result.length-i-1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3090" href="#"></a></td>
<td><pre>                         ^ val.getInt(result.length-i-1));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3091" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3092" href="#"></a></td>
<td><pre>        return valueOf(result);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3093" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3094" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3095" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3096" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (~this)}.  (This method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3097" href="#"></a></td>
<td><pre>     * returns a negative value if and only if this BigInteger is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3098" href="#"></a></td>
<td><pre>     * non-negative.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3099" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3100" href="#"></a></td>
<td><pre>     * @return {@code ~this}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3101" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3102" href="#"></a></td>
<td><pre>    public BigInteger not() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3103" href="#"></a></td>
<td><pre>        int[] result = new int[intLength()];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3104" href="#"></a></td>
<td><pre>        for (int i=0; i &lt; result.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3105" href="#"></a></td>
<td><pre>            result[i] = ~getInt(result.length-i-1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3106" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3107" href="#"></a></td>
<td><pre>        return valueOf(result);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3108" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3109" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3110" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3111" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is {@code (this &amp; ~val)}.  This</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3112" href="#"></a></td>
<td><pre>     * method, which is equivalent to {@code and(val.not())}, is provided as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3113" href="#"></a></td>
<td><pre>     * a convenience for masking operations.  (This method returns a negative</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3114" href="#"></a></td>
<td><pre>     * BigInteger if and only if {@code this} is negative and {@code val} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3115" href="#"></a></td>
<td><pre>     * positive.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3116" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3117" href="#"></a></td>
<td><pre>     * @param val value to be complemented and AND'ed with this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3118" href="#"></a></td>
<td><pre>     * @return {@code this &amp; ~val}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3119" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3120" href="#"></a></td>
<td><pre>    public BigInteger andNot(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3121" href="#"></a></td>
<td><pre>        int[] result = new int[Math.max(intLength(), val.intLength())];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3122" href="#"></a></td>
<td><pre>        for (int i=0; i &lt; result.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3123" href="#"></a></td>
<td><pre>            result[i] = (getInt(result.length-i-1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3124" href="#"></a></td>
<td><pre>                         &amp; ~val.getInt(result.length-i-1));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3125" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3126" href="#"></a></td>
<td><pre>        return valueOf(result);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3127" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3128" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3129" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3130" href="#"></a></td>
<td><pre>    // Single Bit Operations</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3131" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3132" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3133" href="#"></a></td>
<td><pre>     * Returns {@code true} if and only if the designated bit is set.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3134" href="#"></a></td>
<td><pre>     * (Computes {@code ((this &amp; (1&lt;&lt;n)) != 0)}.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3135" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3136" href="#"></a></td>
<td><pre>     * @param  n index of bit to test.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3137" href="#"></a></td>
<td><pre>     * @return {@code true} if and only if the designated bit is set.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3138" href="#"></a></td>
<td><pre>     * @throws ArithmeticException {@code n} is negative.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3139" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3140" href="#"></a></td>
<td><pre>    public boolean testBit(int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3141" href="#"></a></td>
<td><pre>        if (n &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3142" href="#"></a></td>
<td><pre>            throw new ArithmeticException(&quot;Negative bit address&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3143" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3144" href="#"></a></td>
<td><pre>        return (getInt(n &gt;&gt;&gt; 5) &amp; (1 &lt;&lt; (n &amp; 31))) != 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3145" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3146" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3147" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3148" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is equivalent to this BigInteger</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3149" href="#"></a></td>
<td><pre>     * with the designated bit set.  (Computes {@code (this | (1&lt;&lt;n))}.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3150" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3151" href="#"></a></td>
<td><pre>     * @param  n index of bit to set.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3152" href="#"></a></td>
<td><pre>     * @return {@code this | (1&lt;&lt;n)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3153" href="#"></a></td>
<td><pre>     * @throws ArithmeticException {@code n} is negative.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3154" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3155" href="#"></a></td>
<td><pre>    public BigInteger setBit(int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3156" href="#"></a></td>
<td><pre>        if (n &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3157" href="#"></a></td>
<td><pre>            throw new ArithmeticException(&quot;Negative bit address&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3158" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3159" href="#"></a></td>
<td><pre>        int intNum = n &gt;&gt;&gt; 5;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3160" href="#"></a></td>
<td><pre>        int[] result = new int[Math.max(intLength(), intNum+2)];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3161" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3162" href="#"></a></td>
<td><pre>        for (int i=0; i &lt; result.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3163" href="#"></a></td>
<td><pre>            result[result.length-i-1] = getInt(i);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3164" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3165" href="#"></a></td>
<td><pre>        result[result.length-intNum-1] |= (1 &lt;&lt; (n &amp; 31));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3166" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3167" href="#"></a></td>
<td><pre>        return valueOf(result);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3168" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3169" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3170" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3171" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is equivalent to this BigInteger</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3172" href="#"></a></td>
<td><pre>     * with the designated bit cleared.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3173" href="#"></a></td>
<td><pre>     * (Computes {@code (this &amp; ~(1&lt;&lt;n))}.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3174" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3175" href="#"></a></td>
<td><pre>     * @param  n index of bit to clear.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3176" href="#"></a></td>
<td><pre>     * @return {@code this &amp; ~(1&lt;&lt;n)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3177" href="#"></a></td>
<td><pre>     * @throws ArithmeticException {@code n} is negative.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3178" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3179" href="#"></a></td>
<td><pre>    public BigInteger clearBit(int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3180" href="#"></a></td>
<td><pre>        if (n &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3181" href="#"></a></td>
<td><pre>            throw new ArithmeticException(&quot;Negative bit address&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3182" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3183" href="#"></a></td>
<td><pre>        int intNum = n &gt;&gt;&gt; 5;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3184" href="#"></a></td>
<td><pre>        int[] result = new int[Math.max(intLength(), ((n + 1) &gt;&gt;&gt; 5) + 1)];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3185" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3186" href="#"></a></td>
<td><pre>        for (int i=0; i &lt; result.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3187" href="#"></a></td>
<td><pre>            result[result.length-i-1] = getInt(i);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3188" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3189" href="#"></a></td>
<td><pre>        result[result.length-intNum-1] &amp;= ~(1 &lt;&lt; (n &amp; 31));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3190" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3191" href="#"></a></td>
<td><pre>        return valueOf(result);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3192" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3193" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3194" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3195" href="#"></a></td>
<td><pre>     * Returns a BigInteger whose value is equivalent to this BigInteger</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3196" href="#"></a></td>
<td><pre>     * with the designated bit flipped.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3197" href="#"></a></td>
<td><pre>     * (Computes {@code (this ^ (1&lt;&lt;n))}.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3198" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3199" href="#"></a></td>
<td><pre>     * @param  n index of bit to flip.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3200" href="#"></a></td>
<td><pre>     * @return {@code this ^ (1&lt;&lt;n)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3201" href="#"></a></td>
<td><pre>     * @throws ArithmeticException {@code n} is negative.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3202" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3203" href="#"></a></td>
<td><pre>    public BigInteger flipBit(int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3204" href="#"></a></td>
<td><pre>        if (n &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3205" href="#"></a></td>
<td><pre>            throw new ArithmeticException(&quot;Negative bit address&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3206" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3207" href="#"></a></td>
<td><pre>        int intNum = n &gt;&gt;&gt; 5;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3208" href="#"></a></td>
<td><pre>        int[] result = new int[Math.max(intLength(), intNum+2)];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3209" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3210" href="#"></a></td>
<td><pre>        for (int i=0; i &lt; result.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3211" href="#"></a></td>
<td><pre>            result[result.length-i-1] = getInt(i);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3212" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3213" href="#"></a></td>
<td><pre>        result[result.length-intNum-1] ^= (1 &lt;&lt; (n &amp; 31));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3214" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3215" href="#"></a></td>
<td><pre>        return valueOf(result);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3216" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3217" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3218" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3219" href="#"></a></td>
<td><pre>     * Returns the index of the rightmost (lowest-order) one bit in this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3220" href="#"></a></td>
<td><pre>     * BigInteger (the number of zero bits to the right of the rightmost</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3221" href="#"></a></td>
<td><pre>     * one bit).  Returns -1 if this BigInteger contains no one bits.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3222" href="#"></a></td>
<td><pre>     * (Computes {@code (this == 0? -1 : log2(this &amp; -this))}.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3223" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3224" href="#"></a></td>
<td><pre>     * @return index of the rightmost one bit in this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3225" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3226" href="#"></a></td>
<td><pre>    public int getLowestSetBit() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3227" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;deprecation&quot;) int lsb = lowestSetBit - 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3228" href="#"></a></td>
<td><pre>        if (lsb == -2) {  // lowestSetBit not initialized yet</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3229" href="#"></a></td>
<td><pre>            lsb = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3230" href="#"></a></td>
<td><pre>            if (signum == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3231" href="#"></a></td>
<td><pre>                lsb -= 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3232" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3233" href="#"></a></td>
<td><pre>                // Search for lowest order nonzero int</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3234" href="#"></a></td>
<td><pre>                int i,b;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3235" href="#"></a></td>
<td><pre>                for (i=0; (b = getInt(i)) == 0; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3236" href="#"></a></td>
<td><pre>                    ;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3237" href="#"></a></td>
<td><pre>                lsb += (i &lt;&lt; 5) + Integer.numberOfTrailingZeros(b);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3238" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3239" href="#"></a></td>
<td><pre>            lowestSetBit = lsb + 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3240" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3241" href="#"></a></td>
<td><pre>        return lsb;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3242" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3243" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3244" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3245" href="#"></a></td>
<td><pre>    // Miscellaneous Bit Operations</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3246" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3247" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3248" href="#"></a></td>
<td><pre>     * Returns the number of bits in the minimal two's-complement</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3249" href="#"></a></td>
<td><pre>     * representation of this BigInteger, &lt;i&gt;excluding&lt;/i&gt; a sign bit.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3250" href="#"></a></td>
<td><pre>     * For positive BigIntegers, this is equivalent to the number of bits in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3251" href="#"></a></td>
<td><pre>     * the ordinary binary representation.  (Computes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3252" href="#"></a></td>
<td><pre>     * {@code (ceil(log2(this &lt; 0 ? -this : this+1)))}.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3253" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3254" href="#"></a></td>
<td><pre>     * @return number of bits in the minimal two's-complement</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3255" href="#"></a></td>
<td><pre>     *         representation of this BigInteger, &lt;i&gt;excluding&lt;/i&gt; a sign bit.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3256" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3257" href="#"></a></td>
<td><pre>    public int bitLength() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3258" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;deprecation&quot;) int n = bitLength - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3259" href="#"></a></td>
<td><pre>        if (n == -1) { // bitLength not initialized yet</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3260" href="#"></a></td>
<td><pre>            int[] m = mag;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3261" href="#"></a></td>
<td><pre>            int len = m.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3262" href="#"></a></td>
<td><pre>            if (len == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3263" href="#"></a></td>
<td><pre>                n = 0; // offset by one to initialize</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3264" href="#"></a></td>
<td><pre>            }  else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3265" href="#"></a></td>
<td><pre>                // Calculate the bit length of the magnitude</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3266" href="#"></a></td>
<td><pre>                int magBitLength = ((len - 1) &lt;&lt; 5) + bitLengthForInt(mag[0]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3267" href="#"></a></td>
<td><pre>                 if (signum &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3268" href="#"></a></td>
<td><pre>                     // Check if magnitude is a power of two</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3269" href="#"></a></td>
<td><pre>                     boolean pow2 = (Integer.bitCount(mag[0]) == 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3270" href="#"></a></td>
<td><pre>                     for (int i=1; i&lt; len &amp;&amp; pow2; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3271" href="#"></a></td>
<td><pre>                         pow2 = (mag[i] == 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3272" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3273" href="#"></a></td>
<td><pre>                     n = (pow2 ? magBitLength -1 : magBitLength);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3274" href="#"></a></td>
<td><pre>                 } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3275" href="#"></a></td>
<td><pre>                     n = magBitLength;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3276" href="#"></a></td>
<td><pre>                 }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3277" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3278" href="#"></a></td>
<td><pre>            bitLength = n + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3279" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3280" href="#"></a></td>
<td><pre>        return n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3281" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3282" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3283" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3284" href="#"></a></td>
<td><pre>     * Returns the number of bits in the two's complement representation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3285" href="#"></a></td>
<td><pre>     * of this BigInteger that differ from its sign bit.  This method is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3286" href="#"></a></td>
<td><pre>     * useful when implementing bit-vector style sets atop BigIntegers.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3287" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3288" href="#"></a></td>
<td><pre>     * @return number of bits in the two's complement representation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3289" href="#"></a></td>
<td><pre>     *         of this BigInteger that differ from its sign bit.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3290" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3291" href="#"></a></td>
<td><pre>    public int bitCount() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3292" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;deprecation&quot;) int bc = bitCount - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3293" href="#"></a></td>
<td><pre>        if (bc == -1) {  // bitCount not initialized yet</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3294" href="#"></a></td>
<td><pre>            bc = 0;      // offset by one to initialize</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3295" href="#"></a></td>
<td><pre>            // Count the bits in the magnitude</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3296" href="#"></a></td>
<td><pre>            for (int i=0; i &lt; mag.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3297" href="#"></a></td>
<td><pre>                bc += Integer.bitCount(mag[i]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3298" href="#"></a></td>
<td><pre>            if (signum &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3299" href="#"></a></td>
<td><pre>                // Count the trailing zeros in the magnitude</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3300" href="#"></a></td>
<td><pre>                int magTrailingZeroCount = 0, j;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3301" href="#"></a></td>
<td><pre>                for (j=mag.length-1; mag[j] == 0; j--)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3302" href="#"></a></td>
<td><pre>                    magTrailingZeroCount += 32;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3303" href="#"></a></td>
<td><pre>                magTrailingZeroCount += Integer.numberOfTrailingZeros(mag[j]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3304" href="#"></a></td>
<td><pre>                bc += magTrailingZeroCount - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3305" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3306" href="#"></a></td>
<td><pre>            bitCount = bc + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3307" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3308" href="#"></a></td>
<td><pre>        return bc;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3309" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3310" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3311" href="#"></a></td>
<td><pre>    // Primality Testing</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3312" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3313" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3314" href="#"></a></td>
<td><pre>     * Returns {@code true} if this BigInteger is probably prime,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3315" href="#"></a></td>
<td><pre>     * {@code false} if it's definitely composite.  If</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3316" href="#"></a></td>
<td><pre>     * {@code certainty} is &amp;le; 0, {@code true} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3317" href="#"></a></td>
<td><pre>     * returned.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3318" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3319" href="#"></a></td>
<td><pre>     * @param  certainty a measure of the uncertainty that the caller is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3320" href="#"></a></td>
<td><pre>     *         willing to tolerate: if the call returns {@code true}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3321" href="#"></a></td>
<td><pre>     *         the probability that this BigInteger is prime exceeds</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3322" href="#"></a></td>
<td><pre>     *         (1 - 1/2&lt;sup&gt;{@code certainty}&lt;/sup&gt;).  The execution time of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3323" href="#"></a></td>
<td><pre>     *         this method is proportional to the value of this parameter.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3324" href="#"></a></td>
<td><pre>     * @return {@code true} if this BigInteger is probably prime,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3325" href="#"></a></td>
<td><pre>     *         {@code false} if it's definitely composite.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3326" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3327" href="#"></a></td>
<td><pre>    public boolean isProbablePrime(int certainty) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3328" href="#"></a></td>
<td><pre>        if (certainty &lt;= 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3329" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3330" href="#"></a></td>
<td><pre>        BigInteger w = this.abs();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3331" href="#"></a></td>
<td><pre>        if (w.equals(TWO))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3332" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3333" href="#"></a></td>
<td><pre>        if (!w.testBit(0) || w.equals(ONE))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3334" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3335" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3336" href="#"></a></td>
<td><pre>        return w.primeToCertainty(certainty, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3337" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3338" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3339" href="#"></a></td>
<td><pre>    // Comparison Operations</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3340" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3341" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3342" href="#"></a></td>
<td><pre>     * Compares this BigInteger with the specified BigInteger.  This</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3343" href="#"></a></td>
<td><pre>     * method is provided in preference to individual methods for each</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3344" href="#"></a></td>
<td><pre>     * of the six boolean comparison operators ({@literal &lt;}, ==,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3345" href="#"></a></td>
<td><pre>     * {@literal &gt;}, {@literal &gt;=}, !=, {@literal &lt;=}).  The suggested</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3346" href="#"></a></td>
<td><pre>     * idiom for performing these comparisons is: {@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3347" href="#"></a></td>
<td><pre>     * (x.compareTo(y)} &amp;lt;&lt;i&gt;op&lt;/i&gt;&amp;gt; {@code 0)}, where</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3348" href="#"></a></td>
<td><pre>     * &amp;lt;&lt;i&gt;op&lt;/i&gt;&amp;gt; is one of the six comparison operators.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3349" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3350" href="#"></a></td>
<td><pre>     * @param  val BigInteger to which this BigInteger is to be compared.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3351" href="#"></a></td>
<td><pre>     * @return -1, 0 or 1 as this BigInteger is numerically less than, equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3352" href="#"></a></td>
<td><pre>     *         to, or greater than {@code val}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3353" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3354" href="#"></a></td>
<td><pre>    public int compareTo(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3355" href="#"></a></td>
<td><pre>        if (signum == val.signum) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3356" href="#"></a></td>
<td><pre>            switch (signum) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3357" href="#"></a></td>
<td><pre>            case 1:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3358" href="#"></a></td>
<td><pre>                return compareMagnitude(val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3359" href="#"></a></td>
<td><pre>            case -1:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3360" href="#"></a></td>
<td><pre>                return val.compareMagnitude(this);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3361" href="#"></a></td>
<td><pre>            default:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3362" href="#"></a></td>
<td><pre>                return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3363" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3364" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3365" href="#"></a></td>
<td><pre>        return signum &gt; val.signum ? 1 : -1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3366" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3367" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3368" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3369" href="#"></a></td>
<td><pre>     * Compares the magnitude array of this BigInteger with the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3370" href="#"></a></td>
<td><pre>     * BigInteger's. This is the version of compareTo ignoring sign.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3371" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3372" href="#"></a></td>
<td><pre>     * @param val BigInteger whose magnitude array to be compared.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3373" href="#"></a></td>
<td><pre>     * @return -1, 0 or 1 as this magnitude array is less than, equal to or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3374" href="#"></a></td>
<td><pre>     *         greater than the magnitude aray for the specified BigInteger's.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3375" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3376" href="#"></a></td>
<td><pre>    final int compareMagnitude(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3377" href="#"></a></td>
<td><pre>        int[] m1 = mag;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3378" href="#"></a></td>
<td><pre>        int len1 = m1.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3379" href="#"></a></td>
<td><pre>        int[] m2 = val.mag;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3380" href="#"></a></td>
<td><pre>        int len2 = m2.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3381" href="#"></a></td>
<td><pre>        if (len1 &lt; len2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3382" href="#"></a></td>
<td><pre>            return -1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3383" href="#"></a></td>
<td><pre>        if (len1 &gt; len2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3384" href="#"></a></td>
<td><pre>            return 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3385" href="#"></a></td>
<td><pre>        for (int i = 0; i &lt; len1; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3386" href="#"></a></td>
<td><pre>            int a = m1[i];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3387" href="#"></a></td>
<td><pre>            int b = m2[i];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3388" href="#"></a></td>
<td><pre>            if (a != b)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3389" href="#"></a></td>
<td><pre>                return ((a &amp; LONG_MASK) &lt; (b &amp; LONG_MASK)) ? -1 : 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3390" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3391" href="#"></a></td>
<td><pre>        return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3392" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3393" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3394" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3395" href="#"></a></td>
<td><pre>     * Version of compareMagnitude that compares magnitude with long value.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3396" href="#"></a></td>
<td><pre>     * val can't be Long.MIN_VALUE.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3397" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3398" href="#"></a></td>
<td><pre>    final int compareMagnitude(long val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3399" href="#"></a></td>
<td><pre>        assert val != Long.MIN_VALUE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3400" href="#"></a></td>
<td><pre>        int[] m1 = mag;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3401" href="#"></a></td>
<td><pre>        int len = m1.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3402" href="#"></a></td>
<td><pre>        if (len &gt; 2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3403" href="#"></a></td>
<td><pre>            return 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3404" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3405" href="#"></a></td>
<td><pre>        if (val &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3406" href="#"></a></td>
<td><pre>            val = -val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3407" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3408" href="#"></a></td>
<td><pre>        int highWord = (int)(val &gt;&gt;&gt; 32);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3409" href="#"></a></td>
<td><pre>        if (highWord == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3410" href="#"></a></td>
<td><pre>            if (len &lt; 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3411" href="#"></a></td>
<td><pre>                return -1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3412" href="#"></a></td>
<td><pre>            if (len &gt; 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3413" href="#"></a></td>
<td><pre>                return 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3414" href="#"></a></td>
<td><pre>            int a = m1[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3415" href="#"></a></td>
<td><pre>            int b = (int)val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3416" href="#"></a></td>
<td><pre>            if (a != b) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3417" href="#"></a></td>
<td><pre>                return ((a &amp; LONG_MASK) &lt; (b &amp; LONG_MASK))? -1 : 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3418" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3419" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3420" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3421" href="#"></a></td>
<td><pre>            if (len &lt; 2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3422" href="#"></a></td>
<td><pre>                return -1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3423" href="#"></a></td>
<td><pre>            int a = m1[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3424" href="#"></a></td>
<td><pre>            int b = highWord;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3425" href="#"></a></td>
<td><pre>            if (a != b) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3426" href="#"></a></td>
<td><pre>                return ((a &amp; LONG_MASK) &lt; (b &amp; LONG_MASK))? -1 : 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3427" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3428" href="#"></a></td>
<td><pre>            a = m1[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3429" href="#"></a></td>
<td><pre>            b = (int)val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3430" href="#"></a></td>
<td><pre>            if (a != b) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3431" href="#"></a></td>
<td><pre>                return ((a &amp; LONG_MASK) &lt; (b &amp; LONG_MASK))? -1 : 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3432" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3433" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3434" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3435" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3436" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3437" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3438" href="#"></a></td>
<td><pre>     * Compares this BigInteger with the specified Object for equality.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3439" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3440" href="#"></a></td>
<td><pre>     * @param  x Object to which this BigInteger is to be compared.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3441" href="#"></a></td>
<td><pre>     * @return {@code true} if and only if the specified Object is a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3442" href="#"></a></td>
<td><pre>     *         BigInteger whose value is numerically equal to this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3443" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3444" href="#"></a></td>
<td><pre>    public boolean equals(Object x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3445" href="#"></a></td>
<td><pre>        // This test is just an optimization, which may or may not help</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3446" href="#"></a></td>
<td><pre>        if (x == this)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3447" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3448" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3449" href="#"></a></td>
<td><pre>        if (!(x instanceof BigInteger))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3450" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3451" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3452" href="#"></a></td>
<td><pre>        BigInteger xInt = (BigInteger) x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3453" href="#"></a></td>
<td><pre>        if (xInt.signum != signum)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3454" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3455" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3456" href="#"></a></td>
<td><pre>        int[] m = mag;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3457" href="#"></a></td>
<td><pre>        int len = m.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3458" href="#"></a></td>
<td><pre>        int[] xm = xInt.mag;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3459" href="#"></a></td>
<td><pre>        if (len != xm.length)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3460" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3461" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3462" href="#"></a></td>
<td><pre>        for (int i = 0; i &lt; len; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3463" href="#"></a></td>
<td><pre>            if (xm[i] != m[i])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3464" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3465" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3466" href="#"></a></td>
<td><pre>        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3467" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3468" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3469" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3470" href="#"></a></td>
<td><pre>     * Returns the minimum of this BigInteger and {@code val}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3471" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3472" href="#"></a></td>
<td><pre>     * @param  val value with which the minimum is to be computed.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3473" href="#"></a></td>
<td><pre>     * @return the BigInteger whose value is the lesser of this BigInteger and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3474" href="#"></a></td>
<td><pre>     *         {@code val}.  If they are equal, either may be returned.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3475" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3476" href="#"></a></td>
<td><pre>    public BigInteger min(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3477" href="#"></a></td>
<td><pre>        return (compareTo(val) &lt; 0 ? this : val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3478" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3479" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3480" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3481" href="#"></a></td>
<td><pre>     * Returns the maximum of this BigInteger and {@code val}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3482" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3483" href="#"></a></td>
<td><pre>     * @param  val value with which the maximum is to be computed.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3484" href="#"></a></td>
<td><pre>     * @return the BigInteger whose value is the greater of this and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3485" href="#"></a></td>
<td><pre>     *         {@code val}.  If they are equal, either may be returned.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3486" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3487" href="#"></a></td>
<td><pre>    public BigInteger max(BigInteger val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3488" href="#"></a></td>
<td><pre>        return (compareTo(val) &gt; 0 ? this : val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3489" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3490" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3491" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3492" href="#"></a></td>
<td><pre>    // Hash Function</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3493" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3494" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3495" href="#"></a></td>
<td><pre>     * Returns the hash code for this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3496" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3497" href="#"></a></td>
<td><pre>     * @return hash code for this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3498" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3499" href="#"></a></td>
<td><pre>    public int hashCode() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3500" href="#"></a></td>
<td><pre>        int hashCode = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3501" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3502" href="#"></a></td>
<td><pre>        for (int i=0; i &lt; mag.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3503" href="#"></a></td>
<td><pre>            hashCode = (int)(31*hashCode + (mag[i] &amp; LONG_MASK));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3504" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3505" href="#"></a></td>
<td><pre>        return hashCode * signum;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3506" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3507" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3508" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3509" href="#"></a></td>
<td><pre>     * Returns the String representation of this BigInteger in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3510" href="#"></a></td>
<td><pre>     * given radix.  If the radix is outside the range from {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3511" href="#"></a></td>
<td><pre>     * Character#MIN_RADIX} to {@link Character#MAX_RADIX} inclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3512" href="#"></a></td>
<td><pre>     * it will default to 10 (as is the case for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3513" href="#"></a></td>
<td><pre>     * {@code Integer.toString}).  The digit-to-character mapping</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3514" href="#"></a></td>
<td><pre>     * provided by {@code Character.forDigit} is used, and a minus</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3515" href="#"></a></td>
<td><pre>     * sign is prepended if appropriate.  (This representation is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3516" href="#"></a></td>
<td><pre>     * compatible with the {@link #BigInteger(String, int) (String,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3517" href="#"></a></td>
<td><pre>     * int)} constructor.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3518" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3519" href="#"></a></td>
<td><pre>     * @param  radix  radix of the String representation.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3520" href="#"></a></td>
<td><pre>     * @return String representation of this BigInteger in the given radix.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3521" href="#"></a></td>
<td><pre>     * @see    Integer#toString</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3522" href="#"></a></td>
<td><pre>     * @see    Character#forDigit</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3523" href="#"></a></td>
<td><pre>     * @see    #BigInteger(java.lang.String, int)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3524" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3525" href="#"></a></td>
<td><pre>    public String toString(int radix) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3526" href="#"></a></td>
<td><pre>        if (signum == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3527" href="#"></a></td>
<td><pre>            return &quot;0&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3528" href="#"></a></td>
<td><pre>        if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3529" href="#"></a></td>
<td><pre>            radix = 10;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3530" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3531" href="#"></a></td>
<td><pre>        // If it's small enough, use smallToString.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3532" href="#"></a></td>
<td><pre>        if (mag.length &lt;= SCHOENHAGE_BASE_CONVERSION_THRESHOLD)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3533" href="#"></a></td>
<td><pre>           return smallToString(radix);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3534" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3535" href="#"></a></td>
<td><pre>        // Otherwise use recursive toString, which requires positive arguments.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3536" href="#"></a></td>
<td><pre>        // The results will be concatenated into this StringBuilder</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3537" href="#"></a></td>
<td><pre>        StringBuilder sb = new StringBuilder();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3538" href="#"></a></td>
<td><pre>        if (signum &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3539" href="#"></a></td>
<td><pre>            toString(this.negate(), sb, radix, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3540" href="#"></a></td>
<td><pre>            sb.insert(0, '-');</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3541" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3542" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3543" href="#"></a></td>
<td><pre>            toString(this, sb, radix, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3544" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3545" href="#"></a></td>
<td><pre>        return sb.toString();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3546" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3547" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3548" href="#"></a></td>
<td><pre>    /** This method is used to perform toString when arguments are small. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3549" href="#"></a></td>
<td><pre>    private String smallToString(int radix) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3550" href="#"></a></td>
<td><pre>        if (signum == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3551" href="#"></a></td>
<td><pre>            return &quot;0&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3552" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3553" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3554" href="#"></a></td>
<td><pre>        // Compute upper bound on number of digit groups and allocate space</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3555" href="#"></a></td>
<td><pre>        int maxNumDigitGroups = (4*mag.length + 6)/7;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3556" href="#"></a></td>
<td><pre>        String digitGroup[] = new String[maxNumDigitGroups];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3557" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3558" href="#"></a></td>
<td><pre>        // Translate number to string, a digit group at a time</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3559" href="#"></a></td>
<td><pre>        BigInteger tmp = this.abs();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3560" href="#"></a></td>
<td><pre>        int numGroups = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3561" href="#"></a></td>
<td><pre>        while (tmp.signum != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3562" href="#"></a></td>
<td><pre>            BigInteger d = longRadix[radix];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3563" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3564" href="#"></a></td>
<td><pre>            MutableBigInteger q = new MutableBigInteger(),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3565" href="#"></a></td>
<td><pre>                              a = new MutableBigInteger(tmp.mag),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3566" href="#"></a></td>
<td><pre>                              b = new MutableBigInteger(d.mag);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3567" href="#"></a></td>
<td><pre>            MutableBigInteger r = a.divide(b, q);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3568" href="#"></a></td>
<td><pre>            BigInteger q2 = q.toBigInteger(tmp.signum * d.signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3569" href="#"></a></td>
<td><pre>            BigInteger r2 = r.toBigInteger(tmp.signum * d.signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3570" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3571" href="#"></a></td>
<td><pre>            digitGroup[numGroups++] = Long.toString(r2.longValue(), radix);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3572" href="#"></a></td>
<td><pre>            tmp = q2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3573" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3574" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3575" href="#"></a></td>
<td><pre>        // Put sign (if any) and first digit group into result buffer</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3576" href="#"></a></td>
<td><pre>        StringBuilder buf = new StringBuilder(numGroups*digitsPerLong[radix]+1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3577" href="#"></a></td>
<td><pre>        if (signum &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3578" href="#"></a></td>
<td><pre>            buf.append('-');</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3579" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3580" href="#"></a></td>
<td><pre>        buf.append(digitGroup[numGroups-1]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3581" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3582" href="#"></a></td>
<td><pre>        // Append remaining digit groups padded with leading zeros</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3583" href="#"></a></td>
<td><pre>        for (int i=numGroups-2; i &gt;= 0; i--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3584" href="#"></a></td>
<td><pre>            // Prepend (any) leading zeros for this digit group</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3585" href="#"></a></td>
<td><pre>            int numLeadingZeros = digitsPerLong[radix]-digitGroup[i].length();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3586" href="#"></a></td>
<td><pre>            if (numLeadingZeros != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3587" href="#"></a></td>
<td><pre>                buf.append(zeros[numLeadingZeros]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3588" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3589" href="#"></a></td>
<td><pre>            buf.append(digitGroup[i]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3590" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3591" href="#"></a></td>
<td><pre>        return buf.toString();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3592" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3593" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3594" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3595" href="#"></a></td>
<td><pre>     * Converts the specified BigInteger to a string and appends to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3596" href="#"></a></td>
<td><pre>     * {@code sb}.  This implements the recursive Schoenhage algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3597" href="#"></a></td>
<td><pre>     * for base conversions.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3598" href="#"></a></td>
<td><pre>     * &lt;p/&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3599" href="#"></a></td>
<td><pre>     * See Knuth, Donald,  _The Art of Computer Programming_, Vol. 2,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3600" href="#"></a></td>
<td><pre>     * Answers to Exercises (4.4) Question 14.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3601" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3602" href="#"></a></td>
<td><pre>     * @param u      The number to convert to a string.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3603" href="#"></a></td>
<td><pre>     * @param sb     The StringBuilder that will be appended to in place.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3604" href="#"></a></td>
<td><pre>     * @param radix  The base to convert to.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3605" href="#"></a></td>
<td><pre>     * @param digits The minimum number of digits to pad to.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3606" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3607" href="#"></a></td>
<td><pre>    private static void toString(BigInteger u, StringBuilder sb, int radix,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3608" href="#"></a></td>
<td><pre>                                 int digits) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3609" href="#"></a></td>
<td><pre>        /* If we're smaller than a certain threshold, use the smallToString</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3610" href="#"></a></td>
<td><pre>           method, padding with leading zeroes when necessary. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3611" href="#"></a></td>
<td><pre>        if (u.mag.length &lt;= SCHOENHAGE_BASE_CONVERSION_THRESHOLD) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3612" href="#"></a></td>
<td><pre>            String s = u.smallToString(radix);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3613" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3614" href="#"></a></td>
<td><pre>            // Pad with internal zeros if necessary.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3615" href="#"></a></td>
<td><pre>            // Don't pad if we're at the beginning of the string.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3616" href="#"></a></td>
<td><pre>            if ((s.length() &lt; digits) &amp;&amp; (sb.length() &gt; 0)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3617" href="#"></a></td>
<td><pre>                for (int i=s.length(); i &lt; digits; i++) { // May be a faster way to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3618" href="#"></a></td>
<td><pre>                    sb.append('0');                    // do this?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3619" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3620" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3621" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3622" href="#"></a></td>
<td><pre>            sb.append(s);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3623" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3624" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3625" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3626" href="#"></a></td>
<td><pre>        int b, n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3627" href="#"></a></td>
<td><pre>        b = u.bitLength();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3628" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3629" href="#"></a></td>
<td><pre>        // Calculate a value for n in the equation radix^(2^n) = u</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3630" href="#"></a></td>
<td><pre>        // and subtract 1 from that value.  This is used to find the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3631" href="#"></a></td>
<td><pre>        // cache index that contains the best value to divide u.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3632" href="#"></a></td>
<td><pre>        n = (int) Math.round(Math.log(b * LOG_TWO / logCache[radix]) / LOG_TWO - 1.0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3633" href="#"></a></td>
<td><pre>        BigInteger v = getRadixConversionCache(radix, n);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3634" href="#"></a></td>
<td><pre>        BigInteger[] results;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3635" href="#"></a></td>
<td><pre>        results = u.divideAndRemainder(v);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3636" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3637" href="#"></a></td>
<td><pre>        int expectedDigits = 1 &lt;&lt; n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3638" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3639" href="#"></a></td>
<td><pre>        // Now recursively build the two halves of each number.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3640" href="#"></a></td>
<td><pre>        toString(results[0], sb, radix, digits-expectedDigits);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3641" href="#"></a></td>
<td><pre>        toString(results[1], sb, radix, expectedDigits);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3642" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3643" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3644" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3645" href="#"></a></td>
<td><pre>     * Returns the value radix^(2^exponent) from the cache.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3646" href="#"></a></td>
<td><pre>     * If this value doesn't already exist in the cache, it is added.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3647" href="#"></a></td>
<td><pre>     * &lt;p/&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3648" href="#"></a></td>
<td><pre>     * This could be changed to a more complicated caching method using</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3649" href="#"></a></td>
<td><pre>     * {@code Future}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3650" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3651" href="#"></a></td>
<td><pre>    private static BigInteger getRadixConversionCache(int radix, int exponent) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3652" href="#"></a></td>
<td><pre>        BigInteger[] cacheLine = powerCache[radix]; // volatile read</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3653" href="#"></a></td>
<td><pre>        if (exponent &lt; cacheLine.length) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3654" href="#"></a></td>
<td><pre>            return cacheLine[exponent];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3655" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3656" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3657" href="#"></a></td>
<td><pre>        int oldLength = cacheLine.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3658" href="#"></a></td>
<td><pre>        cacheLine = Arrays.copyOf(cacheLine, exponent + 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3659" href="#"></a></td>
<td><pre>        for (int i = oldLength; i &lt;= exponent; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3660" href="#"></a></td>
<td><pre>            cacheLine[i] = cacheLine[i - 1].pow(2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3661" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3662" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3663" href="#"></a></td>
<td><pre>        BigInteger[][] pc = powerCache; // volatile read again</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3664" href="#"></a></td>
<td><pre>        if (exponent &gt;= pc[radix].length) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3665" href="#"></a></td>
<td><pre>            pc = pc.clone();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3666" href="#"></a></td>
<td><pre>            pc[radix] = cacheLine;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3667" href="#"></a></td>
<td><pre>            powerCache = pc; // volatile write, publish</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3668" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3669" href="#"></a></td>
<td><pre>        return cacheLine[exponent];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3670" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3671" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3672" href="#"></a></td>
<td><pre>    /* zero[i] is a string of i consecutive zeros. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3673" href="#"></a></td>
<td><pre>    private static String zeros[] = new String[64];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3674" href="#"></a></td>
<td><pre>    static {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3675" href="#"></a></td>
<td><pre>        zeros[63] =</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3676" href="#"></a></td>
<td><pre>            &quot;000000000000000000000000000000000000000000000000000000000000000&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3677" href="#"></a></td>
<td><pre>        for (int i=0; i &lt; 63; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3678" href="#"></a></td>
<td><pre>            zeros[i] = zeros[63].substring(0, i);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3679" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3680" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3681" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3682" href="#"></a></td>
<td><pre>     * Returns the decimal String representation of this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3683" href="#"></a></td>
<td><pre>     * The digit-to-character mapping provided by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3684" href="#"></a></td>
<td><pre>     * {@code Character.forDigit} is used, and a minus sign is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3685" href="#"></a></td>
<td><pre>     * prepended if appropriate.  (This representation is compatible</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3686" href="#"></a></td>
<td><pre>     * with the {@link #BigInteger(String) (String)} constructor, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3687" href="#"></a></td>
<td><pre>     * allows for String concatenation with Java's + operator.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3688" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3689" href="#"></a></td>
<td><pre>     * @return decimal String representation of this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3690" href="#"></a></td>
<td><pre>     * @see    Character#forDigit</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3691" href="#"></a></td>
<td><pre>     * @see    #BigInteger(java.lang.String)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3692" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3693" href="#"></a></td>
<td><pre>    public String toString() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3694" href="#"></a></td>
<td><pre>        return toString(10);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3695" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3696" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3697" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3698" href="#"></a></td>
<td><pre>     * Returns a byte array containing the two's-complement</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3699" href="#"></a></td>
<td><pre>     * representation of this BigInteger.  The byte array will be in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3700" href="#"></a></td>
<td><pre>     * &lt;i&gt;big-endian&lt;/i&gt; byte-order: the most significant byte is in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3701" href="#"></a></td>
<td><pre>     * the zeroth element.  The array will contain the minimum number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3702" href="#"></a></td>
<td><pre>     * of bytes required to represent this BigInteger, including at</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3703" href="#"></a></td>
<td><pre>     * least one sign bit, which is {@code (ceil((this.bitLength() +</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3704" href="#"></a></td>
<td><pre>     * 1)/8))}.  (This representation is compatible with the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3705" href="#"></a></td>
<td><pre>     * {@link #BigInteger(byte[]) (byte[])} constructor.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3706" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3707" href="#"></a></td>
<td><pre>     * @return a byte array containing the two's-complement representation of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3708" href="#"></a></td>
<td><pre>     *         this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3709" href="#"></a></td>
<td><pre>     * @see    #BigInteger(byte[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3710" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3711" href="#"></a></td>
<td><pre>    public byte[] toByteArray() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3712" href="#"></a></td>
<td><pre>        int byteLen = bitLength()/8 + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3713" href="#"></a></td>
<td><pre>        byte[] byteArray = new byte[byteLen];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3714" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3715" href="#"></a></td>
<td><pre>        for (int i=byteLen-1, bytesCopied=4, nextInt=0, intIndex=0; i &gt;= 0; i--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3716" href="#"></a></td>
<td><pre>            if (bytesCopied == 4) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3717" href="#"></a></td>
<td><pre>                nextInt = getInt(intIndex++);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3718" href="#"></a></td>
<td><pre>                bytesCopied = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3719" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3720" href="#"></a></td>
<td><pre>                nextInt &gt;&gt;&gt;= 8;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3721" href="#"></a></td>
<td><pre>                bytesCopied++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3722" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3723" href="#"></a></td>
<td><pre>            byteArray[i] = (byte)nextInt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3724" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3725" href="#"></a></td>
<td><pre>        return byteArray;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3726" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3727" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3728" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3729" href="#"></a></td>
<td><pre>     * Converts this BigInteger to an {@code int}.  This</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3730" href="#"></a></td>
<td><pre>     * conversion is analogous to a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3731" href="#"></a></td>
<td><pre>     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code long} to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3732" href="#"></a></td>
<td><pre>     * {@code int} as defined in section 5.1.3 of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3733" href="#"></a></td>
<td><pre>     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3734" href="#"></a></td>
<td><pre>     * if this BigInteger is too big to fit in an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3735" href="#"></a></td>
<td><pre>     * {@code int}, only the low-order 32 bits are returned.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3736" href="#"></a></td>
<td><pre>     * Note that this conversion can lose information about the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3737" href="#"></a></td>
<td><pre>     * overall magnitude of the BigInteger value as well as return a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3738" href="#"></a></td>
<td><pre>     * result with the opposite sign.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3739" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3740" href="#"></a></td>
<td><pre>     * @return this BigInteger converted to an {@code int}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3741" href="#"></a></td>
<td><pre>     * @see #intValueExact()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3742" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3743" href="#"></a></td>
<td><pre>    public int intValue() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3744" href="#"></a></td>
<td><pre>        int result = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3745" href="#"></a></td>
<td><pre>        result = getInt(0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3746" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3747" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3748" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3749" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3750" href="#"></a></td>
<td><pre>     * Converts this BigInteger to a {@code long}.  This</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3751" href="#"></a></td>
<td><pre>     * conversion is analogous to a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3752" href="#"></a></td>
<td><pre>     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code long} to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3753" href="#"></a></td>
<td><pre>     * {@code int} as defined in section 5.1.3 of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3754" href="#"></a></td>
<td><pre>     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3755" href="#"></a></td>
<td><pre>     * if this BigInteger is too big to fit in a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3756" href="#"></a></td>
<td><pre>     * {@code long}, only the low-order 64 bits are returned.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3757" href="#"></a></td>
<td><pre>     * Note that this conversion can lose information about the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3758" href="#"></a></td>
<td><pre>     * overall magnitude of the BigInteger value as well as return a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3759" href="#"></a></td>
<td><pre>     * result with the opposite sign.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3760" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3761" href="#"></a></td>
<td><pre>     * @return this BigInteger converted to a {@code long}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3762" href="#"></a></td>
<td><pre>     * @see #longValueExact()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3763" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3764" href="#"></a></td>
<td><pre>    public long longValue() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3765" href="#"></a></td>
<td><pre>        long result = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3766" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3767" href="#"></a></td>
<td><pre>        for (int i=1; i &gt;= 0; i--)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3768" href="#"></a></td>
<td><pre>            result = (result &lt;&lt; 32) + (getInt(i) &amp; LONG_MASK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3769" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3770" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3771" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3772" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3773" href="#"></a></td>
<td><pre>     * Converts this BigInteger to a {@code float}.  This</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3774" href="#"></a></td>
<td><pre>     * conversion is similar to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3775" href="#"></a></td>
<td><pre>     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3776" href="#"></a></td>
<td><pre>     * {@code float} as defined in section 5.1.3 of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3777" href="#"></a></td>
<td><pre>     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3778" href="#"></a></td>
<td><pre>     * if this BigInteger has too great a magnitude</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3779" href="#"></a></td>
<td><pre>     * to represent as a {@code float}, it will be converted to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3780" href="#"></a></td>
<td><pre>     * {@link Float#NEGATIVE_INFINITY} or {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3781" href="#"></a></td>
<td><pre>     * Float#POSITIVE_INFINITY} as appropriate.  Note that even when</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3782" href="#"></a></td>
<td><pre>     * the return value is finite, this conversion can lose</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3783" href="#"></a></td>
<td><pre>     * information about the precision of the BigInteger value.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3784" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3785" href="#"></a></td>
<td><pre>     * @return this BigInteger converted to a {@code float}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3786" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3787" href="#"></a></td>
<td><pre>    public float floatValue() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3788" href="#"></a></td>
<td><pre>        if (signum == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3789" href="#"></a></td>
<td><pre>            return 0.0f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3790" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3791" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3792" href="#"></a></td>
<td><pre>        int exponent = ((mag.length - 1) &lt;&lt; 5) + bitLengthForInt(mag[0]) - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3793" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3794" href="#"></a></td>
<td><pre>        // exponent == floor(log2(abs(this)))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3795" href="#"></a></td>
<td><pre>        if (exponent &lt; Long.SIZE - 1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3796" href="#"></a></td>
<td><pre>            return longValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3797" href="#"></a></td>
<td><pre>        } else if (exponent &gt; Float.MAX_EXPONENT) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3798" href="#"></a></td>
<td><pre>            return signum &gt; 0 ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3799" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3800" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3801" href="#"></a></td>
<td><pre>        /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3802" href="#"></a></td>
<td><pre>         * We need the top SIGNIFICAND_WIDTH bits, including the &quot;implicit&quot;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3803" href="#"></a></td>
<td><pre>         * one bit. To make rounding easier, we pick out the top</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3804" href="#"></a></td>
<td><pre>         * SIGNIFICAND_WIDTH + 1 bits, so we have one to help us round up or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3805" href="#"></a></td>
<td><pre>         * down. twiceSignifFloor will contain the top SIGNIFICAND_WIDTH + 1</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3806" href="#"></a></td>
<td><pre>         * bits, and signifFloor the top SIGNIFICAND_WIDTH.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3807" href="#"></a></td>
<td><pre>         *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3808" href="#"></a></td>
<td><pre>         * It helps to consider the real number signif = abs(this) *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3809" href="#"></a></td>
<td><pre>         * 2^(SIGNIFICAND_WIDTH - 1 - exponent).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3810" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3811" href="#"></a></td>
<td><pre>        int shift = exponent - FloatConsts.SIGNIFICAND_WIDTH;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3812" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3813" href="#"></a></td>
<td><pre>        int twiceSignifFloor;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3814" href="#"></a></td>
<td><pre>        // twiceSignifFloor will be == abs().shiftRight(shift).intValue()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3815" href="#"></a></td>
<td><pre>        // We do the shift into an int directly to improve performance.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3816" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3817" href="#"></a></td>
<td><pre>        int nBits = shift &amp; 0x1f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3818" href="#"></a></td>
<td><pre>        int nBits2 = 32 - nBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3819" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3820" href="#"></a></td>
<td><pre>        if (nBits == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3821" href="#"></a></td>
<td><pre>            twiceSignifFloor = mag[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3822" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3823" href="#"></a></td>
<td><pre>            twiceSignifFloor = mag[0] &gt;&gt;&gt; nBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3824" href="#"></a></td>
<td><pre>            if (twiceSignifFloor == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3825" href="#"></a></td>
<td><pre>                twiceSignifFloor = (mag[0] &lt;&lt; nBits2) | (mag[1] &gt;&gt;&gt; nBits);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3826" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3827" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3828" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3829" href="#"></a></td>
<td><pre>        int signifFloor = twiceSignifFloor &gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3830" href="#"></a></td>
<td><pre>        signifFloor &amp;= FloatConsts.SIGNIF_BIT_MASK; // remove the implied bit</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3831" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3832" href="#"></a></td>
<td><pre>        /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3833" href="#"></a></td>
<td><pre>         * We round up if either the fractional part of signif is strictly</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3834" href="#"></a></td>
<td><pre>         * greater than 0.5 (which is true if the 0.5 bit is set and any lower</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3835" href="#"></a></td>
<td><pre>         * bit is set), or if the fractional part of signif is &gt;= 0.5 and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3836" href="#"></a></td>
<td><pre>         * signifFloor is odd (which is true if both the 0.5 bit and the 1 bit</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3837" href="#"></a></td>
<td><pre>         * are set). This is equivalent to the desired HALF_EVEN rounding.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3838" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3839" href="#"></a></td>
<td><pre>        boolean increment = (twiceSignifFloor &amp; 1) != 0</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3840" href="#"></a></td>
<td><pre>                &amp;&amp; ((signifFloor &amp; 1) != 0 || abs().getLowestSetBit() &lt; shift);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3841" href="#"></a></td>
<td><pre>        int signifRounded = increment ? signifFloor + 1 : signifFloor;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3842" href="#"></a></td>
<td><pre>        int bits = ((exponent + FloatConsts.EXP_BIAS))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3843" href="#"></a></td>
<td><pre>                &lt;&lt; (FloatConsts.SIGNIFICAND_WIDTH - 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3844" href="#"></a></td>
<td><pre>        bits += signifRounded;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3845" href="#"></a></td>
<td><pre>        /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3846" href="#"></a></td>
<td><pre>         * If signifRounded == 2^24, we'd need to set all of the significand</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3847" href="#"></a></td>
<td><pre>         * bits to zero and add 1 to the exponent. This is exactly the behavior</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3848" href="#"></a></td>
<td><pre>         * we get from just adding signifRounded to bits directly. If the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3849" href="#"></a></td>
<td><pre>         * exponent is Float.MAX_EXPONENT, we round up (correctly) to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3850" href="#"></a></td>
<td><pre>         * Float.POSITIVE_INFINITY.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3851" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3852" href="#"></a></td>
<td><pre>        bits |= signum &amp; FloatConsts.SIGN_BIT_MASK;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3853" href="#"></a></td>
<td><pre>        return Float.intBitsToFloat(bits);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3854" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3855" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3856" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3857" href="#"></a></td>
<td><pre>     * Converts this BigInteger to a {@code double}.  This</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3858" href="#"></a></td>
<td><pre>     * conversion is similar to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3859" href="#"></a></td>
<td><pre>     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3860" href="#"></a></td>
<td><pre>     * {@code float} as defined in section 5.1.3 of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3861" href="#"></a></td>
<td><pre>     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3862" href="#"></a></td>
<td><pre>     * if this BigInteger has too great a magnitude</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3863" href="#"></a></td>
<td><pre>     * to represent as a {@code double}, it will be converted to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3864" href="#"></a></td>
<td><pre>     * {@link Double#NEGATIVE_INFINITY} or {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3865" href="#"></a></td>
<td><pre>     * Double#POSITIVE_INFINITY} as appropriate.  Note that even when</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3866" href="#"></a></td>
<td><pre>     * the return value is finite, this conversion can lose</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3867" href="#"></a></td>
<td><pre>     * information about the precision of the BigInteger value.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3868" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3869" href="#"></a></td>
<td><pre>     * @return this BigInteger converted to a {@code double}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3870" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3871" href="#"></a></td>
<td><pre>    public double doubleValue() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3872" href="#"></a></td>
<td><pre>        if (signum == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3873" href="#"></a></td>
<td><pre>            return 0.0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3874" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3875" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3876" href="#"></a></td>
<td><pre>        int exponent = ((mag.length - 1) &lt;&lt; 5) + bitLengthForInt(mag[0]) - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3877" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3878" href="#"></a></td>
<td><pre>        // exponent == floor(log2(abs(this))Double)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3879" href="#"></a></td>
<td><pre>        if (exponent &lt; Long.SIZE - 1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3880" href="#"></a></td>
<td><pre>            return longValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3881" href="#"></a></td>
<td><pre>        } else if (exponent &gt; Double.MAX_EXPONENT) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3882" href="#"></a></td>
<td><pre>            return signum &gt; 0 ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3883" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3884" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3885" href="#"></a></td>
<td><pre>        /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3886" href="#"></a></td>
<td><pre>         * We need the top SIGNIFICAND_WIDTH bits, including the &quot;implicit&quot;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3887" href="#"></a></td>
<td><pre>         * one bit. To make rounding easier, we pick out the top</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3888" href="#"></a></td>
<td><pre>         * SIGNIFICAND_WIDTH + 1 bits, so we have one to help us round up or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3889" href="#"></a></td>
<td><pre>         * down. twiceSignifFloor will contain the top SIGNIFICAND_WIDTH + 1</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3890" href="#"></a></td>
<td><pre>         * bits, and signifFloor the top SIGNIFICAND_WIDTH.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3891" href="#"></a></td>
<td><pre>         *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3892" href="#"></a></td>
<td><pre>         * It helps to consider the real number signif = abs(this) *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3893" href="#"></a></td>
<td><pre>         * 2^(SIGNIFICAND_WIDTH - 1 - exponent).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3894" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3895" href="#"></a></td>
<td><pre>        int shift = exponent - DoubleConsts.SIGNIFICAND_WIDTH;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3896" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3897" href="#"></a></td>
<td><pre>        long twiceSignifFloor;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3898" href="#"></a></td>
<td><pre>        // twiceSignifFloor will be == abs().shiftRight(shift).longValue()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3899" href="#"></a></td>
<td><pre>        // We do the shift into a long directly to improve performance.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3900" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3901" href="#"></a></td>
<td><pre>        int nBits = shift &amp; 0x1f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3902" href="#"></a></td>
<td><pre>        int nBits2 = 32 - nBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3903" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3904" href="#"></a></td>
<td><pre>        int highBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3905" href="#"></a></td>
<td><pre>        int lowBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3906" href="#"></a></td>
<td><pre>        if (nBits == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3907" href="#"></a></td>
<td><pre>            highBits = mag[0];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3908" href="#"></a></td>
<td><pre>            lowBits = mag[1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3909" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3910" href="#"></a></td>
<td><pre>            highBits = mag[0] &gt;&gt;&gt; nBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3911" href="#"></a></td>
<td><pre>            lowBits = (mag[0] &lt;&lt; nBits2) | (mag[1] &gt;&gt;&gt; nBits);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3912" href="#"></a></td>
<td><pre>            if (highBits == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3913" href="#"></a></td>
<td><pre>                highBits = lowBits;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3914" href="#"></a></td>
<td><pre>                lowBits = (mag[1] &lt;&lt; nBits2) | (mag[2] &gt;&gt;&gt; nBits);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3915" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3916" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3917" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3918" href="#"></a></td>
<td><pre>        twiceSignifFloor = ((highBits &amp; LONG_MASK) &lt;&lt; 32)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3919" href="#"></a></td>
<td><pre>                | (lowBits &amp; LONG_MASK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3920" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3921" href="#"></a></td>
<td><pre>        long signifFloor = twiceSignifFloor &gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3922" href="#"></a></td>
<td><pre>        signifFloor &amp;= DoubleConsts.SIGNIF_BIT_MASK; // remove the implied bit</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3923" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3924" href="#"></a></td>
<td><pre>        /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3925" href="#"></a></td>
<td><pre>         * We round up if either the fractional part of signif is strictly</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3926" href="#"></a></td>
<td><pre>         * greater than 0.5 (which is true if the 0.5 bit is set and any lower</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3927" href="#"></a></td>
<td><pre>         * bit is set), or if the fractional part of signif is &gt;= 0.5 and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3928" href="#"></a></td>
<td><pre>         * signifFloor is odd (which is true if both the 0.5 bit and the 1 bit</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3929" href="#"></a></td>
<td><pre>         * are set). This is equivalent to the desired HALF_EVEN rounding.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3930" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3931" href="#"></a></td>
<td><pre>        boolean increment = (twiceSignifFloor &amp; 1) != 0</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3932" href="#"></a></td>
<td><pre>                &amp;&amp; ((signifFloor &amp; 1) != 0 || abs().getLowestSetBit() &lt; shift);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3933" href="#"></a></td>
<td><pre>        long signifRounded = increment ? signifFloor + 1 : signifFloor;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3934" href="#"></a></td>
<td><pre>        long bits = (long) ((exponent + DoubleConsts.EXP_BIAS))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3935" href="#"></a></td>
<td><pre>                &lt;&lt; (DoubleConsts.SIGNIFICAND_WIDTH - 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3936" href="#"></a></td>
<td><pre>        bits += signifRounded;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3937" href="#"></a></td>
<td><pre>        /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3938" href="#"></a></td>
<td><pre>         * If signifRounded == 2^53, we'd need to set all of the significand</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3939" href="#"></a></td>
<td><pre>         * bits to zero and add 1 to the exponent. This is exactly the behavior</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3940" href="#"></a></td>
<td><pre>         * we get from just adding signifRounded to bits directly. If the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3941" href="#"></a></td>
<td><pre>         * exponent is Double.MAX_EXPONENT, we round up (correctly) to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3942" href="#"></a></td>
<td><pre>         * Double.POSITIVE_INFINITY.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3943" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3944" href="#"></a></td>
<td><pre>        bits |= signum &amp; DoubleConsts.SIGN_BIT_MASK;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3945" href="#"></a></td>
<td><pre>        return Double.longBitsToDouble(bits);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3946" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3947" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3948" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3949" href="#"></a></td>
<td><pre>     * Returns a copy of the input array stripped of any leading zero bytes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3950" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3951" href="#"></a></td>
<td><pre>    private static int[] stripLeadingZeroInts(int val[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3952" href="#"></a></td>
<td><pre>        int vlen = val.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3953" href="#"></a></td>
<td><pre>        int keep;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3954" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3955" href="#"></a></td>
<td><pre>        // Find first nonzero byte</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3956" href="#"></a></td>
<td><pre>        for (keep = 0; keep &lt; vlen &amp;&amp; val[keep] == 0; keep++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3957" href="#"></a></td>
<td><pre>            ;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3958" href="#"></a></td>
<td><pre>        return java.util.Arrays.copyOfRange(val, keep, vlen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3959" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3960" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3961" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3962" href="#"></a></td>
<td><pre>     * Returns the input array stripped of any leading zero bytes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3963" href="#"></a></td>
<td><pre>     * Since the source is trusted the copying may be skipped.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3964" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3965" href="#"></a></td>
<td><pre>    private static int[] trustedStripLeadingZeroInts(int val[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3966" href="#"></a></td>
<td><pre>        int vlen = val.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3967" href="#"></a></td>
<td><pre>        int keep;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3968" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3969" href="#"></a></td>
<td><pre>        // Find first nonzero byte</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3970" href="#"></a></td>
<td><pre>        for (keep = 0; keep &lt; vlen &amp;&amp; val[keep] == 0; keep++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3971" href="#"></a></td>
<td><pre>            ;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3972" href="#"></a></td>
<td><pre>        return keep == 0 ? val : java.util.Arrays.copyOfRange(val, keep, vlen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3973" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3974" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3975" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3976" href="#"></a></td>
<td><pre>     * Returns a copy of the input array stripped of any leading zero bytes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3977" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3978" href="#"></a></td>
<td><pre>    private static int[] stripLeadingZeroBytes(byte a[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3979" href="#"></a></td>
<td><pre>        int byteLength = a.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3980" href="#"></a></td>
<td><pre>        int keep;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3981" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3982" href="#"></a></td>
<td><pre>        // Find first nonzero byte</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3983" href="#"></a></td>
<td><pre>        for (keep = 0; keep &lt; byteLength &amp;&amp; a[keep] == 0; keep++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3984" href="#"></a></td>
<td><pre>            ;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3985" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3986" href="#"></a></td>
<td><pre>        // Allocate new array and copy relevant part of input array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3987" href="#"></a></td>
<td><pre>        int intLength = ((byteLength - keep) + 3) &gt;&gt;&gt; 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3988" href="#"></a></td>
<td><pre>        int[] result = new int[intLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3989" href="#"></a></td>
<td><pre>        int b = byteLength - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3990" href="#"></a></td>
<td><pre>        for (int i = intLength-1; i &gt;= 0; i--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3991" href="#"></a></td>
<td><pre>            result[i] = a[b--] &amp; 0xff;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3992" href="#"></a></td>
<td><pre>            int bytesRemaining = b - keep + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3993" href="#"></a></td>
<td><pre>            int bytesToTransfer = Math.min(3, bytesRemaining);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3994" href="#"></a></td>
<td><pre>            for (int j=8; j &lt;= (bytesToTransfer &lt;&lt; 3); j += 8)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3995" href="#"></a></td>
<td><pre>                result[i] |= ((a[b--] &amp; 0xff) &lt;&lt; j);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3996" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3997" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3998" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3999" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4000" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4001" href="#"></a></td>
<td><pre>     * Takes an array a representing a negative 2's-complement number and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4002" href="#"></a></td>
<td><pre>     * returns the minimal (no leading zero bytes) unsigned whose value is -a.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4003" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4004" href="#"></a></td>
<td><pre>    private static int[] makePositive(byte a[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4005" href="#"></a></td>
<td><pre>        int keep, k;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4006" href="#"></a></td>
<td><pre>        int byteLength = a.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4007" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4008" href="#"></a></td>
<td><pre>        // Find first non-sign (0xff) byte of input</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4009" href="#"></a></td>
<td><pre>        for (keep=0; keep &lt; byteLength &amp;&amp; a[keep] == -1; keep++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4010" href="#"></a></td>
<td><pre>            ;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4011" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4012" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4013" href="#"></a></td>
<td><pre>        /* Allocate output array.  If all non-sign bytes are 0x00, we must</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4014" href="#"></a></td>
<td><pre>         * allocate space for one extra output byte. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4015" href="#"></a></td>
<td><pre>        for (k=keep; k &lt; byteLength &amp;&amp; a[k] == 0; k++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4016" href="#"></a></td>
<td><pre>            ;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4017" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4018" href="#"></a></td>
<td><pre>        int extraByte = (k == byteLength) ? 1 : 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4019" href="#"></a></td>
<td><pre>        int intLength = ((byteLength - keep + extraByte) + 3) &gt;&gt;&gt; 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4020" href="#"></a></td>
<td><pre>        int result[] = new int[intLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4021" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4022" href="#"></a></td>
<td><pre>        /* Copy one's complement of input into output, leaving extra</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4023" href="#"></a></td>
<td><pre>         * byte (if it exists) == 0x00 */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4024" href="#"></a></td>
<td><pre>        int b = byteLength - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4025" href="#"></a></td>
<td><pre>        for (int i = intLength-1; i &gt;= 0; i--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4026" href="#"></a></td>
<td><pre>            result[i] = a[b--] &amp; 0xff;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4027" href="#"></a></td>
<td><pre>            int numBytesToTransfer = Math.min(3, b-keep+1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4028" href="#"></a></td>
<td><pre>            if (numBytesToTransfer &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4029" href="#"></a></td>
<td><pre>                numBytesToTransfer = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4030" href="#"></a></td>
<td><pre>            for (int j=8; j &lt;= 8*numBytesToTransfer; j += 8)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4031" href="#"></a></td>
<td><pre>                result[i] |= ((a[b--] &amp; 0xff) &lt;&lt; j);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4032" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4033" href="#"></a></td>
<td><pre>            // Mask indicates which bits must be complemented</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4034" href="#"></a></td>
<td><pre>            int mask = -1 &gt;&gt;&gt; (8*(3-numBytesToTransfer));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4035" href="#"></a></td>
<td><pre>            result[i] = ~result[i] &amp; mask;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4036" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4037" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4038" href="#"></a></td>
<td><pre>        // Add one to one's complement to generate two's complement</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4039" href="#"></a></td>
<td><pre>        for (int i=result.length-1; i &gt;= 0; i--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4040" href="#"></a></td>
<td><pre>            result[i] = (int)((result[i] &amp; LONG_MASK) + 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4041" href="#"></a></td>
<td><pre>            if (result[i] != 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4042" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4043" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4044" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4045" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4046" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4047" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4048" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4049" href="#"></a></td>
<td><pre>     * Takes an array a representing a negative 2's-complement number and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4050" href="#"></a></td>
<td><pre>     * returns the minimal (no leading zero ints) unsigned whose value is -a.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4051" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4052" href="#"></a></td>
<td><pre>    private static int[] makePositive(int a[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4053" href="#"></a></td>
<td><pre>        int keep, j;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4054" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4055" href="#"></a></td>
<td><pre>        // Find first non-sign (0xffffffff) int of input</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4056" href="#"></a></td>
<td><pre>        for (keep=0; keep &lt; a.length &amp;&amp; a[keep] == -1; keep++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4057" href="#"></a></td>
<td><pre>            ;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4058" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4059" href="#"></a></td>
<td><pre>        /* Allocate output array.  If all non-sign ints are 0x00, we must</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4060" href="#"></a></td>
<td><pre>         * allocate space for one extra output int. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4061" href="#"></a></td>
<td><pre>        for (j=keep; j &lt; a.length &amp;&amp; a[j] == 0; j++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4062" href="#"></a></td>
<td><pre>            ;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4063" href="#"></a></td>
<td><pre>        int extraInt = (j == a.length ? 1 : 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4064" href="#"></a></td>
<td><pre>        int result[] = new int[a.length - keep + extraInt];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4065" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4066" href="#"></a></td>
<td><pre>        /* Copy one's complement of input into output, leaving extra</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4067" href="#"></a></td>
<td><pre>         * int (if it exists) == 0x00 */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4068" href="#"></a></td>
<td><pre>        for (int i = keep; i &lt; a.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4069" href="#"></a></td>
<td><pre>            result[i - keep + extraInt] = ~a[i];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4070" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4071" href="#"></a></td>
<td><pre>        // Add one to one's complement to generate two's complement</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4072" href="#"></a></td>
<td><pre>        for (int i=result.length-1; ++result[i] == 0; i--)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4073" href="#"></a></td>
<td><pre>            ;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4074" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4075" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4076" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4077" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4078" href="#"></a></td>
<td><pre>    /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4079" href="#"></a></td>
<td><pre>     * The following two arrays are used for fast String conversions.  Both</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4080" href="#"></a></td>
<td><pre>     * are indexed by radix.  The first is the number of digits of the given</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4081" href="#"></a></td>
<td><pre>     * radix that can fit in a Java long without &quot;going negative&quot;, i.e., the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4082" href="#"></a></td>
<td><pre>     * highest integer n such that radix**n &lt; 2**63.  The second is the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4083" href="#"></a></td>
<td><pre>     * &quot;long radix&quot; that tears each number into &quot;long digits&quot;, each of which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4084" href="#"></a></td>
<td><pre>     * consists of the number of digits in the corresponding element in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4085" href="#"></a></td>
<td><pre>     * digitsPerLong (longRadix[i] = i**digitPerLong[i]).  Both arrays have</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4086" href="#"></a></td>
<td><pre>     * nonsense values in their 0 and 1 elements, as radixes 0 and 1 are not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4087" href="#"></a></td>
<td><pre>     * used.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4088" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4089" href="#"></a></td>
<td><pre>    private static int digitsPerLong[] = {0, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4090" href="#"></a></td>
<td><pre>        62, 39, 31, 27, 24, 22, 20, 19, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4091" href="#"></a></td>
<td><pre>        14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12};</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4092" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4093" href="#"></a></td>
<td><pre>    private static BigInteger longRadix[] = {null, null,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4094" href="#"></a></td>
<td><pre>        valueOf(0x4000000000000000L), valueOf(0x383d9170b85ff80bL),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4095" href="#"></a></td>
<td><pre>        valueOf(0x4000000000000000L), valueOf(0x6765c793fa10079dL),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4096" href="#"></a></td>
<td><pre>        valueOf(0x41c21cb8e1000000L), valueOf(0x3642798750226111L),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4097" href="#"></a></td>
<td><pre>        valueOf(0x1000000000000000L), valueOf(0x12bf307ae81ffd59L),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4098" href="#"></a></td>
<td><pre>        valueOf( 0xde0b6b3a7640000L), valueOf(0x4d28cb56c33fa539L),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4099" href="#"></a></td>
<td><pre>        valueOf(0x1eca170c00000000L), valueOf(0x780c7372621bd74dL),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4100" href="#"></a></td>
<td><pre>        valueOf(0x1e39a5057d810000L), valueOf(0x5b27ac993df97701L),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4101" href="#"></a></td>
<td><pre>        valueOf(0x1000000000000000L), valueOf(0x27b95e997e21d9f1L),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4102" href="#"></a></td>
<td><pre>        valueOf(0x5da0e1e53c5c8000L), valueOf( 0xb16a458ef403f19L),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4103" href="#"></a></td>
<td><pre>        valueOf(0x16bcc41e90000000L), valueOf(0x2d04b7fdd9c0ef49L),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4104" href="#"></a></td>
<td><pre>        valueOf(0x5658597bcaa24000L), valueOf( 0x6feb266931a75b7L),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4105" href="#"></a></td>
<td><pre>        valueOf( 0xc29e98000000000L), valueOf(0x14adf4b7320334b9L),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4106" href="#"></a></td>
<td><pre>        valueOf(0x226ed36478bfa000L), valueOf(0x383d9170b85ff80bL),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4107" href="#"></a></td>
<td><pre>        valueOf(0x5a3c23e39c000000L), valueOf( 0x4e900abb53e6b71L),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4108" href="#"></a></td>
<td><pre>        valueOf( 0x7600ec618141000L), valueOf( 0xaee5720ee830681L),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4109" href="#"></a></td>
<td><pre>        valueOf(0x1000000000000000L), valueOf(0x172588ad4f5f0981L),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4110" href="#"></a></td>
<td><pre>        valueOf(0x211e44f7d02c1000L), valueOf(0x2ee56725f06e5c71L),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4111" href="#"></a></td>
<td><pre>        valueOf(0x41c21cb8e1000000L)};</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4112" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4113" href="#"></a></td>
<td><pre>    /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4114" href="#"></a></td>
<td><pre>     * These two arrays are the integer analogue of above.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4115" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4116" href="#"></a></td>
<td><pre>    private static int digitsPerInt[] = {0, 0, 30, 19, 15, 13, 11,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4117" href="#"></a></td>
<td><pre>        11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4118" href="#"></a></td>
<td><pre>        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5};</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4119" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4120" href="#"></a></td>
<td><pre>    private static int intRadix[] = {0, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4121" href="#"></a></td>
<td><pre>        0x40000000, 0x4546b3db, 0x40000000, 0x48c27395, 0x159fd800,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4122" href="#"></a></td>
<td><pre>        0x75db9c97, 0x40000000, 0x17179149, 0x3b9aca00, 0xcc6db61,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4123" href="#"></a></td>
<td><pre>        0x19a10000, 0x309f1021, 0x57f6c100, 0xa2f1b6f,  0x10000000,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4124" href="#"></a></td>
<td><pre>        0x18754571, 0x247dbc80, 0x3547667b, 0x4c4b4000, 0x6b5a6e1d,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4125" href="#"></a></td>
<td><pre>        0x6c20a40,  0x8d2d931,  0xb640000,  0xe8d4a51,  0x1269ae40,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4126" href="#"></a></td>
<td><pre>        0x17179149, 0x1cb91000, 0x23744899, 0x2b73a840, 0x34e63b41,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4127" href="#"></a></td>
<td><pre>        0x40000000, 0x4cfa3cc1, 0x5c13d840, 0x6d91b519, 0x39aa400</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4128" href="#"></a></td>
<td><pre>    };</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4129" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4130" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4131" href="#"></a></td>
<td><pre>     * These routines provide access to the two's complement representation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4132" href="#"></a></td>
<td><pre>     * of BigIntegers.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4133" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4134" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4135" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4136" href="#"></a></td>
<td><pre>     * Returns the length of the two's complement representation in ints,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4137" href="#"></a></td>
<td><pre>     * including space for at least one sign bit.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4138" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4139" href="#"></a></td>
<td><pre>    private int intLength() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4140" href="#"></a></td>
<td><pre>        return (bitLength() &gt;&gt;&gt; 5) + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4141" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4142" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4143" href="#"></a></td>
<td><pre>    /* Returns sign bit */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4144" href="#"></a></td>
<td><pre>    private int signBit() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4145" href="#"></a></td>
<td><pre>        return signum &lt; 0 ? 1 : 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4146" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4147" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4148" href="#"></a></td>
<td><pre>    /* Returns an int of sign bits */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4149" href="#"></a></td>
<td><pre>    private int signInt() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4150" href="#"></a></td>
<td><pre>        return signum &lt; 0 ? -1 : 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4151" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4152" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4153" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4154" href="#"></a></td>
<td><pre>     * Returns the specified int of the little-endian two's complement</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4155" href="#"></a></td>
<td><pre>     * representation (int 0 is the least significant).  The int number can</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4156" href="#"></a></td>
<td><pre>     * be arbitrarily high (values are logically preceded by infinitely many</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4157" href="#"></a></td>
<td><pre>     * sign ints).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4158" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4159" href="#"></a></td>
<td><pre>    private int getInt(int n) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4160" href="#"></a></td>
<td><pre>        if (n &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4161" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4162" href="#"></a></td>
<td><pre>        if (n &gt;= mag.length)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4163" href="#"></a></td>
<td><pre>            return signInt();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4164" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4165" href="#"></a></td>
<td><pre>        int magInt = mag[mag.length-n-1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4166" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4167" href="#"></a></td>
<td><pre>        return (signum &gt;= 0 ? magInt :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4168" href="#"></a></td>
<td><pre>                (n &lt;= firstNonzeroIntNum() ? -magInt : ~magInt));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4169" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4170" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4171" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4172" href="#"></a></td>
<td><pre>     * Returns the index of the int that contains the first nonzero int in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4173" href="#"></a></td>
<td><pre>     * little-endian binary representation of the magnitude (int 0 is the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4174" href="#"></a></td>
<td><pre>     * least significant). If the magnitude is zero, return value is undefined.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4175" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4176" href="#"></a></td>
<td><pre>    private int firstNonzeroIntNum() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4177" href="#"></a></td>
<td><pre>        int fn = firstNonzeroIntNum - 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4178" href="#"></a></td>
<td><pre>        if (fn == -2) { // firstNonzeroIntNum not initialized yet</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4179" href="#"></a></td>
<td><pre>            fn = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4180" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4181" href="#"></a></td>
<td><pre>            // Search for the first nonzero int</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4182" href="#"></a></td>
<td><pre>            int i;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4183" href="#"></a></td>
<td><pre>            int mlen = mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4184" href="#"></a></td>
<td><pre>            for (i = mlen - 1; i &gt;= 0 &amp;&amp; mag[i] == 0; i--)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4185" href="#"></a></td>
<td><pre>                ;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4186" href="#"></a></td>
<td><pre>            fn = mlen - i - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4187" href="#"></a></td>
<td><pre>            firstNonzeroIntNum = fn + 2; // offset by two to initialize</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4188" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4189" href="#"></a></td>
<td><pre>        return fn;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4190" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4191" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4192" href="#"></a></td>
<td><pre>    /** use serialVersionUID from JDK 1.1. for interoperability */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4193" href="#"></a></td>
<td><pre>    private static final long serialVersionUID = -8287574255936472291L;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4194" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4195" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4196" href="#"></a></td>
<td><pre>     * Serializable fields for BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4197" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4198" href="#"></a></td>
<td><pre>     * @serialField signum  int</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4199" href="#"></a></td>
<td><pre>     *              signum of this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4200" href="#"></a></td>
<td><pre>     * @serialField magnitude int[]</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4201" href="#"></a></td>
<td><pre>     *              magnitude array of this BigInteger.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4202" href="#"></a></td>
<td><pre>     * @serialField bitCount  int</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4203" href="#"></a></td>
<td><pre>     *              number of bits in this BigInteger</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4204" href="#"></a></td>
<td><pre>     * @serialField bitLength int</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4205" href="#"></a></td>
<td><pre>     *              the number of bits in the minimal two's-complement</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4206" href="#"></a></td>
<td><pre>     *              representation of this BigInteger</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4207" href="#"></a></td>
<td><pre>     * @serialField lowestSetBit int</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4208" href="#"></a></td>
<td><pre>     *              lowest set bit in the twos complement representation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4209" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4210" href="#"></a></td>
<td><pre>    private static final ObjectStreamField[] serialPersistentFields = {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4211" href="#"></a></td>
<td><pre>        new ObjectStreamField(&quot;signum&quot;, Integer.TYPE),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4212" href="#"></a></td>
<td><pre>        new ObjectStreamField(&quot;magnitude&quot;, byte[].class),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4213" href="#"></a></td>
<td><pre>        new ObjectStreamField(&quot;bitCount&quot;, Integer.TYPE),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4214" href="#"></a></td>
<td><pre>        new ObjectStreamField(&quot;bitLength&quot;, Integer.TYPE),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4215" href="#"></a></td>
<td><pre>        new ObjectStreamField(&quot;firstNonzeroByteNum&quot;, Integer.TYPE),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4216" href="#"></a></td>
<td><pre>        new ObjectStreamField(&quot;lowestSetBit&quot;, Integer.TYPE)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4217" href="#"></a></td>
<td><pre>        };</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4218" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4219" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4220" href="#"></a></td>
<td><pre>     * Reconstitute the {@code BigInteger} instance from a stream (that is,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4221" href="#"></a></td>
<td><pre>     * deserialize it). The magnitude is read in as an array of bytes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4222" href="#"></a></td>
<td><pre>     * for historical reasons, but it is converted to an array of ints</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4223" href="#"></a></td>
<td><pre>     * and the byte array is discarded.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4224" href="#"></a></td>
<td><pre>     * Note:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4225" href="#"></a></td>
<td><pre>     * The current convention is to initialize the cache fields, bitCount,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4226" href="#"></a></td>
<td><pre>     * bitLength and lowestSetBit, to 0 rather than some other marker value.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4227" href="#"></a></td>
<td><pre>     * Therefore, no explicit action to set these fields needs to be taken in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4228" href="#"></a></td>
<td><pre>     * readObject because those fields already have a 0 value be default since</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4229" href="#"></a></td>
<td><pre>     * defaultReadObject is not being used.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4230" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4231" href="#"></a></td>
<td><pre>    private void readObject(java.io.ObjectInputStream s)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4232" href="#"></a></td>
<td><pre>        throws java.io.IOException, ClassNotFoundException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4233" href="#"></a></td>
<td><pre>        /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4234" href="#"></a></td>
<td><pre>         * In order to maintain compatibility with previous serialized forms,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4235" href="#"></a></td>
<td><pre>         * the magnitude of a BigInteger is serialized as an array of bytes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4236" href="#"></a></td>
<td><pre>         * The magnitude field is used as a temporary store for the byte array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4237" href="#"></a></td>
<td><pre>         * that is deserialized. The cached computation fields should be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4238" href="#"></a></td>
<td><pre>         * transient but are serialized for compatibility reasons.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4239" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4240" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4241" href="#"></a></td>
<td><pre>        // prepare to read the alternate persistent fields</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4242" href="#"></a></td>
<td><pre>        ObjectInputStream.GetField fields = s.readFields();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4243" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4244" href="#"></a></td>
<td><pre>        // Read the alternate persistent fields that we care about</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4245" href="#"></a></td>
<td><pre>        int sign = fields.get(&quot;signum&quot;, -2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4246" href="#"></a></td>
<td><pre>        byte[] magnitude = (byte[])fields.get(&quot;magnitude&quot;, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4247" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4248" href="#"></a></td>
<td><pre>        // Validate signum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4249" href="#"></a></td>
<td><pre>        if (sign &lt; -1 || sign &gt; 1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4250" href="#"></a></td>
<td><pre>            String message = &quot;BigInteger: Invalid signum value&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4251" href="#"></a></td>
<td><pre>            if (fields.defaulted(&quot;signum&quot;))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4252" href="#"></a></td>
<td><pre>                message = &quot;BigInteger: Signum not present in stream&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4253" href="#"></a></td>
<td><pre>            throw new java.io.StreamCorruptedException(message);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4254" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4255" href="#"></a></td>
<td><pre>        int[] mag = stripLeadingZeroBytes(magnitude);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4256" href="#"></a></td>
<td><pre>        if ((mag.length == 0) != (sign == 0)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4257" href="#"></a></td>
<td><pre>            String message = &quot;BigInteger: signum-magnitude mismatch&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4258" href="#"></a></td>
<td><pre>            if (fields.defaulted(&quot;magnitude&quot;))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4259" href="#"></a></td>
<td><pre>                message = &quot;BigInteger: Magnitude not present in stream&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4260" href="#"></a></td>
<td><pre>            throw new java.io.StreamCorruptedException(message);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4261" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4262" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4263" href="#"></a></td>
<td><pre>        // Commit final fields via Unsafe</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4264" href="#"></a></td>
<td><pre>        UnsafeHolder.putSign(this, sign);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4265" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4266" href="#"></a></td>
<td><pre>        // Calculate mag field from magnitude and discard magnitude</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4267" href="#"></a></td>
<td><pre>        UnsafeHolder.putMag(this, mag);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4268" href="#"></a></td>
<td><pre>        if (mag.length &gt;= MAX_MAG_LENGTH) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4269" href="#"></a></td>
<td><pre>            try {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4270" href="#"></a></td>
<td><pre>                checkRange();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4271" href="#"></a></td>
<td><pre>            } catch (ArithmeticException e) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4272" href="#"></a></td>
<td><pre>                throw new java.io.StreamCorruptedException(&quot;BigInteger: Out of the supported range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4273" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4274" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4275" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4276" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4277" href="#"></a></td>
<td><pre>    // Support for resetting final fields while deserializing</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4278" href="#"></a></td>
<td><pre>    private static class UnsafeHolder {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4279" href="#"></a></td>
<td><pre>        private static final sun.misc.Unsafe unsafe;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4280" href="#"></a></td>
<td><pre>        private static final long signumOffset;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4281" href="#"></a></td>
<td><pre>        private static final long magOffset;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4282" href="#"></a></td>
<td><pre>        static {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4283" href="#"></a></td>
<td><pre>            try {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4284" href="#"></a></td>
<td><pre>                unsafe = sun.misc.Unsafe.getUnsafe();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4285" href="#"></a></td>
<td><pre>                signumOffset = unsafe.objectFieldOffset</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4286" href="#"></a></td>
<td><pre>                    (BigInteger.class.getDeclaredField(&quot;signum&quot;));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4287" href="#"></a></td>
<td><pre>                magOffset = unsafe.objectFieldOffset</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4288" href="#"></a></td>
<td><pre>                    (BigInteger.class.getDeclaredField(&quot;mag&quot;));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4289" href="#"></a></td>
<td><pre>            } catch (Exception ex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4290" href="#"></a></td>
<td><pre>                throw new ExceptionInInitializerError(ex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4291" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4292" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4293" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4294" href="#"></a></td>
<td><pre>        static void putSign(BigInteger bi, int sign) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4295" href="#"></a></td>
<td><pre>            unsafe.putIntVolatile(bi, signumOffset, sign);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4296" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4297" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4298" href="#"></a></td>
<td><pre>        static void putMag(BigInteger bi, int[] magnitude) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4299" href="#"></a></td>
<td><pre>            unsafe.putObjectVolatile(bi, magOffset, magnitude);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4300" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4301" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4302" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4303" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4304" href="#"></a></td>
<td><pre>     * Save the {@code BigInteger} instance to a stream.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4305" href="#"></a></td>
<td><pre>     * The magnitude of a BigInteger is serialized as a byte array for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4306" href="#"></a></td>
<td><pre>     * historical reasons.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4307" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4308" href="#"></a></td>
<td><pre>     * @serialData two necessary fields are written as well as obsolete</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4309" href="#"></a></td>
<td><pre>     *             fields for compatibility with older versions.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4310" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4311" href="#"></a></td>
<td><pre>    private void writeObject(ObjectOutputStream s) throws IOException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4312" href="#"></a></td>
<td><pre>        // set the values of the Serializable fields</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4313" href="#"></a></td>
<td><pre>        ObjectOutputStream.PutField fields = s.putFields();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4314" href="#"></a></td>
<td><pre>        fields.put(&quot;signum&quot;, signum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4315" href="#"></a></td>
<td><pre>        fields.put(&quot;magnitude&quot;, magSerializedForm());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4316" href="#"></a></td>
<td><pre>        // The values written for cached fields are compatible with older</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4317" href="#"></a></td>
<td><pre>        // versions, but are ignored in readObject so don't otherwise matter.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4318" href="#"></a></td>
<td><pre>        fields.put(&quot;bitCount&quot;, -1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4319" href="#"></a></td>
<td><pre>        fields.put(&quot;bitLength&quot;, -1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4320" href="#"></a></td>
<td><pre>        fields.put(&quot;lowestSetBit&quot;, -2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4321" href="#"></a></td>
<td><pre>        fields.put(&quot;firstNonzeroByteNum&quot;, -2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4322" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4323" href="#"></a></td>
<td><pre>        // save them</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4324" href="#"></a></td>
<td><pre>        s.writeFields();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4325" href="#"></a></td>
<td><pre>}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4326" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4327" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4328" href="#"></a></td>
<td><pre>     * Returns the mag array as an array of bytes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4329" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4330" href="#"></a></td>
<td><pre>    private byte[] magSerializedForm() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4331" href="#"></a></td>
<td><pre>        int len = mag.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4332" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4333" href="#"></a></td>
<td><pre>        int bitLen = (len == 0 ? 0 : ((len - 1) &lt;&lt; 5) + bitLengthForInt(mag[0]));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4334" href="#"></a></td>
<td><pre>        int byteLen = (bitLen + 7) &gt;&gt;&gt; 3;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4335" href="#"></a></td>
<td><pre>        byte[] result = new byte[byteLen];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4336" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4337" href="#"></a></td>
<td><pre>        for (int i = byteLen - 1, bytesCopied = 4, intIndex = len - 1, nextInt = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4338" href="#"></a></td>
<td><pre>             i &gt;= 0; i--) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4339" href="#"></a></td>
<td><pre>            if (bytesCopied == 4) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4340" href="#"></a></td>
<td><pre>                nextInt = mag[intIndex--];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4341" href="#"></a></td>
<td><pre>                bytesCopied = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4342" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4343" href="#"></a></td>
<td><pre>                nextInt &gt;&gt;&gt;= 8;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4344" href="#"></a></td>
<td><pre>                bytesCopied++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4345" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4346" href="#"></a></td>
<td><pre>            result[i] = (byte)nextInt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4347" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4348" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4349" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4350" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4351" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4352" href="#"></a></td>
<td><pre>     * Converts this {@code BigInteger} to a {@code long}, checking</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4353" href="#"></a></td>
<td><pre>     * for lost information.  If the value of this {@code BigInteger}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4354" href="#"></a></td>
<td><pre>     * is out of the range of the {@code long} type, then an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4355" href="#"></a></td>
<td><pre>     * {@code ArithmeticException} is thrown.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4356" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4357" href="#"></a></td>
<td><pre>     * @return this {@code BigInteger} converted to a {@code long}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4358" href="#"></a></td>
<td><pre>     * @throws ArithmeticException if the value of {@code this} will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4359" href="#"></a></td>
<td><pre>     * not exactly fit in a {@code long}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4360" href="#"></a></td>
<td><pre>     * @see BigInteger#longValue</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4361" href="#"></a></td>
<td><pre>     * @since  1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4362" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4363" href="#"></a></td>
<td><pre>    public long longValueExact() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4364" href="#"></a></td>
<td><pre>        if (mag.length &lt;= 2 &amp;&amp; bitLength() &lt;= 63)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4365" href="#"></a></td>
<td><pre>            return longValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4366" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4367" href="#"></a></td>
<td><pre>            throw new ArithmeticException(&quot;BigInteger out of long range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4368" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4369" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4370" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4371" href="#"></a></td>
<td><pre>     * Converts this {@code BigInteger} to an {@code int}, checking</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4372" href="#"></a></td>
<td><pre>     * for lost information.  If the value of this {@code BigInteger}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4373" href="#"></a></td>
<td><pre>     * is out of the range of the {@code int} type, then an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4374" href="#"></a></td>
<td><pre>     * {@code ArithmeticException} is thrown.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4375" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4376" href="#"></a></td>
<td><pre>     * @return this {@code BigInteger} converted to an {@code int}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4377" href="#"></a></td>
<td><pre>     * @throws ArithmeticException if the value of {@code this} will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4378" href="#"></a></td>
<td><pre>     * not exactly fit in a {@code int}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4379" href="#"></a></td>
<td><pre>     * @see BigInteger#intValue</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4380" href="#"></a></td>
<td><pre>     * @since  1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4381" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4382" href="#"></a></td>
<td><pre>    public int intValueExact() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4383" href="#"></a></td>
<td><pre>        if (mag.length &lt;= 1 &amp;&amp; bitLength() &lt;= 31)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4384" href="#"></a></td>
<td><pre>            return intValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4385" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4386" href="#"></a></td>
<td><pre>            throw new ArithmeticException(&quot;BigInteger out of int range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4387" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4388" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4389" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4390" href="#"></a></td>
<td><pre>     * Converts this {@code BigInteger} to a {@code short}, checking</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4391" href="#"></a></td>
<td><pre>     * for lost information.  If the value of this {@code BigInteger}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4392" href="#"></a></td>
<td><pre>     * is out of the range of the {@code short} type, then an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4393" href="#"></a></td>
<td><pre>     * {@code ArithmeticException} is thrown.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4394" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4395" href="#"></a></td>
<td><pre>     * @return this {@code BigInteger} converted to a {@code short}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4396" href="#"></a></td>
<td><pre>     * @throws ArithmeticException if the value of {@code this} will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4397" href="#"></a></td>
<td><pre>     * not exactly fit in a {@code short}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4398" href="#"></a></td>
<td><pre>     * @see BigInteger#shortValue</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4399" href="#"></a></td>
<td><pre>     * @since  1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4400" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4401" href="#"></a></td>
<td><pre>    public short shortValueExact() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4402" href="#"></a></td>
<td><pre>        if (mag.length &lt;= 1 &amp;&amp; bitLength() &lt;= 31) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4403" href="#"></a></td>
<td><pre>            int value = intValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4404" href="#"></a></td>
<td><pre>            if (value &gt;= Short.MIN_VALUE &amp;&amp; value &lt;= Short.MAX_VALUE)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4405" href="#"></a></td>
<td><pre>                return shortValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4406" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4407" href="#"></a></td>
<td><pre>        throw new ArithmeticException(&quot;BigInteger out of short range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4408" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4409" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4410" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4411" href="#"></a></td>
<td><pre>     * Converts this {@code BigInteger} to a {@code byte}, checking</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4412" href="#"></a></td>
<td><pre>     * for lost information.  If the value of this {@code BigInteger}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4413" href="#"></a></td>
<td><pre>     * is out of the range of the {@code byte} type, then an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4414" href="#"></a></td>
<td><pre>     * {@code ArithmeticException} is thrown.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4415" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4416" href="#"></a></td>
<td><pre>     * @return this {@code BigInteger} converted to a {@code byte}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4417" href="#"></a></td>
<td><pre>     * @throws ArithmeticException if the value of {@code this} will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4418" href="#"></a></td>
<td><pre>     * not exactly fit in a {@code byte}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4419" href="#"></a></td>
<td><pre>     * @see BigInteger#byteValue</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4420" href="#"></a></td>
<td><pre>     * @since  1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4421" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4422" href="#"></a></td>
<td><pre>    public byte byteValueExact() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4423" href="#"></a></td>
<td><pre>        if (mag.length &lt;= 1 &amp;&amp; bitLength() &lt;= 31) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4424" href="#"></a></td>
<td><pre>            int value = intValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4425" href="#"></a></td>
<td><pre>            if (value &gt;= Byte.MIN_VALUE &amp;&amp; value &lt;= Byte.MAX_VALUE)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4426" href="#"></a></td>
<td><pre>                return byteValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4427" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4428" href="#"></a></td>
<td><pre>        throw new ArithmeticException(&quot;BigInteger out of byte range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4429" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4430" href="#"></a></td>
<td><pre>}</pre></td>
</tr>
</table>
</body>
</html>
