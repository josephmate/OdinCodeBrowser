<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package java.sql;

/**
 * Comprehensive information about the database as a whole.
 * &lt;P&gt;
 * This interface is implemented by driver vendors to let users know the capabilities
 * of a Database Management System (DBMS) in combination with
 * the driver based on JDBC&amp;trade; technology
 * (&quot;JDBC driver&quot;) that is used with it.  Different relational DBMSs often support
 * different features, implement features in different ways, and use different
 * data types.  In addition, a driver may implement a feature on top of what the
 * DBMS offers.  Information returned by methods in this interface applies
 * to the capabilities of a particular driver and a particular DBMS working
 * together. Note that as used in this documentation, the term &quot;database&quot; is
 * used generically to refer to both the driver and DBMS.
 * &lt;P&gt;
 * A user for this interface is commonly a tool that needs to discover how to
 * deal with the underlying DBMS.  This is especially true for applications
 * that are intended to be used with more than one DBMS. For example, a tool might use the method
 * &lt;code&gt;getTypeInfo&lt;/code&gt; to find out what data types can be used in a
 * &lt;code&gt;CREATE TABLE&lt;/code&gt; statement.  Or a user might call the method
 * &lt;code&gt;supportsCorrelatedSubqueries&lt;/code&gt; to see if it is possible to use
 * a correlated subquery or &lt;code&gt;supportsBatchUpdates&lt;/code&gt; to see if it is
 * possible to use batch updates.
 * &lt;P&gt;
 * Some &lt;code&gt;DatabaseMetaData&lt;/code&gt; methods return lists of information
 * in the form of &lt;code&gt;ResultSet&lt;/code&gt; objects.
 * Regular &lt;code&gt;ResultSet&lt;/code&gt; methods, such as
 * &lt;code&gt;getString&lt;/code&gt; and &lt;code&gt;getInt&lt;/code&gt;, can be used
 * to retrieve the data from these &lt;code&gt;ResultSet&lt;/code&gt; objects.  If
 * a given form of metadata is not available, an empty &lt;code&gt;ResultSet&lt;/code&gt;
 * will be returned. Additional columns beyond the columns defined to be
 * returned by the &lt;code&gt;ResultSet&lt;/code&gt; object for a given method
 * can be defined by the JDBC driver vendor and must be accessed
 * by their &lt;B&gt;column label&lt;/B&gt;.
 * &lt;P&gt;
 * Some &lt;code&gt;DatabaseMetaData&lt;/code&gt; methods take arguments that are
 * String patterns.  These arguments all have names such as fooPattern.
 * Within a pattern String, &quot;%&quot; means match any substring of 0 or more
 * characters, and &quot;_&quot; means match any one character. Only metadata
 * entries matching the search pattern are returned. If a search pattern
 * argument is set to &lt;code&gt;null&lt;/code&gt;, that argument's criterion will
 * be dropped from the search.
 *
 */
public interface DatabaseMetaData extends Wrapper {

    //----------------------------------------------------------------------
    // First, a variety of minor information about the target database.

    /**
     * Retrieves whether the current user can call all the procedures
     * returned by the method &lt;code&gt;getProcedures&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean allProceduresAreCallable() throws SQLException;

    /**
     * Retrieves whether the current user can use all the tables returned
     * by the method &lt;code&gt;getTables&lt;/code&gt; in a &lt;code&gt;SELECT&lt;/code&gt;
     * statement.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean allTablesAreSelectable() throws SQLException;

    /**
     * Retrieves the URL for this DBMS.
     *
     * @return the URL for this DBMS or &lt;code&gt;null&lt;/code&gt; if it cannot be
     *          generated
     * @exception SQLException if a database access error occurs
     */
    String getURL() throws SQLException;

    /**
     * Retrieves the user name as known to this database.
     *
     * @return the database user name
     * @exception SQLException if a database access error occurs
     */
    String getUserName() throws SQLException;

    /**
     * Retrieves whether this database is in read-only mode.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean isReadOnly() throws SQLException;

    /**
     * Retrieves whether &lt;code&gt;NULL&lt;/code&gt; values are sorted high.
     * Sorted high means that &lt;code&gt;NULL&lt;/code&gt; values
     * sort higher than any other value in a domain.  In an ascending order,
     * if this method returns &lt;code&gt;true&lt;/code&gt;,  &lt;code&gt;NULL&lt;/code&gt; values
     * will appear at the end. By contrast, the method
     * &lt;code&gt;nullsAreSortedAtEnd&lt;/code&gt; indicates whether &lt;code&gt;NULL&lt;/code&gt; values
     * are sorted at the end regardless of sort order.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean nullsAreSortedHigh() throws SQLException;

    /**
     * Retrieves whether &lt;code&gt;NULL&lt;/code&gt; values are sorted low.
     * Sorted low means that &lt;code&gt;NULL&lt;/code&gt; values
     * sort lower than any other value in a domain.  In an ascending order,
     * if this method returns &lt;code&gt;true&lt;/code&gt;,  &lt;code&gt;NULL&lt;/code&gt; values
     * will appear at the beginning. By contrast, the method
     * &lt;code&gt;nullsAreSortedAtStart&lt;/code&gt; indicates whether &lt;code&gt;NULL&lt;/code&gt; values
     * are sorted at the beginning regardless of sort order.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean nullsAreSortedLow() throws SQLException;

    /**
     * Retrieves whether &lt;code&gt;NULL&lt;/code&gt; values are sorted at the start regardless
     * of sort order.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean nullsAreSortedAtStart() throws SQLException;

    /**
     * Retrieves whether &lt;code&gt;NULL&lt;/code&gt; values are sorted at the end regardless of
     * sort order.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean nullsAreSortedAtEnd() throws SQLException;

    /**
     * Retrieves the name of this database product.
     *
     * @return database product name
     * @exception SQLException if a database access error occurs
     */
    String getDatabaseProductName() throws SQLException;

    /**
     * Retrieves the version number of this database product.
     *
     * @return database version number
     * @exception SQLException if a database access error occurs
     */
    String getDatabaseProductVersion() throws SQLException;

    /**
     * Retrieves the name of this JDBC driver.
     *
     * @return JDBC driver name
     * @exception SQLException if a database access error occurs
     */
    String getDriverName() throws SQLException;

    /**
     * Retrieves the version number of this JDBC driver as a &lt;code&gt;String&lt;/code&gt;.
     *
     * @return JDBC driver version
     * @exception SQLException if a database access error occurs
     */
    String getDriverVersion() throws SQLException;

    /**
     * Retrieves this JDBC driver's major version number.
     *
     * @return JDBC driver major version
     */
    int getDriverMajorVersion();

    /**
     * Retrieves this JDBC driver's minor version number.
     *
     * @return JDBC driver minor version number
     */
    int getDriverMinorVersion();

    /**
     * Retrieves whether this database stores tables in a local file.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean usesLocalFiles() throws SQLException;

    /**
     * Retrieves whether this database uses a file for each table.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this database uses a local file for each table;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean usesLocalFilePerTable() throws SQLException;

    /**
     * Retrieves whether this database treats mixed case unquoted SQL identifiers as
     * case sensitive and as a result stores them in mixed case.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsMixedCaseIdentifiers() throws SQLException;

    /**
     * Retrieves whether this database treats mixed case unquoted SQL identifiers as
     * case insensitive and stores them in upper case.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean storesUpperCaseIdentifiers() throws SQLException;

    /**
     * Retrieves whether this database treats mixed case unquoted SQL identifiers as
     * case insensitive and stores them in lower case.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean storesLowerCaseIdentifiers() throws SQLException;

    /**
     * Retrieves whether this database treats mixed case unquoted SQL identifiers as
     * case insensitive and stores them in mixed case.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean storesMixedCaseIdentifiers() throws SQLException;

    /**
     * Retrieves whether this database treats mixed case quoted SQL identifiers as
     * case sensitive and as a result stores them in mixed case.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsMixedCaseQuotedIdentifiers() throws SQLException;

    /**
     * Retrieves whether this database treats mixed case quoted SQL identifiers as
     * case insensitive and stores them in upper case.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean storesUpperCaseQuotedIdentifiers() throws SQLException;

    /**
     * Retrieves whether this database treats mixed case quoted SQL identifiers as
     * case insensitive and stores them in lower case.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean storesLowerCaseQuotedIdentifiers() throws SQLException;

    /**
     * Retrieves whether this database treats mixed case quoted SQL identifiers as
     * case insensitive and stores them in mixed case.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean storesMixedCaseQuotedIdentifiers() throws SQLException;

    /**
     * Retrieves the string used to quote SQL identifiers.
     * This method returns a space &quot; &quot; if identifier quoting is not supported.
     *
     * @return the quoting string or a space if quoting is not supported
     * @exception SQLException if a database access error occurs
     */
    String getIdentifierQuoteString() throws SQLException;

    /**
     * Retrieves a comma-separated list of all of this database's SQL keywords
     * that are NOT also SQL:2003 keywords.
     *
     * @return the list of this database's keywords that are not also
     *         SQL:2003 keywords
     * @exception SQLException if a database access error occurs
     */
    String getSQLKeywords() throws SQLException;

    /**
     * Retrieves a comma-separated list of math functions available with
     * this database.  These are the Open /Open CLI math function names used in
     * the JDBC function escape clause.
     *
     * @return the list of math functions supported by this database
     * @exception SQLException if a database access error occurs
     */
    String getNumericFunctions() throws SQLException;

    /**
     * Retrieves a comma-separated list of string functions available with
     * this database.  These are the  Open Group CLI string function names used
     * in the JDBC function escape clause.
     *
     * @return the list of string functions supported by this database
     * @exception SQLException if a database access error occurs
     */
    String getStringFunctions() throws SQLException;

    /**
     * Retrieves a comma-separated list of system functions available with
     * this database.  These are the  Open Group CLI system function names used
     * in the JDBC function escape clause.
     *
     * @return a list of system functions supported by this database
     * @exception SQLException if a database access error occurs
     */
    String getSystemFunctions() throws SQLException;

    /**
     * Retrieves a comma-separated list of the time and date functions available
     * with this database.
     *
     * @return the list of time and date functions supported by this database
     * @exception SQLException if a database access error occurs
     */
    String getTimeDateFunctions() throws SQLException;

    /**
     * Retrieves the string that can be used to escape wildcard characters.
     * This is the string that can be used to escape '_' or '%' in
     * the catalog search parameters that are a pattern (and therefore use one
     * of the wildcard characters).
     *
     * &lt;P&gt;The '_' character represents any single character;
     * the '%' character represents any sequence of zero or
     * more characters.
     *
     * @return the string used to escape wildcard characters
     * @exception SQLException if a database access error occurs
     */
    String getSearchStringEscape() throws SQLException;

    /**
     * Retrieves all the &quot;extra&quot; characters that can be used in unquoted
     * identifier names (those beyond a-z, A-Z, 0-9 and _).
     *
     * @return the string containing the extra characters
     * @exception SQLException if a database access error occurs
     */
    String getExtraNameCharacters() throws SQLException;

    //--------------------------------------------------------------------
    // Functions describing which features are supported.

    /**
     * Retrieves whether this database supports &lt;code&gt;ALTER TABLE&lt;/code&gt;
     * with add column.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsAlterTableWithAddColumn() throws SQLException;

    /**
     * Retrieves whether this database supports &lt;code&gt;ALTER TABLE&lt;/code&gt;
     * with drop column.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsAlterTableWithDropColumn() throws SQLException;

    /**
     * Retrieves whether this database supports column aliasing.
     *
     * &lt;P&gt;If so, the SQL AS clause can be used to provide names for
     * computed columns or to provide alias names for columns as
     * required.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsColumnAliasing() throws SQLException;

    /**
     * Retrieves whether this database supports concatenations between
     * &lt;code&gt;NULL&lt;/code&gt; and non-&lt;code&gt;NULL&lt;/code&gt; values being
     * &lt;code&gt;NULL&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean nullPlusNonNullIsNull() throws SQLException;

    /**
     * Retrieves whether this database supports the JDBC scalar function
     * &lt;code&gt;CONVERT&lt;/code&gt; for the conversion of one JDBC type to another.
     * The JDBC types are the generic SQL data types defined
     * in &lt;code&gt;java.sql.Types&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsConvert() throws SQLException;

    /**
     * Retrieves whether this database supports the JDBC scalar function
     * &lt;code&gt;CONVERT&lt;/code&gt; for conversions between the JDBC types &lt;i&gt;fromType&lt;/i&gt;
     * and &lt;i&gt;toType&lt;/i&gt;.  The JDBC types are the generic SQL data types defined
     * in &lt;code&gt;java.sql.Types&lt;/code&gt;.
     *
     * @param fromType the type to convert from; one of the type codes from
     *        the class &lt;code&gt;java.sql.Types&lt;/code&gt;
     * @param toType the type to convert to; one of the type codes from
     *        the class &lt;code&gt;java.sql.Types&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @see Types
     */
    boolean supportsConvert(int fromType, int toType) throws SQLException;

    /**
     * Retrieves whether this database supports table correlation names.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsTableCorrelationNames() throws SQLException;

    /**
     * Retrieves whether, when table correlation names are supported, they
     * are restricted to being different from the names of the tables.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsDifferentTableCorrelationNames() throws SQLException;

    /**
     * Retrieves whether this database supports expressions in
     * &lt;code&gt;ORDER BY&lt;/code&gt; lists.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsExpressionsInOrderBy() throws SQLException;

    /**
     * Retrieves whether this database supports using a column that is
     * not in the &lt;code&gt;SELECT&lt;/code&gt; statement in an
     * &lt;code&gt;ORDER BY&lt;/code&gt; clause.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsOrderByUnrelated() throws SQLException;

    /**
     * Retrieves whether this database supports some form of
     * &lt;code&gt;GROUP BY&lt;/code&gt; clause.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsGroupBy() throws SQLException;

    /**
     * Retrieves whether this database supports using a column that is
     * not in the &lt;code&gt;SELECT&lt;/code&gt; statement in a
     * &lt;code&gt;GROUP BY&lt;/code&gt; clause.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsGroupByUnrelated() throws SQLException;

    /**
     * Retrieves whether this database supports using columns not included in
     * the &lt;code&gt;SELECT&lt;/code&gt; statement in a &lt;code&gt;GROUP BY&lt;/code&gt; clause
     * provided that all of the columns in the &lt;code&gt;SELECT&lt;/code&gt; statement
     * are included in the &lt;code&gt;GROUP BY&lt;/code&gt; clause.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsGroupByBeyondSelect() throws SQLException;

    /**
     * Retrieves whether this database supports specifying a
     * &lt;code&gt;LIKE&lt;/code&gt; escape clause.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsLikeEscapeClause() throws SQLException;

    /**
     * Retrieves whether this database supports getting multiple
     * &lt;code&gt;ResultSet&lt;/code&gt; objects from a single call to the
     * method &lt;code&gt;execute&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsMultipleResultSets() throws SQLException;

    /**
     * Retrieves whether this database allows having multiple
     * transactions open at once (on different connections).
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsMultipleTransactions() throws SQLException;

    /**
     * Retrieves whether columns in this database may be defined as non-nullable.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsNonNullableColumns() throws SQLException;

    /**
     * Retrieves whether this database supports the ODBC Minimum SQL grammar.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsMinimumSQLGrammar() throws SQLException;

    /**
     * Retrieves whether this database supports the ODBC Core SQL grammar.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsCoreSQLGrammar() throws SQLException;

    /**
     * Retrieves whether this database supports the ODBC Extended SQL grammar.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsExtendedSQLGrammar() throws SQLException;

    /**
     * Retrieves whether this database supports the ANSI92 entry level SQL
     * grammar.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsANSI92EntryLevelSQL() throws SQLException;

    /**
     * Retrieves whether this database supports the ANSI92 intermediate SQL grammar supported.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsANSI92IntermediateSQL() throws SQLException;

    /**
     * Retrieves whether this database supports the ANSI92 full SQL grammar supported.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsANSI92FullSQL() throws SQLException;

    /**
     * Retrieves whether this database supports the SQL Integrity
     * Enhancement Facility.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsIntegrityEnhancementFacility() throws SQLException;

    /**
     * Retrieves whether this database supports some form of outer join.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsOuterJoins() throws SQLException;

    /**
     * Retrieves whether this database supports full nested outer joins.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsFullOuterJoins() throws SQLException;

    /**
     * Retrieves whether this database provides limited support for outer
     * joins.  (This will be &lt;code&gt;true&lt;/code&gt; if the method
     * &lt;code&gt;supportsFullOuterJoins&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;).
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsLimitedOuterJoins() throws SQLException;

    /**
     * Retrieves the database vendor's preferred term for &quot;schema&quot;.
     *
     * @return the vendor term for &quot;schema&quot;
     * @exception SQLException if a database access error occurs
     */
    String getSchemaTerm() throws SQLException;

    /**
     * Retrieves the database vendor's preferred term for &quot;procedure&quot;.
     *
     * @return the vendor term for &quot;procedure&quot;
     * @exception SQLException if a database access error occurs
     */
    String getProcedureTerm() throws SQLException;

    /**
     * Retrieves the database vendor's preferred term for &quot;catalog&quot;.
     *
     * @return the vendor term for &quot;catalog&quot;
     * @exception SQLException if a database access error occurs
     */
    String getCatalogTerm() throws SQLException;

    /**
     * Retrieves whether a catalog appears at the start of a fully qualified
     * table name.  If not, the catalog appears at the end.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the catalog name appears at the beginning
     *         of a fully qualified table name; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean isCatalogAtStart() throws SQLException;

    /**
     * Retrieves the &lt;code&gt;String&lt;/code&gt; that this database uses as the
     * separator between a catalog and table name.
     *
     * @return the separator string
     * @exception SQLException if a database access error occurs
     */
    String getCatalogSeparator() throws SQLException;

    /**
     * Retrieves whether a schema name can be used in a data manipulation statement.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsSchemasInDataManipulation() throws SQLException;

    /**
     * Retrieves whether a schema name can be used in a procedure call statement.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsSchemasInProcedureCalls() throws SQLException;

    /**
     * Retrieves whether a schema name can be used in a table definition statement.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsSchemasInTableDefinitions() throws SQLException;

    /**
     * Retrieves whether a schema name can be used in an index definition statement.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsSchemasInIndexDefinitions() throws SQLException;

    /**
     * Retrieves whether a schema name can be used in a privilege definition statement.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsSchemasInPrivilegeDefinitions() throws SQLException;

    /**
     * Retrieves whether a catalog name can be used in a data manipulation statement.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsCatalogsInDataManipulation() throws SQLException;

    /**
     * Retrieves whether a catalog name can be used in a procedure call statement.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsCatalogsInProcedureCalls() throws SQLException;

    /**
     * Retrieves whether a catalog name can be used in a table definition statement.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsCatalogsInTableDefinitions() throws SQLException;

    /**
     * Retrieves whether a catalog name can be used in an index definition statement.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsCatalogsInIndexDefinitions() throws SQLException;

    /**
     * Retrieves whether a catalog name can be used in a privilege definition statement.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsCatalogsInPrivilegeDefinitions() throws SQLException;


    /**
     * Retrieves whether this database supports positioned &lt;code&gt;DELETE&lt;/code&gt;
     * statements.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsPositionedDelete() throws SQLException;

    /**
     * Retrieves whether this database supports positioned &lt;code&gt;UPDATE&lt;/code&gt;
     * statements.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsPositionedUpdate() throws SQLException;

    /**
     * Retrieves whether this database supports &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;
     * statements.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsSelectForUpdate() throws SQLException;

    /**
     * Retrieves whether this database supports stored procedure calls
     * that use the stored procedure escape syntax.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsStoredProcedures() throws SQLException;

    /**
     * Retrieves whether this database supports subqueries in comparison
     * expressions.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsSubqueriesInComparisons() throws SQLException;

    /**
     * Retrieves whether this database supports subqueries in
     * &lt;code&gt;EXISTS&lt;/code&gt; expressions.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsSubqueriesInExists() throws SQLException;

    /**
     * Retrieves whether this database supports subqueries in
     * &lt;code&gt;IN&lt;/code&gt; expressions.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsSubqueriesInIns() throws SQLException;

    /**
     * Retrieves whether this database supports subqueries in quantified
     * expressions.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsSubqueriesInQuantifieds() throws SQLException;

    /**
     * Retrieves whether this database supports correlated subqueries.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsCorrelatedSubqueries() throws SQLException;

    /**
     * Retrieves whether this database supports SQL &lt;code&gt;UNION&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsUnion() throws SQLException;

    /**
     * Retrieves whether this database supports SQL &lt;code&gt;UNION ALL&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsUnionAll() throws SQLException;

    /**
     * Retrieves whether this database supports keeping cursors open
     * across commits.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if cursors always remain open;
     *       &lt;code&gt;false&lt;/code&gt; if they might not remain open
     * @exception SQLException if a database access error occurs
     */
    boolean supportsOpenCursorsAcrossCommit() throws SQLException;

    /**
     * Retrieves whether this database supports keeping cursors open
     * across rollbacks.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if cursors always remain open;
     *       &lt;code&gt;false&lt;/code&gt; if they might not remain open
     * @exception SQLException if a database access error occurs
     */
    boolean supportsOpenCursorsAcrossRollback() throws SQLException;

    /**
     * Retrieves whether this database supports keeping statements open
     * across commits.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if statements always remain open;
     *       &lt;code&gt;false&lt;/code&gt; if they might not remain open
     * @exception SQLException if a database access error occurs
     */
    boolean supportsOpenStatementsAcrossCommit() throws SQLException;

    /**
     * Retrieves whether this database supports keeping statements open
     * across rollbacks.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if statements always remain open;
     *       &lt;code&gt;false&lt;/code&gt; if they might not remain open
     * @exception SQLException if a database access error occurs
     */
    boolean supportsOpenStatementsAcrossRollback() throws SQLException;



    //----------------------------------------------------------------------
    // The following group of methods exposes various limitations
    // based on the target database with the current driver.
    // Unless otherwise specified, a result of zero means there is no
    // limit, or the limit is not known.

    /**
     * Retrieves the maximum number of hex characters this database allows in an
     * inline binary literal.
     *
     * @return max the maximum length (in hex characters) for a binary literal;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxBinaryLiteralLength() throws SQLException;

    /**
     * Retrieves the maximum number of characters this database allows
     * for a character literal.
     *
     * @return the maximum number of characters allowed for a character literal;
     *      a result of zero means that there is no limit or the limit is
     *      not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxCharLiteralLength() throws SQLException;

    /**
     * Retrieves the maximum number of characters this database allows
     * for a column name.
     *
     * @return the maximum number of characters allowed for a column name;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxColumnNameLength() throws SQLException;

    /**
     * Retrieves the maximum number of columns this database allows in a
     * &lt;code&gt;GROUP BY&lt;/code&gt; clause.
     *
     * @return the maximum number of columns allowed;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxColumnsInGroupBy() throws SQLException;

    /**
     * Retrieves the maximum number of columns this database allows in an index.
     *
     * @return the maximum number of columns allowed;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxColumnsInIndex() throws SQLException;

    /**
     * Retrieves the maximum number of columns this database allows in an
     * &lt;code&gt;ORDER BY&lt;/code&gt; clause.
     *
     * @return the maximum number of columns allowed;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxColumnsInOrderBy() throws SQLException;

    /**
     * Retrieves the maximum number of columns this database allows in a
     * &lt;code&gt;SELECT&lt;/code&gt; list.
     *
     * @return the maximum number of columns allowed;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxColumnsInSelect() throws SQLException;

    /**
     * Retrieves the maximum number of columns this database allows in a table.
     *
     * @return the maximum number of columns allowed;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxColumnsInTable() throws SQLException;

    /**
     * Retrieves the maximum number of concurrent connections to this
     * database that are possible.
     *
     * @return the maximum number of active connections possible at one time;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxConnections() throws SQLException;

    /**
     * Retrieves the maximum number of characters that this database allows in a
     * cursor name.
     *
     * @return the maximum number of characters allowed in a cursor name;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxCursorNameLength() throws SQLException;

    /**
     * Retrieves the maximum number of bytes this database allows for an
     * index, including all of the parts of the index.
     *
     * @return the maximum number of bytes allowed; this limit includes the
     *      composite of all the constituent parts of the index;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxIndexLength() throws SQLException;

    /**
     * Retrieves the maximum number of characters that this database allows in a
     * schema name.
     *
     * @return the maximum number of characters allowed in a schema name;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxSchemaNameLength() throws SQLException;

    /**
     * Retrieves the maximum number of characters that this database allows in a
     * procedure name.
     *
     * @return the maximum number of characters allowed in a procedure name;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxProcedureNameLength() throws SQLException;

    /**
     * Retrieves the maximum number of characters that this database allows in a
     * catalog name.
     *
     * @return the maximum number of characters allowed in a catalog name;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxCatalogNameLength() throws SQLException;

    /**
     * Retrieves the maximum number of bytes this database allows in
     * a single row.
     *
     * @return the maximum number of bytes allowed for a row; a result of
     *         zero means that there is no limit or the limit is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxRowSize() throws SQLException;

    /**
     * Retrieves whether the return value for the method
     * &lt;code&gt;getMaxRowSize&lt;/code&gt; includes the SQL data types
     * &lt;code&gt;LONGVARCHAR&lt;/code&gt; and &lt;code&gt;LONGVARBINARY&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean doesMaxRowSizeIncludeBlobs() throws SQLException;

    /**
     * Retrieves the maximum number of characters this database allows in
     * an SQL statement.
     *
     * @return the maximum number of characters allowed for an SQL statement;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxStatementLength() throws SQLException;

    /**
     * Retrieves the maximum number of active statements to this database
     * that can be open at the same time.
     *
     * @return the maximum number of statements that can be open at one time;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxStatements() throws SQLException;

    /**
     * Retrieves the maximum number of characters this database allows in
     * a table name.
     *
     * @return the maximum number of characters allowed for a table name;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxTableNameLength() throws SQLException;

    /**
     * Retrieves the maximum number of tables this database allows in a
     * &lt;code&gt;SELECT&lt;/code&gt; statement.
     *
     * @return the maximum number of tables allowed in a &lt;code&gt;SELECT&lt;/code&gt;
     *         statement; a result of zero means that there is no limit or
     *         the limit is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxTablesInSelect() throws SQLException;

    /**
     * Retrieves the maximum number of characters this database allows in
     * a user name.
     *
     * @return the maximum number of characters allowed for a user name;
     *      a result of zero means that there is no limit or the limit
     *      is not known
     * @exception SQLException if a database access error occurs
     */
    int getMaxUserNameLength() throws SQLException;

    //----------------------------------------------------------------------

    /**
     * Retrieves this database's default transaction isolation level.  The
     * possible values are defined in &lt;code&gt;java.sql.Connection&lt;/code&gt;.
     *
     * @return the default isolation level
     * @exception SQLException if a database access error occurs
     * @see Connection
     */
    int getDefaultTransactionIsolation() throws SQLException;

    /**
     * Retrieves whether this database supports transactions. If not, invoking the
     * method &lt;code&gt;commit&lt;/code&gt; is a noop, and the isolation level is
     * &lt;code&gt;TRANSACTION_NONE&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if transactions are supported;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsTransactions() throws SQLException;

    /**
     * Retrieves whether this database supports the given transaction isolation level.
     *
     * @param level one of the transaction isolation levels defined in
     *         &lt;code&gt;java.sql.Connection&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @see Connection
     */
    boolean supportsTransactionIsolationLevel(int level)
        throws SQLException;

    /**
     * Retrieves whether this database supports both data definition and
     * data manipulation statements within a transaction.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsDataDefinitionAndDataManipulationTransactions()
        throws SQLException;
    /**
     * Retrieves whether this database supports only data manipulation
     * statements within a transaction.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean supportsDataManipulationTransactionsOnly()
        throws SQLException;

    /**
     * Retrieves whether a data definition statement within a transaction forces
     * the transaction to commit.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean dataDefinitionCausesTransactionCommit()
        throws SQLException;

    /**
     * Retrieves whether this database ignores a data definition statement
     * within a transaction.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     */
    boolean dataDefinitionIgnoredInTransactions()
        throws SQLException;

    /**
     * Retrieves a description of the stored procedures available in the given
     * catalog.
     * &lt;P&gt;
     * Only procedure descriptions matching the schema and
     * procedure name criteria are returned.  They are ordered by
     * &lt;code&gt;PROCEDURE_CAT&lt;/code&gt;, &lt;code&gt;PROCEDURE_SCHEM&lt;/code&gt;,
     * &lt;code&gt;PROCEDURE_NAME&lt;/code&gt; and &lt;code&gt;SPECIFIC_ NAME&lt;/code&gt;.
     *
     * &lt;P&gt;Each procedure description has the the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;PROCEDURE_CAT&lt;/B&gt; String {@code =&gt;} procedure catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;PROCEDURE_SCHEM&lt;/B&gt; String {@code =&gt;} procedure schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;PROCEDURE_NAME&lt;/B&gt; String {@code =&gt;} procedure name
     *  &lt;LI&gt; reserved for future use
     *  &lt;LI&gt; reserved for future use
     *  &lt;LI&gt; reserved for future use
     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String {@code =&gt;} explanatory comment on the procedure
     *  &lt;LI&gt;&lt;B&gt;PROCEDURE_TYPE&lt;/B&gt; short {@code =&gt;} kind of procedure:
     *      &lt;UL&gt;
     *      &lt;LI&gt; procedureResultUnknown - Cannot determine if  a return value
     *       will be returned
     *      &lt;LI&gt; procedureNoResult - Does not return a return value
     *      &lt;LI&gt; procedureReturnsResult - Returns a return value
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;SPECIFIC_NAME&lt;/B&gt; String  {@code =&gt;} The name which uniquely identifies this
     * procedure within its schema.
     *  &lt;/OL&gt;
     * &lt;p&gt;
     * A user may not have permissions to execute any of the procedures that are
     * returned by &lt;code&gt;getProcedures&lt;/code&gt;
     *
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schemaPattern a schema name pattern; must match the schema name
     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param procedureNamePattern a procedure name pattern; must match the
     *        procedure name as it is stored in the database
     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a procedure description
     * @exception SQLException if a database access error occurs
     * @see #getSearchStringEscape
     */
    ResultSet getProcedures(String catalog, String schemaPattern,
                            String procedureNamePattern) throws SQLException;

    /**
     * Indicates that it is not known whether the procedure returns
     * a result.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;PROCEDURE_TYPE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getProcedures&lt;/code&gt;.
     */
    int procedureResultUnknown  = 0;

    /**
     * Indicates that the procedure does not return a result.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;PROCEDURE_TYPE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getProcedures&lt;/code&gt;.
     */
    int procedureNoResult               = 1;

    /**
     * Indicates that the procedure returns a result.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;PROCEDURE_TYPE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getProcedures&lt;/code&gt;.
     */
    int procedureReturnsResult  = 2;

    /**
     * Retrieves a description of the given catalog's stored procedure parameter
     * and result columns.
     *
     * &lt;P&gt;Only descriptions matching the schema, procedure and
     * parameter name criteria are returned.  They are ordered by
     * PROCEDURE_CAT, PROCEDURE_SCHEM, PROCEDURE_NAME and SPECIFIC_NAME. Within this, the return value,
     * if any, is first. Next are the parameter descriptions in call
     * order. The column descriptions follow in column number order.
     *
     * &lt;P&gt;Each row in the &lt;code&gt;ResultSet&lt;/code&gt; is a parameter description or
     * column description with the following fields:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;PROCEDURE_CAT&lt;/B&gt; String {@code =&gt;} procedure catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;PROCEDURE_SCHEM&lt;/B&gt; String {@code =&gt;} procedure schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;PROCEDURE_NAME&lt;/B&gt; String {@code =&gt;} procedure name
     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String {@code =&gt;} column/parameter name
     *  &lt;LI&gt;&lt;B&gt;COLUMN_TYPE&lt;/B&gt; Short {@code =&gt;} kind of column/parameter:
     *      &lt;UL&gt;
     *      &lt;LI&gt; procedureColumnUnknown - nobody knows
     *      &lt;LI&gt; procedureColumnIn - IN parameter
     *      &lt;LI&gt; procedureColumnInOut - INOUT parameter
     *      &lt;LI&gt; procedureColumnOut - OUT parameter
     *      &lt;LI&gt; procedureColumnReturn - procedure return value
     *      &lt;LI&gt; procedureColumnResult - result column in &lt;code&gt;ResultSet&lt;/code&gt;
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int {@code =&gt;} SQL type from java.sql.Types
     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String {@code =&gt;} SQL type name, for a UDT type the
     *  type name is fully qualified
     *  &lt;LI&gt;&lt;B&gt;PRECISION&lt;/B&gt; int {@code =&gt;} precision
     *  &lt;LI&gt;&lt;B&gt;LENGTH&lt;/B&gt; int {@code =&gt;} length in bytes of data
     *  &lt;LI&gt;&lt;B&gt;SCALE&lt;/B&gt; short {@code =&gt;} scale -  null is returned for data types where
     * SCALE is not applicable.
     *  &lt;LI&gt;&lt;B&gt;RADIX&lt;/B&gt; short {@code =&gt;} radix
     *  &lt;LI&gt;&lt;B&gt;NULLABLE&lt;/B&gt; short {@code =&gt;} can it contain NULL.
     *      &lt;UL&gt;
     *      &lt;LI&gt; procedureNoNulls - does not allow NULL values
     *      &lt;LI&gt; procedureNullable - allows NULL values
     *      &lt;LI&gt; procedureNullableUnknown - nullability unknown
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String {@code =&gt;} comment describing parameter/column
     *  &lt;LI&gt;&lt;B&gt;COLUMN_DEF&lt;/B&gt; String {@code =&gt;} default value for the column, which should be interpreted as a string when the value is enclosed in single quotes (may be &lt;code&gt;null&lt;/code&gt;)
     *      &lt;UL&gt;
     *      &lt;LI&gt; The string NULL (not enclosed in quotes) - if NULL was specified as the default value
     *      &lt;LI&gt; TRUNCATE (not enclosed in quotes)        - if the specified default value cannot be represented without truncation
     *      &lt;LI&gt; NULL                                     - if a default value was not specified
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;SQL_DATA_TYPE&lt;/B&gt; int  {@code =&gt;} reserved for future use
     *  &lt;LI&gt;&lt;B&gt;SQL_DATETIME_SUB&lt;/B&gt; int  {@code =&gt;} reserved for future use
     *  &lt;LI&gt;&lt;B&gt;CHAR_OCTET_LENGTH&lt;/B&gt; int  {@code =&gt;} the maximum length of binary and character based columns.  For any other datatype the returned value is a
     * NULL
     *  &lt;LI&gt;&lt;B&gt;ORDINAL_POSITION&lt;/B&gt; int  {@code =&gt;} the ordinal position, starting from 1, for the input and output parameters for a procedure. A value of 0
     *is returned if this row describes the procedure's return value.  For result set columns, it is the
     *ordinal position of the column in the result set starting from 1.  If there are
     *multiple result sets, the column ordinal positions are implementation
     * defined.
     *  &lt;LI&gt;&lt;B&gt;IS_NULLABLE&lt;/B&gt; String  {@code =&gt;} ISO rules are used to determine the nullability for a column.
     *       &lt;UL&gt;
     *       &lt;LI&gt; YES           --- if the column can include NULLs
     *       &lt;LI&gt; NO            --- if the column cannot include NULLs
     *       &lt;LI&gt; empty string  --- if the nullability for the
     * column is unknown
     *       &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;SPECIFIC_NAME&lt;/B&gt; String  {@code =&gt;} the name which uniquely identifies this procedure within its schema.
     *  &lt;/OL&gt;
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Some databases may not return the column
     * descriptions for a procedure.
     *
     * &lt;p&gt;The PRECISION column represents the specified column size for the given column.
     * For numeric data, this is the maximum precision.  For character data, this is the length in characters.
     * For datetime datatypes, this is the length in characters of the String representation (assuming the
     * maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes.  For the ROWID datatype,
     * this is the length in bytes. Null is returned for data types where the
     * column size is not applicable.
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schemaPattern a schema name pattern; must match the schema name
     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param procedureNamePattern a procedure name pattern; must match the
     *        procedure name as it is stored in the database
     * @param columnNamePattern a column name pattern; must match the column name
     *        as it is stored in the database
     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row describes a stored procedure parameter or
     *      column
     * @exception SQLException if a database access error occurs
     * @see #getSearchStringEscape
     */
    ResultSet getProcedureColumns(String catalog,
                                  String schemaPattern,
                                  String procedureNamePattern,
                                  String columnNamePattern) throws SQLException;

    /**
     * Indicates that type of the column is unknown.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;COLUMN_TYPE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt;
     * returned by the method &lt;code&gt;getProcedureColumns&lt;/code&gt;.
     */
    int procedureColumnUnknown = 0;

    /**
     * Indicates that the column stores IN parameters.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;COLUMN_TYPE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt;
     * returned by the method &lt;code&gt;getProcedureColumns&lt;/code&gt;.
     */
    int procedureColumnIn = 1;

    /**
     * Indicates that the column stores INOUT parameters.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;COLUMN_TYPE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt;
     * returned by the method &lt;code&gt;getProcedureColumns&lt;/code&gt;.
     */
    int procedureColumnInOut = 2;

    /**
     * Indicates that the column stores OUT parameters.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;COLUMN_TYPE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt;
    * returned by the method &lt;code&gt;getProcedureColumns&lt;/code&gt;.
     */
    int procedureColumnOut = 4;
    /**
     * Indicates that the column stores return values.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;COLUMN_TYPE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt;
     * returned by the method &lt;code&gt;getProcedureColumns&lt;/code&gt;.
     */
    int procedureColumnReturn = 5;

    /**
     * Indicates that the column stores results.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;COLUMN_TYPE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt;
     * returned by the method &lt;code&gt;getProcedureColumns&lt;/code&gt;.
     */
    int procedureColumnResult = 3;

    /**
     * Indicates that &lt;code&gt;NULL&lt;/code&gt; values are not allowed.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;NULLABLE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getProcedureColumns&lt;/code&gt;.
     */
    int procedureNoNulls = 0;

    /**
     * Indicates that &lt;code&gt;NULL&lt;/code&gt; values are allowed.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;NULLABLE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getProcedureColumns&lt;/code&gt;.
     */
    int procedureNullable = 1;

    /**
     * Indicates that whether &lt;code&gt;NULL&lt;/code&gt; values are allowed
     * is unknown.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;NULLABLE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getProcedureColumns&lt;/code&gt;.
     */
    int procedureNullableUnknown = 2;


    /**
     * Retrieves a description of the tables available in the given catalog.
     * Only table descriptions matching the catalog, schema, table
     * name and type criteria are returned.  They are ordered by
     * &lt;code&gt;TABLE_TYPE&lt;/code&gt;, &lt;code&gt;TABLE_CAT&lt;/code&gt;,
     * &lt;code&gt;TABLE_SCHEM&lt;/code&gt; and &lt;code&gt;TABLE_NAME&lt;/code&gt;.
     * &lt;P&gt;
     * Each table description has the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String {@code =&gt;} table catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String {@code =&gt;} table schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String {@code =&gt;} table name
     *  &lt;LI&gt;&lt;B&gt;TABLE_TYPE&lt;/B&gt; String {@code =&gt;} table type.  Typical types are &quot;TABLE&quot;,
     *                  &quot;VIEW&quot;, &quot;SYSTEM TABLE&quot;, &quot;GLOBAL TEMPORARY&quot;,
     *                  &quot;LOCAL TEMPORARY&quot;, &quot;ALIAS&quot;, &quot;SYNONYM&quot;.
     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String {@code =&gt;} explanatory comment on the table
     *  &lt;LI&gt;&lt;B&gt;TYPE_CAT&lt;/B&gt; String {@code =&gt;} the types catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TYPE_SCHEM&lt;/B&gt; String {@code =&gt;} the types schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String {@code =&gt;} type name (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;SELF_REFERENCING_COL_NAME&lt;/B&gt; String {@code =&gt;} name of the designated
     *                  &quot;identifier&quot; column of a typed table (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;REF_GENERATION&lt;/B&gt; String {@code =&gt;} specifies how values in
     *                  SELF_REFERENCING_COL_NAME are created. Values are
     *                  &quot;SYSTEM&quot;, &quot;USER&quot;, &quot;DERIVED&quot;. (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;/OL&gt;
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Some databases may not return information for
     * all tables.
     *
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schemaPattern a schema name pattern; must match the schema name
     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param tableNamePattern a table name pattern; must match the
     *        table name as it is stored in the database
     * @param types a list of table types, which must be from the list of table types
     *         returned from {@link #getTableTypes},to include; &lt;code&gt;null&lt;/code&gt; returns
     * all types
     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a table description
     * @exception SQLException if a database access error occurs
     * @see #getSearchStringEscape
     */
    ResultSet getTables(String catalog, String schemaPattern,
                        String tableNamePattern, String types[]) throws SQLException;

    /**
     * Retrieves the schema names available in this database.  The results
     * are ordered by &lt;code&gt;TABLE_CATALOG&lt;/code&gt; and
     * &lt;code&gt;TABLE_SCHEM&lt;/code&gt;.
     *
     * &lt;P&gt;The schema columns are:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String {@code =&gt;} schema name
     *  &lt;LI&gt;&lt;B&gt;TABLE_CATALOG&lt;/B&gt; String {@code =&gt;} catalog name (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;/OL&gt;
     *
     * @return a &lt;code&gt;ResultSet&lt;/code&gt; object in which each row is a
     *         schema description
     * @exception SQLException if a database access error occurs
     *
     */
    ResultSet getSchemas() throws SQLException;

    /**
     * Retrieves the catalog names available in this database.  The results
     * are ordered by catalog name.
     *
     * &lt;P&gt;The catalog column is:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String {@code =&gt;} catalog name
     *  &lt;/OL&gt;
     *
     * @return a &lt;code&gt;ResultSet&lt;/code&gt; object in which each row has a
     *         single &lt;code&gt;String&lt;/code&gt; column that is a catalog name
     * @exception SQLException if a database access error occurs
     */
    ResultSet getCatalogs() throws SQLException;

    /**
     * Retrieves the table types available in this database.  The results
     * are ordered by table type.
     *
     * &lt;P&gt;The table type is:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TABLE_TYPE&lt;/B&gt; String {@code =&gt;} table type.  Typical types are &quot;TABLE&quot;,
     *                  &quot;VIEW&quot;, &quot;SYSTEM TABLE&quot;, &quot;GLOBAL TEMPORARY&quot;,
     *                  &quot;LOCAL TEMPORARY&quot;, &quot;ALIAS&quot;, &quot;SYNONYM&quot;.
     *  &lt;/OL&gt;
     *
     * @return a &lt;code&gt;ResultSet&lt;/code&gt; object in which each row has a
     *         single &lt;code&gt;String&lt;/code&gt; column that is a table type
     * @exception SQLException if a database access error occurs
     */
    ResultSet getTableTypes() throws SQLException;

    /**
     * Retrieves a description of table columns available in
     * the specified catalog.
     *
     * &lt;P&gt;Only column descriptions matching the catalog, schema, table
     * and column name criteria are returned.  They are ordered by
     * &lt;code&gt;TABLE_CAT&lt;/code&gt;,&lt;code&gt;TABLE_SCHEM&lt;/code&gt;,
     * &lt;code&gt;TABLE_NAME&lt;/code&gt;, and &lt;code&gt;ORDINAL_POSITION&lt;/code&gt;.
     *
     * &lt;P&gt;Each column description has the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String {@code =&gt;} table catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String {@code =&gt;} table schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String {@code =&gt;} table name
     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String {@code =&gt;} column name
     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int {@code =&gt;} SQL type from java.sql.Types
     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String {@code =&gt;} Data source dependent type name,
     *  for a UDT the type name is fully qualified
     *  &lt;LI&gt;&lt;B&gt;COLUMN_SIZE&lt;/B&gt; int {@code =&gt;} column size.
     *  &lt;LI&gt;&lt;B&gt;BUFFER_LENGTH&lt;/B&gt; is not used.
     *  &lt;LI&gt;&lt;B&gt;DECIMAL_DIGITS&lt;/B&gt; int {@code =&gt;} the number of fractional digits. Null is returned for data types where
     * DECIMAL_DIGITS is not applicable.
     *  &lt;LI&gt;&lt;B&gt;NUM_PREC_RADIX&lt;/B&gt; int {@code =&gt;} Radix (typically either 10 or 2)
     *  &lt;LI&gt;&lt;B&gt;NULLABLE&lt;/B&gt; int {@code =&gt;} is NULL allowed.
     *      &lt;UL&gt;
     *      &lt;LI&gt; columnNoNulls - might not allow &lt;code&gt;NULL&lt;/code&gt; values
     *      &lt;LI&gt; columnNullable - definitely allows &lt;code&gt;NULL&lt;/code&gt; values
     *      &lt;LI&gt; columnNullableUnknown - nullability unknown
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String {@code =&gt;} comment describing column (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;COLUMN_DEF&lt;/B&gt; String {@code =&gt;} default value for the column, which should be interpreted as a string when the value is enclosed in single quotes (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;SQL_DATA_TYPE&lt;/B&gt; int {@code =&gt;} unused
     *  &lt;LI&gt;&lt;B&gt;SQL_DATETIME_SUB&lt;/B&gt; int {@code =&gt;} unused
     *  &lt;LI&gt;&lt;B&gt;CHAR_OCTET_LENGTH&lt;/B&gt; int {@code =&gt;} for char types the
     *       maximum number of bytes in the column
     *  &lt;LI&gt;&lt;B&gt;ORDINAL_POSITION&lt;/B&gt; int {@code =&gt;} index of column in table
     *      (starting at 1)
     *  &lt;LI&gt;&lt;B&gt;IS_NULLABLE&lt;/B&gt; String  {@code =&gt;} ISO rules are used to determine the nullability for a column.
     *       &lt;UL&gt;
     *       &lt;LI&gt; YES           --- if the column can include NULLs
     *       &lt;LI&gt; NO            --- if the column cannot include NULLs
     *       &lt;LI&gt; empty string  --- if the nullability for the
     * column is unknown
     *       &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;SCOPE_CATALOG&lt;/B&gt; String {@code =&gt;} catalog of table that is the scope
     *      of a reference attribute (&lt;code&gt;null&lt;/code&gt; if DATA_TYPE isn't REF)
     *  &lt;LI&gt;&lt;B&gt;SCOPE_SCHEMA&lt;/B&gt; String {@code =&gt;} schema of table that is the scope
     *      of a reference attribute (&lt;code&gt;null&lt;/code&gt; if the DATA_TYPE isn't REF)
     *  &lt;LI&gt;&lt;B&gt;SCOPE_TABLE&lt;/B&gt; String {@code =&gt;} table name that this the scope
     *      of a reference attribute (&lt;code&gt;null&lt;/code&gt; if the DATA_TYPE isn't REF)
     *  &lt;LI&gt;&lt;B&gt;SOURCE_DATA_TYPE&lt;/B&gt; short {@code =&gt;} source type of a distinct type or user-generated
     *      Ref type, SQL type from java.sql.Types (&lt;code&gt;null&lt;/code&gt; if DATA_TYPE
     *      isn't DISTINCT or user-generated REF)
     *   &lt;LI&gt;&lt;B&gt;IS_AUTOINCREMENT&lt;/B&gt; String  {@code =&gt;} Indicates whether this column is auto incremented
     *       &lt;UL&gt;
     *       &lt;LI&gt; YES           --- if the column is auto incremented
     *       &lt;LI&gt; NO            --- if the column is not auto incremented
     *       &lt;LI&gt; empty string  --- if it cannot be determined whether the column is auto incremented
     *       &lt;/UL&gt;
     *   &lt;LI&gt;&lt;B&gt;IS_GENERATEDCOLUMN&lt;/B&gt; String  {@code =&gt;} Indicates whether this is a generated column
     *       &lt;UL&gt;
     *       &lt;LI&gt; YES           --- if this a generated column
     *       &lt;LI&gt; NO            --- if this not a generated column
     *       &lt;LI&gt; empty string  --- if it cannot be determined whether this is a generated column
     *       &lt;/UL&gt;
     *  &lt;/OL&gt;
     *
     * &lt;p&gt;The COLUMN_SIZE column specifies the column size for the given column.
     * For numeric data, this is the maximum precision.  For character data, this is the length in characters.
     * For datetime datatypes, this is the length in characters of the String representation (assuming the
     * maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes.  For the ROWID datatype,
     * this is the length in bytes. Null is returned for data types where the
     * column size is not applicable.
     *
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schemaPattern a schema name pattern; must match the schema name
     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param tableNamePattern a table name pattern; must match the
     *        table name as it is stored in the database
     * @param columnNamePattern a column name pattern; must match the column
     *        name as it is stored in the database
     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a column description
     * @exception SQLException if a database access error occurs
     * @see #getSearchStringEscape
     */
    ResultSet getColumns(String catalog, String schemaPattern,
                         String tableNamePattern, String columnNamePattern)
        throws SQLException;

    /**
     * Indicates that the column might not allow &lt;code&gt;NULL&lt;/code&gt; values.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;NULLABLE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; returned by the method
     * &lt;code&gt;getColumns&lt;/code&gt;.
     */
    int columnNoNulls = 0;

    /**
     * Indicates that the column definitely allows &lt;code&gt;NULL&lt;/code&gt; values.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;NULLABLE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; returned by the method
     * &lt;code&gt;getColumns&lt;/code&gt;.
     */
    int columnNullable = 1;

    /**
     * Indicates that the nullability of columns is unknown.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;NULLABLE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; returned by the method
     * &lt;code&gt;getColumns&lt;/code&gt;.
     */
    int columnNullableUnknown = 2;

    /**
     * Retrieves a description of the access rights for a table's columns.
     *
     * &lt;P&gt;Only privileges matching the column name criteria are
     * returned.  They are ordered by COLUMN_NAME and PRIVILEGE.
     *
     * &lt;P&gt;Each privilege description has the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String {@code =&gt;} table catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String {@code =&gt;} table schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String {@code =&gt;} table name
     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String {@code =&gt;} column name
     *  &lt;LI&gt;&lt;B&gt;GRANTOR&lt;/B&gt; String {@code =&gt;} grantor of access (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;GRANTEE&lt;/B&gt; String {@code =&gt;} grantee of access
     *  &lt;LI&gt;&lt;B&gt;PRIVILEGE&lt;/B&gt; String {@code =&gt;} name of access (SELECT,
     *      INSERT, UPDATE, REFRENCES, ...)
     *  &lt;LI&gt;&lt;B&gt;IS_GRANTABLE&lt;/B&gt; String {@code =&gt;} &quot;YES&quot; if grantee is permitted
     *      to grant to others; &quot;NO&quot; if not; &lt;code&gt;null&lt;/code&gt; if unknown
     *  &lt;/OL&gt;
     *
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schema a schema name; must match the schema name as it is
     *        stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param table a table name; must match the table name as it is
     *        stored in the database
     * @param columnNamePattern a column name pattern; must match the column
     *        name as it is stored in the database
     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a column privilege description
     * @exception SQLException if a database access error occurs
     * @see #getSearchStringEscape
     */
    ResultSet getColumnPrivileges(String catalog, String schema,
                                  String table, String columnNamePattern) throws SQLException;

    /**
     * Retrieves a description of the access rights for each table available
     * in a catalog. Note that a table privilege applies to one or
     * more columns in the table. It would be wrong to assume that
     * this privilege applies to all columns (this may be true for
     * some systems but is not true for all.)
     *
     * &lt;P&gt;Only privileges matching the schema and table name
     * criteria are returned.  They are ordered by
     * &lt;code&gt;TABLE_CAT&lt;/code&gt;,
     * &lt;code&gt;TABLE_SCHEM&lt;/code&gt;, &lt;code&gt;TABLE_NAME&lt;/code&gt;,
     * and &lt;code&gt;PRIVILEGE&lt;/code&gt;.
     *
     * &lt;P&gt;Each privilege description has the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String {@code =&gt;} table catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String {@code =&gt;} table schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String {@code =&gt;} table name
     *  &lt;LI&gt;&lt;B&gt;GRANTOR&lt;/B&gt; String {@code =&gt;} grantor of access (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;GRANTEE&lt;/B&gt; String {@code =&gt;} grantee of access
     *  &lt;LI&gt;&lt;B&gt;PRIVILEGE&lt;/B&gt; String {@code =&gt;} name of access (SELECT,
     *      INSERT, UPDATE, REFRENCES, ...)
     *  &lt;LI&gt;&lt;B&gt;IS_GRANTABLE&lt;/B&gt; String {@code =&gt;} &quot;YES&quot; if grantee is permitted
     *      to grant to others; &quot;NO&quot; if not; &lt;code&gt;null&lt;/code&gt; if unknown
     *  &lt;/OL&gt;
     *
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schemaPattern a schema name pattern; must match the schema name
     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param tableNamePattern a table name pattern; must match the
     *        table name as it is stored in the database
     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a table privilege description
     * @exception SQLException if a database access error occurs
     * @see #getSearchStringEscape
     */
    ResultSet getTablePrivileges(String catalog, String schemaPattern,
                                 String tableNamePattern) throws SQLException;

    /**
     * Retrieves a description of a table's optimal set of columns that
     * uniquely identifies a row. They are ordered by SCOPE.
     *
     * &lt;P&gt;Each column description has the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;SCOPE&lt;/B&gt; short {@code =&gt;} actual scope of result
     *      &lt;UL&gt;
     *      &lt;LI&gt; bestRowTemporary - very temporary, while using row
     *      &lt;LI&gt; bestRowTransaction - valid for remainder of current transaction
     *      &lt;LI&gt; bestRowSession - valid for remainder of current session
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String {@code =&gt;} column name
     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int {@code =&gt;} SQL data type from java.sql.Types
     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String {@code =&gt;} Data source dependent type name,
     *  for a UDT the type name is fully qualified
     *  &lt;LI&gt;&lt;B&gt;COLUMN_SIZE&lt;/B&gt; int {@code =&gt;} precision
     *  &lt;LI&gt;&lt;B&gt;BUFFER_LENGTH&lt;/B&gt; int {@code =&gt;} not used
     *  &lt;LI&gt;&lt;B&gt;DECIMAL_DIGITS&lt;/B&gt; short  {@code =&gt;} scale - Null is returned for data types where
     * DECIMAL_DIGITS is not applicable.
     *  &lt;LI&gt;&lt;B&gt;PSEUDO_COLUMN&lt;/B&gt; short {@code =&gt;} is this a pseudo column
     *      like an Oracle ROWID
     *      &lt;UL&gt;
     *      &lt;LI&gt; bestRowUnknown - may or may not be pseudo column
     *      &lt;LI&gt; bestRowNotPseudo - is NOT a pseudo column
     *      &lt;LI&gt; bestRowPseudo - is a pseudo column
     *      &lt;/UL&gt;
     *  &lt;/OL&gt;
     *
     * &lt;p&gt;The COLUMN_SIZE column represents the specified column size for the given column.
     * For numeric data, this is the maximum precision.  For character data, this is the length in characters.
     * For datetime datatypes, this is the length in characters of the String representation (assuming the
     * maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes.  For the ROWID datatype,
     * this is the length in bytes. Null is returned for data types where the
     * column size is not applicable.
     *
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schema a schema name; must match the schema name
     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param table a table name; must match the table name as it is stored
     *        in the database
     * @param scope the scope of interest; use same values as SCOPE
     * @param nullable include columns that are nullable.
     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a column description
     * @exception SQLException if a database access error occurs
     */
    ResultSet getBestRowIdentifier(String catalog, String schema,
                                   String table, int scope, boolean nullable) throws SQLException;

    /**
     * Indicates that the scope of the best row identifier is
     * very temporary, lasting only while the
     * row is being used.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;SCOPE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getBestRowIdentifier&lt;/code&gt;.
     */
    int bestRowTemporary   = 0;

    /**
     * Indicates that the scope of the best row identifier is
     * the remainder of the current transaction.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;SCOPE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getBestRowIdentifier&lt;/code&gt;.
     */
    int bestRowTransaction = 1;

    /**
     * Indicates that the scope of the best row identifier is
     * the remainder of the current session.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;SCOPE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getBestRowIdentifier&lt;/code&gt;.
     */
    int bestRowSession     = 2;

    /**
     * Indicates that the best row identifier may or may not be a pseudo column.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;PSEUDO_COLUMN&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getBestRowIdentifier&lt;/code&gt;.
     */
    int bestRowUnknown  = 0;

    /**
     * Indicates that the best row identifier is NOT a pseudo column.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;PSEUDO_COLUMN&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getBestRowIdentifier&lt;/code&gt;.
     */
    int bestRowNotPseudo        = 1;

    /**
     * Indicates that the best row identifier is a pseudo column.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;PSEUDO_COLUMN&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getBestRowIdentifier&lt;/code&gt;.
     */
    int bestRowPseudo   = 2;

    /**
     * Retrieves a description of a table's columns that are automatically
     * updated when any value in a row is updated.  They are
     * unordered.
     *
     * &lt;P&gt;Each column description has the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;SCOPE&lt;/B&gt; short {@code =&gt;} is not used
     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String {@code =&gt;} column name
     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int {@code =&gt;} SQL data type from &lt;code&gt;java.sql.Types&lt;/code&gt;
     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String {@code =&gt;} Data source-dependent type name
     *  &lt;LI&gt;&lt;B&gt;COLUMN_SIZE&lt;/B&gt; int {@code =&gt;} precision
     *  &lt;LI&gt;&lt;B&gt;BUFFER_LENGTH&lt;/B&gt; int {@code =&gt;} length of column value in bytes
     *  &lt;LI&gt;&lt;B&gt;DECIMAL_DIGITS&lt;/B&gt; short  {@code =&gt;} scale - Null is returned for data types where
     * DECIMAL_DIGITS is not applicable.
     *  &lt;LI&gt;&lt;B&gt;PSEUDO_COLUMN&lt;/B&gt; short {@code =&gt;} whether this is pseudo column
     *      like an Oracle ROWID
     *      &lt;UL&gt;
     *      &lt;LI&gt; versionColumnUnknown - may or may not be pseudo column
     *      &lt;LI&gt; versionColumnNotPseudo - is NOT a pseudo column
     *      &lt;LI&gt; versionColumnPseudo - is a pseudo column
     *      &lt;/UL&gt;
     *  &lt;/OL&gt;
     *
     * &lt;p&gt;The COLUMN_SIZE column represents the specified column size for the given column.
     * For numeric data, this is the maximum precision.  For character data, this is the length in characters.
     * For datetime datatypes, this is the length in characters of the String representation (assuming the
     * maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes.  For the ROWID datatype,
     * this is the length in bytes. Null is returned for data types where the
     * column size is not applicable.
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schema a schema name; must match the schema name
     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param table a table name; must match the table name as it is stored
     *        in the database
     * @return a &lt;code&gt;ResultSet&lt;/code&gt; object in which each row is a
     *         column description
     * @exception SQLException if a database access error occurs
     */
    ResultSet getVersionColumns(String catalog, String schema,
                                String table) throws SQLException;

    /**
     * Indicates that this version column may or may not be a pseudo column.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;PSEUDO_COLUMN&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getVersionColumns&lt;/code&gt;.
     */
    int versionColumnUnknown    = 0;

    /**
     * Indicates that this version column is NOT a pseudo column.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;PSEUDO_COLUMN&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getVersionColumns&lt;/code&gt;.
     */
    int versionColumnNotPseudo  = 1;

    /**
     * Indicates that this version column is a pseudo column.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;PSEUDO_COLUMN&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getVersionColumns&lt;/code&gt;.
     */
    int versionColumnPseudo     = 2;

    /**
     * Retrieves a description of the given table's primary key columns.  They
     * are ordered by COLUMN_NAME.
     *
     * &lt;P&gt;Each primary key column description has the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String {@code =&gt;} table catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String {@code =&gt;} table schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String {@code =&gt;} table name
     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String {@code =&gt;} column name
     *  &lt;LI&gt;&lt;B&gt;KEY_SEQ&lt;/B&gt; short {@code =&gt;} sequence number within primary key( a value
     *  of 1 represents the first column of the primary key, a value of 2 would
     *  represent the second column within the primary key).
     *  &lt;LI&gt;&lt;B&gt;PK_NAME&lt;/B&gt; String {@code =&gt;} primary key name (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;/OL&gt;
     *
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schema a schema name; must match the schema name
     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param table a table name; must match the table name as it is stored
     *        in the database
     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a primary key column description
     * @exception SQLException if a database access error occurs
     */
    ResultSet getPrimaryKeys(String catalog, String schema,
                             String table) throws SQLException;

    /**
     * Retrieves a description of the primary key columns that are
     * referenced by the given table's foreign key columns (the primary keys
     * imported by a table).  They are ordered by PKTABLE_CAT,
     * PKTABLE_SCHEM, PKTABLE_NAME, and KEY_SEQ.
     *
     * &lt;P&gt;Each primary key column description has the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;PKTABLE_CAT&lt;/B&gt; String {@code =&gt;} primary key table catalog
     *      being imported (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;PKTABLE_SCHEM&lt;/B&gt; String {@code =&gt;} primary key table schema
     *      being imported (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;PKTABLE_NAME&lt;/B&gt; String {@code =&gt;} primary key table name
     *      being imported
     *  &lt;LI&gt;&lt;B&gt;PKCOLUMN_NAME&lt;/B&gt; String {@code =&gt;} primary key column name
     *      being imported
     *  &lt;LI&gt;&lt;B&gt;FKTABLE_CAT&lt;/B&gt; String {@code =&gt;} foreign key table catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;FKTABLE_SCHEM&lt;/B&gt; String {@code =&gt;} foreign key table schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;FKTABLE_NAME&lt;/B&gt; String {@code =&gt;} foreign key table name
     *  &lt;LI&gt;&lt;B&gt;FKCOLUMN_NAME&lt;/B&gt; String {@code =&gt;} foreign key column name
     *  &lt;LI&gt;&lt;B&gt;KEY_SEQ&lt;/B&gt; short {@code =&gt;} sequence number within a foreign key( a value
     *  of 1 represents the first column of the foreign key, a value of 2 would
     *  represent the second column within the foreign key).
     *  &lt;LI&gt;&lt;B&gt;UPDATE_RULE&lt;/B&gt; short {@code =&gt;} What happens to a
     *       foreign key when the primary key is updated:
     *      &lt;UL&gt;
     *      &lt;LI&gt; importedNoAction - do not allow update of primary
     *               key if it has been imported
     *      &lt;LI&gt; importedKeyCascade - change imported key to agree
     *               with primary key update
     *      &lt;LI&gt; importedKeySetNull - change imported key to &lt;code&gt;NULL&lt;/code&gt;
     *               if its primary key has been updated
     *      &lt;LI&gt; importedKeySetDefault - change imported key to default values
     *               if its primary key has been updated
     *      &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction
     *                                 (for ODBC 2.x compatibility)
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;DELETE_RULE&lt;/B&gt; short {@code =&gt;} What happens to
     *      the foreign key when primary is deleted.
     *      &lt;UL&gt;
     *      &lt;LI&gt; importedKeyNoAction - do not allow delete of primary
     *               key if it has been imported
     *      &lt;LI&gt; importedKeyCascade - delete rows that import a deleted key
     *      &lt;LI&gt; importedKeySetNull - change imported key to NULL if
     *               its primary key has been deleted
     *      &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction
     *                                 (for ODBC 2.x compatibility)
     *      &lt;LI&gt; importedKeySetDefault - change imported key to default if
     *               its primary key has been deleted
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;FK_NAME&lt;/B&gt; String {@code =&gt;} foreign key name (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;PK_NAME&lt;/B&gt; String {@code =&gt;} primary key name (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;DEFERRABILITY&lt;/B&gt; short {@code =&gt;} can the evaluation of foreign key
     *      constraints be deferred until commit
     *      &lt;UL&gt;
     *      &lt;LI&gt; importedKeyInitiallyDeferred - see SQL92 for definition
     *      &lt;LI&gt; importedKeyInitiallyImmediate - see SQL92 for definition
     *      &lt;LI&gt; importedKeyNotDeferrable - see SQL92 for definition
     *      &lt;/UL&gt;
     *  &lt;/OL&gt;
     *
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schema a schema name; must match the schema name
     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param table a table name; must match the table name as it is stored
     *        in the database
     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a primary key column description
     * @exception SQLException if a database access error occurs
     * @see #getExportedKeys
     */
    ResultSet getImportedKeys(String catalog, String schema,
                              String table) throws SQLException;

    /**
     * For the column &lt;code&gt;UPDATE_RULE&lt;/code&gt;,
     * indicates that
     * when the primary key is updated, the foreign key (imported key)
     * is changed to agree with it.
     * For the column &lt;code&gt;DELETE_RULE&lt;/code&gt;,
     * it indicates that
     * when the primary key is deleted, rows that imported that key
     * are deleted.
     * &lt;P&gt;
     * A possible value for the columns &lt;code&gt;UPDATE_RULE&lt;/code&gt;
     * and &lt;code&gt;DELETE_RULE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; objects returned by the methods
     * &lt;code&gt;getImportedKeys&lt;/code&gt;,  &lt;code&gt;getExportedKeys&lt;/code&gt;,
     * and &lt;code&gt;getCrossReference&lt;/code&gt;.
     */
    int importedKeyCascade      = 0;

    /**
     * For the column &lt;code&gt;UPDATE_RULE&lt;/code&gt;, indicates that
     * a primary key may not be updated if it has been imported by
     * another table as a foreign key.
     * For the column &lt;code&gt;DELETE_RULE&lt;/code&gt;, indicates that
     * a primary key may not be deleted if it has been imported by
     * another table as a foreign key.
     * &lt;P&gt;
     * A possible value for the columns &lt;code&gt;UPDATE_RULE&lt;/code&gt;
     * and &lt;code&gt;DELETE_RULE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; objects returned by the methods
     * &lt;code&gt;getImportedKeys&lt;/code&gt;,  &lt;code&gt;getExportedKeys&lt;/code&gt;,
     * and &lt;code&gt;getCrossReference&lt;/code&gt;.
     */
    int importedKeyRestrict = 1;

    /**
     * For the columns &lt;code&gt;UPDATE_RULE&lt;/code&gt;
     * and &lt;code&gt;DELETE_RULE&lt;/code&gt;, indicates that
     * when the primary key is updated or deleted, the foreign key (imported key)
     * is changed to &lt;code&gt;NULL&lt;/code&gt;.
     * &lt;P&gt;
     * A possible value for the columns &lt;code&gt;UPDATE_RULE&lt;/code&gt;
     * and &lt;code&gt;DELETE_RULE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; objects returned by the methods
     * &lt;code&gt;getImportedKeys&lt;/code&gt;,  &lt;code&gt;getExportedKeys&lt;/code&gt;,
     * and &lt;code&gt;getCrossReference&lt;/code&gt;.
     */
    int importedKeySetNull  = 2;

    /**
     * For the columns &lt;code&gt;UPDATE_RULE&lt;/code&gt;
     * and &lt;code&gt;DELETE_RULE&lt;/code&gt;, indicates that
     * if the primary key has been imported, it cannot be updated or deleted.
     * &lt;P&gt;
     * A possible value for the columns &lt;code&gt;UPDATE_RULE&lt;/code&gt;
     * and &lt;code&gt;DELETE_RULE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; objects returned by the methods
     * &lt;code&gt;getImportedKeys&lt;/code&gt;,  &lt;code&gt;getExportedKeys&lt;/code&gt;,
     * and &lt;code&gt;getCrossReference&lt;/code&gt;.
     */
    int importedKeyNoAction = 3;

    /**
     * For the columns &lt;code&gt;UPDATE_RULE&lt;/code&gt;
     * and &lt;code&gt;DELETE_RULE&lt;/code&gt;, indicates that
     * if the primary key is updated or deleted, the foreign key (imported key)
     * is set to the default value.
     * &lt;P&gt;
     * A possible value for the columns &lt;code&gt;UPDATE_RULE&lt;/code&gt;
     * and &lt;code&gt;DELETE_RULE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; objects returned by the methods
     * &lt;code&gt;getImportedKeys&lt;/code&gt;,  &lt;code&gt;getExportedKeys&lt;/code&gt;,
     * and &lt;code&gt;getCrossReference&lt;/code&gt;.
     */
    int importedKeySetDefault  = 4;

    /**
     * Indicates deferrability.  See SQL-92 for a definition.
     * &lt;P&gt;
     * A possible value for the column &lt;code&gt;DEFERRABILITY&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; objects returned by the methods
     * &lt;code&gt;getImportedKeys&lt;/code&gt;,  &lt;code&gt;getExportedKeys&lt;/code&gt;,
     * and &lt;code&gt;getCrossReference&lt;/code&gt;.
     */
    int importedKeyInitiallyDeferred  = 5;

    /**
     * Indicates deferrability.  See SQL-92 for a definition.
     * &lt;P&gt;
     * A possible value for the column &lt;code&gt;DEFERRABILITY&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; objects returned by the methods
     * &lt;code&gt;getImportedKeys&lt;/code&gt;,  &lt;code&gt;getExportedKeys&lt;/code&gt;,
     * and &lt;code&gt;getCrossReference&lt;/code&gt;.
     */
    int importedKeyInitiallyImmediate  = 6;

    /**
     * Indicates deferrability.  See SQL-92 for a definition.
     * &lt;P&gt;
     * A possible value for the column &lt;code&gt;DEFERRABILITY&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; objects returned by the methods
     * &lt;code&gt;getImportedKeys&lt;/code&gt;,  &lt;code&gt;getExportedKeys&lt;/code&gt;,
     * and &lt;code&gt;getCrossReference&lt;/code&gt;.
     */
    int importedKeyNotDeferrable  = 7;

    /**
     * Retrieves a description of the foreign key columns that reference the
     * given table's primary key columns (the foreign keys exported by a
     * table).  They are ordered by FKTABLE_CAT, FKTABLE_SCHEM,
     * FKTABLE_NAME, and KEY_SEQ.
     *
     * &lt;P&gt;Each foreign key column description has the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;PKTABLE_CAT&lt;/B&gt; String {@code =&gt;} primary key table catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;PKTABLE_SCHEM&lt;/B&gt; String {@code =&gt;} primary key table schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;PKTABLE_NAME&lt;/B&gt; String {@code =&gt;} primary key table name
     *  &lt;LI&gt;&lt;B&gt;PKCOLUMN_NAME&lt;/B&gt; String {@code =&gt;} primary key column name
     *  &lt;LI&gt;&lt;B&gt;FKTABLE_CAT&lt;/B&gt; String {@code =&gt;} foreign key table catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *      being exported (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;FKTABLE_SCHEM&lt;/B&gt; String {@code =&gt;} foreign key table schema (may be &lt;code&gt;null&lt;/code&gt;)
     *      being exported (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;FKTABLE_NAME&lt;/B&gt; String {@code =&gt;} foreign key table name
     *      being exported
     *  &lt;LI&gt;&lt;B&gt;FKCOLUMN_NAME&lt;/B&gt; String {@code =&gt;} foreign key column name
     *      being exported
     *  &lt;LI&gt;&lt;B&gt;KEY_SEQ&lt;/B&gt; short {@code =&gt;} sequence number within foreign key( a value
     *  of 1 represents the first column of the foreign key, a value of 2 would
     *  represent the second column within the foreign key).
     *  &lt;LI&gt;&lt;B&gt;UPDATE_RULE&lt;/B&gt; short {@code =&gt;} What happens to
     *       foreign key when primary is updated:
     *      &lt;UL&gt;
     *      &lt;LI&gt; importedNoAction - do not allow update of primary
     *               key if it has been imported
     *      &lt;LI&gt; importedKeyCascade - change imported key to agree
     *               with primary key update
     *      &lt;LI&gt; importedKeySetNull - change imported key to &lt;code&gt;NULL&lt;/code&gt; if
     *               its primary key has been updated
     *      &lt;LI&gt; importedKeySetDefault - change imported key to default values
     *               if its primary key has been updated
     *      &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction
     *                                 (for ODBC 2.x compatibility)
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;DELETE_RULE&lt;/B&gt; short {@code =&gt;} What happens to
     *      the foreign key when primary is deleted.
     *      &lt;UL&gt;
     *      &lt;LI&gt; importedKeyNoAction - do not allow delete of primary
     *               key if it has been imported
     *      &lt;LI&gt; importedKeyCascade - delete rows that import a deleted key
     *      &lt;LI&gt; importedKeySetNull - change imported key to &lt;code&gt;NULL&lt;/code&gt; if
     *               its primary key has been deleted
     *      &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction
     *                                 (for ODBC 2.x compatibility)
     *      &lt;LI&gt; importedKeySetDefault - change imported key to default if
     *               its primary key has been deleted
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;FK_NAME&lt;/B&gt; String {@code =&gt;} foreign key name (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;PK_NAME&lt;/B&gt; String {@code =&gt;} primary key name (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;DEFERRABILITY&lt;/B&gt; short {@code =&gt;} can the evaluation of foreign key
     *      constraints be deferred until commit
     *      &lt;UL&gt;
     *      &lt;LI&gt; importedKeyInitiallyDeferred - see SQL92 for definition
     *      &lt;LI&gt; importedKeyInitiallyImmediate - see SQL92 for definition
     *      &lt;LI&gt; importedKeyNotDeferrable - see SQL92 for definition
     *      &lt;/UL&gt;
     *  &lt;/OL&gt;
     *
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in this database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schema a schema name; must match the schema name
     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param table a table name; must match the table name as it is stored
     *        in this database
     * @return a &lt;code&gt;ResultSet&lt;/code&gt; object in which each row is a
     *         foreign key column description
     * @exception SQLException if a database access error occurs
     * @see #getImportedKeys
     */
    ResultSet getExportedKeys(String catalog, String schema,
                              String table) throws SQLException;

    /**
     * Retrieves a description of the foreign key columns in the given foreign key
     * table that reference the primary key or the columns representing a unique constraint of the  parent table (could be the same or a different table).
     * The number of columns returned from the parent table must match the number of
     * columns that make up the foreign key.  They
     * are ordered by FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, and
     * KEY_SEQ.
     *
     * &lt;P&gt;Each foreign key column description has the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;PKTABLE_CAT&lt;/B&gt; String {@code =&gt;} parent key table catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;PKTABLE_SCHEM&lt;/B&gt; String {@code =&gt;} parent key table schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;PKTABLE_NAME&lt;/B&gt; String {@code =&gt;} parent key table name
     *  &lt;LI&gt;&lt;B&gt;PKCOLUMN_NAME&lt;/B&gt; String {@code =&gt;} parent key column name
     *  &lt;LI&gt;&lt;B&gt;FKTABLE_CAT&lt;/B&gt; String {@code =&gt;} foreign key table catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *      being exported (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;FKTABLE_SCHEM&lt;/B&gt; String {@code =&gt;} foreign key table schema (may be &lt;code&gt;null&lt;/code&gt;)
     *      being exported (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;FKTABLE_NAME&lt;/B&gt; String {@code =&gt;} foreign key table name
     *      being exported
     *  &lt;LI&gt;&lt;B&gt;FKCOLUMN_NAME&lt;/B&gt; String {@code =&gt;} foreign key column name
     *      being exported
     *  &lt;LI&gt;&lt;B&gt;KEY_SEQ&lt;/B&gt; short {@code =&gt;} sequence number within foreign key( a value
     *  of 1 represents the first column of the foreign key, a value of 2 would
     *  represent the second column within the foreign key).
     *  &lt;LI&gt;&lt;B&gt;UPDATE_RULE&lt;/B&gt; short {@code =&gt;} What happens to
     *       foreign key when parent key is updated:
     *      &lt;UL&gt;
     *      &lt;LI&gt; importedNoAction - do not allow update of parent
     *               key if it has been imported
     *      &lt;LI&gt; importedKeyCascade - change imported key to agree
     *               with parent key update
     *      &lt;LI&gt; importedKeySetNull - change imported key to &lt;code&gt;NULL&lt;/code&gt; if
     *               its parent key has been updated
     *      &lt;LI&gt; importedKeySetDefault - change imported key to default values
     *               if its parent key has been updated
     *      &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction
     *                                 (for ODBC 2.x compatibility)
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;DELETE_RULE&lt;/B&gt; short {@code =&gt;} What happens to
     *      the foreign key when parent key is deleted.
     *      &lt;UL&gt;
     *      &lt;LI&gt; importedKeyNoAction - do not allow delete of parent
     *               key if it has been imported
     *      &lt;LI&gt; importedKeyCascade - delete rows that import a deleted key
     *      &lt;LI&gt; importedKeySetNull - change imported key to &lt;code&gt;NULL&lt;/code&gt; if
     *               its primary key has been deleted
     *      &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction
     *                                 (for ODBC 2.x compatibility)
     *      &lt;LI&gt; importedKeySetDefault - change imported key to default if
     *               its parent key has been deleted
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;FK_NAME&lt;/B&gt; String {@code =&gt;} foreign key name (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;PK_NAME&lt;/B&gt; String {@code =&gt;} parent key name (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;DEFERRABILITY&lt;/B&gt; short {@code =&gt;} can the evaluation of foreign key
     *      constraints be deferred until commit
     *      &lt;UL&gt;
     *      &lt;LI&gt; importedKeyInitiallyDeferred - see SQL92 for definition
     *      &lt;LI&gt; importedKeyInitiallyImmediate - see SQL92 for definition
     *      &lt;LI&gt; importedKeyNotDeferrable - see SQL92 for definition
     *      &lt;/UL&gt;
     *  &lt;/OL&gt;
     *
     * @param parentCatalog a catalog name; must match the catalog name
     * as it is stored in the database; &quot;&quot; retrieves those without a
     * catalog; &lt;code&gt;null&lt;/code&gt; means drop catalog name from the selection criteria
     * @param parentSchema a schema name; must match the schema name as
     * it is stored in the database; &quot;&quot; retrieves those without a schema;
     * &lt;code&gt;null&lt;/code&gt; means drop schema name from the selection criteria
     * @param parentTable the name of the table that exports the key; must match
     * the table name as it is stored in the database
     * @param foreignCatalog a catalog name; must match the catalog name as
     * it is stored in the database; &quot;&quot; retrieves those without a
     * catalog; &lt;code&gt;null&lt;/code&gt; means drop catalog name from the selection criteria
     * @param foreignSchema a schema name; must match the schema name as it
     * is stored in the database; &quot;&quot; retrieves those without a schema;
     * &lt;code&gt;null&lt;/code&gt; means drop schema name from the selection criteria
     * @param foreignTable the name of the table that imports the key; must match
     * the table name as it is stored in the database
     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a foreign key column description
     * @exception SQLException if a database access error occurs
     * @see #getImportedKeys
     */
    ResultSet getCrossReference(
                                String parentCatalog, String parentSchema, String parentTable,
                                String foreignCatalog, String foreignSchema, String foreignTable
                                ) throws SQLException;

    /**
     * Retrieves a description of all the data types supported by
     * this database. They are ordered by DATA_TYPE and then by how
     * closely the data type maps to the corresponding JDBC SQL type.
     *
     * &lt;P&gt;If the database supports SQL distinct types, then getTypeInfo() will return
     * a single row with a TYPE_NAME of DISTINCT and a DATA_TYPE of Types.DISTINCT.
     * If the database supports SQL structured types, then getTypeInfo() will return
     * a single row with a TYPE_NAME of STRUCT and a DATA_TYPE of Types.STRUCT.
     *
     * &lt;P&gt;If SQL distinct or structured types are supported, then information on the
     * individual types may be obtained from the getUDTs() method.
     *

     *
     * &lt;P&gt;Each type description has the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String {@code =&gt;} Type name
     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int {@code =&gt;} SQL data type from java.sql.Types
     *  &lt;LI&gt;&lt;B&gt;PRECISION&lt;/B&gt; int {@code =&gt;} maximum precision
     *  &lt;LI&gt;&lt;B&gt;LITERAL_PREFIX&lt;/B&gt; String {@code =&gt;} prefix used to quote a literal
     *      (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;LITERAL_SUFFIX&lt;/B&gt; String {@code =&gt;} suffix used to quote a literal
     (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;CREATE_PARAMS&lt;/B&gt; String {@code =&gt;} parameters used in creating
     *      the type (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;NULLABLE&lt;/B&gt; short {@code =&gt;} can you use NULL for this type.
     *      &lt;UL&gt;
     *      &lt;LI&gt; typeNoNulls - does not allow NULL values
     *      &lt;LI&gt; typeNullable - allows NULL values
     *      &lt;LI&gt; typeNullableUnknown - nullability unknown
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;CASE_SENSITIVE&lt;/B&gt; boolean{@code =&gt;} is it case sensitive.
     *  &lt;LI&gt;&lt;B&gt;SEARCHABLE&lt;/B&gt; short {@code =&gt;} can you use &quot;WHERE&quot; based on this type:
     *      &lt;UL&gt;
     *      &lt;LI&gt; typePredNone - No support
     *      &lt;LI&gt; typePredChar - Only supported with WHERE .. LIKE
     *      &lt;LI&gt; typePredBasic - Supported except for WHERE .. LIKE
     *      &lt;LI&gt; typeSearchable - Supported for all WHERE ..
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;UNSIGNED_ATTRIBUTE&lt;/B&gt; boolean {@code =&gt;} is it unsigned.
     *  &lt;LI&gt;&lt;B&gt;FIXED_PREC_SCALE&lt;/B&gt; boolean {@code =&gt;} can it be a money value.
     *  &lt;LI&gt;&lt;B&gt;AUTO_INCREMENT&lt;/B&gt; boolean {@code =&gt;} can it be used for an
     *      auto-increment value.
     *  &lt;LI&gt;&lt;B&gt;LOCAL_TYPE_NAME&lt;/B&gt; String {@code =&gt;} localized version of type name
     *      (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;MINIMUM_SCALE&lt;/B&gt; short {@code =&gt;} minimum scale supported
     *  &lt;LI&gt;&lt;B&gt;MAXIMUM_SCALE&lt;/B&gt; short {@code =&gt;} maximum scale supported
     *  &lt;LI&gt;&lt;B&gt;SQL_DATA_TYPE&lt;/B&gt; int {@code =&gt;} unused
     *  &lt;LI&gt;&lt;B&gt;SQL_DATETIME_SUB&lt;/B&gt; int {@code =&gt;} unused
     *  &lt;LI&gt;&lt;B&gt;NUM_PREC_RADIX&lt;/B&gt; int {@code =&gt;} usually 2 or 10
     *  &lt;/OL&gt;
     *
     * &lt;p&gt;The PRECISION column represents the maximum column size that the server supports for the given datatype.
     * For numeric data, this is the maximum precision.  For character data, this is the length in characters.
     * For datetime datatypes, this is the length in characters of the String representation (assuming the
     * maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes.  For the ROWID datatype,
     * this is the length in bytes. Null is returned for data types where the
     * column size is not applicable.
     *
     * @return a &lt;code&gt;ResultSet&lt;/code&gt; object in which each row is an SQL
     *         type description
     * @exception SQLException if a database access error occurs
     */
    ResultSet getTypeInfo() throws SQLException;

    /**
     * Indicates that a &lt;code&gt;NULL&lt;/code&gt; value is NOT allowed for this
     * data type.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;NULLABLE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getTypeInfo&lt;/code&gt;.
     */
    int typeNoNulls = 0;

    /**
     * Indicates that a &lt;code&gt;NULL&lt;/code&gt; value is allowed for this
     * data type.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;NULLABLE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getTypeInfo&lt;/code&gt;.
     */
    int typeNullable = 1;

    /**
     * Indicates that it is not known whether a &lt;code&gt;NULL&lt;/code&gt; value
     * is allowed for this data type.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;NULLABLE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getTypeInfo&lt;/code&gt;.
     */
    int typeNullableUnknown = 2;

    /**
     * Indicates that &lt;code&gt;WHERE&lt;/code&gt; search clauses are not supported
     * for this type.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;SEARCHABLE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getTypeInfo&lt;/code&gt;.
     */
    int typePredNone = 0;

    /**
     * Indicates that the data type
     * can be only be used in &lt;code&gt;WHERE&lt;/code&gt; search clauses
     * that  use &lt;code&gt;LIKE&lt;/code&gt; predicates.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;SEARCHABLE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getTypeInfo&lt;/code&gt;.
     */
    int typePredChar = 1;

    /**
     * Indicates that the data type can be only be used in &lt;code&gt;WHERE&lt;/code&gt;
     * search clauses
     * that do not use &lt;code&gt;LIKE&lt;/code&gt; predicates.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;SEARCHABLE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getTypeInfo&lt;/code&gt;.
     */
    int typePredBasic = 2;

    /**
     * Indicates that all &lt;code&gt;WHERE&lt;/code&gt; search clauses can be
     * based on this type.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;SEARCHABLE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getTypeInfo&lt;/code&gt;.
     */
    int typeSearchable  = 3;

    /**
     * Retrieves a description of the given table's indices and statistics. They are
     * ordered by NON_UNIQUE, TYPE, INDEX_NAME, and ORDINAL_POSITION.
     *
     * &lt;P&gt;Each index column description has the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String {@code =&gt;} table catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String {@code =&gt;} table schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String {@code =&gt;} table name
     *  &lt;LI&gt;&lt;B&gt;NON_UNIQUE&lt;/B&gt; boolean {@code =&gt;} Can index values be non-unique.
     *      false when TYPE is tableIndexStatistic
     *  &lt;LI&gt;&lt;B&gt;INDEX_QUALIFIER&lt;/B&gt; String {@code =&gt;} index catalog (may be &lt;code&gt;null&lt;/code&gt;);
     *      &lt;code&gt;null&lt;/code&gt; when TYPE is tableIndexStatistic
     *  &lt;LI&gt;&lt;B&gt;INDEX_NAME&lt;/B&gt; String {@code =&gt;} index name; &lt;code&gt;null&lt;/code&gt; when TYPE is
     *      tableIndexStatistic
     *  &lt;LI&gt;&lt;B&gt;TYPE&lt;/B&gt; short {@code =&gt;} index type:
     *      &lt;UL&gt;
     *      &lt;LI&gt; tableIndexStatistic - this identifies table statistics that are
     *           returned in conjuction with a table's index descriptions
     *      &lt;LI&gt; tableIndexClustered - this is a clustered index
     *      &lt;LI&gt; tableIndexHashed - this is a hashed index
     *      &lt;LI&gt; tableIndexOther - this is some other style of index
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;ORDINAL_POSITION&lt;/B&gt; short {@code =&gt;} column sequence number
     *      within index; zero when TYPE is tableIndexStatistic
     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String {@code =&gt;} column name; &lt;code&gt;null&lt;/code&gt; when TYPE is
     *      tableIndexStatistic
     *  &lt;LI&gt;&lt;B&gt;ASC_OR_DESC&lt;/B&gt; String {@code =&gt;} column sort sequence, &quot;A&quot; {@code =&gt;} ascending,
     *      &quot;D&quot; {@code =&gt;} descending, may be &lt;code&gt;null&lt;/code&gt; if sort sequence is not supported;
     *      &lt;code&gt;null&lt;/code&gt; when TYPE is tableIndexStatistic
     *  &lt;LI&gt;&lt;B&gt;CARDINALITY&lt;/B&gt; long {@code =&gt;} When TYPE is tableIndexStatistic, then
     *      this is the number of rows in the table; otherwise, it is the
     *      number of unique values in the index.
     *  &lt;LI&gt;&lt;B&gt;PAGES&lt;/B&gt; long {@code =&gt;} When TYPE is  tableIndexStatisic then
     *      this is the number of pages used for the table, otherwise it
     *      is the number of pages used for the current index.
     *  &lt;LI&gt;&lt;B&gt;FILTER_CONDITION&lt;/B&gt; String {@code =&gt;} Filter condition, if any.
     *      (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;/OL&gt;
     *
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in this database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schema a schema name; must match the schema name
     *        as it is stored in this database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param table a table name; must match the table name as it is stored
     *        in this database
     * @param unique when true, return only indices for unique values;
     *     when false, return indices regardless of whether unique or not
     * @param approximate when true, result is allowed to reflect approximate
     *     or out of data values; when false, results are requested to be
     *     accurate
     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is an index column description
     * @exception SQLException if a database access error occurs
     */
    ResultSet getIndexInfo(String catalog, String schema, String table,
                           boolean unique, boolean approximate)
        throws SQLException;

    /**
     * Indicates that this column contains table statistics that
     * are returned in conjunction with a table's index descriptions.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;TYPE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getIndexInfo&lt;/code&gt;.
     */
    short tableIndexStatistic = 0;

    /**
     * Indicates that this table index is a clustered index.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;TYPE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getIndexInfo&lt;/code&gt;.
     */
    short tableIndexClustered = 1;

    /**
     * Indicates that this table index is a hashed index.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;TYPE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getIndexInfo&lt;/code&gt;.
     */
    short tableIndexHashed    = 2;

    /**
     * Indicates that this table index is not a clustered
     * index, a hashed index, or table statistics;
     * it is something other than these.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;TYPE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getIndexInfo&lt;/code&gt;.
     */
    short tableIndexOther     = 3;

    //--------------------------JDBC 2.0-----------------------------

    /**
     * Retrieves whether this database supports the given result set type.
     *
     * @param type defined in &lt;code&gt;java.sql.ResultSet&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @see Connection
     * @since 1.2
     */
    boolean supportsResultSetType(int type) throws SQLException;

    /**
     * Retrieves whether this database supports the given concurrency type
     * in combination with the given result set type.
     *
     * @param type defined in &lt;code&gt;java.sql.ResultSet&lt;/code&gt;
     * @param concurrency type defined in &lt;code&gt;java.sql.ResultSet&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @see Connection
     * @since 1.2
     */
    boolean supportsResultSetConcurrency(int type, int concurrency)
        throws SQLException;

    /**
     *
     * Retrieves whether for the given type of &lt;code&gt;ResultSet&lt;/code&gt; object,
     * the result set's own updates are visible.
     *
     * @param type the &lt;code&gt;ResultSet&lt;/code&gt; type; one of
     *        &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if updates are visible for the given result set type;
     *        &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.2
     */
    boolean ownUpdatesAreVisible(int type) throws SQLException;

    /**
     * Retrieves whether a result set's own deletes are visible.
     *
     * @param type the &lt;code&gt;ResultSet&lt;/code&gt; type; one of
     *        &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if deletes are visible for the given result set type;
     *        &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.2
     */
    boolean ownDeletesAreVisible(int type) throws SQLException;

    /**
     * Retrieves whether a result set's own inserts are visible.
     *
     * @param type the &lt;code&gt;ResultSet&lt;/code&gt; type; one of
     *        &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if inserts are visible for the given result set type;
     *        &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.2
     */
    boolean ownInsertsAreVisible(int type) throws SQLException;

    /**
     * Retrieves whether updates made by others are visible.
     *
     * @param type the &lt;code&gt;ResultSet&lt;/code&gt; type; one of
     *        &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if updates made by others
     *        are visible for the given result set type;
     *        &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.2
     */
    boolean othersUpdatesAreVisible(int type) throws SQLException;

    /**
     * Retrieves whether deletes made by others are visible.
     *
     * @param type the &lt;code&gt;ResultSet&lt;/code&gt; type; one of
     *        &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if deletes made by others
     *        are visible for the given result set type;
     *        &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.2
     */
    boolean othersDeletesAreVisible(int type) throws SQLException;

    /**
     * Retrieves whether inserts made by others are visible.
     *
     * @param type the &lt;code&gt;ResultSet&lt;/code&gt; type; one of
     *        &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if inserts made by others
     *         are visible for the given result set type;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.2
     */
    boolean othersInsertsAreVisible(int type) throws SQLException;

    /**
     * Retrieves whether or not a visible row update can be detected by
     * calling the method &lt;code&gt;ResultSet.rowUpdated&lt;/code&gt;.
     *
     * @param type the &lt;code&gt;ResultSet&lt;/code&gt; type; one of
     *        &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if changes are detected by the result set type;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.2
     */
    boolean updatesAreDetected(int type) throws SQLException;

    /**
     * Retrieves whether or not a visible row delete can be detected by
     * calling the method &lt;code&gt;ResultSet.rowDeleted&lt;/code&gt;.  If the method
     * &lt;code&gt;deletesAreDetected&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, it means that
     * deleted rows are removed from the result set.
     *
     * @param type the &lt;code&gt;ResultSet&lt;/code&gt; type; one of
     *        &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if deletes are detected by the given result set type;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.2
     */
    boolean deletesAreDetected(int type) throws SQLException;

    /**
     * Retrieves whether or not a visible row insert can be detected
     * by calling the method &lt;code&gt;ResultSet.rowInserted&lt;/code&gt;.
     *
     * @param type the &lt;code&gt;ResultSet&lt;/code&gt; type; one of
     *        &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
     *        &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if changes are detected by the specified result
     *         set type; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.2
     */
    boolean insertsAreDetected(int type) throws SQLException;

    /**
     * Retrieves whether this database supports batch updates.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this database supports batch updates;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.2
     */
    boolean supportsBatchUpdates() throws SQLException;

    /**
     * Retrieves a description of the user-defined types (UDTs) defined
     * in a particular schema.  Schema-specific UDTs may have type
     * &lt;code&gt;JAVA_OBJECT&lt;/code&gt;, &lt;code&gt;STRUCT&lt;/code&gt;,
     * or &lt;code&gt;DISTINCT&lt;/code&gt;.
     *
     * &lt;P&gt;Only types matching the catalog, schema, type name and type
     * criteria are returned.  They are ordered by &lt;code&gt;DATA_TYPE&lt;/code&gt;,
     * &lt;code&gt;TYPE_CAT&lt;/code&gt;, &lt;code&gt;TYPE_SCHEM&lt;/code&gt;  and
     * &lt;code&gt;TYPE_NAME&lt;/code&gt;.  The type name parameter may be a fully-qualified
     * name.  In this case, the catalog and schemaPattern parameters are
     * ignored.
     *
     * &lt;P&gt;Each type description has the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TYPE_CAT&lt;/B&gt; String {@code =&gt;} the type's catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TYPE_SCHEM&lt;/B&gt; String {@code =&gt;} type's schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String {@code =&gt;} type name
     *  &lt;LI&gt;&lt;B&gt;CLASS_NAME&lt;/B&gt; String {@code =&gt;} Java class name
     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int {@code =&gt;} type value defined in java.sql.Types.
     *     One of JAVA_OBJECT, STRUCT, or DISTINCT
     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String {@code =&gt;} explanatory comment on the type
     *  &lt;LI&gt;&lt;B&gt;BASE_TYPE&lt;/B&gt; short {@code =&gt;} type code of the source type of a
     *     DISTINCT type or the type that implements the user-generated
     *     reference type of the SELF_REFERENCING_COLUMN of a structured
     *     type as defined in java.sql.Types (&lt;code&gt;null&lt;/code&gt; if DATA_TYPE is not
     *     DISTINCT or not STRUCT with REFERENCE_GENERATION = USER_DEFINED)
     *  &lt;/OL&gt;
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; If the driver does not support UDTs, an empty
     * result set is returned.
     *
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schemaPattern a schema pattern name; must match the schema name
     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param typeNamePattern a type name pattern; must match the type name
     *        as it is stored in the database; may be a fully qualified name
     * @param types a list of user-defined types (JAVA_OBJECT,
     *        STRUCT, or DISTINCT) to include; &lt;code&gt;null&lt;/code&gt; returns all types
     * @return &lt;code&gt;ResultSet&lt;/code&gt; object in which each row describes a UDT
     * @exception SQLException if a database access error occurs
     * @see #getSearchStringEscape
     * @since 1.2
     */
    ResultSet getUDTs(String catalog, String schemaPattern,
                      String typeNamePattern, int[] types)
        throws SQLException;

    /**
     * Retrieves the connection that produced this metadata object.
     * &lt;P&gt;
     * @return the connection that produced this metadata object
     * @exception SQLException if a database access error occurs
     * @since 1.2
     */
    Connection getConnection() throws SQLException;

    // ------------------- JDBC 3.0 -------------------------

    /**
     * Retrieves whether this database supports savepoints.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if savepoints are supported;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.4
     */
    boolean supportsSavepoints() throws SQLException;

    /**
     * Retrieves whether this database supports named parameters to callable
     * statements.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if named parameters are supported;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.4
     */
    boolean supportsNamedParameters() throws SQLException;

    /**
     * Retrieves whether it is possible to have multiple &lt;code&gt;ResultSet&lt;/code&gt; objects
     * returned from a &lt;code&gt;CallableStatement&lt;/code&gt; object
     * simultaneously.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if a &lt;code&gt;CallableStatement&lt;/code&gt; object
     *         can return multiple &lt;code&gt;ResultSet&lt;/code&gt; objects
     *         simultaneously; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a datanase access error occurs
     * @since 1.4
     */
    boolean supportsMultipleOpenResults() throws SQLException;

    /**
     * Retrieves whether auto-generated keys can be retrieved after
     * a statement has been executed
     *
     * @return &lt;code&gt;true&lt;/code&gt; if auto-generated keys can be retrieved
     *         after a statement has executed; &lt;code&gt;false&lt;/code&gt; otherwise
     *&lt;p&gt;If &lt;code&gt;true&lt;/code&gt; is returned, the JDBC driver must support the
     * returning of auto-generated keys for at least SQL INSERT statements
     *&lt;p&gt;
     * @exception SQLException if a database access error occurs
     * @since 1.4
     */
    boolean supportsGetGeneratedKeys() throws SQLException;

    /**
     * Retrieves a description of the user-defined type (UDT) hierarchies defined in a
     * particular schema in this database. Only the immediate super type/
     * sub type relationship is modeled.
     * &lt;P&gt;
     * Only supertype information for UDTs matching the catalog,
     * schema, and type name is returned. The type name parameter
     * may be a fully-qualified name. When the UDT name supplied is a
     * fully-qualified name, the catalog and schemaPattern parameters are
     * ignored.
     * &lt;P&gt;
     * If a UDT does not have a direct super type, it is not listed here.
     * A row of the &lt;code&gt;ResultSet&lt;/code&gt; object returned by this method
     * describes the designated UDT and a direct supertype. A row has the following
     * columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TYPE_CAT&lt;/B&gt; String {@code =&gt;} the UDT's catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TYPE_SCHEM&lt;/B&gt; String {@code =&gt;} UDT's schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String {@code =&gt;} type name of the UDT
     *  &lt;LI&gt;&lt;B&gt;SUPERTYPE_CAT&lt;/B&gt; String {@code =&gt;} the direct super type's catalog
     *                           (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;SUPERTYPE_SCHEM&lt;/B&gt; String {@code =&gt;} the direct super type's schema
     *                             (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;SUPERTYPE_NAME&lt;/B&gt; String {@code =&gt;} the direct super type's name
     *  &lt;/OL&gt;
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; If the driver does not support type hierarchies, an
     * empty result set is returned.
     *
     * @param catalog a catalog name; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means drop catalog name from the selection criteria
     * @param schemaPattern a schema name pattern; &quot;&quot; retrieves those
     *        without a schema
     * @param typeNamePattern a UDT name pattern; may be a fully-qualified
     *        name
     * @return a &lt;code&gt;ResultSet&lt;/code&gt; object in which a row gives information
     *         about the designated UDT
     * @throws SQLException if a database access error occurs
     * @see #getSearchStringEscape
     * @since 1.4
     */
    ResultSet getSuperTypes(String catalog, String schemaPattern,
                            String typeNamePattern) throws SQLException;

    /**
     * Retrieves a description of the table hierarchies defined in a particular
     * schema in this database.
     *
     * &lt;P&gt;Only supertable information for tables matching the catalog, schema
     * and table name are returned. The table name parameter may be a fully-
     * qualified name, in which case, the catalog and schemaPattern parameters
     * are ignored. If a table does not have a super table, it is not listed here.
     * Supertables have to be defined in the same catalog and schema as the
     * sub tables. Therefore, the type description does not need to include
     * this information for the supertable.
     *
     * &lt;P&gt;Each type description has the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String {@code =&gt;} the type's catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String {@code =&gt;} type's schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String {@code =&gt;} type name
     *  &lt;LI&gt;&lt;B&gt;SUPERTABLE_NAME&lt;/B&gt; String {@code =&gt;} the direct super type's name
     *  &lt;/OL&gt;
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; If the driver does not support type hierarchies, an
     * empty result set is returned.
     *
     * @param catalog a catalog name; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means drop catalog name from the selection criteria
     * @param schemaPattern a schema name pattern; &quot;&quot; retrieves those
     *        without a schema
     * @param tableNamePattern a table name pattern; may be a fully-qualified
     *        name
     * @return a &lt;code&gt;ResultSet&lt;/code&gt; object in which each row is a type description
     * @throws SQLException if a database access error occurs
     * @see #getSearchStringEscape
     * @since 1.4
     */
    ResultSet getSuperTables(String catalog, String schemaPattern,
                             String tableNamePattern) throws SQLException;

    /**
     * Indicates that &lt;code&gt;NULL&lt;/code&gt; values might not be allowed.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;NULLABLE&lt;/code&gt; in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getAttributes&lt;/code&gt;.
     */
    short attributeNoNulls = 0;

    /**
     * Indicates that &lt;code&gt;NULL&lt;/code&gt; values are definitely allowed.
     * &lt;P&gt;
     * A possible value for the column &lt;code&gt;NULLABLE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getAttributes&lt;/code&gt;.
     */
    short attributeNullable = 1;

    /**
     * Indicates that whether &lt;code&gt;NULL&lt;/code&gt; values are allowed is not
     * known.
     * &lt;P&gt;
     * A possible value for the column &lt;code&gt;NULLABLE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getAttributes&lt;/code&gt;.
     */
    short attributeNullableUnknown = 2;

    /**
     * Retrieves a description of the given attribute of the given type
     * for a user-defined type (UDT) that is available in the given schema
     * and catalog.
     * &lt;P&gt;
     * Descriptions are returned only for attributes of UDTs matching the
     * catalog, schema, type, and attribute name criteria. They are ordered by
     * &lt;code&gt;TYPE_CAT&lt;/code&gt;, &lt;code&gt;TYPE_SCHEM&lt;/code&gt;,
     * &lt;code&gt;TYPE_NAME&lt;/code&gt; and &lt;code&gt;ORDINAL_POSITION&lt;/code&gt;. This description
     * does not contain inherited attributes.
     * &lt;P&gt;
     * The &lt;code&gt;ResultSet&lt;/code&gt; object that is returned has the following
     * columns:
     * &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TYPE_CAT&lt;/B&gt; String {@code =&gt;} type catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TYPE_SCHEM&lt;/B&gt; String {@code =&gt;} type schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String {@code =&gt;} type name
     *  &lt;LI&gt;&lt;B&gt;ATTR_NAME&lt;/B&gt; String {@code =&gt;} attribute name
     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int {@code =&gt;} attribute type SQL type from java.sql.Types
     *  &lt;LI&gt;&lt;B&gt;ATTR_TYPE_NAME&lt;/B&gt; String {@code =&gt;} Data source dependent type name.
     *  For a UDT, the type name is fully qualified. For a REF, the type name is
     *  fully qualified and represents the target type of the reference type.
     *  &lt;LI&gt;&lt;B&gt;ATTR_SIZE&lt;/B&gt; int {@code =&gt;} column size.  For char or date
     *      types this is the maximum number of characters; for numeric or
     *      decimal types this is precision.
     *  &lt;LI&gt;&lt;B&gt;DECIMAL_DIGITS&lt;/B&gt; int {@code =&gt;} the number of fractional digits. Null is returned for data types where
     * DECIMAL_DIGITS is not applicable.
     *  &lt;LI&gt;&lt;B&gt;NUM_PREC_RADIX&lt;/B&gt; int {@code =&gt;} Radix (typically either 10 or 2)
     *  &lt;LI&gt;&lt;B&gt;NULLABLE&lt;/B&gt; int {@code =&gt;} whether NULL is allowed
     *      &lt;UL&gt;
     *      &lt;LI&gt; attributeNoNulls - might not allow NULL values
     *      &lt;LI&gt; attributeNullable - definitely allows NULL values
     *      &lt;LI&gt; attributeNullableUnknown - nullability unknown
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String {@code =&gt;} comment describing column (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;ATTR_DEF&lt;/B&gt; String {@code =&gt;} default value (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;SQL_DATA_TYPE&lt;/B&gt; int {@code =&gt;} unused
     *  &lt;LI&gt;&lt;B&gt;SQL_DATETIME_SUB&lt;/B&gt; int {@code =&gt;} unused
     *  &lt;LI&gt;&lt;B&gt;CHAR_OCTET_LENGTH&lt;/B&gt; int {@code =&gt;} for char types the
     *       maximum number of bytes in the column
     *  &lt;LI&gt;&lt;B&gt;ORDINAL_POSITION&lt;/B&gt; int {@code =&gt;} index of the attribute in the UDT
     *      (starting at 1)
     *  &lt;LI&gt;&lt;B&gt;IS_NULLABLE&lt;/B&gt; String  {@code =&gt;} ISO rules are used to determine
     * the nullability for a attribute.
     *       &lt;UL&gt;
     *       &lt;LI&gt; YES           --- if the attribute can include NULLs
     *       &lt;LI&gt; NO            --- if the attribute cannot include NULLs
     *       &lt;LI&gt; empty string  --- if the nullability for the
     * attribute is unknown
     *       &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;SCOPE_CATALOG&lt;/B&gt; String {@code =&gt;} catalog of table that is the
     *      scope of a reference attribute (&lt;code&gt;null&lt;/code&gt; if DATA_TYPE isn't REF)
     *  &lt;LI&gt;&lt;B&gt;SCOPE_SCHEMA&lt;/B&gt; String {@code =&gt;} schema of table that is the
     *      scope of a reference attribute (&lt;code&gt;null&lt;/code&gt; if DATA_TYPE isn't REF)
     *  &lt;LI&gt;&lt;B&gt;SCOPE_TABLE&lt;/B&gt; String {@code =&gt;} table name that is the scope of a
     *      reference attribute (&lt;code&gt;null&lt;/code&gt; if the DATA_TYPE isn't REF)
     * &lt;LI&gt;&lt;B&gt;SOURCE_DATA_TYPE&lt;/B&gt; short {@code =&gt;} source type of a distinct type or user-generated
     *      Ref type,SQL type from java.sql.Types (&lt;code&gt;null&lt;/code&gt; if DATA_TYPE
     *      isn't DISTINCT or user-generated REF)
     *  &lt;/OL&gt;
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schemaPattern a schema name pattern; must match the schema name
     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param typeNamePattern a type name pattern; must match the
     *        type name as it is stored in the database
     * @param attributeNamePattern an attribute name pattern; must match the attribute
     *        name as it is declared in the database
     * @return a &lt;code&gt;ResultSet&lt;/code&gt; object in which each row is an
     *         attribute description
     * @exception SQLException if a database access error occurs
     * @see #getSearchStringEscape
     * @since 1.4
     */
    ResultSet getAttributes(String catalog, String schemaPattern,
                            String typeNamePattern, String attributeNamePattern)
        throws SQLException;

    /**
     * Retrieves whether this database supports the given result set holdability.
     *
     * @param holdability one of the following constants:
     *          &lt;code&gt;ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code&gt; or
     *          &lt;code&gt;ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @see Connection
     * @since 1.4
     */
    boolean supportsResultSetHoldability(int holdability) throws SQLException;

    /**
     * Retrieves this database's default holdability for &lt;code&gt;ResultSet&lt;/code&gt;
     * objects.
     *
     * @return the default holdability; either
     *         &lt;code&gt;ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code&gt; or
     *         &lt;code&gt;ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code&gt;
     * @exception SQLException if a database access error occurs
     * @since 1.4
     */
    int getResultSetHoldability() throws SQLException;

    /**
     * Retrieves the major version number of the underlying database.
     *
     * @return the underlying database's major version
     * @exception SQLException if a database access error occurs
     * @since 1.4
     */
    int getDatabaseMajorVersion() throws SQLException;

    /**
     * Retrieves the minor version number of the underlying database.
     *
     * @return underlying database's minor version
     * @exception SQLException if a database access error occurs
     * @since 1.4
     */
    int getDatabaseMinorVersion() throws SQLException;

    /**
     * Retrieves the major JDBC version number for this
     * driver.
     *
     * @return JDBC version major number
     * @exception SQLException if a database access error occurs
     * @since 1.4
     */
    int getJDBCMajorVersion() throws SQLException;

    /**
     * Retrieves the minor JDBC version number for this
     * driver.
     *
     * @return JDBC version minor number
     * @exception SQLException if a database access error occurs
     * @since 1.4
     */
    int getJDBCMinorVersion() throws SQLException;

    /**
     *  A possible return value for the method
     * &lt;code&gt;DatabaseMetaData.getSQLStateType&lt;/code&gt; which is used to indicate
     * whether the value returned by the method
     * &lt;code&gt;SQLException.getSQLState&lt;/code&gt; is an
     * X/Open (now know as Open Group) SQL CLI SQLSTATE value.
     * &lt;P&gt;
     * @since 1.4
     */
    int sqlStateXOpen = 1;

    /**
     *  A possible return value for the method
     * &lt;code&gt;DatabaseMetaData.getSQLStateType&lt;/code&gt; which is used to indicate
     * whether the value returned by the method
     * &lt;code&gt;SQLException.getSQLState&lt;/code&gt; is an SQLSTATE value.
     * &lt;P&gt;
     * @since 1.6
     */
    int sqlStateSQL = 2;

     /**
     *  A possible return value for the method
     * &lt;code&gt;DatabaseMetaData.getSQLStateType&lt;/code&gt; which is used to indicate
     * whether the value returned by the method
     * &lt;code&gt;SQLException.getSQLState&lt;/code&gt; is an SQL99 SQLSTATE value.
     * &lt;P&gt;
     * &lt;b&gt;Note:&lt;/b&gt;This constant remains only for compatibility reasons. Developers
     * should use the constant &lt;code&gt;sqlStateSQL&lt;/code&gt; instead.
     *
     * @since 1.4
     */
    int sqlStateSQL99 = sqlStateSQL;

    /**
     * Indicates whether the SQLSTATE returned by &lt;code&gt;SQLException.getSQLState&lt;/code&gt;
     * is X/Open (now known as Open Group) SQL CLI or SQL:2003.
     * @return the type of SQLSTATE; one of:
     *        sqlStateXOpen or
     *        sqlStateSQL
     * @throws SQLException if a database access error occurs
     * @since 1.4
     */
    int getSQLStateType() throws SQLException;

    /**
     * Indicates whether updates made to a LOB are made on a copy or directly
     * to the LOB.
     * @return &lt;code&gt;true&lt;/code&gt; if updates are made to a copy of the LOB;
     *         &lt;code&gt;false&lt;/code&gt; if updates are made directly to the LOB
     * @throws SQLException if a database access error occurs
     * @since 1.4
     */
    boolean locatorsUpdateCopy() throws SQLException;

    /**
     * Retrieves whether this database supports statement pooling.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @throws SQLException if a database access error occurs
     * @since 1.4
     */
    boolean supportsStatementPooling() throws SQLException;

    //------------------------- JDBC 4.0 -----------------------------------

    /**
     * Indicates whether or not this data source supports the SQL &lt;code&gt;ROWID&lt;/code&gt; type,
     * and if so  the lifetime for which a &lt;code&gt;RowId&lt;/code&gt; object remains valid.
     * &lt;p&gt;
     * The returned int values have the following relationship:
     * &lt;pre&gt;{@code
     *     ROWID_UNSUPPORTED &lt; ROWID_VALID_OTHER &lt; ROWID_VALID_TRANSACTION
     *         &lt; ROWID_VALID_SESSION &lt; ROWID_VALID_FOREVER
     * }&lt;/pre&gt;
     * so conditional logic such as
     * &lt;pre&gt;{@code
     *     if (metadata.getRowIdLifetime() &gt; DatabaseMetaData.ROWID_VALID_TRANSACTION)
     * }&lt;/pre&gt;
     * can be used. Valid Forever means valid across all Sessions, and valid for
     * a Session means valid across all its contained Transactions.
     *
     * @return the status indicating the lifetime of a &lt;code&gt;RowId&lt;/code&gt;
     * @throws SQLException if a database access error occurs
     * @since 1.6
     */
    RowIdLifetime getRowIdLifetime() throws SQLException;

    /**
     * Retrieves the schema names available in this database.  The results
     * are ordered by &lt;code&gt;TABLE_CATALOG&lt;/code&gt; and
     * &lt;code&gt;TABLE_SCHEM&lt;/code&gt;.
     *
     * &lt;P&gt;The schema columns are:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String {@code =&gt;} schema name
     *  &lt;LI&gt;&lt;B&gt;TABLE_CATALOG&lt;/B&gt; String {@code =&gt;} catalog name (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;/OL&gt;
     *
     *
     * @param catalog a catalog name; must match the catalog name as it is stored
     * in the database;&quot;&quot; retrieves those without a catalog; null means catalog
     * name should not be used to narrow down the search.
     * @param schemaPattern a schema name; must match the schema name as it is
     * stored in the database; null means
     * schema name should not be used to narrow down the search.
     * @return a &lt;code&gt;ResultSet&lt;/code&gt; object in which each row is a
     *         schema description
     * @exception SQLException if a database access error occurs
     * @see #getSearchStringEscape
     * @since 1.6
     */
    ResultSet getSchemas(String catalog, String schemaPattern) throws SQLException;

    /**
     * Retrieves whether this database supports invoking user-defined or vendor functions
     * using the stored procedure escape syntax.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.6
     */
    boolean supportsStoredFunctionsUsingCallSyntax() throws SQLException;

    /**
     * Retrieves whether a &lt;code&gt;SQLException&lt;/code&gt; while autoCommit is &lt;code&gt;true&lt;/code&gt; indicates
     * that all open ResultSets are closed, even ones that are holdable.  When a &lt;code&gt;SQLException&lt;/code&gt; occurs while
     * autocommit is &lt;code&gt;true&lt;/code&gt;, it is vendor specific whether the JDBC driver responds with a commit operation, a
     * rollback operation, or by doing neither a commit nor a rollback.  A potential result of this difference
     * is in whether or not holdable ResultSets are closed.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.6
     */
    boolean autoCommitFailureClosesAllResultSets() throws SQLException;
        /**
         * Retrieves a list of the client info properties
         * that the driver supports.  The result set contains the following columns
         *
         * &lt;ol&gt;
         * &lt;li&gt;&lt;b&gt;NAME&lt;/b&gt; String{@code =&gt;} The name of the client info property&lt;br&gt;
         * &lt;li&gt;&lt;b&gt;MAX_LEN&lt;/b&gt; int{@code =&gt;} The maximum length of the value for the property&lt;br&gt;
         * &lt;li&gt;&lt;b&gt;DEFAULT_VALUE&lt;/b&gt; String{@code =&gt;} The default value of the property&lt;br&gt;
         * &lt;li&gt;&lt;b&gt;DESCRIPTION&lt;/b&gt; String{@code =&gt;} A description of the property.  This will typically
         *                                              contain information as to where this property is
         *                                              stored in the database.
         * &lt;/ol&gt;
         * &lt;p&gt;
         * The &lt;code&gt;ResultSet&lt;/code&gt; is sorted by the NAME column
         * &lt;p&gt;
         * @return      A &lt;code&gt;ResultSet&lt;/code&gt; object; each row is a supported client info
         * property
         * &lt;p&gt;
         *  @exception SQLException if a database access error occurs
         * &lt;p&gt;
         * @since 1.6
         */
        ResultSet getClientInfoProperties()
                throws SQLException;

    /**
     * Retrieves a description of the  system and user functions available
     * in the given catalog.
     * &lt;P&gt;
     * Only system and user function descriptions matching the schema and
     * function name criteria are returned.  They are ordered by
     * &lt;code&gt;FUNCTION_CAT&lt;/code&gt;, &lt;code&gt;FUNCTION_SCHEM&lt;/code&gt;,
     * &lt;code&gt;FUNCTION_NAME&lt;/code&gt; and
     * &lt;code&gt;SPECIFIC_ NAME&lt;/code&gt;.
     *
     * &lt;P&gt;Each function description has the the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;FUNCTION_CAT&lt;/B&gt; String {@code =&gt;} function catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;FUNCTION_SCHEM&lt;/B&gt; String {@code =&gt;} function schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;FUNCTION_NAME&lt;/B&gt; String {@code =&gt;} function name.  This is the name
     * used to invoke the function
     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String {@code =&gt;} explanatory comment on the function
     * &lt;LI&gt;&lt;B&gt;FUNCTION_TYPE&lt;/B&gt; short {@code =&gt;} kind of function:
     *      &lt;UL&gt;
     *      &lt;LI&gt;functionResultUnknown - Cannot determine if a return value
     *       or table will be returned
     *      &lt;LI&gt; functionNoTable- Does not return a table
     *      &lt;LI&gt; functionReturnsTable - Returns a table
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;SPECIFIC_NAME&lt;/B&gt; String  {@code =&gt;} the name which uniquely identifies
     *  this function within its schema.  This is a user specified, or DBMS
     * generated, name that may be different then the &lt;code&gt;FUNCTION_NAME&lt;/code&gt;
     * for example with overload functions
     *  &lt;/OL&gt;
     * &lt;p&gt;
     * A user may not have permission to execute any of the functions that are
     * returned by &lt;code&gt;getFunctions&lt;/code&gt;
     *
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schemaPattern a schema name pattern; must match the schema name
     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param functionNamePattern a function name pattern; must match the
     *        function name as it is stored in the database
     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a function description
     * @exception SQLException if a database access error occurs
     * @see #getSearchStringEscape
     * @since 1.6
     */
    ResultSet getFunctions(String catalog, String schemaPattern,
                            String functionNamePattern) throws SQLException;
    /**
     * Retrieves a description of the given catalog's system or user
     * function parameters and return type.
     *
     * &lt;P&gt;Only descriptions matching the schema,  function and
     * parameter name criteria are returned. They are ordered by
     * &lt;code&gt;FUNCTION_CAT&lt;/code&gt;, &lt;code&gt;FUNCTION_SCHEM&lt;/code&gt;,
     * &lt;code&gt;FUNCTION_NAME&lt;/code&gt; and
     * &lt;code&gt;SPECIFIC_ NAME&lt;/code&gt;. Within this, the return value,
     * if any, is first. Next are the parameter descriptions in call
     * order. The column descriptions follow in column number order.
     *
     * &lt;P&gt;Each row in the &lt;code&gt;ResultSet&lt;/code&gt;
     * is a parameter description, column description or
     * return type description with the following fields:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;FUNCTION_CAT&lt;/B&gt; String {@code =&gt;} function catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;FUNCTION_SCHEM&lt;/B&gt; String {@code =&gt;} function schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;FUNCTION_NAME&lt;/B&gt; String {@code =&gt;} function name.  This is the name
     * used to invoke the function
     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String {@code =&gt;} column/parameter name
     *  &lt;LI&gt;&lt;B&gt;COLUMN_TYPE&lt;/B&gt; Short {@code =&gt;} kind of column/parameter:
     *      &lt;UL&gt;
     *      &lt;LI&gt; functionColumnUnknown - nobody knows
     *      &lt;LI&gt; functionColumnIn - IN parameter
     *      &lt;LI&gt; functionColumnInOut - INOUT parameter
     *      &lt;LI&gt; functionColumnOut - OUT parameter
     *      &lt;LI&gt; functionColumnReturn - function return value
     *      &lt;LI&gt; functionColumnResult - Indicates that the parameter or column
     *  is a column in the &lt;code&gt;ResultSet&lt;/code&gt;
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int {@code =&gt;} SQL type from java.sql.Types
     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String {@code =&gt;} SQL type name, for a UDT type the
     *  type name is fully qualified
     *  &lt;LI&gt;&lt;B&gt;PRECISION&lt;/B&gt; int {@code =&gt;} precision
     *  &lt;LI&gt;&lt;B&gt;LENGTH&lt;/B&gt; int {@code =&gt;} length in bytes of data
     *  &lt;LI&gt;&lt;B&gt;SCALE&lt;/B&gt; short {@code =&gt;} scale -  null is returned for data types where
     * SCALE is not applicable.
     *  &lt;LI&gt;&lt;B&gt;RADIX&lt;/B&gt; short {@code =&gt;} radix
     *  &lt;LI&gt;&lt;B&gt;NULLABLE&lt;/B&gt; short {@code =&gt;} can it contain NULL.
     *      &lt;UL&gt;
     *      &lt;LI&gt; functionNoNulls - does not allow NULL values
     *      &lt;LI&gt; functionNullable - allows NULL values
     *      &lt;LI&gt; functionNullableUnknown - nullability unknown
     *      &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String {@code =&gt;} comment describing column/parameter
     *  &lt;LI&gt;&lt;B&gt;CHAR_OCTET_LENGTH&lt;/B&gt; int  {@code =&gt;} the maximum length of binary
     * and character based parameters or columns.  For any other datatype the returned value
     * is a NULL
     *  &lt;LI&gt;&lt;B&gt;ORDINAL_POSITION&lt;/B&gt; int  {@code =&gt;} the ordinal position, starting
     * from 1, for the input and output parameters. A value of 0
     * is returned if this row describes the function's return value.
     * For result set columns, it is the
     * ordinal position of the column in the result set starting from 1.
     *  &lt;LI&gt;&lt;B&gt;IS_NULLABLE&lt;/B&gt; String  {@code =&gt;} ISO rules are used to determine
     * the nullability for a parameter or column.
     *       &lt;UL&gt;
     *       &lt;LI&gt; YES           --- if the parameter or column can include NULLs
     *       &lt;LI&gt; NO            --- if the parameter or column  cannot include NULLs
     *       &lt;LI&gt; empty string  --- if the nullability for the
     * parameter  or column is unknown
     *       &lt;/UL&gt;
     *  &lt;LI&gt;&lt;B&gt;SPECIFIC_NAME&lt;/B&gt; String  {@code =&gt;} the name which uniquely identifies
     * this function within its schema.  This is a user specified, or DBMS
     * generated, name that may be different then the &lt;code&gt;FUNCTION_NAME&lt;/code&gt;
     * for example with overload functions
     *  &lt;/OL&gt;
     *
     * &lt;p&gt;The PRECISION column represents the specified column size for the given
     * parameter or column.
     * For numeric data, this is the maximum precision.  For character data, this is the length in characters.
     * For datetime datatypes, this is the length in characters of the String representation (assuming the
     * maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes.  For the ROWID datatype,
     * this is the length in bytes. Null is returned for data types where the
     * column size is not applicable.
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schemaPattern a schema name pattern; must match the schema name
     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param functionNamePattern a procedure name pattern; must match the
     *        function name as it is stored in the database
     * @param columnNamePattern a parameter name pattern; must match the
     * parameter or column name as it is stored in the database
     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row describes a
     * user function parameter, column  or return type
     *
     * @exception SQLException if a database access error occurs
     * @see #getSearchStringEscape
     * @since 1.6
     */
    ResultSet getFunctionColumns(String catalog,
                                  String schemaPattern,
                                  String functionNamePattern,
                                  String columnNamePattern) throws SQLException;


    /**
     * Indicates that type of the parameter or column is unknown.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;COLUMN_TYPE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt;
     * returned by the method &lt;code&gt;getFunctionColumns&lt;/code&gt;.
     */
    int functionColumnUnknown = 0;

    /**
     * Indicates that the parameter or column is an IN parameter.
     * &lt;P&gt;
     *  A possible value for the column
     * &lt;code&gt;COLUMN_TYPE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt;
     * returned by the method &lt;code&gt;getFunctionColumns&lt;/code&gt;.
     * @since 1.6
     */
    int functionColumnIn = 1;

    /**
     * Indicates that the parameter or column is an INOUT parameter.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;COLUMN_TYPE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt;
     * returned by the method &lt;code&gt;getFunctionColumns&lt;/code&gt;.
     * @since 1.6
     */
    int functionColumnInOut = 2;

    /**
     * Indicates that the parameter or column is an OUT parameter.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;COLUMN_TYPE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt;
     * returned by the method &lt;code&gt;getFunctionColumns&lt;/code&gt;.
     * @since 1.6
     */
    int functionColumnOut = 3;
    /**
     * Indicates that the parameter or column is a return value.
     * &lt;P&gt;
     *  A possible value for the column
     * &lt;code&gt;COLUMN_TYPE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt;
     * returned by the method &lt;code&gt;getFunctionColumns&lt;/code&gt;.
     * @since 1.6
     */
    int functionReturn = 4;

       /**
     * Indicates that the parameter or column is a column in a result set.
     * &lt;P&gt;
     *  A possible value for the column
     * &lt;code&gt;COLUMN_TYPE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt;
     * returned by the method &lt;code&gt;getFunctionColumns&lt;/code&gt;.
     * @since 1.6
     */
    int functionColumnResult = 5;


    /**
     * Indicates that &lt;code&gt;NULL&lt;/code&gt; values are not allowed.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;NULLABLE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getFunctionColumns&lt;/code&gt;.
     * @since 1.6
     */
    int functionNoNulls = 0;

    /**
     * Indicates that &lt;code&gt;NULL&lt;/code&gt; values are allowed.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;NULLABLE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getFunctionColumns&lt;/code&gt;.
     * @since 1.6
     */
    int functionNullable = 1;

    /**
     * Indicates that whether &lt;code&gt;NULL&lt;/code&gt; values are allowed
     * is unknown.
     * &lt;P&gt;
     * A possible value for the column
     * &lt;code&gt;NULLABLE&lt;/code&gt;
     * in the &lt;code&gt;ResultSet&lt;/code&gt; object
     * returned by the method &lt;code&gt;getFunctionColumns&lt;/code&gt;.
     * @since 1.6
     */
    int functionNullableUnknown = 2;

    /**
     * Indicates that it is not known whether the function returns
     * a result or a table.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;FUNCTION_TYPE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getFunctions&lt;/code&gt;.
     * @since 1.6
     */
    int functionResultUnknown   = 0;

    /**
     * Indicates that the function  does not return a table.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;FUNCTION_TYPE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getFunctions&lt;/code&gt;.
     * @since 1.6
     */
    int functionNoTable         = 1;

    /**
     * Indicates that the function  returns a table.
     * &lt;P&gt;
     * A possible value for column &lt;code&gt;FUNCTION_TYPE&lt;/code&gt; in the
     * &lt;code&gt;ResultSet&lt;/code&gt; object returned by the method
     * &lt;code&gt;getFunctions&lt;/code&gt;.
     * @since 1.6
     */
    int functionReturnsTable    = 2;

    //--------------------------JDBC 4.1 -----------------------------

    /**
     * Retrieves a description of the pseudo or hidden columns available
     * in a given table within the specified catalog and schema.
     * Pseudo or hidden columns may not always be stored within
     * a table and are not visible in a ResultSet unless they are
     * specified in the query's outermost SELECT list. Pseudo or hidden
     * columns may not necessarily be able to be modified. If there are
     * no pseudo or hidden columns, an empty ResultSet is returned.
     *
     * &lt;P&gt;Only column descriptions matching the catalog, schema, table
     * and column name criteria are returned.  They are ordered by
     * &lt;code&gt;TABLE_CAT&lt;/code&gt;,&lt;code&gt;TABLE_SCHEM&lt;/code&gt;, &lt;code&gt;TABLE_NAME&lt;/code&gt;
     * and &lt;code&gt;COLUMN_NAME&lt;/code&gt;.
     *
     * &lt;P&gt;Each column description has the following columns:
     *  &lt;OL&gt;
     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String {@code =&gt;} table catalog (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String {@code =&gt;} table schema (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String {@code =&gt;} table name
     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String {@code =&gt;} column name
     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int {@code =&gt;} SQL type from java.sql.Types
     *  &lt;LI&gt;&lt;B&gt;COLUMN_SIZE&lt;/B&gt; int {@code =&gt;} column size.
     *  &lt;LI&gt;&lt;B&gt;DECIMAL_DIGITS&lt;/B&gt; int {@code =&gt;} the number of fractional digits. Null is returned for data types where
     * DECIMAL_DIGITS is not applicable.
     *  &lt;LI&gt;&lt;B&gt;NUM_PREC_RADIX&lt;/B&gt; int {@code =&gt;} Radix (typically either 10 or 2)
     *  &lt;LI&gt;&lt;B&gt;COLUMN_USAGE&lt;/B&gt; String {@code =&gt;} The allowed usage for the column.  The
     *  value returned will correspond to the enum name returned by {@link PseudoColumnUsage#name PseudoColumnUsage.name()}
     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String {@code =&gt;} comment describing column (may be &lt;code&gt;null&lt;/code&gt;)
     *  &lt;LI&gt;&lt;B&gt;CHAR_OCTET_LENGTH&lt;/B&gt; int {@code =&gt;} for char types the
     *       maximum number of bytes in the column
     *  &lt;LI&gt;&lt;B&gt;IS_NULLABLE&lt;/B&gt; String  {@code =&gt;} ISO rules are used to determine the nullability for a column.
     *       &lt;UL&gt;
     *       &lt;LI&gt; YES           --- if the column can include NULLs
     *       &lt;LI&gt; NO            --- if the column cannot include NULLs
     *       &lt;LI&gt; empty string  --- if the nullability for the column is unknown
     *       &lt;/UL&gt;
     *  &lt;/OL&gt;
     *
     * &lt;p&gt;The COLUMN_SIZE column specifies the column size for the given column.
     * For numeric data, this is the maximum precision.  For character data, this is the length in characters.
     * For datetime datatypes, this is the length in characters of the String representation (assuming the
     * maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes.  For the ROWID datatype,
     * this is the length in bytes. Null is returned for data types where the
     * column size is not applicable.
     *
     * @param catalog a catalog name; must match the catalog name as it
     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
     *        the search
     * @param schemaPattern a schema name pattern; must match the schema name
     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
     *        the search
     * @param tableNamePattern a table name pattern; must match the
     *        table name as it is stored in the database
     * @param columnNamePattern a column name pattern; must match the column
     *        name as it is stored in the database
     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a column description
     * @exception SQLException if a database access error occurs
     * @see PseudoColumnUsage
     * @since 1.7
     */
    ResultSet getPseudoColumns(String catalog, String schemaPattern,
                         String tableNamePattern, String columnNamePattern)
        throws SQLException;

    /**
     * Retrieves whether a generated key will always be returned if the column
     * name(s) or index(es) specified for the auto generated key column(s)
     * are valid and the statement succeeds.  The key that is returned may or
     * may not be based on the column(s) for the auto generated key.
     * Consult your JDBC driver documentation for additional details.
     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.7
     */
    boolean  generatedKeyAlwaysReturned() throws SQLException;

    //--------------------------JDBC 4.2 -----------------------------

    /**
     *
     * Retrieves the maximum number of bytes this database allows for
     * the logical size for a {@code LOB}.
     *&lt;p&gt;
     * The default implementation will return {@code 0}
     *
     * @return the maximum number of bytes allowed; a result of zero
     * means that there is no limit or the limit is not known
     * @exception SQLException if a database access error occurs
     * @since 1.8
     */
    default long getMaxLogicalLobSize() throws SQLException {
        return 0;
    }

    /**
     * Retrieves whether this database supports REF CURSOR.
     *&lt;p&gt;
     * The default implementation will return {@code false}
     *
     * @return {@code true} if this database supports REF CURSOR;
     *         {@code false} otherwise
     * @exception SQLException if a database access error occurs
     * @since 1.8
     */
    default boolean supportsRefCursors() throws SQLException{
        return false;
    }

}
</pre>
</body>
</html>
