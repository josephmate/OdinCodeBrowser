<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.rmi.server;

import java.rmi.Remote;
import java.rmi.NoSuchObjectException;
import java.lang.reflect.Proxy;
import sun.rmi.server.Util;

/**
 * The &lt;code&gt;RemoteObject&lt;/code&gt; class implements the
 * &lt;code&gt;java.lang.Object&lt;/code&gt; behavior for remote objects.
 * &lt;code&gt;RemoteObject&lt;/code&gt; provides the remote semantics of Object by
 * implementing methods for hashCode, equals, and toString.
 *
 * @author      Ann Wollrath
 * @author      Laird Dornin
 * @author      Peter Jones
 * @since       JDK1.1
 */
public abstract class RemoteObject implements Remote, java.io.Serializable {

    /** The object's remote reference. */
    transient protected RemoteRef ref;

    /** indicate compatibility with JDK 1.1.x version of class */
    private static final long serialVersionUID = -3215090123894869218L;

    /**
     * Creates a remote object.
     */
    protected RemoteObject() {
        ref = null;
    }

    /**
     * Creates a remote object, initialized with the specified remote
     * reference.
     * @param newref remote reference
     */
    protected RemoteObject(RemoteRef newref) {
        ref = newref;
    }

    /**
     * Returns the remote reference for the remote object.
     *
     * &lt;p&gt;Note: The object returned from this method may be an instance of
     * an implementation-specific class.  The &lt;code&gt;RemoteObject&lt;/code&gt;
     * class ensures serialization portability of its instances' remote
     * references through the behavior of its custom
     * &lt;code&gt;writeObject&lt;/code&gt; and &lt;code&gt;readObject&lt;/code&gt; methods.  An
     * instance of &lt;code&gt;RemoteRef&lt;/code&gt; should not be serialized outside
     * of its &lt;code&gt;RemoteObject&lt;/code&gt; wrapper instance or the result may
     * be unportable.
     *
     * @return remote reference for the remote object
     * @since 1.2
     */
    public RemoteRef getRef() {
        return ref;
    }

    /**
     * Returns the stub for the remote object &lt;code&gt;obj&lt;/code&gt; passed
     * as a parameter. This operation is only valid &lt;i&gt;after&lt;/i&gt;
     * the object has been exported.
     * @param obj the remote object whose stub is needed
     * @return the stub for the remote object, &lt;code&gt;obj&lt;/code&gt;.
     * @exception NoSuchObjectException if the stub for the
     * remote object could not be found.
     * @since 1.2
     */
    public static Remote toStub(Remote obj) throws NoSuchObjectException {
        if (obj instanceof RemoteStub ||
            (obj != null &amp;&amp;
             Proxy.isProxyClass(obj.getClass()) &amp;&amp;
             Proxy.getInvocationHandler(obj) instanceof
             RemoteObjectInvocationHandler))
        {
            return obj;
        } else {
            return sun.rmi.transport.ObjectTable.getStub(obj);
        }
    }

    /**
     * Returns a hashcode for a remote object.  Two remote object stubs
     * that refer to the same remote object will have the same hash code
     * (in order to support remote objects as keys in hash tables).
     *
     * @see             java.util.Hashtable
     */
    public int hashCode() {
        return (ref == null) ? super.hashCode() : ref.remoteHashCode();
    }

    /**
     * Compares two remote objects for equality.
     * Returns a boolean that indicates whether this remote object is
     * equivalent to the specified Object. This method is used when a
     * remote object is stored in a hashtable.
     * If the specified Object is not itself an instance of RemoteObject,
     * then this method delegates by returning the result of invoking the
     * &lt;code&gt;equals&lt;/code&gt; method of its parameter with this remote object
     * as the argument.
     * @param   obj     the Object to compare with
     * @return  true if these Objects are equal; false otherwise.
     * @see             java.util.Hashtable
     */
    public boolean equals(Object obj) {
        if (obj instanceof RemoteObject) {
            if (ref == null) {
                return obj == this;
            } else {
                return ref.remoteEquals(((RemoteObject)obj).ref);
            }
        } else if (obj != null) {
            /*
             * Fix for 4099660: if object is not an instance of RemoteObject,
             * use the result of its equals method, to support symmetry is a
             * remote object implementation class that does not extend
             * RemoteObject wishes to support equality with its stub objects.
             */
            return obj.equals(this);
        } else {
            return false;
        }
    }

    /**
     * Returns a String that represents the value of this remote object.
     */
    public String toString() {
        String classname = Util.getUnqualifiedName(getClass());
        return (ref == null) ? classname :
            classname + &quot;[&quot; + ref.remoteToString() + &quot;]&quot;;
    }

    /**
     * &lt;code&gt;writeObject&lt;/code&gt; for custom serialization.
     *
     * &lt;p&gt;This method writes this object's serialized form for this class
     * as follows:
     *
     * &lt;p&gt;The {@link RemoteRef#getRefClass(java.io.ObjectOutput) getRefClass}
     * method is invoked on this object's &lt;code&gt;ref&lt;/code&gt; field
     * to obtain its external ref type name.
     * If the value returned by &lt;code&gt;getRefClass&lt;/code&gt; was
     * a non-&lt;code&gt;null&lt;/code&gt; string of length greater than zero,
     * the &lt;code&gt;writeUTF&lt;/code&gt; method is invoked on &lt;code&gt;out&lt;/code&gt;
     * with the value returned by &lt;code&gt;getRefClass&lt;/code&gt;, and then
     * the &lt;code&gt;writeExternal&lt;/code&gt; method is invoked on
     * this object's &lt;code&gt;ref&lt;/code&gt; field passing &lt;code&gt;out&lt;/code&gt;
     * as the argument; otherwise,
     * the &lt;code&gt;writeUTF&lt;/code&gt; method is invoked on &lt;code&gt;out&lt;/code&gt;
     * with a zero-length string (&lt;code&gt;&quot;&quot;&lt;/code&gt;), and then
     * the &lt;code&gt;writeObject&lt;/code&gt; method is invoked on &lt;code&gt;out&lt;/code&gt;
     * passing this object's &lt;code&gt;ref&lt;/code&gt; field as the argument.
     *
     * @serialData
     *
     * The serialized data for this class comprises a string (written with
     * &lt;code&gt;ObjectOutput.writeUTF&lt;/code&gt;) that is either the external
     * ref type name of the contained &lt;code&gt;RemoteRef&lt;/code&gt; instance
     * (the &lt;code&gt;ref&lt;/code&gt; field) or a zero-length string, followed by
     * either the external form of the &lt;code&gt;ref&lt;/code&gt; field as written by
     * its &lt;code&gt;writeExternal&lt;/code&gt; method if the string was of non-zero
     * length, or the serialized form of the &lt;code&gt;ref&lt;/code&gt; field as
     * written by passing it to the serialization stream's
     * &lt;code&gt;writeObject&lt;/code&gt; if the string was of zero length.
     *
     * &lt;p&gt;If this object is an instance of
     * {@link RemoteStub} or {@link RemoteObjectInvocationHandler}
     * that was returned from any of
     * the &lt;code&gt;UnicastRemoteObject.exportObject&lt;/code&gt; methods
     * and custom socket factories are not used,
     * the external ref type name is &lt;code&gt;&quot;UnicastRef&quot;&lt;/code&gt;.
     *
     * If this object is an instance of
     * &lt;code&gt;RemoteStub&lt;/code&gt; or &lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt;
     * that was returned from any of
     * the &lt;code&gt;UnicastRemoteObject.exportObject&lt;/code&gt; methods
     * and custom socket factories are used,
     * the external ref type name is &lt;code&gt;&quot;UnicastRef2&quot;&lt;/code&gt;.
     *
     * If this object is an instance of
     * &lt;code&gt;RemoteStub&lt;/code&gt; or &lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt;
     * that was returned from any of
     * the &lt;code&gt;java.rmi.activation.Activatable.exportObject&lt;/code&gt; methods,
     * the external ref type name is &lt;code&gt;&quot;ActivatableRef&quot;&lt;/code&gt;.
     *
     * If this object is an instance of
     * &lt;code&gt;RemoteStub&lt;/code&gt; or &lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt;
     * that was returned from
     * the &lt;code&gt;RemoteObject.toStub&lt;/code&gt; method (and the argument passed
     * to &lt;code&gt;toStub&lt;/code&gt; was not itself a &lt;code&gt;RemoteStub&lt;/code&gt;),
     * the external ref type name is a function of how the remote object
     * passed to &lt;code&gt;toStub&lt;/code&gt; was exported, as described above.
     *
     * If this object is an instance of
     * &lt;code&gt;RemoteStub&lt;/code&gt; or &lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt;
     * that was originally created via deserialization,
     * the external ref type name is the same as that which was read
     * when this object was deserialized.
     *
     * &lt;p&gt;If this object is an instance of
     * &lt;code&gt;java.rmi.server.UnicastRemoteObject&lt;/code&gt; that does not
     * use custom socket factories,
     * the external ref type name is &lt;code&gt;&quot;UnicastServerRef&quot;&lt;/code&gt;.
     *
     * If this object is an instance of
     * &lt;code&gt;UnicastRemoteObject&lt;/code&gt; that does
     * use custom socket factories,
     * the external ref type name is &lt;code&gt;&quot;UnicastServerRef2&quot;&lt;/code&gt;.
     *
     * &lt;p&gt;Following is the data that must be written by the
     * &lt;code&gt;writeExternal&lt;/code&gt; method and read by the
     * &lt;code&gt;readExternal&lt;/code&gt; method of &lt;code&gt;RemoteRef&lt;/code&gt;
     * implementation classes that correspond to the each of the
     * defined external ref type names:
     *
     * &lt;p&gt;For &lt;code&gt;&quot;UnicastRef&quot;&lt;/code&gt;:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;the hostname of the referenced remote object,
     * written by {@link java.io.ObjectOutput#writeUTF(String)}
     *
     * &lt;li&gt;the port of the referenced remote object,
     * written by {@link java.io.ObjectOutput#writeInt(int)}
     *
     * &lt;li&gt;the data written as a result of calling
     * {link java.rmi.server.ObjID#write(java.io.ObjectOutput)}
     * on the &lt;code&gt;ObjID&lt;/code&gt; instance contained in the reference
     *
     * &lt;li&gt;the boolean value &lt;code&gt;false&lt;/code&gt;,
     * written by {@link java.io.ObjectOutput#writeBoolean(boolean)}
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt;For &lt;code&gt;&quot;UnicastRef2&quot;&lt;/code&gt; with a
     * &lt;code&gt;null&lt;/code&gt; client socket factory:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;the byte value &lt;code&gt;0x00&lt;/code&gt;
     * (indicating &lt;code&gt;null&lt;/code&gt; client socket factory),
     * written by {@link java.io.ObjectOutput#writeByte(int)}
     *
     * &lt;li&gt;the hostname of the referenced remote object,
     * written by {@link java.io.ObjectOutput#writeUTF(String)}
     *
     * &lt;li&gt;the port of the referenced remote object,
     * written by {@link java.io.ObjectOutput#writeInt(int)}
     *
     * &lt;li&gt;the data written as a result of calling
     * {link java.rmi.server.ObjID#write(java.io.ObjectOutput)}
     * on the &lt;code&gt;ObjID&lt;/code&gt; instance contained in the reference
     *
     * &lt;li&gt;the boolean value &lt;code&gt;false&lt;/code&gt;,
     * written by {@link java.io.ObjectOutput#writeBoolean(boolean)}
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt;For &lt;code&gt;&quot;UnicastRef2&quot;&lt;/code&gt; with a
     * non-&lt;code&gt;null&lt;/code&gt; client socket factory:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;the byte value &lt;code&gt;0x01&lt;/code&gt;
     * (indicating non-&lt;code&gt;null&lt;/code&gt; client socket factory),
     * written by {@link java.io.ObjectOutput#writeByte(int)}
     *
     * &lt;li&gt;the hostname of the referenced remote object,
     * written by {@link java.io.ObjectOutput#writeUTF(String)}
     *
     * &lt;li&gt;the port of the referenced remote object,
     * written by {@link java.io.ObjectOutput#writeInt(int)}
     *
     * &lt;li&gt;a client socket factory (object of type
     * &lt;code&gt;java.rmi.server.RMIClientSocketFactory&lt;/code&gt;),
     * written by passing it to an invocation of
     * &lt;code&gt;writeObject&lt;/code&gt; on the stream instance
     *
     * &lt;li&gt;the data written as a result of calling
     * {link java.rmi.server.ObjID#write(java.io.ObjectOutput)}
     * on the &lt;code&gt;ObjID&lt;/code&gt; instance contained in the reference
     *
     * &lt;li&gt;the boolean value &lt;code&gt;false&lt;/code&gt;,
     * written by {@link java.io.ObjectOutput#writeBoolean(boolean)}
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt;For &lt;code&gt;&quot;ActivatableRef&quot;&lt;/code&gt; with a
     * &lt;code&gt;null&lt;/code&gt; nested remote reference:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;an instance of
     * &lt;code&gt;java.rmi.activation.ActivationID&lt;/code&gt;,
     * written by passing it to an invocation of
     * &lt;code&gt;writeObject&lt;/code&gt; on the stream instance
     *
     * &lt;li&gt;a zero-length string (&lt;code&gt;&quot;&quot;&lt;/code&gt;),
     * written by {@link java.io.ObjectOutput#writeUTF(String)}
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt;For &lt;code&gt;&quot;ActivatableRef&quot;&lt;/code&gt; with a
     * non-&lt;code&gt;null&lt;/code&gt; nested remote reference:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;an instance of
     * &lt;code&gt;java.rmi.activation.ActivationID&lt;/code&gt;,
     * written by passing it to an invocation of
     * &lt;code&gt;writeObject&lt;/code&gt; on the stream instance
     *
     * &lt;li&gt;the external ref type name of the nested remote reference,
     * which must be &lt;code&gt;&quot;UnicastRef2&quot;&lt;/code&gt;,
     * written by {@link java.io.ObjectOutput#writeUTF(String)}
     *
     * &lt;li&gt;the external form of the nested remote reference,
     * written by invoking its &lt;code&gt;writeExternal&lt;/code&gt; method
     * with the stream instance
     * (see the description of the external form for
     * &lt;code&gt;&quot;UnicastRef2&quot;&lt;/code&gt; above)
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt;For &lt;code&gt;&quot;UnicastServerRef&quot;&lt;/code&gt; and
     * &lt;code&gt;&quot;UnicastServerRef2&quot;&lt;/code&gt;, no data is written by the
     * &lt;code&gt;writeExternal&lt;/code&gt; method or read by the
     * &lt;code&gt;readExternal&lt;/code&gt; method.
     */
    private void writeObject(java.io.ObjectOutputStream out)
        throws java.io.IOException, java.lang.ClassNotFoundException
    {
        if (ref == null) {
            throw new java.rmi.MarshalException(&quot;Invalid remote object&quot;);
        } else {
            String refClassName = ref.getRefClass(out);
            if (refClassName == null || refClassName.length() == 0) {
                /*
                 * No reference class name specified, so serialize
                 * remote reference.
                 */
                out.writeUTF(&quot;&quot;);
                out.writeObject(ref);
            } else {
                /*
                 * Built-in reference class specified, so delegate
                 * to reference to write out its external form.
                 */
                out.writeUTF(refClassName);
                ref.writeExternal(out);
            }
        }
    }

    /**
     * &lt;code&gt;readObject&lt;/code&gt; for custom serialization.
     *
     * &lt;p&gt;This method reads this object's serialized form for this class
     * as follows:
     *
     * &lt;p&gt;The &lt;code&gt;readUTF&lt;/code&gt; method is invoked on &lt;code&gt;in&lt;/code&gt;
     * to read the external ref type name for the &lt;code&gt;RemoteRef&lt;/code&gt;
     * instance to be filled in to this object's &lt;code&gt;ref&lt;/code&gt; field.
     * If the string returned by &lt;code&gt;readUTF&lt;/code&gt; has length zero,
     * the &lt;code&gt;readObject&lt;/code&gt; method is invoked on &lt;code&gt;in&lt;/code&gt;,
     * and than the value returned by &lt;code&gt;readObject&lt;/code&gt; is cast to
     * &lt;code&gt;RemoteRef&lt;/code&gt; and this object's &lt;code&gt;ref&lt;/code&gt; field is
     * set to that value.
     * Otherwise, this object's &lt;code&gt;ref&lt;/code&gt; field is set to a
     * &lt;code&gt;RemoteRef&lt;/code&gt; instance that is created of an
     * implementation-specific class corresponding to the external ref
     * type name returned by &lt;code&gt;readUTF&lt;/code&gt;, and then
     * the &lt;code&gt;readExternal&lt;/code&gt; method is invoked on
     * this object's &lt;code&gt;ref&lt;/code&gt; field.
     *
     * &lt;p&gt;If the external ref type name is
     * &lt;code&gt;&quot;UnicastRef&quot;&lt;/code&gt;, &lt;code&gt;&quot;UnicastServerRef&quot;&lt;/code&gt;,
     * &lt;code&gt;&quot;UnicastRef2&quot;&lt;/code&gt;, &lt;code&gt;&quot;UnicastServerRef2&quot;&lt;/code&gt;,
     * or &lt;code&gt;&quot;ActivatableRef&quot;&lt;/code&gt;, a corresponding
     * implementation-specific class must be found, and its
     * &lt;code&gt;readExternal&lt;/code&gt; method must read the serial data
     * for that external ref type name as specified to be written
     * in the &lt;b&gt;serialData&lt;/b&gt; documentation for this class.
     * If the external ref type name is any other string (of non-zero
     * length), a &lt;code&gt;ClassNotFoundException&lt;/code&gt; will be thrown,
     * unless the implementation provides an implementation-specific
     * class corresponding to that external ref type name, in which
     * case this object's &lt;code&gt;ref&lt;/code&gt; field will be set to an
     * instance of that implementation-specific class.
     */
    private void readObject(java.io.ObjectInputStream in)
        throws java.io.IOException, java.lang.ClassNotFoundException
    {
        String refClassName = in.readUTF();
        if (refClassName == null || refClassName.length() == 0) {
            /*
             * No reference class name specified, so construct
             * remote reference from its serialized form.
             */
            ref = (RemoteRef) in.readObject();
        } else {
            /*
             * Built-in reference class specified, so delegate to
             * internal reference class to initialize its fields from
             * its external form.
             */
            String internalRefClassName =
                RemoteRef.packagePrefix + &quot;.&quot; + refClassName;
            Class&lt;?&gt; refClass = Class.forName(internalRefClassName);
            try {
                ref = (RemoteRef) refClass.newInstance();

                /*
                 * If this step fails, assume we found an internal
                 * class that is not meant to be a serializable ref
                 * type.
                 */
            } catch (InstantiationException e) {
                throw new ClassNotFoundException(internalRefClassName, e);
            } catch (IllegalAccessException e) {
                throw new ClassNotFoundException(internalRefClassName, e);
            } catch (ClassCastException e) {
                throw new ClassNotFoundException(internalRefClassName, e);
            }
            ref.readExternal(in);
        }
    }
}
</pre>
</body>
</html>
