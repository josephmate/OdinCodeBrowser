<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.text;

import java.io.Serializable;

/**
 * &lt;code&gt;Format&lt;/code&gt; is an abstract base class for formatting locale-sensitive
 * information such as dates, messages, and numbers.
 *
 * &lt;p&gt;
 * &lt;code&gt;Format&lt;/code&gt; defines the programming interface for formatting
 * locale-sensitive objects into &lt;code&gt;String&lt;/code&gt;s (the
 * &lt;code&gt;format&lt;/code&gt; method) and for parsing &lt;code&gt;String&lt;/code&gt;s back
 * into objects (the &lt;code&gt;parseObject&lt;/code&gt; method).
 *
 * &lt;p&gt;
 * Generally, a format's &lt;code&gt;parseObject&lt;/code&gt; method must be able to parse
 * any string formatted by its &lt;code&gt;format&lt;/code&gt; method. However, there may
 * be exceptional cases where this is not possible. For example, a
 * &lt;code&gt;format&lt;/code&gt; method might create two adjacent integer numbers with
 * no separator in between, and in this case the &lt;code&gt;parseObject&lt;/code&gt; could
 * not tell which digits belong to which number.
 *
 * &lt;h3&gt;Subclassing&lt;/h3&gt;
 *
 * &lt;p&gt;
 * The Java Platform provides three specialized subclasses of &lt;code&gt;Format&lt;/code&gt;--
 * &lt;code&gt;DateFormat&lt;/code&gt;, &lt;code&gt;MessageFormat&lt;/code&gt;, and
 * &lt;code&gt;NumberFormat&lt;/code&gt;--for formatting dates, messages, and numbers,
 * respectively.
 * &lt;p&gt;
 * Concrete subclasses must implement three methods:
 * &lt;ol&gt;
 * &lt;li&gt; &lt;code&gt;format(Object obj, StringBuffer toAppendTo, FieldPosition pos)&lt;/code&gt;
 * &lt;li&gt; &lt;code&gt;formatToCharacterIterator(Object obj)&lt;/code&gt;
 * &lt;li&gt; &lt;code&gt;parseObject(String source, ParsePosition pos)&lt;/code&gt;
 * &lt;/ol&gt;
 * These general methods allow polymorphic parsing and formatting of objects
 * and are used, for example, by &lt;code&gt;MessageFormat&lt;/code&gt;.
 * Subclasses often also provide additional &lt;code&gt;format&lt;/code&gt; methods for
 * specific input types as well as &lt;code&gt;parse&lt;/code&gt; methods for specific
 * result types. Any &lt;code&gt;parse&lt;/code&gt; method that does not take a
 * &lt;code&gt;ParsePosition&lt;/code&gt; argument should throw &lt;code&gt;ParseException&lt;/code&gt;
 * when no text in the required format is at the beginning of the input text.
 *
 * &lt;p&gt;
 * Most subclasses will also implement the following factory methods:
 * &lt;ol&gt;
 * &lt;li&gt;
 * &lt;code&gt;getInstance&lt;/code&gt; for getting a useful format object appropriate
 * for the current locale
 * &lt;li&gt;
 * &lt;code&gt;getInstance(Locale)&lt;/code&gt; for getting a useful format
 * object appropriate for the specified locale
 * &lt;/ol&gt;
 * In addition, some subclasses may also implement other
 * &lt;code&gt;getXxxxInstance&lt;/code&gt; methods for more specialized control. For
 * example, the &lt;code&gt;NumberFormat&lt;/code&gt; class provides
 * &lt;code&gt;getPercentInstance&lt;/code&gt; and &lt;code&gt;getCurrencyInstance&lt;/code&gt;
 * methods for getting specialized number formatters.
 *
 * &lt;p&gt;
 * Subclasses of &lt;code&gt;Format&lt;/code&gt; that allow programmers to create objects
 * for locales (with &lt;code&gt;getInstance(Locale)&lt;/code&gt; for example)
 * must also implement the following class method:
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * public static Locale[] getAvailableLocales()
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * And finally subclasses may define a set of constants to identify the various
 * fields in the formatted output. These constants are used to create a FieldPosition
 * object which identifies what information is contained in the field and its
 * position in the formatted result. These constants should be named
 * &lt;code&gt;&lt;em&gt;item&lt;/em&gt;_FIELD&lt;/code&gt; where &lt;code&gt;&lt;em&gt;item&lt;/em&gt;&lt;/code&gt; identifies
 * the field. For examples of these constants, see &lt;code&gt;ERA_FIELD&lt;/code&gt; and its
 * friends in {@link DateFormat}.
 *
 * &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
 *
 * &lt;p&gt;
 * Formats are generally not synchronized.
 * It is recommended to create separate format instances for each thread.
 * If multiple threads access a format concurrently, it must be synchronized
 * externally.
 *
 * @see          java.text.ParsePosition
 * @see          java.text.FieldPosition
 * @see          java.text.NumberFormat
 * @see          java.text.DateFormat
 * @see          java.text.MessageFormat
 * @author       Mark Davis
 */
public abstract class Format implements Serializable, Cloneable {

    private static final long serialVersionUID = -299282585814624189L;

    /**
     * Sole constructor.  (For invocation by subclass constructors, typically
     * implicit.)
     */
    protected Format() {
    }

    /**
     * Formats an object to produce a string. This is equivalent to
     * &lt;blockquote&gt;
     * {@link #format(Object, StringBuffer, FieldPosition) format}&lt;code&gt;(obj,
     *         new StringBuffer(), new FieldPosition(0)).toString();&lt;/code&gt;
     * &lt;/blockquote&gt;
     *
     * @param obj    The object to format
     * @return       Formatted string.
     * @exception IllegalArgumentException if the Format cannot format the given
     *            object
     */
    public final String format (Object obj) {
        return format(obj, new StringBuffer(), new FieldPosition(0)).toString();
    }

    /**
     * Formats an object and appends the resulting text to a given string
     * buffer.
     * If the &lt;code&gt;pos&lt;/code&gt; argument identifies a field used by the format,
     * then its indices are set to the beginning and end of the first such
     * field encountered.
     *
     * @param obj    The object to format
     * @param toAppendTo    where the text is to be appended
     * @param pos    A &lt;code&gt;FieldPosition&lt;/code&gt; identifying a field
     *               in the formatted text
     * @return       the string buffer passed in as &lt;code&gt;toAppendTo&lt;/code&gt;,
     *               with formatted text appended
     * @exception NullPointerException if &lt;code&gt;toAppendTo&lt;/code&gt; or
     *            &lt;code&gt;pos&lt;/code&gt; is null
     * @exception IllegalArgumentException if the Format cannot format the given
     *            object
     */
    public abstract StringBuffer format(Object obj,
                    StringBuffer toAppendTo,
                    FieldPosition pos);

    /**
     * Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
     * You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
     * to build the resulting String, as well as to determine information
     * about the resulting String.
     * &lt;p&gt;
     * Each attribute key of the AttributedCharacterIterator will be of type
     * &lt;code&gt;Field&lt;/code&gt;. It is up to each &lt;code&gt;Format&lt;/code&gt; implementation
     * to define what the legal values are for each attribute in the
     * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;, but typically the attribute
     * key is also used as the attribute value.
     * &lt;p&gt;The default implementation creates an
     * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; with no attributes. Subclasses
     * that support fields should override this and create an
     * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; with meaningful attributes.
     *
     * @exception NullPointerException if obj is null.
     * @exception IllegalArgumentException when the Format cannot format the
     *            given object.
     * @param obj The object to format
     * @return AttributedCharacterIterator describing the formatted value.
     * @since 1.4
     */
    public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
        return createAttributedCharacterIterator(format(obj));
    }

    /**
     * Parses text from a string to produce an object.
     * &lt;p&gt;
     * The method attempts to parse text starting at the index given by
     * &lt;code&gt;pos&lt;/code&gt;.
     * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
     * to the index after the last character used (parsing does not necessarily
     * use all characters up to the end of the string), and the parsed
     * object is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
     * indicate the starting point for the next call to this method.
     * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
     * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
     * the character where the error occurred, and null is returned.
     *
     * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.
     * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
     *            index information as described above.
     * @return An &lt;code&gt;Object&lt;/code&gt; parsed from the string. In case of
     *         error, returns null.
     * @exception NullPointerException if &lt;code&gt;pos&lt;/code&gt; is null.
     */
    public abstract Object parseObject (String source, ParsePosition pos);

    /**
     * Parses text from the beginning of the given string to produce an object.
     * The method may not use the entire text of the given string.
     *
     * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.
     * @return An &lt;code&gt;Object&lt;/code&gt; parsed from the string.
     * @exception ParseException if the beginning of the specified string
     *            cannot be parsed.
     */
    public Object parseObject(String source) throws ParseException {
        ParsePosition pos = new ParsePosition(0);
        Object result = parseObject(source, pos);
        if (pos.index == 0) {
            throw new ParseException(&quot;Format.parseObject(String) failed&quot;,
                pos.errorIndex);
        }
        return result;
    }

    /**
     * Creates and returns a copy of this object.
     *
     * @return a clone of this instance.
     */
    public Object clone() {
        try {
            return super.clone();
        } catch (CloneNotSupportedException e) {
            // will never happen
            throw new InternalError(e);
        }
    }

    //
    // Convenience methods for creating AttributedCharacterIterators from
    // different parameters.
    //

    /**
     * Creates an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; for the String
     * &lt;code&gt;s&lt;/code&gt;.
     *
     * @param s String to create AttributedCharacterIterator from
     * @return AttributedCharacterIterator wrapping s
     */
    AttributedCharacterIterator createAttributedCharacterIterator(String s) {
        AttributedString as = new AttributedString(s);

        return as.getIterator();
    }

    /**
     * Creates an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; containing the
     * concatenated contents of the passed in
     * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;s.
     *
     * @param iterators AttributedCharacterIterators used to create resulting
     *                  AttributedCharacterIterators
     * @return AttributedCharacterIterator wrapping passed in
     *         AttributedCharacterIterators
     */
    AttributedCharacterIterator createAttributedCharacterIterator(
                       AttributedCharacterIterator[] iterators) {
        AttributedString as = new AttributedString(iterators);

        return as.getIterator();
    }

    /**
     * Returns an AttributedCharacterIterator with the String
     * &lt;code&gt;string&lt;/code&gt; and additional key/value pair &lt;code&gt;key&lt;/code&gt;,
     * &lt;code&gt;value&lt;/code&gt;.
     *
     * @param string String to create AttributedCharacterIterator from
     * @param key Key for AttributedCharacterIterator
     * @param value Value associated with key in AttributedCharacterIterator
     * @return AttributedCharacterIterator wrapping args
     */
    AttributedCharacterIterator createAttributedCharacterIterator(
                      String string, AttributedCharacterIterator.Attribute key,
                      Object value) {
        AttributedString as = new AttributedString(string);

        as.addAttribute(key, value);
        return as.getIterator();
    }

    /**
     * Creates an AttributedCharacterIterator with the contents of
     * &lt;code&gt;iterator&lt;/code&gt; and the additional attribute &lt;code&gt;key&lt;/code&gt;
     * &lt;code&gt;value&lt;/code&gt;.
     *
     * @param iterator Initial AttributedCharacterIterator to add arg to
     * @param key Key for AttributedCharacterIterator
     * @param value Value associated with key in AttributedCharacterIterator
     * @return AttributedCharacterIterator wrapping args
     */
    AttributedCharacterIterator createAttributedCharacterIterator(
              AttributedCharacterIterator iterator,
              AttributedCharacterIterator.Attribute key, Object value) {
        AttributedString as = new AttributedString(iterator);

        as.addAttribute(key, value);
        return as.getIterator();
    }


    /**
     * Defines constants that are used as attribute keys in the
     * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned
     * from &lt;code&gt;Format.formatToCharacterIterator&lt;/code&gt; and as
     * field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.
     *
     * @since 1.4
     */
    public static class Field extends AttributedCharacterIterator.Attribute {

        // Proclaim serial compatibility with 1.4 FCS
        private static final long serialVersionUID = 276966692217360283L;

        /**
         * Creates a Field with the specified name.
         *
         * @param name Name of the attribute
         */
        protected Field(String name) {
            super(name);
        }
    }


    /**
     * FieldDelegate is notified by the various &lt;code&gt;Format&lt;/code&gt;
     * implementations as they are formatting the Objects. This allows for
     * storage of the individual sections of the formatted String for
     * later use, such as in a &lt;code&gt;FieldPosition&lt;/code&gt; or for an
     * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
     * &lt;p&gt;
     * Delegates should NOT assume that the &lt;code&gt;Format&lt;/code&gt; will notify
     * the delegate of fields in any particular order.
     *
     * @see FieldPosition#getFieldDelegate
     * @see CharacterIteratorFieldDelegate
     */
    interface FieldDelegate {
        /**
         * Notified when a particular region of the String is formatted. This
         * method will be invoked if there is no corresponding integer field id
         * matching &lt;code&gt;attr&lt;/code&gt;.
         *
         * @param attr Identifies the field matched
         * @param value Value associated with the field
         * @param start Beginning location of the field, will be &gt;= 0
         * @param end End of the field, will be &gt;= start and &lt;= buffer.length()
         * @param buffer Contains current formatted value, receiver should
         *        NOT modify it.
         */
        public void formatted(Format.Field attr, Object value, int start,
                              int end, StringBuffer buffer);

        /**
         * Notified when a particular region of the String is formatted.
         *
         * @param fieldID Identifies the field by integer
         * @param attr Identifies the field matched
         * @param value Value associated with the field
         * @param start Beginning location of the field, will be &gt;= 0
         * @param end End of the field, will be &gt;= start and &lt;= buffer.length()
         * @param buffer Contains current formatted value, receiver should
         *        NOT modify it.
         */
        public void formatted(int fieldID, Format.Field attr, Object value,
                              int start, int end, StringBuffer buffer);
    }
}
</pre>
</body>
</html>
