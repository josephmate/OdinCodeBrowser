<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/OdinCodeBrowser/css/styles.css"/>
    </head>
<body>
<table>
<tr>
<td><a class="linenum-cell" data-linenum="1" href="#"></a></td>
<td><pre>/*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2" href="#"></a></td>
<td><pre> * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3" href="#"></a></td>
<td><pre> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5" href="#"></a></td>
<td><pre> * This code is free software; you can redistribute it and/or modify it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="6" href="#"></a></td>
<td><pre> * under the terms of the GNU General Public License version 2 only, as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="7" href="#"></a></td>
<td><pre> * published by the Free Software Foundation.  Oracle designates this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="8" href="#"></a></td>
<td><pre> * particular file as subject to the &quot;Classpath&quot; exception as provided</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="9" href="#"></a></td>
<td><pre> * by Oracle in the LICENSE file that accompanied this code.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="10" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="11" href="#"></a></td>
<td><pre> * This code is distributed in the hope that it will be useful, but WITHOUT</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="12" href="#"></a></td>
<td><pre> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="13" href="#"></a></td>
<td><pre> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="14" href="#"></a></td>
<td><pre> * version 2 for more details (a copy is included in the LICENSE file that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="15" href="#"></a></td>
<td><pre> * accompanied this code).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="16" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="17" href="#"></a></td>
<td><pre> * You should have received a copy of the GNU General Public License version</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="18" href="#"></a></td>
<td><pre> * 2 along with this work; if not, write to the Free Software Foundation,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="19" href="#"></a></td>
<td><pre> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="20" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="21" href="#"></a></td>
<td><pre> * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="22" href="#"></a></td>
<td><pre> * or visit www.oracle.com if you need additional information or have any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="23" href="#"></a></td>
<td><pre> * questions.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="24" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="25" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="26" href="#"></a></td>
<td><pre>package java.util;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="27" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="28" href="#"></a></td>
<td><pre>import java.lang.reflect.Array;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="29" href="#"></a></td>
<td><pre>import java.util.concurrent.ForkJoinPool;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="30" href="#"></a></td>
<td><pre>import java.util.function.BinaryOperator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="31" href="#"></a></td>
<td><pre>import java.util.function.DoubleBinaryOperator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="32" href="#"></a></td>
<td><pre>import java.util.function.IntBinaryOperator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="33" href="#"></a></td>
<td><pre>import java.util.function.IntFunction;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="34" href="#"></a></td>
<td><pre>import java.util.function.IntToDoubleFunction;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="35" href="#"></a></td>
<td><pre>import java.util.function.IntToLongFunction;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="36" href="#"></a></td>
<td><pre>import java.util.function.IntUnaryOperator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="37" href="#"></a></td>
<td><pre>import java.util.function.LongBinaryOperator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="38" href="#"></a></td>
<td><pre>import java.util.stream.DoubleStream;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="39" href="#"></a></td>
<td><pre>import java.util.stream.IntStream;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="40" href="#"></a></td>
<td><pre>import java.util.stream.LongStream;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="41" href="#"></a></td>
<td><pre>import java.util.stream.Stream;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="42" href="#"></a></td>
<td><pre>import java.util.stream.StreamSupport;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="43" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="44" href="#"></a></td>
<td><pre>/**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="45" href="#"></a></td>
<td><pre> * This class contains various methods for manipulating arrays (such as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="46" href="#"></a></td>
<td><pre> * sorting and searching). This class also contains a static factory</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="47" href="#"></a></td>
<td><pre> * that allows arrays to be viewed as lists.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="48" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="49" href="#"></a></td>
<td><pre> * &lt;p&gt;The methods in this class all throw a {@code NullPointerException},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="50" href="#"></a></td>
<td><pre> * if the specified array reference is null, except where noted.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="51" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="52" href="#"></a></td>
<td><pre> * &lt;p&gt;The documentation for the methods contained in this class includes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="53" href="#"></a></td>
<td><pre> * briefs description of the &lt;i&gt;implementations&lt;/i&gt;. Such descriptions should</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="54" href="#"></a></td>
<td><pre> * be regarded as &lt;i&gt;implementation notes&lt;/i&gt;, rather than parts of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="55" href="#"></a></td>
<td><pre> * &lt;i&gt;specification&lt;/i&gt;. Implementors should feel free to substitute other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="56" href="#"></a></td>
<td><pre> * algorithms, so long as the specification itself is adhered to. (For</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="57" href="#"></a></td>
<td><pre> * example, the algorithm used by {@code sort(Object[])} does not have to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="58" href="#"></a></td>
<td><pre> * a MergeSort, but it does have to be &lt;i&gt;stable&lt;/i&gt;.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="59" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="60" href="#"></a></td>
<td><pre> * &lt;p&gt;This class is a member of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="61" href="#"></a></td>
<td><pre> * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="62" href="#"></a></td>
<td><pre> * Java Collections Framework&lt;/a&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="63" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="64" href="#"></a></td>
<td><pre> * @author Josh Bloch</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="65" href="#"></a></td>
<td><pre> * @author Neal Gafter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="66" href="#"></a></td>
<td><pre> * @author John Rose</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="67" href="#"></a></td>
<td><pre> * @since  1.2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="68" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="69" href="#"></a></td>
<td><pre>public class Arrays {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="70" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="71" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="72" href="#"></a></td>
<td><pre>     * The minimum array length below which a parallel sorting</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="73" href="#"></a></td>
<td><pre>     * algorithm will not further partition the sorting task. Using</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="74" href="#"></a></td>
<td><pre>     * smaller sizes typically results in memory contention across</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="75" href="#"></a></td>
<td><pre>     * tasks that makes parallel speedups unlikely.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="76" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="77" href="#"></a></td>
<td><pre>    private static final int MIN_ARRAY_SORT_GRAN = 1 &lt;&lt; 13;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="78" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="79" href="#"></a></td>
<td><pre>    // Suppresses default constructor, ensuring non-instantiability.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="80" href="#"></a></td>
<td><pre>    private Arrays() {}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="81" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="82" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="83" href="#"></a></td>
<td><pre>     * A comparator that implements the natural ordering of a group of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="84" href="#"></a></td>
<td><pre>     * mutually comparable elements. May be used when a supplied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="85" href="#"></a></td>
<td><pre>     * comparator is null. To simplify code-sharing within underlying</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="86" href="#"></a></td>
<td><pre>     * implementations, the compare method only declares type Object</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="87" href="#"></a></td>
<td><pre>     * for its second argument.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="88" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="89" href="#"></a></td>
<td><pre>     * Arrays class implementor's note: It is an empirical matter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="90" href="#"></a></td>
<td><pre>     * whether ComparableTimSort offers any performance benefit over</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="91" href="#"></a></td>
<td><pre>     * TimSort used with this comparator.  If not, you are better off</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="92" href="#"></a></td>
<td><pre>     * deleting or bypassing ComparableTimSort.  There is currently no</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="93" href="#"></a></td>
<td><pre>     * empirical case for separating them for parallel sorting, so all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="94" href="#"></a></td>
<td><pre>     * public Object parallelSort methods use the same comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="95" href="#"></a></td>
<td><pre>     * based implementation.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="96" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="97" href="#"></a></td>
<td><pre>    static final class NaturalOrder implements Comparator&lt;Object&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="98" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="99" href="#"></a></td>
<td><pre>        public int compare(Object first, Object second) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="100" href="#"></a></td>
<td><pre>            return ((Comparable&lt;Object&gt;)first).compareTo(second);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="101" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="102" href="#"></a></td>
<td><pre>        static final NaturalOrder INSTANCE = new NaturalOrder();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="103" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="104" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="105" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="106" href="#"></a></td>
<td><pre>     * Checks that {@code fromIndex} and {@code toIndex} are in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="107" href="#"></a></td>
<td><pre>     * the range and throws an exception if they aren't.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="108" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="109" href="#"></a></td>
<td><pre>    private static void rangeCheck(int arrayLength, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="110" href="#"></a></td>
<td><pre>        if (fromIndex &gt; toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="111" href="#"></a></td>
<td><pre>            throw new IllegalArgumentException(</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="112" href="#"></a></td>
<td><pre>                    &quot;fromIndex(&quot; + fromIndex + &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="113" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="114" href="#"></a></td>
<td><pre>        if (fromIndex &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="115" href="#"></a></td>
<td><pre>            throw new ArrayIndexOutOfBoundsException(fromIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="116" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="117" href="#"></a></td>
<td><pre>        if (toIndex &gt; arrayLength) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="118" href="#"></a></td>
<td><pre>            throw new ArrayIndexOutOfBoundsException(toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="119" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="120" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="121" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="122" href="#"></a></td>
<td><pre>    /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="123" href="#"></a></td>
<td><pre>     * Sorting methods. Note that all public &quot;sort&quot; methods take the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="124" href="#"></a></td>
<td><pre>     * same form: Performing argument checks if necessary, and then</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="125" href="#"></a></td>
<td><pre>     * expanding arguments into those required for the internal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="126" href="#"></a></td>
<td><pre>     * implementation methods residing in other package-private</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="127" href="#"></a></td>
<td><pre>     * classes (except for legacyMergeSort, included in this class).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="128" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="129" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="130" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="131" href="#"></a></td>
<td><pre>     * Sorts the specified array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="132" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="133" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="134" href="#"></a></td>
<td><pre>     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="135" href="#"></a></td>
<td><pre>     * offers O(n log(n)) performance on many data sets that cause other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="136" href="#"></a></td>
<td><pre>     * quicksorts to degrade to quadratic performance, and is typically</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="137" href="#"></a></td>
<td><pre>     * faster than traditional (one-pivot) Quicksort implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="138" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="139" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="140" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="141" href="#"></a></td>
<td><pre>    public static void sort(int[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="142" href="#"></a></td>
<td><pre>        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="143" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="144" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="145" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="146" href="#"></a></td>
<td><pre>     * Sorts the specified range of the array into ascending order. The range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="147" href="#"></a></td>
<td><pre>     * to be sorted extends from the index {@code fromIndex}, inclusive, to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="148" href="#"></a></td>
<td><pre>     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="149" href="#"></a></td>
<td><pre>     * the range to be sorted is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="150" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="151" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="152" href="#"></a></td>
<td><pre>     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="153" href="#"></a></td>
<td><pre>     * offers O(n log(n)) performance on many data sets that cause other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="154" href="#"></a></td>
<td><pre>     * quicksorts to degrade to quadratic performance, and is typically</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="155" href="#"></a></td>
<td><pre>     * faster than traditional (one-pivot) Quicksort implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="156" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="157" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="158" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="159" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="160" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="161" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="162" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="163" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="164" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="165" href="#"></a></td>
<td><pre>    public static void sort(int[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="166" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="167" href="#"></a></td>
<td><pre>        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="168" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="169" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="170" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="171" href="#"></a></td>
<td><pre>     * Sorts the specified array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="172" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="173" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="174" href="#"></a></td>
<td><pre>     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="175" href="#"></a></td>
<td><pre>     * offers O(n log(n)) performance on many data sets that cause other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="176" href="#"></a></td>
<td><pre>     * quicksorts to degrade to quadratic performance, and is typically</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="177" href="#"></a></td>
<td><pre>     * faster than traditional (one-pivot) Quicksort implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="178" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="179" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="180" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="181" href="#"></a></td>
<td><pre>    public static void sort(long[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="182" href="#"></a></td>
<td><pre>        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="183" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="184" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="185" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="186" href="#"></a></td>
<td><pre>     * Sorts the specified range of the array into ascending order. The range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="187" href="#"></a></td>
<td><pre>     * to be sorted extends from the index {@code fromIndex}, inclusive, to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="188" href="#"></a></td>
<td><pre>     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="189" href="#"></a></td>
<td><pre>     * the range to be sorted is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="190" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="191" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="192" href="#"></a></td>
<td><pre>     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="193" href="#"></a></td>
<td><pre>     * offers O(n log(n)) performance on many data sets that cause other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="194" href="#"></a></td>
<td><pre>     * quicksorts to degrade to quadratic performance, and is typically</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="195" href="#"></a></td>
<td><pre>     * faster than traditional (one-pivot) Quicksort implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="196" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="197" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="198" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="199" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="200" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="201" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="202" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="203" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="204" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="205" href="#"></a></td>
<td><pre>    public static void sort(long[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="206" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="207" href="#"></a></td>
<td><pre>        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="208" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="209" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="210" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="211" href="#"></a></td>
<td><pre>     * Sorts the specified array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="212" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="213" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="214" href="#"></a></td>
<td><pre>     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="215" href="#"></a></td>
<td><pre>     * offers O(n log(n)) performance on many data sets that cause other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="216" href="#"></a></td>
<td><pre>     * quicksorts to degrade to quadratic performance, and is typically</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="217" href="#"></a></td>
<td><pre>     * faster than traditional (one-pivot) Quicksort implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="218" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="219" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="220" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="221" href="#"></a></td>
<td><pre>    public static void sort(short[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="222" href="#"></a></td>
<td><pre>        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="223" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="224" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="225" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="226" href="#"></a></td>
<td><pre>     * Sorts the specified range of the array into ascending order. The range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="227" href="#"></a></td>
<td><pre>     * to be sorted extends from the index {@code fromIndex}, inclusive, to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="228" href="#"></a></td>
<td><pre>     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="229" href="#"></a></td>
<td><pre>     * the range to be sorted is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="230" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="231" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="232" href="#"></a></td>
<td><pre>     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="233" href="#"></a></td>
<td><pre>     * offers O(n log(n)) performance on many data sets that cause other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="234" href="#"></a></td>
<td><pre>     * quicksorts to degrade to quadratic performance, and is typically</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="235" href="#"></a></td>
<td><pre>     * faster than traditional (one-pivot) Quicksort implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="236" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="237" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="238" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="239" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="240" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="241" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="242" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="243" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="244" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="245" href="#"></a></td>
<td><pre>    public static void sort(short[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="246" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="247" href="#"></a></td>
<td><pre>        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="248" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="249" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="250" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="251" href="#"></a></td>
<td><pre>     * Sorts the specified array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="252" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="253" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="254" href="#"></a></td>
<td><pre>     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="255" href="#"></a></td>
<td><pre>     * offers O(n log(n)) performance on many data sets that cause other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="256" href="#"></a></td>
<td><pre>     * quicksorts to degrade to quadratic performance, and is typically</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="257" href="#"></a></td>
<td><pre>     * faster than traditional (one-pivot) Quicksort implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="258" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="259" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="260" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="261" href="#"></a></td>
<td><pre>    public static void sort(char[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="262" href="#"></a></td>
<td><pre>        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="263" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="264" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="265" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="266" href="#"></a></td>
<td><pre>     * Sorts the specified range of the array into ascending order. The range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="267" href="#"></a></td>
<td><pre>     * to be sorted extends from the index {@code fromIndex}, inclusive, to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="268" href="#"></a></td>
<td><pre>     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="269" href="#"></a></td>
<td><pre>     * the range to be sorted is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="270" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="271" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="272" href="#"></a></td>
<td><pre>     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="273" href="#"></a></td>
<td><pre>     * offers O(n log(n)) performance on many data sets that cause other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="274" href="#"></a></td>
<td><pre>     * quicksorts to degrade to quadratic performance, and is typically</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="275" href="#"></a></td>
<td><pre>     * faster than traditional (one-pivot) Quicksort implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="276" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="277" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="278" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="279" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="280" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="281" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="282" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="283" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="284" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="285" href="#"></a></td>
<td><pre>    public static void sort(char[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="286" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="287" href="#"></a></td>
<td><pre>        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="288" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="289" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="290" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="291" href="#"></a></td>
<td><pre>     * Sorts the specified array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="292" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="293" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="294" href="#"></a></td>
<td><pre>     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="295" href="#"></a></td>
<td><pre>     * offers O(n log(n)) performance on many data sets that cause other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="296" href="#"></a></td>
<td><pre>     * quicksorts to degrade to quadratic performance, and is typically</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="297" href="#"></a></td>
<td><pre>     * faster than traditional (one-pivot) Quicksort implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="298" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="299" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="300" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="301" href="#"></a></td>
<td><pre>    public static void sort(byte[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="302" href="#"></a></td>
<td><pre>        DualPivotQuicksort.sort(a, 0, a.length - 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="303" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="304" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="305" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="306" href="#"></a></td>
<td><pre>     * Sorts the specified range of the array into ascending order. The range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="307" href="#"></a></td>
<td><pre>     * to be sorted extends from the index {@code fromIndex}, inclusive, to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="308" href="#"></a></td>
<td><pre>     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="309" href="#"></a></td>
<td><pre>     * the range to be sorted is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="310" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="311" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="312" href="#"></a></td>
<td><pre>     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="313" href="#"></a></td>
<td><pre>     * offers O(n log(n)) performance on many data sets that cause other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="314" href="#"></a></td>
<td><pre>     * quicksorts to degrade to quadratic performance, and is typically</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="315" href="#"></a></td>
<td><pre>     * faster than traditional (one-pivot) Quicksort implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="316" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="317" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="318" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="319" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="320" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="321" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="322" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="323" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="324" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="325" href="#"></a></td>
<td><pre>    public static void sort(byte[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="326" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="327" href="#"></a></td>
<td><pre>        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="328" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="329" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="330" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="331" href="#"></a></td>
<td><pre>     * Sorts the specified array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="332" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="333" href="#"></a></td>
<td><pre>     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="334" href="#"></a></td>
<td><pre>     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="335" href="#"></a></td>
<td><pre>     * value compares neither less than, greater than, nor equal to any value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="336" href="#"></a></td>
<td><pre>     * even itself. This method uses the total order imposed by the method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="337" href="#"></a></td>
<td><pre>     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="338" href="#"></a></td>
<td><pre>     * {@code 0.0f} and {@code Float.NaN} is considered greater than any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="339" href="#"></a></td>
<td><pre>     * other value and all {@code Float.NaN} values are considered equal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="340" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="341" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="342" href="#"></a></td>
<td><pre>     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="343" href="#"></a></td>
<td><pre>     * offers O(n log(n)) performance on many data sets that cause other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="344" href="#"></a></td>
<td><pre>     * quicksorts to degrade to quadratic performance, and is typically</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="345" href="#"></a></td>
<td><pre>     * faster than traditional (one-pivot) Quicksort implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="346" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="347" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="348" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="349" href="#"></a></td>
<td><pre>    public static void sort(float[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="350" href="#"></a></td>
<td><pre>        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="351" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="352" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="353" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="354" href="#"></a></td>
<td><pre>     * Sorts the specified range of the array into ascending order. The range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="355" href="#"></a></td>
<td><pre>     * to be sorted extends from the index {@code fromIndex}, inclusive, to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="356" href="#"></a></td>
<td><pre>     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="357" href="#"></a></td>
<td><pre>     * the range to be sorted is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="358" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="359" href="#"></a></td>
<td><pre>     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="360" href="#"></a></td>
<td><pre>     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="361" href="#"></a></td>
<td><pre>     * value compares neither less than, greater than, nor equal to any value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="362" href="#"></a></td>
<td><pre>     * even itself. This method uses the total order imposed by the method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="363" href="#"></a></td>
<td><pre>     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="364" href="#"></a></td>
<td><pre>     * {@code 0.0f} and {@code Float.NaN} is considered greater than any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="365" href="#"></a></td>
<td><pre>     * other value and all {@code Float.NaN} values are considered equal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="366" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="367" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="368" href="#"></a></td>
<td><pre>     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="369" href="#"></a></td>
<td><pre>     * offers O(n log(n)) performance on many data sets that cause other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="370" href="#"></a></td>
<td><pre>     * quicksorts to degrade to quadratic performance, and is typically</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="371" href="#"></a></td>
<td><pre>     * faster than traditional (one-pivot) Quicksort implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="372" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="373" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="374" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="375" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="376" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="377" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="378" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="379" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="380" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="381" href="#"></a></td>
<td><pre>    public static void sort(float[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="382" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="383" href="#"></a></td>
<td><pre>        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="384" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="385" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="386" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="387" href="#"></a></td>
<td><pre>     * Sorts the specified array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="388" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="389" href="#"></a></td>
<td><pre>     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="390" href="#"></a></td>
<td><pre>     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="391" href="#"></a></td>
<td><pre>     * value compares neither less than, greater than, nor equal to any value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="392" href="#"></a></td>
<td><pre>     * even itself. This method uses the total order imposed by the method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="393" href="#"></a></td>
<td><pre>     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="394" href="#"></a></td>
<td><pre>     * {@code 0.0d} and {@code Double.NaN} is considered greater than any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="395" href="#"></a></td>
<td><pre>     * other value and all {@code Double.NaN} values are considered equal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="396" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="397" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="398" href="#"></a></td>
<td><pre>     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="399" href="#"></a></td>
<td><pre>     * offers O(n log(n)) performance on many data sets that cause other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="400" href="#"></a></td>
<td><pre>     * quicksorts to degrade to quadratic performance, and is typically</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="401" href="#"></a></td>
<td><pre>     * faster than traditional (one-pivot) Quicksort implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="402" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="403" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="404" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="405" href="#"></a></td>
<td><pre>    public static void sort(double[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="406" href="#"></a></td>
<td><pre>        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="407" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="408" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="409" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="410" href="#"></a></td>
<td><pre>     * Sorts the specified range of the array into ascending order. The range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="411" href="#"></a></td>
<td><pre>     * to be sorted extends from the index {@code fromIndex}, inclusive, to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="412" href="#"></a></td>
<td><pre>     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="413" href="#"></a></td>
<td><pre>     * the range to be sorted is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="414" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="415" href="#"></a></td>
<td><pre>     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="416" href="#"></a></td>
<td><pre>     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="417" href="#"></a></td>
<td><pre>     * value compares neither less than, greater than, nor equal to any value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="418" href="#"></a></td>
<td><pre>     * even itself. This method uses the total order imposed by the method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="419" href="#"></a></td>
<td><pre>     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="420" href="#"></a></td>
<td><pre>     * {@code 0.0d} and {@code Double.NaN} is considered greater than any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="421" href="#"></a></td>
<td><pre>     * other value and all {@code Double.NaN} values are considered equal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="422" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="423" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="424" href="#"></a></td>
<td><pre>     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="425" href="#"></a></td>
<td><pre>     * offers O(n log(n)) performance on many data sets that cause other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="426" href="#"></a></td>
<td><pre>     * quicksorts to degrade to quadratic performance, and is typically</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="427" href="#"></a></td>
<td><pre>     * faster than traditional (one-pivot) Quicksort implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="428" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="429" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="430" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="431" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="432" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="433" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="434" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="435" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="436" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="437" href="#"></a></td>
<td><pre>    public static void sort(double[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="438" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="439" href="#"></a></td>
<td><pre>        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="440" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="441" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="442" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="443" href="#"></a></td>
<td><pre>     * Sorts the specified array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="444" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="445" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="446" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="447" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="448" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(byte[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="449" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="450" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="451" href="#"></a></td>
<td><pre>     * Arrays#sort(byte[]) Arrays.sort} method. The algorithm requires a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="452" href="#"></a></td>
<td><pre>     * working space no greater than the size of the original array. The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="453" href="#"></a></td>
<td><pre>     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="454" href="#"></a></td>
<td><pre>     * execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="455" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="456" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="457" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="458" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="459" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="460" href="#"></a></td>
<td><pre>    public static void parallelSort(byte[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="461" href="#"></a></td>
<td><pre>        int n = a.length, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="462" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="463" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="464" href="#"></a></td>
<td><pre>            DualPivotQuicksort.sort(a, 0, n - 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="465" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="466" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJByte.Sorter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="467" href="#"></a></td>
<td><pre>                (null, a, new byte[n], 0, n, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="468" href="#"></a></td>
<td><pre>                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="469" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="470" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="471" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="472" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="473" href="#"></a></td>
<td><pre>     * Sorts the specified range of the array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="474" href="#"></a></td>
<td><pre>     * The range to be sorted extends from the index {@code fromIndex},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="475" href="#"></a></td>
<td><pre>     * inclusive, to the index {@code toIndex}, exclusive. If</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="476" href="#"></a></td>
<td><pre>     * {@code fromIndex == toIndex}, the range to be sorted is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="477" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="478" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="479" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="480" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="481" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(byte[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="482" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="483" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="484" href="#"></a></td>
<td><pre>     * Arrays#sort(byte[]) Arrays.sort} method. The algorithm requires a working</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="485" href="#"></a></td>
<td><pre>     * space no greater than the size of the specified range of the original</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="486" href="#"></a></td>
<td><pre>     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="487" href="#"></a></td>
<td><pre>     * used to execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="488" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="489" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="490" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="491" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="492" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="493" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="494" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="495" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="496" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="497" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="498" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="499" href="#"></a></td>
<td><pre>    public static void parallelSort(byte[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="500" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="501" href="#"></a></td>
<td><pre>        int n = toIndex - fromIndex, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="502" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="503" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="504" href="#"></a></td>
<td><pre>            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="505" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="506" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJByte.Sorter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="507" href="#"></a></td>
<td><pre>                (null, a, new byte[n], fromIndex, n, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="508" href="#"></a></td>
<td><pre>                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="509" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="510" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="511" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="512" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="513" href="#"></a></td>
<td><pre>     * Sorts the specified array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="514" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="515" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="516" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="517" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="518" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(char[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="519" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="520" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="521" href="#"></a></td>
<td><pre>     * Arrays#sort(char[]) Arrays.sort} method. The algorithm requires a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="522" href="#"></a></td>
<td><pre>     * working space no greater than the size of the original array. The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="523" href="#"></a></td>
<td><pre>     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="524" href="#"></a></td>
<td><pre>     * execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="525" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="526" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="527" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="528" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="529" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="530" href="#"></a></td>
<td><pre>    public static void parallelSort(char[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="531" href="#"></a></td>
<td><pre>        int n = a.length, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="532" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="533" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="534" href="#"></a></td>
<td><pre>            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="535" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="536" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJChar.Sorter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="537" href="#"></a></td>
<td><pre>                (null, a, new char[n], 0, n, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="538" href="#"></a></td>
<td><pre>                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="539" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="540" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="541" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="542" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="543" href="#"></a></td>
<td><pre>     * Sorts the specified range of the array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="544" href="#"></a></td>
<td><pre>     * The range to be sorted extends from the index {@code fromIndex},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="545" href="#"></a></td>
<td><pre>     * inclusive, to the index {@code toIndex}, exclusive. If</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="546" href="#"></a></td>
<td><pre>     * {@code fromIndex == toIndex}, the range to be sorted is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="547" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="548" href="#"></a></td>
<td><pre>      @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="549" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="550" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="551" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(char[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="552" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="553" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="554" href="#"></a></td>
<td><pre>     * Arrays#sort(char[]) Arrays.sort} method. The algorithm requires a working</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="555" href="#"></a></td>
<td><pre>     * space no greater than the size of the specified range of the original</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="556" href="#"></a></td>
<td><pre>     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="557" href="#"></a></td>
<td><pre>     * used to execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="558" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="559" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="560" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="561" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="562" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="563" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="564" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="565" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="566" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="567" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="568" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="569" href="#"></a></td>
<td><pre>    public static void parallelSort(char[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="570" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="571" href="#"></a></td>
<td><pre>        int n = toIndex - fromIndex, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="572" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="573" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="574" href="#"></a></td>
<td><pre>            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="575" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="576" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJChar.Sorter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="577" href="#"></a></td>
<td><pre>                (null, a, new char[n], fromIndex, n, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="578" href="#"></a></td>
<td><pre>                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="579" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="580" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="581" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="582" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="583" href="#"></a></td>
<td><pre>     * Sorts the specified array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="584" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="585" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="586" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="587" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="588" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(short[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="589" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="590" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="591" href="#"></a></td>
<td><pre>     * Arrays#sort(short[]) Arrays.sort} method. The algorithm requires a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="592" href="#"></a></td>
<td><pre>     * working space no greater than the size of the original array. The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="593" href="#"></a></td>
<td><pre>     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="594" href="#"></a></td>
<td><pre>     * execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="595" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="596" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="597" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="598" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="599" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="600" href="#"></a></td>
<td><pre>    public static void parallelSort(short[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="601" href="#"></a></td>
<td><pre>        int n = a.length, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="602" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="603" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="604" href="#"></a></td>
<td><pre>            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="605" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="606" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJShort.Sorter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="607" href="#"></a></td>
<td><pre>                (null, a, new short[n], 0, n, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="608" href="#"></a></td>
<td><pre>                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="609" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="610" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="611" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="612" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="613" href="#"></a></td>
<td><pre>     * Sorts the specified range of the array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="614" href="#"></a></td>
<td><pre>     * The range to be sorted extends from the index {@code fromIndex},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="615" href="#"></a></td>
<td><pre>     * inclusive, to the index {@code toIndex}, exclusive. If</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="616" href="#"></a></td>
<td><pre>     * {@code fromIndex == toIndex}, the range to be sorted is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="617" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="618" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="619" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="620" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="621" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(short[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="622" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="623" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="624" href="#"></a></td>
<td><pre>     * Arrays#sort(short[]) Arrays.sort} method. The algorithm requires a working</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="625" href="#"></a></td>
<td><pre>     * space no greater than the size of the specified range of the original</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="626" href="#"></a></td>
<td><pre>     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="627" href="#"></a></td>
<td><pre>     * used to execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="628" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="629" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="630" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="631" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="632" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="633" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="634" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="635" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="636" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="637" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="638" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="639" href="#"></a></td>
<td><pre>    public static void parallelSort(short[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="640" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="641" href="#"></a></td>
<td><pre>        int n = toIndex - fromIndex, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="642" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="643" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="644" href="#"></a></td>
<td><pre>            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="645" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="646" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJShort.Sorter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="647" href="#"></a></td>
<td><pre>                (null, a, new short[n], fromIndex, n, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="648" href="#"></a></td>
<td><pre>                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="649" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="650" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="651" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="652" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="653" href="#"></a></td>
<td><pre>     * Sorts the specified array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="654" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="655" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="656" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="657" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="658" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(int[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="659" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="660" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="661" href="#"></a></td>
<td><pre>     * Arrays#sort(int[]) Arrays.sort} method. The algorithm requires a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="662" href="#"></a></td>
<td><pre>     * working space no greater than the size of the original array. The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="663" href="#"></a></td>
<td><pre>     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="664" href="#"></a></td>
<td><pre>     * execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="665" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="666" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="667" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="668" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="669" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="670" href="#"></a></td>
<td><pre>    public static void parallelSort(int[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="671" href="#"></a></td>
<td><pre>        int n = a.length, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="672" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="673" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="674" href="#"></a></td>
<td><pre>            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="675" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="676" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJInt.Sorter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="677" href="#"></a></td>
<td><pre>                (null, a, new int[n], 0, n, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="678" href="#"></a></td>
<td><pre>                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="679" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="680" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="681" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="682" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="683" href="#"></a></td>
<td><pre>     * Sorts the specified range of the array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="684" href="#"></a></td>
<td><pre>     * The range to be sorted extends from the index {@code fromIndex},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="685" href="#"></a></td>
<td><pre>     * inclusive, to the index {@code toIndex}, exclusive. If</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="686" href="#"></a></td>
<td><pre>     * {@code fromIndex == toIndex}, the range to be sorted is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="687" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="688" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="689" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="690" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="691" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(int[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="692" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="693" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="694" href="#"></a></td>
<td><pre>     * Arrays#sort(int[]) Arrays.sort} method. The algorithm requires a working</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="695" href="#"></a></td>
<td><pre>     * space no greater than the size of the specified range of the original</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="696" href="#"></a></td>
<td><pre>     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="697" href="#"></a></td>
<td><pre>     * used to execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="698" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="699" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="700" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="701" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="702" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="703" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="704" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="705" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="706" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="707" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="708" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="709" href="#"></a></td>
<td><pre>    public static void parallelSort(int[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="710" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="711" href="#"></a></td>
<td><pre>        int n = toIndex - fromIndex, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="712" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="713" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="714" href="#"></a></td>
<td><pre>            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="715" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="716" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJInt.Sorter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="717" href="#"></a></td>
<td><pre>                (null, a, new int[n], fromIndex, n, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="718" href="#"></a></td>
<td><pre>                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="719" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="720" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="721" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="722" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="723" href="#"></a></td>
<td><pre>     * Sorts the specified array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="724" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="725" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="726" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="727" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="728" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(long[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="729" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="730" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="731" href="#"></a></td>
<td><pre>     * Arrays#sort(long[]) Arrays.sort} method. The algorithm requires a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="732" href="#"></a></td>
<td><pre>     * working space no greater than the size of the original array. The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="733" href="#"></a></td>
<td><pre>     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="734" href="#"></a></td>
<td><pre>     * execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="735" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="736" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="737" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="738" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="739" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="740" href="#"></a></td>
<td><pre>    public static void parallelSort(long[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="741" href="#"></a></td>
<td><pre>        int n = a.length, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="742" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="743" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="744" href="#"></a></td>
<td><pre>            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="745" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="746" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJLong.Sorter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="747" href="#"></a></td>
<td><pre>                (null, a, new long[n], 0, n, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="748" href="#"></a></td>
<td><pre>                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="749" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="750" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="751" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="752" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="753" href="#"></a></td>
<td><pre>     * Sorts the specified range of the array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="754" href="#"></a></td>
<td><pre>     * The range to be sorted extends from the index {@code fromIndex},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="755" href="#"></a></td>
<td><pre>     * inclusive, to the index {@code toIndex}, exclusive. If</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="756" href="#"></a></td>
<td><pre>     * {@code fromIndex == toIndex}, the range to be sorted is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="757" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="758" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="759" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="760" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="761" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(long[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="762" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="763" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="764" href="#"></a></td>
<td><pre>     * Arrays#sort(long[]) Arrays.sort} method. The algorithm requires a working</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="765" href="#"></a></td>
<td><pre>     * space no greater than the size of the specified range of the original</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="766" href="#"></a></td>
<td><pre>     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="767" href="#"></a></td>
<td><pre>     * used to execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="768" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="769" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="770" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="771" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="772" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="773" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="774" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="775" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="776" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="777" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="778" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="779" href="#"></a></td>
<td><pre>    public static void parallelSort(long[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="780" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="781" href="#"></a></td>
<td><pre>        int n = toIndex - fromIndex, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="782" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="783" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="784" href="#"></a></td>
<td><pre>            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="785" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="786" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJLong.Sorter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="787" href="#"></a></td>
<td><pre>                (null, a, new long[n], fromIndex, n, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="788" href="#"></a></td>
<td><pre>                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="789" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="790" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="791" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="792" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="793" href="#"></a></td>
<td><pre>     * Sorts the specified array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="794" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="795" href="#"></a></td>
<td><pre>     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="796" href="#"></a></td>
<td><pre>     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="797" href="#"></a></td>
<td><pre>     * value compares neither less than, greater than, nor equal to any value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="798" href="#"></a></td>
<td><pre>     * even itself. This method uses the total order imposed by the method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="799" href="#"></a></td>
<td><pre>     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="800" href="#"></a></td>
<td><pre>     * {@code 0.0f} and {@code Float.NaN} is considered greater than any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="801" href="#"></a></td>
<td><pre>     * other value and all {@code Float.NaN} values are considered equal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="802" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="803" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="804" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="805" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="806" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(float[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="807" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="808" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="809" href="#"></a></td>
<td><pre>     * Arrays#sort(float[]) Arrays.sort} method. The algorithm requires a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="810" href="#"></a></td>
<td><pre>     * working space no greater than the size of the original array. The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="811" href="#"></a></td>
<td><pre>     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="812" href="#"></a></td>
<td><pre>     * execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="813" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="814" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="815" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="816" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="817" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="818" href="#"></a></td>
<td><pre>    public static void parallelSort(float[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="819" href="#"></a></td>
<td><pre>        int n = a.length, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="820" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="821" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="822" href="#"></a></td>
<td><pre>            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="823" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="824" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJFloat.Sorter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="825" href="#"></a></td>
<td><pre>                (null, a, new float[n], 0, n, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="826" href="#"></a></td>
<td><pre>                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="827" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="828" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="829" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="830" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="831" href="#"></a></td>
<td><pre>     * Sorts the specified range of the array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="832" href="#"></a></td>
<td><pre>     * The range to be sorted extends from the index {@code fromIndex},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="833" href="#"></a></td>
<td><pre>     * inclusive, to the index {@code toIndex}, exclusive. If</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="834" href="#"></a></td>
<td><pre>     * {@code fromIndex == toIndex}, the range to be sorted is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="835" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="836" href="#"></a></td>
<td><pre>     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="837" href="#"></a></td>
<td><pre>     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="838" href="#"></a></td>
<td><pre>     * value compares neither less than, greater than, nor equal to any value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="839" href="#"></a></td>
<td><pre>     * even itself. This method uses the total order imposed by the method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="840" href="#"></a></td>
<td><pre>     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="841" href="#"></a></td>
<td><pre>     * {@code 0.0f} and {@code Float.NaN} is considered greater than any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="842" href="#"></a></td>
<td><pre>     * other value and all {@code Float.NaN} values are considered equal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="843" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="844" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="845" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="846" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="847" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(float[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="848" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="849" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="850" href="#"></a></td>
<td><pre>     * Arrays#sort(float[]) Arrays.sort} method. The algorithm requires a working</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="851" href="#"></a></td>
<td><pre>     * space no greater than the size of the specified range of the original</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="852" href="#"></a></td>
<td><pre>     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="853" href="#"></a></td>
<td><pre>     * used to execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="854" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="855" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="856" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="857" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="858" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="859" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="860" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="861" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="862" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="863" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="864" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="865" href="#"></a></td>
<td><pre>    public static void parallelSort(float[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="866" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="867" href="#"></a></td>
<td><pre>        int n = toIndex - fromIndex, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="868" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="869" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="870" href="#"></a></td>
<td><pre>            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="871" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="872" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJFloat.Sorter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="873" href="#"></a></td>
<td><pre>                (null, a, new float[n], fromIndex, n, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="874" href="#"></a></td>
<td><pre>                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="875" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="876" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="877" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="878" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="879" href="#"></a></td>
<td><pre>     * Sorts the specified array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="880" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="881" href="#"></a></td>
<td><pre>     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="882" href="#"></a></td>
<td><pre>     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="883" href="#"></a></td>
<td><pre>     * value compares neither less than, greater than, nor equal to any value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="884" href="#"></a></td>
<td><pre>     * even itself. This method uses the total order imposed by the method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="885" href="#"></a></td>
<td><pre>     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="886" href="#"></a></td>
<td><pre>     * {@code 0.0d} and {@code Double.NaN} is considered greater than any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="887" href="#"></a></td>
<td><pre>     * other value and all {@code Double.NaN} values are considered equal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="888" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="889" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="890" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="891" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="892" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(double[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="893" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="894" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="895" href="#"></a></td>
<td><pre>     * Arrays#sort(double[]) Arrays.sort} method. The algorithm requires a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="896" href="#"></a></td>
<td><pre>     * working space no greater than the size of the original array. The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="897" href="#"></a></td>
<td><pre>     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="898" href="#"></a></td>
<td><pre>     * execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="899" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="900" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="901" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="902" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="903" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="904" href="#"></a></td>
<td><pre>    public static void parallelSort(double[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="905" href="#"></a></td>
<td><pre>        int n = a.length, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="906" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="907" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="908" href="#"></a></td>
<td><pre>            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="909" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="910" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJDouble.Sorter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="911" href="#"></a></td>
<td><pre>                (null, a, new double[n], 0, n, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="912" href="#"></a></td>
<td><pre>                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="913" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="914" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="915" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="916" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="917" href="#"></a></td>
<td><pre>     * Sorts the specified range of the array into ascending numerical order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="918" href="#"></a></td>
<td><pre>     * The range to be sorted extends from the index {@code fromIndex},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="919" href="#"></a></td>
<td><pre>     * inclusive, to the index {@code toIndex}, exclusive. If</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="920" href="#"></a></td>
<td><pre>     * {@code fromIndex == toIndex}, the range to be sorted is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="921" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="922" href="#"></a></td>
<td><pre>     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="923" href="#"></a></td>
<td><pre>     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="924" href="#"></a></td>
<td><pre>     * value compares neither less than, greater than, nor equal to any value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="925" href="#"></a></td>
<td><pre>     * even itself. This method uses the total order imposed by the method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="926" href="#"></a></td>
<td><pre>     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="927" href="#"></a></td>
<td><pre>     * {@code 0.0d} and {@code Double.NaN} is considered greater than any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="928" href="#"></a></td>
<td><pre>     * other value and all {@code Double.NaN} values are considered equal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="929" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="930" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="931" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="932" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="933" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(double[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="934" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="935" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="936" href="#"></a></td>
<td><pre>     * Arrays#sort(double[]) Arrays.sort} method. The algorithm requires a working</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="937" href="#"></a></td>
<td><pre>     * space no greater than the size of the specified range of the original</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="938" href="#"></a></td>
<td><pre>     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="939" href="#"></a></td>
<td><pre>     * used to execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="940" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="941" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="942" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="943" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive, to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="944" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="945" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="946" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="947" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="948" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="949" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="950" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="951" href="#"></a></td>
<td><pre>    public static void parallelSort(double[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="952" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="953" href="#"></a></td>
<td><pre>        int n = toIndex - fromIndex, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="954" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="955" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="956" href="#"></a></td>
<td><pre>            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="957" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="958" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJDouble.Sorter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="959" href="#"></a></td>
<td><pre>                (null, a, new double[n], fromIndex, n, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="960" href="#"></a></td>
<td><pre>                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="961" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="962" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="963" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="964" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="965" href="#"></a></td>
<td><pre>     * Sorts the specified array of objects into ascending order, according</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="966" href="#"></a></td>
<td><pre>     * to the {@linkplain Comparable natural ordering} of its elements.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="967" href="#"></a></td>
<td><pre>     * All elements in the array must implement the {@link Comparable}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="968" href="#"></a></td>
<td><pre>     * interface.  Furthermore, all elements in the array must be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="969" href="#"></a></td>
<td><pre>     * &lt;i&gt;mutually comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="970" href="#"></a></td>
<td><pre>     * not throw a {@code ClassCastException} for any elements {@code e1}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="971" href="#"></a></td>
<td><pre>     * and {@code e2} in the array).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="972" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="973" href="#"></a></td>
<td><pre>     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="974" href="#"></a></td>
<td><pre>     * not be reordered as a result of the sort.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="975" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="976" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="977" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="978" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="979" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="980" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="981" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="982" href="#"></a></td>
<td><pre>     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="983" href="#"></a></td>
<td><pre>     * working space no greater than the size of the original array. The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="984" href="#"></a></td>
<td><pre>     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="985" href="#"></a></td>
<td><pre>     * execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="986" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="987" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the class of the objects to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="988" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="989" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="990" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the array contains elements that are not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="991" href="#"></a></td>
<td><pre>     *         &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and integers)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="992" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException (optional) if the natural</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="993" href="#"></a></td>
<td><pre>     *         ordering of the array elements is found to violate the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="994" href="#"></a></td>
<td><pre>     *         {@link Comparable} contract</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="995" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="996" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="997" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="998" href="#"></a></td>
<td><pre>    @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="999" href="#"></a></td>
<td><pre>    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void parallelSort(T[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1000" href="#"></a></td>
<td><pre>        int n = a.length, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1001" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1002" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1003" href="#"></a></td>
<td><pre>            TimSort.sort(a, 0, n, NaturalOrder.INSTANCE, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1004" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1005" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1006" href="#"></a></td>
<td><pre>                (null, a,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1007" href="#"></a></td>
<td><pre>                 (T[])Array.newInstance(a.getClass().getComponentType(), n),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1008" href="#"></a></td>
<td><pre>                 0, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1009" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g, NaturalOrder.INSTANCE).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1010" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1011" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1012" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1013" href="#"></a></td>
<td><pre>     * Sorts the specified range of the specified array of objects into</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1014" href="#"></a></td>
<td><pre>     * ascending order, according to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1015" href="#"></a></td>
<td><pre>     * {@linkplain Comparable natural ordering} of its</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1016" href="#"></a></td>
<td><pre>     * elements.  The range to be sorted extends from index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1017" href="#"></a></td>
<td><pre>     * {@code fromIndex}, inclusive, to index {@code toIndex}, exclusive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1018" href="#"></a></td>
<td><pre>     * (If {@code fromIndex==toIndex}, the range to be sorted is empty.)  All</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1019" href="#"></a></td>
<td><pre>     * elements in this range must implement the {@link Comparable}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1020" href="#"></a></td>
<td><pre>     * interface.  Furthermore, all elements in this range must be &lt;i&gt;mutually</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1021" href="#"></a></td>
<td><pre>     * comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must not throw a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1022" href="#"></a></td>
<td><pre>     * {@code ClassCastException} for any elements {@code e1} and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1023" href="#"></a></td>
<td><pre>     * {@code e2} in the array).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1024" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1025" href="#"></a></td>
<td><pre>     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1026" href="#"></a></td>
<td><pre>     * not be reordered as a result of the sort.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1027" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1028" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1029" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1030" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1031" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1032" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1033" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1034" href="#"></a></td>
<td><pre>     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a working</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1035" href="#"></a></td>
<td><pre>     * space no greater than the size of the specified range of the original</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1036" href="#"></a></td>
<td><pre>     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1037" href="#"></a></td>
<td><pre>     * used to execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1038" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1039" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the class of the objects to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1040" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1041" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1042" href="#"></a></td>
<td><pre>     *        sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1043" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1044" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex} or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1045" href="#"></a></td>
<td><pre>     *         (optional) if the natural ordering of the array elements is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1046" href="#"></a></td>
<td><pre>     *         found to violate the {@link Comparable} contract</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1047" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1048" href="#"></a></td>
<td><pre>     *         {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1049" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the array contains elements that are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1050" href="#"></a></td>
<td><pre>     *         not &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1051" href="#"></a></td>
<td><pre>     *         integers).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1052" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1053" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1054" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1055" href="#"></a></td>
<td><pre>    @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1056" href="#"></a></td>
<td><pre>    public static &lt;T extends Comparable&lt;? super T&gt;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1057" href="#"></a></td>
<td><pre>    void parallelSort(T[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1058" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1059" href="#"></a></td>
<td><pre>        int n = toIndex - fromIndex, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1060" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1061" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1062" href="#"></a></td>
<td><pre>            TimSort.sort(a, fromIndex, toIndex, NaturalOrder.INSTANCE, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1063" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1064" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1065" href="#"></a></td>
<td><pre>                (null, a,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1066" href="#"></a></td>
<td><pre>                 (T[])Array.newInstance(a.getClass().getComponentType(), n),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1067" href="#"></a></td>
<td><pre>                 fromIndex, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1068" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g, NaturalOrder.INSTANCE).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1069" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1070" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1071" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1072" href="#"></a></td>
<td><pre>     * Sorts the specified array of objects according to the order induced by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1073" href="#"></a></td>
<td><pre>     * the specified comparator.  All elements in the array must be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1074" href="#"></a></td>
<td><pre>     * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1075" href="#"></a></td>
<td><pre>     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1076" href="#"></a></td>
<td><pre>     * for any elements {@code e1} and {@code e2} in the array).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1077" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1078" href="#"></a></td>
<td><pre>     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1079" href="#"></a></td>
<td><pre>     * not be reordered as a result of the sort.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1080" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1081" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1082" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1083" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1084" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1085" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1086" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1087" href="#"></a></td>
<td><pre>     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1088" href="#"></a></td>
<td><pre>     * working space no greater than the size of the original array. The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1089" href="#"></a></td>
<td><pre>     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1090" href="#"></a></td>
<td><pre>     * execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1091" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1092" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the class of the objects to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1093" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1094" href="#"></a></td>
<td><pre>     * @param cmp the comparator to determine the order of the array.  A</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1095" href="#"></a></td>
<td><pre>     *        {@code null} value indicates that the elements'</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1096" href="#"></a></td>
<td><pre>     *        {@linkplain Comparable natural ordering} should be used.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1097" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the array contains elements that are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1098" href="#"></a></td>
<td><pre>     *         not &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1099" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException (optional) if the comparator is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1100" href="#"></a></td>
<td><pre>     *         found to violate the {@link java.util.Comparator} contract</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1101" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1102" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1103" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1104" href="#"></a></td>
<td><pre>    @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1105" href="#"></a></td>
<td><pre>    public static &lt;T&gt; void parallelSort(T[] a, Comparator&lt;? super T&gt; cmp) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1106" href="#"></a></td>
<td><pre>        if (cmp == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1107" href="#"></a></td>
<td><pre>            cmp = NaturalOrder.INSTANCE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1108" href="#"></a></td>
<td><pre>        int n = a.length, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1109" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1110" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1111" href="#"></a></td>
<td><pre>            TimSort.sort(a, 0, n, cmp, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1112" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1113" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1114" href="#"></a></td>
<td><pre>                (null, a,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1115" href="#"></a></td>
<td><pre>                 (T[])Array.newInstance(a.getClass().getComponentType(), n),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1116" href="#"></a></td>
<td><pre>                 0, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1117" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g, cmp).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1118" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1119" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1120" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1121" href="#"></a></td>
<td><pre>     * Sorts the specified range of the specified array of objects according</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1122" href="#"></a></td>
<td><pre>     * to the order induced by the specified comparator.  The range to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1123" href="#"></a></td>
<td><pre>     * sorted extends from index {@code fromIndex}, inclusive, to index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1124" href="#"></a></td>
<td><pre>     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1125" href="#"></a></td>
<td><pre>     * range to be sorted is empty.)  All elements in the range must be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1126" href="#"></a></td>
<td><pre>     * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1127" href="#"></a></td>
<td><pre>     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1128" href="#"></a></td>
<td><pre>     * for any elements {@code e1} and {@code e2} in the range).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1129" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1130" href="#"></a></td>
<td><pre>     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1131" href="#"></a></td>
<td><pre>     * not be reordered as a result of the sort.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1132" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1133" href="#"></a></td>
<td><pre>     * @implNote The sorting algorithm is a parallel sort-merge that breaks the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1134" href="#"></a></td>
<td><pre>     * array into sub-arrays that are themselves sorted and then merged. When</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1135" href="#"></a></td>
<td><pre>     * the sub-array length reaches a minimum granularity, the sub-array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1136" href="#"></a></td>
<td><pre>     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1137" href="#"></a></td>
<td><pre>     * method. If the length of the specified array is less than the minimum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1138" href="#"></a></td>
<td><pre>     * granularity, then it is sorted using the appropriate {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1139" href="#"></a></td>
<td><pre>     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a working</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1140" href="#"></a></td>
<td><pre>     * space no greater than the size of the specified range of the original</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1141" href="#"></a></td>
<td><pre>     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1142" href="#"></a></td>
<td><pre>     * used to execute any parallel tasks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1143" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1144" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the class of the objects to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1145" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1146" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1147" href="#"></a></td>
<td><pre>     *        sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1148" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1149" href="#"></a></td>
<td><pre>     * @param cmp the comparator to determine the order of the array.  A</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1150" href="#"></a></td>
<td><pre>     *        {@code null} value indicates that the elements'</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1151" href="#"></a></td>
<td><pre>     *        {@linkplain Comparable natural ordering} should be used.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1152" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex} or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1153" href="#"></a></td>
<td><pre>     *         (optional) if the natural ordering of the array elements is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1154" href="#"></a></td>
<td><pre>     *         found to violate the {@link Comparable} contract</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1155" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1156" href="#"></a></td>
<td><pre>     *         {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1157" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the array contains elements that are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1158" href="#"></a></td>
<td><pre>     *         not &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1159" href="#"></a></td>
<td><pre>     *         integers).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1160" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1161" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1162" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1163" href="#"></a></td>
<td><pre>    @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1164" href="#"></a></td>
<td><pre>    public static &lt;T&gt; void parallelSort(T[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1165" href="#"></a></td>
<td><pre>                                        Comparator&lt;? super T&gt; cmp) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1166" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1167" href="#"></a></td>
<td><pre>        if (cmp == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1168" href="#"></a></td>
<td><pre>            cmp = NaturalOrder.INSTANCE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1169" href="#"></a></td>
<td><pre>        int n = toIndex - fromIndex, p, g;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1170" href="#"></a></td>
<td><pre>        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1171" href="#"></a></td>
<td><pre>            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1172" href="#"></a></td>
<td><pre>            TimSort.sort(a, fromIndex, toIndex, cmp, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1173" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1174" href="#"></a></td>
<td><pre>            new ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1175" href="#"></a></td>
<td><pre>                (null, a,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1176" href="#"></a></td>
<td><pre>                 (T[])Array.newInstance(a.getClass().getComponentType(), n),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1177" href="#"></a></td>
<td><pre>                 fromIndex, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1178" href="#"></a></td>
<td><pre>                 MIN_ARRAY_SORT_GRAN : g, cmp).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1179" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1180" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1181" href="#"></a></td>
<td><pre>    /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1182" href="#"></a></td>
<td><pre>     * Sorting of complex type arrays.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1183" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1184" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1185" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1186" href="#"></a></td>
<td><pre>     * Old merge sort implementation can be selected (for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1187" href="#"></a></td>
<td><pre>     * compatibility with broken comparators) using a system property.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1188" href="#"></a></td>
<td><pre>     * Cannot be a static boolean in the enclosing class due to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1189" href="#"></a></td>
<td><pre>     * circular dependencies. To be removed in a future release.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1190" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1191" href="#"></a></td>
<td><pre>    static final class LegacyMergeSort {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1192" href="#"></a></td>
<td><pre>        private static final boolean userRequested =</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1193" href="#"></a></td>
<td><pre>            java.security.AccessController.doPrivileged(</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1194" href="#"></a></td>
<td><pre>                new sun.security.action.GetBooleanAction(</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1195" href="#"></a></td>
<td><pre>                    &quot;java.util.Arrays.useLegacyMergeSort&quot;)).booleanValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1196" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1197" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1198" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1199" href="#"></a></td>
<td><pre>     * Sorts the specified array of objects into ascending order, according</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1200" href="#"></a></td>
<td><pre>     * to the {@linkplain Comparable natural ordering} of its elements.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1201" href="#"></a></td>
<td><pre>     * All elements in the array must implement the {@link Comparable}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1202" href="#"></a></td>
<td><pre>     * interface.  Furthermore, all elements in the array must be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1203" href="#"></a></td>
<td><pre>     * &lt;i&gt;mutually comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1204" href="#"></a></td>
<td><pre>     * not throw a {@code ClassCastException} for any elements {@code e1}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1205" href="#"></a></td>
<td><pre>     * and {@code e2} in the array).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1206" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1207" href="#"></a></td>
<td><pre>     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1208" href="#"></a></td>
<td><pre>     * not be reordered as a result of the sort.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1209" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1210" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1211" href="#"></a></td>
<td><pre>     * iterative mergesort that requires far fewer than n lg(n) comparisons</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1212" href="#"></a></td>
<td><pre>     * when the input array is partially sorted, while offering the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1213" href="#"></a></td>
<td><pre>     * performance of a traditional mergesort when the input array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1214" href="#"></a></td>
<td><pre>     * randomly ordered.  If the input array is nearly sorted, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1215" href="#"></a></td>
<td><pre>     * implementation requires approximately n comparisons.  Temporary</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1216" href="#"></a></td>
<td><pre>     * storage requirements vary from a small constant for nearly sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1217" href="#"></a></td>
<td><pre>     * input arrays to n/2 object references for randomly ordered input</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1218" href="#"></a></td>
<td><pre>     * arrays.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1219" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1220" href="#"></a></td>
<td><pre>     * &lt;p&gt;The implementation takes equal advantage of ascending and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1221" href="#"></a></td>
<td><pre>     * descending order in its input array, and can take advantage of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1222" href="#"></a></td>
<td><pre>     * ascending and descending order in different parts of the the same</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1223" href="#"></a></td>
<td><pre>     * input array.  It is well-suited to merging two or more sorted arrays:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1224" href="#"></a></td>
<td><pre>     * simply concatenate the arrays and sort the resulting array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1225" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1226" href="#"></a></td>
<td><pre>     * &lt;p&gt;The implementation was adapted from Tim Peters's list sort for Python</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1227" href="#"></a></td>
<td><pre>     * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1228" href="#"></a></td>
<td><pre>     * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy's &quot;Optimistic</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1229" href="#"></a></td>
<td><pre>     * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1230" href="#"></a></td>
<td><pre>     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1231" href="#"></a></td>
<td><pre>     * January 1993.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1232" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1233" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1234" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the array contains elements that are not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1235" href="#"></a></td>
<td><pre>     *         &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and integers)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1236" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException (optional) if the natural</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1237" href="#"></a></td>
<td><pre>     *         ordering of the array elements is found to violate the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1238" href="#"></a></td>
<td><pre>     *         {@link Comparable} contract</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1239" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1240" href="#"></a></td>
<td><pre>    public static void sort(Object[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1241" href="#"></a></td>
<td><pre>        if (LegacyMergeSort.userRequested)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1242" href="#"></a></td>
<td><pre>            legacyMergeSort(a);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1243" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1244" href="#"></a></td>
<td><pre>            ComparableTimSort.sort(a, 0, a.length, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1245" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1246" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1247" href="#"></a></td>
<td><pre>    /** To be removed in a future release. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1248" href="#"></a></td>
<td><pre>    private static void legacyMergeSort(Object[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1249" href="#"></a></td>
<td><pre>        Object[] aux = a.clone();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1250" href="#"></a></td>
<td><pre>        mergeSort(aux, a, 0, a.length, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1251" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1252" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1253" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1254" href="#"></a></td>
<td><pre>     * Sorts the specified range of the specified array of objects into</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1255" href="#"></a></td>
<td><pre>     * ascending order, according to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1256" href="#"></a></td>
<td><pre>     * {@linkplain Comparable natural ordering} of its</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1257" href="#"></a></td>
<td><pre>     * elements.  The range to be sorted extends from index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1258" href="#"></a></td>
<td><pre>     * {@code fromIndex}, inclusive, to index {@code toIndex}, exclusive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1259" href="#"></a></td>
<td><pre>     * (If {@code fromIndex==toIndex}, the range to be sorted is empty.)  All</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1260" href="#"></a></td>
<td><pre>     * elements in this range must implement the {@link Comparable}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1261" href="#"></a></td>
<td><pre>     * interface.  Furthermore, all elements in this range must be &lt;i&gt;mutually</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1262" href="#"></a></td>
<td><pre>     * comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must not throw a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1263" href="#"></a></td>
<td><pre>     * {@code ClassCastException} for any elements {@code e1} and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1264" href="#"></a></td>
<td><pre>     * {@code e2} in the array).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1265" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1266" href="#"></a></td>
<td><pre>     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1267" href="#"></a></td>
<td><pre>     * not be reordered as a result of the sort.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1268" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1269" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1270" href="#"></a></td>
<td><pre>     * iterative mergesort that requires far fewer than n lg(n) comparisons</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1271" href="#"></a></td>
<td><pre>     * when the input array is partially sorted, while offering the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1272" href="#"></a></td>
<td><pre>     * performance of a traditional mergesort when the input array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1273" href="#"></a></td>
<td><pre>     * randomly ordered.  If the input array is nearly sorted, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1274" href="#"></a></td>
<td><pre>     * implementation requires approximately n comparisons.  Temporary</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1275" href="#"></a></td>
<td><pre>     * storage requirements vary from a small constant for nearly sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1276" href="#"></a></td>
<td><pre>     * input arrays to n/2 object references for randomly ordered input</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1277" href="#"></a></td>
<td><pre>     * arrays.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1278" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1279" href="#"></a></td>
<td><pre>     * &lt;p&gt;The implementation takes equal advantage of ascending and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1280" href="#"></a></td>
<td><pre>     * descending order in its input array, and can take advantage of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1281" href="#"></a></td>
<td><pre>     * ascending and descending order in different parts of the the same</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1282" href="#"></a></td>
<td><pre>     * input array.  It is well-suited to merging two or more sorted arrays:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1283" href="#"></a></td>
<td><pre>     * simply concatenate the arrays and sort the resulting array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1284" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1285" href="#"></a></td>
<td><pre>     * &lt;p&gt;The implementation was adapted from Tim Peters's list sort for Python</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1286" href="#"></a></td>
<td><pre>     * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1287" href="#"></a></td>
<td><pre>     * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy's &quot;Optimistic</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1288" href="#"></a></td>
<td><pre>     * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1289" href="#"></a></td>
<td><pre>     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1290" href="#"></a></td>
<td><pre>     * January 1993.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1291" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1292" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1293" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1294" href="#"></a></td>
<td><pre>     *        sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1295" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1296" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex} or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1297" href="#"></a></td>
<td><pre>     *         (optional) if the natural ordering of the array elements is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1298" href="#"></a></td>
<td><pre>     *         found to violate the {@link Comparable} contract</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1299" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1300" href="#"></a></td>
<td><pre>     *         {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1301" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the array contains elements that are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1302" href="#"></a></td>
<td><pre>     *         not &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1303" href="#"></a></td>
<td><pre>     *         integers).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1304" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1305" href="#"></a></td>
<td><pre>    public static void sort(Object[] a, int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1306" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1307" href="#"></a></td>
<td><pre>        if (LegacyMergeSort.userRequested)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1308" href="#"></a></td>
<td><pre>            legacyMergeSort(a, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1309" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1310" href="#"></a></td>
<td><pre>            ComparableTimSort.sort(a, fromIndex, toIndex, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1311" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1312" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1313" href="#"></a></td>
<td><pre>    /** To be removed in a future release. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1314" href="#"></a></td>
<td><pre>    private static void legacyMergeSort(Object[] a,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1315" href="#"></a></td>
<td><pre>                                        int fromIndex, int toIndex) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1316" href="#"></a></td>
<td><pre>        Object[] aux = copyOfRange(a, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1317" href="#"></a></td>
<td><pre>        mergeSort(aux, a, fromIndex, toIndex, -fromIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1318" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1319" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1320" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1321" href="#"></a></td>
<td><pre>     * Tuning parameter: list size at or below which insertion sort will be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1322" href="#"></a></td>
<td><pre>     * used in preference to mergesort.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1323" href="#"></a></td>
<td><pre>     * To be removed in a future release.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1324" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1325" href="#"></a></td>
<td><pre>    private static final int INSERTIONSORT_THRESHOLD = 7;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1326" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1327" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1328" href="#"></a></td>
<td><pre>     * Src is the source array that starts at index 0</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1329" href="#"></a></td>
<td><pre>     * Dest is the (possibly larger) array destination with a possible offset</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1330" href="#"></a></td>
<td><pre>     * low is the index in dest to start sorting</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1331" href="#"></a></td>
<td><pre>     * high is the end index in dest to end sorting</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1332" href="#"></a></td>
<td><pre>     * off is the offset to generate corresponding low, high in src</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1333" href="#"></a></td>
<td><pre>     * To be removed in a future release.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1334" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1335" href="#"></a></td>
<td><pre>    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1336" href="#"></a></td>
<td><pre>    private static void mergeSort(Object[] src,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1337" href="#"></a></td>
<td><pre>                                  Object[] dest,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1338" href="#"></a></td>
<td><pre>                                  int low,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1339" href="#"></a></td>
<td><pre>                                  int high,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1340" href="#"></a></td>
<td><pre>                                  int off) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1341" href="#"></a></td>
<td><pre>        int length = high - low;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1342" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1343" href="#"></a></td>
<td><pre>        // Insertion sort on smallest arrays</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1344" href="#"></a></td>
<td><pre>        if (length &lt; INSERTIONSORT_THRESHOLD) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1345" href="#"></a></td>
<td><pre>            for (int i=low; i&lt;high; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1346" href="#"></a></td>
<td><pre>                for (int j=i; j&gt;low &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1347" href="#"></a></td>
<td><pre>                         ((Comparable) dest[j-1]).compareTo(dest[j])&gt;0; j--)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1348" href="#"></a></td>
<td><pre>                    swap(dest, j, j-1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1349" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1350" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1351" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1352" href="#"></a></td>
<td><pre>        // Recursively sort halves of dest into src</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1353" href="#"></a></td>
<td><pre>        int destLow  = low;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1354" href="#"></a></td>
<td><pre>        int destHigh = high;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1355" href="#"></a></td>
<td><pre>        low  += off;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1356" href="#"></a></td>
<td><pre>        high += off;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1357" href="#"></a></td>
<td><pre>        int mid = (low + high) &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1358" href="#"></a></td>
<td><pre>        mergeSort(dest, src, low, mid, -off);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1359" href="#"></a></td>
<td><pre>        mergeSort(dest, src, mid, high, -off);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1360" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1361" href="#"></a></td>
<td><pre>        // If list is already sorted, just copy from src to dest.  This is an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1362" href="#"></a></td>
<td><pre>        // optimization that results in faster sorts for nearly ordered lists.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1363" href="#"></a></td>
<td><pre>        if (((Comparable)src[mid-1]).compareTo(src[mid]) &lt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1364" href="#"></a></td>
<td><pre>            System.arraycopy(src, low, dest, destLow, length);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1365" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1366" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1367" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1368" href="#"></a></td>
<td><pre>        // Merge sorted halves (now in src) into dest</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1369" href="#"></a></td>
<td><pre>        for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1370" href="#"></a></td>
<td><pre>            if (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1371" href="#"></a></td>
<td><pre>                dest[i] = src[p++];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1372" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1373" href="#"></a></td>
<td><pre>                dest[i] = src[q++];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1374" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1375" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1376" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1377" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1378" href="#"></a></td>
<td><pre>     * Swaps x[a] with x[b].</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1379" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1380" href="#"></a></td>
<td><pre>    private static void swap(Object[] x, int a, int b) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1381" href="#"></a></td>
<td><pre>        Object t = x[a];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1382" href="#"></a></td>
<td><pre>        x[a] = x[b];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1383" href="#"></a></td>
<td><pre>        x[b] = t;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1384" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1385" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1386" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1387" href="#"></a></td>
<td><pre>     * Sorts the specified array of objects according to the order induced by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1388" href="#"></a></td>
<td><pre>     * the specified comparator.  All elements in the array must be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1389" href="#"></a></td>
<td><pre>     * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1390" href="#"></a></td>
<td><pre>     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1391" href="#"></a></td>
<td><pre>     * for any elements {@code e1} and {@code e2} in the array).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1392" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1393" href="#"></a></td>
<td><pre>     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1394" href="#"></a></td>
<td><pre>     * not be reordered as a result of the sort.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1395" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1396" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1397" href="#"></a></td>
<td><pre>     * iterative mergesort that requires far fewer than n lg(n) comparisons</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1398" href="#"></a></td>
<td><pre>     * when the input array is partially sorted, while offering the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1399" href="#"></a></td>
<td><pre>     * performance of a traditional mergesort when the input array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1400" href="#"></a></td>
<td><pre>     * randomly ordered.  If the input array is nearly sorted, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1401" href="#"></a></td>
<td><pre>     * implementation requires approximately n comparisons.  Temporary</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1402" href="#"></a></td>
<td><pre>     * storage requirements vary from a small constant for nearly sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1403" href="#"></a></td>
<td><pre>     * input arrays to n/2 object references for randomly ordered input</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1404" href="#"></a></td>
<td><pre>     * arrays.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1405" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1406" href="#"></a></td>
<td><pre>     * &lt;p&gt;The implementation takes equal advantage of ascending and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1407" href="#"></a></td>
<td><pre>     * descending order in its input array, and can take advantage of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1408" href="#"></a></td>
<td><pre>     * ascending and descending order in different parts of the the same</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1409" href="#"></a></td>
<td><pre>     * input array.  It is well-suited to merging two or more sorted arrays:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1410" href="#"></a></td>
<td><pre>     * simply concatenate the arrays and sort the resulting array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1411" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1412" href="#"></a></td>
<td><pre>     * &lt;p&gt;The implementation was adapted from Tim Peters's list sort for Python</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1413" href="#"></a></td>
<td><pre>     * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1414" href="#"></a></td>
<td><pre>     * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy's &quot;Optimistic</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1415" href="#"></a></td>
<td><pre>     * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1416" href="#"></a></td>
<td><pre>     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1417" href="#"></a></td>
<td><pre>     * January 1993.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1418" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1419" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the class of the objects to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1420" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1421" href="#"></a></td>
<td><pre>     * @param c the comparator to determine the order of the array.  A</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1422" href="#"></a></td>
<td><pre>     *        {@code null} value indicates that the elements'</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1423" href="#"></a></td>
<td><pre>     *        {@linkplain Comparable natural ordering} should be used.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1424" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the array contains elements that are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1425" href="#"></a></td>
<td><pre>     *         not &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1426" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException (optional) if the comparator is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1427" href="#"></a></td>
<td><pre>     *         found to violate the {@link Comparator} contract</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1428" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1429" href="#"></a></td>
<td><pre>    public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1430" href="#"></a></td>
<td><pre>        if (c == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1431" href="#"></a></td>
<td><pre>            c = NaturalOrder.INSTANCE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1432" href="#"></a></td>
<td><pre>        if (LegacyMergeSort.userRequested)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1433" href="#"></a></td>
<td><pre>            legacyMergeSort(a, c);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1434" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1435" href="#"></a></td>
<td><pre>            TimSort.sort(a, 0, a.length, c, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1436" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1437" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1438" href="#"></a></td>
<td><pre>    /** To be removed in a future release. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1439" href="#"></a></td>
<td><pre>    private static &lt;T&gt; void legacyMergeSort(T[] a, Comparator&lt;? super T&gt; c) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1440" href="#"></a></td>
<td><pre>        T[] aux = a.clone();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1441" href="#"></a></td>
<td><pre>        if (c==null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1442" href="#"></a></td>
<td><pre>            mergeSort(aux, a, 0, a.length, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1443" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1444" href="#"></a></td>
<td><pre>            mergeSort(aux, a, 0, a.length, 0, c);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1445" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1446" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1447" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1448" href="#"></a></td>
<td><pre>     * Sorts the specified range of the specified array of objects according</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1449" href="#"></a></td>
<td><pre>     * to the order induced by the specified comparator.  The range to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1450" href="#"></a></td>
<td><pre>     * sorted extends from index {@code fromIndex}, inclusive, to index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1451" href="#"></a></td>
<td><pre>     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1452" href="#"></a></td>
<td><pre>     * range to be sorted is empty.)  All elements in the range must be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1453" href="#"></a></td>
<td><pre>     * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1454" href="#"></a></td>
<td><pre>     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1455" href="#"></a></td>
<td><pre>     * for any elements {@code e1} and {@code e2} in the range).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1456" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1457" href="#"></a></td>
<td><pre>     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1458" href="#"></a></td>
<td><pre>     * not be reordered as a result of the sort.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1459" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1460" href="#"></a></td>
<td><pre>     * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1461" href="#"></a></td>
<td><pre>     * iterative mergesort that requires far fewer than n lg(n) comparisons</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1462" href="#"></a></td>
<td><pre>     * when the input array is partially sorted, while offering the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1463" href="#"></a></td>
<td><pre>     * performance of a traditional mergesort when the input array is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1464" href="#"></a></td>
<td><pre>     * randomly ordered.  If the input array is nearly sorted, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1465" href="#"></a></td>
<td><pre>     * implementation requires approximately n comparisons.  Temporary</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1466" href="#"></a></td>
<td><pre>     * storage requirements vary from a small constant for nearly sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1467" href="#"></a></td>
<td><pre>     * input arrays to n/2 object references for randomly ordered input</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1468" href="#"></a></td>
<td><pre>     * arrays.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1469" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1470" href="#"></a></td>
<td><pre>     * &lt;p&gt;The implementation takes equal advantage of ascending and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1471" href="#"></a></td>
<td><pre>     * descending order in its input array, and can take advantage of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1472" href="#"></a></td>
<td><pre>     * ascending and descending order in different parts of the the same</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1473" href="#"></a></td>
<td><pre>     * input array.  It is well-suited to merging two or more sorted arrays:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1474" href="#"></a></td>
<td><pre>     * simply concatenate the arrays and sort the resulting array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1475" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1476" href="#"></a></td>
<td><pre>     * &lt;p&gt;The implementation was adapted from Tim Peters's list sort for Python</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1477" href="#"></a></td>
<td><pre>     * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1478" href="#"></a></td>
<td><pre>     * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy's &quot;Optimistic</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1479" href="#"></a></td>
<td><pre>     * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1480" href="#"></a></td>
<td><pre>     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1481" href="#"></a></td>
<td><pre>     * January 1993.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1482" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1483" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the class of the objects to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1484" href="#"></a></td>
<td><pre>     * @param a the array to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1485" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1486" href="#"></a></td>
<td><pre>     *        sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1487" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1488" href="#"></a></td>
<td><pre>     * @param c the comparator to determine the order of the array.  A</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1489" href="#"></a></td>
<td><pre>     *        {@code null} value indicates that the elements'</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1490" href="#"></a></td>
<td><pre>     *        {@linkplain Comparable natural ordering} should be used.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1491" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the array contains elements that are not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1492" href="#"></a></td>
<td><pre>     *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1493" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex} or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1494" href="#"></a></td>
<td><pre>     *         (optional) if the comparator is found to violate the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1495" href="#"></a></td>
<td><pre>     *         {@link Comparator} contract</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1496" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1497" href="#"></a></td>
<td><pre>     *         {@code toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1498" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1499" href="#"></a></td>
<td><pre>    public static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1500" href="#"></a></td>
<td><pre>                                Comparator&lt;? super T&gt; c) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1501" href="#"></a></td>
<td><pre>        if (c == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1502" href="#"></a></td>
<td><pre>            c = NaturalOrder.INSTANCE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1503" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1504" href="#"></a></td>
<td><pre>        if (LegacyMergeSort.userRequested)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1505" href="#"></a></td>
<td><pre>            legacyMergeSort(a, fromIndex, toIndex, c);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1506" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1507" href="#"></a></td>
<td><pre>            TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1508" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1509" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1510" href="#"></a></td>
<td><pre>    /** To be removed in a future release. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1511" href="#"></a></td>
<td><pre>    private static &lt;T&gt; void legacyMergeSort(T[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1512" href="#"></a></td>
<td><pre>                                            Comparator&lt;? super T&gt; c) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1513" href="#"></a></td>
<td><pre>        T[] aux = copyOfRange(a, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1514" href="#"></a></td>
<td><pre>        if (c==null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1515" href="#"></a></td>
<td><pre>            mergeSort(aux, a, fromIndex, toIndex, -fromIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1516" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1517" href="#"></a></td>
<td><pre>            mergeSort(aux, a, fromIndex, toIndex, -fromIndex, c);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1518" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1519" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1520" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1521" href="#"></a></td>
<td><pre>     * Src is the source array that starts at index 0</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1522" href="#"></a></td>
<td><pre>     * Dest is the (possibly larger) array destination with a possible offset</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1523" href="#"></a></td>
<td><pre>     * low is the index in dest to start sorting</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1524" href="#"></a></td>
<td><pre>     * high is the end index in dest to end sorting</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1525" href="#"></a></td>
<td><pre>     * off is the offset into src corresponding to low in dest</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1526" href="#"></a></td>
<td><pre>     * To be removed in a future release.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1527" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1528" href="#"></a></td>
<td><pre>    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1529" href="#"></a></td>
<td><pre>    private static void mergeSort(Object[] src,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1530" href="#"></a></td>
<td><pre>                                  Object[] dest,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1531" href="#"></a></td>
<td><pre>                                  int low, int high, int off,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1532" href="#"></a></td>
<td><pre>                                  Comparator c) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1533" href="#"></a></td>
<td><pre>        int length = high - low;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1534" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1535" href="#"></a></td>
<td><pre>        // Insertion sort on smallest arrays</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1536" href="#"></a></td>
<td><pre>        if (length &lt; INSERTIONSORT_THRESHOLD) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1537" href="#"></a></td>
<td><pre>            for (int i=low; i&lt;high; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1538" href="#"></a></td>
<td><pre>                for (int j=i; j&gt;low &amp;&amp; c.compare(dest[j-1], dest[j])&gt;0; j--)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1539" href="#"></a></td>
<td><pre>                    swap(dest, j, j-1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1540" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1541" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1542" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1543" href="#"></a></td>
<td><pre>        // Recursively sort halves of dest into src</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1544" href="#"></a></td>
<td><pre>        int destLow  = low;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1545" href="#"></a></td>
<td><pre>        int destHigh = high;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1546" href="#"></a></td>
<td><pre>        low  += off;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1547" href="#"></a></td>
<td><pre>        high += off;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1548" href="#"></a></td>
<td><pre>        int mid = (low + high) &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1549" href="#"></a></td>
<td><pre>        mergeSort(dest, src, low, mid, -off, c);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1550" href="#"></a></td>
<td><pre>        mergeSort(dest, src, mid, high, -off, c);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1551" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1552" href="#"></a></td>
<td><pre>        // If list is already sorted, just copy from src to dest.  This is an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1553" href="#"></a></td>
<td><pre>        // optimization that results in faster sorts for nearly ordered lists.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1554" href="#"></a></td>
<td><pre>        if (c.compare(src[mid-1], src[mid]) &lt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1555" href="#"></a></td>
<td><pre>           System.arraycopy(src, low, dest, destLow, length);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1556" href="#"></a></td>
<td><pre>           return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1557" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1558" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1559" href="#"></a></td>
<td><pre>        // Merge sorted halves (now in src) into dest</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1560" href="#"></a></td>
<td><pre>        for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1561" href="#"></a></td>
<td><pre>            if (q &gt;= high || p &lt; mid &amp;&amp; c.compare(src[p], src[q]) &lt;= 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1562" href="#"></a></td>
<td><pre>                dest[i] = src[p++];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1563" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1564" href="#"></a></td>
<td><pre>                dest[i] = src[q++];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1565" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1566" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1567" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1568" href="#"></a></td>
<td><pre>    // Parallel prefix</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1569" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1570" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1571" href="#"></a></td>
<td><pre>     * Cumulates, in parallel, each element of the given array in place,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1572" href="#"></a></td>
<td><pre>     * using the supplied function. For example if the array initially</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1573" href="#"></a></td>
<td><pre>     * holds {@code [2, 1, 0, 3]} and the operation performs addition,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1574" href="#"></a></td>
<td><pre>     * then upon return the array holds {@code [2, 3, 3, 6]}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1575" href="#"></a></td>
<td><pre>     * Parallel prefix computation is usually more efficient than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1576" href="#"></a></td>
<td><pre>     * sequential loops for large arrays.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1577" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1578" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the class of the objects in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1579" href="#"></a></td>
<td><pre>     * @param array the array, which is modified in-place by this method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1580" href="#"></a></td>
<td><pre>     * @param op a side-effect-free, associative function to perform the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1581" href="#"></a></td>
<td><pre>     * cumulation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1582" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified array or function is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1583" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1584" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1585" href="#"></a></td>
<td><pre>    public static &lt;T&gt; void parallelPrefix(T[] array, BinaryOperator&lt;T&gt; op) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1586" href="#"></a></td>
<td><pre>        Objects.requireNonNull(op);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1587" href="#"></a></td>
<td><pre>        if (array.length &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1588" href="#"></a></td>
<td><pre>            new ArrayPrefixHelpers.CumulateTask&lt;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1589" href="#"></a></td>
<td><pre>                    (null, op, array, 0, array.length).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1590" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1591" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1592" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1593" href="#"></a></td>
<td><pre>     * Performs {@link #parallelPrefix(Object[], BinaryOperator)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1594" href="#"></a></td>
<td><pre>     * for the given subrange of the array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1595" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1596" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the class of the objects in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1597" href="#"></a></td>
<td><pre>     * @param array the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1598" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1599" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1600" href="#"></a></td>
<td><pre>     * @param op a side-effect-free, associative function to perform the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1601" href="#"></a></td>
<td><pre>     * cumulation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1602" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1603" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1604" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; array.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1605" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified array or function is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1606" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1607" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1608" href="#"></a></td>
<td><pre>    public static &lt;T&gt; void parallelPrefix(T[] array, int fromIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1609" href="#"></a></td>
<td><pre>                                          int toIndex, BinaryOperator&lt;T&gt; op) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1610" href="#"></a></td>
<td><pre>        Objects.requireNonNull(op);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1611" href="#"></a></td>
<td><pre>        rangeCheck(array.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1612" href="#"></a></td>
<td><pre>        if (fromIndex &lt; toIndex)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1613" href="#"></a></td>
<td><pre>            new ArrayPrefixHelpers.CumulateTask&lt;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1614" href="#"></a></td>
<td><pre>                    (null, op, array, fromIndex, toIndex).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1615" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1616" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1617" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1618" href="#"></a></td>
<td><pre>     * Cumulates, in parallel, each element of the given array in place,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1619" href="#"></a></td>
<td><pre>     * using the supplied function. For example if the array initially</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1620" href="#"></a></td>
<td><pre>     * holds {@code [2, 1, 0, 3]} and the operation performs addition,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1621" href="#"></a></td>
<td><pre>     * then upon return the array holds {@code [2, 3, 3, 6]}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1622" href="#"></a></td>
<td><pre>     * Parallel prefix computation is usually more efficient than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1623" href="#"></a></td>
<td><pre>     * sequential loops for large arrays.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1624" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1625" href="#"></a></td>
<td><pre>     * @param array the array, which is modified in-place by this method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1626" href="#"></a></td>
<td><pre>     * @param op a side-effect-free, associative function to perform the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1627" href="#"></a></td>
<td><pre>     * cumulation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1628" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified array or function is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1629" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1630" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1631" href="#"></a></td>
<td><pre>    public static void parallelPrefix(long[] array, LongBinaryOperator op) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1632" href="#"></a></td>
<td><pre>        Objects.requireNonNull(op);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1633" href="#"></a></td>
<td><pre>        if (array.length &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1634" href="#"></a></td>
<td><pre>            new ArrayPrefixHelpers.LongCumulateTask</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1635" href="#"></a></td>
<td><pre>                    (null, op, array, 0, array.length).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1636" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1637" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1638" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1639" href="#"></a></td>
<td><pre>     * Performs {@link #parallelPrefix(long[], LongBinaryOperator)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1640" href="#"></a></td>
<td><pre>     * for the given subrange of the array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1641" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1642" href="#"></a></td>
<td><pre>     * @param array the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1643" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1644" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1645" href="#"></a></td>
<td><pre>     * @param op a side-effect-free, associative function to perform the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1646" href="#"></a></td>
<td><pre>     * cumulation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1647" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1648" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1649" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; array.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1650" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified array or function is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1651" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1652" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1653" href="#"></a></td>
<td><pre>    public static void parallelPrefix(long[] array, int fromIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1654" href="#"></a></td>
<td><pre>                                      int toIndex, LongBinaryOperator op) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1655" href="#"></a></td>
<td><pre>        Objects.requireNonNull(op);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1656" href="#"></a></td>
<td><pre>        rangeCheck(array.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1657" href="#"></a></td>
<td><pre>        if (fromIndex &lt; toIndex)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1658" href="#"></a></td>
<td><pre>            new ArrayPrefixHelpers.LongCumulateTask</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1659" href="#"></a></td>
<td><pre>                    (null, op, array, fromIndex, toIndex).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1660" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1661" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1662" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1663" href="#"></a></td>
<td><pre>     * Cumulates, in parallel, each element of the given array in place,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1664" href="#"></a></td>
<td><pre>     * using the supplied function. For example if the array initially</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1665" href="#"></a></td>
<td><pre>     * holds {@code [2.0, 1.0, 0.0, 3.0]} and the operation performs addition,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1666" href="#"></a></td>
<td><pre>     * then upon return the array holds {@code [2.0, 3.0, 3.0, 6.0]}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1667" href="#"></a></td>
<td><pre>     * Parallel prefix computation is usually more efficient than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1668" href="#"></a></td>
<td><pre>     * sequential loops for large arrays.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1669" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1670" href="#"></a></td>
<td><pre>     * &lt;p&gt; Because floating-point operations may not be strictly associative,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1671" href="#"></a></td>
<td><pre>     * the returned result may not be identical to the value that would be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1672" href="#"></a></td>
<td><pre>     * obtained if the operation was performed sequentially.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1673" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1674" href="#"></a></td>
<td><pre>     * @param array the array, which is modified in-place by this method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1675" href="#"></a></td>
<td><pre>     * @param op a side-effect-free function to perform the cumulation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1676" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified array or function is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1677" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1678" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1679" href="#"></a></td>
<td><pre>    public static void parallelPrefix(double[] array, DoubleBinaryOperator op) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1680" href="#"></a></td>
<td><pre>        Objects.requireNonNull(op);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1681" href="#"></a></td>
<td><pre>        if (array.length &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1682" href="#"></a></td>
<td><pre>            new ArrayPrefixHelpers.DoubleCumulateTask</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1683" href="#"></a></td>
<td><pre>                    (null, op, array, 0, array.length).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1684" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1685" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1686" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1687" href="#"></a></td>
<td><pre>     * Performs {@link #parallelPrefix(double[], DoubleBinaryOperator)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1688" href="#"></a></td>
<td><pre>     * for the given subrange of the array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1689" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1690" href="#"></a></td>
<td><pre>     * @param array the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1691" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1692" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1693" href="#"></a></td>
<td><pre>     * @param op a side-effect-free, associative function to perform the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1694" href="#"></a></td>
<td><pre>     * cumulation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1695" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1696" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1697" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; array.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1698" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified array or function is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1699" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1700" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1701" href="#"></a></td>
<td><pre>    public static void parallelPrefix(double[] array, int fromIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1702" href="#"></a></td>
<td><pre>                                      int toIndex, DoubleBinaryOperator op) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1703" href="#"></a></td>
<td><pre>        Objects.requireNonNull(op);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1704" href="#"></a></td>
<td><pre>        rangeCheck(array.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1705" href="#"></a></td>
<td><pre>        if (fromIndex &lt; toIndex)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1706" href="#"></a></td>
<td><pre>            new ArrayPrefixHelpers.DoubleCumulateTask</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1707" href="#"></a></td>
<td><pre>                    (null, op, array, fromIndex, toIndex).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1708" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1709" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1710" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1711" href="#"></a></td>
<td><pre>     * Cumulates, in parallel, each element of the given array in place,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1712" href="#"></a></td>
<td><pre>     * using the supplied function. For example if the array initially</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1713" href="#"></a></td>
<td><pre>     * holds {@code [2, 1, 0, 3]} and the operation performs addition,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1714" href="#"></a></td>
<td><pre>     * then upon return the array holds {@code [2, 3, 3, 6]}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1715" href="#"></a></td>
<td><pre>     * Parallel prefix computation is usually more efficient than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1716" href="#"></a></td>
<td><pre>     * sequential loops for large arrays.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1717" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1718" href="#"></a></td>
<td><pre>     * @param array the array, which is modified in-place by this method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1719" href="#"></a></td>
<td><pre>     * @param op a side-effect-free, associative function to perform the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1720" href="#"></a></td>
<td><pre>     * cumulation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1721" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified array or function is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1722" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1723" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1724" href="#"></a></td>
<td><pre>    public static void parallelPrefix(int[] array, IntBinaryOperator op) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1725" href="#"></a></td>
<td><pre>        Objects.requireNonNull(op);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1726" href="#"></a></td>
<td><pre>        if (array.length &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1727" href="#"></a></td>
<td><pre>            new ArrayPrefixHelpers.IntCumulateTask</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1728" href="#"></a></td>
<td><pre>                    (null, op, array, 0, array.length).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1729" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1730" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1731" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1732" href="#"></a></td>
<td><pre>     * Performs {@link #parallelPrefix(int[], IntBinaryOperator)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1733" href="#"></a></td>
<td><pre>     * for the given subrange of the array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1734" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1735" href="#"></a></td>
<td><pre>     * @param array the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1736" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1737" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element, exclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1738" href="#"></a></td>
<td><pre>     * @param op a side-effect-free, associative function to perform the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1739" href="#"></a></td>
<td><pre>     * cumulation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1740" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1741" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1742" href="#"></a></td>
<td><pre>     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; array.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1743" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified array or function is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1744" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1745" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1746" href="#"></a></td>
<td><pre>    public static void parallelPrefix(int[] array, int fromIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1747" href="#"></a></td>
<td><pre>                                      int toIndex, IntBinaryOperator op) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1748" href="#"></a></td>
<td><pre>        Objects.requireNonNull(op);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1749" href="#"></a></td>
<td><pre>        rangeCheck(array.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1750" href="#"></a></td>
<td><pre>        if (fromIndex &lt; toIndex)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1751" href="#"></a></td>
<td><pre>            new ArrayPrefixHelpers.IntCumulateTask</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1752" href="#"></a></td>
<td><pre>                    (null, op, array, fromIndex, toIndex).invoke();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1753" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1754" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1755" href="#"></a></td>
<td><pre>    // Searching</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1756" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1757" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1758" href="#"></a></td>
<td><pre>     * Searches the specified array of longs for the specified value using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1759" href="#"></a></td>
<td><pre>     * binary search algorithm.  The array must be sorted (as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1760" href="#"></a></td>
<td><pre>     * by the {@link #sort(long[])} method) prior to making this call.  If it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1761" href="#"></a></td>
<td><pre>     * is not sorted, the results are undefined.  If the array contains</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1762" href="#"></a></td>
<td><pre>     * multiple elements with the specified value, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1763" href="#"></a></td>
<td><pre>     * one will be found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1764" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1765" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1766" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1767" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1768" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1769" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1770" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1771" href="#"></a></td>
<td><pre>     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1772" href="#"></a></td>
<td><pre>     *         elements in the array are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1773" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1774" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1775" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1776" href="#"></a></td>
<td><pre>    public static int binarySearch(long[] a, long key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1777" href="#"></a></td>
<td><pre>        return binarySearch0(a, 0, a.length, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1778" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1779" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1780" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1781" href="#"></a></td>
<td><pre>     * Searches a range of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1782" href="#"></a></td>
<td><pre>     * the specified array of longs for the specified value using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1783" href="#"></a></td>
<td><pre>     * binary search algorithm.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1784" href="#"></a></td>
<td><pre>     * The range must be sorted (as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1785" href="#"></a></td>
<td><pre>     * by the {@link #sort(long[], int, int)} method)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1786" href="#"></a></td>
<td><pre>     * prior to making this call.  If it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1787" href="#"></a></td>
<td><pre>     * is not sorted, the results are undefined.  If the range contains</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1788" href="#"></a></td>
<td><pre>     * multiple elements with the specified value, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1789" href="#"></a></td>
<td><pre>     * one will be found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1790" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1791" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1792" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1793" href="#"></a></td>
<td><pre>     *          searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1794" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1795" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1796" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1797" href="#"></a></td>
<td><pre>     *         within the specified range;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1798" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1799" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1800" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1801" href="#"></a></td>
<td><pre>     *         element in the range greater than the key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1802" href="#"></a></td>
<td><pre>     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1803" href="#"></a></td>
<td><pre>     *         elements in the range are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1804" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1805" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1806" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1807" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1808" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1809" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1810" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1811" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1812" href="#"></a></td>
<td><pre>    public static int binarySearch(long[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1813" href="#"></a></td>
<td><pre>                                   long key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1814" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1815" href="#"></a></td>
<td><pre>        return binarySearch0(a, fromIndex, toIndex, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1816" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1817" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1818" href="#"></a></td>
<td><pre>    // Like public version, but without range checks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1819" href="#"></a></td>
<td><pre>    private static int binarySearch0(long[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1820" href="#"></a></td>
<td><pre>                                     long key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1821" href="#"></a></td>
<td><pre>        int low = fromIndex;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1822" href="#"></a></td>
<td><pre>        int high = toIndex - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1823" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1824" href="#"></a></td>
<td><pre>        while (low &lt;= high) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1825" href="#"></a></td>
<td><pre>            int mid = (low + high) &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1826" href="#"></a></td>
<td><pre>            long midVal = a[mid];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1827" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1828" href="#"></a></td>
<td><pre>            if (midVal &lt; key)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1829" href="#"></a></td>
<td><pre>                low = mid + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1830" href="#"></a></td>
<td><pre>            else if (midVal &gt; key)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1831" href="#"></a></td>
<td><pre>                high = mid - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1832" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1833" href="#"></a></td>
<td><pre>                return mid; // key found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1834" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1835" href="#"></a></td>
<td><pre>        return -(low + 1);  // key not found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1836" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1837" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1838" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1839" href="#"></a></td>
<td><pre>     * Searches the specified array of ints for the specified value using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1840" href="#"></a></td>
<td><pre>     * binary search algorithm.  The array must be sorted (as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1841" href="#"></a></td>
<td><pre>     * by the {@link #sort(int[])} method) prior to making this call.  If it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1842" href="#"></a></td>
<td><pre>     * is not sorted, the results are undefined.  If the array contains</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1843" href="#"></a></td>
<td><pre>     * multiple elements with the specified value, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1844" href="#"></a></td>
<td><pre>     * one will be found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1845" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1846" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1847" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1848" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1849" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1850" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1851" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1852" href="#"></a></td>
<td><pre>     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1853" href="#"></a></td>
<td><pre>     *         elements in the array are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1854" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1855" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1856" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1857" href="#"></a></td>
<td><pre>    public static int binarySearch(int[] a, int key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1858" href="#"></a></td>
<td><pre>        return binarySearch0(a, 0, a.length, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1859" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1860" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1861" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1862" href="#"></a></td>
<td><pre>     * Searches a range of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1863" href="#"></a></td>
<td><pre>     * the specified array of ints for the specified value using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1864" href="#"></a></td>
<td><pre>     * binary search algorithm.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1865" href="#"></a></td>
<td><pre>     * The range must be sorted (as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1866" href="#"></a></td>
<td><pre>     * by the {@link #sort(int[], int, int)} method)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1867" href="#"></a></td>
<td><pre>     * prior to making this call.  If it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1868" href="#"></a></td>
<td><pre>     * is not sorted, the results are undefined.  If the range contains</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1869" href="#"></a></td>
<td><pre>     * multiple elements with the specified value, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1870" href="#"></a></td>
<td><pre>     * one will be found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1871" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1872" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1873" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1874" href="#"></a></td>
<td><pre>     *          searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1875" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1876" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1877" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1878" href="#"></a></td>
<td><pre>     *         within the specified range;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1879" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1880" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1881" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1882" href="#"></a></td>
<td><pre>     *         element in the range greater than the key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1883" href="#"></a></td>
<td><pre>     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1884" href="#"></a></td>
<td><pre>     *         elements in the range are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1885" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1886" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1887" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1888" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1889" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1890" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1891" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1892" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1893" href="#"></a></td>
<td><pre>    public static int binarySearch(int[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1894" href="#"></a></td>
<td><pre>                                   int key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1895" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1896" href="#"></a></td>
<td><pre>        return binarySearch0(a, fromIndex, toIndex, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1897" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1898" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1899" href="#"></a></td>
<td><pre>    // Like public version, but without range checks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1900" href="#"></a></td>
<td><pre>    private static int binarySearch0(int[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1901" href="#"></a></td>
<td><pre>                                     int key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1902" href="#"></a></td>
<td><pre>        int low = fromIndex;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1903" href="#"></a></td>
<td><pre>        int high = toIndex - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1904" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1905" href="#"></a></td>
<td><pre>        while (low &lt;= high) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1906" href="#"></a></td>
<td><pre>            int mid = (low + high) &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1907" href="#"></a></td>
<td><pre>            int midVal = a[mid];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1908" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1909" href="#"></a></td>
<td><pre>            if (midVal &lt; key)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1910" href="#"></a></td>
<td><pre>                low = mid + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1911" href="#"></a></td>
<td><pre>            else if (midVal &gt; key)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1912" href="#"></a></td>
<td><pre>                high = mid - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1913" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1914" href="#"></a></td>
<td><pre>                return mid; // key found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1915" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1916" href="#"></a></td>
<td><pre>        return -(low + 1);  // key not found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1917" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1918" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1919" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1920" href="#"></a></td>
<td><pre>     * Searches the specified array of shorts for the specified value using</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1921" href="#"></a></td>
<td><pre>     * the binary search algorithm.  The array must be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1922" href="#"></a></td>
<td><pre>     * (as by the {@link #sort(short[])} method) prior to making this call.  If</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1923" href="#"></a></td>
<td><pre>     * it is not sorted, the results are undefined.  If the array contains</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1924" href="#"></a></td>
<td><pre>     * multiple elements with the specified value, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1925" href="#"></a></td>
<td><pre>     * one will be found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1926" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1927" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1928" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1929" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1930" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1931" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1932" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1933" href="#"></a></td>
<td><pre>     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1934" href="#"></a></td>
<td><pre>     *         elements in the array are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1935" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1936" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1937" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1938" href="#"></a></td>
<td><pre>    public static int binarySearch(short[] a, short key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1939" href="#"></a></td>
<td><pre>        return binarySearch0(a, 0, a.length, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1940" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1941" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1942" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1943" href="#"></a></td>
<td><pre>     * Searches a range of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1944" href="#"></a></td>
<td><pre>     * the specified array of shorts for the specified value using</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1945" href="#"></a></td>
<td><pre>     * the binary search algorithm.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1946" href="#"></a></td>
<td><pre>     * The range must be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1947" href="#"></a></td>
<td><pre>     * (as by the {@link #sort(short[], int, int)} method)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1948" href="#"></a></td>
<td><pre>     * prior to making this call.  If</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1949" href="#"></a></td>
<td><pre>     * it is not sorted, the results are undefined.  If the range contains</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1950" href="#"></a></td>
<td><pre>     * multiple elements with the specified value, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1951" href="#"></a></td>
<td><pre>     * one will be found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1952" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1953" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1954" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1955" href="#"></a></td>
<td><pre>     *          searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1956" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1957" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1958" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1959" href="#"></a></td>
<td><pre>     *         within the specified range;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1960" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1961" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1962" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1963" href="#"></a></td>
<td><pre>     *         element in the range greater than the key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1964" href="#"></a></td>
<td><pre>     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1965" href="#"></a></td>
<td><pre>     *         elements in the range are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1966" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1967" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1968" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1969" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1970" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1971" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1972" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1973" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1974" href="#"></a></td>
<td><pre>    public static int binarySearch(short[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1975" href="#"></a></td>
<td><pre>                                   short key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1976" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1977" href="#"></a></td>
<td><pre>        return binarySearch0(a, fromIndex, toIndex, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1978" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1979" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1980" href="#"></a></td>
<td><pre>    // Like public version, but without range checks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1981" href="#"></a></td>
<td><pre>    private static int binarySearch0(short[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1982" href="#"></a></td>
<td><pre>                                     short key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1983" href="#"></a></td>
<td><pre>        int low = fromIndex;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1984" href="#"></a></td>
<td><pre>        int high = toIndex - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1985" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1986" href="#"></a></td>
<td><pre>        while (low &lt;= high) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1987" href="#"></a></td>
<td><pre>            int mid = (low + high) &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1988" href="#"></a></td>
<td><pre>            short midVal = a[mid];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1989" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1990" href="#"></a></td>
<td><pre>            if (midVal &lt; key)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1991" href="#"></a></td>
<td><pre>                low = mid + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1992" href="#"></a></td>
<td><pre>            else if (midVal &gt; key)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1993" href="#"></a></td>
<td><pre>                high = mid - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1994" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1995" href="#"></a></td>
<td><pre>                return mid; // key found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1996" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1997" href="#"></a></td>
<td><pre>        return -(low + 1);  // key not found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1998" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1999" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2000" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2001" href="#"></a></td>
<td><pre>     * Searches the specified array of chars for the specified value using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2002" href="#"></a></td>
<td><pre>     * binary search algorithm.  The array must be sorted (as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2003" href="#"></a></td>
<td><pre>     * by the {@link #sort(char[])} method) prior to making this call.  If it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2004" href="#"></a></td>
<td><pre>     * is not sorted, the results are undefined.  If the array contains</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2005" href="#"></a></td>
<td><pre>     * multiple elements with the specified value, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2006" href="#"></a></td>
<td><pre>     * one will be found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2007" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2008" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2009" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2010" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2011" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2012" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2013" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2014" href="#"></a></td>
<td><pre>     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2015" href="#"></a></td>
<td><pre>     *         elements in the array are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2016" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2017" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2018" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2019" href="#"></a></td>
<td><pre>    public static int binarySearch(char[] a, char key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2020" href="#"></a></td>
<td><pre>        return binarySearch0(a, 0, a.length, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2021" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2022" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2023" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2024" href="#"></a></td>
<td><pre>     * Searches a range of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2025" href="#"></a></td>
<td><pre>     * the specified array of chars for the specified value using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2026" href="#"></a></td>
<td><pre>     * binary search algorithm.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2027" href="#"></a></td>
<td><pre>     * The range must be sorted (as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2028" href="#"></a></td>
<td><pre>     * by the {@link #sort(char[], int, int)} method)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2029" href="#"></a></td>
<td><pre>     * prior to making this call.  If it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2030" href="#"></a></td>
<td><pre>     * is not sorted, the results are undefined.  If the range contains</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2031" href="#"></a></td>
<td><pre>     * multiple elements with the specified value, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2032" href="#"></a></td>
<td><pre>     * one will be found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2033" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2034" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2035" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2036" href="#"></a></td>
<td><pre>     *          searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2037" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2038" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2039" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2040" href="#"></a></td>
<td><pre>     *         within the specified range;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2041" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2042" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2043" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2044" href="#"></a></td>
<td><pre>     *         element in the range greater than the key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2045" href="#"></a></td>
<td><pre>     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2046" href="#"></a></td>
<td><pre>     *         elements in the range are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2047" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2048" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2049" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2050" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2051" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2052" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2053" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2054" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2055" href="#"></a></td>
<td><pre>    public static int binarySearch(char[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2056" href="#"></a></td>
<td><pre>                                   char key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2057" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2058" href="#"></a></td>
<td><pre>        return binarySearch0(a, fromIndex, toIndex, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2059" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2060" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2061" href="#"></a></td>
<td><pre>    // Like public version, but without range checks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2062" href="#"></a></td>
<td><pre>    private static int binarySearch0(char[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2063" href="#"></a></td>
<td><pre>                                     char key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2064" href="#"></a></td>
<td><pre>        int low = fromIndex;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2065" href="#"></a></td>
<td><pre>        int high = toIndex - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2066" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2067" href="#"></a></td>
<td><pre>        while (low &lt;= high) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2068" href="#"></a></td>
<td><pre>            int mid = (low + high) &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2069" href="#"></a></td>
<td><pre>            char midVal = a[mid];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2070" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2071" href="#"></a></td>
<td><pre>            if (midVal &lt; key)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2072" href="#"></a></td>
<td><pre>                low = mid + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2073" href="#"></a></td>
<td><pre>            else if (midVal &gt; key)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2074" href="#"></a></td>
<td><pre>                high = mid - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2075" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2076" href="#"></a></td>
<td><pre>                return mid; // key found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2077" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2078" href="#"></a></td>
<td><pre>        return -(low + 1);  // key not found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2079" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2080" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2081" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2082" href="#"></a></td>
<td><pre>     * Searches the specified array of bytes for the specified value using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2083" href="#"></a></td>
<td><pre>     * binary search algorithm.  The array must be sorted (as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2084" href="#"></a></td>
<td><pre>     * by the {@link #sort(byte[])} method) prior to making this call.  If it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2085" href="#"></a></td>
<td><pre>     * is not sorted, the results are undefined.  If the array contains</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2086" href="#"></a></td>
<td><pre>     * multiple elements with the specified value, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2087" href="#"></a></td>
<td><pre>     * one will be found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2088" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2089" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2090" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2091" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2092" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2093" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2094" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2095" href="#"></a></td>
<td><pre>     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2096" href="#"></a></td>
<td><pre>     *         elements in the array are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2097" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2098" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2099" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2100" href="#"></a></td>
<td><pre>    public static int binarySearch(byte[] a, byte key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2101" href="#"></a></td>
<td><pre>        return binarySearch0(a, 0, a.length, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2102" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2103" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2104" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2105" href="#"></a></td>
<td><pre>     * Searches a range of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2106" href="#"></a></td>
<td><pre>     * the specified array of bytes for the specified value using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2107" href="#"></a></td>
<td><pre>     * binary search algorithm.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2108" href="#"></a></td>
<td><pre>     * The range must be sorted (as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2109" href="#"></a></td>
<td><pre>     * by the {@link #sort(byte[], int, int)} method)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2110" href="#"></a></td>
<td><pre>     * prior to making this call.  If it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2111" href="#"></a></td>
<td><pre>     * is not sorted, the results are undefined.  If the range contains</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2112" href="#"></a></td>
<td><pre>     * multiple elements with the specified value, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2113" href="#"></a></td>
<td><pre>     * one will be found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2114" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2115" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2116" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2117" href="#"></a></td>
<td><pre>     *          searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2118" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2119" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2120" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2121" href="#"></a></td>
<td><pre>     *         within the specified range;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2122" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2123" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2124" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2125" href="#"></a></td>
<td><pre>     *         element in the range greater than the key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2126" href="#"></a></td>
<td><pre>     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2127" href="#"></a></td>
<td><pre>     *         elements in the range are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2128" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2129" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2130" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2131" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2132" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2133" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2134" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2135" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2136" href="#"></a></td>
<td><pre>    public static int binarySearch(byte[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2137" href="#"></a></td>
<td><pre>                                   byte key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2138" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2139" href="#"></a></td>
<td><pre>        return binarySearch0(a, fromIndex, toIndex, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2140" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2141" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2142" href="#"></a></td>
<td><pre>    // Like public version, but without range checks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2143" href="#"></a></td>
<td><pre>    private static int binarySearch0(byte[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2144" href="#"></a></td>
<td><pre>                                     byte key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2145" href="#"></a></td>
<td><pre>        int low = fromIndex;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2146" href="#"></a></td>
<td><pre>        int high = toIndex - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2147" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2148" href="#"></a></td>
<td><pre>        while (low &lt;= high) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2149" href="#"></a></td>
<td><pre>            int mid = (low + high) &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2150" href="#"></a></td>
<td><pre>            byte midVal = a[mid];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2151" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2152" href="#"></a></td>
<td><pre>            if (midVal &lt; key)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2153" href="#"></a></td>
<td><pre>                low = mid + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2154" href="#"></a></td>
<td><pre>            else if (midVal &gt; key)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2155" href="#"></a></td>
<td><pre>                high = mid - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2156" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2157" href="#"></a></td>
<td><pre>                return mid; // key found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2158" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2159" href="#"></a></td>
<td><pre>        return -(low + 1);  // key not found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2160" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2161" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2162" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2163" href="#"></a></td>
<td><pre>     * Searches the specified array of doubles for the specified value using</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2164" href="#"></a></td>
<td><pre>     * the binary search algorithm.  The array must be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2165" href="#"></a></td>
<td><pre>     * (as by the {@link #sort(double[])} method) prior to making this call.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2166" href="#"></a></td>
<td><pre>     * If it is not sorted, the results are undefined.  If the array contains</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2167" href="#"></a></td>
<td><pre>     * multiple elements with the specified value, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2168" href="#"></a></td>
<td><pre>     * one will be found.  This method considers all NaN values to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2169" href="#"></a></td>
<td><pre>     * equivalent and equal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2170" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2171" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2172" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2173" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2174" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2175" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2176" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2177" href="#"></a></td>
<td><pre>     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2178" href="#"></a></td>
<td><pre>     *         elements in the array are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2179" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2180" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2181" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2182" href="#"></a></td>
<td><pre>    public static int binarySearch(double[] a, double key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2183" href="#"></a></td>
<td><pre>        return binarySearch0(a, 0, a.length, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2184" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2185" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2186" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2187" href="#"></a></td>
<td><pre>     * Searches a range of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2188" href="#"></a></td>
<td><pre>     * the specified array of doubles for the specified value using</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2189" href="#"></a></td>
<td><pre>     * the binary search algorithm.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2190" href="#"></a></td>
<td><pre>     * The range must be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2191" href="#"></a></td>
<td><pre>     * (as by the {@link #sort(double[], int, int)} method)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2192" href="#"></a></td>
<td><pre>     * prior to making this call.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2193" href="#"></a></td>
<td><pre>     * If it is not sorted, the results are undefined.  If the range contains</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2194" href="#"></a></td>
<td><pre>     * multiple elements with the specified value, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2195" href="#"></a></td>
<td><pre>     * one will be found.  This method considers all NaN values to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2196" href="#"></a></td>
<td><pre>     * equivalent and equal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2197" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2198" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2199" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2200" href="#"></a></td>
<td><pre>     *          searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2201" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2202" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2203" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2204" href="#"></a></td>
<td><pre>     *         within the specified range;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2205" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2206" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2207" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2208" href="#"></a></td>
<td><pre>     *         element in the range greater than the key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2209" href="#"></a></td>
<td><pre>     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2210" href="#"></a></td>
<td><pre>     *         elements in the range are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2211" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2212" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2213" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2214" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2215" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2216" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2217" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2218" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2219" href="#"></a></td>
<td><pre>    public static int binarySearch(double[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2220" href="#"></a></td>
<td><pre>                                   double key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2221" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2222" href="#"></a></td>
<td><pre>        return binarySearch0(a, fromIndex, toIndex, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2223" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2224" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2225" href="#"></a></td>
<td><pre>    // Like public version, but without range checks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2226" href="#"></a></td>
<td><pre>    private static int binarySearch0(double[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2227" href="#"></a></td>
<td><pre>                                     double key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2228" href="#"></a></td>
<td><pre>        int low = fromIndex;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2229" href="#"></a></td>
<td><pre>        int high = toIndex - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2230" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2231" href="#"></a></td>
<td><pre>        while (low &lt;= high) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2232" href="#"></a></td>
<td><pre>            int mid = (low + high) &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2233" href="#"></a></td>
<td><pre>            double midVal = a[mid];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2234" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2235" href="#"></a></td>
<td><pre>            if (midVal &lt; key)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2236" href="#"></a></td>
<td><pre>                low = mid + 1;  // Neither val is NaN, thisVal is smaller</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2237" href="#"></a></td>
<td><pre>            else if (midVal &gt; key)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2238" href="#"></a></td>
<td><pre>                high = mid - 1; // Neither val is NaN, thisVal is larger</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2239" href="#"></a></td>
<td><pre>            else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2240" href="#"></a></td>
<td><pre>                long midBits = Double.doubleToLongBits(midVal);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2241" href="#"></a></td>
<td><pre>                long keyBits = Double.doubleToLongBits(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2242" href="#"></a></td>
<td><pre>                if (midBits == keyBits)     // Values are equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2243" href="#"></a></td>
<td><pre>                    return mid;             // Key found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2244" href="#"></a></td>
<td><pre>                else if (midBits &lt; keyBits) // (-0.0, 0.0) or (!NaN, NaN)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2245" href="#"></a></td>
<td><pre>                    low = mid + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2246" href="#"></a></td>
<td><pre>                else                        // (0.0, -0.0) or (NaN, !NaN)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2247" href="#"></a></td>
<td><pre>                    high = mid - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2248" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2249" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2250" href="#"></a></td>
<td><pre>        return -(low + 1);  // key not found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2251" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2252" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2253" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2254" href="#"></a></td>
<td><pre>     * Searches the specified array of floats for the specified value using</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2255" href="#"></a></td>
<td><pre>     * the binary search algorithm. The array must be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2256" href="#"></a></td>
<td><pre>     * (as by the {@link #sort(float[])} method) prior to making this call. If</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2257" href="#"></a></td>
<td><pre>     * it is not sorted, the results are undefined. If the array contains</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2258" href="#"></a></td>
<td><pre>     * multiple elements with the specified value, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2259" href="#"></a></td>
<td><pre>     * one will be found. This method considers all NaN values to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2260" href="#"></a></td>
<td><pre>     * equivalent and equal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2261" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2262" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2263" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2264" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2265" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;. The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2266" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2267" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2268" href="#"></a></td>
<td><pre>     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2269" href="#"></a></td>
<td><pre>     *         elements in the array are less than the specified key. Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2270" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2271" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2272" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2273" href="#"></a></td>
<td><pre>    public static int binarySearch(float[] a, float key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2274" href="#"></a></td>
<td><pre>        return binarySearch0(a, 0, a.length, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2275" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2276" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2277" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2278" href="#"></a></td>
<td><pre>     * Searches a range of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2279" href="#"></a></td>
<td><pre>     * the specified array of floats for the specified value using</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2280" href="#"></a></td>
<td><pre>     * the binary search algorithm.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2281" href="#"></a></td>
<td><pre>     * The range must be sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2282" href="#"></a></td>
<td><pre>     * (as by the {@link #sort(float[], int, int)} method)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2283" href="#"></a></td>
<td><pre>     * prior to making this call. If</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2284" href="#"></a></td>
<td><pre>     * it is not sorted, the results are undefined. If the range contains</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2285" href="#"></a></td>
<td><pre>     * multiple elements with the specified value, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2286" href="#"></a></td>
<td><pre>     * one will be found. This method considers all NaN values to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2287" href="#"></a></td>
<td><pre>     * equivalent and equal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2288" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2289" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2290" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2291" href="#"></a></td>
<td><pre>     *          searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2292" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2293" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2294" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2295" href="#"></a></td>
<td><pre>     *         within the specified range;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2296" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;. The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2297" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2298" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2299" href="#"></a></td>
<td><pre>     *         element in the range greater than the key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2300" href="#"></a></td>
<td><pre>     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2301" href="#"></a></td>
<td><pre>     *         elements in the range are less than the specified key. Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2302" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2303" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2304" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2305" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2306" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2307" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2308" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2309" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2310" href="#"></a></td>
<td><pre>    public static int binarySearch(float[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2311" href="#"></a></td>
<td><pre>                                   float key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2312" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2313" href="#"></a></td>
<td><pre>        return binarySearch0(a, fromIndex, toIndex, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2314" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2315" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2316" href="#"></a></td>
<td><pre>    // Like public version, but without range checks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2317" href="#"></a></td>
<td><pre>    private static int binarySearch0(float[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2318" href="#"></a></td>
<td><pre>                                     float key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2319" href="#"></a></td>
<td><pre>        int low = fromIndex;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2320" href="#"></a></td>
<td><pre>        int high = toIndex - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2321" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2322" href="#"></a></td>
<td><pre>        while (low &lt;= high) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2323" href="#"></a></td>
<td><pre>            int mid = (low + high) &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2324" href="#"></a></td>
<td><pre>            float midVal = a[mid];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2325" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2326" href="#"></a></td>
<td><pre>            if (midVal &lt; key)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2327" href="#"></a></td>
<td><pre>                low = mid + 1;  // Neither val is NaN, thisVal is smaller</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2328" href="#"></a></td>
<td><pre>            else if (midVal &gt; key)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2329" href="#"></a></td>
<td><pre>                high = mid - 1; // Neither val is NaN, thisVal is larger</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2330" href="#"></a></td>
<td><pre>            else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2331" href="#"></a></td>
<td><pre>                int midBits = Float.floatToIntBits(midVal);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2332" href="#"></a></td>
<td><pre>                int keyBits = Float.floatToIntBits(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2333" href="#"></a></td>
<td><pre>                if (midBits == keyBits)     // Values are equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2334" href="#"></a></td>
<td><pre>                    return mid;             // Key found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2335" href="#"></a></td>
<td><pre>                else if (midBits &lt; keyBits) // (-0.0, 0.0) or (!NaN, NaN)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2336" href="#"></a></td>
<td><pre>                    low = mid + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2337" href="#"></a></td>
<td><pre>                else                        // (0.0, -0.0) or (NaN, !NaN)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2338" href="#"></a></td>
<td><pre>                    high = mid - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2339" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2340" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2341" href="#"></a></td>
<td><pre>        return -(low + 1);  // key not found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2342" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2343" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2344" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2345" href="#"></a></td>
<td><pre>     * Searches the specified array for the specified object using the binary</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2346" href="#"></a></td>
<td><pre>     * search algorithm. The array must be sorted into ascending order</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2347" href="#"></a></td>
<td><pre>     * according to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2348" href="#"></a></td>
<td><pre>     * {@linkplain Comparable natural ordering}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2349" href="#"></a></td>
<td><pre>     * of its elements (as by the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2350" href="#"></a></td>
<td><pre>     * {@link #sort(Object[])} method) prior to making this call.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2351" href="#"></a></td>
<td><pre>     * If it is not sorted, the results are undefined.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2352" href="#"></a></td>
<td><pre>     * (If the array contains elements that are not mutually comparable (for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2353" href="#"></a></td>
<td><pre>     * example, strings and integers), it &lt;i&gt;cannot&lt;/i&gt; be sorted according</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2354" href="#"></a></td>
<td><pre>     * to the natural ordering of its elements, hence results are undefined.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2355" href="#"></a></td>
<td><pre>     * If the array contains multiple</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2356" href="#"></a></td>
<td><pre>     * elements equal to the specified object, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2357" href="#"></a></td>
<td><pre>     * one will be found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2358" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2359" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2360" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2361" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2362" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2363" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2364" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2365" href="#"></a></td>
<td><pre>     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2366" href="#"></a></td>
<td><pre>     *         elements in the array are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2367" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2368" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2369" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the search key is not comparable to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2370" href="#"></a></td>
<td><pre>     *         elements of the array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2371" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2372" href="#"></a></td>
<td><pre>    public static int binarySearch(Object[] a, Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2373" href="#"></a></td>
<td><pre>        return binarySearch0(a, 0, a.length, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2374" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2375" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2376" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2377" href="#"></a></td>
<td><pre>     * Searches a range of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2378" href="#"></a></td>
<td><pre>     * the specified array for the specified object using the binary</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2379" href="#"></a></td>
<td><pre>     * search algorithm.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2380" href="#"></a></td>
<td><pre>     * The range must be sorted into ascending order</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2381" href="#"></a></td>
<td><pre>     * according to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2382" href="#"></a></td>
<td><pre>     * {@linkplain Comparable natural ordering}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2383" href="#"></a></td>
<td><pre>     * of its elements (as by the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2384" href="#"></a></td>
<td><pre>     * {@link #sort(Object[], int, int)} method) prior to making this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2385" href="#"></a></td>
<td><pre>     * call.  If it is not sorted, the results are undefined.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2386" href="#"></a></td>
<td><pre>     * (If the range contains elements that are not mutually comparable (for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2387" href="#"></a></td>
<td><pre>     * example, strings and integers), it &lt;i&gt;cannot&lt;/i&gt; be sorted according</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2388" href="#"></a></td>
<td><pre>     * to the natural ordering of its elements, hence results are undefined.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2389" href="#"></a></td>
<td><pre>     * If the range contains multiple</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2390" href="#"></a></td>
<td><pre>     * elements equal to the specified object, there is no guarantee which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2391" href="#"></a></td>
<td><pre>     * one will be found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2392" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2393" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2394" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2395" href="#"></a></td>
<td><pre>     *          searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2396" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2397" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2398" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2399" href="#"></a></td>
<td><pre>     *         within the specified range;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2400" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2401" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2402" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2403" href="#"></a></td>
<td><pre>     *         element in the range greater than the key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2404" href="#"></a></td>
<td><pre>     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2405" href="#"></a></td>
<td><pre>     *         elements in the range are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2406" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2407" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2408" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the search key is not comparable to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2409" href="#"></a></td>
<td><pre>     *         elements of the array within the specified range.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2410" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2411" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2412" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2413" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2414" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2415" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2416" href="#"></a></td>
<td><pre>    public static int binarySearch(Object[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2417" href="#"></a></td>
<td><pre>                                   Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2418" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2419" href="#"></a></td>
<td><pre>        return binarySearch0(a, fromIndex, toIndex, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2420" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2421" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2422" href="#"></a></td>
<td><pre>    // Like public version, but without range checks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2423" href="#"></a></td>
<td><pre>    private static int binarySearch0(Object[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2424" href="#"></a></td>
<td><pre>                                     Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2425" href="#"></a></td>
<td><pre>        int low = fromIndex;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2426" href="#"></a></td>
<td><pre>        int high = toIndex - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2427" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2428" href="#"></a></td>
<td><pre>        while (low &lt;= high) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2429" href="#"></a></td>
<td><pre>            int mid = (low + high) &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2430" href="#"></a></td>
<td><pre>            @SuppressWarnings(&quot;rawtypes&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2431" href="#"></a></td>
<td><pre>            Comparable midVal = (Comparable)a[mid];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2432" href="#"></a></td>
<td><pre>            @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2433" href="#"></a></td>
<td><pre>            int cmp = midVal.compareTo(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2434" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2435" href="#"></a></td>
<td><pre>            if (cmp &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2436" href="#"></a></td>
<td><pre>                low = mid + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2437" href="#"></a></td>
<td><pre>            else if (cmp &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2438" href="#"></a></td>
<td><pre>                high = mid - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2439" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2440" href="#"></a></td>
<td><pre>                return mid; // key found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2441" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2442" href="#"></a></td>
<td><pre>        return -(low + 1);  // key not found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2443" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2444" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2445" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2446" href="#"></a></td>
<td><pre>     * Searches the specified array for the specified object using the binary</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2447" href="#"></a></td>
<td><pre>     * search algorithm.  The array must be sorted into ascending order</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2448" href="#"></a></td>
<td><pre>     * according to the specified comparator (as by the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2449" href="#"></a></td>
<td><pre>     * {@link #sort(Object[], Comparator) sort(T[], Comparator)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2450" href="#"></a></td>
<td><pre>     * method) prior to making this call.  If it is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2451" href="#"></a></td>
<td><pre>     * not sorted, the results are undefined.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2452" href="#"></a></td>
<td><pre>     * If the array contains multiple</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2453" href="#"></a></td>
<td><pre>     * elements equal to the specified object, there is no guarantee which one</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2454" href="#"></a></td>
<td><pre>     * will be found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2455" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2456" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the class of the objects in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2457" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2458" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2459" href="#"></a></td>
<td><pre>     * @param c the comparator by which the array is ordered.  A</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2460" href="#"></a></td>
<td><pre>     *        &lt;tt&gt;null&lt;/tt&gt; value indicates that the elements'</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2461" href="#"></a></td>
<td><pre>     *        {@linkplain Comparable natural ordering} should be used.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2462" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2463" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2464" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2465" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2466" href="#"></a></td>
<td><pre>     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2467" href="#"></a></td>
<td><pre>     *         elements in the array are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2468" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2469" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2470" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the array contains elements that are not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2471" href="#"></a></td>
<td><pre>     *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2472" href="#"></a></td>
<td><pre>     *         or the search key is not comparable to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2473" href="#"></a></td>
<td><pre>     *         elements of the array using this comparator.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2474" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2475" href="#"></a></td>
<td><pre>    public static &lt;T&gt; int binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2476" href="#"></a></td>
<td><pre>        return binarySearch0(a, 0, a.length, key, c);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2477" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2478" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2479" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2480" href="#"></a></td>
<td><pre>     * Searches a range of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2481" href="#"></a></td>
<td><pre>     * the specified array for the specified object using the binary</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2482" href="#"></a></td>
<td><pre>     * search algorithm.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2483" href="#"></a></td>
<td><pre>     * The range must be sorted into ascending order</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2484" href="#"></a></td>
<td><pre>     * according to the specified comparator (as by the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2485" href="#"></a></td>
<td><pre>     * {@link #sort(Object[], int, int, Comparator)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2486" href="#"></a></td>
<td><pre>     * sort(T[], int, int, Comparator)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2487" href="#"></a></td>
<td><pre>     * method) prior to making this call.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2488" href="#"></a></td>
<td><pre>     * If it is not sorted, the results are undefined.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2489" href="#"></a></td>
<td><pre>     * If the range contains multiple elements equal to the specified object,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2490" href="#"></a></td>
<td><pre>     * there is no guarantee which one will be found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2491" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2492" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the class of the objects in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2493" href="#"></a></td>
<td><pre>     * @param a the array to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2494" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2495" href="#"></a></td>
<td><pre>     *          searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2496" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be searched</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2497" href="#"></a></td>
<td><pre>     * @param key the value to be searched for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2498" href="#"></a></td>
<td><pre>     * @param c the comparator by which the array is ordered.  A</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2499" href="#"></a></td>
<td><pre>     *        &lt;tt&gt;null&lt;/tt&gt; value indicates that the elements'</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2500" href="#"></a></td>
<td><pre>     *        {@linkplain Comparable natural ordering} should be used.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2501" href="#"></a></td>
<td><pre>     * @return index of the search key, if it is contained in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2502" href="#"></a></td>
<td><pre>     *         within the specified range;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2503" href="#"></a></td>
<td><pre>     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2504" href="#"></a></td>
<td><pre>     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2505" href="#"></a></td>
<td><pre>     *         key would be inserted into the array: the index of the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2506" href="#"></a></td>
<td><pre>     *         element in the range greater than the key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2507" href="#"></a></td>
<td><pre>     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2508" href="#"></a></td>
<td><pre>     *         elements in the range are less than the specified key.  Note</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2509" href="#"></a></td>
<td><pre>     *         that this guarantees that the return value will be &amp;gt;= 0 if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2510" href="#"></a></td>
<td><pre>     *         and only if the key is found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2511" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the range contains elements that are not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2512" href="#"></a></td>
<td><pre>     *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2513" href="#"></a></td>
<td><pre>     *         or the search key is not comparable to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2514" href="#"></a></td>
<td><pre>     *         elements in the range using this comparator.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2515" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2516" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &gt; toIndex}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2517" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2518" href="#"></a></td>
<td><pre>     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2519" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2520" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2521" href="#"></a></td>
<td><pre>    public static &lt;T&gt; int binarySearch(T[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2522" href="#"></a></td>
<td><pre>                                       T key, Comparator&lt;? super T&gt; c) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2523" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2524" href="#"></a></td>
<td><pre>        return binarySearch0(a, fromIndex, toIndex, key, c);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2525" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2526" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2527" href="#"></a></td>
<td><pre>    // Like public version, but without range checks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2528" href="#"></a></td>
<td><pre>    private static &lt;T&gt; int binarySearch0(T[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2529" href="#"></a></td>
<td><pre>                                         T key, Comparator&lt;? super T&gt; c) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2530" href="#"></a></td>
<td><pre>        if (c == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2531" href="#"></a></td>
<td><pre>            return binarySearch0(a, fromIndex, toIndex, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2532" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2533" href="#"></a></td>
<td><pre>        int low = fromIndex;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2534" href="#"></a></td>
<td><pre>        int high = toIndex - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2535" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2536" href="#"></a></td>
<td><pre>        while (low &lt;= high) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2537" href="#"></a></td>
<td><pre>            int mid = (low + high) &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2538" href="#"></a></td>
<td><pre>            T midVal = a[mid];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2539" href="#"></a></td>
<td><pre>            int cmp = c.compare(midVal, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2540" href="#"></a></td>
<td><pre>            if (cmp &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2541" href="#"></a></td>
<td><pre>                low = mid + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2542" href="#"></a></td>
<td><pre>            else if (cmp &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2543" href="#"></a></td>
<td><pre>                high = mid - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2544" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2545" href="#"></a></td>
<td><pre>                return mid; // key found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2546" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2547" href="#"></a></td>
<td><pre>        return -(low + 1);  // key not found.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2548" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2549" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2550" href="#"></a></td>
<td><pre>    // Equality Testing</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2551" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2552" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2553" href="#"></a></td>
<td><pre>     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of longs are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2554" href="#"></a></td>
<td><pre>     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2555" href="#"></a></td>
<td><pre>     * arrays contain the same number of elements, and all corresponding pairs</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2556" href="#"></a></td>
<td><pre>     * of elements in the two arrays are equal.  In other words, two arrays</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2557" href="#"></a></td>
<td><pre>     * are equal if they contain the same elements in the same order.  Also,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2558" href="#"></a></td>
<td><pre>     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2559" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2560" href="#"></a></td>
<td><pre>     * @param a one array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2561" href="#"></a></td>
<td><pre>     * @param a2 the other array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2562" href="#"></a></td>
<td><pre>     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2563" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2564" href="#"></a></td>
<td><pre>    public static boolean equals(long[] a, long[] a2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2565" href="#"></a></td>
<td><pre>        if (a==a2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2566" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2567" href="#"></a></td>
<td><pre>        if (a==null || a2==null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2568" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2569" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2570" href="#"></a></td>
<td><pre>        int length = a.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2571" href="#"></a></td>
<td><pre>        if (a2.length != length)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2572" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2573" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2574" href="#"></a></td>
<td><pre>        for (int i=0; i&lt;length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2575" href="#"></a></td>
<td><pre>            if (a[i] != a2[i])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2576" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2577" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2578" href="#"></a></td>
<td><pre>        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2579" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2580" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2581" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2582" href="#"></a></td>
<td><pre>     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of ints are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2583" href="#"></a></td>
<td><pre>     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2584" href="#"></a></td>
<td><pre>     * arrays contain the same number of elements, and all corresponding pairs</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2585" href="#"></a></td>
<td><pre>     * of elements in the two arrays are equal.  In other words, two arrays</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2586" href="#"></a></td>
<td><pre>     * are equal if they contain the same elements in the same order.  Also,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2587" href="#"></a></td>
<td><pre>     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2588" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2589" href="#"></a></td>
<td><pre>     * @param a one array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2590" href="#"></a></td>
<td><pre>     * @param a2 the other array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2591" href="#"></a></td>
<td><pre>     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2592" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2593" href="#"></a></td>
<td><pre>    public static boolean equals(int[] a, int[] a2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2594" href="#"></a></td>
<td><pre>        if (a==a2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2595" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2596" href="#"></a></td>
<td><pre>        if (a==null || a2==null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2597" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2598" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2599" href="#"></a></td>
<td><pre>        int length = a.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2600" href="#"></a></td>
<td><pre>        if (a2.length != length)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2601" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2602" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2603" href="#"></a></td>
<td><pre>        for (int i=0; i&lt;length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2604" href="#"></a></td>
<td><pre>            if (a[i] != a2[i])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2605" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2606" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2607" href="#"></a></td>
<td><pre>        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2608" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2609" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2610" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2611" href="#"></a></td>
<td><pre>     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of shorts are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2612" href="#"></a></td>
<td><pre>     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2613" href="#"></a></td>
<td><pre>     * arrays contain the same number of elements, and all corresponding pairs</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2614" href="#"></a></td>
<td><pre>     * of elements in the two arrays are equal.  In other words, two arrays</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2615" href="#"></a></td>
<td><pre>     * are equal if they contain the same elements in the same order.  Also,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2616" href="#"></a></td>
<td><pre>     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2617" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2618" href="#"></a></td>
<td><pre>     * @param a one array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2619" href="#"></a></td>
<td><pre>     * @param a2 the other array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2620" href="#"></a></td>
<td><pre>     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2621" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2622" href="#"></a></td>
<td><pre>    public static boolean equals(short[] a, short a2[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2623" href="#"></a></td>
<td><pre>        if (a==a2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2624" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2625" href="#"></a></td>
<td><pre>        if (a==null || a2==null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2626" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2627" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2628" href="#"></a></td>
<td><pre>        int length = a.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2629" href="#"></a></td>
<td><pre>        if (a2.length != length)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2630" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2631" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2632" href="#"></a></td>
<td><pre>        for (int i=0; i&lt;length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2633" href="#"></a></td>
<td><pre>            if (a[i] != a2[i])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2634" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2635" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2636" href="#"></a></td>
<td><pre>        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2637" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2638" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2639" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2640" href="#"></a></td>
<td><pre>     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of chars are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2641" href="#"></a></td>
<td><pre>     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2642" href="#"></a></td>
<td><pre>     * arrays contain the same number of elements, and all corresponding pairs</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2643" href="#"></a></td>
<td><pre>     * of elements in the two arrays are equal.  In other words, two arrays</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2644" href="#"></a></td>
<td><pre>     * are equal if they contain the same elements in the same order.  Also,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2645" href="#"></a></td>
<td><pre>     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2646" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2647" href="#"></a></td>
<td><pre>     * @param a one array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2648" href="#"></a></td>
<td><pre>     * @param a2 the other array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2649" href="#"></a></td>
<td><pre>     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2650" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2651" href="#"></a></td>
<td><pre>    public static boolean equals(char[] a, char[] a2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2652" href="#"></a></td>
<td><pre>        if (a==a2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2653" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2654" href="#"></a></td>
<td><pre>        if (a==null || a2==null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2655" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2656" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2657" href="#"></a></td>
<td><pre>        int length = a.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2658" href="#"></a></td>
<td><pre>        if (a2.length != length)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2659" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2660" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2661" href="#"></a></td>
<td><pre>        for (int i=0; i&lt;length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2662" href="#"></a></td>
<td><pre>            if (a[i] != a2[i])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2663" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2664" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2665" href="#"></a></td>
<td><pre>        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2666" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2667" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2668" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2669" href="#"></a></td>
<td><pre>     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of bytes are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2670" href="#"></a></td>
<td><pre>     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2671" href="#"></a></td>
<td><pre>     * arrays contain the same number of elements, and all corresponding pairs</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2672" href="#"></a></td>
<td><pre>     * of elements in the two arrays are equal.  In other words, two arrays</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2673" href="#"></a></td>
<td><pre>     * are equal if they contain the same elements in the same order.  Also,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2674" href="#"></a></td>
<td><pre>     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2675" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2676" href="#"></a></td>
<td><pre>     * @param a one array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2677" href="#"></a></td>
<td><pre>     * @param a2 the other array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2678" href="#"></a></td>
<td><pre>     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2679" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2680" href="#"></a></td>
<td><pre>    public static boolean equals(byte[] a, byte[] a2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2681" href="#"></a></td>
<td><pre>        if (a==a2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2682" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2683" href="#"></a></td>
<td><pre>        if (a==null || a2==null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2684" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2685" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2686" href="#"></a></td>
<td><pre>        int length = a.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2687" href="#"></a></td>
<td><pre>        if (a2.length != length)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2688" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2689" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2690" href="#"></a></td>
<td><pre>        for (int i=0; i&lt;length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2691" href="#"></a></td>
<td><pre>            if (a[i] != a2[i])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2692" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2693" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2694" href="#"></a></td>
<td><pre>        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2695" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2696" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2697" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2698" href="#"></a></td>
<td><pre>     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of booleans are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2699" href="#"></a></td>
<td><pre>     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2700" href="#"></a></td>
<td><pre>     * arrays contain the same number of elements, and all corresponding pairs</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2701" href="#"></a></td>
<td><pre>     * of elements in the two arrays are equal.  In other words, two arrays</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2702" href="#"></a></td>
<td><pre>     * are equal if they contain the same elements in the same order.  Also,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2703" href="#"></a></td>
<td><pre>     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2704" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2705" href="#"></a></td>
<td><pre>     * @param a one array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2706" href="#"></a></td>
<td><pre>     * @param a2 the other array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2707" href="#"></a></td>
<td><pre>     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2708" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2709" href="#"></a></td>
<td><pre>    public static boolean equals(boolean[] a, boolean[] a2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2710" href="#"></a></td>
<td><pre>        if (a==a2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2711" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2712" href="#"></a></td>
<td><pre>        if (a==null || a2==null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2713" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2714" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2715" href="#"></a></td>
<td><pre>        int length = a.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2716" href="#"></a></td>
<td><pre>        if (a2.length != length)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2717" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2718" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2719" href="#"></a></td>
<td><pre>        for (int i=0; i&lt;length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2720" href="#"></a></td>
<td><pre>            if (a[i] != a2[i])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2721" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2722" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2723" href="#"></a></td>
<td><pre>        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2724" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2725" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2726" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2727" href="#"></a></td>
<td><pre>     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of doubles are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2728" href="#"></a></td>
<td><pre>     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2729" href="#"></a></td>
<td><pre>     * arrays contain the same number of elements, and all corresponding pairs</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2730" href="#"></a></td>
<td><pre>     * of elements in the two arrays are equal.  In other words, two arrays</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2731" href="#"></a></td>
<td><pre>     * are equal if they contain the same elements in the same order.  Also,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2732" href="#"></a></td>
<td><pre>     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2733" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2734" href="#"></a></td>
<td><pre>     * Two doubles &lt;tt&gt;d1&lt;/tt&gt; and &lt;tt&gt;d2&lt;/tt&gt; are considered equal if:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2735" href="#"></a></td>
<td><pre>     * &lt;pre&gt;    &lt;tt&gt;new Double(d1).equals(new Double(d2))&lt;/tt&gt;&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2736" href="#"></a></td>
<td><pre>     * (Unlike the &lt;tt&gt;==&lt;/tt&gt; operator, this method considers</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2737" href="#"></a></td>
<td><pre>     * &lt;tt&gt;NaN&lt;/tt&gt; equals to itself, and 0.0d unequal to -0.0d.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2738" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2739" href="#"></a></td>
<td><pre>     * @param a one array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2740" href="#"></a></td>
<td><pre>     * @param a2 the other array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2741" href="#"></a></td>
<td><pre>     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2742" href="#"></a></td>
<td><pre>     * @see Double#equals(Object)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2743" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2744" href="#"></a></td>
<td><pre>    public static boolean equals(double[] a, double[] a2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2745" href="#"></a></td>
<td><pre>        if (a==a2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2746" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2747" href="#"></a></td>
<td><pre>        if (a==null || a2==null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2748" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2749" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2750" href="#"></a></td>
<td><pre>        int length = a.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2751" href="#"></a></td>
<td><pre>        if (a2.length != length)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2752" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2753" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2754" href="#"></a></td>
<td><pre>        for (int i=0; i&lt;length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2755" href="#"></a></td>
<td><pre>            if (Double.doubleToLongBits(a[i])!=Double.doubleToLongBits(a2[i]))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2756" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2757" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2758" href="#"></a></td>
<td><pre>        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2759" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2760" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2761" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2762" href="#"></a></td>
<td><pre>     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of floats are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2763" href="#"></a></td>
<td><pre>     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2764" href="#"></a></td>
<td><pre>     * arrays contain the same number of elements, and all corresponding pairs</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2765" href="#"></a></td>
<td><pre>     * of elements in the two arrays are equal.  In other words, two arrays</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2766" href="#"></a></td>
<td><pre>     * are equal if they contain the same elements in the same order.  Also,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2767" href="#"></a></td>
<td><pre>     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2768" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2769" href="#"></a></td>
<td><pre>     * Two floats &lt;tt&gt;f1&lt;/tt&gt; and &lt;tt&gt;f2&lt;/tt&gt; are considered equal if:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2770" href="#"></a></td>
<td><pre>     * &lt;pre&gt;    &lt;tt&gt;new Float(f1).equals(new Float(f2))&lt;/tt&gt;&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2771" href="#"></a></td>
<td><pre>     * (Unlike the &lt;tt&gt;==&lt;/tt&gt; operator, this method considers</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2772" href="#"></a></td>
<td><pre>     * &lt;tt&gt;NaN&lt;/tt&gt; equals to itself, and 0.0f unequal to -0.0f.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2773" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2774" href="#"></a></td>
<td><pre>     * @param a one array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2775" href="#"></a></td>
<td><pre>     * @param a2 the other array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2776" href="#"></a></td>
<td><pre>     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2777" href="#"></a></td>
<td><pre>     * @see Float#equals(Object)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2778" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2779" href="#"></a></td>
<td><pre>    public static boolean equals(float[] a, float[] a2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2780" href="#"></a></td>
<td><pre>        if (a==a2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2781" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2782" href="#"></a></td>
<td><pre>        if (a==null || a2==null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2783" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2784" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2785" href="#"></a></td>
<td><pre>        int length = a.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2786" href="#"></a></td>
<td><pre>        if (a2.length != length)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2787" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2788" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2789" href="#"></a></td>
<td><pre>        for (int i=0; i&lt;length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2790" href="#"></a></td>
<td><pre>            if (Float.floatToIntBits(a[i])!=Float.floatToIntBits(a2[i]))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2791" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2792" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2793" href="#"></a></td>
<td><pre>        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2794" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2795" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2796" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2797" href="#"></a></td>
<td><pre>     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of Objects are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2798" href="#"></a></td>
<td><pre>     * &lt;i&gt;equal&lt;/i&gt; to one another.  The two arrays are considered equal if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2799" href="#"></a></td>
<td><pre>     * both arrays contain the same number of elements, and all corresponding</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2800" href="#"></a></td>
<td><pre>     * pairs of elements in the two arrays are equal.  Two objects &lt;tt&gt;e1&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2801" href="#"></a></td>
<td><pre>     * and &lt;tt&gt;e2&lt;/tt&gt; are considered &lt;i&gt;equal&lt;/i&gt; if &lt;tt&gt;(e1==null ? e2==null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2802" href="#"></a></td>
<td><pre>     * : e1.equals(e2))&lt;/tt&gt;.  In other words, the two arrays are equal if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2803" href="#"></a></td>
<td><pre>     * they contain the same elements in the same order.  Also, two array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2804" href="#"></a></td>
<td><pre>     * references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2805" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2806" href="#"></a></td>
<td><pre>     * @param a one array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2807" href="#"></a></td>
<td><pre>     * @param a2 the other array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2808" href="#"></a></td>
<td><pre>     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2809" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2810" href="#"></a></td>
<td><pre>    public static boolean equals(Object[] a, Object[] a2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2811" href="#"></a></td>
<td><pre>        if (a==a2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2812" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2813" href="#"></a></td>
<td><pre>        if (a==null || a2==null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2814" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2815" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2816" href="#"></a></td>
<td><pre>        int length = a.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2817" href="#"></a></td>
<td><pre>        if (a2.length != length)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2818" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2819" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2820" href="#"></a></td>
<td><pre>        for (int i=0; i&lt;length; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2821" href="#"></a></td>
<td><pre>            Object o1 = a[i];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2822" href="#"></a></td>
<td><pre>            Object o2 = a2[i];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2823" href="#"></a></td>
<td><pre>            if (!(o1==null ? o2==null : o1.equals(o2)))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2824" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2825" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2826" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2827" href="#"></a></td>
<td><pre>        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2828" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2829" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2830" href="#"></a></td>
<td><pre>    // Filling</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2831" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2832" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2833" href="#"></a></td>
<td><pre>     * Assigns the specified long value to each element of the specified array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2834" href="#"></a></td>
<td><pre>     * of longs.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2835" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2836" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2837" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2838" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2839" href="#"></a></td>
<td><pre>    public static void fill(long[] a, long val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2840" href="#"></a></td>
<td><pre>        for (int i = 0, len = a.length; i &lt; len; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2841" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2842" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2843" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2844" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2845" href="#"></a></td>
<td><pre>     * Assigns the specified long value to each element of the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2846" href="#"></a></td>
<td><pre>     * range of the specified array of longs.  The range to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2847" href="#"></a></td>
<td><pre>     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2848" href="#"></a></td>
<td><pre>     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2849" href="#"></a></td>
<td><pre>     * range to be filled is empty.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2850" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2851" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2852" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2853" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2854" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2855" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2856" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2857" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2858" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2859" href="#"></a></td>
<td><pre>     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2860" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2861" href="#"></a></td>
<td><pre>    public static void fill(long[] a, int fromIndex, int toIndex, long val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2862" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2863" href="#"></a></td>
<td><pre>        for (int i = fromIndex; i &lt; toIndex; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2864" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2865" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2866" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2867" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2868" href="#"></a></td>
<td><pre>     * Assigns the specified int value to each element of the specified array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2869" href="#"></a></td>
<td><pre>     * of ints.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2870" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2871" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2872" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2873" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2874" href="#"></a></td>
<td><pre>    public static void fill(int[] a, int val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2875" href="#"></a></td>
<td><pre>        for (int i = 0, len = a.length; i &lt; len; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2876" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2877" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2878" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2879" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2880" href="#"></a></td>
<td><pre>     * Assigns the specified int value to each element of the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2881" href="#"></a></td>
<td><pre>     * range of the specified array of ints.  The range to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2882" href="#"></a></td>
<td><pre>     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2883" href="#"></a></td>
<td><pre>     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2884" href="#"></a></td>
<td><pre>     * range to be filled is empty.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2885" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2886" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2887" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2888" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2889" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2890" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2891" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2892" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2893" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2894" href="#"></a></td>
<td><pre>     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2895" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2896" href="#"></a></td>
<td><pre>    public static void fill(int[] a, int fromIndex, int toIndex, int val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2897" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2898" href="#"></a></td>
<td><pre>        for (int i = fromIndex; i &lt; toIndex; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2899" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2900" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2901" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2902" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2903" href="#"></a></td>
<td><pre>     * Assigns the specified short value to each element of the specified array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2904" href="#"></a></td>
<td><pre>     * of shorts.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2905" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2906" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2907" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2908" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2909" href="#"></a></td>
<td><pre>    public static void fill(short[] a, short val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2910" href="#"></a></td>
<td><pre>        for (int i = 0, len = a.length; i &lt; len; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2911" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2912" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2913" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2914" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2915" href="#"></a></td>
<td><pre>     * Assigns the specified short value to each element of the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2916" href="#"></a></td>
<td><pre>     * range of the specified array of shorts.  The range to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2917" href="#"></a></td>
<td><pre>     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2918" href="#"></a></td>
<td><pre>     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2919" href="#"></a></td>
<td><pre>     * range to be filled is empty.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2920" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2921" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2922" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2923" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2924" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2925" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2926" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2927" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2928" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2929" href="#"></a></td>
<td><pre>     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2930" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2931" href="#"></a></td>
<td><pre>    public static void fill(short[] a, int fromIndex, int toIndex, short val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2932" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2933" href="#"></a></td>
<td><pre>        for (int i = fromIndex; i &lt; toIndex; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2934" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2935" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2936" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2937" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2938" href="#"></a></td>
<td><pre>     * Assigns the specified char value to each element of the specified array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2939" href="#"></a></td>
<td><pre>     * of chars.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2940" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2941" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2942" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2943" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2944" href="#"></a></td>
<td><pre>    public static void fill(char[] a, char val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2945" href="#"></a></td>
<td><pre>        for (int i = 0, len = a.length; i &lt; len; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2946" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2947" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2948" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2949" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2950" href="#"></a></td>
<td><pre>     * Assigns the specified char value to each element of the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2951" href="#"></a></td>
<td><pre>     * range of the specified array of chars.  The range to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2952" href="#"></a></td>
<td><pre>     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2953" href="#"></a></td>
<td><pre>     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2954" href="#"></a></td>
<td><pre>     * range to be filled is empty.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2955" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2956" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2957" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2958" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2959" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2960" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2961" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2962" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2963" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2964" href="#"></a></td>
<td><pre>     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2965" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2966" href="#"></a></td>
<td><pre>    public static void fill(char[] a, int fromIndex, int toIndex, char val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2967" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2968" href="#"></a></td>
<td><pre>        for (int i = fromIndex; i &lt; toIndex; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2969" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2970" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2971" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2972" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2973" href="#"></a></td>
<td><pre>     * Assigns the specified byte value to each element of the specified array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2974" href="#"></a></td>
<td><pre>     * of bytes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2975" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2976" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2977" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2978" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2979" href="#"></a></td>
<td><pre>    public static void fill(byte[] a, byte val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2980" href="#"></a></td>
<td><pre>        for (int i = 0, len = a.length; i &lt; len; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2981" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2982" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2983" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2984" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2985" href="#"></a></td>
<td><pre>     * Assigns the specified byte value to each element of the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2986" href="#"></a></td>
<td><pre>     * range of the specified array of bytes.  The range to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2987" href="#"></a></td>
<td><pre>     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2988" href="#"></a></td>
<td><pre>     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2989" href="#"></a></td>
<td><pre>     * range to be filled is empty.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2990" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2991" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2992" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2993" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2994" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2995" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2996" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2997" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2998" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2999" href="#"></a></td>
<td><pre>     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3000" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3001" href="#"></a></td>
<td><pre>    public static void fill(byte[] a, int fromIndex, int toIndex, byte val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3002" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3003" href="#"></a></td>
<td><pre>        for (int i = fromIndex; i &lt; toIndex; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3004" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3005" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3006" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3007" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3008" href="#"></a></td>
<td><pre>     * Assigns the specified boolean value to each element of the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3009" href="#"></a></td>
<td><pre>     * array of booleans.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3010" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3011" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3012" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3013" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3014" href="#"></a></td>
<td><pre>    public static void fill(boolean[] a, boolean val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3015" href="#"></a></td>
<td><pre>        for (int i = 0, len = a.length; i &lt; len; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3016" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3017" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3018" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3019" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3020" href="#"></a></td>
<td><pre>     * Assigns the specified boolean value to each element of the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3021" href="#"></a></td>
<td><pre>     * range of the specified array of booleans.  The range to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3022" href="#"></a></td>
<td><pre>     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3023" href="#"></a></td>
<td><pre>     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3024" href="#"></a></td>
<td><pre>     * range to be filled is empty.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3025" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3026" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3027" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3028" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3029" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3030" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3031" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3032" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3033" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3034" href="#"></a></td>
<td><pre>     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3035" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3036" href="#"></a></td>
<td><pre>    public static void fill(boolean[] a, int fromIndex, int toIndex,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3037" href="#"></a></td>
<td><pre>                            boolean val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3038" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3039" href="#"></a></td>
<td><pre>        for (int i = fromIndex; i &lt; toIndex; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3040" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3041" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3042" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3043" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3044" href="#"></a></td>
<td><pre>     * Assigns the specified double value to each element of the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3045" href="#"></a></td>
<td><pre>     * array of doubles.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3046" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3047" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3048" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3049" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3050" href="#"></a></td>
<td><pre>    public static void fill(double[] a, double val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3051" href="#"></a></td>
<td><pre>        for (int i = 0, len = a.length; i &lt; len; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3052" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3053" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3054" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3055" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3056" href="#"></a></td>
<td><pre>     * Assigns the specified double value to each element of the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3057" href="#"></a></td>
<td><pre>     * range of the specified array of doubles.  The range to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3058" href="#"></a></td>
<td><pre>     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3059" href="#"></a></td>
<td><pre>     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3060" href="#"></a></td>
<td><pre>     * range to be filled is empty.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3061" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3062" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3063" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3064" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3065" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3066" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3067" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3068" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3069" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3070" href="#"></a></td>
<td><pre>     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3071" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3072" href="#"></a></td>
<td><pre>    public static void fill(double[] a, int fromIndex, int toIndex,double val){</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3073" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3074" href="#"></a></td>
<td><pre>        for (int i = fromIndex; i &lt; toIndex; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3075" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3076" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3077" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3078" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3079" href="#"></a></td>
<td><pre>     * Assigns the specified float value to each element of the specified array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3080" href="#"></a></td>
<td><pre>     * of floats.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3081" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3082" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3083" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3084" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3085" href="#"></a></td>
<td><pre>    public static void fill(float[] a, float val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3086" href="#"></a></td>
<td><pre>        for (int i = 0, len = a.length; i &lt; len; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3087" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3088" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3089" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3090" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3091" href="#"></a></td>
<td><pre>     * Assigns the specified float value to each element of the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3092" href="#"></a></td>
<td><pre>     * range of the specified array of floats.  The range to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3093" href="#"></a></td>
<td><pre>     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3094" href="#"></a></td>
<td><pre>     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3095" href="#"></a></td>
<td><pre>     * range to be filled is empty.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3096" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3097" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3098" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3099" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3100" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3101" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3102" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3103" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3104" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3105" href="#"></a></td>
<td><pre>     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3106" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3107" href="#"></a></td>
<td><pre>    public static void fill(float[] a, int fromIndex, int toIndex, float val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3108" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3109" href="#"></a></td>
<td><pre>        for (int i = fromIndex; i &lt; toIndex; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3110" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3111" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3112" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3113" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3114" href="#"></a></td>
<td><pre>     * Assigns the specified Object reference to each element of the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3115" href="#"></a></td>
<td><pre>     * array of Objects.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3116" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3117" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3118" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3119" href="#"></a></td>
<td><pre>     * @throws ArrayStoreException if the specified value is not of a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3120" href="#"></a></td>
<td><pre>     *         runtime type that can be stored in the specified array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3121" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3122" href="#"></a></td>
<td><pre>    public static void fill(Object[] a, Object val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3123" href="#"></a></td>
<td><pre>        for (int i = 0, len = a.length; i &lt; len; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3124" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3125" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3126" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3127" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3128" href="#"></a></td>
<td><pre>     * Assigns the specified Object reference to each element of the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3129" href="#"></a></td>
<td><pre>     * range of the specified array of Objects.  The range to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3130" href="#"></a></td>
<td><pre>     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3131" href="#"></a></td>
<td><pre>     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3132" href="#"></a></td>
<td><pre>     * range to be filled is empty.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3133" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3134" href="#"></a></td>
<td><pre>     * @param a the array to be filled</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3135" href="#"></a></td>
<td><pre>     * @param fromIndex the index of the first element (inclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3136" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3137" href="#"></a></td>
<td><pre>     * @param toIndex the index of the last element (exclusive) to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3138" href="#"></a></td>
<td><pre>     *        filled with the specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3139" href="#"></a></td>
<td><pre>     * @param val the value to be stored in all elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3140" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3141" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3142" href="#"></a></td>
<td><pre>     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3143" href="#"></a></td>
<td><pre>     * @throws ArrayStoreException if the specified value is not of a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3144" href="#"></a></td>
<td><pre>     *         runtime type that can be stored in the specified array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3145" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3146" href="#"></a></td>
<td><pre>    public static void fill(Object[] a, int fromIndex, int toIndex, Object val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3147" href="#"></a></td>
<td><pre>        rangeCheck(a.length, fromIndex, toIndex);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3148" href="#"></a></td>
<td><pre>        for (int i = fromIndex; i &lt; toIndex; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3149" href="#"></a></td>
<td><pre>            a[i] = val;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3150" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3151" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3152" href="#"></a></td>
<td><pre>    // Cloning</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3153" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3154" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3155" href="#"></a></td>
<td><pre>     * Copies the specified array, truncating or padding with nulls (if necessary)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3156" href="#"></a></td>
<td><pre>     * so the copy has the specified length.  For all indices that are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3157" href="#"></a></td>
<td><pre>     * valid in both the original array and the copy, the two arrays will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3158" href="#"></a></td>
<td><pre>     * contain identical values.  For any indices that are valid in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3159" href="#"></a></td>
<td><pre>     * copy but not the original, the copy will contain &lt;tt&gt;null&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3160" href="#"></a></td>
<td><pre>     * Such indices will exist if and only if the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3161" href="#"></a></td>
<td><pre>     * is greater than that of the original array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3162" href="#"></a></td>
<td><pre>     * The resulting array is of exactly the same class as the original array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3163" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3164" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the class of the objects in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3165" href="#"></a></td>
<td><pre>     * @param original the array to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3166" href="#"></a></td>
<td><pre>     * @param newLength the length of the copy to be returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3167" href="#"></a></td>
<td><pre>     * @return a copy of the original array, truncated or padded with nulls</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3168" href="#"></a></td>
<td><pre>     *     to obtain the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3169" href="#"></a></td>
<td><pre>     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3170" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3171" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3172" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3173" href="#"></a></td>
<td><pre>    @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3174" href="#"></a></td>
<td><pre>    public static &lt;T&gt; T[] copyOf(T[] original, int newLength) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3175" href="#"></a></td>
<td><pre>        return (T[]) copyOf(original, newLength, original.getClass());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3176" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3177" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3178" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3179" href="#"></a></td>
<td><pre>     * Copies the specified array, truncating or padding with nulls (if necessary)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3180" href="#"></a></td>
<td><pre>     * so the copy has the specified length.  For all indices that are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3181" href="#"></a></td>
<td><pre>     * valid in both the original array and the copy, the two arrays will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3182" href="#"></a></td>
<td><pre>     * contain identical values.  For any indices that are valid in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3183" href="#"></a></td>
<td><pre>     * copy but not the original, the copy will contain &lt;tt&gt;null&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3184" href="#"></a></td>
<td><pre>     * Such indices will exist if and only if the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3185" href="#"></a></td>
<td><pre>     * is greater than that of the original array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3186" href="#"></a></td>
<td><pre>     * The resulting array is of the class &lt;tt&gt;newType&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3187" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3188" href="#"></a></td>
<td><pre>     * @param &lt;U&gt; the class of the objects in the original array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3189" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the class of the objects in the returned array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3190" href="#"></a></td>
<td><pre>     * @param original the array to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3191" href="#"></a></td>
<td><pre>     * @param newLength the length of the copy to be returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3192" href="#"></a></td>
<td><pre>     * @param newType the class of the copy to be returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3193" href="#"></a></td>
<td><pre>     * @return a copy of the original array, truncated or padded with nulls</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3194" href="#"></a></td>
<td><pre>     *     to obtain the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3195" href="#"></a></td>
<td><pre>     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3196" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3197" href="#"></a></td>
<td><pre>     * @throws ArrayStoreException if an element copied from</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3198" href="#"></a></td>
<td><pre>     *     &lt;tt&gt;original&lt;/tt&gt; is not of a runtime type that can be stored in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3199" href="#"></a></td>
<td><pre>     *     an array of class &lt;tt&gt;newType&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3200" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3201" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3202" href="#"></a></td>
<td><pre>    public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3203" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3204" href="#"></a></td>
<td><pre>        T[] copy = ((Object)newType == (Object)Object[].class)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3205" href="#"></a></td>
<td><pre>            ? (T[]) new Object[newLength]</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3206" href="#"></a></td>
<td><pre>            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3207" href="#"></a></td>
<td><pre>        System.arraycopy(original, 0, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3208" href="#"></a></td>
<td><pre>                         Math.min(original.length, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3209" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3210" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3211" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3212" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3213" href="#"></a></td>
<td><pre>     * Copies the specified array, truncating or padding with zeros (if necessary)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3214" href="#"></a></td>
<td><pre>     * so the copy has the specified length.  For all indices that are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3215" href="#"></a></td>
<td><pre>     * valid in both the original array and the copy, the two arrays will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3216" href="#"></a></td>
<td><pre>     * contain identical values.  For any indices that are valid in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3217" href="#"></a></td>
<td><pre>     * copy but not the original, the copy will contain &lt;tt&gt;(byte)0&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3218" href="#"></a></td>
<td><pre>     * Such indices will exist if and only if the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3219" href="#"></a></td>
<td><pre>     * is greater than that of the original array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3220" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3221" href="#"></a></td>
<td><pre>     * @param original the array to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3222" href="#"></a></td>
<td><pre>     * @param newLength the length of the copy to be returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3223" href="#"></a></td>
<td><pre>     * @return a copy of the original array, truncated or padded with zeros</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3224" href="#"></a></td>
<td><pre>     *     to obtain the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3225" href="#"></a></td>
<td><pre>     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3226" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3227" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3228" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3229" href="#"></a></td>
<td><pre>    public static byte[] copyOf(byte[] original, int newLength) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3230" href="#"></a></td>
<td><pre>        byte[] copy = new byte[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3231" href="#"></a></td>
<td><pre>        System.arraycopy(original, 0, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3232" href="#"></a></td>
<td><pre>                         Math.min(original.length, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3233" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3234" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3235" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3236" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3237" href="#"></a></td>
<td><pre>     * Copies the specified array, truncating or padding with zeros (if necessary)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3238" href="#"></a></td>
<td><pre>     * so the copy has the specified length.  For all indices that are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3239" href="#"></a></td>
<td><pre>     * valid in both the original array and the copy, the two arrays will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3240" href="#"></a></td>
<td><pre>     * contain identical values.  For any indices that are valid in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3241" href="#"></a></td>
<td><pre>     * copy but not the original, the copy will contain &lt;tt&gt;(short)0&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3242" href="#"></a></td>
<td><pre>     * Such indices will exist if and only if the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3243" href="#"></a></td>
<td><pre>     * is greater than that of the original array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3244" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3245" href="#"></a></td>
<td><pre>     * @param original the array to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3246" href="#"></a></td>
<td><pre>     * @param newLength the length of the copy to be returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3247" href="#"></a></td>
<td><pre>     * @return a copy of the original array, truncated or padded with zeros</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3248" href="#"></a></td>
<td><pre>     *     to obtain the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3249" href="#"></a></td>
<td><pre>     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3250" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3251" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3252" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3253" href="#"></a></td>
<td><pre>    public static short[] copyOf(short[] original, int newLength) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3254" href="#"></a></td>
<td><pre>        short[] copy = new short[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3255" href="#"></a></td>
<td><pre>        System.arraycopy(original, 0, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3256" href="#"></a></td>
<td><pre>                         Math.min(original.length, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3257" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3258" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3259" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3260" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3261" href="#"></a></td>
<td><pre>     * Copies the specified array, truncating or padding with zeros (if necessary)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3262" href="#"></a></td>
<td><pre>     * so the copy has the specified length.  For all indices that are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3263" href="#"></a></td>
<td><pre>     * valid in both the original array and the copy, the two arrays will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3264" href="#"></a></td>
<td><pre>     * contain identical values.  For any indices that are valid in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3265" href="#"></a></td>
<td><pre>     * copy but not the original, the copy will contain &lt;tt&gt;0&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3266" href="#"></a></td>
<td><pre>     * Such indices will exist if and only if the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3267" href="#"></a></td>
<td><pre>     * is greater than that of the original array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3268" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3269" href="#"></a></td>
<td><pre>     * @param original the array to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3270" href="#"></a></td>
<td><pre>     * @param newLength the length of the copy to be returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3271" href="#"></a></td>
<td><pre>     * @return a copy of the original array, truncated or padded with zeros</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3272" href="#"></a></td>
<td><pre>     *     to obtain the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3273" href="#"></a></td>
<td><pre>     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3274" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3275" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3276" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3277" href="#"></a></td>
<td><pre>    public static int[] copyOf(int[] original, int newLength) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3278" href="#"></a></td>
<td><pre>        int[] copy = new int[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3279" href="#"></a></td>
<td><pre>        System.arraycopy(original, 0, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3280" href="#"></a></td>
<td><pre>                         Math.min(original.length, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3281" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3282" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3283" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3284" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3285" href="#"></a></td>
<td><pre>     * Copies the specified array, truncating or padding with zeros (if necessary)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3286" href="#"></a></td>
<td><pre>     * so the copy has the specified length.  For all indices that are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3287" href="#"></a></td>
<td><pre>     * valid in both the original array and the copy, the two arrays will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3288" href="#"></a></td>
<td><pre>     * contain identical values.  For any indices that are valid in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3289" href="#"></a></td>
<td><pre>     * copy but not the original, the copy will contain &lt;tt&gt;0L&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3290" href="#"></a></td>
<td><pre>     * Such indices will exist if and only if the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3291" href="#"></a></td>
<td><pre>     * is greater than that of the original array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3292" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3293" href="#"></a></td>
<td><pre>     * @param original the array to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3294" href="#"></a></td>
<td><pre>     * @param newLength the length of the copy to be returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3295" href="#"></a></td>
<td><pre>     * @return a copy of the original array, truncated or padded with zeros</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3296" href="#"></a></td>
<td><pre>     *     to obtain the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3297" href="#"></a></td>
<td><pre>     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3298" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3299" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3300" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3301" href="#"></a></td>
<td><pre>    public static long[] copyOf(long[] original, int newLength) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3302" href="#"></a></td>
<td><pre>        long[] copy = new long[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3303" href="#"></a></td>
<td><pre>        System.arraycopy(original, 0, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3304" href="#"></a></td>
<td><pre>                         Math.min(original.length, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3305" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3306" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3307" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3308" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3309" href="#"></a></td>
<td><pre>     * Copies the specified array, truncating or padding with null characters (if necessary)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3310" href="#"></a></td>
<td><pre>     * so the copy has the specified length.  For all indices that are valid</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3311" href="#"></a></td>
<td><pre>     * in both the original array and the copy, the two arrays will contain</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3312" href="#"></a></td>
<td><pre>     * identical values.  For any indices that are valid in the copy but not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3313" href="#"></a></td>
<td><pre>     * the original, the copy will contain &lt;tt&gt;'\\u000'&lt;/tt&gt;.  Such indices</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3314" href="#"></a></td>
<td><pre>     * will exist if and only if the specified length is greater than that of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3315" href="#"></a></td>
<td><pre>     * the original array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3316" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3317" href="#"></a></td>
<td><pre>     * @param original the array to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3318" href="#"></a></td>
<td><pre>     * @param newLength the length of the copy to be returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3319" href="#"></a></td>
<td><pre>     * @return a copy of the original array, truncated or padded with null characters</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3320" href="#"></a></td>
<td><pre>     *     to obtain the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3321" href="#"></a></td>
<td><pre>     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3322" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3323" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3324" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3325" href="#"></a></td>
<td><pre>    public static char[] copyOf(char[] original, int newLength) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3326" href="#"></a></td>
<td><pre>        char[] copy = new char[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3327" href="#"></a></td>
<td><pre>        System.arraycopy(original, 0, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3328" href="#"></a></td>
<td><pre>                         Math.min(original.length, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3329" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3330" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3331" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3332" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3333" href="#"></a></td>
<td><pre>     * Copies the specified array, truncating or padding with zeros (if necessary)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3334" href="#"></a></td>
<td><pre>     * so the copy has the specified length.  For all indices that are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3335" href="#"></a></td>
<td><pre>     * valid in both the original array and the copy, the two arrays will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3336" href="#"></a></td>
<td><pre>     * contain identical values.  For any indices that are valid in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3337" href="#"></a></td>
<td><pre>     * copy but not the original, the copy will contain &lt;tt&gt;0f&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3338" href="#"></a></td>
<td><pre>     * Such indices will exist if and only if the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3339" href="#"></a></td>
<td><pre>     * is greater than that of the original array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3340" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3341" href="#"></a></td>
<td><pre>     * @param original the array to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3342" href="#"></a></td>
<td><pre>     * @param newLength the length of the copy to be returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3343" href="#"></a></td>
<td><pre>     * @return a copy of the original array, truncated or padded with zeros</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3344" href="#"></a></td>
<td><pre>     *     to obtain the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3345" href="#"></a></td>
<td><pre>     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3346" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3347" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3348" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3349" href="#"></a></td>
<td><pre>    public static float[] copyOf(float[] original, int newLength) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3350" href="#"></a></td>
<td><pre>        float[] copy = new float[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3351" href="#"></a></td>
<td><pre>        System.arraycopy(original, 0, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3352" href="#"></a></td>
<td><pre>                         Math.min(original.length, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3353" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3354" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3355" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3356" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3357" href="#"></a></td>
<td><pre>     * Copies the specified array, truncating or padding with zeros (if necessary)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3358" href="#"></a></td>
<td><pre>     * so the copy has the specified length.  For all indices that are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3359" href="#"></a></td>
<td><pre>     * valid in both the original array and the copy, the two arrays will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3360" href="#"></a></td>
<td><pre>     * contain identical values.  For any indices that are valid in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3361" href="#"></a></td>
<td><pre>     * copy but not the original, the copy will contain &lt;tt&gt;0d&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3362" href="#"></a></td>
<td><pre>     * Such indices will exist if and only if the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3363" href="#"></a></td>
<td><pre>     * is greater than that of the original array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3364" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3365" href="#"></a></td>
<td><pre>     * @param original the array to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3366" href="#"></a></td>
<td><pre>     * @param newLength the length of the copy to be returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3367" href="#"></a></td>
<td><pre>     * @return a copy of the original array, truncated or padded with zeros</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3368" href="#"></a></td>
<td><pre>     *     to obtain the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3369" href="#"></a></td>
<td><pre>     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3370" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3371" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3372" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3373" href="#"></a></td>
<td><pre>    public static double[] copyOf(double[] original, int newLength) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3374" href="#"></a></td>
<td><pre>        double[] copy = new double[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3375" href="#"></a></td>
<td><pre>        System.arraycopy(original, 0, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3376" href="#"></a></td>
<td><pre>                         Math.min(original.length, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3377" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3378" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3379" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3380" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3381" href="#"></a></td>
<td><pre>     * Copies the specified array, truncating or padding with &lt;tt&gt;false&lt;/tt&gt; (if necessary)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3382" href="#"></a></td>
<td><pre>     * so the copy has the specified length.  For all indices that are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3383" href="#"></a></td>
<td><pre>     * valid in both the original array and the copy, the two arrays will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3384" href="#"></a></td>
<td><pre>     * contain identical values.  For any indices that are valid in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3385" href="#"></a></td>
<td><pre>     * copy but not the original, the copy will contain &lt;tt&gt;false&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3386" href="#"></a></td>
<td><pre>     * Such indices will exist if and only if the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3387" href="#"></a></td>
<td><pre>     * is greater than that of the original array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3388" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3389" href="#"></a></td>
<td><pre>     * @param original the array to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3390" href="#"></a></td>
<td><pre>     * @param newLength the length of the copy to be returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3391" href="#"></a></td>
<td><pre>     * @return a copy of the original array, truncated or padded with false elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3392" href="#"></a></td>
<td><pre>     *     to obtain the specified length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3393" href="#"></a></td>
<td><pre>     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3394" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3395" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3396" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3397" href="#"></a></td>
<td><pre>    public static boolean[] copyOf(boolean[] original, int newLength) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3398" href="#"></a></td>
<td><pre>        boolean[] copy = new boolean[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3399" href="#"></a></td>
<td><pre>        System.arraycopy(original, 0, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3400" href="#"></a></td>
<td><pre>                         Math.min(original.length, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3401" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3402" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3403" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3404" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3405" href="#"></a></td>
<td><pre>     * Copies the specified range of the specified array into a new array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3406" href="#"></a></td>
<td><pre>     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3407" href="#"></a></td>
<td><pre>     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3408" href="#"></a></td>
<td><pre>     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3409" href="#"></a></td>
<td><pre>     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3410" href="#"></a></td>
<td><pre>     * Values from subsequent elements in the original array are placed into</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3411" href="#"></a></td>
<td><pre>     * subsequent elements in the copy.  The final index of the range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3412" href="#"></a></td>
<td><pre>     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3413" href="#"></a></td>
<td><pre>     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3414" href="#"></a></td>
<td><pre>     * &lt;tt&gt;null&lt;/tt&gt; is placed in all elements of the copy whose index is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3415" href="#"></a></td>
<td><pre>     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3416" href="#"></a></td>
<td><pre>     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3417" href="#"></a></td>
<td><pre>     * &lt;p&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3418" href="#"></a></td>
<td><pre>     * The resulting array is of exactly the same class as the original array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3419" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3420" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the class of the objects in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3421" href="#"></a></td>
<td><pre>     * @param original the array from which a range is to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3422" href="#"></a></td>
<td><pre>     * @param from the initial index of the range to be copied, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3423" href="#"></a></td>
<td><pre>     * @param to the final index of the range to be copied, exclusive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3424" href="#"></a></td>
<td><pre>     *     (This index may lie outside the array.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3425" href="#"></a></td>
<td><pre>     * @return a new array containing the specified range from the original array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3426" href="#"></a></td>
<td><pre>     *     truncated or padded with nulls to obtain the required length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3427" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3428" href="#"></a></td>
<td><pre>     *     or {@code from &gt; original.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3429" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3430" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3431" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3432" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3433" href="#"></a></td>
<td><pre>    @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3434" href="#"></a></td>
<td><pre>    public static &lt;T&gt; T[] copyOfRange(T[] original, int from, int to) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3435" href="#"></a></td>
<td><pre>        return copyOfRange(original, from, to, (Class&lt;? extends T[]&gt;) original.getClass());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3436" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3437" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3438" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3439" href="#"></a></td>
<td><pre>     * Copies the specified range of the specified array into a new array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3440" href="#"></a></td>
<td><pre>     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3441" href="#"></a></td>
<td><pre>     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3442" href="#"></a></td>
<td><pre>     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3443" href="#"></a></td>
<td><pre>     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3444" href="#"></a></td>
<td><pre>     * Values from subsequent elements in the original array are placed into</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3445" href="#"></a></td>
<td><pre>     * subsequent elements in the copy.  The final index of the range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3446" href="#"></a></td>
<td><pre>     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3447" href="#"></a></td>
<td><pre>     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3448" href="#"></a></td>
<td><pre>     * &lt;tt&gt;null&lt;/tt&gt; is placed in all elements of the copy whose index is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3449" href="#"></a></td>
<td><pre>     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3450" href="#"></a></td>
<td><pre>     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3451" href="#"></a></td>
<td><pre>     * The resulting array is of the class &lt;tt&gt;newType&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3452" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3453" href="#"></a></td>
<td><pre>     * @param &lt;U&gt; the class of the objects in the original array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3454" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the class of the objects in the returned array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3455" href="#"></a></td>
<td><pre>     * @param original the array from which a range is to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3456" href="#"></a></td>
<td><pre>     * @param from the initial index of the range to be copied, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3457" href="#"></a></td>
<td><pre>     * @param to the final index of the range to be copied, exclusive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3458" href="#"></a></td>
<td><pre>     *     (This index may lie outside the array.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3459" href="#"></a></td>
<td><pre>     * @param newType the class of the copy to be returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3460" href="#"></a></td>
<td><pre>     * @return a new array containing the specified range from the original array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3461" href="#"></a></td>
<td><pre>     *     truncated or padded with nulls to obtain the required length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3462" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3463" href="#"></a></td>
<td><pre>     *     or {@code from &gt; original.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3464" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3465" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3466" href="#"></a></td>
<td><pre>     * @throws ArrayStoreException if an element copied from</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3467" href="#"></a></td>
<td><pre>     *     &lt;tt&gt;original&lt;/tt&gt; is not of a runtime type that can be stored in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3468" href="#"></a></td>
<td><pre>     *     an array of class &lt;tt&gt;newType&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3469" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3470" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3471" href="#"></a></td>
<td><pre>    public static &lt;T,U&gt; T[] copyOfRange(U[] original, int from, int to, Class&lt;? extends T[]&gt; newType) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3472" href="#"></a></td>
<td><pre>        int newLength = to - from;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3473" href="#"></a></td>
<td><pre>        if (newLength &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3474" href="#"></a></td>
<td><pre>            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3475" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3476" href="#"></a></td>
<td><pre>        T[] copy = ((Object)newType == (Object)Object[].class)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3477" href="#"></a></td>
<td><pre>            ? (T[]) new Object[newLength]</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3478" href="#"></a></td>
<td><pre>            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3479" href="#"></a></td>
<td><pre>        System.arraycopy(original, from, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3480" href="#"></a></td>
<td><pre>                         Math.min(original.length - from, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3481" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3482" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3483" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3484" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3485" href="#"></a></td>
<td><pre>     * Copies the specified range of the specified array into a new array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3486" href="#"></a></td>
<td><pre>     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3487" href="#"></a></td>
<td><pre>     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3488" href="#"></a></td>
<td><pre>     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3489" href="#"></a></td>
<td><pre>     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3490" href="#"></a></td>
<td><pre>     * Values from subsequent elements in the original array are placed into</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3491" href="#"></a></td>
<td><pre>     * subsequent elements in the copy.  The final index of the range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3492" href="#"></a></td>
<td><pre>     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3493" href="#"></a></td>
<td><pre>     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3494" href="#"></a></td>
<td><pre>     * &lt;tt&gt;(byte)0&lt;/tt&gt; is placed in all elements of the copy whose index is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3495" href="#"></a></td>
<td><pre>     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3496" href="#"></a></td>
<td><pre>     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3497" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3498" href="#"></a></td>
<td><pre>     * @param original the array from which a range is to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3499" href="#"></a></td>
<td><pre>     * @param from the initial index of the range to be copied, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3500" href="#"></a></td>
<td><pre>     * @param to the final index of the range to be copied, exclusive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3501" href="#"></a></td>
<td><pre>     *     (This index may lie outside the array.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3502" href="#"></a></td>
<td><pre>     * @return a new array containing the specified range from the original array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3503" href="#"></a></td>
<td><pre>     *     truncated or padded with zeros to obtain the required length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3504" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3505" href="#"></a></td>
<td><pre>     *     or {@code from &gt; original.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3506" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3507" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3508" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3509" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3510" href="#"></a></td>
<td><pre>    public static byte[] copyOfRange(byte[] original, int from, int to) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3511" href="#"></a></td>
<td><pre>        int newLength = to - from;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3512" href="#"></a></td>
<td><pre>        if (newLength &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3513" href="#"></a></td>
<td><pre>            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3514" href="#"></a></td>
<td><pre>        byte[] copy = new byte[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3515" href="#"></a></td>
<td><pre>        System.arraycopy(original, from, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3516" href="#"></a></td>
<td><pre>                         Math.min(original.length - from, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3517" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3518" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3519" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3520" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3521" href="#"></a></td>
<td><pre>     * Copies the specified range of the specified array into a new array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3522" href="#"></a></td>
<td><pre>     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3523" href="#"></a></td>
<td><pre>     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3524" href="#"></a></td>
<td><pre>     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3525" href="#"></a></td>
<td><pre>     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3526" href="#"></a></td>
<td><pre>     * Values from subsequent elements in the original array are placed into</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3527" href="#"></a></td>
<td><pre>     * subsequent elements in the copy.  The final index of the range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3528" href="#"></a></td>
<td><pre>     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3529" href="#"></a></td>
<td><pre>     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3530" href="#"></a></td>
<td><pre>     * &lt;tt&gt;(short)0&lt;/tt&gt; is placed in all elements of the copy whose index is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3531" href="#"></a></td>
<td><pre>     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3532" href="#"></a></td>
<td><pre>     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3533" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3534" href="#"></a></td>
<td><pre>     * @param original the array from which a range is to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3535" href="#"></a></td>
<td><pre>     * @param from the initial index of the range to be copied, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3536" href="#"></a></td>
<td><pre>     * @param to the final index of the range to be copied, exclusive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3537" href="#"></a></td>
<td><pre>     *     (This index may lie outside the array.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3538" href="#"></a></td>
<td><pre>     * @return a new array containing the specified range from the original array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3539" href="#"></a></td>
<td><pre>     *     truncated or padded with zeros to obtain the required length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3540" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3541" href="#"></a></td>
<td><pre>     *     or {@code from &gt; original.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3542" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3543" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3544" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3545" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3546" href="#"></a></td>
<td><pre>    public static short[] copyOfRange(short[] original, int from, int to) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3547" href="#"></a></td>
<td><pre>        int newLength = to - from;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3548" href="#"></a></td>
<td><pre>        if (newLength &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3549" href="#"></a></td>
<td><pre>            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3550" href="#"></a></td>
<td><pre>        short[] copy = new short[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3551" href="#"></a></td>
<td><pre>        System.arraycopy(original, from, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3552" href="#"></a></td>
<td><pre>                         Math.min(original.length - from, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3553" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3554" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3555" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3556" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3557" href="#"></a></td>
<td><pre>     * Copies the specified range of the specified array into a new array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3558" href="#"></a></td>
<td><pre>     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3559" href="#"></a></td>
<td><pre>     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3560" href="#"></a></td>
<td><pre>     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3561" href="#"></a></td>
<td><pre>     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3562" href="#"></a></td>
<td><pre>     * Values from subsequent elements in the original array are placed into</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3563" href="#"></a></td>
<td><pre>     * subsequent elements in the copy.  The final index of the range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3564" href="#"></a></td>
<td><pre>     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3565" href="#"></a></td>
<td><pre>     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3566" href="#"></a></td>
<td><pre>     * &lt;tt&gt;0&lt;/tt&gt; is placed in all elements of the copy whose index is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3567" href="#"></a></td>
<td><pre>     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3568" href="#"></a></td>
<td><pre>     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3569" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3570" href="#"></a></td>
<td><pre>     * @param original the array from which a range is to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3571" href="#"></a></td>
<td><pre>     * @param from the initial index of the range to be copied, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3572" href="#"></a></td>
<td><pre>     * @param to the final index of the range to be copied, exclusive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3573" href="#"></a></td>
<td><pre>     *     (This index may lie outside the array.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3574" href="#"></a></td>
<td><pre>     * @return a new array containing the specified range from the original array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3575" href="#"></a></td>
<td><pre>     *     truncated or padded with zeros to obtain the required length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3576" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3577" href="#"></a></td>
<td><pre>     *     or {@code from &gt; original.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3578" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3579" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3580" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3581" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3582" href="#"></a></td>
<td><pre>    public static int[] copyOfRange(int[] original, int from, int to) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3583" href="#"></a></td>
<td><pre>        int newLength = to - from;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3584" href="#"></a></td>
<td><pre>        if (newLength &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3585" href="#"></a></td>
<td><pre>            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3586" href="#"></a></td>
<td><pre>        int[] copy = new int[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3587" href="#"></a></td>
<td><pre>        System.arraycopy(original, from, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3588" href="#"></a></td>
<td><pre>                         Math.min(original.length - from, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3589" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3590" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3591" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3592" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3593" href="#"></a></td>
<td><pre>     * Copies the specified range of the specified array into a new array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3594" href="#"></a></td>
<td><pre>     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3595" href="#"></a></td>
<td><pre>     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3596" href="#"></a></td>
<td><pre>     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3597" href="#"></a></td>
<td><pre>     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3598" href="#"></a></td>
<td><pre>     * Values from subsequent elements in the original array are placed into</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3599" href="#"></a></td>
<td><pre>     * subsequent elements in the copy.  The final index of the range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3600" href="#"></a></td>
<td><pre>     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3601" href="#"></a></td>
<td><pre>     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3602" href="#"></a></td>
<td><pre>     * &lt;tt&gt;0L&lt;/tt&gt; is placed in all elements of the copy whose index is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3603" href="#"></a></td>
<td><pre>     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3604" href="#"></a></td>
<td><pre>     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3605" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3606" href="#"></a></td>
<td><pre>     * @param original the array from which a range is to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3607" href="#"></a></td>
<td><pre>     * @param from the initial index of the range to be copied, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3608" href="#"></a></td>
<td><pre>     * @param to the final index of the range to be copied, exclusive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3609" href="#"></a></td>
<td><pre>     *     (This index may lie outside the array.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3610" href="#"></a></td>
<td><pre>     * @return a new array containing the specified range from the original array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3611" href="#"></a></td>
<td><pre>     *     truncated or padded with zeros to obtain the required length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3612" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3613" href="#"></a></td>
<td><pre>     *     or {@code from &gt; original.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3614" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3615" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3616" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3617" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3618" href="#"></a></td>
<td><pre>    public static long[] copyOfRange(long[] original, int from, int to) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3619" href="#"></a></td>
<td><pre>        int newLength = to - from;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3620" href="#"></a></td>
<td><pre>        if (newLength &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3621" href="#"></a></td>
<td><pre>            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3622" href="#"></a></td>
<td><pre>        long[] copy = new long[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3623" href="#"></a></td>
<td><pre>        System.arraycopy(original, from, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3624" href="#"></a></td>
<td><pre>                         Math.min(original.length - from, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3625" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3626" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3627" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3628" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3629" href="#"></a></td>
<td><pre>     * Copies the specified range of the specified array into a new array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3630" href="#"></a></td>
<td><pre>     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3631" href="#"></a></td>
<td><pre>     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3632" href="#"></a></td>
<td><pre>     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3633" href="#"></a></td>
<td><pre>     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3634" href="#"></a></td>
<td><pre>     * Values from subsequent elements in the original array are placed into</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3635" href="#"></a></td>
<td><pre>     * subsequent elements in the copy.  The final index of the range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3636" href="#"></a></td>
<td><pre>     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3637" href="#"></a></td>
<td><pre>     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3638" href="#"></a></td>
<td><pre>     * &lt;tt&gt;'\\u000'&lt;/tt&gt; is placed in all elements of the copy whose index is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3639" href="#"></a></td>
<td><pre>     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3640" href="#"></a></td>
<td><pre>     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3641" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3642" href="#"></a></td>
<td><pre>     * @param original the array from which a range is to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3643" href="#"></a></td>
<td><pre>     * @param from the initial index of the range to be copied, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3644" href="#"></a></td>
<td><pre>     * @param to the final index of the range to be copied, exclusive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3645" href="#"></a></td>
<td><pre>     *     (This index may lie outside the array.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3646" href="#"></a></td>
<td><pre>     * @return a new array containing the specified range from the original array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3647" href="#"></a></td>
<td><pre>     *     truncated or padded with null characters to obtain the required length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3648" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3649" href="#"></a></td>
<td><pre>     *     or {@code from &gt; original.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3650" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3651" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3652" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3653" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3654" href="#"></a></td>
<td><pre>    public static char[] copyOfRange(char[] original, int from, int to) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3655" href="#"></a></td>
<td><pre>        int newLength = to - from;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3656" href="#"></a></td>
<td><pre>        if (newLength &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3657" href="#"></a></td>
<td><pre>            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3658" href="#"></a></td>
<td><pre>        char[] copy = new char[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3659" href="#"></a></td>
<td><pre>        System.arraycopy(original, from, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3660" href="#"></a></td>
<td><pre>                         Math.min(original.length - from, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3661" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3662" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3663" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3664" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3665" href="#"></a></td>
<td><pre>     * Copies the specified range of the specified array into a new array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3666" href="#"></a></td>
<td><pre>     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3667" href="#"></a></td>
<td><pre>     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3668" href="#"></a></td>
<td><pre>     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3669" href="#"></a></td>
<td><pre>     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3670" href="#"></a></td>
<td><pre>     * Values from subsequent elements in the original array are placed into</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3671" href="#"></a></td>
<td><pre>     * subsequent elements in the copy.  The final index of the range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3672" href="#"></a></td>
<td><pre>     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3673" href="#"></a></td>
<td><pre>     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3674" href="#"></a></td>
<td><pre>     * &lt;tt&gt;0f&lt;/tt&gt; is placed in all elements of the copy whose index is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3675" href="#"></a></td>
<td><pre>     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3676" href="#"></a></td>
<td><pre>     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3677" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3678" href="#"></a></td>
<td><pre>     * @param original the array from which a range is to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3679" href="#"></a></td>
<td><pre>     * @param from the initial index of the range to be copied, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3680" href="#"></a></td>
<td><pre>     * @param to the final index of the range to be copied, exclusive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3681" href="#"></a></td>
<td><pre>     *     (This index may lie outside the array.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3682" href="#"></a></td>
<td><pre>     * @return a new array containing the specified range from the original array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3683" href="#"></a></td>
<td><pre>     *     truncated or padded with zeros to obtain the required length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3684" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3685" href="#"></a></td>
<td><pre>     *     or {@code from &gt; original.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3686" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3687" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3688" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3689" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3690" href="#"></a></td>
<td><pre>    public static float[] copyOfRange(float[] original, int from, int to) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3691" href="#"></a></td>
<td><pre>        int newLength = to - from;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3692" href="#"></a></td>
<td><pre>        if (newLength &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3693" href="#"></a></td>
<td><pre>            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3694" href="#"></a></td>
<td><pre>        float[] copy = new float[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3695" href="#"></a></td>
<td><pre>        System.arraycopy(original, from, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3696" href="#"></a></td>
<td><pre>                         Math.min(original.length - from, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3697" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3698" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3699" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3700" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3701" href="#"></a></td>
<td><pre>     * Copies the specified range of the specified array into a new array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3702" href="#"></a></td>
<td><pre>     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3703" href="#"></a></td>
<td><pre>     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3704" href="#"></a></td>
<td><pre>     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3705" href="#"></a></td>
<td><pre>     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3706" href="#"></a></td>
<td><pre>     * Values from subsequent elements in the original array are placed into</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3707" href="#"></a></td>
<td><pre>     * subsequent elements in the copy.  The final index of the range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3708" href="#"></a></td>
<td><pre>     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3709" href="#"></a></td>
<td><pre>     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3710" href="#"></a></td>
<td><pre>     * &lt;tt&gt;0d&lt;/tt&gt; is placed in all elements of the copy whose index is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3711" href="#"></a></td>
<td><pre>     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3712" href="#"></a></td>
<td><pre>     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3713" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3714" href="#"></a></td>
<td><pre>     * @param original the array from which a range is to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3715" href="#"></a></td>
<td><pre>     * @param from the initial index of the range to be copied, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3716" href="#"></a></td>
<td><pre>     * @param to the final index of the range to be copied, exclusive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3717" href="#"></a></td>
<td><pre>     *     (This index may lie outside the array.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3718" href="#"></a></td>
<td><pre>     * @return a new array containing the specified range from the original array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3719" href="#"></a></td>
<td><pre>     *     truncated or padded with zeros to obtain the required length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3720" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3721" href="#"></a></td>
<td><pre>     *     or {@code from &gt; original.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3722" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3723" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3724" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3725" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3726" href="#"></a></td>
<td><pre>    public static double[] copyOfRange(double[] original, int from, int to) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3727" href="#"></a></td>
<td><pre>        int newLength = to - from;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3728" href="#"></a></td>
<td><pre>        if (newLength &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3729" href="#"></a></td>
<td><pre>            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3730" href="#"></a></td>
<td><pre>        double[] copy = new double[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3731" href="#"></a></td>
<td><pre>        System.arraycopy(original, from, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3732" href="#"></a></td>
<td><pre>                         Math.min(original.length - from, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3733" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3734" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3735" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3736" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3737" href="#"></a></td>
<td><pre>     * Copies the specified range of the specified array into a new array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3738" href="#"></a></td>
<td><pre>     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3739" href="#"></a></td>
<td><pre>     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3740" href="#"></a></td>
<td><pre>     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3741" href="#"></a></td>
<td><pre>     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3742" href="#"></a></td>
<td><pre>     * Values from subsequent elements in the original array are placed into</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3743" href="#"></a></td>
<td><pre>     * subsequent elements in the copy.  The final index of the range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3744" href="#"></a></td>
<td><pre>     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3745" href="#"></a></td>
<td><pre>     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3746" href="#"></a></td>
<td><pre>     * &lt;tt&gt;false&lt;/tt&gt; is placed in all elements of the copy whose index is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3747" href="#"></a></td>
<td><pre>     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3748" href="#"></a></td>
<td><pre>     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3749" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3750" href="#"></a></td>
<td><pre>     * @param original the array from which a range is to be copied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3751" href="#"></a></td>
<td><pre>     * @param from the initial index of the range to be copied, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3752" href="#"></a></td>
<td><pre>     * @param to the final index of the range to be copied, exclusive.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3753" href="#"></a></td>
<td><pre>     *     (This index may lie outside the array.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3754" href="#"></a></td>
<td><pre>     * @return a new array containing the specified range from the original array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3755" href="#"></a></td>
<td><pre>     *     truncated or padded with false elements to obtain the required length</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3756" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3757" href="#"></a></td>
<td><pre>     *     or {@code from &gt; original.length}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3758" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3759" href="#"></a></td>
<td><pre>     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3760" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3761" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3762" href="#"></a></td>
<td><pre>    public static boolean[] copyOfRange(boolean[] original, int from, int to) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3763" href="#"></a></td>
<td><pre>        int newLength = to - from;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3764" href="#"></a></td>
<td><pre>        if (newLength &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3765" href="#"></a></td>
<td><pre>            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3766" href="#"></a></td>
<td><pre>        boolean[] copy = new boolean[newLength];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3767" href="#"></a></td>
<td><pre>        System.arraycopy(original, from, copy, 0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3768" href="#"></a></td>
<td><pre>                         Math.min(original.length - from, newLength));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3769" href="#"></a></td>
<td><pre>        return copy;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3770" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3771" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3772" href="#"></a></td>
<td><pre>    // Misc</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3773" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3774" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3775" href="#"></a></td>
<td><pre>     * Returns a fixed-size list backed by the specified array.  (Changes to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3776" href="#"></a></td>
<td><pre>     * the returned list &quot;write through&quot; to the array.)  This method acts</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3777" href="#"></a></td>
<td><pre>     * as bridge between array-based and collection-based APIs, in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3778" href="#"></a></td>
<td><pre>     * combination with {@link Collection#toArray}.  The returned list is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3779" href="#"></a></td>
<td><pre>     * serializable and implements {@link RandomAccess}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3780" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3781" href="#"></a></td>
<td><pre>     * &lt;p&gt;This method also provides a convenient way to create a fixed-size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3782" href="#"></a></td>
<td><pre>     * list initialized to contain several elements:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3783" href="#"></a></td>
<td><pre>     * &lt;pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3784" href="#"></a></td>
<td><pre>     *     List&amp;lt;String&amp;gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3785" href="#"></a></td>
<td><pre>     * &lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3786" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3787" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the class of the objects in the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3788" href="#"></a></td>
<td><pre>     * @param a the array by which the list will be backed</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3789" href="#"></a></td>
<td><pre>     * @return a list view of the specified array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3790" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3791" href="#"></a></td>
<td><pre>    @SafeVarargs</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3792" href="#"></a></td>
<td><pre>    @SuppressWarnings(&quot;varargs&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3793" href="#"></a></td>
<td><pre>    public static &lt;T&gt; List&lt;T&gt; asList(T... a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3794" href="#"></a></td>
<td><pre>        return new ArrayList&lt;&gt;(a);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3795" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3796" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3797" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3798" href="#"></a></td>
<td><pre>     * @serial include</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3799" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3800" href="#"></a></td>
<td><pre>    private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3801" href="#"></a></td>
<td><pre>        implements RandomAccess, java.io.Serializable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3802" href="#"></a></td>
<td><pre>    {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3803" href="#"></a></td>
<td><pre>        private static final long serialVersionUID = -2764017481108945198L;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3804" href="#"></a></td>
<td><pre>        private final E[] a;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3805" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3806" href="#"></a></td>
<td><pre>        ArrayList(E[] array) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3807" href="#"></a></td>
<td><pre>            a = Objects.requireNonNull(array);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3808" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3809" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3810" href="#"></a></td>
<td><pre>        @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3811" href="#"></a></td>
<td><pre>        public int size() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3812" href="#"></a></td>
<td><pre>            return a.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3813" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3814" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3815" href="#"></a></td>
<td><pre>        @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3816" href="#"></a></td>
<td><pre>        public Object[] toArray() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3817" href="#"></a></td>
<td><pre>            return a.clone();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3818" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3819" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3820" href="#"></a></td>
<td><pre>        @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3821" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3822" href="#"></a></td>
<td><pre>        public &lt;T&gt; T[] toArray(T[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3823" href="#"></a></td>
<td><pre>            int size = size();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3824" href="#"></a></td>
<td><pre>            if (a.length &lt; size)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3825" href="#"></a></td>
<td><pre>                return Arrays.copyOf(this.a, size,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3826" href="#"></a></td>
<td><pre>                                     (Class&lt;? extends T[]&gt;) a.getClass());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3827" href="#"></a></td>
<td><pre>            System.arraycopy(this.a, 0, a, 0, size);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3828" href="#"></a></td>
<td><pre>            if (a.length &gt; size)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3829" href="#"></a></td>
<td><pre>                a[size] = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3830" href="#"></a></td>
<td><pre>            return a;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3831" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3832" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3833" href="#"></a></td>
<td><pre>        @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3834" href="#"></a></td>
<td><pre>        public E get(int index) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3835" href="#"></a></td>
<td><pre>            return a[index];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3836" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3837" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3838" href="#"></a></td>
<td><pre>        @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3839" href="#"></a></td>
<td><pre>        public E set(int index, E element) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3840" href="#"></a></td>
<td><pre>            E oldValue = a[index];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3841" href="#"></a></td>
<td><pre>            a[index] = element;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3842" href="#"></a></td>
<td><pre>            return oldValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3843" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3844" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3845" href="#"></a></td>
<td><pre>        @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3846" href="#"></a></td>
<td><pre>        public int indexOf(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3847" href="#"></a></td>
<td><pre>            if (o==null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3848" href="#"></a></td>
<td><pre>                for (int i=0; i&lt;a.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3849" href="#"></a></td>
<td><pre>                    if (a[i]==null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3850" href="#"></a></td>
<td><pre>                        return i;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3851" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3852" href="#"></a></td>
<td><pre>                for (int i=0; i&lt;a.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3853" href="#"></a></td>
<td><pre>                    if (o.equals(a[i]))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3854" href="#"></a></td>
<td><pre>                        return i;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3855" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3856" href="#"></a></td>
<td><pre>            return -1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3857" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3858" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3859" href="#"></a></td>
<td><pre>        @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3860" href="#"></a></td>
<td><pre>        public boolean contains(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3861" href="#"></a></td>
<td><pre>            return indexOf(o) != -1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3862" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3863" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3864" href="#"></a></td>
<td><pre>        @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3865" href="#"></a></td>
<td><pre>        public Spliterator&lt;E&gt; spliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3866" href="#"></a></td>
<td><pre>            return Spliterators.spliterator(a, Spliterator.ORDERED);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3867" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3868" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3869" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3870" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3871" href="#"></a></td>
<td><pre>     * Returns a hash code based on the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3872" href="#"></a></td>
<td><pre>     * For any two &lt;tt&gt;long&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3873" href="#"></a></td>
<td><pre>     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3874" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3875" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3876" href="#"></a></td>
<td><pre>     * &lt;p&gt;The value returned by this method is the same value that would be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3877" href="#"></a></td>
<td><pre>     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3878" href="#"></a></td>
<td><pre>     * method on a {@link List} containing a sequence of {@link Long}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3879" href="#"></a></td>
<td><pre>     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3880" href="#"></a></td>
<td><pre>     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3881" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3882" href="#"></a></td>
<td><pre>     * @param a the array whose hash value to compute</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3883" href="#"></a></td>
<td><pre>     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3884" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3885" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3886" href="#"></a></td>
<td><pre>    public static int hashCode(long a[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3887" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3888" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3889" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3890" href="#"></a></td>
<td><pre>        int result = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3891" href="#"></a></td>
<td><pre>        for (long element : a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3892" href="#"></a></td>
<td><pre>            int elementHash = (int)(element ^ (element &gt;&gt;&gt; 32));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3893" href="#"></a></td>
<td><pre>            result = 31 * result + elementHash;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3894" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3895" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3896" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3897" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3898" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3899" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3900" href="#"></a></td>
<td><pre>     * Returns a hash code based on the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3901" href="#"></a></td>
<td><pre>     * For any two non-null &lt;tt&gt;int&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3902" href="#"></a></td>
<td><pre>     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3903" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3904" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3905" href="#"></a></td>
<td><pre>     * &lt;p&gt;The value returned by this method is the same value that would be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3906" href="#"></a></td>
<td><pre>     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3907" href="#"></a></td>
<td><pre>     * method on a {@link List} containing a sequence of {@link Integer}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3908" href="#"></a></td>
<td><pre>     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3909" href="#"></a></td>
<td><pre>     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3910" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3911" href="#"></a></td>
<td><pre>     * @param a the array whose hash value to compute</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3912" href="#"></a></td>
<td><pre>     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3913" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3914" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3915" href="#"></a></td>
<td><pre>    public static int hashCode(int a[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3916" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3917" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3918" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3919" href="#"></a></td>
<td><pre>        int result = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3920" href="#"></a></td>
<td><pre>        for (int element : a)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3921" href="#"></a></td>
<td><pre>            result = 31 * result + element;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3922" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3923" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3924" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3925" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3926" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3927" href="#"></a></td>
<td><pre>     * Returns a hash code based on the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3928" href="#"></a></td>
<td><pre>     * For any two &lt;tt&gt;short&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3929" href="#"></a></td>
<td><pre>     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3930" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3931" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3932" href="#"></a></td>
<td><pre>     * &lt;p&gt;The value returned by this method is the same value that would be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3933" href="#"></a></td>
<td><pre>     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3934" href="#"></a></td>
<td><pre>     * method on a {@link List} containing a sequence of {@link Short}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3935" href="#"></a></td>
<td><pre>     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3936" href="#"></a></td>
<td><pre>     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3937" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3938" href="#"></a></td>
<td><pre>     * @param a the array whose hash value to compute</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3939" href="#"></a></td>
<td><pre>     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3940" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3941" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3942" href="#"></a></td>
<td><pre>    public static int hashCode(short a[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3943" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3944" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3945" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3946" href="#"></a></td>
<td><pre>        int result = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3947" href="#"></a></td>
<td><pre>        for (short element : a)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3948" href="#"></a></td>
<td><pre>            result = 31 * result + element;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3949" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3950" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3951" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3952" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3953" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3954" href="#"></a></td>
<td><pre>     * Returns a hash code based on the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3955" href="#"></a></td>
<td><pre>     * For any two &lt;tt&gt;char&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3956" href="#"></a></td>
<td><pre>     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3957" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3958" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3959" href="#"></a></td>
<td><pre>     * &lt;p&gt;The value returned by this method is the same value that would be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3960" href="#"></a></td>
<td><pre>     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3961" href="#"></a></td>
<td><pre>     * method on a {@link List} containing a sequence of {@link Character}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3962" href="#"></a></td>
<td><pre>     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3963" href="#"></a></td>
<td><pre>     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3964" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3965" href="#"></a></td>
<td><pre>     * @param a the array whose hash value to compute</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3966" href="#"></a></td>
<td><pre>     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3967" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3968" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3969" href="#"></a></td>
<td><pre>    public static int hashCode(char a[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3970" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3971" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3972" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3973" href="#"></a></td>
<td><pre>        int result = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3974" href="#"></a></td>
<td><pre>        for (char element : a)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3975" href="#"></a></td>
<td><pre>            result = 31 * result + element;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3976" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3977" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3978" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3979" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3980" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3981" href="#"></a></td>
<td><pre>     * Returns a hash code based on the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3982" href="#"></a></td>
<td><pre>     * For any two &lt;tt&gt;byte&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3983" href="#"></a></td>
<td><pre>     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3984" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3985" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3986" href="#"></a></td>
<td><pre>     * &lt;p&gt;The value returned by this method is the same value that would be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3987" href="#"></a></td>
<td><pre>     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3988" href="#"></a></td>
<td><pre>     * method on a {@link List} containing a sequence of {@link Byte}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3989" href="#"></a></td>
<td><pre>     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3990" href="#"></a></td>
<td><pre>     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3991" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3992" href="#"></a></td>
<td><pre>     * @param a the array whose hash value to compute</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3993" href="#"></a></td>
<td><pre>     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3994" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3995" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3996" href="#"></a></td>
<td><pre>    public static int hashCode(byte a[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3997" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3998" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3999" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4000" href="#"></a></td>
<td><pre>        int result = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4001" href="#"></a></td>
<td><pre>        for (byte element : a)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4002" href="#"></a></td>
<td><pre>            result = 31 * result + element;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4003" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4004" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4005" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4006" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4007" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4008" href="#"></a></td>
<td><pre>     * Returns a hash code based on the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4009" href="#"></a></td>
<td><pre>     * For any two &lt;tt&gt;boolean&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4010" href="#"></a></td>
<td><pre>     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4011" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4012" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4013" href="#"></a></td>
<td><pre>     * &lt;p&gt;The value returned by this method is the same value that would be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4014" href="#"></a></td>
<td><pre>     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4015" href="#"></a></td>
<td><pre>     * method on a {@link List} containing a sequence of {@link Boolean}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4016" href="#"></a></td>
<td><pre>     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4017" href="#"></a></td>
<td><pre>     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4018" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4019" href="#"></a></td>
<td><pre>     * @param a the array whose hash value to compute</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4020" href="#"></a></td>
<td><pre>     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4021" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4022" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4023" href="#"></a></td>
<td><pre>    public static int hashCode(boolean a[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4024" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4025" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4026" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4027" href="#"></a></td>
<td><pre>        int result = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4028" href="#"></a></td>
<td><pre>        for (boolean element : a)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4029" href="#"></a></td>
<td><pre>            result = 31 * result + (element ? 1231 : 1237);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4030" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4031" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4032" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4033" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4034" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4035" href="#"></a></td>
<td><pre>     * Returns a hash code based on the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4036" href="#"></a></td>
<td><pre>     * For any two &lt;tt&gt;float&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4037" href="#"></a></td>
<td><pre>     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4038" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4039" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4040" href="#"></a></td>
<td><pre>     * &lt;p&gt;The value returned by this method is the same value that would be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4041" href="#"></a></td>
<td><pre>     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4042" href="#"></a></td>
<td><pre>     * method on a {@link List} containing a sequence of {@link Float}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4043" href="#"></a></td>
<td><pre>     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4044" href="#"></a></td>
<td><pre>     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4045" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4046" href="#"></a></td>
<td><pre>     * @param a the array whose hash value to compute</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4047" href="#"></a></td>
<td><pre>     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4048" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4049" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4050" href="#"></a></td>
<td><pre>    public static int hashCode(float a[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4051" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4052" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4053" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4054" href="#"></a></td>
<td><pre>        int result = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4055" href="#"></a></td>
<td><pre>        for (float element : a)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4056" href="#"></a></td>
<td><pre>            result = 31 * result + Float.floatToIntBits(element);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4057" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4058" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4059" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4060" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4061" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4062" href="#"></a></td>
<td><pre>     * Returns a hash code based on the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4063" href="#"></a></td>
<td><pre>     * For any two &lt;tt&gt;double&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4064" href="#"></a></td>
<td><pre>     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4065" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4066" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4067" href="#"></a></td>
<td><pre>     * &lt;p&gt;The value returned by this method is the same value that would be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4068" href="#"></a></td>
<td><pre>     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4069" href="#"></a></td>
<td><pre>     * method on a {@link List} containing a sequence of {@link Double}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4070" href="#"></a></td>
<td><pre>     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4071" href="#"></a></td>
<td><pre>     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4072" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4073" href="#"></a></td>
<td><pre>     * @param a the array whose hash value to compute</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4074" href="#"></a></td>
<td><pre>     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4075" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4076" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4077" href="#"></a></td>
<td><pre>    public static int hashCode(double a[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4078" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4079" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4080" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4081" href="#"></a></td>
<td><pre>        int result = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4082" href="#"></a></td>
<td><pre>        for (double element : a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4083" href="#"></a></td>
<td><pre>            long bits = Double.doubleToLongBits(element);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4084" href="#"></a></td>
<td><pre>            result = 31 * result + (int)(bits ^ (bits &gt;&gt;&gt; 32));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4085" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4086" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4087" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4088" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4089" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4090" href="#"></a></td>
<td><pre>     * Returns a hash code based on the contents of the specified array.  If</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4091" href="#"></a></td>
<td><pre>     * the array contains other arrays as elements, the hash code is based on</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4092" href="#"></a></td>
<td><pre>     * their identities rather than their contents.  It is therefore</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4093" href="#"></a></td>
<td><pre>     * acceptable to invoke this method on an array that contains itself as an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4094" href="#"></a></td>
<td><pre>     * element,  either directly or indirectly through one or more levels of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4095" href="#"></a></td>
<td><pre>     * arrays.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4096" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4097" href="#"></a></td>
<td><pre>     * &lt;p&gt;For any two arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt; such that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4098" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4099" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4100" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4101" href="#"></a></td>
<td><pre>     * &lt;p&gt;The value returned by this method is equal to the value that would</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4102" href="#"></a></td>
<td><pre>     * be returned by &lt;tt&gt;Arrays.asList(a).hashCode()&lt;/tt&gt;, unless &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4103" href="#"></a></td>
<td><pre>     * is &lt;tt&gt;null&lt;/tt&gt;, in which case &lt;tt&gt;0&lt;/tt&gt; is returned.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4104" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4105" href="#"></a></td>
<td><pre>     * @param a the array whose content-based hash code to compute</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4106" href="#"></a></td>
<td><pre>     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4107" href="#"></a></td>
<td><pre>     * @see #deepHashCode(Object[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4108" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4109" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4110" href="#"></a></td>
<td><pre>    public static int hashCode(Object a[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4111" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4112" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4113" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4114" href="#"></a></td>
<td><pre>        int result = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4115" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4116" href="#"></a></td>
<td><pre>        for (Object element : a)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4117" href="#"></a></td>
<td><pre>            result = 31 * result + (element == null ? 0 : element.hashCode());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4118" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4119" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4120" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4121" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4122" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4123" href="#"></a></td>
<td><pre>     * Returns a hash code based on the &quot;deep contents&quot; of the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4124" href="#"></a></td>
<td><pre>     * array.  If the array contains other arrays as elements, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4125" href="#"></a></td>
<td><pre>     * hash code is based on their contents and so on, ad infinitum.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4126" href="#"></a></td>
<td><pre>     * It is therefore unacceptable to invoke this method on an array that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4127" href="#"></a></td>
<td><pre>     * contains itself as an element, either directly or indirectly through</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4128" href="#"></a></td>
<td><pre>     * one or more levels of arrays.  The behavior of such an invocation is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4129" href="#"></a></td>
<td><pre>     * undefined.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4130" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4131" href="#"></a></td>
<td><pre>     * &lt;p&gt;For any two arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt; such that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4132" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Arrays.deepEquals(a, b)&lt;/tt&gt;, it is also the case that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4133" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Arrays.deepHashCode(a) == Arrays.deepHashCode(b)&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4134" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4135" href="#"></a></td>
<td><pre>     * &lt;p&gt;The computation of the value returned by this method is similar to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4136" href="#"></a></td>
<td><pre>     * that of the value returned by {@link List#hashCode()} on a list</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4137" href="#"></a></td>
<td><pre>     * containing the same elements as &lt;tt&gt;a&lt;/tt&gt; in the same order, with one</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4138" href="#"></a></td>
<td><pre>     * difference: If an element &lt;tt&gt;e&lt;/tt&gt; of &lt;tt&gt;a&lt;/tt&gt; is itself an array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4139" href="#"></a></td>
<td><pre>     * its hash code is computed not by calling &lt;tt&gt;e.hashCode()&lt;/tt&gt;, but as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4140" href="#"></a></td>
<td><pre>     * by calling the appropriate overloading of &lt;tt&gt;Arrays.hashCode(e)&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4141" href="#"></a></td>
<td><pre>     * if &lt;tt&gt;e&lt;/tt&gt; is an array of a primitive type, or as by calling</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4142" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Arrays.deepHashCode(e)&lt;/tt&gt; recursively if &lt;tt&gt;e&lt;/tt&gt; is an array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4143" href="#"></a></td>
<td><pre>     * of a reference type.  If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4144" href="#"></a></td>
<td><pre>     * returns 0.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4145" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4146" href="#"></a></td>
<td><pre>     * @param a the array whose deep-content-based hash code to compute</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4147" href="#"></a></td>
<td><pre>     * @return a deep-content-based hash code for &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4148" href="#"></a></td>
<td><pre>     * @see #hashCode(Object[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4149" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4150" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4151" href="#"></a></td>
<td><pre>    public static int deepHashCode(Object a[]) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4152" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4153" href="#"></a></td>
<td><pre>            return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4154" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4155" href="#"></a></td>
<td><pre>        int result = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4156" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4157" href="#"></a></td>
<td><pre>        for (Object element : a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4158" href="#"></a></td>
<td><pre>            int elementHash = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4159" href="#"></a></td>
<td><pre>            if (element instanceof Object[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4160" href="#"></a></td>
<td><pre>                elementHash = deepHashCode((Object[]) element);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4161" href="#"></a></td>
<td><pre>            else if (element instanceof byte[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4162" href="#"></a></td>
<td><pre>                elementHash = hashCode((byte[]) element);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4163" href="#"></a></td>
<td><pre>            else if (element instanceof short[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4164" href="#"></a></td>
<td><pre>                elementHash = hashCode((short[]) element);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4165" href="#"></a></td>
<td><pre>            else if (element instanceof int[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4166" href="#"></a></td>
<td><pre>                elementHash = hashCode((int[]) element);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4167" href="#"></a></td>
<td><pre>            else if (element instanceof long[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4168" href="#"></a></td>
<td><pre>                elementHash = hashCode((long[]) element);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4169" href="#"></a></td>
<td><pre>            else if (element instanceof char[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4170" href="#"></a></td>
<td><pre>                elementHash = hashCode((char[]) element);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4171" href="#"></a></td>
<td><pre>            else if (element instanceof float[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4172" href="#"></a></td>
<td><pre>                elementHash = hashCode((float[]) element);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4173" href="#"></a></td>
<td><pre>            else if (element instanceof double[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4174" href="#"></a></td>
<td><pre>                elementHash = hashCode((double[]) element);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4175" href="#"></a></td>
<td><pre>            else if (element instanceof boolean[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4176" href="#"></a></td>
<td><pre>                elementHash = hashCode((boolean[]) element);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4177" href="#"></a></td>
<td><pre>            else if (element != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4178" href="#"></a></td>
<td><pre>                elementHash = element.hashCode();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4179" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4180" href="#"></a></td>
<td><pre>            result = 31 * result + elementHash;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4181" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4182" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4183" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4184" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4185" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4186" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4187" href="#"></a></td>
<td><pre>     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays are &lt;i&gt;deeply</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4188" href="#"></a></td>
<td><pre>     * equal&lt;/i&gt; to one another.  Unlike the {@link #equals(Object[],Object[])}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4189" href="#"></a></td>
<td><pre>     * method, this method is appropriate for use with nested arrays of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4190" href="#"></a></td>
<td><pre>     * arbitrary depth.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4191" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4192" href="#"></a></td>
<td><pre>     * &lt;p&gt;Two array references are considered deeply equal if both</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4193" href="#"></a></td>
<td><pre>     * are &lt;tt&gt;null&lt;/tt&gt;, or if they refer to arrays that contain the same</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4194" href="#"></a></td>
<td><pre>     * number of elements and all corresponding pairs of elements in the two</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4195" href="#"></a></td>
<td><pre>     * arrays are deeply equal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4196" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4197" href="#"></a></td>
<td><pre>     * &lt;p&gt;Two possibly &lt;tt&gt;null&lt;/tt&gt; elements &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4198" href="#"></a></td>
<td><pre>     * deeply equal if any of the following conditions hold:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4199" href="#"></a></td>
<td><pre>     * &lt;ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4200" href="#"></a></td>
<td><pre>     *    &lt;li&gt; &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; are both arrays of object reference</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4201" href="#"></a></td>
<td><pre>     *         types, and &lt;tt&gt;Arrays.deepEquals(e1, e2) would return true&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4202" href="#"></a></td>
<td><pre>     *    &lt;li&gt; &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; are arrays of the same primitive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4203" href="#"></a></td>
<td><pre>     *         type, and the appropriate overloading of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4204" href="#"></a></td>
<td><pre>     *         &lt;tt&gt;Arrays.equals(e1, e2)&lt;/tt&gt; would return true.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4205" href="#"></a></td>
<td><pre>     *    &lt;li&gt; &lt;tt&gt;e1 == e2&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4206" href="#"></a></td>
<td><pre>     *    &lt;li&gt; &lt;tt&gt;e1.equals(e2)&lt;/tt&gt; would return true.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4207" href="#"></a></td>
<td><pre>     * &lt;/ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4208" href="#"></a></td>
<td><pre>     * Note that this definition permits &lt;tt&gt;null&lt;/tt&gt; elements at any depth.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4209" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4210" href="#"></a></td>
<td><pre>     * &lt;p&gt;If either of the specified arrays contain themselves as elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4211" href="#"></a></td>
<td><pre>     * either directly or indirectly through one or more levels of arrays,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4212" href="#"></a></td>
<td><pre>     * the behavior of this method is undefined.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4213" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4214" href="#"></a></td>
<td><pre>     * @param a1 one array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4215" href="#"></a></td>
<td><pre>     * @param a2 the other array to be tested for equality</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4216" href="#"></a></td>
<td><pre>     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4217" href="#"></a></td>
<td><pre>     * @see #equals(Object[],Object[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4218" href="#"></a></td>
<td><pre>     * @see Objects#deepEquals(Object, Object)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4219" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4220" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4221" href="#"></a></td>
<td><pre>    public static boolean deepEquals(Object[] a1, Object[] a2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4222" href="#"></a></td>
<td><pre>        if (a1 == a2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4223" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4224" href="#"></a></td>
<td><pre>        if (a1 == null || a2==null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4225" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4226" href="#"></a></td>
<td><pre>        int length = a1.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4227" href="#"></a></td>
<td><pre>        if (a2.length != length)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4228" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4229" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4230" href="#"></a></td>
<td><pre>        for (int i = 0; i &lt; length; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4231" href="#"></a></td>
<td><pre>            Object e1 = a1[i];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4232" href="#"></a></td>
<td><pre>            Object e2 = a2[i];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4233" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4234" href="#"></a></td>
<td><pre>            if (e1 == e2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4235" href="#"></a></td>
<td><pre>                continue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4236" href="#"></a></td>
<td><pre>            if (e1 == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4237" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4238" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4239" href="#"></a></td>
<td><pre>            // Figure out whether the two elements are equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4240" href="#"></a></td>
<td><pre>            boolean eq = deepEquals0(e1, e2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4241" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4242" href="#"></a></td>
<td><pre>            if (!eq)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4243" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4244" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4245" href="#"></a></td>
<td><pre>        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4246" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4247" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4248" href="#"></a></td>
<td><pre>    static boolean deepEquals0(Object e1, Object e2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4249" href="#"></a></td>
<td><pre>        assert e1 != null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4250" href="#"></a></td>
<td><pre>        boolean eq;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4251" href="#"></a></td>
<td><pre>        if (e1 instanceof Object[] &amp;&amp; e2 instanceof Object[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4252" href="#"></a></td>
<td><pre>            eq = deepEquals ((Object[]) e1, (Object[]) e2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4253" href="#"></a></td>
<td><pre>        else if (e1 instanceof byte[] &amp;&amp; e2 instanceof byte[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4254" href="#"></a></td>
<td><pre>            eq = equals((byte[]) e1, (byte[]) e2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4255" href="#"></a></td>
<td><pre>        else if (e1 instanceof short[] &amp;&amp; e2 instanceof short[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4256" href="#"></a></td>
<td><pre>            eq = equals((short[]) e1, (short[]) e2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4257" href="#"></a></td>
<td><pre>        else if (e1 instanceof int[] &amp;&amp; e2 instanceof int[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4258" href="#"></a></td>
<td><pre>            eq = equals((int[]) e1, (int[]) e2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4259" href="#"></a></td>
<td><pre>        else if (e1 instanceof long[] &amp;&amp; e2 instanceof long[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4260" href="#"></a></td>
<td><pre>            eq = equals((long[]) e1, (long[]) e2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4261" href="#"></a></td>
<td><pre>        else if (e1 instanceof char[] &amp;&amp; e2 instanceof char[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4262" href="#"></a></td>
<td><pre>            eq = equals((char[]) e1, (char[]) e2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4263" href="#"></a></td>
<td><pre>        else if (e1 instanceof float[] &amp;&amp; e2 instanceof float[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4264" href="#"></a></td>
<td><pre>            eq = equals((float[]) e1, (float[]) e2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4265" href="#"></a></td>
<td><pre>        else if (e1 instanceof double[] &amp;&amp; e2 instanceof double[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4266" href="#"></a></td>
<td><pre>            eq = equals((double[]) e1, (double[]) e2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4267" href="#"></a></td>
<td><pre>        else if (e1 instanceof boolean[] &amp;&amp; e2 instanceof boolean[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4268" href="#"></a></td>
<td><pre>            eq = equals((boolean[]) e1, (boolean[]) e2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4269" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4270" href="#"></a></td>
<td><pre>            eq = e1.equals(e2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4271" href="#"></a></td>
<td><pre>        return eq;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4272" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4273" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4274" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4275" href="#"></a></td>
<td><pre>     * Returns a string representation of the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4276" href="#"></a></td>
<td><pre>     * The string representation consists of a list of the array's elements,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4277" href="#"></a></td>
<td><pre>     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4278" href="#"></a></td>
<td><pre>     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4279" href="#"></a></td>
<td><pre>     * space).  Elements are converted to strings as by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4280" href="#"></a></td>
<td><pre>     * &lt;tt&gt;String.valueOf(long)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4281" href="#"></a></td>
<td><pre>     * is &lt;tt&gt;null&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4282" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4283" href="#"></a></td>
<td><pre>     * @param a the array whose string representation to return</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4284" href="#"></a></td>
<td><pre>     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4285" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4286" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4287" href="#"></a></td>
<td><pre>    public static String toString(long[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4288" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4289" href="#"></a></td>
<td><pre>            return &quot;null&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4290" href="#"></a></td>
<td><pre>        int iMax = a.length - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4291" href="#"></a></td>
<td><pre>        if (iMax == -1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4292" href="#"></a></td>
<td><pre>            return &quot;[]&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4293" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4294" href="#"></a></td>
<td><pre>        StringBuilder b = new StringBuilder();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4295" href="#"></a></td>
<td><pre>        b.append('[');</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4296" href="#"></a></td>
<td><pre>        for (int i = 0; ; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4297" href="#"></a></td>
<td><pre>            b.append(a[i]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4298" href="#"></a></td>
<td><pre>            if (i == iMax)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4299" href="#"></a></td>
<td><pre>                return b.append(']').toString();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4300" href="#"></a></td>
<td><pre>            b.append(&quot;, &quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4301" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4302" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4303" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4304" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4305" href="#"></a></td>
<td><pre>     * Returns a string representation of the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4306" href="#"></a></td>
<td><pre>     * The string representation consists of a list of the array's elements,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4307" href="#"></a></td>
<td><pre>     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4308" href="#"></a></td>
<td><pre>     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4309" href="#"></a></td>
<td><pre>     * space).  Elements are converted to strings as by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4310" href="#"></a></td>
<td><pre>     * &lt;tt&gt;String.valueOf(int)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt; is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4311" href="#"></a></td>
<td><pre>     * &lt;tt&gt;null&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4312" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4313" href="#"></a></td>
<td><pre>     * @param a the array whose string representation to return</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4314" href="#"></a></td>
<td><pre>     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4315" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4316" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4317" href="#"></a></td>
<td><pre>    public static String toString(int[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4318" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4319" href="#"></a></td>
<td><pre>            return &quot;null&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4320" href="#"></a></td>
<td><pre>        int iMax = a.length - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4321" href="#"></a></td>
<td><pre>        if (iMax == -1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4322" href="#"></a></td>
<td><pre>            return &quot;[]&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4323" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4324" href="#"></a></td>
<td><pre>        StringBuilder b = new StringBuilder();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4325" href="#"></a></td>
<td><pre>        b.append('[');</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4326" href="#"></a></td>
<td><pre>        for (int i = 0; ; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4327" href="#"></a></td>
<td><pre>            b.append(a[i]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4328" href="#"></a></td>
<td><pre>            if (i == iMax)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4329" href="#"></a></td>
<td><pre>                return b.append(']').toString();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4330" href="#"></a></td>
<td><pre>            b.append(&quot;, &quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4331" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4332" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4333" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4334" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4335" href="#"></a></td>
<td><pre>     * Returns a string representation of the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4336" href="#"></a></td>
<td><pre>     * The string representation consists of a list of the array's elements,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4337" href="#"></a></td>
<td><pre>     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4338" href="#"></a></td>
<td><pre>     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4339" href="#"></a></td>
<td><pre>     * space).  Elements are converted to strings as by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4340" href="#"></a></td>
<td><pre>     * &lt;tt&gt;String.valueOf(short)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4341" href="#"></a></td>
<td><pre>     * is &lt;tt&gt;null&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4342" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4343" href="#"></a></td>
<td><pre>     * @param a the array whose string representation to return</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4344" href="#"></a></td>
<td><pre>     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4345" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4346" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4347" href="#"></a></td>
<td><pre>    public static String toString(short[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4348" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4349" href="#"></a></td>
<td><pre>            return &quot;null&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4350" href="#"></a></td>
<td><pre>        int iMax = a.length - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4351" href="#"></a></td>
<td><pre>        if (iMax == -1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4352" href="#"></a></td>
<td><pre>            return &quot;[]&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4353" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4354" href="#"></a></td>
<td><pre>        StringBuilder b = new StringBuilder();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4355" href="#"></a></td>
<td><pre>        b.append('[');</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4356" href="#"></a></td>
<td><pre>        for (int i = 0; ; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4357" href="#"></a></td>
<td><pre>            b.append(a[i]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4358" href="#"></a></td>
<td><pre>            if (i == iMax)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4359" href="#"></a></td>
<td><pre>                return b.append(']').toString();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4360" href="#"></a></td>
<td><pre>            b.append(&quot;, &quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4361" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4362" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4363" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4364" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4365" href="#"></a></td>
<td><pre>     * Returns a string representation of the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4366" href="#"></a></td>
<td><pre>     * The string representation consists of a list of the array's elements,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4367" href="#"></a></td>
<td><pre>     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4368" href="#"></a></td>
<td><pre>     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4369" href="#"></a></td>
<td><pre>     * space).  Elements are converted to strings as by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4370" href="#"></a></td>
<td><pre>     * &lt;tt&gt;String.valueOf(char)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4371" href="#"></a></td>
<td><pre>     * is &lt;tt&gt;null&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4372" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4373" href="#"></a></td>
<td><pre>     * @param a the array whose string representation to return</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4374" href="#"></a></td>
<td><pre>     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4375" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4376" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4377" href="#"></a></td>
<td><pre>    public static String toString(char[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4378" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4379" href="#"></a></td>
<td><pre>            return &quot;null&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4380" href="#"></a></td>
<td><pre>        int iMax = a.length - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4381" href="#"></a></td>
<td><pre>        if (iMax == -1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4382" href="#"></a></td>
<td><pre>            return &quot;[]&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4383" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4384" href="#"></a></td>
<td><pre>        StringBuilder b = new StringBuilder();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4385" href="#"></a></td>
<td><pre>        b.append('[');</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4386" href="#"></a></td>
<td><pre>        for (int i = 0; ; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4387" href="#"></a></td>
<td><pre>            b.append(a[i]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4388" href="#"></a></td>
<td><pre>            if (i == iMax)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4389" href="#"></a></td>
<td><pre>                return b.append(']').toString();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4390" href="#"></a></td>
<td><pre>            b.append(&quot;, &quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4391" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4392" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4393" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4394" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4395" href="#"></a></td>
<td><pre>     * Returns a string representation of the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4396" href="#"></a></td>
<td><pre>     * The string representation consists of a list of the array's elements,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4397" href="#"></a></td>
<td><pre>     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4398" href="#"></a></td>
<td><pre>     * are separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4399" href="#"></a></td>
<td><pre>     * by a space).  Elements are converted to strings as by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4400" href="#"></a></td>
<td><pre>     * &lt;tt&gt;String.valueOf(byte)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4401" href="#"></a></td>
<td><pre>     * &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4402" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4403" href="#"></a></td>
<td><pre>     * @param a the array whose string representation to return</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4404" href="#"></a></td>
<td><pre>     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4405" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4406" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4407" href="#"></a></td>
<td><pre>    public static String toString(byte[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4408" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4409" href="#"></a></td>
<td><pre>            return &quot;null&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4410" href="#"></a></td>
<td><pre>        int iMax = a.length - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4411" href="#"></a></td>
<td><pre>        if (iMax == -1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4412" href="#"></a></td>
<td><pre>            return &quot;[]&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4413" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4414" href="#"></a></td>
<td><pre>        StringBuilder b = new StringBuilder();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4415" href="#"></a></td>
<td><pre>        b.append('[');</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4416" href="#"></a></td>
<td><pre>        for (int i = 0; ; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4417" href="#"></a></td>
<td><pre>            b.append(a[i]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4418" href="#"></a></td>
<td><pre>            if (i == iMax)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4419" href="#"></a></td>
<td><pre>                return b.append(']').toString();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4420" href="#"></a></td>
<td><pre>            b.append(&quot;, &quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4421" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4422" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4423" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4424" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4425" href="#"></a></td>
<td><pre>     * Returns a string representation of the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4426" href="#"></a></td>
<td><pre>     * The string representation consists of a list of the array's elements,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4427" href="#"></a></td>
<td><pre>     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4428" href="#"></a></td>
<td><pre>     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4429" href="#"></a></td>
<td><pre>     * space).  Elements are converted to strings as by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4430" href="#"></a></td>
<td><pre>     * &lt;tt&gt;String.valueOf(boolean)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4431" href="#"></a></td>
<td><pre>     * &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4432" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4433" href="#"></a></td>
<td><pre>     * @param a the array whose string representation to return</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4434" href="#"></a></td>
<td><pre>     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4435" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4436" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4437" href="#"></a></td>
<td><pre>    public static String toString(boolean[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4438" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4439" href="#"></a></td>
<td><pre>            return &quot;null&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4440" href="#"></a></td>
<td><pre>        int iMax = a.length - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4441" href="#"></a></td>
<td><pre>        if (iMax == -1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4442" href="#"></a></td>
<td><pre>            return &quot;[]&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4443" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4444" href="#"></a></td>
<td><pre>        StringBuilder b = new StringBuilder();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4445" href="#"></a></td>
<td><pre>        b.append('[');</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4446" href="#"></a></td>
<td><pre>        for (int i = 0; ; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4447" href="#"></a></td>
<td><pre>            b.append(a[i]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4448" href="#"></a></td>
<td><pre>            if (i == iMax)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4449" href="#"></a></td>
<td><pre>                return b.append(']').toString();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4450" href="#"></a></td>
<td><pre>            b.append(&quot;, &quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4451" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4452" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4453" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4454" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4455" href="#"></a></td>
<td><pre>     * Returns a string representation of the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4456" href="#"></a></td>
<td><pre>     * The string representation consists of a list of the array's elements,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4457" href="#"></a></td>
<td><pre>     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4458" href="#"></a></td>
<td><pre>     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4459" href="#"></a></td>
<td><pre>     * space).  Elements are converted to strings as by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4460" href="#"></a></td>
<td><pre>     * &lt;tt&gt;String.valueOf(float)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4461" href="#"></a></td>
<td><pre>     * is &lt;tt&gt;null&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4462" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4463" href="#"></a></td>
<td><pre>     * @param a the array whose string representation to return</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4464" href="#"></a></td>
<td><pre>     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4465" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4466" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4467" href="#"></a></td>
<td><pre>    public static String toString(float[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4468" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4469" href="#"></a></td>
<td><pre>            return &quot;null&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4470" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4471" href="#"></a></td>
<td><pre>        int iMax = a.length - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4472" href="#"></a></td>
<td><pre>        if (iMax == -1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4473" href="#"></a></td>
<td><pre>            return &quot;[]&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4474" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4475" href="#"></a></td>
<td><pre>        StringBuilder b = new StringBuilder();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4476" href="#"></a></td>
<td><pre>        b.append('[');</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4477" href="#"></a></td>
<td><pre>        for (int i = 0; ; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4478" href="#"></a></td>
<td><pre>            b.append(a[i]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4479" href="#"></a></td>
<td><pre>            if (i == iMax)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4480" href="#"></a></td>
<td><pre>                return b.append(']').toString();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4481" href="#"></a></td>
<td><pre>            b.append(&quot;, &quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4482" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4483" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4484" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4485" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4486" href="#"></a></td>
<td><pre>     * Returns a string representation of the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4487" href="#"></a></td>
<td><pre>     * The string representation consists of a list of the array's elements,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4488" href="#"></a></td>
<td><pre>     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4489" href="#"></a></td>
<td><pre>     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4490" href="#"></a></td>
<td><pre>     * space).  Elements are converted to strings as by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4491" href="#"></a></td>
<td><pre>     * &lt;tt&gt;String.valueOf(double)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4492" href="#"></a></td>
<td><pre>     * is &lt;tt&gt;null&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4493" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4494" href="#"></a></td>
<td><pre>     * @param a the array whose string representation to return</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4495" href="#"></a></td>
<td><pre>     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4496" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4497" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4498" href="#"></a></td>
<td><pre>    public static String toString(double[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4499" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4500" href="#"></a></td>
<td><pre>            return &quot;null&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4501" href="#"></a></td>
<td><pre>        int iMax = a.length - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4502" href="#"></a></td>
<td><pre>        if (iMax == -1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4503" href="#"></a></td>
<td><pre>            return &quot;[]&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4504" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4505" href="#"></a></td>
<td><pre>        StringBuilder b = new StringBuilder();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4506" href="#"></a></td>
<td><pre>        b.append('[');</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4507" href="#"></a></td>
<td><pre>        for (int i = 0; ; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4508" href="#"></a></td>
<td><pre>            b.append(a[i]);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4509" href="#"></a></td>
<td><pre>            if (i == iMax)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4510" href="#"></a></td>
<td><pre>                return b.append(']').toString();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4511" href="#"></a></td>
<td><pre>            b.append(&quot;, &quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4512" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4513" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4514" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4515" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4516" href="#"></a></td>
<td><pre>     * Returns a string representation of the contents of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4517" href="#"></a></td>
<td><pre>     * If the array contains other arrays as elements, they are converted to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4518" href="#"></a></td>
<td><pre>     * strings by the {@link Object#toString} method inherited from</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4519" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Object&lt;/tt&gt;, which describes their &lt;i&gt;identities&lt;/i&gt; rather than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4520" href="#"></a></td>
<td><pre>     * their contents.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4521" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4522" href="#"></a></td>
<td><pre>     * &lt;p&gt;The value returned by this method is equal to the value that would</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4523" href="#"></a></td>
<td><pre>     * be returned by &lt;tt&gt;Arrays.asList(a).toString()&lt;/tt&gt;, unless &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4524" href="#"></a></td>
<td><pre>     * is &lt;tt&gt;null&lt;/tt&gt;, in which case &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; is returned.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4525" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4526" href="#"></a></td>
<td><pre>     * @param a the array whose string representation to return</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4527" href="#"></a></td>
<td><pre>     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4528" href="#"></a></td>
<td><pre>     * @see #deepToString(Object[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4529" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4530" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4531" href="#"></a></td>
<td><pre>    public static String toString(Object[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4532" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4533" href="#"></a></td>
<td><pre>            return &quot;null&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4534" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4535" href="#"></a></td>
<td><pre>        int iMax = a.length - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4536" href="#"></a></td>
<td><pre>        if (iMax == -1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4537" href="#"></a></td>
<td><pre>            return &quot;[]&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4538" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4539" href="#"></a></td>
<td><pre>        StringBuilder b = new StringBuilder();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4540" href="#"></a></td>
<td><pre>        b.append('[');</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4541" href="#"></a></td>
<td><pre>        for (int i = 0; ; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4542" href="#"></a></td>
<td><pre>            b.append(String.valueOf(a[i]));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4543" href="#"></a></td>
<td><pre>            if (i == iMax)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4544" href="#"></a></td>
<td><pre>                return b.append(']').toString();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4545" href="#"></a></td>
<td><pre>            b.append(&quot;, &quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4546" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4547" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4548" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4549" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4550" href="#"></a></td>
<td><pre>     * Returns a string representation of the &quot;deep contents&quot; of the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4551" href="#"></a></td>
<td><pre>     * array.  If the array contains other arrays as elements, the string</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4552" href="#"></a></td>
<td><pre>     * representation contains their contents and so on.  This method is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4553" href="#"></a></td>
<td><pre>     * designed for converting multidimensional arrays to strings.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4554" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4555" href="#"></a></td>
<td><pre>     * &lt;p&gt;The string representation consists of a list of the array's</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4556" href="#"></a></td>
<td><pre>     * elements, enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4557" href="#"></a></td>
<td><pre>     * elements are separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4558" href="#"></a></td>
<td><pre>     * followed by a space).  Elements are converted to strings as by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4559" href="#"></a></td>
<td><pre>     * &lt;tt&gt;String.valueOf(Object)&lt;/tt&gt;, unless they are themselves</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4560" href="#"></a></td>
<td><pre>     * arrays.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4561" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4562" href="#"></a></td>
<td><pre>     * &lt;p&gt;If an element &lt;tt&gt;e&lt;/tt&gt; is an array of a primitive type, it is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4563" href="#"></a></td>
<td><pre>     * converted to a string as by invoking the appropriate overloading of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4564" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Arrays.toString(e)&lt;/tt&gt;.  If an element &lt;tt&gt;e&lt;/tt&gt; is an array of a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4565" href="#"></a></td>
<td><pre>     * reference type, it is converted to a string as by invoking</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4566" href="#"></a></td>
<td><pre>     * this method recursively.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4567" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4568" href="#"></a></td>
<td><pre>     * &lt;p&gt;To avoid infinite recursion, if the specified array contains itself</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4569" href="#"></a></td>
<td><pre>     * as an element, or contains an indirect reference to itself through one</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4570" href="#"></a></td>
<td><pre>     * or more levels of arrays, the self-reference is converted to the string</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4571" href="#"></a></td>
<td><pre>     * &lt;tt&gt;&quot;[...]&quot;&lt;/tt&gt;.  For example, an array containing only a reference</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4572" href="#"></a></td>
<td><pre>     * to itself would be rendered as &lt;tt&gt;&quot;[[...]]&quot;&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4573" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4574" href="#"></a></td>
<td><pre>     * &lt;p&gt;This method returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if the specified array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4575" href="#"></a></td>
<td><pre>     * is &lt;tt&gt;null&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4576" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4577" href="#"></a></td>
<td><pre>     * @param a the array whose string representation to return</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4578" href="#"></a></td>
<td><pre>     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4579" href="#"></a></td>
<td><pre>     * @see #toString(Object[])</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4580" href="#"></a></td>
<td><pre>     * @since 1.5</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4581" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4582" href="#"></a></td>
<td><pre>    public static String deepToString(Object[] a) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4583" href="#"></a></td>
<td><pre>        if (a == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4584" href="#"></a></td>
<td><pre>            return &quot;null&quot;;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4585" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4586" href="#"></a></td>
<td><pre>        int bufLen = 20 * a.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4587" href="#"></a></td>
<td><pre>        if (a.length != 0 &amp;&amp; bufLen &lt;= 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4588" href="#"></a></td>
<td><pre>            bufLen = Integer.MAX_VALUE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4589" href="#"></a></td>
<td><pre>        StringBuilder buf = new StringBuilder(bufLen);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4590" href="#"></a></td>
<td><pre>        deepToString(a, buf, new HashSet&lt;Object[]&gt;());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4591" href="#"></a></td>
<td><pre>        return buf.toString();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4592" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4593" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4594" href="#"></a></td>
<td><pre>    private static void deepToString(Object[] a, StringBuilder buf,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4595" href="#"></a></td>
<td><pre>                                     Set&lt;Object[]&gt; dejaVu) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4596" href="#"></a></td>
<td><pre>        if (a == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4597" href="#"></a></td>
<td><pre>            buf.append(&quot;null&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4598" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4599" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4600" href="#"></a></td>
<td><pre>        int iMax = a.length - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4601" href="#"></a></td>
<td><pre>        if (iMax == -1) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4602" href="#"></a></td>
<td><pre>            buf.append(&quot;[]&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4603" href="#"></a></td>
<td><pre>            return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4604" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4605" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4606" href="#"></a></td>
<td><pre>        dejaVu.add(a);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4607" href="#"></a></td>
<td><pre>        buf.append('[');</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4608" href="#"></a></td>
<td><pre>        for (int i = 0; ; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4609" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4610" href="#"></a></td>
<td><pre>            Object element = a[i];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4611" href="#"></a></td>
<td><pre>            if (element == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4612" href="#"></a></td>
<td><pre>                buf.append(&quot;null&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4613" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4614" href="#"></a></td>
<td><pre>                Class&lt;?&gt; eClass = element.getClass();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4615" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4616" href="#"></a></td>
<td><pre>                if (eClass.isArray()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4617" href="#"></a></td>
<td><pre>                    if (eClass == byte[].class)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4618" href="#"></a></td>
<td><pre>                        buf.append(toString((byte[]) element));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4619" href="#"></a></td>
<td><pre>                    else if (eClass == short[].class)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4620" href="#"></a></td>
<td><pre>                        buf.append(toString((short[]) element));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4621" href="#"></a></td>
<td><pre>                    else if (eClass == int[].class)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4622" href="#"></a></td>
<td><pre>                        buf.append(toString((int[]) element));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4623" href="#"></a></td>
<td><pre>                    else if (eClass == long[].class)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4624" href="#"></a></td>
<td><pre>                        buf.append(toString((long[]) element));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4625" href="#"></a></td>
<td><pre>                    else if (eClass == char[].class)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4626" href="#"></a></td>
<td><pre>                        buf.append(toString((char[]) element));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4627" href="#"></a></td>
<td><pre>                    else if (eClass == float[].class)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4628" href="#"></a></td>
<td><pre>                        buf.append(toString((float[]) element));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4629" href="#"></a></td>
<td><pre>                    else if (eClass == double[].class)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4630" href="#"></a></td>
<td><pre>                        buf.append(toString((double[]) element));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4631" href="#"></a></td>
<td><pre>                    else if (eClass == boolean[].class)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4632" href="#"></a></td>
<td><pre>                        buf.append(toString((boolean[]) element));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4633" href="#"></a></td>
<td><pre>                    else { // element is an array of object references</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4634" href="#"></a></td>
<td><pre>                        if (dejaVu.contains(element))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4635" href="#"></a></td>
<td><pre>                            buf.append(&quot;[...]&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4636" href="#"></a></td>
<td><pre>                        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4637" href="#"></a></td>
<td><pre>                            deepToString((Object[])element, buf, dejaVu);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4638" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4639" href="#"></a></td>
<td><pre>                } else {  // element is non-null and not an array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4640" href="#"></a></td>
<td><pre>                    buf.append(element.toString());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4641" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4642" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4643" href="#"></a></td>
<td><pre>            if (i == iMax)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4644" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4645" href="#"></a></td>
<td><pre>            buf.append(&quot;, &quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4646" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4647" href="#"></a></td>
<td><pre>        buf.append(']');</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4648" href="#"></a></td>
<td><pre>        dejaVu.remove(a);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4649" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4650" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4651" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4652" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4653" href="#"></a></td>
<td><pre>     * Set all elements of the specified array, using the provided</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4654" href="#"></a></td>
<td><pre>     * generator function to compute each element.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4655" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4656" href="#"></a></td>
<td><pre>     * &lt;p&gt;If the generator function throws an exception, it is relayed to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4657" href="#"></a></td>
<td><pre>     * the caller and the array is left in an indeterminate state.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4658" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4659" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; type of elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4660" href="#"></a></td>
<td><pre>     * @param array array to be initialized</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4661" href="#"></a></td>
<td><pre>     * @param generator a function accepting an index and producing the desired</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4662" href="#"></a></td>
<td><pre>     *        value for that position</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4663" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the generator is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4664" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4665" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4666" href="#"></a></td>
<td><pre>    public static &lt;T&gt; void setAll(T[] array, IntFunction&lt;? extends T&gt; generator) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4667" href="#"></a></td>
<td><pre>        Objects.requireNonNull(generator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4668" href="#"></a></td>
<td><pre>        for (int i = 0; i &lt; array.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4669" href="#"></a></td>
<td><pre>            array[i] = generator.apply(i);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4670" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4671" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4672" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4673" href="#"></a></td>
<td><pre>     * Set all elements of the specified array, in parallel, using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4674" href="#"></a></td>
<td><pre>     * provided generator function to compute each element.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4675" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4676" href="#"></a></td>
<td><pre>     * &lt;p&gt;If the generator function throws an exception, an unchecked exception</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4677" href="#"></a></td>
<td><pre>     * is thrown from {@code parallelSetAll} and the array is left in an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4678" href="#"></a></td>
<td><pre>     * indeterminate state.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4679" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4680" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; type of elements of the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4681" href="#"></a></td>
<td><pre>     * @param array array to be initialized</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4682" href="#"></a></td>
<td><pre>     * @param generator a function accepting an index and producing the desired</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4683" href="#"></a></td>
<td><pre>     *        value for that position</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4684" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the generator is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4685" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4686" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4687" href="#"></a></td>
<td><pre>    public static &lt;T&gt; void parallelSetAll(T[] array, IntFunction&lt;? extends T&gt; generator) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4688" href="#"></a></td>
<td><pre>        Objects.requireNonNull(generator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4689" href="#"></a></td>
<td><pre>        IntStream.range(0, array.length).parallel().forEach(i -&gt; { array[i] = generator.apply(i); });</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4690" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4691" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4692" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4693" href="#"></a></td>
<td><pre>     * Set all elements of the specified array, using the provided</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4694" href="#"></a></td>
<td><pre>     * generator function to compute each element.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4695" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4696" href="#"></a></td>
<td><pre>     * &lt;p&gt;If the generator function throws an exception, it is relayed to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4697" href="#"></a></td>
<td><pre>     * the caller and the array is left in an indeterminate state.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4698" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4699" href="#"></a></td>
<td><pre>     * @param array array to be initialized</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4700" href="#"></a></td>
<td><pre>     * @param generator a function accepting an index and producing the desired</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4701" href="#"></a></td>
<td><pre>     *        value for that position</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4702" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the generator is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4703" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4704" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4705" href="#"></a></td>
<td><pre>    public static void setAll(int[] array, IntUnaryOperator generator) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4706" href="#"></a></td>
<td><pre>        Objects.requireNonNull(generator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4707" href="#"></a></td>
<td><pre>        for (int i = 0; i &lt; array.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4708" href="#"></a></td>
<td><pre>            array[i] = generator.applyAsInt(i);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4709" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4710" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4711" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4712" href="#"></a></td>
<td><pre>     * Set all elements of the specified array, in parallel, using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4713" href="#"></a></td>
<td><pre>     * provided generator function to compute each element.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4714" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4715" href="#"></a></td>
<td><pre>     * &lt;p&gt;If the generator function throws an exception, an unchecked exception</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4716" href="#"></a></td>
<td><pre>     * is thrown from {@code parallelSetAll} and the array is left in an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4717" href="#"></a></td>
<td><pre>     * indeterminate state.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4718" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4719" href="#"></a></td>
<td><pre>     * @param array array to be initialized</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4720" href="#"></a></td>
<td><pre>     * @param generator a function accepting an index and producing the desired</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4721" href="#"></a></td>
<td><pre>     * value for that position</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4722" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the generator is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4723" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4724" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4725" href="#"></a></td>
<td><pre>    public static void parallelSetAll(int[] array, IntUnaryOperator generator) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4726" href="#"></a></td>
<td><pre>        Objects.requireNonNull(generator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4727" href="#"></a></td>
<td><pre>        IntStream.range(0, array.length).parallel().forEach(i -&gt; { array[i] = generator.applyAsInt(i); });</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4728" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4729" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4730" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4731" href="#"></a></td>
<td><pre>     * Set all elements of the specified array, using the provided</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4732" href="#"></a></td>
<td><pre>     * generator function to compute each element.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4733" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4734" href="#"></a></td>
<td><pre>     * &lt;p&gt;If the generator function throws an exception, it is relayed to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4735" href="#"></a></td>
<td><pre>     * the caller and the array is left in an indeterminate state.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4736" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4737" href="#"></a></td>
<td><pre>     * @param array array to be initialized</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4738" href="#"></a></td>
<td><pre>     * @param generator a function accepting an index and producing the desired</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4739" href="#"></a></td>
<td><pre>     *        value for that position</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4740" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the generator is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4741" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4742" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4743" href="#"></a></td>
<td><pre>    public static void setAll(long[] array, IntToLongFunction generator) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4744" href="#"></a></td>
<td><pre>        Objects.requireNonNull(generator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4745" href="#"></a></td>
<td><pre>        for (int i = 0; i &lt; array.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4746" href="#"></a></td>
<td><pre>            array[i] = generator.applyAsLong(i);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4747" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4748" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4749" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4750" href="#"></a></td>
<td><pre>     * Set all elements of the specified array, in parallel, using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4751" href="#"></a></td>
<td><pre>     * provided generator function to compute each element.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4752" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4753" href="#"></a></td>
<td><pre>     * &lt;p&gt;If the generator function throws an exception, an unchecked exception</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4754" href="#"></a></td>
<td><pre>     * is thrown from {@code parallelSetAll} and the array is left in an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4755" href="#"></a></td>
<td><pre>     * indeterminate state.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4756" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4757" href="#"></a></td>
<td><pre>     * @param array array to be initialized</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4758" href="#"></a></td>
<td><pre>     * @param generator a function accepting an index and producing the desired</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4759" href="#"></a></td>
<td><pre>     *        value for that position</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4760" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the generator is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4761" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4762" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4763" href="#"></a></td>
<td><pre>    public static void parallelSetAll(long[] array, IntToLongFunction generator) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4764" href="#"></a></td>
<td><pre>        Objects.requireNonNull(generator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4765" href="#"></a></td>
<td><pre>        IntStream.range(0, array.length).parallel().forEach(i -&gt; { array[i] = generator.applyAsLong(i); });</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4766" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4767" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4768" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4769" href="#"></a></td>
<td><pre>     * Set all elements of the specified array, using the provided</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4770" href="#"></a></td>
<td><pre>     * generator function to compute each element.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4771" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4772" href="#"></a></td>
<td><pre>     * &lt;p&gt;If the generator function throws an exception, it is relayed to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4773" href="#"></a></td>
<td><pre>     * the caller and the array is left in an indeterminate state.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4774" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4775" href="#"></a></td>
<td><pre>     * @param array array to be initialized</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4776" href="#"></a></td>
<td><pre>     * @param generator a function accepting an index and producing the desired</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4777" href="#"></a></td>
<td><pre>     *        value for that position</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4778" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the generator is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4779" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4780" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4781" href="#"></a></td>
<td><pre>    public static void setAll(double[] array, IntToDoubleFunction generator) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4782" href="#"></a></td>
<td><pre>        Objects.requireNonNull(generator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4783" href="#"></a></td>
<td><pre>        for (int i = 0; i &lt; array.length; i++)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4784" href="#"></a></td>
<td><pre>            array[i] = generator.applyAsDouble(i);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4785" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4786" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4787" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4788" href="#"></a></td>
<td><pre>     * Set all elements of the specified array, in parallel, using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4789" href="#"></a></td>
<td><pre>     * provided generator function to compute each element.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4790" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4791" href="#"></a></td>
<td><pre>     * &lt;p&gt;If the generator function throws an exception, an unchecked exception</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4792" href="#"></a></td>
<td><pre>     * is thrown from {@code parallelSetAll} and the array is left in an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4793" href="#"></a></td>
<td><pre>     * indeterminate state.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4794" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4795" href="#"></a></td>
<td><pre>     * @param array array to be initialized</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4796" href="#"></a></td>
<td><pre>     * @param generator a function accepting an index and producing the desired</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4797" href="#"></a></td>
<td><pre>     *        value for that position</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4798" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the generator is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4799" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4800" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4801" href="#"></a></td>
<td><pre>    public static void parallelSetAll(double[] array, IntToDoubleFunction generator) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4802" href="#"></a></td>
<td><pre>        Objects.requireNonNull(generator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4803" href="#"></a></td>
<td><pre>        IntStream.range(0, array.length).parallel().forEach(i -&gt; { array[i] = generator.applyAsDouble(i); });</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4804" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4805" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4806" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4807" href="#"></a></td>
<td><pre>     * Returns a {@link Spliterator} covering all of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4808" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4809" href="#"></a></td>
<td><pre>     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4810" href="#"></a></td>
<td><pre>     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4811" href="#"></a></td>
<td><pre>     * {@link Spliterator#IMMUTABLE}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4812" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4813" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; type of elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4814" href="#"></a></td>
<td><pre>     * @param array the array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4815" href="#"></a></td>
<td><pre>     * @return a spliterator for the array elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4816" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4817" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4818" href="#"></a></td>
<td><pre>    public static &lt;T&gt; Spliterator&lt;T&gt; spliterator(T[] array) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4819" href="#"></a></td>
<td><pre>        return Spliterators.spliterator(array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4820" href="#"></a></td>
<td><pre>                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4821" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4822" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4823" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4824" href="#"></a></td>
<td><pre>     * Returns a {@link Spliterator} covering the specified range of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4825" href="#"></a></td>
<td><pre>     * specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4826" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4827" href="#"></a></td>
<td><pre>     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4828" href="#"></a></td>
<td><pre>     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4829" href="#"></a></td>
<td><pre>     * {@link Spliterator#IMMUTABLE}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4830" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4831" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; type of elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4832" href="#"></a></td>
<td><pre>     * @param array the array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4833" href="#"></a></td>
<td><pre>     * @param startInclusive the first index to cover, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4834" href="#"></a></td>
<td><pre>     * @param endExclusive index immediately past the last index to cover</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4835" href="#"></a></td>
<td><pre>     * @return a spliterator for the array elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4836" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4837" href="#"></a></td>
<td><pre>     *         negative, {@code endExclusive} is less than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4838" href="#"></a></td>
<td><pre>     *         {@code startInclusive}, or {@code endExclusive} is greater than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4839" href="#"></a></td>
<td><pre>     *         the array size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4840" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4841" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4842" href="#"></a></td>
<td><pre>    public static &lt;T&gt; Spliterator&lt;T&gt; spliterator(T[] array, int startInclusive, int endExclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4843" href="#"></a></td>
<td><pre>        return Spliterators.spliterator(array, startInclusive, endExclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4844" href="#"></a></td>
<td><pre>                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4845" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4846" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4847" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4848" href="#"></a></td>
<td><pre>     * Returns a {@link Spliterator.OfInt} covering all of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4849" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4850" href="#"></a></td>
<td><pre>     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4851" href="#"></a></td>
<td><pre>     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4852" href="#"></a></td>
<td><pre>     * {@link Spliterator#IMMUTABLE}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4853" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4854" href="#"></a></td>
<td><pre>     * @param array the array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4855" href="#"></a></td>
<td><pre>     * @return a spliterator for the array elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4856" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4857" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4858" href="#"></a></td>
<td><pre>    public static Spliterator.OfInt spliterator(int[] array) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4859" href="#"></a></td>
<td><pre>        return Spliterators.spliterator(array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4860" href="#"></a></td>
<td><pre>                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4861" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4862" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4863" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4864" href="#"></a></td>
<td><pre>     * Returns a {@link Spliterator.OfInt} covering the specified range of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4865" href="#"></a></td>
<td><pre>     * specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4866" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4867" href="#"></a></td>
<td><pre>     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4868" href="#"></a></td>
<td><pre>     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4869" href="#"></a></td>
<td><pre>     * {@link Spliterator#IMMUTABLE}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4870" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4871" href="#"></a></td>
<td><pre>     * @param array the array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4872" href="#"></a></td>
<td><pre>     * @param startInclusive the first index to cover, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4873" href="#"></a></td>
<td><pre>     * @param endExclusive index immediately past the last index to cover</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4874" href="#"></a></td>
<td><pre>     * @return a spliterator for the array elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4875" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4876" href="#"></a></td>
<td><pre>     *         negative, {@code endExclusive} is less than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4877" href="#"></a></td>
<td><pre>     *         {@code startInclusive}, or {@code endExclusive} is greater than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4878" href="#"></a></td>
<td><pre>     *         the array size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4879" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4880" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4881" href="#"></a></td>
<td><pre>    public static Spliterator.OfInt spliterator(int[] array, int startInclusive, int endExclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4882" href="#"></a></td>
<td><pre>        return Spliterators.spliterator(array, startInclusive, endExclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4883" href="#"></a></td>
<td><pre>                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4884" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4885" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4886" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4887" href="#"></a></td>
<td><pre>     * Returns a {@link Spliterator.OfLong} covering all of the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4888" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4889" href="#"></a></td>
<td><pre>     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4890" href="#"></a></td>
<td><pre>     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4891" href="#"></a></td>
<td><pre>     * {@link Spliterator#IMMUTABLE}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4892" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4893" href="#"></a></td>
<td><pre>     * @param array the array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4894" href="#"></a></td>
<td><pre>     * @return the spliterator for the array elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4895" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4896" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4897" href="#"></a></td>
<td><pre>    public static Spliterator.OfLong spliterator(long[] array) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4898" href="#"></a></td>
<td><pre>        return Spliterators.spliterator(array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4899" href="#"></a></td>
<td><pre>                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4900" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4901" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4902" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4903" href="#"></a></td>
<td><pre>     * Returns a {@link Spliterator.OfLong} covering the specified range of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4904" href="#"></a></td>
<td><pre>     * specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4905" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4906" href="#"></a></td>
<td><pre>     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4907" href="#"></a></td>
<td><pre>     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4908" href="#"></a></td>
<td><pre>     * {@link Spliterator#IMMUTABLE}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4909" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4910" href="#"></a></td>
<td><pre>     * @param array the array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4911" href="#"></a></td>
<td><pre>     * @param startInclusive the first index to cover, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4912" href="#"></a></td>
<td><pre>     * @param endExclusive index immediately past the last index to cover</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4913" href="#"></a></td>
<td><pre>     * @return a spliterator for the array elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4914" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4915" href="#"></a></td>
<td><pre>     *         negative, {@code endExclusive} is less than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4916" href="#"></a></td>
<td><pre>     *         {@code startInclusive}, or {@code endExclusive} is greater than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4917" href="#"></a></td>
<td><pre>     *         the array size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4918" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4919" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4920" href="#"></a></td>
<td><pre>    public static Spliterator.OfLong spliterator(long[] array, int startInclusive, int endExclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4921" href="#"></a></td>
<td><pre>        return Spliterators.spliterator(array, startInclusive, endExclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4922" href="#"></a></td>
<td><pre>                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4923" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4924" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4925" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4926" href="#"></a></td>
<td><pre>     * Returns a {@link Spliterator.OfDouble} covering all of the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4927" href="#"></a></td>
<td><pre>     * array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4928" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4929" href="#"></a></td>
<td><pre>     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4930" href="#"></a></td>
<td><pre>     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4931" href="#"></a></td>
<td><pre>     * {@link Spliterator#IMMUTABLE}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4932" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4933" href="#"></a></td>
<td><pre>     * @param array the array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4934" href="#"></a></td>
<td><pre>     * @return a spliterator for the array elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4935" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4936" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4937" href="#"></a></td>
<td><pre>    public static Spliterator.OfDouble spliterator(double[] array) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4938" href="#"></a></td>
<td><pre>        return Spliterators.spliterator(array,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4939" href="#"></a></td>
<td><pre>                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4940" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4941" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4942" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4943" href="#"></a></td>
<td><pre>     * Returns a {@link Spliterator.OfDouble} covering the specified range of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4944" href="#"></a></td>
<td><pre>     * the specified array.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4945" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4946" href="#"></a></td>
<td><pre>     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4947" href="#"></a></td>
<td><pre>     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4948" href="#"></a></td>
<td><pre>     * {@link Spliterator#IMMUTABLE}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4949" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4950" href="#"></a></td>
<td><pre>     * @param array the array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4951" href="#"></a></td>
<td><pre>     * @param startInclusive the first index to cover, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4952" href="#"></a></td>
<td><pre>     * @param endExclusive index immediately past the last index to cover</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4953" href="#"></a></td>
<td><pre>     * @return a spliterator for the array elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4954" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4955" href="#"></a></td>
<td><pre>     *         negative, {@code endExclusive} is less than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4956" href="#"></a></td>
<td><pre>     *         {@code startInclusive}, or {@code endExclusive} is greater than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4957" href="#"></a></td>
<td><pre>     *         the array size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4958" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4959" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4960" href="#"></a></td>
<td><pre>    public static Spliterator.OfDouble spliterator(double[] array, int startInclusive, int endExclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4961" href="#"></a></td>
<td><pre>        return Spliterators.spliterator(array, startInclusive, endExclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4962" href="#"></a></td>
<td><pre>                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4963" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4964" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4965" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4966" href="#"></a></td>
<td><pre>     * Returns a sequential {@link Stream} with the specified array as its</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4967" href="#"></a></td>
<td><pre>     * source.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4968" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4969" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; The type of the array elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4970" href="#"></a></td>
<td><pre>     * @param array The array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4971" href="#"></a></td>
<td><pre>     * @return a {@code Stream} for the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4972" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4973" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4974" href="#"></a></td>
<td><pre>    public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4975" href="#"></a></td>
<td><pre>        return stream(array, 0, array.length);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4976" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4977" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4978" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4979" href="#"></a></td>
<td><pre>     * Returns a sequential {@link Stream} with the specified range of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4980" href="#"></a></td>
<td><pre>     * specified array as its source.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4981" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4982" href="#"></a></td>
<td><pre>     * @param &lt;T&gt; the type of the array elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4983" href="#"></a></td>
<td><pre>     * @param array the array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4984" href="#"></a></td>
<td><pre>     * @param startInclusive the first index to cover, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4985" href="#"></a></td>
<td><pre>     * @param endExclusive index immediately past the last index to cover</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4986" href="#"></a></td>
<td><pre>     * @return a {@code Stream} for the array range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4987" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4988" href="#"></a></td>
<td><pre>     *         negative, {@code endExclusive} is less than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4989" href="#"></a></td>
<td><pre>     *         {@code startInclusive}, or {@code endExclusive} is greater than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4990" href="#"></a></td>
<td><pre>     *         the array size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4991" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4992" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4993" href="#"></a></td>
<td><pre>    public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array, int startInclusive, int endExclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4994" href="#"></a></td>
<td><pre>        return StreamSupport.stream(spliterator(array, startInclusive, endExclusive), false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4995" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4996" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4997" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4998" href="#"></a></td>
<td><pre>     * Returns a sequential {@link IntStream} with the specified array as its</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4999" href="#"></a></td>
<td><pre>     * source.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5000" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5001" href="#"></a></td>
<td><pre>     * @param array the array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5002" href="#"></a></td>
<td><pre>     * @return an {@code IntStream} for the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5003" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5004" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5005" href="#"></a></td>
<td><pre>    public static IntStream stream(int[] array) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5006" href="#"></a></td>
<td><pre>        return stream(array, 0, array.length);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5007" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5008" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5009" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5010" href="#"></a></td>
<td><pre>     * Returns a sequential {@link IntStream} with the specified range of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5011" href="#"></a></td>
<td><pre>     * specified array as its source.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5012" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5013" href="#"></a></td>
<td><pre>     * @param array the array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5014" href="#"></a></td>
<td><pre>     * @param startInclusive the first index to cover, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5015" href="#"></a></td>
<td><pre>     * @param endExclusive index immediately past the last index to cover</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5016" href="#"></a></td>
<td><pre>     * @return an {@code IntStream} for the array range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5017" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5018" href="#"></a></td>
<td><pre>     *         negative, {@code endExclusive} is less than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5019" href="#"></a></td>
<td><pre>     *         {@code startInclusive}, or {@code endExclusive} is greater than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5020" href="#"></a></td>
<td><pre>     *         the array size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5021" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5022" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5023" href="#"></a></td>
<td><pre>    public static IntStream stream(int[] array, int startInclusive, int endExclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5024" href="#"></a></td>
<td><pre>        return StreamSupport.intStream(spliterator(array, startInclusive, endExclusive), false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5025" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5026" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5027" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5028" href="#"></a></td>
<td><pre>     * Returns a sequential {@link LongStream} with the specified array as its</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5029" href="#"></a></td>
<td><pre>     * source.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5030" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5031" href="#"></a></td>
<td><pre>     * @param array the array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5032" href="#"></a></td>
<td><pre>     * @return a {@code LongStream} for the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5033" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5034" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5035" href="#"></a></td>
<td><pre>    public static LongStream stream(long[] array) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5036" href="#"></a></td>
<td><pre>        return stream(array, 0, array.length);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5037" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5038" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5039" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5040" href="#"></a></td>
<td><pre>     * Returns a sequential {@link LongStream} with the specified range of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5041" href="#"></a></td>
<td><pre>     * specified array as its source.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5042" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5043" href="#"></a></td>
<td><pre>     * @param array the array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5044" href="#"></a></td>
<td><pre>     * @param startInclusive the first index to cover, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5045" href="#"></a></td>
<td><pre>     * @param endExclusive index immediately past the last index to cover</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5046" href="#"></a></td>
<td><pre>     * @return a {@code LongStream} for the array range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5047" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5048" href="#"></a></td>
<td><pre>     *         negative, {@code endExclusive} is less than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5049" href="#"></a></td>
<td><pre>     *         {@code startInclusive}, or {@code endExclusive} is greater than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5050" href="#"></a></td>
<td><pre>     *         the array size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5051" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5052" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5053" href="#"></a></td>
<td><pre>    public static LongStream stream(long[] array, int startInclusive, int endExclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5054" href="#"></a></td>
<td><pre>        return StreamSupport.longStream(spliterator(array, startInclusive, endExclusive), false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5055" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5056" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5057" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5058" href="#"></a></td>
<td><pre>     * Returns a sequential {@link DoubleStream} with the specified array as its</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5059" href="#"></a></td>
<td><pre>     * source.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5060" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5061" href="#"></a></td>
<td><pre>     * @param array the array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5062" href="#"></a></td>
<td><pre>     * @return a {@code DoubleStream} for the array</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5063" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5064" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5065" href="#"></a></td>
<td><pre>    public static DoubleStream stream(double[] array) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5066" href="#"></a></td>
<td><pre>        return stream(array, 0, array.length);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5067" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5068" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5069" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5070" href="#"></a></td>
<td><pre>     * Returns a sequential {@link DoubleStream} with the specified range of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5071" href="#"></a></td>
<td><pre>     * specified array as its source.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5072" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5073" href="#"></a></td>
<td><pre>     * @param array the array, assumed to be unmodified during use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5074" href="#"></a></td>
<td><pre>     * @param startInclusive the first index to cover, inclusive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5075" href="#"></a></td>
<td><pre>     * @param endExclusive index immediately past the last index to cover</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5076" href="#"></a></td>
<td><pre>     * @return a {@code DoubleStream} for the array range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5077" href="#"></a></td>
<td><pre>     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5078" href="#"></a></td>
<td><pre>     *         negative, {@code endExclusive} is less than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5079" href="#"></a></td>
<td><pre>     *         {@code startInclusive}, or {@code endExclusive} is greater than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5080" href="#"></a></td>
<td><pre>     *         the array size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5081" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5082" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5083" href="#"></a></td>
<td><pre>    public static DoubleStream stream(double[] array, int startInclusive, int endExclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5084" href="#"></a></td>
<td><pre>        return StreamSupport.doubleStream(spliterator(array, startInclusive, endExclusive), false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5085" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5086" href="#"></a></td>
<td><pre>}</pre></td>
</tr>
</table>
</body>
</html>
