<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/OdinCodeBrowser/css/styles.css"/>
    </head>
<body>
<table>
<tr>
<td><a class="linenum-cell" data-linenum="1" href="#"></a></td>
<td><pre>/*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2" href="#"></a></td>
<td><pre> * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3" href="#"></a></td>
<td><pre> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5" href="#"></a></td>
<td><pre> * This code is free software; you can redistribute it and/or modify it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="6" href="#"></a></td>
<td><pre> * under the terms of the GNU General Public License version 2 only, as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="7" href="#"></a></td>
<td><pre> * published by the Free Software Foundation.  Oracle designates this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="8" href="#"></a></td>
<td><pre> * particular file as subject to the &quot;Classpath&quot; exception as provided</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="9" href="#"></a></td>
<td><pre> * by Oracle in the LICENSE file that accompanied this code.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="10" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="11" href="#"></a></td>
<td><pre> * This code is distributed in the hope that it will be useful, but WITHOUT</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="12" href="#"></a></td>
<td><pre> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="13" href="#"></a></td>
<td><pre> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="14" href="#"></a></td>
<td><pre> * version 2 for more details (a copy is included in the LICENSE file that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="15" href="#"></a></td>
<td><pre> * accompanied this code).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="16" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="17" href="#"></a></td>
<td><pre> * You should have received a copy of the GNU General Public License version</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="18" href="#"></a></td>
<td><pre> * 2 along with this work; if not, write to the Free Software Foundation,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="19" href="#"></a></td>
<td><pre> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="20" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="21" href="#"></a></td>
<td><pre> * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="22" href="#"></a></td>
<td><pre> * or visit www.oracle.com if you need additional information or have any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="23" href="#"></a></td>
<td><pre> * questions.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="24" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="25" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="26" href="#"></a></td>
<td><pre>/**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="27" href="#"></a></td>
<td><pre> * Classes to support functional-style operations on streams of elements, such</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="28" href="#"></a></td>
<td><pre> * as map-reduce transformations on collections.  For example:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="29" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="30" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="31" href="#"></a></td>
<td><pre> *     int sum = widgets.stream()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="32" href="#"></a></td>
<td><pre> *                      .filter(b -&gt; b.getColor() == RED)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="33" href="#"></a></td>
<td><pre> *                      .mapToInt(b -&gt; b.getWeight())</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="34" href="#"></a></td>
<td><pre> *                      .sum();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="35" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="36" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="37" href="#"></a></td>
<td><pre> * &lt;p&gt;Here we use {@code widgets}, a {@code Collection&lt;Widget&gt;},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="38" href="#"></a></td>
<td><pre> * as a source for a stream, and then perform a filter-map-reduce on the stream</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="39" href="#"></a></td>
<td><pre> * to obtain the sum of the weights of the red widgets.  (Summation is an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="40" href="#"></a></td>
<td><pre> * example of a &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="41" href="#"></a></td>
<td><pre> * operation.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="42" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="43" href="#"></a></td>
<td><pre> * &lt;p&gt;The key abstraction introduced in this package is &lt;em&gt;stream&lt;/em&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="44" href="#"></a></td>
<td><pre> * classes {@link java.util.stream.Stream}, {@link java.util.stream.IntStream},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="45" href="#"></a></td>
<td><pre> * {@link java.util.stream.LongStream}, and {@link java.util.stream.DoubleStream}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="46" href="#"></a></td>
<td><pre> * are streams over objects and the primitive {@code int}, {@code long} and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="47" href="#"></a></td>
<td><pre> * {@code double} types.  Streams differ from collections in several ways:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="48" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="49" href="#"></a></td>
<td><pre> * &lt;ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="50" href="#"></a></td>
<td><pre> *     &lt;li&gt;No storage.  A stream is not a data structure that stores elements;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="51" href="#"></a></td>
<td><pre> *     instead, it conveys elements from a source such as a data structure,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="52" href="#"></a></td>
<td><pre> *     an array, a generator function, or an I/O channel, through a pipeline of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="53" href="#"></a></td>
<td><pre> *     computational operations.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="54" href="#"></a></td>
<td><pre> *     &lt;li&gt;Functional in nature.  An operation on a stream produces a result,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="55" href="#"></a></td>
<td><pre> *     but does not modify its source.  For example, filtering a {@code Stream}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="56" href="#"></a></td>
<td><pre> *     obtained from a collection produces a new {@code Stream} without the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="57" href="#"></a></td>
<td><pre> *     filtered elements, rather than removing elements from the source</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="58" href="#"></a></td>
<td><pre> *     collection.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="59" href="#"></a></td>
<td><pre> *     &lt;li&gt;Laziness-seeking.  Many stream operations, such as filtering, mapping,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="60" href="#"></a></td>
<td><pre> *     or duplicate removal, can be implemented lazily, exposing opportunities</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="61" href="#"></a></td>
<td><pre> *     for optimization.  For example, &quot;find the first {@code String} with</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="62" href="#"></a></td>
<td><pre> *     three consecutive vowels&quot; need not examine all the input strings.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="63" href="#"></a></td>
<td><pre> *     Stream operations are divided into intermediate ({@code Stream}-producing)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="64" href="#"></a></td>
<td><pre> *     operations and terminal (value- or side-effect-producing) operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="65" href="#"></a></td>
<td><pre> *     Intermediate operations are always lazy.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="66" href="#"></a></td>
<td><pre> *     &lt;li&gt;Possibly unbounded.  While collections have a finite size, streams</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="67" href="#"></a></td>
<td><pre> *     need not.  Short-circuiting operations such as {@code limit(n)} or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="68" href="#"></a></td>
<td><pre> *     {@code findFirst()} can allow computations on infinite streams to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="69" href="#"></a></td>
<td><pre> *     complete in finite time.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="70" href="#"></a></td>
<td><pre> *     &lt;li&gt;Consumable. The elements of a stream are only visited once during</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="71" href="#"></a></td>
<td><pre> *     the life of a stream. Like an {@link java.util.Iterator}, a new stream</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="72" href="#"></a></td>
<td><pre> *     must be generated to revisit the same elements of the source.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="73" href="#"></a></td>
<td><pre> *     &lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="74" href="#"></a></td>
<td><pre> * &lt;/ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="75" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="76" href="#"></a></td>
<td><pre> * Streams can be obtained in a number of ways. Some examples include:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="77" href="#"></a></td>
<td><pre> * &lt;ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="78" href="#"></a></td>
<td><pre> *     &lt;li&gt;From a {@link java.util.Collection} via the {@code stream()} and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="79" href="#"></a></td>
<td><pre> *     {@code parallelStream()} methods;&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="80" href="#"></a></td>
<td><pre> *     &lt;li&gt;From an array via {@link java.util.Arrays#stream(Object[])};&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="81" href="#"></a></td>
<td><pre> *     &lt;li&gt;From static factory methods on the stream classes, such as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="82" href="#"></a></td>
<td><pre> *     {@link java.util.stream.Stream#of(Object[])},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="83" href="#"></a></td>
<td><pre> *     {@link java.util.stream.IntStream#range(int, int)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="84" href="#"></a></td>
<td><pre> *     or {@link java.util.stream.Stream#iterate(Object, UnaryOperator)};&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="85" href="#"></a></td>
<td><pre> *     &lt;li&gt;The lines of a file can be obtained from {@link java.io.BufferedReader#lines()};&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="86" href="#"></a></td>
<td><pre> *     &lt;li&gt;Streams of file paths can be obtained from methods in {@link java.nio.file.Files};&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="87" href="#"></a></td>
<td><pre> *     &lt;li&gt;Streams of random numbers can be obtained from {@link java.util.Random#ints()};&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="88" href="#"></a></td>
<td><pre> *     &lt;li&gt;Numerous other stream-bearing methods in the JDK, including</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="89" href="#"></a></td>
<td><pre> *     {@link java.util.BitSet#stream()},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="90" href="#"></a></td>
<td><pre> *     {@link java.util.regex.Pattern#splitAsStream(java.lang.CharSequence)},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="91" href="#"></a></td>
<td><pre> *     and {@link java.util.jar.JarFile#stream()}.&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="92" href="#"></a></td>
<td><pre> * &lt;/ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="93" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="94" href="#"></a></td>
<td><pre> * &lt;p&gt;Additional stream sources can be provided by third-party libraries using</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="95" href="#"></a></td>
<td><pre> * &lt;a href=&quot;package-summary.html#StreamSources&quot;&gt;these techniques&lt;/a&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="96" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="97" href="#"></a></td>
<td><pre> * &lt;h2&gt;&lt;a name=&quot;StreamOps&quot;&gt;Stream operations and pipelines&lt;/a&gt;&lt;/h2&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="98" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="99" href="#"></a></td>
<td><pre> * &lt;p&gt;Stream operations are divided into &lt;em&gt;intermediate&lt;/em&gt; and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="100" href="#"></a></td>
<td><pre> * &lt;em&gt;terminal&lt;/em&gt; operations, and are combined to form &lt;em&gt;stream</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="101" href="#"></a></td>
<td><pre> * pipelines&lt;/em&gt;.  A stream pipeline consists of a source (such as a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="102" href="#"></a></td>
<td><pre> * {@code Collection}, an array, a generator function, or an I/O channel);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="103" href="#"></a></td>
<td><pre> * followed by zero or more intermediate operations such as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="104" href="#"></a></td>
<td><pre> * {@code Stream.filter} or {@code Stream.map}; and a terminal operation such</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="105" href="#"></a></td>
<td><pre> * as {@code Stream.forEach} or {@code Stream.reduce}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="106" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="107" href="#"></a></td>
<td><pre> * &lt;p&gt;Intermediate operations return a new stream.  They are always</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="108" href="#"></a></td>
<td><pre> * &lt;em&gt;lazy&lt;/em&gt;; executing an intermediate operation such as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="109" href="#"></a></td>
<td><pre> * {@code filter()} does not actually perform any filtering, but instead</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="110" href="#"></a></td>
<td><pre> * creates a new stream that, when traversed, contains the elements of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="111" href="#"></a></td>
<td><pre> * the initial stream that match the given predicate.  Traversal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="112" href="#"></a></td>
<td><pre> * of the pipeline source does not begin until the terminal operation of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="113" href="#"></a></td>
<td><pre> * pipeline is executed.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="114" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="115" href="#"></a></td>
<td><pre> * &lt;p&gt;Terminal operations, such as {@code Stream.forEach} or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="116" href="#"></a></td>
<td><pre> * {@code IntStream.sum}, may traverse the stream to produce a result or a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="117" href="#"></a></td>
<td><pre> * side-effect. After the terminal operation is performed, the stream pipeline</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="118" href="#"></a></td>
<td><pre> * is considered consumed, and can no longer be used; if you need to traverse</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="119" href="#"></a></td>
<td><pre> * the same data source again, you must return to the data source to get a new</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="120" href="#"></a></td>
<td><pre> * stream.  In almost all cases, terminal operations are &lt;em&gt;eager&lt;/em&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="121" href="#"></a></td>
<td><pre> * completing their traversal of the data source and processing of the pipeline</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="122" href="#"></a></td>
<td><pre> * before returning.  Only the terminal operations {@code iterator()} and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="123" href="#"></a></td>
<td><pre> * {@code spliterator()} are not; these are provided as an &quot;escape hatch&quot; to enable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="124" href="#"></a></td>
<td><pre> * arbitrary client-controlled pipeline traversals in the event that the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="125" href="#"></a></td>
<td><pre> * existing operations are not sufficient to the task.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="126" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="127" href="#"></a></td>
<td><pre> * &lt;p&gt; Processing streams lazily allows for significant efficiencies; in a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="128" href="#"></a></td>
<td><pre> * pipeline such as the filter-map-sum example above, filtering, mapping, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="129" href="#"></a></td>
<td><pre> * summing can be fused into a single pass on the data, with minimal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="130" href="#"></a></td>
<td><pre> * intermediate state. Laziness also allows avoiding examining all the data</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="131" href="#"></a></td>
<td><pre> * when it is not necessary; for operations such as &quot;find the first string</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="132" href="#"></a></td>
<td><pre> * longer than 1000 characters&quot;, it is only necessary to examine just enough</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="133" href="#"></a></td>
<td><pre> * strings to find one that has the desired characteristics without examining</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="134" href="#"></a></td>
<td><pre> * all of the strings available from the source. (This behavior becomes even</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="135" href="#"></a></td>
<td><pre> * more important when the input stream is infinite and not merely large.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="136" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="137" href="#"></a></td>
<td><pre> * &lt;p&gt;Intermediate operations are further divided into &lt;em&gt;stateless&lt;/em&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="138" href="#"></a></td>
<td><pre> * and &lt;em&gt;stateful&lt;/em&gt; operations. Stateless operations, such as {@code filter}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="139" href="#"></a></td>
<td><pre> * and {@code map}, retain no state from previously seen element when processing</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="140" href="#"></a></td>
<td><pre> * a new element -- each element can be processed</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="141" href="#"></a></td>
<td><pre> * independently of operations on other elements.  Stateful operations, such as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="142" href="#"></a></td>
<td><pre> * {@code distinct} and {@code sorted}, may incorporate state from previously</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="143" href="#"></a></td>
<td><pre> * seen elements when processing new elements.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="144" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="145" href="#"></a></td>
<td><pre> * &lt;p&gt;Stateful operations may need to process the entire input</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="146" href="#"></a></td>
<td><pre> * before producing a result.  For example, one cannot produce any results from</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="147" href="#"></a></td>
<td><pre> * sorting a stream until one has seen all elements of the stream.  As a result,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="148" href="#"></a></td>
<td><pre> * under parallel computation, some pipelines containing stateful intermediate</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="149" href="#"></a></td>
<td><pre> * operations may require multiple passes on the data or may need to buffer</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="150" href="#"></a></td>
<td><pre> * significant data.  Pipelines containing exclusively stateless intermediate</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="151" href="#"></a></td>
<td><pre> * operations can be processed in a single pass, whether sequential or parallel,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="152" href="#"></a></td>
<td><pre> * with minimal data buffering.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="153" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="154" href="#"></a></td>
<td><pre> * &lt;p&gt;Further, some operations are deemed &lt;em&gt;short-circuiting&lt;/em&gt; operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="155" href="#"></a></td>
<td><pre> * An intermediate operation is short-circuiting if, when presented with</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="156" href="#"></a></td>
<td><pre> * infinite input, it may produce a finite stream as a result.  A terminal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="157" href="#"></a></td>
<td><pre> * operation is short-circuiting if, when presented with infinite input, it may</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="158" href="#"></a></td>
<td><pre> * terminate in finite time.  Having a short-circuiting operation in the pipeline</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="159" href="#"></a></td>
<td><pre> * is a necessary, but not sufficient, condition for the processing of an infinite</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="160" href="#"></a></td>
<td><pre> * stream to terminate normally in finite time.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="161" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="162" href="#"></a></td>
<td><pre> * &lt;h3&gt;Parallelism&lt;/h3&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="163" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="164" href="#"></a></td>
<td><pre> * &lt;p&gt;Processing elements with an explicit {@code for-}loop is inherently serial.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="165" href="#"></a></td>
<td><pre> * Streams facilitate parallel execution by reframing the computation as a pipeline of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="166" href="#"></a></td>
<td><pre> * aggregate operations, rather than as imperative operations on each individual</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="167" href="#"></a></td>
<td><pre> * element.  All streams operations can execute either in serial or in parallel.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="168" href="#"></a></td>
<td><pre> * The stream implementations in the JDK create serial streams unless parallelism is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="169" href="#"></a></td>
<td><pre> * explicitly requested.  For example, {@code Collection} has methods</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="170" href="#"></a></td>
<td><pre> * {@link java.util.Collection#stream} and {@link java.util.Collection#parallelStream},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="171" href="#"></a></td>
<td><pre> * which produce sequential and parallel streams respectively; other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="172" href="#"></a></td>
<td><pre> * stream-bearing methods such as {@link java.util.stream.IntStream#range(int, int)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="173" href="#"></a></td>
<td><pre> * produce sequential streams but these streams can be efficiently parallelized by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="174" href="#"></a></td>
<td><pre> * invoking their {@link java.util.stream.BaseStream#parallel()} method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="175" href="#"></a></td>
<td><pre> * To execute the prior &quot;sum of weights of widgets&quot; query in parallel, we would</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="176" href="#"></a></td>
<td><pre> * do:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="177" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="178" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="179" href="#"></a></td>
<td><pre> *     int sumOfWeights = widgets.}&lt;code&gt;&lt;b&gt;parallelStream()&lt;/b&gt;&lt;/code&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="180" href="#"></a></td>
<td><pre> *                               .filter(b -&gt; b.getColor() == RED)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="181" href="#"></a></td>
<td><pre> *                               .mapToInt(b -&gt; b.getWeight())</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="182" href="#"></a></td>
<td><pre> *                               .sum();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="183" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="184" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="185" href="#"></a></td>
<td><pre> * &lt;p&gt;The only difference between the serial and parallel versions of this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="186" href="#"></a></td>
<td><pre> * example is the creation of the initial stream, using &quot;{@code parallelStream()}&quot;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="187" href="#"></a></td>
<td><pre> * instead of &quot;{@code stream()}&quot;.  When the terminal operation is initiated,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="188" href="#"></a></td>
<td><pre> * the stream pipeline is executed sequentially or in parallel depending on the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="189" href="#"></a></td>
<td><pre> * orientation of the stream on which it is invoked.  Whether a stream will execute in serial or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="190" href="#"></a></td>
<td><pre> * parallel can be determined with the {@code isParallel()} method, and the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="191" href="#"></a></td>
<td><pre> * orientation of a stream can be modified with the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="192" href="#"></a></td>
<td><pre> * {@link java.util.stream.BaseStream#sequential()} and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="193" href="#"></a></td>
<td><pre> * {@link java.util.stream.BaseStream#parallel()} operations.  When the terminal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="194" href="#"></a></td>
<td><pre> * operation is initiated, the stream pipeline is executed sequentially or in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="195" href="#"></a></td>
<td><pre> * parallel depending on the mode of the stream on which it is invoked.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="196" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="197" href="#"></a></td>
<td><pre> * &lt;p&gt;Except for operations identified as explicitly nondeterministic, such</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="198" href="#"></a></td>
<td><pre> * as {@code findAny()}, whether a stream executes sequentially or in parallel</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="199" href="#"></a></td>
<td><pre> * should not change the result of the computation.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="200" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="201" href="#"></a></td>
<td><pre> * &lt;p&gt;Most stream operations accept parameters that describe user-specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="202" href="#"></a></td>
<td><pre> * behavior, which are often lambda expressions.  To preserve correct behavior,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="203" href="#"></a></td>
<td><pre> * these &lt;em&gt;behavioral parameters&lt;/em&gt; must be &lt;em&gt;non-interfering&lt;/em&gt;, and in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="204" href="#"></a></td>
<td><pre> * most cases must be &lt;em&gt;stateless&lt;/em&gt;.  Such parameters are always instances</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="205" href="#"></a></td>
<td><pre> * of a &lt;a href=&quot;../function/package-summary.html&quot;&gt;functional interface&lt;/a&gt; such</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="206" href="#"></a></td>
<td><pre> * as {@link java.util.function.Function}, and are often lambda expressions or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="207" href="#"></a></td>
<td><pre> * method references.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="208" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="209" href="#"></a></td>
<td><pre> * &lt;h3&gt;&lt;a name=&quot;NonInterference&quot;&gt;Non-interference&lt;/a&gt;&lt;/h3&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="210" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="211" href="#"></a></td>
<td><pre> * Streams enable you to execute possibly-parallel aggregate operations over a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="212" href="#"></a></td>
<td><pre> * variety of data sources, including even non-thread-safe collections such as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="213" href="#"></a></td>
<td><pre> * {@code ArrayList}. This is possible only if we can prevent</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="214" href="#"></a></td>
<td><pre> * &lt;em&gt;interference&lt;/em&gt; with the data source during the execution of a stream</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="215" href="#"></a></td>
<td><pre> * pipeline.  Except for the escape-hatch operations {@code iterator()} and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="216" href="#"></a></td>
<td><pre> * {@code spliterator()}, execution begins when the terminal operation is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="217" href="#"></a></td>
<td><pre> * invoked, and ends when the terminal operation completes.  For most data</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="218" href="#"></a></td>
<td><pre> * sources, preventing interference means ensuring that the data source is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="219" href="#"></a></td>
<td><pre> * &lt;em&gt;not modified at all&lt;/em&gt; during the execution of the stream pipeline.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="220" href="#"></a></td>
<td><pre> * The notable exception to this are streams whose sources are concurrent</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="221" href="#"></a></td>
<td><pre> * collections, which are specifically designed to handle concurrent modification.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="222" href="#"></a></td>
<td><pre> * Concurrent stream sources are those whose {@code Spliterator} reports the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="223" href="#"></a></td>
<td><pre> * {@code CONCURRENT} characteristic.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="224" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="225" href="#"></a></td>
<td><pre> * &lt;p&gt;Accordingly, behavioral parameters in stream pipelines whose source might</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="226" href="#"></a></td>
<td><pre> * not be concurrent should never modify the stream's data source.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="227" href="#"></a></td>
<td><pre> * A behavioral parameter is said to &lt;em&gt;interfere&lt;/em&gt; with a non-concurrent</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="228" href="#"></a></td>
<td><pre> * data source if it modifies, or causes to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="229" href="#"></a></td>
<td><pre> * modified, the stream's data source.  The need for non-interference applies</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="230" href="#"></a></td>
<td><pre> * to all pipelines, not just parallel ones.  Unless the stream source is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="231" href="#"></a></td>
<td><pre> * concurrent, modifying a stream's data source during execution of a stream</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="232" href="#"></a></td>
<td><pre> * pipeline can cause exceptions, incorrect answers, or nonconformant behavior.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="233" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="234" href="#"></a></td>
<td><pre> * For well-behaved stream sources, the source can be modified before the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="235" href="#"></a></td>
<td><pre> * terminal operation commences and those modifications will be reflected in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="236" href="#"></a></td>
<td><pre> * the covered elements.  For example, consider the following code:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="237" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="238" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="239" href="#"></a></td>
<td><pre> *     List&lt;String&gt; l = new ArrayList(Arrays.asList(&quot;one&quot;, &quot;two&quot;));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="240" href="#"></a></td>
<td><pre> *     Stream&lt;String&gt; sl = l.stream();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="241" href="#"></a></td>
<td><pre> *     l.add(&quot;three&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="242" href="#"></a></td>
<td><pre> *     String s = sl.collect(joining(&quot; &quot;));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="243" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="244" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="245" href="#"></a></td>
<td><pre> * First a list is created consisting of two strings: &quot;one&quot;; and &quot;two&quot;. Then a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="246" href="#"></a></td>
<td><pre> * stream is created from that list. Next the list is modified by adding a third</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="247" href="#"></a></td>
<td><pre> * string: &quot;three&quot;. Finally the elements of the stream are collected and joined</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="248" href="#"></a></td>
<td><pre> * together. Since the list was modified before the terminal {@code collect}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="249" href="#"></a></td>
<td><pre> * operation commenced the result will be a string of &quot;one two three&quot;. All the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="250" href="#"></a></td>
<td><pre> * streams returned from JDK collections, and most other JDK classes,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="251" href="#"></a></td>
<td><pre> * are well-behaved in this manner; for streams generated by other libraries, see</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="252" href="#"></a></td>
<td><pre> * &lt;a href=&quot;package-summary.html#StreamSources&quot;&gt;Low-level stream</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="253" href="#"></a></td>
<td><pre> * construction&lt;/a&gt; for requirements for building well-behaved streams.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="254" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="255" href="#"></a></td>
<td><pre> * &lt;h3&gt;&lt;a name=&quot;Statelessness&quot;&gt;Stateless behaviors&lt;/a&gt;&lt;/h3&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="256" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="257" href="#"></a></td>
<td><pre> * Stream pipeline results may be nondeterministic or incorrect if the behavioral</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="258" href="#"></a></td>
<td><pre> * parameters to the stream operations are &lt;em&gt;stateful&lt;/em&gt;.  A stateful lambda</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="259" href="#"></a></td>
<td><pre> * (or other object implementing the appropriate functional interface) is one</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="260" href="#"></a></td>
<td><pre> * whose result depends on any state which might change during the execution</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="261" href="#"></a></td>
<td><pre> * of the stream pipeline.  An example of a stateful lambda is the parameter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="262" href="#"></a></td>
<td><pre> * to {@code map()} in:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="263" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="264" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="265" href="#"></a></td>
<td><pre> *     Set&lt;Integer&gt; seen = Collections.synchronizedSet(new HashSet&lt;&gt;());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="266" href="#"></a></td>
<td><pre> *     stream.parallel().map(e -&gt; { if (seen.add(e)) return 0; else return e; })...</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="267" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="268" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="269" href="#"></a></td>
<td><pre> * Here, if the mapping operation is performed in parallel, the results for the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="270" href="#"></a></td>
<td><pre> * same input could vary from run to run, due to thread scheduling differences,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="271" href="#"></a></td>
<td><pre> * whereas, with a stateless lambda expression the results would always be the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="272" href="#"></a></td>
<td><pre> * same.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="273" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="274" href="#"></a></td>
<td><pre> * &lt;p&gt;Note also that attempting to access mutable state from behavioral parameters</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="275" href="#"></a></td>
<td><pre> * presents you with a bad choice with respect to safety and performance; if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="276" href="#"></a></td>
<td><pre> * you do not synchronize access to that state, you have a data race and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="277" href="#"></a></td>
<td><pre> * therefore your code is broken, but if you do synchronize access to that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="278" href="#"></a></td>
<td><pre> * state, you risk having contention undermine the parallelism you are seeking</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="279" href="#"></a></td>
<td><pre> * to benefit from.  The best approach is to avoid stateful behavioral</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="280" href="#"></a></td>
<td><pre> * parameters to stream operations entirely; there is usually a way to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="281" href="#"></a></td>
<td><pre> * restructure the stream pipeline to avoid statefulness.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="282" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="283" href="#"></a></td>
<td><pre> * &lt;h3&gt;Side-effects&lt;/h3&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="284" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="285" href="#"></a></td>
<td><pre> * Side-effects in behavioral parameters to stream operations are, in general,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="286" href="#"></a></td>
<td><pre> * discouraged, as they can often lead to unwitting violations of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="287" href="#"></a></td>
<td><pre> * statelessness requirement, as well as other thread-safety hazards.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="288" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="289" href="#"></a></td>
<td><pre> * &lt;p&gt;If the behavioral parameters do have side-effects, unless explicitly</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="290" href="#"></a></td>
<td><pre> * stated, there are no guarantees as to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="291" href="#"></a></td>
<td><pre> * &lt;a href=&quot;../concurrent/package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;visibility&lt;/i&gt;&lt;/a&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="292" href="#"></a></td>
<td><pre> * of those side-effects to other threads, nor are there any guarantees that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="293" href="#"></a></td>
<td><pre> * different operations on the &quot;same&quot; element within the same stream pipeline</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="294" href="#"></a></td>
<td><pre> * are executed in the same thread.  Further, the ordering of those effects</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="295" href="#"></a></td>
<td><pre> * may be surprising.  Even when a pipeline is constrained to produce a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="296" href="#"></a></td>
<td><pre> * &lt;em&gt;result&lt;/em&gt; that is consistent with the encounter order of the stream</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="297" href="#"></a></td>
<td><pre> * source (for example, {@code IntStream.range(0,5).parallel().map(x -&gt; x*2).toArray()}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="298" href="#"></a></td>
<td><pre> * must produce {@code [0, 2, 4, 6, 8]}), no guarantees are made as to the order</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="299" href="#"></a></td>
<td><pre> * in which the mapper function is applied to individual elements, or in what</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="300" href="#"></a></td>
<td><pre> * thread any behavioral parameter is executed for a given element.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="301" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="302" href="#"></a></td>
<td><pre> * &lt;p&gt;Many computations where one might be tempted to use side effects can be more</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="303" href="#"></a></td>
<td><pre> * safely and efficiently expressed without side-effects, such as using</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="304" href="#"></a></td>
<td><pre> * &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt; instead of mutable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="305" href="#"></a></td>
<td><pre> * accumulators. However, side-effects such as using {@code println()} for debugging</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="306" href="#"></a></td>
<td><pre> * purposes are usually harmless.  A small number of stream operations, such as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="307" href="#"></a></td>
<td><pre> * {@code forEach()} and {@code peek()}, can operate only via side-effects;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="308" href="#"></a></td>
<td><pre> * these should be used with care.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="309" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="310" href="#"></a></td>
<td><pre> * &lt;p&gt;As an example of how to transform a stream pipeline that inappropriately</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="311" href="#"></a></td>
<td><pre> * uses side-effects to one that does not, the following code searches a stream</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="312" href="#"></a></td>
<td><pre> * of strings for those matching a given regular expression, and puts the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="313" href="#"></a></td>
<td><pre> * matches in a list.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="314" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="315" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="316" href="#"></a></td>
<td><pre> *     ArrayList&lt;String&gt; results = new ArrayList&lt;&gt;();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="317" href="#"></a></td>
<td><pre> *     stream.filter(s -&gt; pattern.matcher(s).matches())</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="318" href="#"></a></td>
<td><pre> *           .forEach(s -&gt; results.add(s));  // Unnecessary use of side-effects!</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="319" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="320" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="321" href="#"></a></td>
<td><pre> * This code unnecessarily uses side-effects.  If executed in parallel, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="322" href="#"></a></td>
<td><pre> * non-thread-safety of {@code ArrayList} would cause incorrect results, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="323" href="#"></a></td>
<td><pre> * adding needed synchronization would cause contention, undermining the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="324" href="#"></a></td>
<td><pre> * benefit of parallelism.  Furthermore, using side-effects here is completely</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="325" href="#"></a></td>
<td><pre> * unnecessary; the {@code forEach()} can simply be replaced with a reduction</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="326" href="#"></a></td>
<td><pre> * operation that is safer, more efficient, and more amenable to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="327" href="#"></a></td>
<td><pre> * parallelization:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="328" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="329" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="330" href="#"></a></td>
<td><pre> *     List&lt;String&gt;results =</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="331" href="#"></a></td>
<td><pre> *         stream.filter(s -&gt; pattern.matcher(s).matches())</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="332" href="#"></a></td>
<td><pre> *               .collect(Collectors.toList());  // No side-effects!</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="333" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="334" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="335" href="#"></a></td>
<td><pre> * &lt;h3&gt;&lt;a name=&quot;Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/h3&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="336" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="337" href="#"></a></td>
<td><pre> * &lt;p&gt;Streams may or may not have a defined &lt;em&gt;encounter order&lt;/em&gt;.  Whether</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="338" href="#"></a></td>
<td><pre> * or not a stream has an encounter order depends on the source and the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="339" href="#"></a></td>
<td><pre> * intermediate operations.  Certain stream sources (such as {@code List} or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="340" href="#"></a></td>
<td><pre> * arrays) are intrinsically ordered, whereas others (such as {@code HashSet})</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="341" href="#"></a></td>
<td><pre> * are not.  Some intermediate operations, such as {@code sorted()}, may impose</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="342" href="#"></a></td>
<td><pre> * an encounter order on an otherwise unordered stream, and others may render an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="343" href="#"></a></td>
<td><pre> * ordered stream unordered, such as {@link java.util.stream.BaseStream#unordered()}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="344" href="#"></a></td>
<td><pre> * Further, some terminal operations may ignore encounter order, such as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="345" href="#"></a></td>
<td><pre> * {@code forEach()}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="346" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="347" href="#"></a></td>
<td><pre> * &lt;p&gt;If a stream is ordered, most operations are constrained to operate on the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="348" href="#"></a></td>
<td><pre> * elements in their encounter order; if the source of a stream is a {@code List}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="349" href="#"></a></td>
<td><pre> * containing {@code [1, 2, 3]}, then the result of executing {@code map(x -&gt; x*2)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="350" href="#"></a></td>
<td><pre> * must be {@code [2, 4, 6]}.  However, if the source has no defined encounter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="351" href="#"></a></td>
<td><pre> * order, then any permutation of the values {@code [2, 4, 6]} would be a valid</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="352" href="#"></a></td>
<td><pre> * result.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="353" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="354" href="#"></a></td>
<td><pre> * &lt;p&gt;For sequential streams, the presence or absence of an encounter order does</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="355" href="#"></a></td>
<td><pre> * not affect performance, only determinism.  If a stream is ordered, repeated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="356" href="#"></a></td>
<td><pre> * execution of identical stream pipelines on an identical source will produce</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="357" href="#"></a></td>
<td><pre> * an identical result; if it is not ordered, repeated execution might produce</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="358" href="#"></a></td>
<td><pre> * different results.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="359" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="360" href="#"></a></td>
<td><pre> * &lt;p&gt;For parallel streams, relaxing the ordering constraint can sometimes enable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="361" href="#"></a></td>
<td><pre> * more efficient execution.  Certain aggregate operations,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="362" href="#"></a></td>
<td><pre> * such as filtering duplicates ({@code distinct()}) or grouped reductions</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="363" href="#"></a></td>
<td><pre> * ({@code Collectors.groupingBy()}) can be implemented more efficiently if ordering of elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="364" href="#"></a></td>
<td><pre> * is not relevant.  Similarly, operations that are intrinsically tied to encounter order,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="365" href="#"></a></td>
<td><pre> * such as {@code limit()}, may require</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="366" href="#"></a></td>
<td><pre> * buffering to ensure proper ordering, undermining the benefit of parallelism.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="367" href="#"></a></td>
<td><pre> * In cases where the stream has an encounter order, but the user does not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="368" href="#"></a></td>
<td><pre> * particularly &lt;em&gt;care&lt;/em&gt; about that encounter order, explicitly de-ordering</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="369" href="#"></a></td>
<td><pre> * the stream with {@link java.util.stream.BaseStream#unordered() unordered()} may</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="370" href="#"></a></td>
<td><pre> * improve parallel performance for some stateful or terminal operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="371" href="#"></a></td>
<td><pre> * However, most stream pipelines, such as the &quot;sum of weight of blocks&quot; example</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="372" href="#"></a></td>
<td><pre> * above, still parallelize efficiently even under ordering constraints.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="373" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="374" href="#"></a></td>
<td><pre> * &lt;h2&gt;&lt;a name=&quot;Reduction&quot;&gt;Reduction operations&lt;/a&gt;&lt;/h2&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="375" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="376" href="#"></a></td>
<td><pre> * A &lt;em&gt;reduction&lt;/em&gt; operation (also called a &lt;em&gt;fold&lt;/em&gt;) takes a sequence</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="377" href="#"></a></td>
<td><pre> * of input elements and combines them into a single summary result by repeated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="378" href="#"></a></td>
<td><pre> * application of a combining operation, such as finding the sum or maximum of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="379" href="#"></a></td>
<td><pre> * a set of numbers, or accumulating elements into a list.  The streams classes have</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="380" href="#"></a></td>
<td><pre> * multiple forms of general reduction operations, called</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="381" href="#"></a></td>
<td><pre> * {@link java.util.stream.Stream#reduce(java.util.function.BinaryOperator) reduce()}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="382" href="#"></a></td>
<td><pre> * and {@link java.util.stream.Stream#collect(java.util.stream.Collector) collect()},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="383" href="#"></a></td>
<td><pre> * as well as multiple specialized reduction forms such as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="384" href="#"></a></td>
<td><pre> * {@link java.util.stream.IntStream#sum() sum()}, {@link java.util.stream.IntStream#max() max()},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="385" href="#"></a></td>
<td><pre> * or {@link java.util.stream.IntStream#count() count()}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="386" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="387" href="#"></a></td>
<td><pre> * &lt;p&gt;Of course, such operations can be readily implemented as simple sequential</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="388" href="#"></a></td>
<td><pre> * loops, as in:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="389" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="390" href="#"></a></td>
<td><pre> *    int sum = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="391" href="#"></a></td>
<td><pre> *    for (int x : numbers) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="392" href="#"></a></td>
<td><pre> *       sum += x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="393" href="#"></a></td>
<td><pre> *    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="394" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="395" href="#"></a></td>
<td><pre> * However, there are good reasons to prefer a reduce operation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="396" href="#"></a></td>
<td><pre> * over a mutative accumulation such as the above.  Not only is a reduction</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="397" href="#"></a></td>
<td><pre> * &quot;more abstract&quot; -- it operates on the stream as a whole rather than individual</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="398" href="#"></a></td>
<td><pre> * elements -- but a properly constructed reduce operation is inherently</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="399" href="#"></a></td>
<td><pre> * parallelizable, so long as the function(s) used to process the elements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="400" href="#"></a></td>
<td><pre> * are &lt;a href=&quot;package-summary.html#Associativity&quot;&gt;associative&lt;/a&gt; and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="401" href="#"></a></td>
<td><pre> * &lt;a href=&quot;package-summary.html#NonInterfering&quot;&gt;stateless&lt;/a&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="402" href="#"></a></td>
<td><pre> * For example, given a stream of numbers for which we want to find the sum, we</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="403" href="#"></a></td>
<td><pre> * can write:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="404" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="405" href="#"></a></td>
<td><pre> *    int sum = numbers.stream().reduce(0, (x,y) -&gt; x+y);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="406" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="407" href="#"></a></td>
<td><pre> * or:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="408" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="409" href="#"></a></td>
<td><pre> *    int sum = numbers.stream().reduce(0, Integer::sum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="410" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="411" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="412" href="#"></a></td>
<td><pre> * &lt;p&gt;These reduction operations can run safely in parallel with almost no</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="413" href="#"></a></td>
<td><pre> * modification:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="414" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="415" href="#"></a></td>
<td><pre> *    int sum = numbers.parallelStream().reduce(0, Integer::sum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="416" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="417" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="418" href="#"></a></td>
<td><pre> * &lt;p&gt;Reduction parallellizes well because the implementation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="419" href="#"></a></td>
<td><pre> * can operate on subsets of the data in parallel, and then combine the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="420" href="#"></a></td>
<td><pre> * intermediate results to get the final correct answer.  (Even if the language</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="421" href="#"></a></td>
<td><pre> * had a &quot;parallel for-each&quot; construct, the mutative accumulation approach would</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="422" href="#"></a></td>
<td><pre> * still required the developer to provide</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="423" href="#"></a></td>
<td><pre> * thread-safe updates to the shared accumulating variable {@code sum}, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="424" href="#"></a></td>
<td><pre> * the required synchronization would then likely eliminate any performance gain from</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="425" href="#"></a></td>
<td><pre> * parallelism.)  Using {@code reduce()} instead removes all of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="426" href="#"></a></td>
<td><pre> * burden of parallelizing the reduction operation, and the library can provide</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="427" href="#"></a></td>
<td><pre> * an efficient parallel implementation with no additional synchronization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="428" href="#"></a></td>
<td><pre> * required.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="429" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="430" href="#"></a></td>
<td><pre> * &lt;p&gt;The &quot;widgets&quot; examples shown earlier shows how reduction combines with</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="431" href="#"></a></td>
<td><pre> * other operations to replace for loops with bulk operations.  If {@code widgets}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="432" href="#"></a></td>
<td><pre> * is a collection of {@code Widget} objects, which have a {@code getWeight} method,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="433" href="#"></a></td>
<td><pre> * we can find the heaviest widget with:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="434" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="435" href="#"></a></td>
<td><pre> *     OptionalInt heaviest = widgets.parallelStream()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="436" href="#"></a></td>
<td><pre> *                                   .mapToInt(Widget::getWeight)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="437" href="#"></a></td>
<td><pre> *                                   .max();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="438" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="439" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="440" href="#"></a></td>
<td><pre> * &lt;p&gt;In its more general form, a {@code reduce} operation on elements of type</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="441" href="#"></a></td>
<td><pre> * {@code &lt;T&gt;} yielding a result of type {@code &lt;U&gt;} requires three parameters:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="442" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="443" href="#"></a></td>
<td><pre> * &lt;U&gt; U reduce(U identity,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="444" href="#"></a></td>
<td><pre> *              BiFunction&lt;U, ? super T, U&gt; accumulator,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="445" href="#"></a></td>
<td><pre> *              BinaryOperator&lt;U&gt; combiner);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="446" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="447" href="#"></a></td>
<td><pre> * Here, the &lt;em&gt;identity&lt;/em&gt; element is both an initial seed value for the reduction</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="448" href="#"></a></td>
<td><pre> * and a default result if there are no input elements. The &lt;em&gt;accumulator&lt;/em&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="449" href="#"></a></td>
<td><pre> * function takes a partial result and the next element, and produces a new</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="450" href="#"></a></td>
<td><pre> * partial result. The &lt;em&gt;combiner&lt;/em&gt; function combines two partial results</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="451" href="#"></a></td>
<td><pre> * to produce a new partial result.  (The combiner is necessary in parallel</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="452" href="#"></a></td>
<td><pre> * reductions, where the input is partitioned, a partial accumulation computed</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="453" href="#"></a></td>
<td><pre> * for each partition, and then the partial results are combined to produce a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="454" href="#"></a></td>
<td><pre> * final result.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="455" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="456" href="#"></a></td>
<td><pre> * &lt;p&gt;More formally, the {@code identity} value must be an &lt;em&gt;identity&lt;/em&gt; for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="457" href="#"></a></td>
<td><pre> * the combiner function. This means that for all {@code u},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="458" href="#"></a></td>
<td><pre> * {@code combiner.apply(identity, u)} is equal to {@code u}. Additionally, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="459" href="#"></a></td>
<td><pre> * {@code combiner} function must be &lt;a href=&quot;package-summary.html#Associativity&quot;&gt;associative&lt;/a&gt; and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="460" href="#"></a></td>
<td><pre> * must be compatible with the {@code accumulator} function: for all {@code u}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="461" href="#"></a></td>
<td><pre> * and {@code t}, {@code combiner.apply(u, accumulator.apply(identity, t))} must</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="462" href="#"></a></td>
<td><pre> * be {@code equals()} to {@code accumulator.apply(u, t)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="463" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="464" href="#"></a></td>
<td><pre> * &lt;p&gt;The three-argument form is a generalization of the two-argument form,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="465" href="#"></a></td>
<td><pre> * incorporating a mapping step into the accumulation step.  We could</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="466" href="#"></a></td>
<td><pre> * re-cast the simple sum-of-weights example using the more general form as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="467" href="#"></a></td>
<td><pre> * follows:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="468" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="469" href="#"></a></td>
<td><pre> *     int sumOfWeights = widgets.stream()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="470" href="#"></a></td>
<td><pre> *                               .reduce(0,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="471" href="#"></a></td>
<td><pre> *                                       (sum, b) -&gt; sum + b.getWeight())</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="472" href="#"></a></td>
<td><pre> *                                       Integer::sum);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="473" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="474" href="#"></a></td>
<td><pre> * though the explicit map-reduce form is more readable and therefore should</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="475" href="#"></a></td>
<td><pre> * usually be preferred. The generalized form is provided for cases where</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="476" href="#"></a></td>
<td><pre> * significant work can be optimized away by combining mapping and reducing</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="477" href="#"></a></td>
<td><pre> * into a single function.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="478" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="479" href="#"></a></td>
<td><pre> * &lt;h3&gt;&lt;a name=&quot;MutableReduction&quot;&gt;Mutable reduction&lt;/a&gt;&lt;/h3&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="480" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="481" href="#"></a></td>
<td><pre> * A &lt;em&gt;mutable reduction operation&lt;/em&gt; accumulates input elements into a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="482" href="#"></a></td>
<td><pre> * mutable result container, such as a {@code Collection} or {@code StringBuilder},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="483" href="#"></a></td>
<td><pre> * as it processes the elements in the stream.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="484" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="485" href="#"></a></td>
<td><pre> * &lt;p&gt;If we wanted to take a stream of strings and concatenate them into a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="486" href="#"></a></td>
<td><pre> * single long string, we &lt;em&gt;could&lt;/em&gt; achieve this with ordinary reduction:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="487" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="488" href="#"></a></td>
<td><pre> *     String concatenated = strings.reduce(&quot;&quot;, String::concat)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="489" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="490" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="491" href="#"></a></td>
<td><pre> * &lt;p&gt;We would get the desired result, and it would even work in parallel.  However,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="492" href="#"></a></td>
<td><pre> * we might not be happy about the performance!  Such an implementation would do</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="493" href="#"></a></td>
<td><pre> * a great deal of string copying, and the run time would be &lt;em&gt;O(n^2)&lt;/em&gt; in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="494" href="#"></a></td>
<td><pre> * the number of characters.  A more performant approach would be to accumulate</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="495" href="#"></a></td>
<td><pre> * the results into a {@link java.lang.StringBuilder}, which is a mutable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="496" href="#"></a></td>
<td><pre> * container for accumulating strings.  We can use the same technique to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="497" href="#"></a></td>
<td><pre> * parallelize mutable reduction as we do with ordinary reduction.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="498" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="499" href="#"></a></td>
<td><pre> * &lt;p&gt;The mutable reduction operation is called</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="500" href="#"></a></td>
<td><pre> * {@link java.util.stream.Stream#collect(Collector) collect()},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="501" href="#"></a></td>
<td><pre> * as it collects together the desired results into a result container such</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="502" href="#"></a></td>
<td><pre> * as a {@code Collection}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="503" href="#"></a></td>
<td><pre> * A {@code collect} operation requires three functions:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="504" href="#"></a></td>
<td><pre> * a supplier function to construct new instances of the result container, an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="505" href="#"></a></td>
<td><pre> * accumulator function to incorporate an input element into a result</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="506" href="#"></a></td>
<td><pre> * container, and a combining function to merge the contents of one result</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="507" href="#"></a></td>
<td><pre> * container into another.  The form of this is very similar to the general</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="508" href="#"></a></td>
<td><pre> * form of ordinary reduction:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="509" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="510" href="#"></a></td>
<td><pre> * &lt;R&gt; R collect(Supplier&lt;R&gt; supplier,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="511" href="#"></a></td>
<td><pre> *               BiConsumer&lt;R, ? super T&gt; accumulator,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="512" href="#"></a></td>
<td><pre> *               BiConsumer&lt;R, R&gt; combiner);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="513" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="514" href="#"></a></td>
<td><pre> * &lt;p&gt;As with {@code reduce()}, a benefit of expressing {@code collect} in this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="515" href="#"></a></td>
<td><pre> * abstract way is that it is directly amenable to parallelization: we can</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="516" href="#"></a></td>
<td><pre> * accumulate partial results in parallel and then combine them, so long as the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="517" href="#"></a></td>
<td><pre> * accumulation and combining functions satisfy the appropriate requirements.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="518" href="#"></a></td>
<td><pre> * For example, to collect the String representations of the elements in a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="519" href="#"></a></td>
<td><pre> * stream into an {@code ArrayList}, we could write the obvious sequential</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="520" href="#"></a></td>
<td><pre> * for-each form:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="521" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="522" href="#"></a></td>
<td><pre> *     ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="523" href="#"></a></td>
<td><pre> *     for (T element : stream) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="524" href="#"></a></td>
<td><pre> *         strings.add(element.toString());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="525" href="#"></a></td>
<td><pre> *     }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="526" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="527" href="#"></a></td>
<td><pre> * Or we could use a parallelizable collect form:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="528" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="529" href="#"></a></td>
<td><pre> *     ArrayList&lt;String&gt; strings = stream.collect(() -&gt; new ArrayList&lt;&gt;(),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="530" href="#"></a></td>
<td><pre> *                                                (c, e) -&gt; c.add(e.toString()),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="531" href="#"></a></td>
<td><pre> *                                                (c1, c2) -&gt; c1.addAll(c2));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="532" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="533" href="#"></a></td>
<td><pre> * or, pulling the mapping operation out of the accumulator function, we could</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="534" href="#"></a></td>
<td><pre> * express it more succinctly as:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="535" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="536" href="#"></a></td>
<td><pre> *     List&lt;String&gt; strings = stream.map(Object::toString)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="537" href="#"></a></td>
<td><pre> *                                  .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="538" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="539" href="#"></a></td>
<td><pre> * Here, our supplier is just the {@link java.util.ArrayList#ArrayList()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="540" href="#"></a></td>
<td><pre> * ArrayList constructor}, the accumulator adds the stringified element to an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="541" href="#"></a></td>
<td><pre> * {@code ArrayList}, and the combiner simply uses {@link java.util.ArrayList#addAll addAll}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="542" href="#"></a></td>
<td><pre> * to copy the strings from one container into the other.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="543" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="544" href="#"></a></td>
<td><pre> * &lt;p&gt;The three aspects of {@code collect} -- supplier, accumulator, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="545" href="#"></a></td>
<td><pre> * combiner -- are tightly coupled.  We can use the abstraction of a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="546" href="#"></a></td>
<td><pre> * {@link java.util.stream.Collector} to capture all three aspects.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="547" href="#"></a></td>
<td><pre> * above example for collecting strings into a {@code List} can be rewritten</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="548" href="#"></a></td>
<td><pre> * using a standard {@code Collector} as:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="549" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="550" href="#"></a></td>
<td><pre> *     List&lt;String&gt; strings = stream.map(Object::toString)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="551" href="#"></a></td>
<td><pre> *                                  .collect(Collectors.toList());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="552" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="553" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="554" href="#"></a></td>
<td><pre> * &lt;p&gt;Packaging mutable reductions into a Collector has another advantage:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="555" href="#"></a></td>
<td><pre> * composability.  The class {@link java.util.stream.Collectors} contains a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="556" href="#"></a></td>
<td><pre> * number of predefined factories for collectors, including combinators</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="557" href="#"></a></td>
<td><pre> * that transform one collector into another.  For example, suppose we have a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="558" href="#"></a></td>
<td><pre> * collector that computes the sum of the salaries of a stream of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="559" href="#"></a></td>
<td><pre> * employees, as follows:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="560" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="561" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="562" href="#"></a></td>
<td><pre> *     Collector&lt;Employee, ?, Integer&gt; summingSalaries</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="563" href="#"></a></td>
<td><pre> *         = Collectors.summingInt(Employee::getSalary);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="564" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="565" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="566" href="#"></a></td>
<td><pre> * (The {@code ?} for the second type parameter merely indicates that we don't</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="567" href="#"></a></td>
<td><pre> * care about the intermediate representation used by this collector.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="568" href="#"></a></td>
<td><pre> * If we wanted to create a collector to tabulate the sum of salaries by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="569" href="#"></a></td>
<td><pre> * department, we could reuse {@code summingSalaries} using</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="570" href="#"></a></td>
<td><pre> * {@link java.util.stream.Collectors#groupingBy(java.util.function.Function, java.util.stream.Collector) groupingBy}:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="571" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="572" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="573" href="#"></a></td>
<td><pre> *     Map&lt;Department, Integer&gt; salariesByDept</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="574" href="#"></a></td>
<td><pre> *         = employees.stream().collect(Collectors.groupingBy(Employee::getDepartment,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="575" href="#"></a></td>
<td><pre> *                                                            summingSalaries));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="576" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="577" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="578" href="#"></a></td>
<td><pre> * &lt;p&gt;As with the regular reduction operation, {@code collect()} operations can</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="579" href="#"></a></td>
<td><pre> * only be parallelized if appropriate conditions are met.  For any partially</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="580" href="#"></a></td>
<td><pre> * accumulated result, combining it with an empty result container must</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="581" href="#"></a></td>
<td><pre> * produce an equivalent result.  That is, for a partially accumulated result</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="582" href="#"></a></td>
<td><pre> * {@code p} that is the result of any series of accumulator and combiner</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="583" href="#"></a></td>
<td><pre> * invocations, {@code p} must be equivalent to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="584" href="#"></a></td>
<td><pre> * {@code combiner.apply(p, supplier.get())}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="585" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="586" href="#"></a></td>
<td><pre> * &lt;p&gt;Further, however the computation is split, it must produce an equivalent</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="587" href="#"></a></td>
<td><pre> * result.  For any input elements {@code t1} and {@code t2}, the results</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="588" href="#"></a></td>
<td><pre> * {@code r1} and {@code r2} in the computation below must be equivalent:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="589" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="590" href="#"></a></td>
<td><pre> *     A a1 = supplier.get();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="591" href="#"></a></td>
<td><pre> *     accumulator.accept(a1, t1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="592" href="#"></a></td>
<td><pre> *     accumulator.accept(a1, t2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="593" href="#"></a></td>
<td><pre> *     R r1 = finisher.apply(a1);  // result without splitting</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="594" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="595" href="#"></a></td>
<td><pre> *     A a2 = supplier.get();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="596" href="#"></a></td>
<td><pre> *     accumulator.accept(a2, t1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="597" href="#"></a></td>
<td><pre> *     A a3 = supplier.get();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="598" href="#"></a></td>
<td><pre> *     accumulator.accept(a3, t2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="599" href="#"></a></td>
<td><pre> *     R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="600" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="601" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="602" href="#"></a></td>
<td><pre> * &lt;p&gt;Here, equivalence generally means according to {@link java.lang.Object#equals(Object)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="603" href="#"></a></td>
<td><pre> * but in some cases equivalence may be relaxed to account for differences in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="604" href="#"></a></td>
<td><pre> * order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="605" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="606" href="#"></a></td>
<td><pre> * &lt;h3&gt;&lt;a name=&quot;ConcurrentReduction&quot;&gt;Reduction, concurrency, and ordering&lt;/a&gt;&lt;/h3&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="607" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="608" href="#"></a></td>
<td><pre> * With some complex reduction operations, for example a {@code collect()} that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="609" href="#"></a></td>
<td><pre> * produces a {@code Map}, such as:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="610" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="611" href="#"></a></td>
<td><pre> *     Map&lt;Buyer, List&lt;Transaction&gt;&gt; salesByBuyer</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="612" href="#"></a></td>
<td><pre> *         = txns.parallelStream()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="613" href="#"></a></td>
<td><pre> *               .collect(Collectors.groupingBy(Transaction::getBuyer));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="614" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="615" href="#"></a></td>
<td><pre> * it may actually be counterproductive to perform the operation in parallel.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="616" href="#"></a></td>
<td><pre> * This is because the combining step (merging one {@code Map} into another by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="617" href="#"></a></td>
<td><pre> * key) can be expensive for some {@code Map} implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="618" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="619" href="#"></a></td>
<td><pre> * &lt;p&gt;Suppose, however, that the result container used in this reduction</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="620" href="#"></a></td>
<td><pre> * was a concurrently modifiable collection -- such as a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="621" href="#"></a></td>
<td><pre> * {@link java.util.concurrent.ConcurrentHashMap}. In that case, the parallel</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="622" href="#"></a></td>
<td><pre> * invocations of the accumulator could actually deposit their results</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="623" href="#"></a></td>
<td><pre> * concurrently into the same shared result container, eliminating the need for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="624" href="#"></a></td>
<td><pre> * the combiner to merge distinct result containers. This potentially provides</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="625" href="#"></a></td>
<td><pre> * a boost to the parallel execution performance. We call this a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="626" href="#"></a></td>
<td><pre> * &lt;em&gt;concurrent&lt;/em&gt; reduction.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="627" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="628" href="#"></a></td>
<td><pre> * &lt;p&gt;A {@link java.util.stream.Collector} that supports concurrent reduction is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="629" href="#"></a></td>
<td><pre> * marked with the {@link java.util.stream.Collector.Characteristics#CONCURRENT}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="630" href="#"></a></td>
<td><pre> * characteristic.  However, a concurrent collection also has a downside.  If</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="631" href="#"></a></td>
<td><pre> * multiple threads are depositing results concurrently into a shared container,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="632" href="#"></a></td>
<td><pre> * the order in which results are deposited is non-deterministic. Consequently,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="633" href="#"></a></td>
<td><pre> * a concurrent reduction is only possible if ordering is not important for the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="634" href="#"></a></td>
<td><pre> * stream being processed. The {@link java.util.stream.Stream#collect(Collector)}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="635" href="#"></a></td>
<td><pre> * implementation will only perform a concurrent reduction if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="636" href="#"></a></td>
<td><pre> * &lt;ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="637" href="#"></a></td>
<td><pre> * &lt;li&gt;The stream is parallel;&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="638" href="#"></a></td>
<td><pre> * &lt;li&gt;The collector has the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="639" href="#"></a></td>
<td><pre> * {@link java.util.stream.Collector.Characteristics#CONCURRENT} characteristic,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="640" href="#"></a></td>
<td><pre> * and;&lt;/li&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="641" href="#"></a></td>
<td><pre> * &lt;li&gt;Either the stream is unordered, or the collector has the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="642" href="#"></a></td>
<td><pre> * {@link java.util.stream.Collector.Characteristics#UNORDERED} characteristic.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="643" href="#"></a></td>
<td><pre> * &lt;/ul&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="644" href="#"></a></td>
<td><pre> * You can ensure the stream is unordered by using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="645" href="#"></a></td>
<td><pre> * {@link java.util.stream.BaseStream#unordered()} method.  For example:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="646" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="647" href="#"></a></td>
<td><pre> *     Map&lt;Buyer, List&lt;Transaction&gt;&gt; salesByBuyer</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="648" href="#"></a></td>
<td><pre> *         = txns.parallelStream()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="649" href="#"></a></td>
<td><pre> *               .unordered()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="650" href="#"></a></td>
<td><pre> *               .collect(groupingByConcurrent(Transaction::getBuyer));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="651" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="652" href="#"></a></td>
<td><pre> * (where {@link java.util.stream.Collectors#groupingByConcurrent} is the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="653" href="#"></a></td>
<td><pre> * concurrent equivalent of {@code groupingBy}).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="654" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="655" href="#"></a></td>
<td><pre> * &lt;p&gt;Note that if it is important that the elements for a given key appear in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="656" href="#"></a></td>
<td><pre> * the order they appear in the source, then we cannot use a concurrent</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="657" href="#"></a></td>
<td><pre> * reduction, as ordering is one of the casualties of concurrent insertion.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="658" href="#"></a></td>
<td><pre> * We would then be constrained to implement either a sequential reduction or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="659" href="#"></a></td>
<td><pre> * a merge-based parallel reduction.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="660" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="661" href="#"></a></td>
<td><pre> * &lt;h3&gt;&lt;a name=&quot;Associativity&quot;&gt;Associativity&lt;/a&gt;&lt;/h3&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="662" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="663" href="#"></a></td>
<td><pre> * An operator or function {@code op} is &lt;em&gt;associative&lt;/em&gt; if the following</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="664" href="#"></a></td>
<td><pre> * holds:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="665" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="666" href="#"></a></td>
<td><pre> *     (a op b) op c == a op (b op c)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="667" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="668" href="#"></a></td>
<td><pre> * The importance of this to parallel evaluation can be seen if we expand this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="669" href="#"></a></td>
<td><pre> * to four terms:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="670" href="#"></a></td>
<td><pre> * &lt;pre&gt;{@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="671" href="#"></a></td>
<td><pre> *     a op b op c op d == (a op b) op (c op d)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="672" href="#"></a></td>
<td><pre> * }&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="673" href="#"></a></td>
<td><pre> * So we can evaluate {@code (a op b)} in parallel with {@code (c op d)}, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="674" href="#"></a></td>
<td><pre> * then invoke {@code op} on the results.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="675" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="676" href="#"></a></td>
<td><pre> * &lt;p&gt;Examples of associative operations include numeric addition, min, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="677" href="#"></a></td>
<td><pre> * max, and string concatenation.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="678" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="679" href="#"></a></td>
<td><pre> * &lt;h2&gt;&lt;a name=&quot;StreamSources&quot;&gt;Low-level stream construction&lt;/a&gt;&lt;/h2&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="680" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="681" href="#"></a></td>
<td><pre> * So far, all the stream examples have used methods like</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="682" href="#"></a></td>
<td><pre> * {@link java.util.Collection#stream()} or {@link java.util.Arrays#stream(Object[])}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="683" href="#"></a></td>
<td><pre> * to obtain a stream.  How are those stream-bearing methods implemented?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="684" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="685" href="#"></a></td>
<td><pre> * &lt;p&gt;The class {@link java.util.stream.StreamSupport} has a number of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="686" href="#"></a></td>
<td><pre> * low-level methods for creating a stream, all using some form of a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="687" href="#"></a></td>
<td><pre> * {@link java.util.Spliterator}. A spliterator is the parallel analogue of an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="688" href="#"></a></td>
<td><pre> * {@link java.util.Iterator}; it describes a (possibly infinite) collection of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="689" href="#"></a></td>
<td><pre> * elements, with support for sequentially advancing, bulk traversal, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="690" href="#"></a></td>
<td><pre> * splitting off some portion of the input into another spliterator which can</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="691" href="#"></a></td>
<td><pre> * be processed in parallel.  At the lowest level, all streams are driven by a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="692" href="#"></a></td>
<td><pre> * spliterator.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="693" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="694" href="#"></a></td>
<td><pre> * &lt;p&gt;There are a number of implementation choices in implementing a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="695" href="#"></a></td>
<td><pre> * spliterator, nearly all of which are tradeoffs between simplicity of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="696" href="#"></a></td>
<td><pre> * implementation and runtime performance of streams using that spliterator.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="697" href="#"></a></td>
<td><pre> * The simplest, but least performant, way to create a spliterator is to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="698" href="#"></a></td>
<td><pre> * create one from an iterator using</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="699" href="#"></a></td>
<td><pre> * {@link java.util.Spliterators#spliteratorUnknownSize(java.util.Iterator, int)}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="700" href="#"></a></td>
<td><pre> * While such a spliterator will work, it will likely offer poor parallel</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="701" href="#"></a></td>
<td><pre> * performance, since we have lost sizing information (how big is the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="702" href="#"></a></td>
<td><pre> * underlying data set), as well as being constrained to a simplistic</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="703" href="#"></a></td>
<td><pre> * splitting algorithm.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="704" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="705" href="#"></a></td>
<td><pre> * &lt;p&gt;A higher-quality spliterator will provide balanced and known-size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="706" href="#"></a></td>
<td><pre> * splits, accurate sizing information, and a number of other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="707" href="#"></a></td>
<td><pre> * {@link java.util.Spliterator#characteristics() characteristics} of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="708" href="#"></a></td>
<td><pre> * spliterator or data that can be used by implementations to optimize</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="709" href="#"></a></td>
<td><pre> * execution.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="710" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="711" href="#"></a></td>
<td><pre> * &lt;p&gt;Spliterators for mutable data sources have an additional challenge;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="712" href="#"></a></td>
<td><pre> * timing of binding to the data, since the data could change between the time</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="713" href="#"></a></td>
<td><pre> * the spliterator is created and the time the stream pipeline is executed.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="714" href="#"></a></td>
<td><pre> * Ideally, a spliterator for a stream would report a characteristic of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="715" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="716" href="#"></a></td>
<td><pre> * {@code IMMUTABLE} or {@code CONCURRENT}; if not it should be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="717" href="#"></a></td>
<td><pre> * &lt;a href=&quot;../Spliterator.html#binding&quot;&gt;&lt;em&gt;late-binding&lt;/em&gt;&lt;/a&gt;. If a source</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="718" href="#"></a></td>
<td><pre> * cannot directly supply a recommended spliterator, it may indirectly supply</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="719" href="#"></a></td>
<td><pre> * a spliterator using a {@code Supplier}, and construct a stream via the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="720" href="#"></a></td>
<td><pre> * {@code Supplier}-accepting versions of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="721" href="#"></a></td>
<td><pre> * {@link java.util.stream.StreamSupport#stream(Supplier, int, boolean) stream()}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="722" href="#"></a></td>
<td><pre> * The spliterator is obtained from the supplier only after the terminal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="723" href="#"></a></td>
<td><pre> * operation of the stream pipeline commences.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="724" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="725" href="#"></a></td>
<td><pre> * &lt;p&gt;These requirements significantly reduce the scope of potential</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="726" href="#"></a></td>
<td><pre> * interference between mutations of the stream source and execution of stream</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="727" href="#"></a></td>
<td><pre> * pipelines. Streams based on spliterators with the desired characteristics,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="728" href="#"></a></td>
<td><pre> * or those using the Supplier-based factory forms, are immune to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="729" href="#"></a></td>
<td><pre> * modifications of the data source prior to commencement of the terminal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="730" href="#"></a></td>
<td><pre> * operation (provided the behavioral parameters to the stream operations meet</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="731" href="#"></a></td>
<td><pre> * the required criteria for non-interference and statelessness).  See</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="732" href="#"></a></td>
<td><pre> * &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;Non-Interference&lt;/a&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="733" href="#"></a></td>
<td><pre> * for more details.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="734" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="735" href="#"></a></td>
<td><pre> * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="736" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="737" href="#"></a></td>
<td><pre>package java.util.stream;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="738" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="739" href="#"></a></td>
<td><pre>import java.util.function.BinaryOperator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="740" href="#"></a></td>
<td><pre>import java.util.function.UnaryOperator;</pre></td>
</tr>
</table>
</body>
</html>
