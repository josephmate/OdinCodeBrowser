<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.util.stream;

import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Collection;
import java.util.Deque;
import java.util.List;
import java.util.Objects;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.concurrent.CountedCompleter;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.DoubleConsumer;
import java.util.function.IntConsumer;
import java.util.function.IntFunction;
import java.util.function.LongConsumer;
import java.util.function.LongFunction;

/**
 * Factory methods for constructing implementations of {@link Node} and
 * {@link Node.Builder} and their primitive specializations.  Fork/Join tasks
 * for collecting output from a {@link PipelineHelper} to a {@link Node} and
 * flattening {@link Node}s.
 *
 * @since 1.8
 */
final class Nodes {

    private Nodes() {
        throw new Error(&quot;no instances&quot;);
    }

    /**
     * The maximum size of an array that can be allocated.
     */
    static final long MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    // IllegalArgumentException messages
    static final String BAD_SIZE = &quot;Stream size exceeds max array size&quot;;

    @SuppressWarnings(&quot;raw&quot;)
    private static final Node EMPTY_NODE = new EmptyNode.OfRef();
    private static final Node.OfInt EMPTY_INT_NODE = new EmptyNode.OfInt();
    private static final Node.OfLong EMPTY_LONG_NODE = new EmptyNode.OfLong();
    private static final Node.OfDouble EMPTY_DOUBLE_NODE = new EmptyNode.OfDouble();

    // General shape-based node creation methods

    /**
     * Produces an empty node whose count is zero, has no children and no content.
     *
     * @param &lt;T&gt; the type of elements of the created node
     * @param shape the shape of the node to be created
     * @return an empty node.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Node&lt;T&gt; emptyNode(StreamShape shape) {
        switch (shape) {
            case REFERENCE:    return (Node&lt;T&gt;) EMPTY_NODE;
            case INT_VALUE:    return (Node&lt;T&gt;) EMPTY_INT_NODE;
            case LONG_VALUE:   return (Node&lt;T&gt;) EMPTY_LONG_NODE;
            case DOUBLE_VALUE: return (Node&lt;T&gt;) EMPTY_DOUBLE_NODE;
            default:
                throw new IllegalStateException(&quot;Unknown shape &quot; + shape);
        }
    }

    /**
     * Produces a concatenated {@link Node} that has two or more children.
     * &lt;p&gt;The count of the concatenated node is equal to the sum of the count
     * of each child. Traversal of the concatenated node traverses the content
     * of each child in encounter order of the list of children. Splitting a
     * spliterator obtained from the concatenated node preserves the encounter
     * order of the list of children.
     *
     * &lt;p&gt;The result may be a concatenated node, the input sole node if the size
     * of the list is 1, or an empty node.
     *
     * @param &lt;T&gt; the type of elements of the concatenated node
     * @param shape the shape of the concatenated node to be created
     * @param left the left input node
     * @param right the right input node
     * @return a {@code Node} covering the elements of the input nodes
     * @throws IllegalStateException if all {@link Node} elements of the list
     * are an not instance of type supported by this factory.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Node&lt;T&gt; conc(StreamShape shape, Node&lt;T&gt; left, Node&lt;T&gt; right) {
        switch (shape) {
            case REFERENCE:
                return new ConcNode&lt;&gt;(left, right);
            case INT_VALUE:
                return (Node&lt;T&gt;) new ConcNode.OfInt((Node.OfInt) left, (Node.OfInt) right);
            case LONG_VALUE:
                return (Node&lt;T&gt;) new ConcNode.OfLong((Node.OfLong) left, (Node.OfLong) right);
            case DOUBLE_VALUE:
                return (Node&lt;T&gt;) new ConcNode.OfDouble((Node.OfDouble) left, (Node.OfDouble) right);
            default:
                throw new IllegalStateException(&quot;Unknown shape &quot; + shape);
        }
    }

    // Reference-based node methods

    /**
     * Produces a {@link Node} describing an array.
     *
     * &lt;p&gt;The node will hold a reference to the array and will not make a copy.
     *
     * @param &lt;T&gt; the type of elements held by the node
     * @param array the array
     * @return a node holding an array
     */
    static &lt;T&gt; Node&lt;T&gt; node(T[] array) {
        return new ArrayNode&lt;&gt;(array);
    }

    /**
     * Produces a {@link Node} describing a {@link Collection}.
     * &lt;p&gt;
     * The node will hold a reference to the collection and will not make a copy.
     *
     * @param &lt;T&gt; the type of elements held by the node
     * @param c the collection
     * @return a node holding a collection
     */
    static &lt;T&gt; Node&lt;T&gt; node(Collection&lt;T&gt; c) {
        return new CollectionNode&lt;&gt;(c);
    }

    /**
     * Produces a {@link Node.Builder}.
     *
     * @param exactSizeIfKnown -1 if a variable size builder is requested,
     * otherwise the exact capacity desired.  A fixed capacity builder will
     * fail if the wrong number of elements are added to the builder.
     * @param generator the array factory
     * @param &lt;T&gt; the type of elements of the node builder
     * @return a {@code Node.Builder}
     */
    static &lt;T&gt; Node.Builder&lt;T&gt; builder(long exactSizeIfKnown, IntFunction&lt;T[]&gt; generator) {
        return (exactSizeIfKnown &gt;= 0 &amp;&amp; exactSizeIfKnown &lt; MAX_ARRAY_SIZE)
               ? new FixedNodeBuilder&lt;&gt;(exactSizeIfKnown, generator)
               : builder();
    }

    /**
     * Produces a variable size @{link Node.Builder}.
     *
     * @param &lt;T&gt; the type of elements of the node builder
     * @return a {@code Node.Builder}
     */
    static &lt;T&gt; Node.Builder&lt;T&gt; builder() {
        return new SpinedNodeBuilder&lt;&gt;();
    }

    // Int nodes

    /**
     * Produces a {@link Node.OfInt} describing an int[] array.
     *
     * &lt;p&gt;The node will hold a reference to the array and will not make a copy.
     *
     * @param array the array
     * @return a node holding an array
     */
    static Node.OfInt node(int[] array) {
        return new IntArrayNode(array);
    }

    /**
     * Produces a {@link Node.Builder.OfInt}.
     *
     * @param exactSizeIfKnown -1 if a variable size builder is requested,
     * otherwise the exact capacity desired.  A fixed capacity builder will
     * fail if the wrong number of elements are added to the builder.
     * @return a {@code Node.Builder.OfInt}
     */
    static Node.Builder.OfInt intBuilder(long exactSizeIfKnown) {
        return (exactSizeIfKnown &gt;= 0 &amp;&amp; exactSizeIfKnown &lt; MAX_ARRAY_SIZE)
               ? new IntFixedNodeBuilder(exactSizeIfKnown)
               : intBuilder();
    }

    /**
     * Produces a variable size @{link Node.Builder.OfInt}.
     *
     * @return a {@code Node.Builder.OfInt}
     */
    static Node.Builder.OfInt intBuilder() {
        return new IntSpinedNodeBuilder();
    }

    // Long nodes

    /**
     * Produces a {@link Node.OfLong} describing a long[] array.
     * &lt;p&gt;
     * The node will hold a reference to the array and will not make a copy.
     *
     * @param array the array
     * @return a node holding an array
     */
    static Node.OfLong node(final long[] array) {
        return new LongArrayNode(array);
    }

    /**
     * Produces a {@link Node.Builder.OfLong}.
     *
     * @param exactSizeIfKnown -1 if a variable size builder is requested,
     * otherwise the exact capacity desired.  A fixed capacity builder will
     * fail if the wrong number of elements are added to the builder.
     * @return a {@code Node.Builder.OfLong}
     */
    static Node.Builder.OfLong longBuilder(long exactSizeIfKnown) {
        return (exactSizeIfKnown &gt;= 0 &amp;&amp; exactSizeIfKnown &lt; MAX_ARRAY_SIZE)
               ? new LongFixedNodeBuilder(exactSizeIfKnown)
               : longBuilder();
    }

    /**
     * Produces a variable size @{link Node.Builder.OfLong}.
     *
     * @return a {@code Node.Builder.OfLong}
     */
    static Node.Builder.OfLong longBuilder() {
        return new LongSpinedNodeBuilder();
    }

    // Double nodes

    /**
     * Produces a {@link Node.OfDouble} describing a double[] array.
     *
     * &lt;p&gt;The node will hold a reference to the array and will not make a copy.
     *
     * @param array the array
     * @return a node holding an array
     */
    static Node.OfDouble node(final double[] array) {
        return new DoubleArrayNode(array);
    }

    /**
     * Produces a {@link Node.Builder.OfDouble}.
     *
     * @param exactSizeIfKnown -1 if a variable size builder is requested,
     * otherwise the exact capacity desired.  A fixed capacity builder will
     * fail if the wrong number of elements are added to the builder.
     * @return a {@code Node.Builder.OfDouble}
     */
    static Node.Builder.OfDouble doubleBuilder(long exactSizeIfKnown) {
        return (exactSizeIfKnown &gt;= 0 &amp;&amp; exactSizeIfKnown &lt; MAX_ARRAY_SIZE)
               ? new DoubleFixedNodeBuilder(exactSizeIfKnown)
               : doubleBuilder();
    }

    /**
     * Produces a variable size @{link Node.Builder.OfDouble}.
     *
     * @return a {@code Node.Builder.OfDouble}
     */
    static Node.Builder.OfDouble doubleBuilder() {
        return new DoubleSpinedNodeBuilder();
    }

    // Parallel evaluation of pipelines to nodes

    /**
     * Collect, in parallel, elements output from a pipeline and describe those
     * elements with a {@link Node}.
     *
     * @implSpec
     * If the exact size of the output from the pipeline is known and the source
     * {@link Spliterator} has the {@link Spliterator#SUBSIZED} characteristic,
     * then a flat {@link Node} will be returned whose content is an array,
     * since the size is known the array can be constructed in advance and
     * output elements can be placed into the array concurrently by leaf
     * tasks at the correct offsets.  If the exact size is not known, output
     * elements are collected into a conc-node whose shape mirrors that
     * of the computation. This conc-node can then be flattened in
     * parallel to produce a flat {@code Node} if desired.
     *
     * @param helper the pipeline helper describing the pipeline
     * @param flattenTree whether a conc node should be flattened into a node
     *                    describing an array before returning
     * @param generator the array generator
     * @return a {@link Node} describing the output elements
     */
    public static &lt;P_IN, P_OUT&gt; Node&lt;P_OUT&gt; collect(PipelineHelper&lt;P_OUT&gt; helper,
                                                    Spliterator&lt;P_IN&gt; spliterator,
                                                    boolean flattenTree,
                                                    IntFunction&lt;P_OUT[]&gt; generator) {
        long size = helper.exactOutputSizeIfKnown(spliterator);
        if (size &gt;= 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {
            if (size &gt;= MAX_ARRAY_SIZE)
                throw new IllegalArgumentException(BAD_SIZE);
            P_OUT[] array = generator.apply((int) size);
            new SizedCollectorTask.OfRef&lt;&gt;(spliterator, helper, array).invoke();
            return node(array);
        } else {
            Node&lt;P_OUT&gt; node = new CollectorTask.OfRef&lt;&gt;(helper, generator, spliterator).invoke();
            return flattenTree ? flatten(node, generator) : node;
        }
    }

    /**
     * Collect, in parallel, elements output from an int-valued pipeline and
     * describe those elements with a {@link Node.OfInt}.
     *
     * @implSpec
     * If the exact size of the output from the pipeline is known and the source
     * {@link Spliterator} has the {@link Spliterator#SUBSIZED} characteristic,
     * then a flat {@link Node} will be returned whose content is an array,
     * since the size is known the array can be constructed in advance and
     * output elements can be placed into the array concurrently by leaf
     * tasks at the correct offsets.  If the exact size is not known, output
     * elements are collected into a conc-node whose shape mirrors that
     * of the computation. This conc-node can then be flattened in
     * parallel to produce a flat {@code Node.OfInt} if desired.
     *
     * @param &lt;P_IN&gt; the type of elements from the source Spliterator
     * @param helper the pipeline helper describing the pipeline
     * @param flattenTree whether a conc node should be flattened into a node
     *                    describing an array before returning
     * @return a {@link Node.OfInt} describing the output elements
     */
    public static &lt;P_IN&gt; Node.OfInt collectInt(PipelineHelper&lt;Integer&gt; helper,
                                               Spliterator&lt;P_IN&gt; spliterator,
                                               boolean flattenTree) {
        long size = helper.exactOutputSizeIfKnown(spliterator);
        if (size &gt;= 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {
            if (size &gt;= MAX_ARRAY_SIZE)
                throw new IllegalArgumentException(BAD_SIZE);
            int[] array = new int[(int) size];
            new SizedCollectorTask.OfInt&lt;&gt;(spliterator, helper, array).invoke();
            return node(array);
        }
        else {
            Node.OfInt node = new CollectorTask.OfInt&lt;&gt;(helper, spliterator).invoke();
            return flattenTree ? flattenInt(node) : node;
        }
    }

    /**
     * Collect, in parallel, elements output from a long-valued pipeline and
     * describe those elements with a {@link Node.OfLong}.
     *
     * @implSpec
     * If the exact size of the output from the pipeline is known and the source
     * {@link Spliterator} has the {@link Spliterator#SUBSIZED} characteristic,
     * then a flat {@link Node} will be returned whose content is an array,
     * since the size is known the array can be constructed in advance and
     * output elements can be placed into the array concurrently by leaf
     * tasks at the correct offsets.  If the exact size is not known, output
     * elements are collected into a conc-node whose shape mirrors that
     * of the computation. This conc-node can then be flattened in
     * parallel to produce a flat {@code Node.OfLong} if desired.
     *
     * @param &lt;P_IN&gt; the type of elements from the source Spliterator
     * @param helper the pipeline helper describing the pipeline
     * @param flattenTree whether a conc node should be flattened into a node
     *                    describing an array before returning
     * @return a {@link Node.OfLong} describing the output elements
     */
    public static &lt;P_IN&gt; Node.OfLong collectLong(PipelineHelper&lt;Long&gt; helper,
                                                 Spliterator&lt;P_IN&gt; spliterator,
                                                 boolean flattenTree) {
        long size = helper.exactOutputSizeIfKnown(spliterator);
        if (size &gt;= 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {
            if (size &gt;= MAX_ARRAY_SIZE)
                throw new IllegalArgumentException(BAD_SIZE);
            long[] array = new long[(int) size];
            new SizedCollectorTask.OfLong&lt;&gt;(spliterator, helper, array).invoke();
            return node(array);
        }
        else {
            Node.OfLong node = new CollectorTask.OfLong&lt;&gt;(helper, spliterator).invoke();
            return flattenTree ? flattenLong(node) : node;
        }
    }

    /**
     * Collect, in parallel, elements output from n double-valued pipeline and
     * describe those elements with a {@link Node.OfDouble}.
     *
     * @implSpec
     * If the exact size of the output from the pipeline is known and the source
     * {@link Spliterator} has the {@link Spliterator#SUBSIZED} characteristic,
     * then a flat {@link Node} will be returned whose content is an array,
     * since the size is known the array can be constructed in advance and
     * output elements can be placed into the array concurrently by leaf
     * tasks at the correct offsets.  If the exact size is not known, output
     * elements are collected into a conc-node whose shape mirrors that
     * of the computation. This conc-node can then be flattened in
     * parallel to produce a flat {@code Node.OfDouble} if desired.
     *
     * @param &lt;P_IN&gt; the type of elements from the source Spliterator
     * @param helper the pipeline helper describing the pipeline
     * @param flattenTree whether a conc node should be flattened into a node
     *                    describing an array before returning
     * @return a {@link Node.OfDouble} describing the output elements
     */
    public static &lt;P_IN&gt; Node.OfDouble collectDouble(PipelineHelper&lt;Double&gt; helper,
                                                     Spliterator&lt;P_IN&gt; spliterator,
                                                     boolean flattenTree) {
        long size = helper.exactOutputSizeIfKnown(spliterator);
        if (size &gt;= 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {
            if (size &gt;= MAX_ARRAY_SIZE)
                throw new IllegalArgumentException(BAD_SIZE);
            double[] array = new double[(int) size];
            new SizedCollectorTask.OfDouble&lt;&gt;(spliterator, helper, array).invoke();
            return node(array);
        }
        else {
            Node.OfDouble node = new CollectorTask.OfDouble&lt;&gt;(helper, spliterator).invoke();
            return flattenTree ? flattenDouble(node) : node;
        }
    }

    // Parallel flattening of nodes

    /**
     * Flatten, in parallel, a {@link Node}.  A flattened node is one that has
     * no children.  If the node is already flat, it is simply returned.
     *
     * @implSpec
     * If a new node is to be created, the generator is used to create an array
     * whose length is {@link Node#count()}.  Then the node tree is traversed
     * and leaf node elements are placed in the array concurrently by leaf tasks
     * at the correct offsets.
     *
     * @param &lt;T&gt; type of elements contained by the node
     * @param node the node to flatten
     * @param generator the array factory used to create array instances
     * @return a flat {@code Node}
     */
    public static &lt;T&gt; Node&lt;T&gt; flatten(Node&lt;T&gt; node, IntFunction&lt;T[]&gt; generator) {
        if (node.getChildCount() &gt; 0) {
            long size = node.count();
            if (size &gt;= MAX_ARRAY_SIZE)
                throw new IllegalArgumentException(BAD_SIZE);
            T[] array = generator.apply((int) size);
            new ToArrayTask.OfRef&lt;&gt;(node, array, 0).invoke();
            return node(array);
        } else {
            return node;
        }
    }

    /**
     * Flatten, in parallel, a {@link Node.OfInt}.  A flattened node is one that
     * has no children.  If the node is already flat, it is simply returned.
     *
     * @implSpec
     * If a new node is to be created, a new int[] array is created whose length
     * is {@link Node#count()}.  Then the node tree is traversed and leaf node
     * elements are placed in the array concurrently by leaf tasks at the
     * correct offsets.
     *
     * @param node the node to flatten
     * @return a flat {@code Node.OfInt}
     */
    public static Node.OfInt flattenInt(Node.OfInt node) {
        if (node.getChildCount() &gt; 0) {
            long size = node.count();
            if (size &gt;= MAX_ARRAY_SIZE)
                throw new IllegalArgumentException(BAD_SIZE);
            int[] array = new int[(int) size];
            new ToArrayTask.OfInt(node, array, 0).invoke();
            return node(array);
        } else {
            return node;
        }
    }

    /**
     * Flatten, in parallel, a {@link Node.OfLong}.  A flattened node is one that
     * has no children.  If the node is already flat, it is simply returned.
     *
     * @implSpec
     * If a new node is to be created, a new long[] array is created whose length
     * is {@link Node#count()}.  Then the node tree is traversed and leaf node
     * elements are placed in the array concurrently by leaf tasks at the
     * correct offsets.
     *
     * @param node the node to flatten
     * @return a flat {@code Node.OfLong}
     */
    public static Node.OfLong flattenLong(Node.OfLong node) {
        if (node.getChildCount() &gt; 0) {
            long size = node.count();
            if (size &gt;= MAX_ARRAY_SIZE)
                throw new IllegalArgumentException(BAD_SIZE);
            long[] array = new long[(int) size];
            new ToArrayTask.OfLong(node, array, 0).invoke();
            return node(array);
        } else {
            return node;
        }
    }

    /**
     * Flatten, in parallel, a {@link Node.OfDouble}.  A flattened node is one that
     * has no children.  If the node is already flat, it is simply returned.
     *
     * @implSpec
     * If a new node is to be created, a new double[] array is created whose length
     * is {@link Node#count()}.  Then the node tree is traversed and leaf node
     * elements are placed in the array concurrently by leaf tasks at the
     * correct offsets.
     *
     * @param node the node to flatten
     * @return a flat {@code Node.OfDouble}
     */
    public static Node.OfDouble flattenDouble(Node.OfDouble node) {
        if (node.getChildCount() &gt; 0) {
            long size = node.count();
            if (size &gt;= MAX_ARRAY_SIZE)
                throw new IllegalArgumentException(BAD_SIZE);
            double[] array = new double[(int) size];
            new ToArrayTask.OfDouble(node, array, 0).invoke();
            return node(array);
        } else {
            return node;
        }
    }

    // Implementations

    private static abstract class EmptyNode&lt;T, T_ARR, T_CONS&gt; implements Node&lt;T&gt; {
        EmptyNode() { }

        @Override
        public T[] asArray(IntFunction&lt;T[]&gt; generator) {
            return generator.apply(0);
        }

        public void copyInto(T_ARR array, int offset) { }

        @Override
        public long count() {
            return 0;
        }

        public void forEach(T_CONS consumer) { }

        private static class OfRef&lt;T&gt; extends EmptyNode&lt;T, T[], Consumer&lt;? super T&gt;&gt; {
            private OfRef() {
                super();
            }

            @Override
            public Spliterator&lt;T&gt; spliterator() {
                return Spliterators.emptySpliterator();
            }
        }

        private static final class OfInt
                extends EmptyNode&lt;Integer, int[], IntConsumer&gt;
                implements Node.OfInt {

            OfInt() { } // Avoid creation of special accessor

            @Override
            public Spliterator.OfInt spliterator() {
                return Spliterators.emptyIntSpliterator();
            }

            @Override
            public int[] asPrimitiveArray() {
                return EMPTY_INT_ARRAY;
            }
        }

        private static final class OfLong
                extends EmptyNode&lt;Long, long[], LongConsumer&gt;
                implements Node.OfLong {

            OfLong() { } // Avoid creation of special accessor

            @Override
            public Spliterator.OfLong spliterator() {
                return Spliterators.emptyLongSpliterator();
            }

            @Override
            public long[] asPrimitiveArray() {
                return EMPTY_LONG_ARRAY;
            }
        }

        private static final class OfDouble
                extends EmptyNode&lt;Double, double[], DoubleConsumer&gt;
                implements Node.OfDouble {

            OfDouble() { } // Avoid creation of special accessor

            @Override
            public Spliterator.OfDouble spliterator() {
                return Spliterators.emptyDoubleSpliterator();
            }

            @Override
            public double[] asPrimitiveArray() {
                return EMPTY_DOUBLE_ARRAY;
            }
        }
    }

    /** Node class for a reference array */
    private static class ArrayNode&lt;T&gt; implements Node&lt;T&gt; {
        final T[] array;
        int curSize;

        @SuppressWarnings(&quot;unchecked&quot;)
        ArrayNode(long size, IntFunction&lt;T[]&gt; generator) {
            if (size &gt;= MAX_ARRAY_SIZE)
                throw new IllegalArgumentException(BAD_SIZE);
            this.array = generator.apply((int) size);
            this.curSize = 0;
        }

        ArrayNode(T[] array) {
            this.array = array;
            this.curSize = array.length;
        }

        // Node

        @Override
        public Spliterator&lt;T&gt; spliterator() {
            return Arrays.spliterator(array, 0, curSize);
        }

        @Override
        public void copyInto(T[] dest, int destOffset) {
            System.arraycopy(array, 0, dest, destOffset, curSize);
        }

        @Override
        public T[] asArray(IntFunction&lt;T[]&gt; generator) {
            if (array.length == curSize) {
                return array;
            } else {
                throw new IllegalStateException();
            }
        }

        @Override
        public long count() {
            return curSize;
        }

        @Override
        public void forEach(Consumer&lt;? super T&gt; consumer) {
            for (int i = 0; i &lt; curSize; i++) {
                consumer.accept(array[i]);
            }
        }

        //

        @Override
        public String toString() {
            return String.format(&quot;ArrayNode[%d][%s]&quot;,
                                 array.length - curSize, Arrays.toString(array));
        }
    }

    /** Node class for a Collection */
    private static final class CollectionNode&lt;T&gt; implements Node&lt;T&gt; {
        private final Collection&lt;T&gt; c;

        CollectionNode(Collection&lt;T&gt; c) {
            this.c = c;
        }

        // Node

        @Override
        public Spliterator&lt;T&gt; spliterator() {
            return c.stream().spliterator();
        }

        @Override
        public void copyInto(T[] array, int offset) {
            for (T t : c)
                array[offset++] = t;
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public T[] asArray(IntFunction&lt;T[]&gt; generator) {
            return c.toArray(generator.apply(c.size()));
        }

        @Override
        public long count() {
            return c.size();
        }

        @Override
        public void forEach(Consumer&lt;? super T&gt; consumer) {
            c.forEach(consumer);
        }

        //

        @Override
        public String toString() {
            return String.format(&quot;CollectionNode[%d][%s]&quot;, c.size(), c);
        }
    }

    /**
     * Node class for an internal node with two or more children
     */
    private static abstract class AbstractConcNode&lt;T, T_NODE extends Node&lt;T&gt;&gt; implements Node&lt;T&gt; {
        protected final T_NODE left;
        protected final T_NODE right;
        private final long size;

        AbstractConcNode(T_NODE left, T_NODE right) {
            this.left = left;
            this.right = right;
            // The Node count will be required when the Node spliterator is
            // obtained and it is cheaper to aggressively calculate bottom up
            // as the tree is built rather than later on from the top down
            // traversing the tree
            this.size = left.count() + right.count();
        }

        @Override
        public int getChildCount() {
            return 2;
        }

        @Override
        public T_NODE getChild(int i) {
            if (i == 0) return left;
            if (i == 1) return right;
            throw new IndexOutOfBoundsException();
        }

        @Override
        public long count() {
            return size;
        }
    }

    static final class ConcNode&lt;T&gt;
            extends AbstractConcNode&lt;T, Node&lt;T&gt;&gt;
            implements Node&lt;T&gt; {

        ConcNode(Node&lt;T&gt; left, Node&lt;T&gt; right) {
            super(left, right);
        }

        @Override
        public Spliterator&lt;T&gt; spliterator() {
            return new Nodes.InternalNodeSpliterator.OfRef&lt;&gt;(this);
        }

        @Override
        public void copyInto(T[] array, int offset) {
            Objects.requireNonNull(array);
            left.copyInto(array, offset);
            // Cast to int is safe since it is the callers responsibility to
            // ensure that there is sufficient room in the array
            right.copyInto(array, offset + (int) left.count());
        }

        @Override
        public T[] asArray(IntFunction&lt;T[]&gt; generator) {
            long size = count();
            if (size &gt;= MAX_ARRAY_SIZE)
                throw new IllegalArgumentException(BAD_SIZE);
            T[] array = generator.apply((int) size);
            copyInto(array, 0);
            return array;
        }

        @Override
        public void forEach(Consumer&lt;? super T&gt; consumer) {
            left.forEach(consumer);
            right.forEach(consumer);
        }

        @Override
        public Node&lt;T&gt; truncate(long from, long to, IntFunction&lt;T[]&gt; generator) {
            if (from == 0 &amp;&amp; to == count())
                return this;
            long leftCount = left.count();
            if (from &gt;= leftCount)
                return right.truncate(from - leftCount, to - leftCount, generator);
            else if (to &lt;= leftCount)
                return left.truncate(from, to, generator);
            else {
                return Nodes.conc(getShape(), left.truncate(from, leftCount, generator),
                                  right.truncate(0, to - leftCount, generator));
            }
        }

        @Override
        public String toString() {
            if (count() &lt; 32) {
                return String.format(&quot;ConcNode[%s.%s]&quot;, left, right);
            } else {
                return String.format(&quot;ConcNode[size=%d]&quot;, count());
            }
        }

        private abstract static class OfPrimitive&lt;E, T_CONS, T_ARR,
                                                  T_SPLITR extends Spliterator.OfPrimitive&lt;E, T_CONS, T_SPLITR&gt;,
                                                  T_NODE extends Node.OfPrimitive&lt;E, T_CONS, T_ARR, T_SPLITR, T_NODE&gt;&gt;
                extends AbstractConcNode&lt;E, T_NODE&gt;
                implements Node.OfPrimitive&lt;E, T_CONS, T_ARR, T_SPLITR, T_NODE&gt; {

            OfPrimitive(T_NODE left, T_NODE right) {
                super(left, right);
            }

            @Override
            public void forEach(T_CONS consumer) {
                left.forEach(consumer);
                right.forEach(consumer);
            }

            @Override
            public void copyInto(T_ARR array, int offset) {
                left.copyInto(array, offset);
                // Cast to int is safe since it is the callers responsibility to
                // ensure that there is sufficient room in the array
                right.copyInto(array, offset + (int) left.count());
            }

            @Override
            public T_ARR asPrimitiveArray() {
                long size = count();
                if (size &gt;= MAX_ARRAY_SIZE)
                    throw new IllegalArgumentException(BAD_SIZE);
                T_ARR array = newArray((int) size);
                copyInto(array, 0);
                return array;
            }

            @Override
            public String toString() {
                if (count() &lt; 32)
                    return String.format(&quot;%s[%s.%s]&quot;, this.getClass().getName(), left, right);
                else
                    return String.format(&quot;%s[size=%d]&quot;, this.getClass().getName(), count());
            }
        }

        static final class OfInt
                extends ConcNode.OfPrimitive&lt;Integer, IntConsumer, int[], Spliterator.OfInt, Node.OfInt&gt;
                implements Node.OfInt {

            OfInt(Node.OfInt left, Node.OfInt right) {
                super(left, right);
            }

            @Override
            public Spliterator.OfInt spliterator() {
                return new InternalNodeSpliterator.OfInt(this);
            }
        }

        static final class OfLong
                extends ConcNode.OfPrimitive&lt;Long, LongConsumer, long[], Spliterator.OfLong, Node.OfLong&gt;
                implements Node.OfLong {

            OfLong(Node.OfLong left, Node.OfLong right) {
                super(left, right);
            }

            @Override
            public Spliterator.OfLong spliterator() {
                return new InternalNodeSpliterator.OfLong(this);
            }
        }

        static final class OfDouble
                extends ConcNode.OfPrimitive&lt;Double, DoubleConsumer, double[], Spliterator.OfDouble, Node.OfDouble&gt;
                implements Node.OfDouble {

            OfDouble(Node.OfDouble left, Node.OfDouble right) {
                super(left, right);
            }

            @Override
            public Spliterator.OfDouble spliterator() {
                return new InternalNodeSpliterator.OfDouble(this);
            }
        }
    }

    /** Abstract class for spliterator for all internal node classes */
    private static abstract class InternalNodeSpliterator&lt;T,
                                                          S extends Spliterator&lt;T&gt;,
                                                          N extends Node&lt;T&gt;&gt;
            implements Spliterator&lt;T&gt; {
        // Node we are pointing to
        // null if full traversal has occurred
        N curNode;

        // next child of curNode to consume
        int curChildIndex;

        // The spliterator of the curNode if that node is last and has no children.
        // This spliterator will be delegated to for splitting and traversing.
        // null if curNode has children
        S lastNodeSpliterator;

        // spliterator used while traversing with tryAdvance
        // null if no partial traversal has occurred
        S tryAdvanceSpliterator;

        // node stack used when traversing to search and find leaf nodes
        // null if no partial traversal has occurred
        Deque&lt;N&gt; tryAdvanceStack;

        InternalNodeSpliterator(N curNode) {
            this.curNode = curNode;
        }

        /**
         * Initiate a stack containing, in left-to-right order, the child nodes
         * covered by this spliterator
         */
        protected final Deque&lt;N&gt; initStack() {
            // Bias size to the case where leaf nodes are close to this node
            // 8 is the minimum initial capacity for the ArrayDeque implementation
            Deque&lt;N&gt; stack = new ArrayDeque&lt;&gt;(8);
            for (int i = curNode.getChildCount() - 1; i &gt;= curChildIndex; i--)
                stack.addFirst((N) curNode.getChild(i));
            return stack;
        }

        /**
         * Depth first search, in left-to-right order, of the node tree, using
         * an explicit stack, to find the next non-empty leaf node.
         */
        protected final N findNextLeafNode(Deque&lt;N&gt; stack) {
            N n = null;
            while ((n = stack.pollFirst()) != null) {
                if (n.getChildCount() == 0) {
                    if (n.count() &gt; 0)
                        return n;
                } else {
                    for (int i = n.getChildCount() - 1; i &gt;= 0; i--)
                        stack.addFirst((N) n.getChild(i));
                }
            }

            return null;
        }

        protected final boolean initTryAdvance() {
            if (curNode == null)
                return false;

            if (tryAdvanceSpliterator == null) {
                if (lastNodeSpliterator == null) {
                    // Initiate the node stack
                    tryAdvanceStack = initStack();
                    N leaf = findNextLeafNode(tryAdvanceStack);
                    if (leaf != null)
                        tryAdvanceSpliterator = (S) leaf.spliterator();
                    else {
                        // A non-empty leaf node was not found
                        // No elements to traverse
                        curNode = null;
                        return false;
                    }
                }
                else
                    tryAdvanceSpliterator = lastNodeSpliterator;
            }
            return true;
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public final S trySplit() {
            if (curNode == null || tryAdvanceSpliterator != null)
                return null; // Cannot split if fully or partially traversed
            else if (lastNodeSpliterator != null)
                return (S) lastNodeSpliterator.trySplit();
            else if (curChildIndex &lt; curNode.getChildCount() - 1)
                return (S) curNode.getChild(curChildIndex++).spliterator();
            else {
                curNode = (N) curNode.getChild(curChildIndex);
                if (curNode.getChildCount() == 0) {
                    lastNodeSpliterator = (S) curNode.spliterator();
                    return (S) lastNodeSpliterator.trySplit();
                }
                else {
                    curChildIndex = 0;
                    return (S) curNode.getChild(curChildIndex++).spliterator();
                }
            }
        }

        @Override
        public final long estimateSize() {
            if (curNode == null)
                return 0;

            // Will not reflect the effects of partial traversal.
            // This is compliant with the specification
            if (lastNodeSpliterator != null)
                return lastNodeSpliterator.estimateSize();
            else {
                long size = 0;
                for (int i = curChildIndex; i &lt; curNode.getChildCount(); i++)
                    size += curNode.getChild(i).count();
                return size;
            }
        }

        @Override
        public final int characteristics() {
            return Spliterator.SIZED;
        }

        private static final class OfRef&lt;T&gt;
                extends InternalNodeSpliterator&lt;T, Spliterator&lt;T&gt;, Node&lt;T&gt;&gt; {

            OfRef(Node&lt;T&gt; curNode) {
                super(curNode);
            }

            @Override
            public boolean tryAdvance(Consumer&lt;? super T&gt; consumer) {
                if (!initTryAdvance())
                    return false;

                boolean hasNext = tryAdvanceSpliterator.tryAdvance(consumer);
                if (!hasNext) {
                    if (lastNodeSpliterator == null) {
                        // Advance to the spliterator of the next non-empty leaf node
                        Node&lt;T&gt; leaf = findNextLeafNode(tryAdvanceStack);
                        if (leaf != null) {
                            tryAdvanceSpliterator = leaf.spliterator();
                            // Since the node is not-empty the spliterator can be advanced
                            return tryAdvanceSpliterator.tryAdvance(consumer);
                        }
                    }
                    // No more elements to traverse
                    curNode = null;
                }
                return hasNext;
            }

            @Override
            public void forEachRemaining(Consumer&lt;? super T&gt; consumer) {
                if (curNode == null)
                    return;

                if (tryAdvanceSpliterator == null) {
                    if (lastNodeSpliterator == null) {
                        Deque&lt;Node&lt;T&gt;&gt; stack = initStack();
                        Node&lt;T&gt; leaf;
                        while ((leaf = findNextLeafNode(stack)) != null) {
                            leaf.forEach(consumer);
                        }
                        curNode = null;
                    }
                    else
                        lastNodeSpliterator.forEachRemaining(consumer);
                }
                else
                    while(tryAdvance(consumer)) { }
            }
        }

        private static abstract class OfPrimitive&lt;T, T_CONS, T_ARR,
                                                  T_SPLITR extends Spliterator.OfPrimitive&lt;T, T_CONS, T_SPLITR&gt;,
                                                  N extends Node.OfPrimitive&lt;T, T_CONS, T_ARR, T_SPLITR, N&gt;&gt;
                extends InternalNodeSpliterator&lt;T, T_SPLITR, N&gt;
                implements Spliterator.OfPrimitive&lt;T, T_CONS, T_SPLITR&gt; {

            OfPrimitive(N cur) {
                super(cur);
            }

            @Override
            public boolean tryAdvance(T_CONS consumer) {
                if (!initTryAdvance())
                    return false;

                boolean hasNext = tryAdvanceSpliterator.tryAdvance(consumer);
                if (!hasNext) {
                    if (lastNodeSpliterator == null) {
                        // Advance to the spliterator of the next non-empty leaf node
                        N leaf = findNextLeafNode(tryAdvanceStack);
                        if (leaf != null) {
                            tryAdvanceSpliterator = leaf.spliterator();
                            // Since the node is not-empty the spliterator can be advanced
                            return tryAdvanceSpliterator.tryAdvance(consumer);
                        }
                    }
                    // No more elements to traverse
                    curNode = null;
                }
                return hasNext;
            }

            @Override
            public void forEachRemaining(T_CONS consumer) {
                if (curNode == null)
                    return;

                if (tryAdvanceSpliterator == null) {
                    if (lastNodeSpliterator == null) {
                        Deque&lt;N&gt; stack = initStack();
                        N leaf;
                        while ((leaf = findNextLeafNode(stack)) != null) {
                            leaf.forEach(consumer);
                        }
                        curNode = null;
                    }
                    else
                        lastNodeSpliterator.forEachRemaining(consumer);
                }
                else
                    while(tryAdvance(consumer)) { }
            }
        }

        private static final class OfInt
                extends OfPrimitive&lt;Integer, IntConsumer, int[], Spliterator.OfInt, Node.OfInt&gt;
                implements Spliterator.OfInt {

            OfInt(Node.OfInt cur) {
                super(cur);
            }
        }

        private static final class OfLong
                extends OfPrimitive&lt;Long, LongConsumer, long[], Spliterator.OfLong, Node.OfLong&gt;
                implements Spliterator.OfLong {

            OfLong(Node.OfLong cur) {
                super(cur);
            }
        }

        private static final class OfDouble
                extends OfPrimitive&lt;Double, DoubleConsumer, double[], Spliterator.OfDouble, Node.OfDouble&gt;
                implements Spliterator.OfDouble {

            OfDouble(Node.OfDouble cur) {
                super(cur);
            }
        }
    }

    /**
     * Fixed-sized builder class for reference nodes
     */
    private static final class FixedNodeBuilder&lt;T&gt;
            extends ArrayNode&lt;T&gt;
            implements Node.Builder&lt;T&gt; {

        FixedNodeBuilder(long size, IntFunction&lt;T[]&gt; generator) {
            super(size, generator);
            assert size &lt; MAX_ARRAY_SIZE;
        }

        @Override
        public Node&lt;T&gt; build() {
            if (curSize &lt; array.length)
                throw new IllegalStateException(String.format(&quot;Current size %d is less than fixed size %d&quot;,
                                                              curSize, array.length));
            return this;
        }

        @Override
        public void begin(long size) {
            if (size != array.length)
                throw new IllegalStateException(String.format(&quot;Begin size %d is not equal to fixed size %d&quot;,
                                                              size, array.length));
            curSize = 0;
        }

        @Override
        public void accept(T t) {
            if (curSize &lt; array.length) {
                array[curSize++] = t;
            } else {
                throw new IllegalStateException(String.format(&quot;Accept exceeded fixed size of %d&quot;,
                                                              array.length));
            }
        }

        @Override
        public void end() {
            if (curSize &lt; array.length)
                throw new IllegalStateException(String.format(&quot;End size %d is less than fixed size %d&quot;,
                                                              curSize, array.length));
        }

        @Override
        public String toString() {
            return String.format(&quot;FixedNodeBuilder[%d][%s]&quot;,
                                 array.length - curSize, Arrays.toString(array));
        }
    }

    /**
     * Variable-sized builder class for reference nodes
     */
    private static final class SpinedNodeBuilder&lt;T&gt;
            extends SpinedBuffer&lt;T&gt;
            implements Node&lt;T&gt;, Node.Builder&lt;T&gt; {
        private boolean building = false;

        SpinedNodeBuilder() {} // Avoid creation of special accessor

        @Override
        public Spliterator&lt;T&gt; spliterator() {
            assert !building : &quot;during building&quot;;
            return super.spliterator();
        }

        @Override
        public void forEach(Consumer&lt;? super T&gt; consumer) {
            assert !building : &quot;during building&quot;;
            super.forEach(consumer);
        }

        //
        @Override
        public void begin(long size) {
            assert !building : &quot;was already building&quot;;
            building = true;
            clear();
            ensureCapacity(size);
        }

        @Override
        public void accept(T t) {
            assert building : &quot;not building&quot;;
            super.accept(t);
        }

        @Override
        public void end() {
            assert building : &quot;was not building&quot;;
            building = false;
            // @@@ check begin(size) and size
        }

        @Override
        public void copyInto(T[] array, int offset) {
            assert !building : &quot;during building&quot;;
            super.copyInto(array, offset);
        }

        @Override
        public T[] asArray(IntFunction&lt;T[]&gt; arrayFactory) {
            assert !building : &quot;during building&quot;;
            return super.asArray(arrayFactory);
        }

        @Override
        public Node&lt;T&gt; build() {
            assert !building : &quot;during building&quot;;
            return this;
        }
    }

    //

    private static final int[] EMPTY_INT_ARRAY = new int[0];
    private static final long[] EMPTY_LONG_ARRAY = new long[0];
    private static final double[] EMPTY_DOUBLE_ARRAY = new double[0];

    private static class IntArrayNode implements Node.OfInt {
        final int[] array;
        int curSize;

        IntArrayNode(long size) {
            if (size &gt;= MAX_ARRAY_SIZE)
                throw new IllegalArgumentException(BAD_SIZE);
            this.array = new int[(int) size];
            this.curSize = 0;
        }

        IntArrayNode(int[] array) {
            this.array = array;
            this.curSize = array.length;
        }

        // Node

        @Override
        public Spliterator.OfInt spliterator() {
            return Arrays.spliterator(array, 0, curSize);
        }

        @Override
        public int[] asPrimitiveArray() {
            if (array.length == curSize) {
                return array;
            } else {
                return Arrays.copyOf(array, curSize);
            }
        }

        @Override
        public void copyInto(int[] dest, int destOffset) {
            System.arraycopy(array, 0, dest, destOffset, curSize);
        }

        @Override
        public long count() {
            return curSize;
        }

        @Override
        public void forEach(IntConsumer consumer) {
            for (int i = 0; i &lt; curSize; i++) {
                consumer.accept(array[i]);
            }
        }

        @Override
        public String toString() {
            return String.format(&quot;IntArrayNode[%d][%s]&quot;,
                                 array.length - curSize, Arrays.toString(array));
        }
    }

    private static class LongArrayNode implements Node.OfLong {
        final long[] array;
        int curSize;

        LongArrayNode(long size) {
            if (size &gt;= MAX_ARRAY_SIZE)
                throw new IllegalArgumentException(BAD_SIZE);
            this.array = new long[(int) size];
            this.curSize = 0;
        }

        LongArrayNode(long[] array) {
            this.array = array;
            this.curSize = array.length;
        }

        @Override
        public Spliterator.OfLong spliterator() {
            return Arrays.spliterator(array, 0, curSize);
        }

        @Override
        public long[] asPrimitiveArray() {
            if (array.length == curSize) {
                return array;
            } else {
                return Arrays.copyOf(array, curSize);
            }
        }

        @Override
        public void copyInto(long[] dest, int destOffset) {
            System.arraycopy(array, 0, dest, destOffset, curSize);
        }

        @Override
        public long count() {
            return curSize;
        }

        @Override
        public void forEach(LongConsumer consumer) {
            for (int i = 0; i &lt; curSize; i++) {
                consumer.accept(array[i]);
            }
        }

        @Override
        public String toString() {
            return String.format(&quot;LongArrayNode[%d][%s]&quot;,
                                 array.length - curSize, Arrays.toString(array));
        }
    }

    private static class DoubleArrayNode implements Node.OfDouble {
        final double[] array;
        int curSize;

        DoubleArrayNode(long size) {
            if (size &gt;= MAX_ARRAY_SIZE)
                throw new IllegalArgumentException(BAD_SIZE);
            this.array = new double[(int) size];
            this.curSize = 0;
        }

        DoubleArrayNode(double[] array) {
            this.array = array;
            this.curSize = array.length;
        }

        @Override
        public Spliterator.OfDouble spliterator() {
            return Arrays.spliterator(array, 0, curSize);
        }

        @Override
        public double[] asPrimitiveArray() {
            if (array.length == curSize) {
                return array;
            } else {
                return Arrays.copyOf(array, curSize);
            }
        }

        @Override
        public void copyInto(double[] dest, int destOffset) {
            System.arraycopy(array, 0, dest, destOffset, curSize);
        }

        @Override
        public long count() {
            return curSize;
        }

        @Override
        public void forEach(DoubleConsumer consumer) {
            for (int i = 0; i &lt; curSize; i++) {
                consumer.accept(array[i]);
            }
        }

        @Override
        public String toString() {
            return String.format(&quot;DoubleArrayNode[%d][%s]&quot;,
                                 array.length - curSize, Arrays.toString(array));
        }
    }

    private static final class IntFixedNodeBuilder
            extends IntArrayNode
            implements Node.Builder.OfInt {

        IntFixedNodeBuilder(long size) {
            super(size);
            assert size &lt; MAX_ARRAY_SIZE;
        }

        @Override
        public Node.OfInt build() {
            if (curSize &lt; array.length) {
                throw new IllegalStateException(String.format(&quot;Current size %d is less than fixed size %d&quot;,
                                                              curSize, array.length));
            }

            return this;
        }

        @Override
        public void begin(long size) {
            if (size != array.length) {
                throw new IllegalStateException(String.format(&quot;Begin size %d is not equal to fixed size %d&quot;,
                                                              size, array.length));
            }

            curSize = 0;
        }

        @Override
        public void accept(int i) {
            if (curSize &lt; array.length) {
                array[curSize++] = i;
            } else {
                throw new IllegalStateException(String.format(&quot;Accept exceeded fixed size of %d&quot;,
                                                              array.length));
            }
        }

        @Override
        public void end() {
            if (curSize &lt; array.length) {
                throw new IllegalStateException(String.format(&quot;End size %d is less than fixed size %d&quot;,
                                                              curSize, array.length));
            }
        }

        @Override
        public String toString() {
            return String.format(&quot;IntFixedNodeBuilder[%d][%s]&quot;,
                                 array.length - curSize, Arrays.toString(array));
        }
    }

    private static final class LongFixedNodeBuilder
            extends LongArrayNode
            implements Node.Builder.OfLong {

        LongFixedNodeBuilder(long size) {
            super(size);
            assert size &lt; MAX_ARRAY_SIZE;
        }

        @Override
        public Node.OfLong build() {
            if (curSize &lt; array.length) {
                throw new IllegalStateException(String.format(&quot;Current size %d is less than fixed size %d&quot;,
                                                              curSize, array.length));
            }

            return this;
        }

        @Override
        public void begin(long size) {
            if (size != array.length) {
                throw new IllegalStateException(String.format(&quot;Begin size %d is not equal to fixed size %d&quot;,
                                                              size, array.length));
            }

            curSize = 0;
        }

        @Override
        public void accept(long i) {
            if (curSize &lt; array.length) {
                array[curSize++] = i;
            } else {
                throw new IllegalStateException(String.format(&quot;Accept exceeded fixed size of %d&quot;,
                                                              array.length));
            }
        }

        @Override
        public void end() {
            if (curSize &lt; array.length) {
                throw new IllegalStateException(String.format(&quot;End size %d is less than fixed size %d&quot;,
                                                              curSize, array.length));
            }
        }

        @Override
        public String toString() {
            return String.format(&quot;LongFixedNodeBuilder[%d][%s]&quot;,
                                 array.length - curSize, Arrays.toString(array));
        }
    }

    private static final class DoubleFixedNodeBuilder
            extends DoubleArrayNode
            implements Node.Builder.OfDouble {

        DoubleFixedNodeBuilder(long size) {
            super(size);
            assert size &lt; MAX_ARRAY_SIZE;
        }

        @Override
        public Node.OfDouble build() {
            if (curSize &lt; array.length) {
                throw new IllegalStateException(String.format(&quot;Current size %d is less than fixed size %d&quot;,
                                                              curSize, array.length));
            }

            return this;
        }

        @Override
        public void begin(long size) {
            if (size != array.length) {
                throw new IllegalStateException(String.format(&quot;Begin size %d is not equal to fixed size %d&quot;,
                                                              size, array.length));
            }

            curSize = 0;
        }

        @Override
        public void accept(double i) {
            if (curSize &lt; array.length) {
                array[curSize++] = i;
            } else {
                throw new IllegalStateException(String.format(&quot;Accept exceeded fixed size of %d&quot;,
                                                              array.length));
            }
        }

        @Override
        public void end() {
            if (curSize &lt; array.length) {
                throw new IllegalStateException(String.format(&quot;End size %d is less than fixed size %d&quot;,
                                                              curSize, array.length));
            }
        }

        @Override
        public String toString() {
            return String.format(&quot;DoubleFixedNodeBuilder[%d][%s]&quot;,
                                 array.length - curSize, Arrays.toString(array));
        }
    }

    private static final class IntSpinedNodeBuilder
            extends SpinedBuffer.OfInt
            implements Node.OfInt, Node.Builder.OfInt {
        private boolean building = false;

        IntSpinedNodeBuilder() {} // Avoid creation of special accessor

        @Override
        public Spliterator.OfInt spliterator() {
            assert !building : &quot;during building&quot;;
            return super.spliterator();
        }

        @Override
        public void forEach(IntConsumer consumer) {
            assert !building : &quot;during building&quot;;
            super.forEach(consumer);
        }

        //
        @Override
        public void begin(long size) {
            assert !building : &quot;was already building&quot;;
            building = true;
            clear();
            ensureCapacity(size);
        }

        @Override
        public void accept(int i) {
            assert building : &quot;not building&quot;;
            super.accept(i);
        }

        @Override
        public void end() {
            assert building : &quot;was not building&quot;;
            building = false;
            // @@@ check begin(size) and size
        }

        @Override
        public void copyInto(int[] array, int offset) throws IndexOutOfBoundsException {
            assert !building : &quot;during building&quot;;
            super.copyInto(array, offset);
        }

        @Override
        public int[] asPrimitiveArray() {
            assert !building : &quot;during building&quot;;
            return super.asPrimitiveArray();
        }

        @Override
        public Node.OfInt build() {
            assert !building : &quot;during building&quot;;
            return this;
        }
    }

    private static final class LongSpinedNodeBuilder
            extends SpinedBuffer.OfLong
            implements Node.OfLong, Node.Builder.OfLong {
        private boolean building = false;

        LongSpinedNodeBuilder() {} // Avoid creation of special accessor

        @Override
        public Spliterator.OfLong spliterator() {
            assert !building : &quot;during building&quot;;
            return super.spliterator();
        }

        @Override
        public void forEach(LongConsumer consumer) {
            assert !building : &quot;during building&quot;;
            super.forEach(consumer);
        }

        //
        @Override
        public void begin(long size) {
            assert !building : &quot;was already building&quot;;
            building = true;
            clear();
            ensureCapacity(size);
        }

        @Override
        public void accept(long i) {
            assert building : &quot;not building&quot;;
            super.accept(i);
        }

        @Override
        public void end() {
            assert building : &quot;was not building&quot;;
            building = false;
            // @@@ check begin(size) and size
        }

        @Override
        public void copyInto(long[] array, int offset) {
            assert !building : &quot;during building&quot;;
            super.copyInto(array, offset);
        }

        @Override
        public long[] asPrimitiveArray() {
            assert !building : &quot;during building&quot;;
            return super.asPrimitiveArray();
        }

        @Override
        public Node.OfLong build() {
            assert !building : &quot;during building&quot;;
            return this;
        }
    }

    private static final class DoubleSpinedNodeBuilder
            extends SpinedBuffer.OfDouble
            implements Node.OfDouble, Node.Builder.OfDouble {
        private boolean building = false;

        DoubleSpinedNodeBuilder() {} // Avoid creation of special accessor

        @Override
        public Spliterator.OfDouble spliterator() {
            assert !building : &quot;during building&quot;;
            return super.spliterator();
        }

        @Override
        public void forEach(DoubleConsumer consumer) {
            assert !building : &quot;during building&quot;;
            super.forEach(consumer);
        }

        //
        @Override
        public void begin(long size) {
            assert !building : &quot;was already building&quot;;
            building = true;
            clear();
            ensureCapacity(size);
        }

        @Override
        public void accept(double i) {
            assert building : &quot;not building&quot;;
            super.accept(i);
        }

        @Override
        public void end() {
            assert building : &quot;was not building&quot;;
            building = false;
            // @@@ check begin(size) and size
        }

        @Override
        public void copyInto(double[] array, int offset) {
            assert !building : &quot;during building&quot;;
            super.copyInto(array, offset);
        }

        @Override
        public double[] asPrimitiveArray() {
            assert !building : &quot;during building&quot;;
            return super.asPrimitiveArray();
        }

        @Override
        public Node.OfDouble build() {
            assert !building : &quot;during building&quot;;
            return this;
        }
    }

    /*
     * This and subclasses are not intended to be serializable
     */
    @SuppressWarnings(&quot;serial&quot;)
    private static abstract class SizedCollectorTask&lt;P_IN, P_OUT, T_SINK extends Sink&lt;P_OUT&gt;,
                                                     K extends SizedCollectorTask&lt;P_IN, P_OUT, T_SINK, K&gt;&gt;
            extends CountedCompleter&lt;Void&gt;
            implements Sink&lt;P_OUT&gt; {
        protected final Spliterator&lt;P_IN&gt; spliterator;
        protected final PipelineHelper&lt;P_OUT&gt; helper;
        protected final long targetSize;
        protected long offset;
        protected long length;
        // For Sink implementation
        protected int index, fence;

        SizedCollectorTask(Spliterator&lt;P_IN&gt; spliterator,
                           PipelineHelper&lt;P_OUT&gt; helper,
                           int arrayLength) {
            assert spliterator.hasCharacteristics(Spliterator.SUBSIZED);
            this.spliterator = spliterator;
            this.helper = helper;
            this.targetSize = AbstractTask.suggestTargetSize(spliterator.estimateSize());
            this.offset = 0;
            this.length = arrayLength;
        }

        SizedCollectorTask(K parent, Spliterator&lt;P_IN&gt; spliterator,
                           long offset, long length, int arrayLength) {
            super(parent);
            assert spliterator.hasCharacteristics(Spliterator.SUBSIZED);
            this.spliterator = spliterator;
            this.helper = parent.helper;
            this.targetSize = parent.targetSize;
            this.offset = offset;
            this.length = length;

            if (offset &lt; 0 || length &lt; 0 || (offset + length - 1 &gt;= arrayLength)) {
                throw new IllegalArgumentException(
                        String.format(&quot;offset and length interval [%d, %d + %d) is not within array size interval [0, %d)&quot;,
                                      offset, offset, length, arrayLength));
            }
        }

        @Override
        public void compute() {
            SizedCollectorTask&lt;P_IN, P_OUT, T_SINK, K&gt; task = this;
            Spliterator&lt;P_IN&gt; rightSplit = spliterator, leftSplit;
            while (rightSplit.estimateSize() &gt; task.targetSize &amp;&amp;
                   (leftSplit = rightSplit.trySplit()) != null) {
                task.setPendingCount(1);
                long leftSplitSize = leftSplit.estimateSize();
                task.makeChild(leftSplit, task.offset, leftSplitSize).fork();
                task = task.makeChild(rightSplit, task.offset + leftSplitSize,
                                      task.length - leftSplitSize);
            }

            assert task.offset + task.length &lt; MAX_ARRAY_SIZE;
            T_SINK sink = (T_SINK) task;
            task.helper.wrapAndCopyInto(sink, rightSplit);
            task.propagateCompletion();
        }

        abstract K makeChild(Spliterator&lt;P_IN&gt; spliterator, long offset, long size);

        @Override
        public void begin(long size) {
            if (size &gt; length)
                throw new IllegalStateException(&quot;size passed to Sink.begin exceeds array length&quot;);
            // Casts to int are safe since absolute size is verified to be within
            // bounds when the root concrete SizedCollectorTask is constructed
            // with the shared array
            index = (int) offset;
            fence = index + (int) length;
        }

        @SuppressWarnings(&quot;serial&quot;)
        static final class OfRef&lt;P_IN, P_OUT&gt;
                extends SizedCollectorTask&lt;P_IN, P_OUT, Sink&lt;P_OUT&gt;, OfRef&lt;P_IN, P_OUT&gt;&gt;
                implements Sink&lt;P_OUT&gt; {
            private final P_OUT[] array;

            OfRef(Spliterator&lt;P_IN&gt; spliterator, PipelineHelper&lt;P_OUT&gt; helper, P_OUT[] array) {
                super(spliterator, helper, array.length);
                this.array = array;
            }

            OfRef(OfRef&lt;P_IN, P_OUT&gt; parent, Spliterator&lt;P_IN&gt; spliterator,
                  long offset, long length) {
                super(parent, spliterator, offset, length, parent.array.length);
                this.array = parent.array;
            }

            @Override
            OfRef&lt;P_IN, P_OUT&gt; makeChild(Spliterator&lt;P_IN&gt; spliterator,
                                         long offset, long size) {
                return new OfRef&lt;&gt;(this, spliterator, offset, size);
            }

            @Override
            public void accept(P_OUT value) {
                if (index &gt;= fence) {
                    throw new IndexOutOfBoundsException(Integer.toString(index));
                }
                array[index++] = value;
            }
        }

        @SuppressWarnings(&quot;serial&quot;)
        static final class OfInt&lt;P_IN&gt;
                extends SizedCollectorTask&lt;P_IN, Integer, Sink.OfInt, OfInt&lt;P_IN&gt;&gt;
                implements Sink.OfInt {
            private final int[] array;

            OfInt(Spliterator&lt;P_IN&gt; spliterator, PipelineHelper&lt;Integer&gt; helper, int[] array) {
                super(spliterator, helper, array.length);
                this.array = array;
            }

            OfInt(SizedCollectorTask.OfInt&lt;P_IN&gt; parent, Spliterator&lt;P_IN&gt; spliterator,
                  long offset, long length) {
                super(parent, spliterator, offset, length, parent.array.length);
                this.array = parent.array;
            }

            @Override
            SizedCollectorTask.OfInt&lt;P_IN&gt; makeChild(Spliterator&lt;P_IN&gt; spliterator,
                                                     long offset, long size) {
                return new SizedCollectorTask.OfInt&lt;&gt;(this, spliterator, offset, size);
            }

            @Override
            public void accept(int value) {
                if (index &gt;= fence) {
                    throw new IndexOutOfBoundsException(Integer.toString(index));
                }
                array[index++] = value;
            }
        }

        @SuppressWarnings(&quot;serial&quot;)
        static final class OfLong&lt;P_IN&gt;
                extends SizedCollectorTask&lt;P_IN, Long, Sink.OfLong, OfLong&lt;P_IN&gt;&gt;
                implements Sink.OfLong {
            private final long[] array;

            OfLong(Spliterator&lt;P_IN&gt; spliterator, PipelineHelper&lt;Long&gt; helper, long[] array) {
                super(spliterator, helper, array.length);
                this.array = array;
            }

            OfLong(SizedCollectorTask.OfLong&lt;P_IN&gt; parent, Spliterator&lt;P_IN&gt; spliterator,
                   long offset, long length) {
                super(parent, spliterator, offset, length, parent.array.length);
                this.array = parent.array;
            }

            @Override
            SizedCollectorTask.OfLong&lt;P_IN&gt; makeChild(Spliterator&lt;P_IN&gt; spliterator,
                                                      long offset, long size) {
                return new SizedCollectorTask.OfLong&lt;&gt;(this, spliterator, offset, size);
            }

            @Override
            public void accept(long value) {
                if (index &gt;= fence) {
                    throw new IndexOutOfBoundsException(Integer.toString(index));
                }
                array[index++] = value;
            }
        }

        @SuppressWarnings(&quot;serial&quot;)
        static final class OfDouble&lt;P_IN&gt;
                extends SizedCollectorTask&lt;P_IN, Double, Sink.OfDouble, OfDouble&lt;P_IN&gt;&gt;
                implements Sink.OfDouble {
            private final double[] array;

            OfDouble(Spliterator&lt;P_IN&gt; spliterator, PipelineHelper&lt;Double&gt; helper, double[] array) {
                super(spliterator, helper, array.length);
                this.array = array;
            }

            OfDouble(SizedCollectorTask.OfDouble&lt;P_IN&gt; parent, Spliterator&lt;P_IN&gt; spliterator,
                     long offset, long length) {
                super(parent, spliterator, offset, length, parent.array.length);
                this.array = parent.array;
            }

            @Override
            SizedCollectorTask.OfDouble&lt;P_IN&gt; makeChild(Spliterator&lt;P_IN&gt; spliterator,
                                                        long offset, long size) {
                return new SizedCollectorTask.OfDouble&lt;&gt;(this, spliterator, offset, size);
            }

            @Override
            public void accept(double value) {
                if (index &gt;= fence) {
                    throw new IndexOutOfBoundsException(Integer.toString(index));
                }
                array[index++] = value;
            }
        }
    }

    @SuppressWarnings(&quot;serial&quot;)
    private static abstract class ToArrayTask&lt;T, T_NODE extends Node&lt;T&gt;,
                                              K extends ToArrayTask&lt;T, T_NODE, K&gt;&gt;
            extends CountedCompleter&lt;Void&gt; {
        protected final T_NODE node;
        protected final int offset;

        ToArrayTask(T_NODE node, int offset) {
            this.node = node;
            this.offset = offset;
        }

        ToArrayTask(K parent, T_NODE node, int offset) {
            super(parent);
            this.node = node;
            this.offset = offset;
        }

        abstract void copyNodeToArray();

        abstract K makeChild(int childIndex, int offset);

        @Override
        public void compute() {
            ToArrayTask&lt;T, T_NODE, K&gt; task = this;
            while (true) {
                if (task.node.getChildCount() == 0) {
                    task.copyNodeToArray();
                    task.propagateCompletion();
                    return;
                }
                else {
                    task.setPendingCount(task.node.getChildCount() - 1);

                    int size = 0;
                    int i = 0;
                    for (;i &lt; task.node.getChildCount() - 1; i++) {
                        K leftTask = task.makeChild(i, task.offset + size);
                        size += leftTask.node.count();
                        leftTask.fork();
                    }
                    task = task.makeChild(i, task.offset + size);
                }
            }
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfRef&lt;T&gt;
                extends ToArrayTask&lt;T, Node&lt;T&gt;, OfRef&lt;T&gt;&gt; {
            private final T[] array;

            private OfRef(Node&lt;T&gt; node, T[] array, int offset) {
                super(node, offset);
                this.array = array;
            }

            private OfRef(OfRef&lt;T&gt; parent, Node&lt;T&gt; node, int offset) {
                super(parent, node, offset);
                this.array = parent.array;
            }

            @Override
            OfRef&lt;T&gt; makeChild(int childIndex, int offset) {
                return new OfRef&lt;&gt;(this, node.getChild(childIndex), offset);
            }

            @Override
            void copyNodeToArray() {
                node.copyInto(array, offset);
            }
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static class OfPrimitive&lt;T, T_CONS, T_ARR,
                                         T_SPLITR extends Spliterator.OfPrimitive&lt;T, T_CONS, T_SPLITR&gt;,
                                         T_NODE extends Node.OfPrimitive&lt;T, T_CONS, T_ARR, T_SPLITR, T_NODE&gt;&gt;
                extends ToArrayTask&lt;T, T_NODE, OfPrimitive&lt;T, T_CONS, T_ARR, T_SPLITR, T_NODE&gt;&gt; {
            private final T_ARR array;

            private OfPrimitive(T_NODE node, T_ARR array, int offset) {
                super(node, offset);
                this.array = array;
            }

            private OfPrimitive(OfPrimitive&lt;T, T_CONS, T_ARR, T_SPLITR, T_NODE&gt; parent, T_NODE node, int offset) {
                super(parent, node, offset);
                this.array = parent.array;
            }

            @Override
            OfPrimitive&lt;T, T_CONS, T_ARR, T_SPLITR, T_NODE&gt; makeChild(int childIndex, int offset) {
                return new OfPrimitive&lt;&gt;(this, node.getChild(childIndex), offset);
            }

            @Override
            void copyNodeToArray() {
                node.copyInto(array, offset);
            }
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfInt
                extends OfPrimitive&lt;Integer, IntConsumer, int[], Spliterator.OfInt, Node.OfInt&gt; {
            private OfInt(Node.OfInt node, int[] array, int offset) {
                super(node, array, offset);
            }
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfLong
                extends OfPrimitive&lt;Long, LongConsumer, long[], Spliterator.OfLong, Node.OfLong&gt; {
            private OfLong(Node.OfLong node, long[] array, int offset) {
                super(node, array, offset);
            }
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfDouble
                extends OfPrimitive&lt;Double, DoubleConsumer, double[], Spliterator.OfDouble, Node.OfDouble&gt; {
            private OfDouble(Node.OfDouble node, double[] array, int offset) {
                super(node, array, offset);
            }
        }
    }

    @SuppressWarnings(&quot;serial&quot;)
    private static class CollectorTask&lt;P_IN, P_OUT, T_NODE extends Node&lt;P_OUT&gt;, T_BUILDER extends Node.Builder&lt;P_OUT&gt;&gt;
            extends AbstractTask&lt;P_IN, P_OUT, T_NODE, CollectorTask&lt;P_IN, P_OUT, T_NODE, T_BUILDER&gt;&gt; {
        protected final PipelineHelper&lt;P_OUT&gt; helper;
        protected final LongFunction&lt;T_BUILDER&gt; builderFactory;
        protected final BinaryOperator&lt;T_NODE&gt; concFactory;

        CollectorTask(PipelineHelper&lt;P_OUT&gt; helper,
                      Spliterator&lt;P_IN&gt; spliterator,
                      LongFunction&lt;T_BUILDER&gt; builderFactory,
                      BinaryOperator&lt;T_NODE&gt; concFactory) {
            super(helper, spliterator);
            this.helper = helper;
            this.builderFactory = builderFactory;
            this.concFactory = concFactory;
        }

        CollectorTask(CollectorTask&lt;P_IN, P_OUT, T_NODE, T_BUILDER&gt; parent,
                      Spliterator&lt;P_IN&gt; spliterator) {
            super(parent, spliterator);
            helper = parent.helper;
            builderFactory = parent.builderFactory;
            concFactory = parent.concFactory;
        }

        @Override
        protected CollectorTask&lt;P_IN, P_OUT, T_NODE, T_BUILDER&gt; makeChild(Spliterator&lt;P_IN&gt; spliterator) {
            return new CollectorTask&lt;&gt;(this, spliterator);
        }

        @Override
        protected T_NODE doLeaf() {
            T_BUILDER builder = builderFactory.apply(helper.exactOutputSizeIfKnown(spliterator));
            return (T_NODE) helper.wrapAndCopyInto(builder, spliterator).build();
        }

        @Override
        public void onCompletion(CountedCompleter&lt;?&gt; caller) {
            if (!isLeaf())
                setLocalResult(concFactory.apply(leftChild.getLocalResult(), rightChild.getLocalResult()));
            super.onCompletion(caller);
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfRef&lt;P_IN, P_OUT&gt;
                extends CollectorTask&lt;P_IN, P_OUT, Node&lt;P_OUT&gt;, Node.Builder&lt;P_OUT&gt;&gt; {
            OfRef(PipelineHelper&lt;P_OUT&gt; helper,
                  IntFunction&lt;P_OUT[]&gt; generator,
                  Spliterator&lt;P_IN&gt; spliterator) {
                super(helper, spliterator, s -&gt; builder(s, generator), ConcNode::new);
            }
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfInt&lt;P_IN&gt;
                extends CollectorTask&lt;P_IN, Integer, Node.OfInt, Node.Builder.OfInt&gt; {
            OfInt(PipelineHelper&lt;Integer&gt; helper, Spliterator&lt;P_IN&gt; spliterator) {
                super(helper, spliterator, Nodes::intBuilder, ConcNode.OfInt::new);
            }
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfLong&lt;P_IN&gt;
                extends CollectorTask&lt;P_IN, Long, Node.OfLong, Node.Builder.OfLong&gt; {
            OfLong(PipelineHelper&lt;Long&gt; helper, Spliterator&lt;P_IN&gt; spliterator) {
                super(helper, spliterator, Nodes::longBuilder, ConcNode.OfLong::new);
            }
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfDouble&lt;P_IN&gt;
                extends CollectorTask&lt;P_IN, Double, Node.OfDouble, Node.Builder.OfDouble&gt; {
            OfDouble(PipelineHelper&lt;Double&gt; helper, Spliterator&lt;P_IN&gt; spliterator) {
                super(helper, spliterator, Nodes::doubleBuilder, ConcNode.OfDouble::new);
            }
        }
    }
}
</pre>
</body>
</html>
