<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.util.stream;

import java.util.Objects;
import java.util.Spliterator;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CountedCompleter;
import java.util.concurrent.ForkJoinTask;
import java.util.function.Consumer;
import java.util.function.DoubleConsumer;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;

/**
 * Factory for creating instances of {@code TerminalOp} that perform an
 * action for every element of a stream.  Supported variants include unordered
 * traversal (elements are provided to the {@code Consumer} as soon as they are
 * available), and ordered traversal (elements are provided to the
 * {@code Consumer} in encounter order.)
 *
 * &lt;p&gt;Elements are provided to the {@code Consumer} on whatever thread and
 * whatever order they become available.  For ordered traversals, it is
 * guaranteed that processing an element &lt;em&gt;happens-before&lt;/em&gt; processing
 * subsequent elements in the encounter order.
 *
 * &lt;p&gt;Exceptions occurring as a result of sending an element to the
 * {@code Consumer} will be relayed to the caller and traversal will be
 * prematurely terminated.
 *
 * @since 1.8
 */
final class ForEachOps {

    private ForEachOps() { }

    /**
     * Constructs a {@code TerminalOp} that perform an action for every element
     * of a stream.
     *
     * @param action the {@code Consumer} that receives all elements of a
     *        stream
     * @param ordered whether an ordered traversal is requested
     * @param &lt;T&gt; the type of the stream elements
     * @return the {@code TerminalOp} instance
     */
    public static &lt;T&gt; TerminalOp&lt;T, Void&gt; makeRef(Consumer&lt;? super T&gt; action,
                                                  boolean ordered) {
        Objects.requireNonNull(action);
        return new ForEachOp.OfRef&lt;&gt;(action, ordered);
    }

    /**
     * Constructs a {@code TerminalOp} that perform an action for every element
     * of an {@code IntStream}.
     *
     * @param action the {@code IntConsumer} that receives all elements of a
     *        stream
     * @param ordered whether an ordered traversal is requested
     * @return the {@code TerminalOp} instance
     */
    public static TerminalOp&lt;Integer, Void&gt; makeInt(IntConsumer action,
                                                    boolean ordered) {
        Objects.requireNonNull(action);
        return new ForEachOp.OfInt(action, ordered);
    }

    /**
     * Constructs a {@code TerminalOp} that perform an action for every element
     * of a {@code LongStream}.
     *
     * @param action the {@code LongConsumer} that receives all elements of a
     *        stream
     * @param ordered whether an ordered traversal is requested
     * @return the {@code TerminalOp} instance
     */
    public static TerminalOp&lt;Long, Void&gt; makeLong(LongConsumer action,
                                                  boolean ordered) {
        Objects.requireNonNull(action);
        return new ForEachOp.OfLong(action, ordered);
    }

    /**
     * Constructs a {@code TerminalOp} that perform an action for every element
     * of a {@code DoubleStream}.
     *
     * @param action the {@code DoubleConsumer} that receives all elements of
     *        a stream
     * @param ordered whether an ordered traversal is requested
     * @return the {@code TerminalOp} instance
     */
    public static TerminalOp&lt;Double, Void&gt; makeDouble(DoubleConsumer action,
                                                      boolean ordered) {
        Objects.requireNonNull(action);
        return new ForEachOp.OfDouble(action, ordered);
    }

    /**
     * A {@code TerminalOp} that evaluates a stream pipeline and sends the
     * output to itself as a {@code TerminalSink}.  Elements will be sent in
     * whatever thread they become available.  If the traversal is unordered,
     * they will be sent independent of the stream's encounter order.
     *
     * &lt;p&gt;This terminal operation is stateless.  For parallel evaluation, each
     * leaf instance of a {@code ForEachTask} will send elements to the same
     * {@code TerminalSink} reference that is an instance of this class.
     *
     * @param &lt;T&gt; the output type of the stream pipeline
     */
    static abstract class ForEachOp&lt;T&gt;
            implements TerminalOp&lt;T, Void&gt;, TerminalSink&lt;T, Void&gt; {
        private final boolean ordered;

        protected ForEachOp(boolean ordered) {
            this.ordered = ordered;
        }

        // TerminalOp

        @Override
        public int getOpFlags() {
            return ordered ? 0 : StreamOpFlag.NOT_ORDERED;
        }

        @Override
        public &lt;S&gt; Void evaluateSequential(PipelineHelper&lt;T&gt; helper,
                                           Spliterator&lt;S&gt; spliterator) {
            return helper.wrapAndCopyInto(this, spliterator).get();
        }

        @Override
        public &lt;S&gt; Void evaluateParallel(PipelineHelper&lt;T&gt; helper,
                                         Spliterator&lt;S&gt; spliterator) {
            if (ordered)
                new ForEachOrderedTask&lt;&gt;(helper, spliterator, this).invoke();
            else
                new ForEachTask&lt;&gt;(helper, spliterator, helper.wrapSink(this)).invoke();
            return null;
        }

        // TerminalSink

        @Override
        public Void get() {
            return null;
        }

        // Implementations

        /** Implementation class for reference streams */
        static final class OfRef&lt;T&gt; extends ForEachOp&lt;T&gt; {
            final Consumer&lt;? super T&gt; consumer;

            OfRef(Consumer&lt;? super T&gt; consumer, boolean ordered) {
                super(ordered);
                this.consumer = consumer;
            }

            @Override
            public void accept(T t) {
                consumer.accept(t);
            }
        }

        /** Implementation class for {@code IntStream} */
        static final class OfInt extends ForEachOp&lt;Integer&gt;
                implements Sink.OfInt {
            final IntConsumer consumer;

            OfInt(IntConsumer consumer, boolean ordered) {
                super(ordered);
                this.consumer = consumer;
            }

            @Override
            public StreamShape inputShape() {
                return StreamShape.INT_VALUE;
            }

            @Override
            public void accept(int t) {
                consumer.accept(t);
            }
        }

        /** Implementation class for {@code LongStream} */
        static final class OfLong extends ForEachOp&lt;Long&gt;
                implements Sink.OfLong {
            final LongConsumer consumer;

            OfLong(LongConsumer consumer, boolean ordered) {
                super(ordered);
                this.consumer = consumer;
            }

            @Override
            public StreamShape inputShape() {
                return StreamShape.LONG_VALUE;
            }

            @Override
            public void accept(long t) {
                consumer.accept(t);
            }
        }

        /** Implementation class for {@code DoubleStream} */
        static final class OfDouble extends ForEachOp&lt;Double&gt;
                implements Sink.OfDouble {
            final DoubleConsumer consumer;

            OfDouble(DoubleConsumer consumer, boolean ordered) {
                super(ordered);
                this.consumer = consumer;
            }

            @Override
            public StreamShape inputShape() {
                return StreamShape.DOUBLE_VALUE;
            }

            @Override
            public void accept(double t) {
                consumer.accept(t);
            }
        }
    }

    /** A {@code ForkJoinTask} for performing a parallel for-each operation */
    @SuppressWarnings(&quot;serial&quot;)
    static final class ForEachTask&lt;S, T&gt; extends CountedCompleter&lt;Void&gt; {
        private Spliterator&lt;S&gt; spliterator;
        private final Sink&lt;S&gt; sink;
        private final PipelineHelper&lt;T&gt; helper;
        private long targetSize;

        ForEachTask(PipelineHelper&lt;T&gt; helper,
                    Spliterator&lt;S&gt; spliterator,
                    Sink&lt;S&gt; sink) {
            super(null);
            this.sink = sink;
            this.helper = helper;
            this.spliterator = spliterator;
            this.targetSize = 0L;
        }

        ForEachTask(ForEachTask&lt;S, T&gt; parent, Spliterator&lt;S&gt; spliterator) {
            super(parent);
            this.spliterator = spliterator;
            this.sink = parent.sink;
            this.targetSize = parent.targetSize;
            this.helper = parent.helper;
        }

        // Similar to AbstractTask but doesn't need to track child tasks
        public void compute() {
            Spliterator&lt;S&gt; rightSplit = spliterator, leftSplit;
            long sizeEstimate = rightSplit.estimateSize(), sizeThreshold;
            if ((sizeThreshold = targetSize) == 0L)
                targetSize = sizeThreshold = AbstractTask.suggestTargetSize(sizeEstimate);
            boolean isShortCircuit = StreamOpFlag.SHORT_CIRCUIT.isKnown(helper.getStreamAndOpFlags());
            boolean forkRight = false;
            Sink&lt;S&gt; taskSink = sink;
            ForEachTask&lt;S, T&gt; task = this;
            while (!isShortCircuit || !taskSink.cancellationRequested()) {
                if (sizeEstimate &lt;= sizeThreshold ||
                    (leftSplit = rightSplit.trySplit()) == null) {
                    task.helper.copyInto(taskSink, rightSplit);
                    break;
                }
                ForEachTask&lt;S, T&gt; leftTask = new ForEachTask&lt;&gt;(task, leftSplit);
                task.addToPendingCount(1);
                ForEachTask&lt;S, T&gt; taskToFork;
                if (forkRight) {
                    forkRight = false;
                    rightSplit = leftSplit;
                    taskToFork = task;
                    task = leftTask;
                }
                else {
                    forkRight = true;
                    taskToFork = leftTask;
                }
                taskToFork.fork();
                sizeEstimate = rightSplit.estimateSize();
            }
            task.spliterator = null;
            task.propagateCompletion();
        }
    }

    /**
     * A {@code ForkJoinTask} for performing a parallel for-each operation
     * which visits the elements in encounter order
     */
    @SuppressWarnings(&quot;serial&quot;)
    static final class ForEachOrderedTask&lt;S, T&gt; extends CountedCompleter&lt;Void&gt; {
        private final PipelineHelper&lt;T&gt; helper;
        private Spliterator&lt;S&gt; spliterator;
        private final long targetSize;
        private final ConcurrentHashMap&lt;ForEachOrderedTask&lt;S, T&gt;, ForEachOrderedTask&lt;S, T&gt;&gt; completionMap;
        private final Sink&lt;T&gt; action;
        private final Object lock;
        private final ForEachOrderedTask&lt;S, T&gt; leftPredecessor;
        private Node&lt;T&gt; node;

        protected ForEachOrderedTask(PipelineHelper&lt;T&gt; helper,
                                     Spliterator&lt;S&gt; spliterator,
                                     Sink&lt;T&gt; action) {
            super(null);
            this.helper = helper;
            this.spliterator = spliterator;
            this.targetSize = AbstractTask.suggestTargetSize(spliterator.estimateSize());
            this.completionMap = new ConcurrentHashMap&lt;&gt;();
            this.action = action;
            this.lock = new Object();
            this.leftPredecessor = null;
        }

        ForEachOrderedTask(ForEachOrderedTask&lt;S, T&gt; parent,
                           Spliterator&lt;S&gt; spliterator,
                           ForEachOrderedTask&lt;S, T&gt; leftPredecessor) {
            super(parent);
            this.helper = parent.helper;
            this.spliterator = spliterator;
            this.targetSize = parent.targetSize;
            this.completionMap = parent.completionMap;
            this.action = parent.action;
            this.lock = parent.lock;
            this.leftPredecessor = leftPredecessor;
        }

        @Override
        public final void compute() {
            doCompute(this);
        }

        private static &lt;S, T&gt; void doCompute(ForEachOrderedTask&lt;S, T&gt; task) {
            Spliterator&lt;S&gt; rightSplit = task.spliterator, leftSplit;
            long sizeThreshold = task.targetSize;
            boolean forkRight = false;
            while (rightSplit.estimateSize() &gt; sizeThreshold &amp;&amp;
                   (leftSplit = rightSplit.trySplit()) != null) {
                ForEachOrderedTask&lt;S, T&gt; leftChild =
                    new ForEachOrderedTask&lt;&gt;(task, leftSplit, task.leftPredecessor);
                ForEachOrderedTask&lt;S, T&gt; rightChild =
                    new ForEachOrderedTask&lt;&gt;(task, rightSplit, leftChild);
                task.completionMap.put(leftChild, rightChild);
                task.addToPendingCount(1); // forking
                rightChild.addToPendingCount(1); // right pending on left child
                if (task.leftPredecessor != null) {
                    leftChild.addToPendingCount(1); // left pending on previous subtree, except left spine
                    if (task.completionMap.replace(task.leftPredecessor, task, leftChild))
                        task.addToPendingCount(-1); // transfer my &quot;right child&quot; count to my left child
                    else
                        leftChild.addToPendingCount(-1); // left child is ready to go when ready
                }
                ForEachOrderedTask&lt;S, T&gt; taskToFork;
                if (forkRight) {
                    forkRight = false;
                    rightSplit = leftSplit;
                    task = leftChild;
                    taskToFork = rightChild;
                }
                else {
                    forkRight = true;
                    task = rightChild;
                    taskToFork = leftChild;
                }
                taskToFork.fork();
            }
            if (task.getPendingCount() == 0) {
                task.helper.wrapAndCopyInto(task.action, rightSplit);
            }
            else {
                Node.Builder&lt;T&gt; nb = task.helper.makeNodeBuilder(
                  task.helper.exactOutputSizeIfKnown(rightSplit),
                  size -&gt; (T[]) new Object[size]);
                task.node = task.helper.wrapAndCopyInto(nb, rightSplit).build();
            }
            task.tryComplete();
        }

        @Override
        public void onCompletion(CountedCompleter&lt;?&gt; caller) {
            spliterator = null;
            if (node != null) {
                // Dump any data from this leaf into the sink
                synchronized (lock) {
                    node.forEach(action);
                }
                node = null;
            }
            ForEachOrderedTask&lt;S, T&gt; victim = completionMap.remove(this);
            if (victim != null)
                victim.tryComplete();
        }
    }
}
</pre>
</body>
</html>
