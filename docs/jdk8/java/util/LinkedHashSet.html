<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

/**
 * &lt;p&gt;Hash table and linked list implementation of the &lt;tt&gt;Set&lt;/tt&gt; interface,
 * with predictable iteration order.  This implementation differs from
 * &lt;tt&gt;HashSet&lt;/tt&gt; in that it maintains a doubly-linked list running through
 * all of its entries.  This linked list defines the iteration ordering,
 * which is the order in which elements were inserted into the set
 * (&lt;i&gt;insertion-order&lt;/i&gt;).  Note that insertion order is &lt;i&gt;not&lt;/i&gt; affected
 * if an element is &lt;i&gt;re-inserted&lt;/i&gt; into the set.  (An element &lt;tt&gt;e&lt;/tt&gt;
 * is reinserted into a set &lt;tt&gt;s&lt;/tt&gt; if &lt;tt&gt;s.add(e)&lt;/tt&gt; is invoked when
 * &lt;tt&gt;s.contains(e)&lt;/tt&gt; would return &lt;tt&gt;true&lt;/tt&gt; immediately prior to
 * the invocation.)
 *
 * &lt;p&gt;This implementation spares its clients from the unspecified, generally
 * chaotic ordering provided by {@link HashSet}, without incurring the
 * increased cost associated with {@link TreeSet}.  It can be used to
 * produce a copy of a set that has the same order as the original, regardless
 * of the original set's implementation:
 * &lt;pre&gt;
 *     void foo(Set s) {
 *         Set copy = new LinkedHashSet(s);
 *         ...
 *     }
 * &lt;/pre&gt;
 * This technique is particularly useful if a module takes a set on input,
 * copies it, and later returns results whose order is determined by that of
 * the copy.  (Clients generally appreciate having things returned in the same
 * order they were presented.)
 *
 * &lt;p&gt;This class provides all of the optional &lt;tt&gt;Set&lt;/tt&gt; operations, and
 * permits null elements.  Like &lt;tt&gt;HashSet&lt;/tt&gt;, it provides constant-time
 * performance for the basic operations (&lt;tt&gt;add&lt;/tt&gt;, &lt;tt&gt;contains&lt;/tt&gt; and
 * &lt;tt&gt;remove&lt;/tt&gt;), assuming the hash function disperses elements
 * properly among the buckets.  Performance is likely to be just slightly
 * below that of &lt;tt&gt;HashSet&lt;/tt&gt;, due to the added expense of maintaining the
 * linked list, with one exception: Iteration over a &lt;tt&gt;LinkedHashSet&lt;/tt&gt;
 * requires time proportional to the &lt;i&gt;size&lt;/i&gt; of the set, regardless of
 * its capacity.  Iteration over a &lt;tt&gt;HashSet&lt;/tt&gt; is likely to be more
 * expensive, requiring time proportional to its &lt;i&gt;capacity&lt;/i&gt;.
 *
 * &lt;p&gt;A linked hash set has two parameters that affect its performance:
 * &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  They are defined precisely
 * as for &lt;tt&gt;HashSet&lt;/tt&gt;.  Note, however, that the penalty for choosing an
 * excessively high value for initial capacity is less severe for this class
 * than for &lt;tt&gt;HashSet&lt;/tt&gt;, as iteration times for this class are unaffected
 * by capacity.
 *
 * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
 * If multiple threads access a linked hash set concurrently, and at least
 * one of the threads modifies the set, it &lt;em&gt;must&lt;/em&gt; be synchronized
 * externally.  This is typically accomplished by synchronizing on some
 * object that naturally encapsulates the set.
 *
 * If no such object exists, the set should be &quot;wrapped&quot; using the
 * {@link Collections#synchronizedSet Collections.synchronizedSet}
 * method.  This is best done at creation time, to prevent accidental
 * unsynchronized access to the set: &lt;pre&gt;
 *   Set s = Collections.synchronizedSet(new LinkedHashSet(...));&lt;/pre&gt;
 *
 * &lt;p&gt;The iterators returned by this class's &lt;tt&gt;iterator&lt;/tt&gt; method are
 * &lt;em&gt;fail-fast&lt;/em&gt;: if the set is modified at any time after the iterator
 * is created, in any way except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt;
 * method, the iterator will throw a {@link ConcurrentModificationException}.
 * Thus, in the face of concurrent modification, the iterator fails quickly
 * and cleanly, rather than risking arbitrary, non-deterministic behavior at
 * an undetermined time in the future.
 *
 * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
 * as it is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification.  Fail-fast iterators
 * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness:   &lt;i&gt;the fail-fast behavior of iterators
 * should be used only to detect bugs.&lt;/i&gt;
 *
 * &lt;p&gt;This class is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @param &lt;E&gt; the type of elements maintained by this set
 *
 * @author  Josh Bloch
 * @see     Object#hashCode()
 * @see     Collection
 * @see     Set
 * @see     HashSet
 * @see     TreeSet
 * @see     Hashtable
 * @since   1.4
 */

public class LinkedHashSet&lt;E&gt;
    extends HashSet&lt;E&gt;
    implements Set&lt;E&gt;, Cloneable, java.io.Serializable {

    private static final long serialVersionUID = -2851667679971038690L;

    /**
     * Constructs a new, empty linked hash set with the specified initial
     * capacity and load factor.
     *
     * @param      initialCapacity the initial capacity of the linked hash set
     * @param      loadFactor      the load factor of the linked hash set
     * @throws     IllegalArgumentException  if the initial capacity is less
     *               than zero, or if the load factor is nonpositive
     */
    public LinkedHashSet(int initialCapacity, float loadFactor) {
        super(initialCapacity, loadFactor, true);
    }

    /**
     * Constructs a new, empty linked hash set with the specified initial
     * capacity and the default load factor (0.75).
     *
     * @param   initialCapacity   the initial capacity of the LinkedHashSet
     * @throws  IllegalArgumentException if the initial capacity is less
     *              than zero
     */
    public LinkedHashSet(int initialCapacity) {
        super(initialCapacity, .75f, true);
    }

    /**
     * Constructs a new, empty linked hash set with the default initial
     * capacity (16) and load factor (0.75).
     */
    public LinkedHashSet() {
        super(16, .75f, true);
    }

    /**
     * Constructs a new linked hash set with the same elements as the
     * specified collection.  The linked hash set is created with an initial
     * capacity sufficient to hold the elements in the specified collection
     * and the default load factor (0.75).
     *
     * @param c  the collection whose elements are to be placed into
     *           this set
     * @throws NullPointerException if the specified collection is null
     */
    public LinkedHashSet(Collection&lt;? extends E&gt; c) {
        super(Math.max(2*c.size(), 11), .75f, true);
        addAll(c);
    }

    /**
     * Creates a &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;
     * and &lt;em&gt;fail-fast&lt;/em&gt; {@code Spliterator} over the elements in this set.
     *
     * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED},
     * {@link Spliterator#DISTINCT}, and {@code ORDERED}.  Implementations
     * should document the reporting of additional characteristic values.
     *
     * @implNote
     * The implementation creates a
     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; spliterator
     * from the set's {@code Iterator}.  The spliterator inherits the
     * &lt;em&gt;fail-fast&lt;/em&gt; properties of the set's iterator.
     * The created {@code Spliterator} additionally reports
     * {@link Spliterator#SUBSIZED}.
     *
     * @return a {@code Spliterator} over the elements in this set
     * @since 1.8
     */
    @Override
    public Spliterator&lt;E&gt; spliterator() {
        return Spliterators.spliterator(this, Spliterator.DISTINCT | Spliterator.ORDERED);
    }
}
</pre>
</body>
</html>
