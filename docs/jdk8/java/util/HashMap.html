<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/OdinCodeBrowser/css/styles.css"/>
    </head>
<body>
<table>
<tr>
<td><a class="linenum-cell" data-linenum="1" href="#"></a></td>
<td><pre>/*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2" href="#"></a></td>
<td><pre> * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3" href="#"></a></td>
<td><pre> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5" href="#"></a></td>
<td><pre> * This code is free software; you can redistribute it and/or modify it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="6" href="#"></a></td>
<td><pre> * under the terms of the GNU General Public License version 2 only, as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="7" href="#"></a></td>
<td><pre> * published by the Free Software Foundation.  Oracle designates this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="8" href="#"></a></td>
<td><pre> * particular file as subject to the &quot;Classpath&quot; exception as provided</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="9" href="#"></a></td>
<td><pre> * by Oracle in the LICENSE file that accompanied this code.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="10" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="11" href="#"></a></td>
<td><pre> * This code is distributed in the hope that it will be useful, but WITHOUT</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="12" href="#"></a></td>
<td><pre> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="13" href="#"></a></td>
<td><pre> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="14" href="#"></a></td>
<td><pre> * version 2 for more details (a copy is included in the LICENSE file that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="15" href="#"></a></td>
<td><pre> * accompanied this code).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="16" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="17" href="#"></a></td>
<td><pre> * You should have received a copy of the GNU General Public License version</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="18" href="#"></a></td>
<td><pre> * 2 along with this work; if not, write to the Free Software Foundation,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="19" href="#"></a></td>
<td><pre> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="20" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="21" href="#"></a></td>
<td><pre> * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="22" href="#"></a></td>
<td><pre> * or visit www.oracle.com if you need additional information or have any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="23" href="#"></a></td>
<td><pre> * questions.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="24" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="25" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="26" href="#"></a></td>
<td><pre>package java.util;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="27" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="28" href="#"></a></td>
<td><pre>import java.io.IOException;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="29" href="#"></a></td>
<td><pre>import java.io.InvalidObjectException;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="30" href="#"></a></td>
<td><pre>import java.io.Serializable;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="31" href="#"></a></td>
<td><pre>import java.lang.reflect.ParameterizedType;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="32" href="#"></a></td>
<td><pre>import java.lang.reflect.Type;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="33" href="#"></a></td>
<td><pre>import java.util.function.BiConsumer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="34" href="#"></a></td>
<td><pre>import java.util.function.BiFunction;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="35" href="#"></a></td>
<td><pre>import java.util.function.Consumer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="36" href="#"></a></td>
<td><pre>import java.util.function.Function;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="37" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="38" href="#"></a></td>
<td><pre>/**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="39" href="#"></a></td>
<td><pre> * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface.  This</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="40" href="#"></a></td>
<td><pre> * implementation provides all of the optional map operations, and permits</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="41" href="#"></a></td>
<td><pre> * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  (The &lt;tt&gt;HashMap&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="42" href="#"></a></td>
<td><pre> * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="43" href="#"></a></td>
<td><pre> * unsynchronized and permits nulls.)  This class makes no guarantees as to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="44" href="#"></a></td>
<td><pre> * the order of the map; in particular, it does not guarantee that the order</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="45" href="#"></a></td>
<td><pre> * will remain constant over time.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="46" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="47" href="#"></a></td>
<td><pre> * &lt;p&gt;This implementation provides constant-time performance for the basic</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="48" href="#"></a></td>
<td><pre> * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="49" href="#"></a></td>
<td><pre> * disperses the elements properly among the buckets.  Iteration over</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="50" href="#"></a></td>
<td><pre> * collection views requires time proportional to the &quot;capacity&quot; of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="51" href="#"></a></td>
<td><pre> * &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="52" href="#"></a></td>
<td><pre> * of key-value mappings).  Thus, it's very important not to set the initial</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="53" href="#"></a></td>
<td><pre> * capacity too high (or the load factor too low) if iteration performance is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="54" href="#"></a></td>
<td><pre> * important.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="55" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="56" href="#"></a></td>
<td><pre> * &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;/tt&gt; has two parameters that affect its</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="57" href="#"></a></td>
<td><pre> * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="58" href="#"></a></td>
<td><pre> * &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="59" href="#"></a></td>
<td><pre> * capacity is simply the capacity at the time the hash table is created.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="60" href="#"></a></td>
<td><pre> * &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="61" href="#"></a></td>
<td><pre> * get before its capacity is automatically increased.  When the number of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="62" href="#"></a></td>
<td><pre> * entries in the hash table exceeds the product of the load factor and the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="63" href="#"></a></td>
<td><pre> * current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="64" href="#"></a></td>
<td><pre> * structures are rebuilt) so that the hash table has approximately twice the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="65" href="#"></a></td>
<td><pre> * number of buckets.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="66" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="67" href="#"></a></td>
<td><pre> * &lt;p&gt;As a general rule, the default load factor (.75) offers a good</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="68" href="#"></a></td>
<td><pre> * tradeoff between time and space costs.  Higher values decrease the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="69" href="#"></a></td>
<td><pre> * space overhead but increase the lookup cost (reflected in most of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="70" href="#"></a></td>
<td><pre> * the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="71" href="#"></a></td>
<td><pre> * &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The expected number of entries in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="72" href="#"></a></td>
<td><pre> * the map and its load factor should be taken into account when</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="73" href="#"></a></td>
<td><pre> * setting its initial capacity, so as to minimize the number of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="74" href="#"></a></td>
<td><pre> * rehash operations.  If the initial capacity is greater than the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="75" href="#"></a></td>
<td><pre> * maximum number of entries divided by the load factor, no rehash</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="76" href="#"></a></td>
<td><pre> * operations will ever occur.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="77" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="78" href="#"></a></td>
<td><pre> * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="79" href="#"></a></td>
<td><pre> * instance, creating it with a sufficiently large capacity will allow</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="80" href="#"></a></td>
<td><pre> * the mappings to be stored more efficiently than letting it perform</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="81" href="#"></a></td>
<td><pre> * automatic rehashing as needed to grow the table.  Note that using</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="82" href="#"></a></td>
<td><pre> * many keys with the same {@code hashCode()} is a sure way to slow</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="83" href="#"></a></td>
<td><pre> * down performance of any hash table. To ameliorate impact, when keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="84" href="#"></a></td>
<td><pre> * are {@link Comparable}, this class may use comparison order among</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="85" href="#"></a></td>
<td><pre> * keys to help break ties.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="86" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="87" href="#"></a></td>
<td><pre> * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="88" href="#"></a></td>
<td><pre> * If multiple threads access a hash map concurrently, and at least one of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="89" href="#"></a></td>
<td><pre> * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="90" href="#"></a></td>
<td><pre> * synchronized externally.  (A structural modification is any operation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="91" href="#"></a></td>
<td><pre> * that adds or deletes one or more mappings; merely changing the value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="92" href="#"></a></td>
<td><pre> * associated with a key that an instance already contains is not a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="93" href="#"></a></td>
<td><pre> * structural modification.)  This is typically accomplished by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="94" href="#"></a></td>
<td><pre> * synchronizing on some object that naturally encapsulates the map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="95" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="96" href="#"></a></td>
<td><pre> * If no such object exists, the map should be &quot;wrapped&quot; using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="97" href="#"></a></td>
<td><pre> * {@link Collections#synchronizedMap Collections.synchronizedMap}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="98" href="#"></a></td>
<td><pre> * method.  This is best done at creation time, to prevent accidental</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="99" href="#"></a></td>
<td><pre> * unsynchronized access to the map:&lt;pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="100" href="#"></a></td>
<td><pre> *   Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="101" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="102" href="#"></a></td>
<td><pre> * &lt;p&gt;The iterators returned by all of this class's &quot;collection view methods&quot;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="103" href="#"></a></td>
<td><pre> * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="104" href="#"></a></td>
<td><pre> * the iterator is created, in any way except through the iterator's own</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="105" href="#"></a></td>
<td><pre> * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="106" href="#"></a></td>
<td><pre> * {@link ConcurrentModificationException}.  Thus, in the face of concurrent</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="107" href="#"></a></td>
<td><pre> * modification, the iterator fails quickly and cleanly, rather than risking</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="108" href="#"></a></td>
<td><pre> * arbitrary, non-deterministic behavior at an undetermined time in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="109" href="#"></a></td>
<td><pre> * future.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="110" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="111" href="#"></a></td>
<td><pre> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="112" href="#"></a></td>
<td><pre> * as it is, generally speaking, impossible to make any hard guarantees in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="113" href="#"></a></td>
<td><pre> * presence of unsynchronized concurrent modification.  Fail-fast iterators</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="114" href="#"></a></td>
<td><pre> * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="115" href="#"></a></td>
<td><pre> * Therefore, it would be wrong to write a program that depended on this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="116" href="#"></a></td>
<td><pre> * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="117" href="#"></a></td>
<td><pre> * should be used only to detect bugs.&lt;/i&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="118" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="119" href="#"></a></td>
<td><pre> * &lt;p&gt;This class is a member of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="120" href="#"></a></td>
<td><pre> * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="121" href="#"></a></td>
<td><pre> * Java Collections Framework&lt;/a&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="122" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="123" href="#"></a></td>
<td><pre> * @param &lt;K&gt; the type of keys maintained by this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="124" href="#"></a></td>
<td><pre> * @param &lt;V&gt; the type of mapped values</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="125" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="126" href="#"></a></td>
<td><pre> * @author  Doug Lea</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="127" href="#"></a></td>
<td><pre> * @author  Josh Bloch</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="128" href="#"></a></td>
<td><pre> * @author  Arthur van Hoff</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="129" href="#"></a></td>
<td><pre> * @author  Neal Gafter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="130" href="#"></a></td>
<td><pre> * @see     Object#hashCode()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="131" href="#"></a></td>
<td><pre> * @see     Collection</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="132" href="#"></a></td>
<td><pre> * @see     Map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="133" href="#"></a></td>
<td><pre> * @see     TreeMap</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="134" href="#"></a></td>
<td><pre> * @see     Hashtable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="135" href="#"></a></td>
<td><pre> * @since   1.2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="136" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="137" href="#"></a></td>
<td><pre>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="138" href="#"></a></td>
<td><pre>    implements Map&lt;K,V&gt;, Cloneable, Serializable {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="139" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="140" href="#"></a></td>
<td><pre>    private static final long serialVersionUID = 362498820763181265L;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="141" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="142" href="#"></a></td>
<td><pre>    /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="143" href="#"></a></td>
<td><pre>     * Implementation notes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="144" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="145" href="#"></a></td>
<td><pre>     * This map usually acts as a binned (bucketed) hash table, but</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="146" href="#"></a></td>
<td><pre>     * when bins get too large, they are transformed into bins of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="147" href="#"></a></td>
<td><pre>     * TreeNodes, each structured similarly to those in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="148" href="#"></a></td>
<td><pre>     * java.util.TreeMap. Most methods try to use normal bins, but</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="149" href="#"></a></td>
<td><pre>     * relay to TreeNode methods when applicable (simply by checking</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="150" href="#"></a></td>
<td><pre>     * instanceof a node).  Bins of TreeNodes may be traversed and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="151" href="#"></a></td>
<td><pre>     * used like any others, but additionally support faster lookup</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="152" href="#"></a></td>
<td><pre>     * when overpopulated. However, since the vast majority of bins in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="153" href="#"></a></td>
<td><pre>     * normal use are not overpopulated, checking for existence of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="154" href="#"></a></td>
<td><pre>     * tree bins may be delayed in the course of table methods.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="155" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="156" href="#"></a></td>
<td><pre>     * Tree bins (i.e., bins whose elements are all TreeNodes) are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="157" href="#"></a></td>
<td><pre>     * ordered primarily by hashCode, but in the case of ties, if two</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="158" href="#"></a></td>
<td><pre>     * elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="159" href="#"></a></td>
<td><pre>     * type then their compareTo method is used for ordering. (We</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="160" href="#"></a></td>
<td><pre>     * conservatively check generic types via reflection to validate</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="161" href="#"></a></td>
<td><pre>     * this -- see method comparableClassFor).  The added complexity</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="162" href="#"></a></td>
<td><pre>     * of tree bins is worthwhile in providing worst-case O(log n)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="163" href="#"></a></td>
<td><pre>     * operations when keys either have distinct hashes or are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="164" href="#"></a></td>
<td><pre>     * orderable, Thus, performance degrades gracefully under</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="165" href="#"></a></td>
<td><pre>     * accidental or malicious usages in which hashCode() methods</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="166" href="#"></a></td>
<td><pre>     * return values that are poorly distributed, as well as those in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="167" href="#"></a></td>
<td><pre>     * which many keys share a hashCode, so long as they are also</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="168" href="#"></a></td>
<td><pre>     * Comparable. (If neither of these apply, we may waste about a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="169" href="#"></a></td>
<td><pre>     * factor of two in time and space compared to taking no</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="170" href="#"></a></td>
<td><pre>     * precautions. But the only known cases stem from poor user</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="171" href="#"></a></td>
<td><pre>     * programming practices that are already so slow that this makes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="172" href="#"></a></td>
<td><pre>     * little difference.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="173" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="174" href="#"></a></td>
<td><pre>     * Because TreeNodes are about twice the size of regular nodes, we</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="175" href="#"></a></td>
<td><pre>     * use them only when bins contain enough nodes to warrant use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="176" href="#"></a></td>
<td><pre>     * (see TREEIFY_THRESHOLD). And when they become too small (due to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="177" href="#"></a></td>
<td><pre>     * removal or resizing) they are converted back to plain bins.  In</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="178" href="#"></a></td>
<td><pre>     * usages with well-distributed user hashCodes, tree bins are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="179" href="#"></a></td>
<td><pre>     * rarely used.  Ideally, under random hashCodes, the frequency of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="180" href="#"></a></td>
<td><pre>     * nodes in bins follows a Poisson distribution</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="181" href="#"></a></td>
<td><pre>     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="182" href="#"></a></td>
<td><pre>     * parameter of about 0.5 on average for the default resizing</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="183" href="#"></a></td>
<td><pre>     * threshold of 0.75, although with a large variance because of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="184" href="#"></a></td>
<td><pre>     * resizing granularity. Ignoring variance, the expected</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="185" href="#"></a></td>
<td><pre>     * occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="186" href="#"></a></td>
<td><pre>     * factorial(k)). The first values are:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="187" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="188" href="#"></a></td>
<td><pre>     * 0:    0.60653066</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="189" href="#"></a></td>
<td><pre>     * 1:    0.30326533</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="190" href="#"></a></td>
<td><pre>     * 2:    0.07581633</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="191" href="#"></a></td>
<td><pre>     * 3:    0.01263606</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="192" href="#"></a></td>
<td><pre>     * 4:    0.00157952</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="193" href="#"></a></td>
<td><pre>     * 5:    0.00015795</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="194" href="#"></a></td>
<td><pre>     * 6:    0.00001316</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="195" href="#"></a></td>
<td><pre>     * 7:    0.00000094</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="196" href="#"></a></td>
<td><pre>     * 8:    0.00000006</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="197" href="#"></a></td>
<td><pre>     * more: less than 1 in ten million</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="198" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="199" href="#"></a></td>
<td><pre>     * The root of a tree bin is normally its first node.  However,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="200" href="#"></a></td>
<td><pre>     * sometimes (currently only upon Iterator.remove), the root might</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="201" href="#"></a></td>
<td><pre>     * be elsewhere, but can be recovered following parent links</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="202" href="#"></a></td>
<td><pre>     * (method TreeNode.root()).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="203" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="204" href="#"></a></td>
<td><pre>     * All applicable internal methods accept a hash code as an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="205" href="#"></a></td>
<td><pre>     * argument (as normally supplied from a public method), allowing</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="206" href="#"></a></td>
<td><pre>     * them to call each other without recomputing user hashCodes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="207" href="#"></a></td>
<td><pre>     * Most internal methods also accept a &quot;tab&quot; argument, that is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="208" href="#"></a></td>
<td><pre>     * normally the current table, but may be a new or old one when</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="209" href="#"></a></td>
<td><pre>     * resizing or converting.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="210" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="211" href="#"></a></td>
<td><pre>     * When bin lists are treeified, split, or untreeified, we keep</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="212" href="#"></a></td>
<td><pre>     * them in the same relative access/traversal order (i.e., field</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="213" href="#"></a></td>
<td><pre>     * Node.next) to better preserve locality, and to slightly</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="214" href="#"></a></td>
<td><pre>     * simplify handling of splits and traversals that invoke</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="215" href="#"></a></td>
<td><pre>     * iterator.remove. When using comparators on insertion, to keep a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="216" href="#"></a></td>
<td><pre>     * total ordering (or as close as is required here) across</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="217" href="#"></a></td>
<td><pre>     * rebalancings, we compare classes and identityHashCodes as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="218" href="#"></a></td>
<td><pre>     * tie-breakers.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="219" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="220" href="#"></a></td>
<td><pre>     * The use and transitions among plain vs tree modes is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="221" href="#"></a></td>
<td><pre>     * complicated by the existence of subclass LinkedHashMap. See</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="222" href="#"></a></td>
<td><pre>     * below for hook methods defined to be invoked upon insertion,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="223" href="#"></a></td>
<td><pre>     * removal and access that allow LinkedHashMap internals to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="224" href="#"></a></td>
<td><pre>     * otherwise remain independent of these mechanics. (This also</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="225" href="#"></a></td>
<td><pre>     * requires that a map instance be passed to some utility methods</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="226" href="#"></a></td>
<td><pre>     * that may create new nodes.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="227" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="228" href="#"></a></td>
<td><pre>     * The concurrent-programming-like SSA-based coding style helps</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="229" href="#"></a></td>
<td><pre>     * avoid aliasing errors amid all of the twisty pointer operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="230" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="231" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="232" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="233" href="#"></a></td>
<td><pre>     * The default initial capacity - MUST be a power of two.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="234" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="235" href="#"></a></td>
<td><pre>    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="236" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="237" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="238" href="#"></a></td>
<td><pre>     * The maximum capacity, used if a higher value is implicitly specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="239" href="#"></a></td>
<td><pre>     * by either of the constructors with arguments.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="240" href="#"></a></td>
<td><pre>     * MUST be a power of two &lt;= 1&lt;&lt;30.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="241" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="242" href="#"></a></td>
<td><pre>    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="243" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="244" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="245" href="#"></a></td>
<td><pre>     * The load factor used when none specified in constructor.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="246" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="247" href="#"></a></td>
<td><pre>    static final float DEFAULT_LOAD_FACTOR = 0.75f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="248" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="249" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="250" href="#"></a></td>
<td><pre>     * The bin count threshold for using a tree rather than list for a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="251" href="#"></a></td>
<td><pre>     * bin.  Bins are converted to trees when adding an element to a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="252" href="#"></a></td>
<td><pre>     * bin with at least this many nodes. The value must be greater</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="253" href="#"></a></td>
<td><pre>     * than 2 and should be at least 8 to mesh with assumptions in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="254" href="#"></a></td>
<td><pre>     * tree removal about conversion back to plain bins upon</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="255" href="#"></a></td>
<td><pre>     * shrinkage.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="256" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="257" href="#"></a></td>
<td><pre>    static final int TREEIFY_THRESHOLD = 8;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="258" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="259" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="260" href="#"></a></td>
<td><pre>     * The bin count threshold for untreeifying a (split) bin during a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="261" href="#"></a></td>
<td><pre>     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="262" href="#"></a></td>
<td><pre>     * most 6 to mesh with shrinkage detection under removal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="263" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="264" href="#"></a></td>
<td><pre>    static final int UNTREEIFY_THRESHOLD = 6;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="265" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="266" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="267" href="#"></a></td>
<td><pre>     * The smallest table capacity for which bins may be treeified.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="268" href="#"></a></td>
<td><pre>     * (Otherwise the table is resized if too many nodes in a bin.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="269" href="#"></a></td>
<td><pre>     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="270" href="#"></a></td>
<td><pre>     * between resizing and treeification thresholds.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="271" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="272" href="#"></a></td>
<td><pre>    static final int MIN_TREEIFY_CAPACITY = 64;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="273" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="274" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="275" href="#"></a></td>
<td><pre>     * Basic hash bin node, used for most entries.  (See below for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="276" href="#"></a></td>
<td><pre>     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="277" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="278" href="#"></a></td>
<td><pre>    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="279" href="#"></a></td>
<td><pre>        final int hash;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="280" href="#"></a></td>
<td><pre>        final K key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="281" href="#"></a></td>
<td><pre>        V value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="282" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="283" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="284" href="#"></a></td>
<td><pre>        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="285" href="#"></a></td>
<td><pre>            this.hash = hash;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="286" href="#"></a></td>
<td><pre>            this.key = key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="287" href="#"></a></td>
<td><pre>            this.value = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="288" href="#"></a></td>
<td><pre>            this.next = next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="289" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="290" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="291" href="#"></a></td>
<td><pre>        public final K getKey()        { return key; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="292" href="#"></a></td>
<td><pre>        public final V getValue()      { return value; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="293" href="#"></a></td>
<td><pre>        public final String toString() { return key + &quot;=&quot; + value; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="294" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="295" href="#"></a></td>
<td><pre>        public final int hashCode() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="296" href="#"></a></td>
<td><pre>            return Objects.hashCode(key) ^ Objects.hashCode(value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="297" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="298" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="299" href="#"></a></td>
<td><pre>        public final V setValue(V newValue) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="300" href="#"></a></td>
<td><pre>            V oldValue = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="301" href="#"></a></td>
<td><pre>            value = newValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="302" href="#"></a></td>
<td><pre>            return oldValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="303" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="304" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="305" href="#"></a></td>
<td><pre>        public final boolean equals(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="306" href="#"></a></td>
<td><pre>            if (o == this)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="307" href="#"></a></td>
<td><pre>                return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="308" href="#"></a></td>
<td><pre>            if (o instanceof Map.Entry) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="309" href="#"></a></td>
<td><pre>                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="310" href="#"></a></td>
<td><pre>                if (Objects.equals(key, e.getKey()) &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="311" href="#"></a></td>
<td><pre>                    Objects.equals(value, e.getValue()))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="312" href="#"></a></td>
<td><pre>                    return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="313" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="314" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="315" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="316" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="317" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="318" href="#"></a></td>
<td><pre>    /* ---------------- Static utilities -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="319" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="320" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="321" href="#"></a></td>
<td><pre>     * Computes key.hashCode() and spreads (XORs) higher bits of hash</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="322" href="#"></a></td>
<td><pre>     * to lower.  Because the table uses power-of-two masking, sets of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="323" href="#"></a></td>
<td><pre>     * hashes that vary only in bits above the current mask will</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="324" href="#"></a></td>
<td><pre>     * always collide. (Among known examples are sets of Float keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="325" href="#"></a></td>
<td><pre>     * holding consecutive whole numbers in small tables.)  So we</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="326" href="#"></a></td>
<td><pre>     * apply a transform that spreads the impact of higher bits</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="327" href="#"></a></td>
<td><pre>     * downward. There is a tradeoff between speed, utility, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="328" href="#"></a></td>
<td><pre>     * quality of bit-spreading. Because many common sets of hashes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="329" href="#"></a></td>
<td><pre>     * are already reasonably distributed (so don't benefit from</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="330" href="#"></a></td>
<td><pre>     * spreading), and because we use trees to handle large sets of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="331" href="#"></a></td>
<td><pre>     * collisions in bins, we just XOR some shifted bits in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="332" href="#"></a></td>
<td><pre>     * cheapest possible way to reduce systematic lossage, as well as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="333" href="#"></a></td>
<td><pre>     * to incorporate impact of the highest bits that would otherwise</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="334" href="#"></a></td>
<td><pre>     * never be used in index calculations because of table bounds.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="335" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="336" href="#"></a></td>
<td><pre>    static final int hash(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="337" href="#"></a></td>
<td><pre>        int h;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="338" href="#"></a></td>
<td><pre>        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="339" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="340" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="341" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="342" href="#"></a></td>
<td><pre>     * Returns x's Class if it is of the form &quot;class C implements</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="343" href="#"></a></td>
<td><pre>     * Comparable&lt;C&gt;&quot;, else null.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="344" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="345" href="#"></a></td>
<td><pre>    static Class&lt;?&gt; comparableClassFor(Object x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="346" href="#"></a></td>
<td><pre>        if (x instanceof Comparable) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="347" href="#"></a></td>
<td><pre>            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="348" href="#"></a></td>
<td><pre>            if ((c = x.getClass()) == String.class) // bypass checks</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="349" href="#"></a></td>
<td><pre>                return c;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="350" href="#"></a></td>
<td><pre>            if ((ts = c.getGenericInterfaces()) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="351" href="#"></a></td>
<td><pre>                for (int i = 0; i &lt; ts.length; ++i) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="352" href="#"></a></td>
<td><pre>                    if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="353" href="#"></a></td>
<td><pre>                        ((p = (ParameterizedType)t).getRawType() ==</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="354" href="#"></a></td>
<td><pre>                         Comparable.class) &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="355" href="#"></a></td>
<td><pre>                        (as = p.getActualTypeArguments()) != null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="356" href="#"></a></td>
<td><pre>                        as.length == 1 &amp;&amp; as[0] == c) // type arg is c</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="357" href="#"></a></td>
<td><pre>                        return c;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="358" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="359" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="360" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="361" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="362" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="363" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="364" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="365" href="#"></a></td>
<td><pre>     * Returns k.compareTo(x) if x matches kc (k's screened comparable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="366" href="#"></a></td>
<td><pre>     * class), else 0.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="367" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="368" href="#"></a></td>
<td><pre>    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) // for cast to Comparable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="369" href="#"></a></td>
<td><pre>    static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="370" href="#"></a></td>
<td><pre>        return (x == null || x.getClass() != kc ? 0 :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="371" href="#"></a></td>
<td><pre>                ((Comparable)k).compareTo(x));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="372" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="373" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="374" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="375" href="#"></a></td>
<td><pre>     * Returns a power of two size for the given target capacity.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="376" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="377" href="#"></a></td>
<td><pre>    static final int tableSizeFor(int cap) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="378" href="#"></a></td>
<td><pre>        int n = cap - 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="379" href="#"></a></td>
<td><pre>        n |= n &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="380" href="#"></a></td>
<td><pre>        n |= n &gt;&gt;&gt; 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="381" href="#"></a></td>
<td><pre>        n |= n &gt;&gt;&gt; 4;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="382" href="#"></a></td>
<td><pre>        n |= n &gt;&gt;&gt; 8;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="383" href="#"></a></td>
<td><pre>        n |= n &gt;&gt;&gt; 16;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="384" href="#"></a></td>
<td><pre>        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="385" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="386" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="387" href="#"></a></td>
<td><pre>    /* ---------------- Fields -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="388" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="389" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="390" href="#"></a></td>
<td><pre>     * The table, initialized on first use, and resized as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="391" href="#"></a></td>
<td><pre>     * necessary. When allocated, length is always a power of two.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="392" href="#"></a></td>
<td><pre>     * (We also tolerate length zero in some operations to allow</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="393" href="#"></a></td>
<td><pre>     * bootstrapping mechanics that are currently not needed.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="394" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="395" href="#"></a></td>
<td><pre>    transient Node&lt;K,V&gt;[] table;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="396" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="397" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="398" href="#"></a></td>
<td><pre>     * Holds cached entrySet(). Note that AbstractMap fields are used</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="399" href="#"></a></td>
<td><pre>     * for keySet() and values().</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="400" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="401" href="#"></a></td>
<td><pre>    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="402" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="403" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="404" href="#"></a></td>
<td><pre>     * The number of key-value mappings contained in this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="405" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="406" href="#"></a></td>
<td><pre>    transient int size;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="407" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="408" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="409" href="#"></a></td>
<td><pre>     * The number of times this HashMap has been structurally modified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="410" href="#"></a></td>
<td><pre>     * Structural modifications are those that change the number of mappings in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="411" href="#"></a></td>
<td><pre>     * the HashMap or otherwise modify its internal structure (e.g.,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="412" href="#"></a></td>
<td><pre>     * rehash).  This field is used to make iterators on Collection-views of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="413" href="#"></a></td>
<td><pre>     * the HashMap fail-fast.  (See ConcurrentModificationException).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="414" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="415" href="#"></a></td>
<td><pre>    transient int modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="416" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="417" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="418" href="#"></a></td>
<td><pre>     * The next size value at which to resize (capacity * load factor).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="419" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="420" href="#"></a></td>
<td><pre>     * @serial</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="421" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="422" href="#"></a></td>
<td><pre>    // (The javadoc description is true upon serialization.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="423" href="#"></a></td>
<td><pre>    // Additionally, if the table array has not been allocated, this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="424" href="#"></a></td>
<td><pre>    // field holds the initial array capacity, or zero signifying</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="425" href="#"></a></td>
<td><pre>    // DEFAULT_INITIAL_CAPACITY.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="426" href="#"></a></td>
<td><pre>    int threshold;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="427" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="428" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="429" href="#"></a></td>
<td><pre>     * The load factor for the hash table.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="430" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="431" href="#"></a></td>
<td><pre>     * @serial</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="432" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="433" href="#"></a></td>
<td><pre>    final float loadFactor;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="434" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="435" href="#"></a></td>
<td><pre>    /* ---------------- Public operations -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="436" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="437" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="438" href="#"></a></td>
<td><pre>     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="439" href="#"></a></td>
<td><pre>     * capacity and load factor.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="440" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="441" href="#"></a></td>
<td><pre>     * @param  initialCapacity the initial capacity</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="442" href="#"></a></td>
<td><pre>     * @param  loadFactor      the load factor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="443" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if the initial capacity is negative</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="444" href="#"></a></td>
<td><pre>     *         or the load factor is nonpositive</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="445" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="446" href="#"></a></td>
<td><pre>    public HashMap(int initialCapacity, float loadFactor) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="447" href="#"></a></td>
<td><pre>        if (initialCapacity &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="448" href="#"></a></td>
<td><pre>            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="449" href="#"></a></td>
<td><pre>                                               initialCapacity);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="450" href="#"></a></td>
<td><pre>        if (initialCapacity &gt; MAXIMUM_CAPACITY)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="451" href="#"></a></td>
<td><pre>            initialCapacity = MAXIMUM_CAPACITY;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="452" href="#"></a></td>
<td><pre>        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="453" href="#"></a></td>
<td><pre>            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="454" href="#"></a></td>
<td><pre>                                               loadFactor);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="455" href="#"></a></td>
<td><pre>        this.loadFactor = loadFactor;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="456" href="#"></a></td>
<td><pre>        this.threshold = tableSizeFor(initialCapacity);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="457" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="458" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="459" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="460" href="#"></a></td>
<td><pre>     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="461" href="#"></a></td>
<td><pre>     * capacity and the default load factor (0.75).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="462" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="463" href="#"></a></td>
<td><pre>     * @param  initialCapacity the initial capacity.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="464" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException if the initial capacity is negative.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="465" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="466" href="#"></a></td>
<td><pre>    public HashMap(int initialCapacity) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="467" href="#"></a></td>
<td><pre>        this(initialCapacity, DEFAULT_LOAD_FACTOR);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="468" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="469" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="470" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="471" href="#"></a></td>
<td><pre>     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="472" href="#"></a></td>
<td><pre>     * (16) and the default load factor (0.75).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="473" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="474" href="#"></a></td>
<td><pre>    public HashMap() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="475" href="#"></a></td>
<td><pre>        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="476" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="477" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="478" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="479" href="#"></a></td>
<td><pre>     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="480" href="#"></a></td>
<td><pre>     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="481" href="#"></a></td>
<td><pre>     * default load factor (0.75) and an initial capacity sufficient to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="482" href="#"></a></td>
<td><pre>     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="483" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="484" href="#"></a></td>
<td><pre>     * @param   m the map whose mappings are to be placed in this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="485" href="#"></a></td>
<td><pre>     * @throws  NullPointerException if the specified map is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="486" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="487" href="#"></a></td>
<td><pre>    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="488" href="#"></a></td>
<td><pre>        this.loadFactor = DEFAULT_LOAD_FACTOR;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="489" href="#"></a></td>
<td><pre>        putMapEntries(m, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="490" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="491" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="492" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="493" href="#"></a></td>
<td><pre>     * Implements Map.putAll and Map constructor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="494" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="495" href="#"></a></td>
<td><pre>     * @param m the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="496" href="#"></a></td>
<td><pre>     * @param evict false when initially constructing this map, else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="497" href="#"></a></td>
<td><pre>     * true (relayed to method afterNodeInsertion).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="498" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="499" href="#"></a></td>
<td><pre>    final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="500" href="#"></a></td>
<td><pre>        int s = m.size();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="501" href="#"></a></td>
<td><pre>        if (s &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="502" href="#"></a></td>
<td><pre>            if (table == null) { // pre-size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="503" href="#"></a></td>
<td><pre>                float ft = ((float)s / loadFactor) + 1.0F;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="504" href="#"></a></td>
<td><pre>                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="505" href="#"></a></td>
<td><pre>                         (int)ft : MAXIMUM_CAPACITY);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="506" href="#"></a></td>
<td><pre>                if (t &gt; threshold)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="507" href="#"></a></td>
<td><pre>                    threshold = tableSizeFor(t);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="508" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="509" href="#"></a></td>
<td><pre>            else if (s &gt; threshold)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="510" href="#"></a></td>
<td><pre>                resize();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="511" href="#"></a></td>
<td><pre>            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="512" href="#"></a></td>
<td><pre>                K key = e.getKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="513" href="#"></a></td>
<td><pre>                V value = e.getValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="514" href="#"></a></td>
<td><pre>                putVal(hash(key), key, value, false, evict);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="515" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="516" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="517" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="518" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="519" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="520" href="#"></a></td>
<td><pre>     * Returns the number of key-value mappings in this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="521" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="522" href="#"></a></td>
<td><pre>     * @return the number of key-value mappings in this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="523" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="524" href="#"></a></td>
<td><pre>    public int size() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="525" href="#"></a></td>
<td><pre>        return size;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="526" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="527" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="528" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="529" href="#"></a></td>
<td><pre>     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="530" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="531" href="#"></a></td>
<td><pre>     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="532" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="533" href="#"></a></td>
<td><pre>    public boolean isEmpty() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="534" href="#"></a></td>
<td><pre>        return size == 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="535" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="536" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="537" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="538" href="#"></a></td>
<td><pre>     * Returns the value to which the specified key is mapped,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="539" href="#"></a></td>
<td><pre>     * or {@code null} if this map contains no mapping for the key.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="540" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="541" href="#"></a></td>
<td><pre>     * &lt;p&gt;More formally, if this map contains a mapping from a key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="542" href="#"></a></td>
<td><pre>     * {@code k} to a value {@code v} such that {@code (key==null ? k==null :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="543" href="#"></a></td>
<td><pre>     * key.equals(k))}, then this method returns {@code v}; otherwise</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="544" href="#"></a></td>
<td><pre>     * it returns {@code null}.  (There can be at most one such mapping.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="545" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="546" href="#"></a></td>
<td><pre>     * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="547" href="#"></a></td>
<td><pre>     * indicate that the map contains no mapping for the key; it's also</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="548" href="#"></a></td>
<td><pre>     * possible that the map explicitly maps the key to {@code null}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="549" href="#"></a></td>
<td><pre>     * The {@link #containsKey containsKey} operation may be used to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="550" href="#"></a></td>
<td><pre>     * distinguish these two cases.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="551" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="552" href="#"></a></td>
<td><pre>     * @see #put(Object, Object)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="553" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="554" href="#"></a></td>
<td><pre>    public V get(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="555" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="556" href="#"></a></td>
<td><pre>        return (e = getNode(hash(key), key)) == null ? null : e.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="557" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="558" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="559" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="560" href="#"></a></td>
<td><pre>     * Implements Map.get and related methods</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="561" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="562" href="#"></a></td>
<td><pre>     * @param hash hash for key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="563" href="#"></a></td>
<td><pre>     * @param key the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="564" href="#"></a></td>
<td><pre>     * @return the node, or null if none</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="565" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="566" href="#"></a></td>
<td><pre>    final Node&lt;K,V&gt; getNode(int hash, Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="567" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="568" href="#"></a></td>
<td><pre>        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="569" href="#"></a></td>
<td><pre>            (first = tab[(n - 1) &amp; hash]) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="570" href="#"></a></td>
<td><pre>            if (first.hash == hash &amp;&amp; // always check first node</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="571" href="#"></a></td>
<td><pre>                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="572" href="#"></a></td>
<td><pre>                return first;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="573" href="#"></a></td>
<td><pre>            if ((e = first.next) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="574" href="#"></a></td>
<td><pre>                if (first instanceof TreeNode)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="575" href="#"></a></td>
<td><pre>                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="576" href="#"></a></td>
<td><pre>                do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="577" href="#"></a></td>
<td><pre>                    if (e.hash == hash &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="578" href="#"></a></td>
<td><pre>                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="579" href="#"></a></td>
<td><pre>                        return e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="580" href="#"></a></td>
<td><pre>                } while ((e = e.next) != null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="581" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="582" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="583" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="584" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="585" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="586" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="587" href="#"></a></td>
<td><pre>     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="588" href="#"></a></td>
<td><pre>     * specified key.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="589" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="590" href="#"></a></td>
<td><pre>     * @param   key   The key whose presence in this map is to be tested</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="591" href="#"></a></td>
<td><pre>     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="592" href="#"></a></td>
<td><pre>     * key.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="593" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="594" href="#"></a></td>
<td><pre>    public boolean containsKey(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="595" href="#"></a></td>
<td><pre>        return getNode(hash(key), key) != null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="596" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="597" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="598" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="599" href="#"></a></td>
<td><pre>     * Associates the specified value with the specified key in this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="600" href="#"></a></td>
<td><pre>     * If the map previously contained a mapping for the key, the old</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="601" href="#"></a></td>
<td><pre>     * value is replaced.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="602" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="603" href="#"></a></td>
<td><pre>     * @param key key with which the specified value is to be associated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="604" href="#"></a></td>
<td><pre>     * @param value value to be associated with the specified key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="605" href="#"></a></td>
<td><pre>     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="606" href="#"></a></td>
<td><pre>     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="607" href="#"></a></td>
<td><pre>     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="608" href="#"></a></td>
<td><pre>     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="609" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="610" href="#"></a></td>
<td><pre>    public V put(K key, V value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="611" href="#"></a></td>
<td><pre>        return putVal(hash(key), key, value, false, true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="612" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="613" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="614" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="615" href="#"></a></td>
<td><pre>     * Implements Map.put and related methods</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="616" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="617" href="#"></a></td>
<td><pre>     * @param hash hash for key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="618" href="#"></a></td>
<td><pre>     * @param key the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="619" href="#"></a></td>
<td><pre>     * @param value the value to put</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="620" href="#"></a></td>
<td><pre>     * @param onlyIfAbsent if true, don't change existing value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="621" href="#"></a></td>
<td><pre>     * @param evict if false, the table is in creation mode.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="622" href="#"></a></td>
<td><pre>     * @return previous value, or null if none</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="623" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="624" href="#"></a></td>
<td><pre>    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="625" href="#"></a></td>
<td><pre>                   boolean evict) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="626" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="627" href="#"></a></td>
<td><pre>        if ((tab = table) == null || (n = tab.length) == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="628" href="#"></a></td>
<td><pre>            n = (tab = resize()).length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="629" href="#"></a></td>
<td><pre>        if ((p = tab[i = (n - 1) &amp; hash]) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="630" href="#"></a></td>
<td><pre>            tab[i] = newNode(hash, key, value, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="631" href="#"></a></td>
<td><pre>        else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="632" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; e; K k;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="633" href="#"></a></td>
<td><pre>            if (p.hash == hash &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="634" href="#"></a></td>
<td><pre>                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="635" href="#"></a></td>
<td><pre>                e = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="636" href="#"></a></td>
<td><pre>            else if (p instanceof TreeNode)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="637" href="#"></a></td>
<td><pre>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="638" href="#"></a></td>
<td><pre>            else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="639" href="#"></a></td>
<td><pre>                for (int binCount = 0; ; ++binCount) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="640" href="#"></a></td>
<td><pre>                    if ((e = p.next) == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="641" href="#"></a></td>
<td><pre>                        p.next = newNode(hash, key, value, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="642" href="#"></a></td>
<td><pre>                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="643" href="#"></a></td>
<td><pre>                            treeifyBin(tab, hash);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="644" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="645" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="646" href="#"></a></td>
<td><pre>                    if (e.hash == hash &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="647" href="#"></a></td>
<td><pre>                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="648" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="649" href="#"></a></td>
<td><pre>                    p = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="650" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="651" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="652" href="#"></a></td>
<td><pre>            if (e != null) { // existing mapping for key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="653" href="#"></a></td>
<td><pre>                V oldValue = e.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="654" href="#"></a></td>
<td><pre>                if (!onlyIfAbsent || oldValue == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="655" href="#"></a></td>
<td><pre>                    e.value = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="656" href="#"></a></td>
<td><pre>                afterNodeAccess(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="657" href="#"></a></td>
<td><pre>                return oldValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="658" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="659" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="660" href="#"></a></td>
<td><pre>        ++modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="661" href="#"></a></td>
<td><pre>        if (++size &gt; threshold)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="662" href="#"></a></td>
<td><pre>            resize();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="663" href="#"></a></td>
<td><pre>        afterNodeInsertion(evict);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="664" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="665" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="666" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="667" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="668" href="#"></a></td>
<td><pre>     * Initializes or doubles table size.  If null, allocates in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="669" href="#"></a></td>
<td><pre>     * accord with initial capacity target held in field threshold.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="670" href="#"></a></td>
<td><pre>     * Otherwise, because we are using power-of-two expansion, the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="671" href="#"></a></td>
<td><pre>     * elements from each bin must either stay at same index, or move</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="672" href="#"></a></td>
<td><pre>     * with a power of two offset in the new table.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="673" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="674" href="#"></a></td>
<td><pre>     * @return the table</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="675" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="676" href="#"></a></td>
<td><pre>    final Node&lt;K,V&gt;[] resize() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="677" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt;[] oldTab = table;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="678" href="#"></a></td>
<td><pre>        int oldCap = (oldTab == null) ? 0 : oldTab.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="679" href="#"></a></td>
<td><pre>        int oldThr = threshold;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="680" href="#"></a></td>
<td><pre>        int newCap, newThr = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="681" href="#"></a></td>
<td><pre>        if (oldCap &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="682" href="#"></a></td>
<td><pre>            if (oldCap &gt;= MAXIMUM_CAPACITY) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="683" href="#"></a></td>
<td><pre>                threshold = Integer.MAX_VALUE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="684" href="#"></a></td>
<td><pre>                return oldTab;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="685" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="686" href="#"></a></td>
<td><pre>            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="687" href="#"></a></td>
<td><pre>                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="688" href="#"></a></td>
<td><pre>                newThr = oldThr &lt;&lt; 1; // double threshold</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="689" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="690" href="#"></a></td>
<td><pre>        else if (oldThr &gt; 0) // initial capacity was placed in threshold</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="691" href="#"></a></td>
<td><pre>            newCap = oldThr;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="692" href="#"></a></td>
<td><pre>        else {               // zero initial threshold signifies using defaults</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="693" href="#"></a></td>
<td><pre>            newCap = DEFAULT_INITIAL_CAPACITY;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="694" href="#"></a></td>
<td><pre>            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="695" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="696" href="#"></a></td>
<td><pre>        if (newThr == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="697" href="#"></a></td>
<td><pre>            float ft = (float)newCap * loadFactor;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="698" href="#"></a></td>
<td><pre>            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="699" href="#"></a></td>
<td><pre>                      (int)ft : Integer.MAX_VALUE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="700" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="701" href="#"></a></td>
<td><pre>        threshold = newThr;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="702" href="#"></a></td>
<td><pre>        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="703" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="704" href="#"></a></td>
<td><pre>        table = newTab;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="705" href="#"></a></td>
<td><pre>        if (oldTab != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="706" href="#"></a></td>
<td><pre>            for (int j = 0; j &lt; oldCap; ++j) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="707" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="708" href="#"></a></td>
<td><pre>                if ((e = oldTab[j]) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="709" href="#"></a></td>
<td><pre>                    oldTab[j] = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="710" href="#"></a></td>
<td><pre>                    if (e.next == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="711" href="#"></a></td>
<td><pre>                        newTab[e.hash &amp; (newCap - 1)] = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="712" href="#"></a></td>
<td><pre>                    else if (e instanceof TreeNode)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="713" href="#"></a></td>
<td><pre>                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="714" href="#"></a></td>
<td><pre>                    else { // preserve order</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="715" href="#"></a></td>
<td><pre>                        Node&lt;K,V&gt; loHead = null, loTail = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="716" href="#"></a></td>
<td><pre>                        Node&lt;K,V&gt; hiHead = null, hiTail = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="717" href="#"></a></td>
<td><pre>                        Node&lt;K,V&gt; next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="718" href="#"></a></td>
<td><pre>                        do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="719" href="#"></a></td>
<td><pre>                            next = e.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="720" href="#"></a></td>
<td><pre>                            if ((e.hash &amp; oldCap) == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="721" href="#"></a></td>
<td><pre>                                if (loTail == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="722" href="#"></a></td>
<td><pre>                                    loHead = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="723" href="#"></a></td>
<td><pre>                                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="724" href="#"></a></td>
<td><pre>                                    loTail.next = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="725" href="#"></a></td>
<td><pre>                                loTail = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="726" href="#"></a></td>
<td><pre>                            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="727" href="#"></a></td>
<td><pre>                            else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="728" href="#"></a></td>
<td><pre>                                if (hiTail == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="729" href="#"></a></td>
<td><pre>                                    hiHead = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="730" href="#"></a></td>
<td><pre>                                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="731" href="#"></a></td>
<td><pre>                                    hiTail.next = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="732" href="#"></a></td>
<td><pre>                                hiTail = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="733" href="#"></a></td>
<td><pre>                            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="734" href="#"></a></td>
<td><pre>                        } while ((e = next) != null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="735" href="#"></a></td>
<td><pre>                        if (loTail != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="736" href="#"></a></td>
<td><pre>                            loTail.next = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="737" href="#"></a></td>
<td><pre>                            newTab[j] = loHead;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="738" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="739" href="#"></a></td>
<td><pre>                        if (hiTail != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="740" href="#"></a></td>
<td><pre>                            hiTail.next = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="741" href="#"></a></td>
<td><pre>                            newTab[j + oldCap] = hiHead;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="742" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="743" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="744" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="745" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="746" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="747" href="#"></a></td>
<td><pre>        return newTab;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="748" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="749" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="750" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="751" href="#"></a></td>
<td><pre>     * Replaces all linked nodes in bin at index for given hash unless</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="752" href="#"></a></td>
<td><pre>     * table is too small, in which case resizes instead.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="753" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="754" href="#"></a></td>
<td><pre>    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="755" href="#"></a></td>
<td><pre>        int n, index; Node&lt;K,V&gt; e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="756" href="#"></a></td>
<td><pre>        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="757" href="#"></a></td>
<td><pre>            resize();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="758" href="#"></a></td>
<td><pre>        else if ((e = tab[index = (n - 1) &amp; hash]) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="759" href="#"></a></td>
<td><pre>            TreeNode&lt;K,V&gt; hd = null, tl = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="760" href="#"></a></td>
<td><pre>            do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="761" href="#"></a></td>
<td><pre>                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="762" href="#"></a></td>
<td><pre>                if (tl == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="763" href="#"></a></td>
<td><pre>                    hd = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="764" href="#"></a></td>
<td><pre>                else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="765" href="#"></a></td>
<td><pre>                    p.prev = tl;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="766" href="#"></a></td>
<td><pre>                    tl.next = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="767" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="768" href="#"></a></td>
<td><pre>                tl = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="769" href="#"></a></td>
<td><pre>            } while ((e = e.next) != null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="770" href="#"></a></td>
<td><pre>            if ((tab[index] = hd) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="771" href="#"></a></td>
<td><pre>                hd.treeify(tab);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="772" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="773" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="774" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="775" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="776" href="#"></a></td>
<td><pre>     * Copies all of the mappings from the specified map to this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="777" href="#"></a></td>
<td><pre>     * These mappings will replace any mappings that this map had for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="778" href="#"></a></td>
<td><pre>     * any of the keys currently in the specified map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="779" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="780" href="#"></a></td>
<td><pre>     * @param m mappings to be stored in this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="781" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified map is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="782" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="783" href="#"></a></td>
<td><pre>    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="784" href="#"></a></td>
<td><pre>        putMapEntries(m, true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="785" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="786" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="787" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="788" href="#"></a></td>
<td><pre>     * Removes the mapping for the specified key from this map if present.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="789" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="790" href="#"></a></td>
<td><pre>     * @param  key key whose mapping is to be removed from the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="791" href="#"></a></td>
<td><pre>     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="792" href="#"></a></td>
<td><pre>     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="793" href="#"></a></td>
<td><pre>     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="794" href="#"></a></td>
<td><pre>     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="795" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="796" href="#"></a></td>
<td><pre>    public V remove(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="797" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="798" href="#"></a></td>
<td><pre>        return (e = removeNode(hash(key), key, null, false, true)) == null ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="799" href="#"></a></td>
<td><pre>            null : e.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="800" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="801" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="802" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="803" href="#"></a></td>
<td><pre>     * Implements Map.remove and related methods</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="804" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="805" href="#"></a></td>
<td><pre>     * @param hash hash for key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="806" href="#"></a></td>
<td><pre>     * @param key the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="807" href="#"></a></td>
<td><pre>     * @param value the value to match if matchValue, else ignored</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="808" href="#"></a></td>
<td><pre>     * @param matchValue if true only remove if value is equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="809" href="#"></a></td>
<td><pre>     * @param movable if false do not move other nodes while removing</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="810" href="#"></a></td>
<td><pre>     * @return the node, or null if none</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="811" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="812" href="#"></a></td>
<td><pre>    final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="813" href="#"></a></td>
<td><pre>                               boolean matchValue, boolean movable) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="814" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="815" href="#"></a></td>
<td><pre>        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="816" href="#"></a></td>
<td><pre>            (p = tab[index = (n - 1) &amp; hash]) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="817" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; node = null, e; K k; V v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="818" href="#"></a></td>
<td><pre>            if (p.hash == hash &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="819" href="#"></a></td>
<td><pre>                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="820" href="#"></a></td>
<td><pre>                node = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="821" href="#"></a></td>
<td><pre>            else if ((e = p.next) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="822" href="#"></a></td>
<td><pre>                if (p instanceof TreeNode)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="823" href="#"></a></td>
<td><pre>                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="824" href="#"></a></td>
<td><pre>                else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="825" href="#"></a></td>
<td><pre>                    do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="826" href="#"></a></td>
<td><pre>                        if (e.hash == hash &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="827" href="#"></a></td>
<td><pre>                            ((k = e.key) == key ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="828" href="#"></a></td>
<td><pre>                             (key != null &amp;&amp; key.equals(k)))) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="829" href="#"></a></td>
<td><pre>                            node = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="830" href="#"></a></td>
<td><pre>                            break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="831" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="832" href="#"></a></td>
<td><pre>                        p = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="833" href="#"></a></td>
<td><pre>                    } while ((e = e.next) != null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="834" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="835" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="836" href="#"></a></td>
<td><pre>            if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="837" href="#"></a></td>
<td><pre>                                 (value != null &amp;&amp; value.equals(v)))) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="838" href="#"></a></td>
<td><pre>                if (node instanceof TreeNode)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="839" href="#"></a></td>
<td><pre>                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="840" href="#"></a></td>
<td><pre>                else if (node == p)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="841" href="#"></a></td>
<td><pre>                    tab[index] = node.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="842" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="843" href="#"></a></td>
<td><pre>                    p.next = node.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="844" href="#"></a></td>
<td><pre>                ++modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="845" href="#"></a></td>
<td><pre>                --size;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="846" href="#"></a></td>
<td><pre>                afterNodeRemoval(node);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="847" href="#"></a></td>
<td><pre>                return node;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="848" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="849" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="850" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="851" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="852" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="853" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="854" href="#"></a></td>
<td><pre>     * Removes all of the mappings from this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="855" href="#"></a></td>
<td><pre>     * The map will be empty after this call returns.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="856" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="857" href="#"></a></td>
<td><pre>    public void clear() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="858" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt;[] tab;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="859" href="#"></a></td>
<td><pre>        modCount++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="860" href="#"></a></td>
<td><pre>        if ((tab = table) != null &amp;&amp; size &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="861" href="#"></a></td>
<td><pre>            size = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="862" href="#"></a></td>
<td><pre>            for (int i = 0; i &lt; tab.length; ++i)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="863" href="#"></a></td>
<td><pre>                tab[i] = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="864" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="865" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="866" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="867" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="868" href="#"></a></td>
<td><pre>     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="869" href="#"></a></td>
<td><pre>     * specified value.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="870" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="871" href="#"></a></td>
<td><pre>     * @param value value whose presence in this map is to be tested</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="872" href="#"></a></td>
<td><pre>     * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="873" href="#"></a></td>
<td><pre>     *         specified value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="874" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="875" href="#"></a></td>
<td><pre>    public boolean containsValue(Object value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="876" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt;[] tab; V v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="877" href="#"></a></td>
<td><pre>        if ((tab = table) != null &amp;&amp; size &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="878" href="#"></a></td>
<td><pre>            for (int i = 0; i &lt; tab.length; ++i) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="879" href="#"></a></td>
<td><pre>                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="880" href="#"></a></td>
<td><pre>                    if ((v = e.value) == value ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="881" href="#"></a></td>
<td><pre>                        (value != null &amp;&amp; value.equals(v)))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="882" href="#"></a></td>
<td><pre>                        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="883" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="884" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="885" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="886" href="#"></a></td>
<td><pre>        return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="887" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="888" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="889" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="890" href="#"></a></td>
<td><pre>     * Returns a {@link Set} view of the keys contained in this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="891" href="#"></a></td>
<td><pre>     * The set is backed by the map, so changes to the map are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="892" href="#"></a></td>
<td><pre>     * reflected in the set, and vice-versa.  If the map is modified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="893" href="#"></a></td>
<td><pre>     * while an iteration over the set is in progress (except through</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="894" href="#"></a></td>
<td><pre>     * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="895" href="#"></a></td>
<td><pre>     * the iteration are undefined.  The set supports element removal,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="896" href="#"></a></td>
<td><pre>     * which removes the corresponding mapping from the map, via the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="897" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="898" href="#"></a></td>
<td><pre>     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="899" href="#"></a></td>
<td><pre>     * operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="900" href="#"></a></td>
<td><pre>     * operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="901" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="902" href="#"></a></td>
<td><pre>     * @return a set view of the keys contained in this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="903" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="904" href="#"></a></td>
<td><pre>    public Set&lt;K&gt; keySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="905" href="#"></a></td>
<td><pre>        Set&lt;K&gt; ks;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="906" href="#"></a></td>
<td><pre>        return (ks = keySet) == null ? (keySet = new KeySet()) : ks;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="907" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="908" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="909" href="#"></a></td>
<td><pre>    final class KeySet extends AbstractSet&lt;K&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="910" href="#"></a></td>
<td><pre>        public final int size()                 { return size; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="911" href="#"></a></td>
<td><pre>        public final void clear()               { HashMap.this.clear(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="912" href="#"></a></td>
<td><pre>        public final Iterator&lt;K&gt; iterator()     { return new KeyIterator(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="913" href="#"></a></td>
<td><pre>        public final boolean contains(Object o) { return containsKey(o); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="914" href="#"></a></td>
<td><pre>        public final boolean remove(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="915" href="#"></a></td>
<td><pre>            return removeNode(hash(key), key, null, false, true) != null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="916" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="917" href="#"></a></td>
<td><pre>        public final Spliterator&lt;K&gt; spliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="918" href="#"></a></td>
<td><pre>            return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="919" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="920" href="#"></a></td>
<td><pre>        public final void forEach(Consumer&lt;? super K&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="921" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt;[] tab;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="922" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="923" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="924" href="#"></a></td>
<td><pre>            if (size &gt; 0 &amp;&amp; (tab = table) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="925" href="#"></a></td>
<td><pre>                int mc = modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="926" href="#"></a></td>
<td><pre>                for (int i = 0; i &lt; tab.length; ++i) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="927" href="#"></a></td>
<td><pre>                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="928" href="#"></a></td>
<td><pre>                        action.accept(e.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="929" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="930" href="#"></a></td>
<td><pre>                if (modCount != mc)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="931" href="#"></a></td>
<td><pre>                    throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="932" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="933" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="934" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="935" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="936" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="937" href="#"></a></td>
<td><pre>     * Returns a {@link Collection} view of the values contained in this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="938" href="#"></a></td>
<td><pre>     * The collection is backed by the map, so changes to the map are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="939" href="#"></a></td>
<td><pre>     * reflected in the collection, and vice-versa.  If the map is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="940" href="#"></a></td>
<td><pre>     * modified while an iteration over the collection is in progress</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="941" href="#"></a></td>
<td><pre>     * (except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="942" href="#"></a></td>
<td><pre>     * the results of the iteration are undefined.  The collection</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="943" href="#"></a></td>
<td><pre>     * supports element removal, which removes the corresponding</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="944" href="#"></a></td>
<td><pre>     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="945" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="946" href="#"></a></td>
<td><pre>     * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="947" href="#"></a></td>
<td><pre>     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="948" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="949" href="#"></a></td>
<td><pre>     * @return a view of the values contained in this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="950" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="951" href="#"></a></td>
<td><pre>    public Collection&lt;V&gt; values() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="952" href="#"></a></td>
<td><pre>        Collection&lt;V&gt; vs;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="953" href="#"></a></td>
<td><pre>        return (vs = values) == null ? (values = new Values()) : vs;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="954" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="955" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="956" href="#"></a></td>
<td><pre>    final class Values extends AbstractCollection&lt;V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="957" href="#"></a></td>
<td><pre>        public final int size()                 { return size; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="958" href="#"></a></td>
<td><pre>        public final void clear()               { HashMap.this.clear(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="959" href="#"></a></td>
<td><pre>        public final Iterator&lt;V&gt; iterator()     { return new ValueIterator(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="960" href="#"></a></td>
<td><pre>        public final boolean contains(Object o) { return containsValue(o); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="961" href="#"></a></td>
<td><pre>        public final Spliterator&lt;V&gt; spliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="962" href="#"></a></td>
<td><pre>            return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="963" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="964" href="#"></a></td>
<td><pre>        public final void forEach(Consumer&lt;? super V&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="965" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt;[] tab;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="966" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="967" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="968" href="#"></a></td>
<td><pre>            if (size &gt; 0 &amp;&amp; (tab = table) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="969" href="#"></a></td>
<td><pre>                int mc = modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="970" href="#"></a></td>
<td><pre>                for (int i = 0; i &lt; tab.length; ++i) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="971" href="#"></a></td>
<td><pre>                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="972" href="#"></a></td>
<td><pre>                        action.accept(e.value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="973" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="974" href="#"></a></td>
<td><pre>                if (modCount != mc)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="975" href="#"></a></td>
<td><pre>                    throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="976" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="977" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="978" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="979" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="980" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="981" href="#"></a></td>
<td><pre>     * Returns a {@link Set} view of the mappings contained in this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="982" href="#"></a></td>
<td><pre>     * The set is backed by the map, so changes to the map are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="983" href="#"></a></td>
<td><pre>     * reflected in the set, and vice-versa.  If the map is modified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="984" href="#"></a></td>
<td><pre>     * while an iteration over the set is in progress (except through</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="985" href="#"></a></td>
<td><pre>     * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="986" href="#"></a></td>
<td><pre>     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="987" href="#"></a></td>
<td><pre>     * iterator) the results of the iteration are undefined.  The set</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="988" href="#"></a></td>
<td><pre>     * supports element removal, which removes the corresponding</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="989" href="#"></a></td>
<td><pre>     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="990" href="#"></a></td>
<td><pre>     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="991" href="#"></a></td>
<td><pre>     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="992" href="#"></a></td>
<td><pre>     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="993" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="994" href="#"></a></td>
<td><pre>     * @return a set view of the mappings contained in this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="995" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="996" href="#"></a></td>
<td><pre>    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="997" href="#"></a></td>
<td><pre>        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="998" href="#"></a></td>
<td><pre>        return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="999" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1000" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1001" href="#"></a></td>
<td><pre>    final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1002" href="#"></a></td>
<td><pre>        public final int size()                 { return size; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1003" href="#"></a></td>
<td><pre>        public final void clear()               { HashMap.this.clear(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1004" href="#"></a></td>
<td><pre>        public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1005" href="#"></a></td>
<td><pre>            return new EntryIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1006" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1007" href="#"></a></td>
<td><pre>        public final boolean contains(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1008" href="#"></a></td>
<td><pre>            if (!(o instanceof Map.Entry))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1009" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1010" href="#"></a></td>
<td><pre>            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1011" href="#"></a></td>
<td><pre>            Object key = e.getKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1012" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; candidate = getNode(hash(key), key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1013" href="#"></a></td>
<td><pre>            return candidate != null &amp;&amp; candidate.equals(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1014" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1015" href="#"></a></td>
<td><pre>        public final boolean remove(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1016" href="#"></a></td>
<td><pre>            if (o instanceof Map.Entry) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1017" href="#"></a></td>
<td><pre>                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1018" href="#"></a></td>
<td><pre>                Object key = e.getKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1019" href="#"></a></td>
<td><pre>                Object value = e.getValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1020" href="#"></a></td>
<td><pre>                return removeNode(hash(key), key, value, true, true) != null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1021" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1022" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1023" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1024" href="#"></a></td>
<td><pre>        public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1025" href="#"></a></td>
<td><pre>            return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1026" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1027" href="#"></a></td>
<td><pre>        public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1028" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt;[] tab;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1029" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1030" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1031" href="#"></a></td>
<td><pre>            if (size &gt; 0 &amp;&amp; (tab = table) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1032" href="#"></a></td>
<td><pre>                int mc = modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1033" href="#"></a></td>
<td><pre>                for (int i = 0; i &lt; tab.length; ++i) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1034" href="#"></a></td>
<td><pre>                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1035" href="#"></a></td>
<td><pre>                        action.accept(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1036" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1037" href="#"></a></td>
<td><pre>                if (modCount != mc)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1038" href="#"></a></td>
<td><pre>                    throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1039" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1040" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1041" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1042" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1043" href="#"></a></td>
<td><pre>    // Overrides of JDK8 Map extension methods</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1044" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1045" href="#"></a></td>
<td><pre>    @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1046" href="#"></a></td>
<td><pre>    public V getOrDefault(Object key, V defaultValue) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1047" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1048" href="#"></a></td>
<td><pre>        return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1049" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1050" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1051" href="#"></a></td>
<td><pre>    @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1052" href="#"></a></td>
<td><pre>    public V putIfAbsent(K key, V value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1053" href="#"></a></td>
<td><pre>        return putVal(hash(key), key, value, true, true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1054" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1055" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1056" href="#"></a></td>
<td><pre>    @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1057" href="#"></a></td>
<td><pre>    public boolean remove(Object key, Object value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1058" href="#"></a></td>
<td><pre>        return removeNode(hash(key), key, value, true, true) != null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1059" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1060" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1061" href="#"></a></td>
<td><pre>    @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1062" href="#"></a></td>
<td><pre>    public boolean replace(K key, V oldValue, V newValue) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1063" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; e; V v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1064" href="#"></a></td>
<td><pre>        if ((e = getNode(hash(key), key)) != null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1065" href="#"></a></td>
<td><pre>            ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1066" href="#"></a></td>
<td><pre>            e.value = newValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1067" href="#"></a></td>
<td><pre>            afterNodeAccess(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1068" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1069" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1070" href="#"></a></td>
<td><pre>        return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1071" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1072" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1073" href="#"></a></td>
<td><pre>    @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1074" href="#"></a></td>
<td><pre>    public V replace(K key, V value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1075" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1076" href="#"></a></td>
<td><pre>        if ((e = getNode(hash(key), key)) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1077" href="#"></a></td>
<td><pre>            V oldValue = e.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1078" href="#"></a></td>
<td><pre>            e.value = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1079" href="#"></a></td>
<td><pre>            afterNodeAccess(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1080" href="#"></a></td>
<td><pre>            return oldValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1081" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1082" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1083" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1084" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1085" href="#"></a></td>
<td><pre>    @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1086" href="#"></a></td>
<td><pre>    public V computeIfAbsent(K key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1087" href="#"></a></td>
<td><pre>                             Function&lt;? super K, ? extends V&gt; mappingFunction) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1088" href="#"></a></td>
<td><pre>        if (mappingFunction == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1089" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1090" href="#"></a></td>
<td><pre>        int hash = hash(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1091" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1092" href="#"></a></td>
<td><pre>        int binCount = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1093" href="#"></a></td>
<td><pre>        TreeNode&lt;K,V&gt; t = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1094" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; old = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1095" href="#"></a></td>
<td><pre>        if (size &gt; threshold || (tab = table) == null ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1096" href="#"></a></td>
<td><pre>            (n = tab.length) == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1097" href="#"></a></td>
<td><pre>            n = (tab = resize()).length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1098" href="#"></a></td>
<td><pre>        if ((first = tab[i = (n - 1) &amp; hash]) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1099" href="#"></a></td>
<td><pre>            if (first instanceof TreeNode)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1100" href="#"></a></td>
<td><pre>                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1101" href="#"></a></td>
<td><pre>            else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1102" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; e = first; K k;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1103" href="#"></a></td>
<td><pre>                do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1104" href="#"></a></td>
<td><pre>                    if (e.hash == hash &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1105" href="#"></a></td>
<td><pre>                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1106" href="#"></a></td>
<td><pre>                        old = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1107" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1108" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1109" href="#"></a></td>
<td><pre>                    ++binCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1110" href="#"></a></td>
<td><pre>                } while ((e = e.next) != null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1111" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1112" href="#"></a></td>
<td><pre>            V oldValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1113" href="#"></a></td>
<td><pre>            if (old != null &amp;&amp; (oldValue = old.value) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1114" href="#"></a></td>
<td><pre>                afterNodeAccess(old);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1115" href="#"></a></td>
<td><pre>                return oldValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1116" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1117" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1118" href="#"></a></td>
<td><pre>        V v = mappingFunction.apply(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1119" href="#"></a></td>
<td><pre>        if (v == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1120" href="#"></a></td>
<td><pre>            return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1121" href="#"></a></td>
<td><pre>        } else if (old != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1122" href="#"></a></td>
<td><pre>            old.value = v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1123" href="#"></a></td>
<td><pre>            afterNodeAccess(old);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1124" href="#"></a></td>
<td><pre>            return v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1125" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1126" href="#"></a></td>
<td><pre>        else if (t != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1127" href="#"></a></td>
<td><pre>            t.putTreeVal(this, tab, hash, key, v);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1128" href="#"></a></td>
<td><pre>        else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1129" href="#"></a></td>
<td><pre>            tab[i] = newNode(hash, key, v, first);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1130" href="#"></a></td>
<td><pre>            if (binCount &gt;= TREEIFY_THRESHOLD - 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1131" href="#"></a></td>
<td><pre>                treeifyBin(tab, hash);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1132" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1133" href="#"></a></td>
<td><pre>        ++modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1134" href="#"></a></td>
<td><pre>        ++size;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1135" href="#"></a></td>
<td><pre>        afterNodeInsertion(true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1136" href="#"></a></td>
<td><pre>        return v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1137" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1138" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1139" href="#"></a></td>
<td><pre>    public V computeIfPresent(K key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1140" href="#"></a></td>
<td><pre>                              BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1141" href="#"></a></td>
<td><pre>        if (remappingFunction == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1142" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1143" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; e; V oldValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1144" href="#"></a></td>
<td><pre>        int hash = hash(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1145" href="#"></a></td>
<td><pre>        if ((e = getNode(hash, key)) != null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1146" href="#"></a></td>
<td><pre>            (oldValue = e.value) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1147" href="#"></a></td>
<td><pre>            V v = remappingFunction.apply(key, oldValue);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1148" href="#"></a></td>
<td><pre>            if (v != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1149" href="#"></a></td>
<td><pre>                e.value = v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1150" href="#"></a></td>
<td><pre>                afterNodeAccess(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1151" href="#"></a></td>
<td><pre>                return v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1152" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1153" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1154" href="#"></a></td>
<td><pre>                removeNode(hash, key, null, false, true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1155" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1156" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1157" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1158" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1159" href="#"></a></td>
<td><pre>    @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1160" href="#"></a></td>
<td><pre>    public V compute(K key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1161" href="#"></a></td>
<td><pre>                     BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1162" href="#"></a></td>
<td><pre>        if (remappingFunction == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1163" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1164" href="#"></a></td>
<td><pre>        int hash = hash(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1165" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1166" href="#"></a></td>
<td><pre>        int binCount = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1167" href="#"></a></td>
<td><pre>        TreeNode&lt;K,V&gt; t = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1168" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; old = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1169" href="#"></a></td>
<td><pre>        if (size &gt; threshold || (tab = table) == null ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1170" href="#"></a></td>
<td><pre>            (n = tab.length) == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1171" href="#"></a></td>
<td><pre>            n = (tab = resize()).length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1172" href="#"></a></td>
<td><pre>        if ((first = tab[i = (n - 1) &amp; hash]) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1173" href="#"></a></td>
<td><pre>            if (first instanceof TreeNode)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1174" href="#"></a></td>
<td><pre>                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1175" href="#"></a></td>
<td><pre>            else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1176" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; e = first; K k;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1177" href="#"></a></td>
<td><pre>                do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1178" href="#"></a></td>
<td><pre>                    if (e.hash == hash &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1179" href="#"></a></td>
<td><pre>                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1180" href="#"></a></td>
<td><pre>                        old = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1181" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1182" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1183" href="#"></a></td>
<td><pre>                    ++binCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1184" href="#"></a></td>
<td><pre>                } while ((e = e.next) != null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1185" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1186" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1187" href="#"></a></td>
<td><pre>        V oldValue = (old == null) ? null : old.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1188" href="#"></a></td>
<td><pre>        V v = remappingFunction.apply(key, oldValue);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1189" href="#"></a></td>
<td><pre>        if (old != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1190" href="#"></a></td>
<td><pre>            if (v != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1191" href="#"></a></td>
<td><pre>                old.value = v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1192" href="#"></a></td>
<td><pre>                afterNodeAccess(old);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1193" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1194" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1195" href="#"></a></td>
<td><pre>                removeNode(hash, key, null, false, true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1196" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1197" href="#"></a></td>
<td><pre>        else if (v != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1198" href="#"></a></td>
<td><pre>            if (t != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1199" href="#"></a></td>
<td><pre>                t.putTreeVal(this, tab, hash, key, v);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1200" href="#"></a></td>
<td><pre>            else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1201" href="#"></a></td>
<td><pre>                tab[i] = newNode(hash, key, v, first);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1202" href="#"></a></td>
<td><pre>                if (binCount &gt;= TREEIFY_THRESHOLD - 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1203" href="#"></a></td>
<td><pre>                    treeifyBin(tab, hash);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1204" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1205" href="#"></a></td>
<td><pre>            ++modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1206" href="#"></a></td>
<td><pre>            ++size;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1207" href="#"></a></td>
<td><pre>            afterNodeInsertion(true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1208" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1209" href="#"></a></td>
<td><pre>        return v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1210" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1211" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1212" href="#"></a></td>
<td><pre>    @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1213" href="#"></a></td>
<td><pre>    public V merge(K key, V value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1214" href="#"></a></td>
<td><pre>                   BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1215" href="#"></a></td>
<td><pre>        if (value == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1216" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1217" href="#"></a></td>
<td><pre>        if (remappingFunction == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1218" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1219" href="#"></a></td>
<td><pre>        int hash = hash(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1220" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1221" href="#"></a></td>
<td><pre>        int binCount = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1222" href="#"></a></td>
<td><pre>        TreeNode&lt;K,V&gt; t = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1223" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; old = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1224" href="#"></a></td>
<td><pre>        if (size &gt; threshold || (tab = table) == null ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1225" href="#"></a></td>
<td><pre>            (n = tab.length) == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1226" href="#"></a></td>
<td><pre>            n = (tab = resize()).length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1227" href="#"></a></td>
<td><pre>        if ((first = tab[i = (n - 1) &amp; hash]) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1228" href="#"></a></td>
<td><pre>            if (first instanceof TreeNode)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1229" href="#"></a></td>
<td><pre>                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1230" href="#"></a></td>
<td><pre>            else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1231" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; e = first; K k;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1232" href="#"></a></td>
<td><pre>                do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1233" href="#"></a></td>
<td><pre>                    if (e.hash == hash &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1234" href="#"></a></td>
<td><pre>                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1235" href="#"></a></td>
<td><pre>                        old = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1236" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1237" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1238" href="#"></a></td>
<td><pre>                    ++binCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1239" href="#"></a></td>
<td><pre>                } while ((e = e.next) != null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1240" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1241" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1242" href="#"></a></td>
<td><pre>        if (old != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1243" href="#"></a></td>
<td><pre>            V v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1244" href="#"></a></td>
<td><pre>            if (old.value != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1245" href="#"></a></td>
<td><pre>                v = remappingFunction.apply(old.value, value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1246" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1247" href="#"></a></td>
<td><pre>                v = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1248" href="#"></a></td>
<td><pre>            if (v != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1249" href="#"></a></td>
<td><pre>                old.value = v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1250" href="#"></a></td>
<td><pre>                afterNodeAccess(old);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1251" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1252" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1253" href="#"></a></td>
<td><pre>                removeNode(hash, key, null, false, true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1254" href="#"></a></td>
<td><pre>            return v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1255" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1256" href="#"></a></td>
<td><pre>        if (value != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1257" href="#"></a></td>
<td><pre>            if (t != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1258" href="#"></a></td>
<td><pre>                t.putTreeVal(this, tab, hash, key, value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1259" href="#"></a></td>
<td><pre>            else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1260" href="#"></a></td>
<td><pre>                tab[i] = newNode(hash, key, value, first);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1261" href="#"></a></td>
<td><pre>                if (binCount &gt;= TREEIFY_THRESHOLD - 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1262" href="#"></a></td>
<td><pre>                    treeifyBin(tab, hash);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1263" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1264" href="#"></a></td>
<td><pre>            ++modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1265" href="#"></a></td>
<td><pre>            ++size;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1266" href="#"></a></td>
<td><pre>            afterNodeInsertion(true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1267" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1268" href="#"></a></td>
<td><pre>        return value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1269" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1270" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1271" href="#"></a></td>
<td><pre>    @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1272" href="#"></a></td>
<td><pre>    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1273" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt;[] tab;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1274" href="#"></a></td>
<td><pre>        if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1275" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1276" href="#"></a></td>
<td><pre>        if (size &gt; 0 &amp;&amp; (tab = table) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1277" href="#"></a></td>
<td><pre>            int mc = modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1278" href="#"></a></td>
<td><pre>            for (int i = 0; i &lt; tab.length; ++i) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1279" href="#"></a></td>
<td><pre>                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1280" href="#"></a></td>
<td><pre>                    action.accept(e.key, e.value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1281" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1282" href="#"></a></td>
<td><pre>            if (modCount != mc)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1283" href="#"></a></td>
<td><pre>                throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1284" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1285" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1286" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1287" href="#"></a></td>
<td><pre>    @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1288" href="#"></a></td>
<td><pre>    public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1289" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt;[] tab;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1290" href="#"></a></td>
<td><pre>        if (function == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1291" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1292" href="#"></a></td>
<td><pre>        if (size &gt; 0 &amp;&amp; (tab = table) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1293" href="#"></a></td>
<td><pre>            int mc = modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1294" href="#"></a></td>
<td><pre>            for (int i = 0; i &lt; tab.length; ++i) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1295" href="#"></a></td>
<td><pre>                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1296" href="#"></a></td>
<td><pre>                    e.value = function.apply(e.key, e.value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1297" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1298" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1299" href="#"></a></td>
<td><pre>            if (modCount != mc)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1300" href="#"></a></td>
<td><pre>                throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1301" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1302" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1303" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1304" href="#"></a></td>
<td><pre>    /* ------------------------------------------------------------ */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1305" href="#"></a></td>
<td><pre>    // Cloning and serialization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1306" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1307" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1308" href="#"></a></td>
<td><pre>     * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1309" href="#"></a></td>
<td><pre>     * values themselves are not cloned.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1310" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1311" href="#"></a></td>
<td><pre>     * @return a shallow copy of this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1312" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1313" href="#"></a></td>
<td><pre>    @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1314" href="#"></a></td>
<td><pre>    @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1315" href="#"></a></td>
<td><pre>    public Object clone() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1316" href="#"></a></td>
<td><pre>        HashMap&lt;K,V&gt; result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1317" href="#"></a></td>
<td><pre>        try {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1318" href="#"></a></td>
<td><pre>            result = (HashMap&lt;K,V&gt;)super.clone();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1319" href="#"></a></td>
<td><pre>        } catch (CloneNotSupportedException e) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1320" href="#"></a></td>
<td><pre>            // this shouldn't happen, since we are Cloneable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1321" href="#"></a></td>
<td><pre>            throw new InternalError(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1322" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1323" href="#"></a></td>
<td><pre>        result.reinitialize();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1324" href="#"></a></td>
<td><pre>        result.putMapEntries(this, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1325" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1326" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1327" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1328" href="#"></a></td>
<td><pre>    // These methods are also used when serializing HashSets</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1329" href="#"></a></td>
<td><pre>    final float loadFactor() { return loadFactor; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1330" href="#"></a></td>
<td><pre>    final int capacity() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1331" href="#"></a></td>
<td><pre>        return (table != null) ? table.length :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1332" href="#"></a></td>
<td><pre>            (threshold &gt; 0) ? threshold :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1333" href="#"></a></td>
<td><pre>            DEFAULT_INITIAL_CAPACITY;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1334" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1335" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1336" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1337" href="#"></a></td>
<td><pre>     * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1338" href="#"></a></td>
<td><pre>     * serialize it).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1339" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1340" href="#"></a></td>
<td><pre>     * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1341" href="#"></a></td>
<td><pre>     *             bucket array) is emitted (int), followed by the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1342" href="#"></a></td>
<td><pre>     *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1343" href="#"></a></td>
<td><pre>     *             mappings), followed by the key (Object) and value (Object)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1344" href="#"></a></td>
<td><pre>     *             for each key-value mapping.  The key-value mappings are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1345" href="#"></a></td>
<td><pre>     *             emitted in no particular order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1346" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1347" href="#"></a></td>
<td><pre>    private void writeObject(java.io.ObjectOutputStream s)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1348" href="#"></a></td>
<td><pre>        throws IOException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1349" href="#"></a></td>
<td><pre>        int buckets = capacity();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1350" href="#"></a></td>
<td><pre>        // Write out the threshold, loadfactor, and any hidden stuff</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1351" href="#"></a></td>
<td><pre>        s.defaultWriteObject();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1352" href="#"></a></td>
<td><pre>        s.writeInt(buckets);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1353" href="#"></a></td>
<td><pre>        s.writeInt(size);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1354" href="#"></a></td>
<td><pre>        internalWriteEntries(s);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1355" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1356" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1357" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1358" href="#"></a></td>
<td><pre>     * Reconstitute the {@code HashMap} instance from a stream (i.e.,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1359" href="#"></a></td>
<td><pre>     * deserialize it).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1360" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1361" href="#"></a></td>
<td><pre>    private void readObject(java.io.ObjectInputStream s)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1362" href="#"></a></td>
<td><pre>        throws IOException, ClassNotFoundException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1363" href="#"></a></td>
<td><pre>        // Read in the threshold (ignored), loadfactor, and any hidden stuff</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1364" href="#"></a></td>
<td><pre>        s.defaultReadObject();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1365" href="#"></a></td>
<td><pre>        reinitialize();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1366" href="#"></a></td>
<td><pre>        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1367" href="#"></a></td>
<td><pre>            throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1368" href="#"></a></td>
<td><pre>                                             loadFactor);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1369" href="#"></a></td>
<td><pre>        s.readInt();                // Read and ignore number of buckets</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1370" href="#"></a></td>
<td><pre>        int mappings = s.readInt(); // Read number of mappings (size)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1371" href="#"></a></td>
<td><pre>        if (mappings &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1372" href="#"></a></td>
<td><pre>            throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1373" href="#"></a></td>
<td><pre>                                             mappings);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1374" href="#"></a></td>
<td><pre>        else if (mappings &gt; 0) { // (if zero, use defaults)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1375" href="#"></a></td>
<td><pre>            // Size the table using given load factor only if within</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1376" href="#"></a></td>
<td><pre>            // range of 0.25...4.0</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1377" href="#"></a></td>
<td><pre>            float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1378" href="#"></a></td>
<td><pre>            float fc = (float)mappings / lf + 1.0f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1379" href="#"></a></td>
<td><pre>            int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1380" href="#"></a></td>
<td><pre>                       DEFAULT_INITIAL_CAPACITY :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1381" href="#"></a></td>
<td><pre>                       (fc &gt;= MAXIMUM_CAPACITY) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1382" href="#"></a></td>
<td><pre>                       MAXIMUM_CAPACITY :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1383" href="#"></a></td>
<td><pre>                       tableSizeFor((int)fc));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1384" href="#"></a></td>
<td><pre>            float ft = (float)cap * lf;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1385" href="#"></a></td>
<td><pre>            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1386" href="#"></a></td>
<td><pre>                         (int)ft : Integer.MAX_VALUE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1387" href="#"></a></td>
<td><pre>            @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1388" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1389" href="#"></a></td>
<td><pre>            table = tab;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1390" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1391" href="#"></a></td>
<td><pre>            // Read the keys and values, and put the mappings in the HashMap</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1392" href="#"></a></td>
<td><pre>            for (int i = 0; i &lt; mappings; i++) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1393" href="#"></a></td>
<td><pre>                @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1394" href="#"></a></td>
<td><pre>                    K key = (K) s.readObject();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1395" href="#"></a></td>
<td><pre>                @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1396" href="#"></a></td>
<td><pre>                    V value = (V) s.readObject();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1397" href="#"></a></td>
<td><pre>                putVal(hash(key), key, value, false, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1398" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1399" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1400" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1401" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1402" href="#"></a></td>
<td><pre>    /* ------------------------------------------------------------ */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1403" href="#"></a></td>
<td><pre>    // iterators</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1404" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1405" href="#"></a></td>
<td><pre>    abstract class HashIterator {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1406" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; next;        // next entry to return</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1407" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; current;     // current entry</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1408" href="#"></a></td>
<td><pre>        int expectedModCount;  // for fast-fail</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1409" href="#"></a></td>
<td><pre>        int index;             // current slot</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1410" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1411" href="#"></a></td>
<td><pre>        HashIterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1412" href="#"></a></td>
<td><pre>            expectedModCount = modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1413" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt;[] t = table;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1414" href="#"></a></td>
<td><pre>            current = next = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1415" href="#"></a></td>
<td><pre>            index = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1416" href="#"></a></td>
<td><pre>            if (t != null &amp;&amp; size &gt; 0) { // advance to first entry</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1417" href="#"></a></td>
<td><pre>                do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1418" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1419" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1420" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1421" href="#"></a></td>
<td><pre>        public final boolean hasNext() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1422" href="#"></a></td>
<td><pre>            return next != null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1423" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1424" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1425" href="#"></a></td>
<td><pre>        final Node&lt;K,V&gt; nextNode() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1426" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt;[] t;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1427" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; e = next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1428" href="#"></a></td>
<td><pre>            if (modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1429" href="#"></a></td>
<td><pre>                throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1430" href="#"></a></td>
<td><pre>            if (e == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1431" href="#"></a></td>
<td><pre>                throw new NoSuchElementException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1432" href="#"></a></td>
<td><pre>            if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1433" href="#"></a></td>
<td><pre>                do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1434" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1435" href="#"></a></td>
<td><pre>            return e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1436" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1437" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1438" href="#"></a></td>
<td><pre>        public final void remove() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1439" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; p = current;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1440" href="#"></a></td>
<td><pre>            if (p == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1441" href="#"></a></td>
<td><pre>                throw new IllegalStateException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1442" href="#"></a></td>
<td><pre>            if (modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1443" href="#"></a></td>
<td><pre>                throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1444" href="#"></a></td>
<td><pre>            current = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1445" href="#"></a></td>
<td><pre>            K key = p.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1446" href="#"></a></td>
<td><pre>            removeNode(hash(key), key, null, false, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1447" href="#"></a></td>
<td><pre>            expectedModCount = modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1448" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1449" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1450" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1451" href="#"></a></td>
<td><pre>    final class KeyIterator extends HashIterator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1452" href="#"></a></td>
<td><pre>        implements Iterator&lt;K&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1453" href="#"></a></td>
<td><pre>        public final K next() { return nextNode().key; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1454" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1455" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1456" href="#"></a></td>
<td><pre>    final class ValueIterator extends HashIterator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1457" href="#"></a></td>
<td><pre>        implements Iterator&lt;V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1458" href="#"></a></td>
<td><pre>        public final V next() { return nextNode().value; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1459" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1460" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1461" href="#"></a></td>
<td><pre>    final class EntryIterator extends HashIterator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1462" href="#"></a></td>
<td><pre>        implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1463" href="#"></a></td>
<td><pre>        public final Map.Entry&lt;K,V&gt; next() { return nextNode(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1464" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1465" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1466" href="#"></a></td>
<td><pre>    /* ------------------------------------------------------------ */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1467" href="#"></a></td>
<td><pre>    // spliterators</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1468" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1469" href="#"></a></td>
<td><pre>    static class HashMapSpliterator&lt;K,V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1470" href="#"></a></td>
<td><pre>        final HashMap&lt;K,V&gt; map;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1471" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; current;          // current node</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1472" href="#"></a></td>
<td><pre>        int index;                  // current index, modified on advance/split</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1473" href="#"></a></td>
<td><pre>        int fence;                  // one past last index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1474" href="#"></a></td>
<td><pre>        int est;                    // size estimate</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1475" href="#"></a></td>
<td><pre>        int expectedModCount;       // for comodification checks</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1476" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1477" href="#"></a></td>
<td><pre>        HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1478" href="#"></a></td>
<td><pre>                           int fence, int est,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1479" href="#"></a></td>
<td><pre>                           int expectedModCount) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1480" href="#"></a></td>
<td><pre>            this.map = m;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1481" href="#"></a></td>
<td><pre>            this.index = origin;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1482" href="#"></a></td>
<td><pre>            this.fence = fence;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1483" href="#"></a></td>
<td><pre>            this.est = est;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1484" href="#"></a></td>
<td><pre>            this.expectedModCount = expectedModCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1485" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1486" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1487" href="#"></a></td>
<td><pre>        final int getFence() { // initialize fence and size on first use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1488" href="#"></a></td>
<td><pre>            int hi;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1489" href="#"></a></td>
<td><pre>            if ((hi = fence) &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1490" href="#"></a></td>
<td><pre>                HashMap&lt;K,V&gt; m = map;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1491" href="#"></a></td>
<td><pre>                est = m.size;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1492" href="#"></a></td>
<td><pre>                expectedModCount = m.modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1493" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt;[] tab = m.table;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1494" href="#"></a></td>
<td><pre>                hi = fence = (tab == null) ? 0 : tab.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1495" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1496" href="#"></a></td>
<td><pre>            return hi;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1497" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1498" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1499" href="#"></a></td>
<td><pre>        public final long estimateSize() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1500" href="#"></a></td>
<td><pre>            getFence(); // force init</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1501" href="#"></a></td>
<td><pre>            return (long) est;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1502" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1503" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1504" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1505" href="#"></a></td>
<td><pre>    static final class KeySpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1506" href="#"></a></td>
<td><pre>        extends HashMapSpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1507" href="#"></a></td>
<td><pre>        implements Spliterator&lt;K&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1508" href="#"></a></td>
<td><pre>        KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1509" href="#"></a></td>
<td><pre>                       int expectedModCount) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1510" href="#"></a></td>
<td><pre>            super(m, origin, fence, est, expectedModCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1511" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1512" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1513" href="#"></a></td>
<td><pre>        public KeySpliterator&lt;K,V&gt; trySplit() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1514" href="#"></a></td>
<td><pre>            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1515" href="#"></a></td>
<td><pre>            return (lo &gt;= mid || current != null) ? null :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1516" href="#"></a></td>
<td><pre>                new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1517" href="#"></a></td>
<td><pre>                                        expectedModCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1518" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1519" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1520" href="#"></a></td>
<td><pre>        public void forEachRemaining(Consumer&lt;? super K&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1521" href="#"></a></td>
<td><pre>            int i, hi, mc;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1522" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1523" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1524" href="#"></a></td>
<td><pre>            HashMap&lt;K,V&gt; m = map;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1525" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt;[] tab = m.table;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1526" href="#"></a></td>
<td><pre>            if ((hi = fence) &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1527" href="#"></a></td>
<td><pre>                mc = expectedModCount = m.modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1528" href="#"></a></td>
<td><pre>                hi = fence = (tab == null) ? 0 : tab.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1529" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1530" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1531" href="#"></a></td>
<td><pre>                mc = expectedModCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1532" href="#"></a></td>
<td><pre>            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1533" href="#"></a></td>
<td><pre>                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1534" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; p = current;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1535" href="#"></a></td>
<td><pre>                current = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1536" href="#"></a></td>
<td><pre>                do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1537" href="#"></a></td>
<td><pre>                    if (p == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1538" href="#"></a></td>
<td><pre>                        p = tab[i++];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1539" href="#"></a></td>
<td><pre>                    else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1540" href="#"></a></td>
<td><pre>                        action.accept(p.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1541" href="#"></a></td>
<td><pre>                        p = p.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1542" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1543" href="#"></a></td>
<td><pre>                } while (p != null || i &lt; hi);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1544" href="#"></a></td>
<td><pre>                if (m.modCount != mc)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1545" href="#"></a></td>
<td><pre>                    throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1546" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1547" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1548" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1549" href="#"></a></td>
<td><pre>        public boolean tryAdvance(Consumer&lt;? super K&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1550" href="#"></a></td>
<td><pre>            int hi;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1551" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1552" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1553" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt;[] tab = map.table;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1554" href="#"></a></td>
<td><pre>            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1555" href="#"></a></td>
<td><pre>                while (current != null || index &lt; hi) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1556" href="#"></a></td>
<td><pre>                    if (current == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1557" href="#"></a></td>
<td><pre>                        current = tab[index++];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1558" href="#"></a></td>
<td><pre>                    else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1559" href="#"></a></td>
<td><pre>                        K k = current.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1560" href="#"></a></td>
<td><pre>                        current = current.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1561" href="#"></a></td>
<td><pre>                        action.accept(k);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1562" href="#"></a></td>
<td><pre>                        if (map.modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1563" href="#"></a></td>
<td><pre>                            throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1564" href="#"></a></td>
<td><pre>                        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1565" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1566" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1567" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1568" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1569" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1570" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1571" href="#"></a></td>
<td><pre>        public int characteristics() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1572" href="#"></a></td>
<td><pre>            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) |</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1573" href="#"></a></td>
<td><pre>                Spliterator.DISTINCT;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1574" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1575" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1576" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1577" href="#"></a></td>
<td><pre>    static final class ValueSpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1578" href="#"></a></td>
<td><pre>        extends HashMapSpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1579" href="#"></a></td>
<td><pre>        implements Spliterator&lt;V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1580" href="#"></a></td>
<td><pre>        ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1581" href="#"></a></td>
<td><pre>                         int expectedModCount) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1582" href="#"></a></td>
<td><pre>            super(m, origin, fence, est, expectedModCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1583" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1584" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1585" href="#"></a></td>
<td><pre>        public ValueSpliterator&lt;K,V&gt; trySplit() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1586" href="#"></a></td>
<td><pre>            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1587" href="#"></a></td>
<td><pre>            return (lo &gt;= mid || current != null) ? null :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1588" href="#"></a></td>
<td><pre>                new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1589" href="#"></a></td>
<td><pre>                                          expectedModCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1590" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1591" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1592" href="#"></a></td>
<td><pre>        public void forEachRemaining(Consumer&lt;? super V&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1593" href="#"></a></td>
<td><pre>            int i, hi, mc;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1594" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1595" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1596" href="#"></a></td>
<td><pre>            HashMap&lt;K,V&gt; m = map;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1597" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt;[] tab = m.table;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1598" href="#"></a></td>
<td><pre>            if ((hi = fence) &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1599" href="#"></a></td>
<td><pre>                mc = expectedModCount = m.modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1600" href="#"></a></td>
<td><pre>                hi = fence = (tab == null) ? 0 : tab.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1601" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1602" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1603" href="#"></a></td>
<td><pre>                mc = expectedModCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1604" href="#"></a></td>
<td><pre>            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1605" href="#"></a></td>
<td><pre>                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1606" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; p = current;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1607" href="#"></a></td>
<td><pre>                current = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1608" href="#"></a></td>
<td><pre>                do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1609" href="#"></a></td>
<td><pre>                    if (p == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1610" href="#"></a></td>
<td><pre>                        p = tab[i++];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1611" href="#"></a></td>
<td><pre>                    else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1612" href="#"></a></td>
<td><pre>                        action.accept(p.value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1613" href="#"></a></td>
<td><pre>                        p = p.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1614" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1615" href="#"></a></td>
<td><pre>                } while (p != null || i &lt; hi);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1616" href="#"></a></td>
<td><pre>                if (m.modCount != mc)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1617" href="#"></a></td>
<td><pre>                    throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1618" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1619" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1620" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1621" href="#"></a></td>
<td><pre>        public boolean tryAdvance(Consumer&lt;? super V&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1622" href="#"></a></td>
<td><pre>            int hi;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1623" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1624" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1625" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt;[] tab = map.table;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1626" href="#"></a></td>
<td><pre>            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1627" href="#"></a></td>
<td><pre>                while (current != null || index &lt; hi) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1628" href="#"></a></td>
<td><pre>                    if (current == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1629" href="#"></a></td>
<td><pre>                        current = tab[index++];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1630" href="#"></a></td>
<td><pre>                    else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1631" href="#"></a></td>
<td><pre>                        V v = current.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1632" href="#"></a></td>
<td><pre>                        current = current.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1633" href="#"></a></td>
<td><pre>                        action.accept(v);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1634" href="#"></a></td>
<td><pre>                        if (map.modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1635" href="#"></a></td>
<td><pre>                            throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1636" href="#"></a></td>
<td><pre>                        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1637" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1638" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1639" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1640" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1641" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1642" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1643" href="#"></a></td>
<td><pre>        public int characteristics() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1644" href="#"></a></td>
<td><pre>            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1645" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1646" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1647" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1648" href="#"></a></td>
<td><pre>    static final class EntrySpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1649" href="#"></a></td>
<td><pre>        extends HashMapSpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1650" href="#"></a></td>
<td><pre>        implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1651" href="#"></a></td>
<td><pre>        EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1652" href="#"></a></td>
<td><pre>                         int expectedModCount) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1653" href="#"></a></td>
<td><pre>            super(m, origin, fence, est, expectedModCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1654" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1655" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1656" href="#"></a></td>
<td><pre>        public EntrySpliterator&lt;K,V&gt; trySplit() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1657" href="#"></a></td>
<td><pre>            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1658" href="#"></a></td>
<td><pre>            return (lo &gt;= mid || current != null) ? null :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1659" href="#"></a></td>
<td><pre>                new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1660" href="#"></a></td>
<td><pre>                                          expectedModCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1661" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1662" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1663" href="#"></a></td>
<td><pre>        public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1664" href="#"></a></td>
<td><pre>            int i, hi, mc;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1665" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1666" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1667" href="#"></a></td>
<td><pre>            HashMap&lt;K,V&gt; m = map;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1668" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt;[] tab = m.table;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1669" href="#"></a></td>
<td><pre>            if ((hi = fence) &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1670" href="#"></a></td>
<td><pre>                mc = expectedModCount = m.modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1671" href="#"></a></td>
<td><pre>                hi = fence = (tab == null) ? 0 : tab.length;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1672" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1673" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1674" href="#"></a></td>
<td><pre>                mc = expectedModCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1675" href="#"></a></td>
<td><pre>            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1676" href="#"></a></td>
<td><pre>                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1677" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; p = current;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1678" href="#"></a></td>
<td><pre>                current = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1679" href="#"></a></td>
<td><pre>                do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1680" href="#"></a></td>
<td><pre>                    if (p == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1681" href="#"></a></td>
<td><pre>                        p = tab[i++];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1682" href="#"></a></td>
<td><pre>                    else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1683" href="#"></a></td>
<td><pre>                        action.accept(p);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1684" href="#"></a></td>
<td><pre>                        p = p.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1685" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1686" href="#"></a></td>
<td><pre>                } while (p != null || i &lt; hi);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1687" href="#"></a></td>
<td><pre>                if (m.modCount != mc)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1688" href="#"></a></td>
<td><pre>                    throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1689" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1690" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1691" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1692" href="#"></a></td>
<td><pre>        public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1693" href="#"></a></td>
<td><pre>            int hi;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1694" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1695" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1696" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt;[] tab = map.table;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1697" href="#"></a></td>
<td><pre>            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1698" href="#"></a></td>
<td><pre>                while (current != null || index &lt; hi) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1699" href="#"></a></td>
<td><pre>                    if (current == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1700" href="#"></a></td>
<td><pre>                        current = tab[index++];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1701" href="#"></a></td>
<td><pre>                    else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1702" href="#"></a></td>
<td><pre>                        Node&lt;K,V&gt; e = current;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1703" href="#"></a></td>
<td><pre>                        current = current.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1704" href="#"></a></td>
<td><pre>                        action.accept(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1705" href="#"></a></td>
<td><pre>                        if (map.modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1706" href="#"></a></td>
<td><pre>                            throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1707" href="#"></a></td>
<td><pre>                        return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1708" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1709" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1710" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1711" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1712" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1713" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1714" href="#"></a></td>
<td><pre>        public int characteristics() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1715" href="#"></a></td>
<td><pre>            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) |</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1716" href="#"></a></td>
<td><pre>                Spliterator.DISTINCT;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1717" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1718" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1719" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1720" href="#"></a></td>
<td><pre>    /* ------------------------------------------------------------ */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1721" href="#"></a></td>
<td><pre>    // LinkedHashMap support</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1722" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1723" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1724" href="#"></a></td>
<td><pre>    /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1725" href="#"></a></td>
<td><pre>     * The following package-protected methods are designed to be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1726" href="#"></a></td>
<td><pre>     * overridden by LinkedHashMap, but not by any other subclass.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1727" href="#"></a></td>
<td><pre>     * Nearly all other internal methods are also package-protected</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1728" href="#"></a></td>
<td><pre>     * but are declared final, so can be used by LinkedHashMap, view</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1729" href="#"></a></td>
<td><pre>     * classes, and HashSet.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1730" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1731" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1732" href="#"></a></td>
<td><pre>    // Create a regular (non-tree) node</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1733" href="#"></a></td>
<td><pre>    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1734" href="#"></a></td>
<td><pre>        return new Node&lt;&gt;(hash, key, value, next);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1735" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1736" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1737" href="#"></a></td>
<td><pre>    // For conversion from TreeNodes to plain nodes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1738" href="#"></a></td>
<td><pre>    Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1739" href="#"></a></td>
<td><pre>        return new Node&lt;&gt;(p.hash, p.key, p.value, next);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1740" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1741" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1742" href="#"></a></td>
<td><pre>    // Create a tree bin node</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1743" href="#"></a></td>
<td><pre>    TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1744" href="#"></a></td>
<td><pre>        return new TreeNode&lt;&gt;(hash, key, value, next);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1745" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1746" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1747" href="#"></a></td>
<td><pre>    // For treeifyBin</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1748" href="#"></a></td>
<td><pre>    TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1749" href="#"></a></td>
<td><pre>        return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1750" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1751" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1752" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1753" href="#"></a></td>
<td><pre>     * Reset to initial default state.  Called by clone and readObject.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1754" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1755" href="#"></a></td>
<td><pre>    void reinitialize() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1756" href="#"></a></td>
<td><pre>        table = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1757" href="#"></a></td>
<td><pre>        entrySet = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1758" href="#"></a></td>
<td><pre>        keySet = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1759" href="#"></a></td>
<td><pre>        values = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1760" href="#"></a></td>
<td><pre>        modCount = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1761" href="#"></a></td>
<td><pre>        threshold = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1762" href="#"></a></td>
<td><pre>        size = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1763" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1764" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1765" href="#"></a></td>
<td><pre>    // Callbacks to allow LinkedHashMap post-actions</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1766" href="#"></a></td>
<td><pre>    void afterNodeAccess(Node&lt;K,V&gt; p) { }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1767" href="#"></a></td>
<td><pre>    void afterNodeInsertion(boolean evict) { }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1768" href="#"></a></td>
<td><pre>    void afterNodeRemoval(Node&lt;K,V&gt; p) { }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1769" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1770" href="#"></a></td>
<td><pre>    // Called only from writeObject, to ensure compatible ordering.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1771" href="#"></a></td>
<td><pre>    void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1772" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt;[] tab;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1773" href="#"></a></td>
<td><pre>        if (size &gt; 0 &amp;&amp; (tab = table) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1774" href="#"></a></td>
<td><pre>            for (int i = 0; i &lt; tab.length; ++i) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1775" href="#"></a></td>
<td><pre>                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1776" href="#"></a></td>
<td><pre>                    s.writeObject(e.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1777" href="#"></a></td>
<td><pre>                    s.writeObject(e.value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1778" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1779" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1780" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1781" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1782" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1783" href="#"></a></td>
<td><pre>    /* ------------------------------------------------------------ */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1784" href="#"></a></td>
<td><pre>    // Tree bins</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1785" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1786" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1787" href="#"></a></td>
<td><pre>     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1788" href="#"></a></td>
<td><pre>     * extends Node) so can be used as extension of either regular or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1789" href="#"></a></td>
<td><pre>     * linked node.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1790" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1791" href="#"></a></td>
<td><pre>    static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1792" href="#"></a></td>
<td><pre>        TreeNode&lt;K,V&gt; parent;  // red-black tree links</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1793" href="#"></a></td>
<td><pre>        TreeNode&lt;K,V&gt; left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1794" href="#"></a></td>
<td><pre>        TreeNode&lt;K,V&gt; right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1795" href="#"></a></td>
<td><pre>        TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1796" href="#"></a></td>
<td><pre>        boolean red;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1797" href="#"></a></td>
<td><pre>        TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1798" href="#"></a></td>
<td><pre>            super(hash, key, val, next);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1799" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1800" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1801" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1802" href="#"></a></td>
<td><pre>         * Returns root of tree containing this node.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1803" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1804" href="#"></a></td>
<td><pre>        final TreeNode&lt;K,V&gt; root() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1805" href="#"></a></td>
<td><pre>            for (TreeNode&lt;K,V&gt; r = this, p;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1806" href="#"></a></td>
<td><pre>                if ((p = r.parent) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1807" href="#"></a></td>
<td><pre>                    return r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1808" href="#"></a></td>
<td><pre>                r = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1809" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1810" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1811" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1812" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1813" href="#"></a></td>
<td><pre>         * Ensures that the given root is the first node of its bin.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1814" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1815" href="#"></a></td>
<td><pre>        static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1816" href="#"></a></td>
<td><pre>            int n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1817" href="#"></a></td>
<td><pre>            if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1818" href="#"></a></td>
<td><pre>                int index = (n - 1) &amp; root.hash;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1819" href="#"></a></td>
<td><pre>                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1820" href="#"></a></td>
<td><pre>                if (root != first) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1821" href="#"></a></td>
<td><pre>                    Node&lt;K,V&gt; rn;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1822" href="#"></a></td>
<td><pre>                    tab[index] = root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1823" href="#"></a></td>
<td><pre>                    TreeNode&lt;K,V&gt; rp = root.prev;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1824" href="#"></a></td>
<td><pre>                    if ((rn = root.next) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1825" href="#"></a></td>
<td><pre>                        ((TreeNode&lt;K,V&gt;)rn).prev = rp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1826" href="#"></a></td>
<td><pre>                    if (rp != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1827" href="#"></a></td>
<td><pre>                        rp.next = rn;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1828" href="#"></a></td>
<td><pre>                    if (first != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1829" href="#"></a></td>
<td><pre>                        first.prev = root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1830" href="#"></a></td>
<td><pre>                    root.next = first;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1831" href="#"></a></td>
<td><pre>                    root.prev = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1832" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1833" href="#"></a></td>
<td><pre>                assert checkInvariants(root);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1834" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1835" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1836" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1837" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1838" href="#"></a></td>
<td><pre>         * Finds the node starting at root p with the given hash and key.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1839" href="#"></a></td>
<td><pre>         * The kc argument caches comparableClassFor(key) upon first use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1840" href="#"></a></td>
<td><pre>         * comparing keys.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1841" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1842" href="#"></a></td>
<td><pre>        final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1843" href="#"></a></td>
<td><pre>            TreeNode&lt;K,V&gt; p = this;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1844" href="#"></a></td>
<td><pre>            do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1845" href="#"></a></td>
<td><pre>                int ph, dir; K pk;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1846" href="#"></a></td>
<td><pre>                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1847" href="#"></a></td>
<td><pre>                if ((ph = p.hash) &gt; h)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1848" href="#"></a></td>
<td><pre>                    p = pl;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1849" href="#"></a></td>
<td><pre>                else if (ph &lt; h)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1850" href="#"></a></td>
<td><pre>                    p = pr;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1851" href="#"></a></td>
<td><pre>                else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1852" href="#"></a></td>
<td><pre>                    return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1853" href="#"></a></td>
<td><pre>                else if (pl == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1854" href="#"></a></td>
<td><pre>                    p = pr;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1855" href="#"></a></td>
<td><pre>                else if (pr == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1856" href="#"></a></td>
<td><pre>                    p = pl;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1857" href="#"></a></td>
<td><pre>                else if ((kc != null ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1858" href="#"></a></td>
<td><pre>                          (kc = comparableClassFor(k)) != null) &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1859" href="#"></a></td>
<td><pre>                         (dir = compareComparables(kc, k, pk)) != 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1860" href="#"></a></td>
<td><pre>                    p = (dir &lt; 0) ? pl : pr;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1861" href="#"></a></td>
<td><pre>                else if ((q = pr.find(h, k, kc)) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1862" href="#"></a></td>
<td><pre>                    return q;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1863" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1864" href="#"></a></td>
<td><pre>                    p = pl;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1865" href="#"></a></td>
<td><pre>            } while (p != null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1866" href="#"></a></td>
<td><pre>            return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1867" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1868" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1869" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1870" href="#"></a></td>
<td><pre>         * Calls find for root node.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1871" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1872" href="#"></a></td>
<td><pre>        final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1873" href="#"></a></td>
<td><pre>            return ((parent != null) ? root() : this).find(h, k, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1874" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1875" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1876" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1877" href="#"></a></td>
<td><pre>         * Tie-breaking utility for ordering insertions when equal</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1878" href="#"></a></td>
<td><pre>         * hashCodes and non-comparable. We don't require a total</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1879" href="#"></a></td>
<td><pre>         * order, just a consistent insertion rule to maintain</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1880" href="#"></a></td>
<td><pre>         * equivalence across rebalancings. Tie-breaking further than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1881" href="#"></a></td>
<td><pre>         * necessary simplifies testing a bit.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1882" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1883" href="#"></a></td>
<td><pre>        static int tieBreakOrder(Object a, Object b) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1884" href="#"></a></td>
<td><pre>            int d;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1885" href="#"></a></td>
<td><pre>            if (a == null || b == null ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1886" href="#"></a></td>
<td><pre>                (d = a.getClass().getName().</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1887" href="#"></a></td>
<td><pre>                 compareTo(b.getClass().getName())) == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1888" href="#"></a></td>
<td><pre>                d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1889" href="#"></a></td>
<td><pre>                     -1 : 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1890" href="#"></a></td>
<td><pre>            return d;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1891" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1892" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1893" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1894" href="#"></a></td>
<td><pre>         * Forms tree of the nodes linked from this node.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1895" href="#"></a></td>
<td><pre>         * @return root of tree</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1896" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1897" href="#"></a></td>
<td><pre>        final void treeify(Node&lt;K,V&gt;[] tab) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1898" href="#"></a></td>
<td><pre>            TreeNode&lt;K,V&gt; root = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1899" href="#"></a></td>
<td><pre>            for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1900" href="#"></a></td>
<td><pre>                next = (TreeNode&lt;K,V&gt;)x.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1901" href="#"></a></td>
<td><pre>                x.left = x.right = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1902" href="#"></a></td>
<td><pre>                if (root == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1903" href="#"></a></td>
<td><pre>                    x.parent = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1904" href="#"></a></td>
<td><pre>                    x.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1905" href="#"></a></td>
<td><pre>                    root = x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1906" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1907" href="#"></a></td>
<td><pre>                else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1908" href="#"></a></td>
<td><pre>                    K k = x.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1909" href="#"></a></td>
<td><pre>                    int h = x.hash;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1910" href="#"></a></td>
<td><pre>                    Class&lt;?&gt; kc = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1911" href="#"></a></td>
<td><pre>                    for (TreeNode&lt;K,V&gt; p = root;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1912" href="#"></a></td>
<td><pre>                        int dir, ph;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1913" href="#"></a></td>
<td><pre>                        K pk = p.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1914" href="#"></a></td>
<td><pre>                        if ((ph = p.hash) &gt; h)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1915" href="#"></a></td>
<td><pre>                            dir = -1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1916" href="#"></a></td>
<td><pre>                        else if (ph &lt; h)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1917" href="#"></a></td>
<td><pre>                            dir = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1918" href="#"></a></td>
<td><pre>                        else if ((kc == null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1919" href="#"></a></td>
<td><pre>                                  (kc = comparableClassFor(k)) == null) ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1920" href="#"></a></td>
<td><pre>                                 (dir = compareComparables(kc, k, pk)) == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1921" href="#"></a></td>
<td><pre>                            dir = tieBreakOrder(k, pk);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1922" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1923" href="#"></a></td>
<td><pre>                        TreeNode&lt;K,V&gt; xp = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1924" href="#"></a></td>
<td><pre>                        if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1925" href="#"></a></td>
<td><pre>                            x.parent = xp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1926" href="#"></a></td>
<td><pre>                            if (dir &lt;= 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1927" href="#"></a></td>
<td><pre>                                xp.left = x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1928" href="#"></a></td>
<td><pre>                            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1929" href="#"></a></td>
<td><pre>                                xp.right = x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1930" href="#"></a></td>
<td><pre>                            root = balanceInsertion(root, x);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1931" href="#"></a></td>
<td><pre>                            break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1932" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1933" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1934" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1935" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1936" href="#"></a></td>
<td><pre>            moveRootToFront(tab, root);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1937" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1938" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1939" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1940" href="#"></a></td>
<td><pre>         * Returns a list of non-TreeNodes replacing those linked from</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1941" href="#"></a></td>
<td><pre>         * this node.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1942" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1943" href="#"></a></td>
<td><pre>        final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1944" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; hd = null, tl = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1945" href="#"></a></td>
<td><pre>            for (Node&lt;K,V&gt; q = this; q != null; q = q.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1946" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; p = map.replacementNode(q, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1947" href="#"></a></td>
<td><pre>                if (tl == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1948" href="#"></a></td>
<td><pre>                    hd = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1949" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1950" href="#"></a></td>
<td><pre>                    tl.next = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1951" href="#"></a></td>
<td><pre>                tl = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1952" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1953" href="#"></a></td>
<td><pre>            return hd;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1954" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1955" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1956" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1957" href="#"></a></td>
<td><pre>         * Tree version of putVal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1958" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1959" href="#"></a></td>
<td><pre>        final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1960" href="#"></a></td>
<td><pre>                                       int h, K k, V v) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1961" href="#"></a></td>
<td><pre>            Class&lt;?&gt; kc = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1962" href="#"></a></td>
<td><pre>            boolean searched = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1963" href="#"></a></td>
<td><pre>            TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1964" href="#"></a></td>
<td><pre>            for (TreeNode&lt;K,V&gt; p = root;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1965" href="#"></a></td>
<td><pre>                int dir, ph; K pk;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1966" href="#"></a></td>
<td><pre>                if ((ph = p.hash) &gt; h)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1967" href="#"></a></td>
<td><pre>                    dir = -1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1968" href="#"></a></td>
<td><pre>                else if (ph &lt; h)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1969" href="#"></a></td>
<td><pre>                    dir = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1970" href="#"></a></td>
<td><pre>                else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk)))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1971" href="#"></a></td>
<td><pre>                    return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1972" href="#"></a></td>
<td><pre>                else if ((kc == null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1973" href="#"></a></td>
<td><pre>                          (kc = comparableClassFor(k)) == null) ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1974" href="#"></a></td>
<td><pre>                         (dir = compareComparables(kc, k, pk)) == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1975" href="#"></a></td>
<td><pre>                    if (!searched) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1976" href="#"></a></td>
<td><pre>                        TreeNode&lt;K,V&gt; q, ch;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1977" href="#"></a></td>
<td><pre>                        searched = true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1978" href="#"></a></td>
<td><pre>                        if (((ch = p.left) != null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1979" href="#"></a></td>
<td><pre>                             (q = ch.find(h, k, kc)) != null) ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1980" href="#"></a></td>
<td><pre>                            ((ch = p.right) != null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1981" href="#"></a></td>
<td><pre>                             (q = ch.find(h, k, kc)) != null))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1982" href="#"></a></td>
<td><pre>                            return q;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1983" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1984" href="#"></a></td>
<td><pre>                    dir = tieBreakOrder(k, pk);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1985" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1986" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1987" href="#"></a></td>
<td><pre>                TreeNode&lt;K,V&gt; xp = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1988" href="#"></a></td>
<td><pre>                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1989" href="#"></a></td>
<td><pre>                    Node&lt;K,V&gt; xpn = xp.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1990" href="#"></a></td>
<td><pre>                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1991" href="#"></a></td>
<td><pre>                    if (dir &lt;= 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1992" href="#"></a></td>
<td><pre>                        xp.left = x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1993" href="#"></a></td>
<td><pre>                    else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1994" href="#"></a></td>
<td><pre>                        xp.right = x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1995" href="#"></a></td>
<td><pre>                    xp.next = x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1996" href="#"></a></td>
<td><pre>                    x.parent = x.prev = xp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1997" href="#"></a></td>
<td><pre>                    if (xpn != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1998" href="#"></a></td>
<td><pre>                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1999" href="#"></a></td>
<td><pre>                    moveRootToFront(tab, balanceInsertion(root, x));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2000" href="#"></a></td>
<td><pre>                    return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2001" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2002" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2003" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2004" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2005" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2006" href="#"></a></td>
<td><pre>         * Removes the given node, that must be present before this call.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2007" href="#"></a></td>
<td><pre>         * This is messier than typical red-black deletion code because we</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2008" href="#"></a></td>
<td><pre>         * cannot swap the contents of an interior node with a leaf</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2009" href="#"></a></td>
<td><pre>         * successor that is pinned by &quot;next&quot; pointers that are accessible</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2010" href="#"></a></td>
<td><pre>         * independently during traversal. So instead we swap the tree</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2011" href="#"></a></td>
<td><pre>         * linkages. If the current tree appears to have too few nodes,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2012" href="#"></a></td>
<td><pre>         * the bin is converted back to a plain bin. (The test triggers</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2013" href="#"></a></td>
<td><pre>         * somewhere between 2 and 6 nodes, depending on tree structure).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2014" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2015" href="#"></a></td>
<td><pre>        final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2016" href="#"></a></td>
<td><pre>                                  boolean movable) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2017" href="#"></a></td>
<td><pre>            int n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2018" href="#"></a></td>
<td><pre>            if (tab == null || (n = tab.length) == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2019" href="#"></a></td>
<td><pre>                return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2020" href="#"></a></td>
<td><pre>            int index = (n - 1) &amp; hash;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2021" href="#"></a></td>
<td><pre>            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2022" href="#"></a></td>
<td><pre>            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2023" href="#"></a></td>
<td><pre>            if (pred == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2024" href="#"></a></td>
<td><pre>                tab[index] = first = succ;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2025" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2026" href="#"></a></td>
<td><pre>                pred.next = succ;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2027" href="#"></a></td>
<td><pre>            if (succ != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2028" href="#"></a></td>
<td><pre>                succ.prev = pred;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2029" href="#"></a></td>
<td><pre>            if (first == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2030" href="#"></a></td>
<td><pre>                return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2031" href="#"></a></td>
<td><pre>            if (root.parent != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2032" href="#"></a></td>
<td><pre>                root = root.root();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2033" href="#"></a></td>
<td><pre>            if (root == null || root.right == null ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2034" href="#"></a></td>
<td><pre>                (rl = root.left) == null || rl.left == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2035" href="#"></a></td>
<td><pre>                tab[index] = first.untreeify(map);  // too small</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2036" href="#"></a></td>
<td><pre>                return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2037" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2038" href="#"></a></td>
<td><pre>            TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2039" href="#"></a></td>
<td><pre>            if (pl != null &amp;&amp; pr != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2040" href="#"></a></td>
<td><pre>                TreeNode&lt;K,V&gt; s = pr, sl;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2041" href="#"></a></td>
<td><pre>                while ((sl = s.left) != null) // find successor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2042" href="#"></a></td>
<td><pre>                    s = sl;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2043" href="#"></a></td>
<td><pre>                boolean c = s.red; s.red = p.red; p.red = c; // swap colors</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2044" href="#"></a></td>
<td><pre>                TreeNode&lt;K,V&gt; sr = s.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2045" href="#"></a></td>
<td><pre>                TreeNode&lt;K,V&gt; pp = p.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2046" href="#"></a></td>
<td><pre>                if (s == pr) { // p was s's direct parent</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2047" href="#"></a></td>
<td><pre>                    p.parent = s;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2048" href="#"></a></td>
<td><pre>                    s.right = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2049" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2050" href="#"></a></td>
<td><pre>                else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2051" href="#"></a></td>
<td><pre>                    TreeNode&lt;K,V&gt; sp = s.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2052" href="#"></a></td>
<td><pre>                    if ((p.parent = sp) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2053" href="#"></a></td>
<td><pre>                        if (s == sp.left)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2054" href="#"></a></td>
<td><pre>                            sp.left = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2055" href="#"></a></td>
<td><pre>                        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2056" href="#"></a></td>
<td><pre>                            sp.right = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2057" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2058" href="#"></a></td>
<td><pre>                    if ((s.right = pr) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2059" href="#"></a></td>
<td><pre>                        pr.parent = s;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2060" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2061" href="#"></a></td>
<td><pre>                p.left = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2062" href="#"></a></td>
<td><pre>                if ((p.right = sr) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2063" href="#"></a></td>
<td><pre>                    sr.parent = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2064" href="#"></a></td>
<td><pre>                if ((s.left = pl) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2065" href="#"></a></td>
<td><pre>                    pl.parent = s;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2066" href="#"></a></td>
<td><pre>                if ((s.parent = pp) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2067" href="#"></a></td>
<td><pre>                    root = s;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2068" href="#"></a></td>
<td><pre>                else if (p == pp.left)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2069" href="#"></a></td>
<td><pre>                    pp.left = s;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2070" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2071" href="#"></a></td>
<td><pre>                    pp.right = s;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2072" href="#"></a></td>
<td><pre>                if (sr != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2073" href="#"></a></td>
<td><pre>                    replacement = sr;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2074" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2075" href="#"></a></td>
<td><pre>                    replacement = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2076" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2077" href="#"></a></td>
<td><pre>            else if (pl != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2078" href="#"></a></td>
<td><pre>                replacement = pl;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2079" href="#"></a></td>
<td><pre>            else if (pr != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2080" href="#"></a></td>
<td><pre>                replacement = pr;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2081" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2082" href="#"></a></td>
<td><pre>                replacement = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2083" href="#"></a></td>
<td><pre>            if (replacement != p) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2084" href="#"></a></td>
<td><pre>                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2085" href="#"></a></td>
<td><pre>                if (pp == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2086" href="#"></a></td>
<td><pre>                    root = replacement;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2087" href="#"></a></td>
<td><pre>                else if (p == pp.left)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2088" href="#"></a></td>
<td><pre>                    pp.left = replacement;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2089" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2090" href="#"></a></td>
<td><pre>                    pp.right = replacement;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2091" href="#"></a></td>
<td><pre>                p.left = p.right = p.parent = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2092" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2093" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2094" href="#"></a></td>
<td><pre>            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2095" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2096" href="#"></a></td>
<td><pre>            if (replacement == p) {  // detach</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2097" href="#"></a></td>
<td><pre>                TreeNode&lt;K,V&gt; pp = p.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2098" href="#"></a></td>
<td><pre>                p.parent = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2099" href="#"></a></td>
<td><pre>                if (pp != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2100" href="#"></a></td>
<td><pre>                    if (p == pp.left)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2101" href="#"></a></td>
<td><pre>                        pp.left = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2102" href="#"></a></td>
<td><pre>                    else if (p == pp.right)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2103" href="#"></a></td>
<td><pre>                        pp.right = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2104" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2105" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2106" href="#"></a></td>
<td><pre>            if (movable)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2107" href="#"></a></td>
<td><pre>                moveRootToFront(tab, r);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2108" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2109" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2110" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2111" href="#"></a></td>
<td><pre>         * Splits nodes in a tree bin into lower and upper tree bins,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2112" href="#"></a></td>
<td><pre>         * or untreeifies if now too small. Called only from resize;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2113" href="#"></a></td>
<td><pre>         * see above discussion about split bits and indices.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2114" href="#"></a></td>
<td><pre>         *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2115" href="#"></a></td>
<td><pre>         * @param map the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2116" href="#"></a></td>
<td><pre>         * @param tab the table for recording bin heads</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2117" href="#"></a></td>
<td><pre>         * @param index the index of the table being split</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2118" href="#"></a></td>
<td><pre>         * @param bit the bit of hash to split on</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2119" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2120" href="#"></a></td>
<td><pre>        final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2121" href="#"></a></td>
<td><pre>            TreeNode&lt;K,V&gt; b = this;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2122" href="#"></a></td>
<td><pre>            // Relink into lo and hi lists, preserving order</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2123" href="#"></a></td>
<td><pre>            TreeNode&lt;K,V&gt; loHead = null, loTail = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2124" href="#"></a></td>
<td><pre>            TreeNode&lt;K,V&gt; hiHead = null, hiTail = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2125" href="#"></a></td>
<td><pre>            int lc = 0, hc = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2126" href="#"></a></td>
<td><pre>            for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2127" href="#"></a></td>
<td><pre>                next = (TreeNode&lt;K,V&gt;)e.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2128" href="#"></a></td>
<td><pre>                e.next = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2129" href="#"></a></td>
<td><pre>                if ((e.hash &amp; bit) == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2130" href="#"></a></td>
<td><pre>                    if ((e.prev = loTail) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2131" href="#"></a></td>
<td><pre>                        loHead = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2132" href="#"></a></td>
<td><pre>                    else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2133" href="#"></a></td>
<td><pre>                        loTail.next = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2134" href="#"></a></td>
<td><pre>                    loTail = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2135" href="#"></a></td>
<td><pre>                    ++lc;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2136" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2137" href="#"></a></td>
<td><pre>                else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2138" href="#"></a></td>
<td><pre>                    if ((e.prev = hiTail) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2139" href="#"></a></td>
<td><pre>                        hiHead = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2140" href="#"></a></td>
<td><pre>                    else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2141" href="#"></a></td>
<td><pre>                        hiTail.next = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2142" href="#"></a></td>
<td><pre>                    hiTail = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2143" href="#"></a></td>
<td><pre>                    ++hc;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2144" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2145" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2146" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2147" href="#"></a></td>
<td><pre>            if (loHead != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2148" href="#"></a></td>
<td><pre>                if (lc &lt;= UNTREEIFY_THRESHOLD)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2149" href="#"></a></td>
<td><pre>                    tab[index] = loHead.untreeify(map);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2150" href="#"></a></td>
<td><pre>                else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2151" href="#"></a></td>
<td><pre>                    tab[index] = loHead;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2152" href="#"></a></td>
<td><pre>                    if (hiHead != null) // (else is already treeified)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2153" href="#"></a></td>
<td><pre>                        loHead.treeify(tab);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2154" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2155" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2156" href="#"></a></td>
<td><pre>            if (hiHead != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2157" href="#"></a></td>
<td><pre>                if (hc &lt;= UNTREEIFY_THRESHOLD)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2158" href="#"></a></td>
<td><pre>                    tab[index + bit] = hiHead.untreeify(map);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2159" href="#"></a></td>
<td><pre>                else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2160" href="#"></a></td>
<td><pre>                    tab[index + bit] = hiHead;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2161" href="#"></a></td>
<td><pre>                    if (loHead != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2162" href="#"></a></td>
<td><pre>                        hiHead.treeify(tab);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2163" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2164" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2165" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2166" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2167" href="#"></a></td>
<td><pre>        /* ------------------------------------------------------------ */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2168" href="#"></a></td>
<td><pre>        // Red-black tree methods, all adapted from CLR</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2169" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2170" href="#"></a></td>
<td><pre>        static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2171" href="#"></a></td>
<td><pre>                                              TreeNode&lt;K,V&gt; p) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2172" href="#"></a></td>
<td><pre>            TreeNode&lt;K,V&gt; r, pp, rl;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2173" href="#"></a></td>
<td><pre>            if (p != null &amp;&amp; (r = p.right) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2174" href="#"></a></td>
<td><pre>                if ((rl = p.right = r.left) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2175" href="#"></a></td>
<td><pre>                    rl.parent = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2176" href="#"></a></td>
<td><pre>                if ((pp = r.parent = p.parent) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2177" href="#"></a></td>
<td><pre>                    (root = r).red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2178" href="#"></a></td>
<td><pre>                else if (pp.left == p)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2179" href="#"></a></td>
<td><pre>                    pp.left = r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2180" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2181" href="#"></a></td>
<td><pre>                    pp.right = r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2182" href="#"></a></td>
<td><pre>                r.left = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2183" href="#"></a></td>
<td><pre>                p.parent = r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2184" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2185" href="#"></a></td>
<td><pre>            return root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2186" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2187" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2188" href="#"></a></td>
<td><pre>        static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2189" href="#"></a></td>
<td><pre>                                               TreeNode&lt;K,V&gt; p) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2190" href="#"></a></td>
<td><pre>            TreeNode&lt;K,V&gt; l, pp, lr;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2191" href="#"></a></td>
<td><pre>            if (p != null &amp;&amp; (l = p.left) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2192" href="#"></a></td>
<td><pre>                if ((lr = p.left = l.right) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2193" href="#"></a></td>
<td><pre>                    lr.parent = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2194" href="#"></a></td>
<td><pre>                if ((pp = l.parent = p.parent) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2195" href="#"></a></td>
<td><pre>                    (root = l).red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2196" href="#"></a></td>
<td><pre>                else if (pp.right == p)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2197" href="#"></a></td>
<td><pre>                    pp.right = l;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2198" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2199" href="#"></a></td>
<td><pre>                    pp.left = l;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2200" href="#"></a></td>
<td><pre>                l.right = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2201" href="#"></a></td>
<td><pre>                p.parent = l;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2202" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2203" href="#"></a></td>
<td><pre>            return root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2204" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2205" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2206" href="#"></a></td>
<td><pre>        static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2207" href="#"></a></td>
<td><pre>                                                    TreeNode&lt;K,V&gt; x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2208" href="#"></a></td>
<td><pre>            x.red = true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2209" href="#"></a></td>
<td><pre>            for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2210" href="#"></a></td>
<td><pre>                if ((xp = x.parent) == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2211" href="#"></a></td>
<td><pre>                    x.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2212" href="#"></a></td>
<td><pre>                    return x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2213" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2214" href="#"></a></td>
<td><pre>                else if (!xp.red || (xpp = xp.parent) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2215" href="#"></a></td>
<td><pre>                    return root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2216" href="#"></a></td>
<td><pre>                if (xp == (xppl = xpp.left)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2217" href="#"></a></td>
<td><pre>                    if ((xppr = xpp.right) != null &amp;&amp; xppr.red) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2218" href="#"></a></td>
<td><pre>                        xppr.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2219" href="#"></a></td>
<td><pre>                        xp.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2220" href="#"></a></td>
<td><pre>                        xpp.red = true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2221" href="#"></a></td>
<td><pre>                        x = xpp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2222" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2223" href="#"></a></td>
<td><pre>                    else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2224" href="#"></a></td>
<td><pre>                        if (x == xp.right) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2225" href="#"></a></td>
<td><pre>                            root = rotateLeft(root, x = xp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2226" href="#"></a></td>
<td><pre>                            xpp = (xp = x.parent) == null ? null : xp.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2227" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2228" href="#"></a></td>
<td><pre>                        if (xp != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2229" href="#"></a></td>
<td><pre>                            xp.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2230" href="#"></a></td>
<td><pre>                            if (xpp != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2231" href="#"></a></td>
<td><pre>                                xpp.red = true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2232" href="#"></a></td>
<td><pre>                                root = rotateRight(root, xpp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2233" href="#"></a></td>
<td><pre>                            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2234" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2235" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2236" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2237" href="#"></a></td>
<td><pre>                else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2238" href="#"></a></td>
<td><pre>                    if (xppl != null &amp;&amp; xppl.red) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2239" href="#"></a></td>
<td><pre>                        xppl.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2240" href="#"></a></td>
<td><pre>                        xp.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2241" href="#"></a></td>
<td><pre>                        xpp.red = true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2242" href="#"></a></td>
<td><pre>                        x = xpp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2243" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2244" href="#"></a></td>
<td><pre>                    else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2245" href="#"></a></td>
<td><pre>                        if (x == xp.left) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2246" href="#"></a></td>
<td><pre>                            root = rotateRight(root, x = xp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2247" href="#"></a></td>
<td><pre>                            xpp = (xp = x.parent) == null ? null : xp.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2248" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2249" href="#"></a></td>
<td><pre>                        if (xp != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2250" href="#"></a></td>
<td><pre>                            xp.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2251" href="#"></a></td>
<td><pre>                            if (xpp != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2252" href="#"></a></td>
<td><pre>                                xpp.red = true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2253" href="#"></a></td>
<td><pre>                                root = rotateLeft(root, xpp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2254" href="#"></a></td>
<td><pre>                            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2255" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2256" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2257" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2258" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2259" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2260" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2261" href="#"></a></td>
<td><pre>        static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2262" href="#"></a></td>
<td><pre>                                                   TreeNode&lt;K,V&gt; x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2263" href="#"></a></td>
<td><pre>            for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2264" href="#"></a></td>
<td><pre>                if (x == null || x == root)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2265" href="#"></a></td>
<td><pre>                    return root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2266" href="#"></a></td>
<td><pre>                else if ((xp = x.parent) == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2267" href="#"></a></td>
<td><pre>                    x.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2268" href="#"></a></td>
<td><pre>                    return x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2269" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2270" href="#"></a></td>
<td><pre>                else if (x.red) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2271" href="#"></a></td>
<td><pre>                    x.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2272" href="#"></a></td>
<td><pre>                    return root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2273" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2274" href="#"></a></td>
<td><pre>                else if ((xpl = xp.left) == x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2275" href="#"></a></td>
<td><pre>                    if ((xpr = xp.right) != null &amp;&amp; xpr.red) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2276" href="#"></a></td>
<td><pre>                        xpr.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2277" href="#"></a></td>
<td><pre>                        xp.red = true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2278" href="#"></a></td>
<td><pre>                        root = rotateLeft(root, xp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2279" href="#"></a></td>
<td><pre>                        xpr = (xp = x.parent) == null ? null : xp.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2280" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2281" href="#"></a></td>
<td><pre>                    if (xpr == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2282" href="#"></a></td>
<td><pre>                        x = xp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2283" href="#"></a></td>
<td><pre>                    else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2284" href="#"></a></td>
<td><pre>                        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2285" href="#"></a></td>
<td><pre>                        if ((sr == null || !sr.red) &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2286" href="#"></a></td>
<td><pre>                            (sl == null || !sl.red)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2287" href="#"></a></td>
<td><pre>                            xpr.red = true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2288" href="#"></a></td>
<td><pre>                            x = xp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2289" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2290" href="#"></a></td>
<td><pre>                        else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2291" href="#"></a></td>
<td><pre>                            if (sr == null || !sr.red) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2292" href="#"></a></td>
<td><pre>                                if (sl != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2293" href="#"></a></td>
<td><pre>                                    sl.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2294" href="#"></a></td>
<td><pre>                                xpr.red = true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2295" href="#"></a></td>
<td><pre>                                root = rotateRight(root, xpr);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2296" href="#"></a></td>
<td><pre>                                xpr = (xp = x.parent) == null ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2297" href="#"></a></td>
<td><pre>                                    null : xp.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2298" href="#"></a></td>
<td><pre>                            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2299" href="#"></a></td>
<td><pre>                            if (xpr != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2300" href="#"></a></td>
<td><pre>                                xpr.red = (xp == null) ? false : xp.red;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2301" href="#"></a></td>
<td><pre>                                if ((sr = xpr.right) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2302" href="#"></a></td>
<td><pre>                                    sr.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2303" href="#"></a></td>
<td><pre>                            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2304" href="#"></a></td>
<td><pre>                            if (xp != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2305" href="#"></a></td>
<td><pre>                                xp.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2306" href="#"></a></td>
<td><pre>                                root = rotateLeft(root, xp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2307" href="#"></a></td>
<td><pre>                            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2308" href="#"></a></td>
<td><pre>                            x = root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2309" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2310" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2311" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2312" href="#"></a></td>
<td><pre>                else { // symmetric</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2313" href="#"></a></td>
<td><pre>                    if (xpl != null &amp;&amp; xpl.red) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2314" href="#"></a></td>
<td><pre>                        xpl.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2315" href="#"></a></td>
<td><pre>                        xp.red = true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2316" href="#"></a></td>
<td><pre>                        root = rotateRight(root, xp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2317" href="#"></a></td>
<td><pre>                        xpl = (xp = x.parent) == null ? null : xp.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2318" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2319" href="#"></a></td>
<td><pre>                    if (xpl == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2320" href="#"></a></td>
<td><pre>                        x = xp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2321" href="#"></a></td>
<td><pre>                    else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2322" href="#"></a></td>
<td><pre>                        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2323" href="#"></a></td>
<td><pre>                        if ((sl == null || !sl.red) &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2324" href="#"></a></td>
<td><pre>                            (sr == null || !sr.red)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2325" href="#"></a></td>
<td><pre>                            xpl.red = true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2326" href="#"></a></td>
<td><pre>                            x = xp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2327" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2328" href="#"></a></td>
<td><pre>                        else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2329" href="#"></a></td>
<td><pre>                            if (sl == null || !sl.red) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2330" href="#"></a></td>
<td><pre>                                if (sr != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2331" href="#"></a></td>
<td><pre>                                    sr.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2332" href="#"></a></td>
<td><pre>                                xpl.red = true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2333" href="#"></a></td>
<td><pre>                                root = rotateLeft(root, xpl);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2334" href="#"></a></td>
<td><pre>                                xpl = (xp = x.parent) == null ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2335" href="#"></a></td>
<td><pre>                                    null : xp.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2336" href="#"></a></td>
<td><pre>                            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2337" href="#"></a></td>
<td><pre>                            if (xpl != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2338" href="#"></a></td>
<td><pre>                                xpl.red = (xp == null) ? false : xp.red;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2339" href="#"></a></td>
<td><pre>                                if ((sl = xpl.left) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2340" href="#"></a></td>
<td><pre>                                    sl.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2341" href="#"></a></td>
<td><pre>                            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2342" href="#"></a></td>
<td><pre>                            if (xp != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2343" href="#"></a></td>
<td><pre>                                xp.red = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2344" href="#"></a></td>
<td><pre>                                root = rotateRight(root, xp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2345" href="#"></a></td>
<td><pre>                            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2346" href="#"></a></td>
<td><pre>                            x = root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2347" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2348" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2349" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2350" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2351" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2352" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2353" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2354" href="#"></a></td>
<td><pre>         * Recursive invariant check</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2355" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2356" href="#"></a></td>
<td><pre>        static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2357" href="#"></a></td>
<td><pre>            TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2358" href="#"></a></td>
<td><pre>                tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2359" href="#"></a></td>
<td><pre>            if (tb != null &amp;&amp; tb.next != t)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2360" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2361" href="#"></a></td>
<td><pre>            if (tn != null &amp;&amp; tn.prev != t)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2362" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2363" href="#"></a></td>
<td><pre>            if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2364" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2365" href="#"></a></td>
<td><pre>            if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2366" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2367" href="#"></a></td>
<td><pre>            if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2368" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2369" href="#"></a></td>
<td><pre>            if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2370" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2371" href="#"></a></td>
<td><pre>            if (tl != null &amp;&amp; !checkInvariants(tl))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2372" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2373" href="#"></a></td>
<td><pre>            if (tr != null &amp;&amp; !checkInvariants(tr))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2374" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2375" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2376" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2377" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2378" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2379" href="#"></a></td>
<td><pre>}</pre></td>
</tr>
</table>
</body>
</html>
