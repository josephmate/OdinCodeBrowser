<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/OdinCodeBrowser/css/styles.css"/>
    </head>
<body>
<table>
<tr>
<td><a class="linenum-cell" data-linenum="1" href="#"></a></td>
<td><pre>/*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2" href="#"></a></td>
<td><pre> * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3" href="#"></a></td>
<td><pre> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5" href="#"></a></td>
<td><pre> * This code is free software; you can redistribute it and/or modify it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="6" href="#"></a></td>
<td><pre> * under the terms of the GNU General Public License version 2 only, as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="7" href="#"></a></td>
<td><pre> * published by the Free Software Foundation.  Oracle designates this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="8" href="#"></a></td>
<td><pre> * particular file as subject to the &quot;Classpath&quot; exception as provided</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="9" href="#"></a></td>
<td><pre> * by Oracle in the LICENSE file that accompanied this code.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="10" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="11" href="#"></a></td>
<td><pre> * This code is distributed in the hope that it will be useful, but WITHOUT</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="12" href="#"></a></td>
<td><pre> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="13" href="#"></a></td>
<td><pre> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="14" href="#"></a></td>
<td><pre> * version 2 for more details (a copy is included in the LICENSE file that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="15" href="#"></a></td>
<td><pre> * accompanied this code).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="16" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="17" href="#"></a></td>
<td><pre> * You should have received a copy of the GNU General Public License version</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="18" href="#"></a></td>
<td><pre> * 2 along with this work; if not, write to the Free Software Foundation,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="19" href="#"></a></td>
<td><pre> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="20" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="21" href="#"></a></td>
<td><pre> * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="22" href="#"></a></td>
<td><pre> * or visit www.oracle.com if you need additional information or have any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="23" href="#"></a></td>
<td><pre> * questions.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="24" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="25" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="26" href="#"></a></td>
<td><pre>package java.util;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="27" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="28" href="#"></a></td>
<td><pre>import java.io.Serializable;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="29" href="#"></a></td>
<td><pre>import java.util.function.BiConsumer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="30" href="#"></a></td>
<td><pre>import java.util.function.BiFunction;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="31" href="#"></a></td>
<td><pre>import java.util.function.Consumer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="32" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="33" href="#"></a></td>
<td><pre>/**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="34" href="#"></a></td>
<td><pre> * A Red-Black tree based {@link NavigableMap} implementation.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="35" href="#"></a></td>
<td><pre> * The map is sorted according to the {@linkplain Comparable natural</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="36" href="#"></a></td>
<td><pre> * ordering} of its keys, or by a {@link Comparator} provided at map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="37" href="#"></a></td>
<td><pre> * creation time, depending on which constructor is used.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="38" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="39" href="#"></a></td>
<td><pre> * &lt;p&gt;This implementation provides guaranteed log(n) time cost for the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="40" href="#"></a></td>
<td><pre> * {@code containsKey}, {@code get}, {@code put} and {@code remove}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="41" href="#"></a></td>
<td><pre> * operations.  Algorithms are adaptations of those in Cormen, Leiserson, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="42" href="#"></a></td>
<td><pre> * Rivest's &lt;em&gt;Introduction to Algorithms&lt;/em&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="43" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="44" href="#"></a></td>
<td><pre> * &lt;p&gt;Note that the ordering maintained by a tree map, like any sorted map, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="45" href="#"></a></td>
<td><pre> * whether or not an explicit comparator is provided, must be &lt;em&gt;consistent</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="46" href="#"></a></td>
<td><pre> * with {@code equals}&lt;/em&gt; if this sorted map is to correctly implement the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="47" href="#"></a></td>
<td><pre> * {@code Map} interface.  (See {@code Comparable} or {@code Comparator} for a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="48" href="#"></a></td>
<td><pre> * precise definition of &lt;em&gt;consistent with equals&lt;/em&gt;.)  This is so because</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="49" href="#"></a></td>
<td><pre> * the {@code Map} interface is defined in terms of the {@code equals}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="50" href="#"></a></td>
<td><pre> * operation, but a sorted map performs all key comparisons using its {@code</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="51" href="#"></a></td>
<td><pre> * compareTo} (or {@code compare}) method, so two keys that are deemed equal by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="52" href="#"></a></td>
<td><pre> * this method are, from the standpoint of the sorted map, equal.  The behavior</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="53" href="#"></a></td>
<td><pre> * of a sorted map &lt;em&gt;is&lt;/em&gt; well-defined even if its ordering is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="54" href="#"></a></td>
<td><pre> * inconsistent with {@code equals}; it just fails to obey the general contract</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="55" href="#"></a></td>
<td><pre> * of the {@code Map} interface.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="56" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="57" href="#"></a></td>
<td><pre> * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="58" href="#"></a></td>
<td><pre> * If multiple threads access a map concurrently, and at least one of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="59" href="#"></a></td>
<td><pre> * threads modifies the map structurally, it &lt;em&gt;must&lt;/em&gt; be synchronized</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="60" href="#"></a></td>
<td><pre> * externally.  (A structural modification is any operation that adds or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="61" href="#"></a></td>
<td><pre> * deletes one or more mappings; merely changing the value associated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="62" href="#"></a></td>
<td><pre> * with an existing key is not a structural modification.)  This is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="63" href="#"></a></td>
<td><pre> * typically accomplished by synchronizing on some object that naturally</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="64" href="#"></a></td>
<td><pre> * encapsulates the map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="65" href="#"></a></td>
<td><pre> * If no such object exists, the map should be &quot;wrapped&quot; using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="66" href="#"></a></td>
<td><pre> * {@link Collections#synchronizedSortedMap Collections.synchronizedSortedMap}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="67" href="#"></a></td>
<td><pre> * method.  This is best done at creation time, to prevent accidental</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="68" href="#"></a></td>
<td><pre> * unsynchronized access to the map: &lt;pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="69" href="#"></a></td>
<td><pre> *   SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));&lt;/pre&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="70" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="71" href="#"></a></td>
<td><pre> * &lt;p&gt;The iterators returned by the {@code iterator} method of the collections</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="72" href="#"></a></td>
<td><pre> * returned by all of this class's &quot;collection view methods&quot; are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="73" href="#"></a></td>
<td><pre> * &lt;em&gt;fail-fast&lt;/em&gt;: if the map is structurally modified at any time after</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="74" href="#"></a></td>
<td><pre> * the iterator is created, in any way except through the iterator's own</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="75" href="#"></a></td>
<td><pre> * {@code remove} method, the iterator will throw a {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="76" href="#"></a></td>
<td><pre> * ConcurrentModificationException}.  Thus, in the face of concurrent</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="77" href="#"></a></td>
<td><pre> * modification, the iterator fails quickly and cleanly, rather than risking</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="78" href="#"></a></td>
<td><pre> * arbitrary, non-deterministic behavior at an undetermined time in the future.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="79" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="80" href="#"></a></td>
<td><pre> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="81" href="#"></a></td>
<td><pre> * as it is, generally speaking, impossible to make any hard guarantees in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="82" href="#"></a></td>
<td><pre> * presence of unsynchronized concurrent modification.  Fail-fast iterators</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="83" href="#"></a></td>
<td><pre> * throw {@code ConcurrentModificationException} on a best-effort basis.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="84" href="#"></a></td>
<td><pre> * Therefore, it would be wrong to write a program that depended on this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="85" href="#"></a></td>
<td><pre> * exception for its correctness:   &lt;em&gt;the fail-fast behavior of iterators</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="86" href="#"></a></td>
<td><pre> * should be used only to detect bugs.&lt;/em&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="87" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="88" href="#"></a></td>
<td><pre> * &lt;p&gt;All {@code Map.Entry} pairs returned by methods in this class</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="89" href="#"></a></td>
<td><pre> * and its views represent snapshots of mappings at the time they were</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="90" href="#"></a></td>
<td><pre> * produced. They do &lt;strong&gt;not&lt;/strong&gt; support the {@code Entry.setValue}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="91" href="#"></a></td>
<td><pre> * method. (Note however that it is possible to change mappings in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="92" href="#"></a></td>
<td><pre> * associated map using {@code put}.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="93" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="94" href="#"></a></td>
<td><pre> * &lt;p&gt;This class is a member of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="95" href="#"></a></td>
<td><pre> * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="96" href="#"></a></td>
<td><pre> * Java Collections Framework&lt;/a&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="97" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="98" href="#"></a></td>
<td><pre> * @param &lt;K&gt; the type of keys maintained by this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="99" href="#"></a></td>
<td><pre> * @param &lt;V&gt; the type of mapped values</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="100" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="101" href="#"></a></td>
<td><pre> * @author  Josh Bloch and Doug Lea</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="102" href="#"></a></td>
<td><pre> * @see Map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="103" href="#"></a></td>
<td><pre> * @see HashMap</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="104" href="#"></a></td>
<td><pre> * @see Hashtable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="105" href="#"></a></td>
<td><pre> * @see Comparable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="106" href="#"></a></td>
<td><pre> * @see Comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="107" href="#"></a></td>
<td><pre> * @see Collection</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="108" href="#"></a></td>
<td><pre> * @since 1.2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="109" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="110" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="111" href="#"></a></td>
<td><pre>public class TreeMap&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="112" href="#"></a></td>
<td><pre>    extends AbstractMap&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="113" href="#"></a></td>
<td><pre>    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="114" href="#"></a></td>
<td><pre>{</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="115" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="116" href="#"></a></td>
<td><pre>     * The comparator used to maintain order in this tree map, or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="117" href="#"></a></td>
<td><pre>     * null if it uses the natural ordering of its keys.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="118" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="119" href="#"></a></td>
<td><pre>     * @serial</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="120" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="121" href="#"></a></td>
<td><pre>    private final Comparator&lt;? super K&gt; comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="122" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="123" href="#"></a></td>
<td><pre>    private transient Entry&lt;K,V&gt; root = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="124" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="125" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="126" href="#"></a></td>
<td><pre>     * The number of entries in the tree</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="127" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="128" href="#"></a></td>
<td><pre>    private transient int size = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="129" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="130" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="131" href="#"></a></td>
<td><pre>     * The number of structural modifications to the tree.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="132" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="133" href="#"></a></td>
<td><pre>    private transient int modCount = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="134" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="135" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="136" href="#"></a></td>
<td><pre>     * Constructs a new, empty tree map, using the natural ordering of its</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="137" href="#"></a></td>
<td><pre>     * keys.  All keys inserted into the map must implement the {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="138" href="#"></a></td>
<td><pre>     * Comparable} interface.  Furthermore, all such keys must be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="139" href="#"></a></td>
<td><pre>     * &lt;em&gt;mutually comparable&lt;/em&gt;: {@code k1.compareTo(k2)} must not throw</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="140" href="#"></a></td>
<td><pre>     * a {@code ClassCastException} for any keys {@code k1} and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="141" href="#"></a></td>
<td><pre>     * {@code k2} in the map.  If the user attempts to put a key into the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="142" href="#"></a></td>
<td><pre>     * map that violates this constraint (for example, the user attempts to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="143" href="#"></a></td>
<td><pre>     * put a string key into a map whose keys are integers), the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="144" href="#"></a></td>
<td><pre>     * {@code put(Object key, Object value)} call will throw a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="145" href="#"></a></td>
<td><pre>     * {@code ClassCastException}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="146" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="147" href="#"></a></td>
<td><pre>    public TreeMap() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="148" href="#"></a></td>
<td><pre>        comparator = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="149" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="150" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="151" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="152" href="#"></a></td>
<td><pre>     * Constructs a new, empty tree map, ordered according to the given</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="153" href="#"></a></td>
<td><pre>     * comparator.  All keys inserted into the map must be &lt;em&gt;mutually</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="154" href="#"></a></td>
<td><pre>     * comparable&lt;/em&gt; by the given comparator: {@code comparator.compare(k1,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="155" href="#"></a></td>
<td><pre>     * k2)} must not throw a {@code ClassCastException} for any keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="156" href="#"></a></td>
<td><pre>     * {@code k1} and {@code k2} in the map.  If the user attempts to put</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="157" href="#"></a></td>
<td><pre>     * a key into the map that violates this constraint, the {@code put(Object</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="158" href="#"></a></td>
<td><pre>     * key, Object value)} call will throw a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="159" href="#"></a></td>
<td><pre>     * {@code ClassCastException}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="160" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="161" href="#"></a></td>
<td><pre>     * @param comparator the comparator that will be used to order this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="162" href="#"></a></td>
<td><pre>     *        If {@code null}, the {@linkplain Comparable natural</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="163" href="#"></a></td>
<td><pre>     *        ordering} of the keys will be used.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="164" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="165" href="#"></a></td>
<td><pre>    public TreeMap(Comparator&lt;? super K&gt; comparator) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="166" href="#"></a></td>
<td><pre>        this.comparator = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="167" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="168" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="169" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="170" href="#"></a></td>
<td><pre>     * Constructs a new tree map containing the same mappings as the given</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="171" href="#"></a></td>
<td><pre>     * map, ordered according to the &lt;em&gt;natural ordering&lt;/em&gt; of its keys.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="172" href="#"></a></td>
<td><pre>     * All keys inserted into the new map must implement the {@link</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="173" href="#"></a></td>
<td><pre>     * Comparable} interface.  Furthermore, all such keys must be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="174" href="#"></a></td>
<td><pre>     * &lt;em&gt;mutually comparable&lt;/em&gt;: {@code k1.compareTo(k2)} must not throw</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="175" href="#"></a></td>
<td><pre>     * a {@code ClassCastException} for any keys {@code k1} and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="176" href="#"></a></td>
<td><pre>     * {@code k2} in the map.  This method runs in n*log(n) time.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="177" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="178" href="#"></a></td>
<td><pre>     * @param  m the map whose mappings are to be placed in this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="179" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the keys in m are not {@link Comparable},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="180" href="#"></a></td>
<td><pre>     *         or are not mutually comparable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="181" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified map is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="182" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="183" href="#"></a></td>
<td><pre>    public TreeMap(Map&lt;? extends K, ? extends V&gt; m) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="184" href="#"></a></td>
<td><pre>        comparator = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="185" href="#"></a></td>
<td><pre>        putAll(m);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="186" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="187" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="188" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="189" href="#"></a></td>
<td><pre>     * Constructs a new tree map containing the same mappings and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="190" href="#"></a></td>
<td><pre>     * using the same ordering as the specified sorted map.  This</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="191" href="#"></a></td>
<td><pre>     * method runs in linear time.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="192" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="193" href="#"></a></td>
<td><pre>     * @param  m the sorted map whose mappings are to be placed in this map,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="194" href="#"></a></td>
<td><pre>     *         and whose comparator is to be used to sort this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="195" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified map is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="196" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="197" href="#"></a></td>
<td><pre>    public TreeMap(SortedMap&lt;K, ? extends V&gt; m) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="198" href="#"></a></td>
<td><pre>        comparator = m.comparator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="199" href="#"></a></td>
<td><pre>        try {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="200" href="#"></a></td>
<td><pre>            buildFromSorted(m.size(), m.entrySet().iterator(), null, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="201" href="#"></a></td>
<td><pre>        } catch (java.io.IOException cannotHappen) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="202" href="#"></a></td>
<td><pre>        } catch (ClassNotFoundException cannotHappen) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="203" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="204" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="205" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="206" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="207" href="#"></a></td>
<td><pre>    // Query Operations</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="208" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="209" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="210" href="#"></a></td>
<td><pre>     * Returns the number of key-value mappings in this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="211" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="212" href="#"></a></td>
<td><pre>     * @return the number of key-value mappings in this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="213" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="214" href="#"></a></td>
<td><pre>    public int size() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="215" href="#"></a></td>
<td><pre>        return size;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="216" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="217" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="218" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="219" href="#"></a></td>
<td><pre>     * Returns {@code true} if this map contains a mapping for the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="220" href="#"></a></td>
<td><pre>     * key.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="221" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="222" href="#"></a></td>
<td><pre>     * @param key key whose presence in this map is to be tested</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="223" href="#"></a></td>
<td><pre>     * @return {@code true} if this map contains a mapping for the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="224" href="#"></a></td>
<td><pre>     *         specified key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="225" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the specified key cannot be compared</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="226" href="#"></a></td>
<td><pre>     *         with the keys currently in the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="227" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="228" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="229" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="230" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="231" href="#"></a></td>
<td><pre>    public boolean containsKey(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="232" href="#"></a></td>
<td><pre>        return getEntry(key) != null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="233" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="234" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="235" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="236" href="#"></a></td>
<td><pre>     * Returns {@code true} if this map maps one or more keys to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="237" href="#"></a></td>
<td><pre>     * specified value.  More formally, returns {@code true} if and only if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="238" href="#"></a></td>
<td><pre>     * this map contains at least one mapping to a value {@code v} such</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="239" href="#"></a></td>
<td><pre>     * that {@code (value==null ? v==null : value.equals(v))}.  This</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="240" href="#"></a></td>
<td><pre>     * operation will probably require time linear in the map size for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="241" href="#"></a></td>
<td><pre>     * most implementations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="242" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="243" href="#"></a></td>
<td><pre>     * @param value value whose presence in this map is to be tested</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="244" href="#"></a></td>
<td><pre>     * @return {@code true} if a mapping to {@code value} exists;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="245" href="#"></a></td>
<td><pre>     *         {@code false} otherwise</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="246" href="#"></a></td>
<td><pre>     * @since 1.2</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="247" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="248" href="#"></a></td>
<td><pre>    public boolean containsValue(Object value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="249" href="#"></a></td>
<td><pre>        for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="250" href="#"></a></td>
<td><pre>            if (valEquals(value, e.value))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="251" href="#"></a></td>
<td><pre>                return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="252" href="#"></a></td>
<td><pre>        return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="253" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="254" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="255" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="256" href="#"></a></td>
<td><pre>     * Returns the value to which the specified key is mapped,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="257" href="#"></a></td>
<td><pre>     * or {@code null} if this map contains no mapping for the key.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="258" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="259" href="#"></a></td>
<td><pre>     * &lt;p&gt;More formally, if this map contains a mapping from a key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="260" href="#"></a></td>
<td><pre>     * {@code k} to a value {@code v} such that {@code key} compares</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="261" href="#"></a></td>
<td><pre>     * equal to {@code k} according to the map's ordering, then this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="262" href="#"></a></td>
<td><pre>     * method returns {@code v}; otherwise it returns {@code null}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="263" href="#"></a></td>
<td><pre>     * (There can be at most one such mapping.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="264" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="265" href="#"></a></td>
<td><pre>     * &lt;p&gt;A return value of {@code null} does not &lt;em&gt;necessarily&lt;/em&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="266" href="#"></a></td>
<td><pre>     * indicate that the map contains no mapping for the key; it's also</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="267" href="#"></a></td>
<td><pre>     * possible that the map explicitly maps the key to {@code null}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="268" href="#"></a></td>
<td><pre>     * The {@link #containsKey containsKey} operation may be used to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="269" href="#"></a></td>
<td><pre>     * distinguish these two cases.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="270" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="271" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the specified key cannot be compared</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="272" href="#"></a></td>
<td><pre>     *         with the keys currently in the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="273" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="274" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="275" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="276" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="277" href="#"></a></td>
<td><pre>    public V get(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="278" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; p = getEntry(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="279" href="#"></a></td>
<td><pre>        return (p==null ? null : p.value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="280" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="281" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="282" href="#"></a></td>
<td><pre>    public Comparator&lt;? super K&gt; comparator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="283" href="#"></a></td>
<td><pre>        return comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="284" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="285" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="286" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="287" href="#"></a></td>
<td><pre>     * @throws NoSuchElementException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="288" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="289" href="#"></a></td>
<td><pre>    public K firstKey() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="290" href="#"></a></td>
<td><pre>        return key(getFirstEntry());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="291" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="292" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="293" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="294" href="#"></a></td>
<td><pre>     * @throws NoSuchElementException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="295" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="296" href="#"></a></td>
<td><pre>    public K lastKey() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="297" href="#"></a></td>
<td><pre>        return key(getLastEntry());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="298" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="299" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="300" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="301" href="#"></a></td>
<td><pre>     * Copies all of the mappings from the specified map to this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="302" href="#"></a></td>
<td><pre>     * These mappings replace any mappings that this map had for any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="303" href="#"></a></td>
<td><pre>     * of the keys currently in the specified map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="304" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="305" href="#"></a></td>
<td><pre>     * @param  map mappings to be stored in this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="306" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the class of a key or value in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="307" href="#"></a></td>
<td><pre>     *         the specified map prevents it from being stored in this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="308" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified map is null or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="309" href="#"></a></td>
<td><pre>     *         the specified map contains a null key and this map does not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="310" href="#"></a></td>
<td><pre>     *         permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="311" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="312" href="#"></a></td>
<td><pre>    public void putAll(Map&lt;? extends K, ? extends V&gt; map) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="313" href="#"></a></td>
<td><pre>        int mapSize = map.size();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="314" href="#"></a></td>
<td><pre>        if (size==0 &amp;&amp; mapSize!=0 &amp;&amp; map instanceof SortedMap) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="315" href="#"></a></td>
<td><pre>            Comparator&lt;?&gt; c = ((SortedMap&lt;?,?&gt;)map).comparator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="316" href="#"></a></td>
<td><pre>            if (c == comparator || (c != null &amp;&amp; c.equals(comparator))) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="317" href="#"></a></td>
<td><pre>                ++modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="318" href="#"></a></td>
<td><pre>                try {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="319" href="#"></a></td>
<td><pre>                    buildFromSorted(mapSize, map.entrySet().iterator(),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="320" href="#"></a></td>
<td><pre>                                    null, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="321" href="#"></a></td>
<td><pre>                } catch (java.io.IOException cannotHappen) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="322" href="#"></a></td>
<td><pre>                } catch (ClassNotFoundException cannotHappen) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="323" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="324" href="#"></a></td>
<td><pre>                return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="325" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="326" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="327" href="#"></a></td>
<td><pre>        super.putAll(map);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="328" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="329" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="330" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="331" href="#"></a></td>
<td><pre>     * Returns this map's entry for the given key, or {@code null} if the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="332" href="#"></a></td>
<td><pre>     * does not contain an entry for the key.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="333" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="334" href="#"></a></td>
<td><pre>     * @return this map's entry for the given key, or {@code null} if the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="335" href="#"></a></td>
<td><pre>     *         does not contain an entry for the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="336" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the specified key cannot be compared</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="337" href="#"></a></td>
<td><pre>     *         with the keys currently in the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="338" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="339" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="340" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="341" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="342" href="#"></a></td>
<td><pre>    final Entry&lt;K,V&gt; getEntry(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="343" href="#"></a></td>
<td><pre>        // Offload comparator-based version for sake of performance</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="344" href="#"></a></td>
<td><pre>        if (comparator != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="345" href="#"></a></td>
<td><pre>            return getEntryUsingComparator(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="346" href="#"></a></td>
<td><pre>        if (key == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="347" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="348" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="349" href="#"></a></td>
<td><pre>            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="350" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; p = root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="351" href="#"></a></td>
<td><pre>        while (p != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="352" href="#"></a></td>
<td><pre>            int cmp = k.compareTo(p.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="353" href="#"></a></td>
<td><pre>            if (cmp &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="354" href="#"></a></td>
<td><pre>                p = p.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="355" href="#"></a></td>
<td><pre>            else if (cmp &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="356" href="#"></a></td>
<td><pre>                p = p.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="357" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="358" href="#"></a></td>
<td><pre>                return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="359" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="360" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="361" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="362" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="363" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="364" href="#"></a></td>
<td><pre>     * Version of getEntry using comparator. Split off from getEntry</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="365" href="#"></a></td>
<td><pre>     * for performance. (This is not worth doing for most methods,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="366" href="#"></a></td>
<td><pre>     * that are less dependent on comparator performance, but is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="367" href="#"></a></td>
<td><pre>     * worthwhile here.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="368" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="369" href="#"></a></td>
<td><pre>    final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="370" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="371" href="#"></a></td>
<td><pre>            K k = (K) key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="372" href="#"></a></td>
<td><pre>        Comparator&lt;? super K&gt; cpr = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="373" href="#"></a></td>
<td><pre>        if (cpr != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="374" href="#"></a></td>
<td><pre>            Entry&lt;K,V&gt; p = root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="375" href="#"></a></td>
<td><pre>            while (p != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="376" href="#"></a></td>
<td><pre>                int cmp = cpr.compare(k, p.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="377" href="#"></a></td>
<td><pre>                if (cmp &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="378" href="#"></a></td>
<td><pre>                    p = p.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="379" href="#"></a></td>
<td><pre>                else if (cmp &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="380" href="#"></a></td>
<td><pre>                    p = p.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="381" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="382" href="#"></a></td>
<td><pre>                    return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="383" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="384" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="385" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="386" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="387" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="388" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="389" href="#"></a></td>
<td><pre>     * Gets the entry corresponding to the specified key; if no such entry</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="390" href="#"></a></td>
<td><pre>     * exists, returns the entry for the least key greater than the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="391" href="#"></a></td>
<td><pre>     * key; if no such entry exists (i.e., the greatest key in the Tree is less</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="392" href="#"></a></td>
<td><pre>     * than the specified key), returns {@code null}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="393" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="394" href="#"></a></td>
<td><pre>    final Entry&lt;K,V&gt; getCeilingEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="395" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; p = root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="396" href="#"></a></td>
<td><pre>        while (p != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="397" href="#"></a></td>
<td><pre>            int cmp = compare(key, p.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="398" href="#"></a></td>
<td><pre>            if (cmp &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="399" href="#"></a></td>
<td><pre>                if (p.left != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="400" href="#"></a></td>
<td><pre>                    p = p.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="401" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="402" href="#"></a></td>
<td><pre>                    return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="403" href="#"></a></td>
<td><pre>            } else if (cmp &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="404" href="#"></a></td>
<td><pre>                if (p.right != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="405" href="#"></a></td>
<td><pre>                    p = p.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="406" href="#"></a></td>
<td><pre>                } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="407" href="#"></a></td>
<td><pre>                    Entry&lt;K,V&gt; parent = p.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="408" href="#"></a></td>
<td><pre>                    Entry&lt;K,V&gt; ch = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="409" href="#"></a></td>
<td><pre>                    while (parent != null &amp;&amp; ch == parent.right) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="410" href="#"></a></td>
<td><pre>                        ch = parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="411" href="#"></a></td>
<td><pre>                        parent = parent.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="412" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="413" href="#"></a></td>
<td><pre>                    return parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="414" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="415" href="#"></a></td>
<td><pre>            } else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="416" href="#"></a></td>
<td><pre>                return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="417" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="418" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="419" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="420" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="421" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="422" href="#"></a></td>
<td><pre>     * Gets the entry corresponding to the specified key; if no such entry</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="423" href="#"></a></td>
<td><pre>     * exists, returns the entry for the greatest key less than the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="424" href="#"></a></td>
<td><pre>     * key; if no such entry exists, returns {@code null}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="425" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="426" href="#"></a></td>
<td><pre>    final Entry&lt;K,V&gt; getFloorEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="427" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; p = root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="428" href="#"></a></td>
<td><pre>        while (p != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="429" href="#"></a></td>
<td><pre>            int cmp = compare(key, p.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="430" href="#"></a></td>
<td><pre>            if (cmp &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="431" href="#"></a></td>
<td><pre>                if (p.right != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="432" href="#"></a></td>
<td><pre>                    p = p.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="433" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="434" href="#"></a></td>
<td><pre>                    return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="435" href="#"></a></td>
<td><pre>            } else if (cmp &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="436" href="#"></a></td>
<td><pre>                if (p.left != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="437" href="#"></a></td>
<td><pre>                    p = p.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="438" href="#"></a></td>
<td><pre>                } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="439" href="#"></a></td>
<td><pre>                    Entry&lt;K,V&gt; parent = p.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="440" href="#"></a></td>
<td><pre>                    Entry&lt;K,V&gt; ch = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="441" href="#"></a></td>
<td><pre>                    while (parent != null &amp;&amp; ch == parent.left) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="442" href="#"></a></td>
<td><pre>                        ch = parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="443" href="#"></a></td>
<td><pre>                        parent = parent.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="444" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="445" href="#"></a></td>
<td><pre>                    return parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="446" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="447" href="#"></a></td>
<td><pre>            } else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="448" href="#"></a></td>
<td><pre>                return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="449" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="450" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="451" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="452" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="453" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="454" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="455" href="#"></a></td>
<td><pre>     * Gets the entry for the least key greater than the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="456" href="#"></a></td>
<td><pre>     * key; if no such entry exists, returns the entry for the least</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="457" href="#"></a></td>
<td><pre>     * key greater than the specified key; if no such entry exists</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="458" href="#"></a></td>
<td><pre>     * returns {@code null}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="459" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="460" href="#"></a></td>
<td><pre>    final Entry&lt;K,V&gt; getHigherEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="461" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; p = root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="462" href="#"></a></td>
<td><pre>        while (p != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="463" href="#"></a></td>
<td><pre>            int cmp = compare(key, p.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="464" href="#"></a></td>
<td><pre>            if (cmp &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="465" href="#"></a></td>
<td><pre>                if (p.left != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="466" href="#"></a></td>
<td><pre>                    p = p.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="467" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="468" href="#"></a></td>
<td><pre>                    return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="469" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="470" href="#"></a></td>
<td><pre>                if (p.right != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="471" href="#"></a></td>
<td><pre>                    p = p.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="472" href="#"></a></td>
<td><pre>                } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="473" href="#"></a></td>
<td><pre>                    Entry&lt;K,V&gt; parent = p.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="474" href="#"></a></td>
<td><pre>                    Entry&lt;K,V&gt; ch = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="475" href="#"></a></td>
<td><pre>                    while (parent != null &amp;&amp; ch == parent.right) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="476" href="#"></a></td>
<td><pre>                        ch = parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="477" href="#"></a></td>
<td><pre>                        parent = parent.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="478" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="479" href="#"></a></td>
<td><pre>                    return parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="480" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="481" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="482" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="483" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="484" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="485" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="486" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="487" href="#"></a></td>
<td><pre>     * Returns the entry for the greatest key less than the specified key; if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="488" href="#"></a></td>
<td><pre>     * no such entry exists (i.e., the least key in the Tree is greater than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="489" href="#"></a></td>
<td><pre>     * the specified key), returns {@code null}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="490" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="491" href="#"></a></td>
<td><pre>    final Entry&lt;K,V&gt; getLowerEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="492" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; p = root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="493" href="#"></a></td>
<td><pre>        while (p != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="494" href="#"></a></td>
<td><pre>            int cmp = compare(key, p.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="495" href="#"></a></td>
<td><pre>            if (cmp &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="496" href="#"></a></td>
<td><pre>                if (p.right != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="497" href="#"></a></td>
<td><pre>                    p = p.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="498" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="499" href="#"></a></td>
<td><pre>                    return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="500" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="501" href="#"></a></td>
<td><pre>                if (p.left != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="502" href="#"></a></td>
<td><pre>                    p = p.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="503" href="#"></a></td>
<td><pre>                } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="504" href="#"></a></td>
<td><pre>                    Entry&lt;K,V&gt; parent = p.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="505" href="#"></a></td>
<td><pre>                    Entry&lt;K,V&gt; ch = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="506" href="#"></a></td>
<td><pre>                    while (parent != null &amp;&amp; ch == parent.left) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="507" href="#"></a></td>
<td><pre>                        ch = parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="508" href="#"></a></td>
<td><pre>                        parent = parent.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="509" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="510" href="#"></a></td>
<td><pre>                    return parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="511" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="512" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="513" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="514" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="515" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="516" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="517" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="518" href="#"></a></td>
<td><pre>     * Associates the specified value with the specified key in this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="519" href="#"></a></td>
<td><pre>     * If the map previously contained a mapping for the key, the old</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="520" href="#"></a></td>
<td><pre>     * value is replaced.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="521" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="522" href="#"></a></td>
<td><pre>     * @param key key with which the specified value is to be associated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="523" href="#"></a></td>
<td><pre>     * @param value value to be associated with the specified key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="524" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="525" href="#"></a></td>
<td><pre>     * @return the previous value associated with {@code key}, or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="526" href="#"></a></td>
<td><pre>     *         {@code null} if there was no mapping for {@code key}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="527" href="#"></a></td>
<td><pre>     *         (A {@code null} return can also indicate that the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="528" href="#"></a></td>
<td><pre>     *         previously associated {@code null} with {@code key}.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="529" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the specified key cannot be compared</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="530" href="#"></a></td>
<td><pre>     *         with the keys currently in the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="531" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="532" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="533" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="534" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="535" href="#"></a></td>
<td><pre>    public V put(K key, V value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="536" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; t = root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="537" href="#"></a></td>
<td><pre>        if (t == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="538" href="#"></a></td>
<td><pre>            compare(key, key); // type (and possibly null) check</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="539" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="540" href="#"></a></td>
<td><pre>            root = new Entry&lt;&gt;(key, value, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="541" href="#"></a></td>
<td><pre>            size = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="542" href="#"></a></td>
<td><pre>            modCount++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="543" href="#"></a></td>
<td><pre>            return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="544" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="545" href="#"></a></td>
<td><pre>        int cmp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="546" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="547" href="#"></a></td>
<td><pre>        // split comparator and comparable paths</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="548" href="#"></a></td>
<td><pre>        Comparator&lt;? super K&gt; cpr = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="549" href="#"></a></td>
<td><pre>        if (cpr != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="550" href="#"></a></td>
<td><pre>            do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="551" href="#"></a></td>
<td><pre>                parent = t;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="552" href="#"></a></td>
<td><pre>                cmp = cpr.compare(key, t.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="553" href="#"></a></td>
<td><pre>                if (cmp &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="554" href="#"></a></td>
<td><pre>                    t = t.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="555" href="#"></a></td>
<td><pre>                else if (cmp &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="556" href="#"></a></td>
<td><pre>                    t = t.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="557" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="558" href="#"></a></td>
<td><pre>                    return t.setValue(value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="559" href="#"></a></td>
<td><pre>            } while (t != null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="560" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="561" href="#"></a></td>
<td><pre>        else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="562" href="#"></a></td>
<td><pre>            if (key == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="563" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="564" href="#"></a></td>
<td><pre>            @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="565" href="#"></a></td>
<td><pre>                Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="566" href="#"></a></td>
<td><pre>            do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="567" href="#"></a></td>
<td><pre>                parent = t;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="568" href="#"></a></td>
<td><pre>                cmp = k.compareTo(t.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="569" href="#"></a></td>
<td><pre>                if (cmp &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="570" href="#"></a></td>
<td><pre>                    t = t.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="571" href="#"></a></td>
<td><pre>                else if (cmp &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="572" href="#"></a></td>
<td><pre>                    t = t.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="573" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="574" href="#"></a></td>
<td><pre>                    return t.setValue(value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="575" href="#"></a></td>
<td><pre>            } while (t != null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="576" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="577" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="578" href="#"></a></td>
<td><pre>        if (cmp &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="579" href="#"></a></td>
<td><pre>            parent.left = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="580" href="#"></a></td>
<td><pre>        else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="581" href="#"></a></td>
<td><pre>            parent.right = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="582" href="#"></a></td>
<td><pre>        fixAfterInsertion(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="583" href="#"></a></td>
<td><pre>        size++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="584" href="#"></a></td>
<td><pre>        modCount++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="585" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="586" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="587" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="588" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="589" href="#"></a></td>
<td><pre>     * Removes the mapping for this key from this TreeMap if present.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="590" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="591" href="#"></a></td>
<td><pre>     * @param  key key for which mapping should be removed</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="592" href="#"></a></td>
<td><pre>     * @return the previous value associated with {@code key}, or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="593" href="#"></a></td>
<td><pre>     *         {@code null} if there was no mapping for {@code key}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="594" href="#"></a></td>
<td><pre>     *         (A {@code null} return can also indicate that the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="595" href="#"></a></td>
<td><pre>     *         previously associated {@code null} with {@code key}.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="596" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the specified key cannot be compared</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="597" href="#"></a></td>
<td><pre>     *         with the keys currently in the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="598" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="599" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="600" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="601" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="602" href="#"></a></td>
<td><pre>    public V remove(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="603" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; p = getEntry(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="604" href="#"></a></td>
<td><pre>        if (p == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="605" href="#"></a></td>
<td><pre>            return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="606" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="607" href="#"></a></td>
<td><pre>        V oldValue = p.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="608" href="#"></a></td>
<td><pre>        deleteEntry(p);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="609" href="#"></a></td>
<td><pre>        return oldValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="610" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="611" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="612" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="613" href="#"></a></td>
<td><pre>     * Removes all of the mappings from this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="614" href="#"></a></td>
<td><pre>     * The map will be empty after this call returns.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="615" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="616" href="#"></a></td>
<td><pre>    public void clear() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="617" href="#"></a></td>
<td><pre>        modCount++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="618" href="#"></a></td>
<td><pre>        size = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="619" href="#"></a></td>
<td><pre>        root = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="620" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="621" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="622" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="623" href="#"></a></td>
<td><pre>     * Returns a shallow copy of this {@code TreeMap} instance. (The keys and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="624" href="#"></a></td>
<td><pre>     * values themselves are not cloned.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="625" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="626" href="#"></a></td>
<td><pre>     * @return a shallow copy of this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="627" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="628" href="#"></a></td>
<td><pre>    public Object clone() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="629" href="#"></a></td>
<td><pre>        TreeMap&lt;?,?&gt; clone;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="630" href="#"></a></td>
<td><pre>        try {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="631" href="#"></a></td>
<td><pre>            clone = (TreeMap&lt;?,?&gt;) super.clone();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="632" href="#"></a></td>
<td><pre>        } catch (CloneNotSupportedException e) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="633" href="#"></a></td>
<td><pre>            throw new InternalError(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="634" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="635" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="636" href="#"></a></td>
<td><pre>        // Put clone into &quot;virgin&quot; state (except for comparator)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="637" href="#"></a></td>
<td><pre>        clone.root = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="638" href="#"></a></td>
<td><pre>        clone.size = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="639" href="#"></a></td>
<td><pre>        clone.modCount = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="640" href="#"></a></td>
<td><pre>        clone.entrySet = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="641" href="#"></a></td>
<td><pre>        clone.navigableKeySet = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="642" href="#"></a></td>
<td><pre>        clone.descendingMap = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="643" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="644" href="#"></a></td>
<td><pre>        // Initialize clone with our mappings</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="645" href="#"></a></td>
<td><pre>        try {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="646" href="#"></a></td>
<td><pre>            clone.buildFromSorted(size, entrySet().iterator(), null, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="647" href="#"></a></td>
<td><pre>        } catch (java.io.IOException cannotHappen) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="648" href="#"></a></td>
<td><pre>        } catch (ClassNotFoundException cannotHappen) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="649" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="650" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="651" href="#"></a></td>
<td><pre>        return clone;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="652" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="653" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="654" href="#"></a></td>
<td><pre>    // NavigableMap API methods</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="655" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="656" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="657" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="658" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="659" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; firstEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="660" href="#"></a></td>
<td><pre>        return exportEntry(getFirstEntry());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="661" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="662" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="663" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="664" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="665" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="666" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; lastEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="667" href="#"></a></td>
<td><pre>        return exportEntry(getLastEntry());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="668" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="669" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="670" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="671" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="672" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="673" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; pollFirstEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="674" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; p = getFirstEntry();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="675" href="#"></a></td>
<td><pre>        Map.Entry&lt;K,V&gt; result = exportEntry(p);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="676" href="#"></a></td>
<td><pre>        if (p != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="677" href="#"></a></td>
<td><pre>            deleteEntry(p);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="678" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="679" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="680" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="681" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="682" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="683" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="684" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; pollLastEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="685" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; p = getLastEntry();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="686" href="#"></a></td>
<td><pre>        Map.Entry&lt;K,V&gt; result = exportEntry(p);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="687" href="#"></a></td>
<td><pre>        if (p != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="688" href="#"></a></td>
<td><pre>            deleteEntry(p);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="689" href="#"></a></td>
<td><pre>        return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="690" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="691" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="692" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="693" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="694" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="695" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="696" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="697" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="698" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="699" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; lowerEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="700" href="#"></a></td>
<td><pre>        return exportEntry(getLowerEntry(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="701" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="702" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="703" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="704" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="705" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="706" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="707" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="708" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="709" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="710" href="#"></a></td>
<td><pre>    public K lowerKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="711" href="#"></a></td>
<td><pre>        return keyOrNull(getLowerEntry(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="712" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="713" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="714" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="715" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="716" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="717" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="718" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="719" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="720" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="721" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; floorEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="722" href="#"></a></td>
<td><pre>        return exportEntry(getFloorEntry(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="723" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="724" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="725" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="726" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="727" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="728" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="729" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="730" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="731" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="732" href="#"></a></td>
<td><pre>    public K floorKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="733" href="#"></a></td>
<td><pre>        return keyOrNull(getFloorEntry(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="734" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="735" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="736" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="737" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="738" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="739" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="740" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="741" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="742" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="743" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; ceilingEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="744" href="#"></a></td>
<td><pre>        return exportEntry(getCeilingEntry(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="745" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="746" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="747" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="748" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="749" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="750" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="751" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="752" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="753" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="754" href="#"></a></td>
<td><pre>    public K ceilingKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="755" href="#"></a></td>
<td><pre>        return keyOrNull(getCeilingEntry(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="756" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="757" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="758" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="759" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="760" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="761" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="762" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="763" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="764" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="765" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; higherEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="766" href="#"></a></td>
<td><pre>        return exportEntry(getHigherEntry(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="767" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="768" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="769" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="770" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="771" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="772" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="773" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="774" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="775" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="776" href="#"></a></td>
<td><pre>    public K higherKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="777" href="#"></a></td>
<td><pre>        return keyOrNull(getHigherEntry(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="778" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="779" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="780" href="#"></a></td>
<td><pre>    // Views</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="781" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="782" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="783" href="#"></a></td>
<td><pre>     * Fields initialized to contain an instance of the entry set view</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="784" href="#"></a></td>
<td><pre>     * the first time this view is requested.  Views are stateless, so</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="785" href="#"></a></td>
<td><pre>     * there's no reason to create more than one.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="786" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="787" href="#"></a></td>
<td><pre>    private transient EntrySet entrySet = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="788" href="#"></a></td>
<td><pre>    private transient KeySet&lt;K&gt; navigableKeySet = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="789" href="#"></a></td>
<td><pre>    private transient NavigableMap&lt;K,V&gt; descendingMap = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="790" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="791" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="792" href="#"></a></td>
<td><pre>     * Returns a {@link Set} view of the keys contained in this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="793" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="794" href="#"></a></td>
<td><pre>     * &lt;p&gt;The set's iterator returns the keys in ascending order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="795" href="#"></a></td>
<td><pre>     * The set's spliterator is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="796" href="#"></a></td>
<td><pre>     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="797" href="#"></a></td>
<td><pre>     * &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports {@link Spliterator#SORTED}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="798" href="#"></a></td>
<td><pre>     * and {@link Spliterator#ORDERED} with an encounter order that is ascending</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="799" href="#"></a></td>
<td><pre>     * key order.  The spliterator's comparator (see</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="800" href="#"></a></td>
<td><pre>     * {@link java.util.Spliterator#getComparator()}) is {@code null} if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="801" href="#"></a></td>
<td><pre>     * the tree map's comparator (see {@link #comparator()}) is {@code null}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="802" href="#"></a></td>
<td><pre>     * Otherwise, the spliterator's comparator is the same as or imposes the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="803" href="#"></a></td>
<td><pre>     * same total ordering as the tree map's comparator.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="804" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="805" href="#"></a></td>
<td><pre>     * &lt;p&gt;The set is backed by the map, so changes to the map are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="806" href="#"></a></td>
<td><pre>     * reflected in the set, and vice-versa.  If the map is modified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="807" href="#"></a></td>
<td><pre>     * while an iteration over the set is in progress (except through</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="808" href="#"></a></td>
<td><pre>     * the iterator's own {@code remove} operation), the results of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="809" href="#"></a></td>
<td><pre>     * the iteration are undefined.  The set supports element removal,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="810" href="#"></a></td>
<td><pre>     * which removes the corresponding mapping from the map, via the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="811" href="#"></a></td>
<td><pre>     * {@code Iterator.remove}, {@code Set.remove},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="812" href="#"></a></td>
<td><pre>     * {@code removeAll}, {@code retainAll}, and {@code clear}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="813" href="#"></a></td>
<td><pre>     * operations.  It does not support the {@code add} or {@code addAll}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="814" href="#"></a></td>
<td><pre>     * operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="815" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="816" href="#"></a></td>
<td><pre>    public Set&lt;K&gt; keySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="817" href="#"></a></td>
<td><pre>        return navigableKeySet();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="818" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="819" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="820" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="821" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="822" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="823" href="#"></a></td>
<td><pre>    public NavigableSet&lt;K&gt; navigableKeySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="824" href="#"></a></td>
<td><pre>        KeySet&lt;K&gt; nks = navigableKeySet;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="825" href="#"></a></td>
<td><pre>        return (nks != null) ? nks : (navigableKeySet = new KeySet&lt;&gt;(this));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="826" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="827" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="828" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="829" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="830" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="831" href="#"></a></td>
<td><pre>    public NavigableSet&lt;K&gt; descendingKeySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="832" href="#"></a></td>
<td><pre>        return descendingMap().navigableKeySet();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="833" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="834" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="835" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="836" href="#"></a></td>
<td><pre>     * Returns a {@link Collection} view of the values contained in this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="837" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="838" href="#"></a></td>
<td><pre>     * &lt;p&gt;The collection's iterator returns the values in ascending order</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="839" href="#"></a></td>
<td><pre>     * of the corresponding keys. The collection's spliterator is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="840" href="#"></a></td>
<td><pre>     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="841" href="#"></a></td>
<td><pre>     * &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports {@link Spliterator#ORDERED}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="842" href="#"></a></td>
<td><pre>     * with an encounter order that is ascending order of the corresponding</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="843" href="#"></a></td>
<td><pre>     * keys.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="844" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="845" href="#"></a></td>
<td><pre>     * &lt;p&gt;The collection is backed by the map, so changes to the map are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="846" href="#"></a></td>
<td><pre>     * reflected in the collection, and vice-versa.  If the map is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="847" href="#"></a></td>
<td><pre>     * modified while an iteration over the collection is in progress</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="848" href="#"></a></td>
<td><pre>     * (except through the iterator's own {@code remove} operation),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="849" href="#"></a></td>
<td><pre>     * the results of the iteration are undefined.  The collection</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="850" href="#"></a></td>
<td><pre>     * supports element removal, which removes the corresponding</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="851" href="#"></a></td>
<td><pre>     * mapping from the map, via the {@code Iterator.remove},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="852" href="#"></a></td>
<td><pre>     * {@code Collection.remove}, {@code removeAll},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="853" href="#"></a></td>
<td><pre>     * {@code retainAll} and {@code clear} operations.  It does not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="854" href="#"></a></td>
<td><pre>     * support the {@code add} or {@code addAll} operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="855" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="856" href="#"></a></td>
<td><pre>    public Collection&lt;V&gt; values() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="857" href="#"></a></td>
<td><pre>        Collection&lt;V&gt; vs = values;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="858" href="#"></a></td>
<td><pre>        return (vs != null) ? vs : (values = new Values());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="859" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="860" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="861" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="862" href="#"></a></td>
<td><pre>     * Returns a {@link Set} view of the mappings contained in this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="863" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="864" href="#"></a></td>
<td><pre>     * &lt;p&gt;The set's iterator returns the entries in ascending key order. The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="865" href="#"></a></td>
<td><pre>     * sets's spliterator is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="866" href="#"></a></td>
<td><pre>     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="867" href="#"></a></td>
<td><pre>     * &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports {@link Spliterator#SORTED} and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="868" href="#"></a></td>
<td><pre>     * {@link Spliterator#ORDERED} with an encounter order that is ascending key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="869" href="#"></a></td>
<td><pre>     * order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="870" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="871" href="#"></a></td>
<td><pre>     * &lt;p&gt;The set is backed by the map, so changes to the map are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="872" href="#"></a></td>
<td><pre>     * reflected in the set, and vice-versa.  If the map is modified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="873" href="#"></a></td>
<td><pre>     * while an iteration over the set is in progress (except through</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="874" href="#"></a></td>
<td><pre>     * the iterator's own {@code remove} operation, or through the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="875" href="#"></a></td>
<td><pre>     * {@code setValue} operation on a map entry returned by the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="876" href="#"></a></td>
<td><pre>     * iterator) the results of the iteration are undefined.  The set</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="877" href="#"></a></td>
<td><pre>     * supports element removal, which removes the corresponding</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="878" href="#"></a></td>
<td><pre>     * mapping from the map, via the {@code Iterator.remove},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="879" href="#"></a></td>
<td><pre>     * {@code Set.remove}, {@code removeAll}, {@code retainAll} and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="880" href="#"></a></td>
<td><pre>     * {@code clear} operations.  It does not support the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="881" href="#"></a></td>
<td><pre>     * {@code add} or {@code addAll} operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="882" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="883" href="#"></a></td>
<td><pre>    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="884" href="#"></a></td>
<td><pre>        EntrySet es = entrySet;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="885" href="#"></a></td>
<td><pre>        return (es != null) ? es : (entrySet = new EntrySet());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="886" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="887" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="888" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="889" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="890" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="891" href="#"></a></td>
<td><pre>    public NavigableMap&lt;K, V&gt; descendingMap() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="892" href="#"></a></td>
<td><pre>        NavigableMap&lt;K, V&gt; km = descendingMap;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="893" href="#"></a></td>
<td><pre>        return (km != null) ? km :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="894" href="#"></a></td>
<td><pre>            (descendingMap = new DescendingSubMap&lt;&gt;(this,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="895" href="#"></a></td>
<td><pre>                                                    true, null, true,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="896" href="#"></a></td>
<td><pre>                                                    true, null, true));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="897" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="898" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="899" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="900" href="#"></a></td>
<td><pre>     * @throws ClassCastException       {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="901" href="#"></a></td>
<td><pre>     * @throws NullPointerException if {@code fromKey} or {@code toKey} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="902" href="#"></a></td>
<td><pre>     *         null and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="903" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="904" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="905" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="906" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="907" href="#"></a></td>
<td><pre>    public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="908" href="#"></a></td>
<td><pre>                                    K toKey,   boolean toInclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="909" href="#"></a></td>
<td><pre>        return new AscendingSubMap&lt;&gt;(this,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="910" href="#"></a></td>
<td><pre>                                     false, fromKey, fromInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="911" href="#"></a></td>
<td><pre>                                     false, toKey,   toInclusive);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="912" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="913" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="914" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="915" href="#"></a></td>
<td><pre>     * @throws ClassCastException       {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="916" href="#"></a></td>
<td><pre>     * @throws NullPointerException if {@code toKey} is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="917" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="918" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="919" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="920" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="921" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="922" href="#"></a></td>
<td><pre>    public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="923" href="#"></a></td>
<td><pre>        return new AscendingSubMap&lt;&gt;(this,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="924" href="#"></a></td>
<td><pre>                                     true,  null,  true,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="925" href="#"></a></td>
<td><pre>                                     false, toKey, inclusive);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="926" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="927" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="928" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="929" href="#"></a></td>
<td><pre>     * @throws ClassCastException       {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="930" href="#"></a></td>
<td><pre>     * @throws NullPointerException if {@code fromKey} is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="931" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="932" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="933" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="934" href="#"></a></td>
<td><pre>     * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="935" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="936" href="#"></a></td>
<td><pre>    public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="937" href="#"></a></td>
<td><pre>        return new AscendingSubMap&lt;&gt;(this,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="938" href="#"></a></td>
<td><pre>                                     false, fromKey, inclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="939" href="#"></a></td>
<td><pre>                                     true,  null,    true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="940" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="941" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="942" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="943" href="#"></a></td>
<td><pre>     * @throws ClassCastException       {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="944" href="#"></a></td>
<td><pre>     * @throws NullPointerException if {@code fromKey} or {@code toKey} is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="945" href="#"></a></td>
<td><pre>     *         null and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="946" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="947" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="948" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="949" href="#"></a></td>
<td><pre>    public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="950" href="#"></a></td>
<td><pre>        return subMap(fromKey, true, toKey, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="951" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="952" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="953" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="954" href="#"></a></td>
<td><pre>     * @throws ClassCastException       {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="955" href="#"></a></td>
<td><pre>     * @throws NullPointerException if {@code toKey} is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="956" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="957" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="958" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="959" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="960" href="#"></a></td>
<td><pre>    public SortedMap&lt;K,V&gt; headMap(K toKey) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="961" href="#"></a></td>
<td><pre>        return headMap(toKey, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="962" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="963" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="964" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="965" href="#"></a></td>
<td><pre>     * @throws ClassCastException       {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="966" href="#"></a></td>
<td><pre>     * @throws NullPointerException if {@code fromKey} is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="967" href="#"></a></td>
<td><pre>     *         and this map uses natural ordering, or its comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="968" href="#"></a></td>
<td><pre>     *         does not permit null keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="969" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="970" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="971" href="#"></a></td>
<td><pre>    public SortedMap&lt;K,V&gt; tailMap(K fromKey) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="972" href="#"></a></td>
<td><pre>        return tailMap(fromKey, true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="973" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="974" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="975" href="#"></a></td>
<td><pre>    @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="976" href="#"></a></td>
<td><pre>    public boolean replace(K key, V oldValue, V newValue) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="977" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; p = getEntry(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="978" href="#"></a></td>
<td><pre>        if (p!=null &amp;&amp; Objects.equals(oldValue, p.value)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="979" href="#"></a></td>
<td><pre>            p.value = newValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="980" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="981" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="982" href="#"></a></td>
<td><pre>        return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="983" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="984" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="985" href="#"></a></td>
<td><pre>    @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="986" href="#"></a></td>
<td><pre>    public V replace(K key, V value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="987" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; p = getEntry(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="988" href="#"></a></td>
<td><pre>        if (p!=null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="989" href="#"></a></td>
<td><pre>            V oldValue = p.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="990" href="#"></a></td>
<td><pre>            p.value = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="991" href="#"></a></td>
<td><pre>            return oldValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="992" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="993" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="994" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="995" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="996" href="#"></a></td>
<td><pre>    @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="997" href="#"></a></td>
<td><pre>    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="998" href="#"></a></td>
<td><pre>        Objects.requireNonNull(action);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="999" href="#"></a></td>
<td><pre>        int expectedModCount = modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1000" href="#"></a></td>
<td><pre>        for (Entry&lt;K, V&gt; e = getFirstEntry(); e != null; e = successor(e)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1001" href="#"></a></td>
<td><pre>            action.accept(e.key, e.value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1002" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1003" href="#"></a></td>
<td><pre>            if (expectedModCount != modCount) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1004" href="#"></a></td>
<td><pre>                throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1005" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1006" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1007" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1008" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1009" href="#"></a></td>
<td><pre>    @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1010" href="#"></a></td>
<td><pre>    public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1011" href="#"></a></td>
<td><pre>        Objects.requireNonNull(function);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1012" href="#"></a></td>
<td><pre>        int expectedModCount = modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1013" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1014" href="#"></a></td>
<td><pre>        for (Entry&lt;K, V&gt; e = getFirstEntry(); e != null; e = successor(e)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1015" href="#"></a></td>
<td><pre>            e.value = function.apply(e.key, e.value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1016" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1017" href="#"></a></td>
<td><pre>            if (expectedModCount != modCount) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1018" href="#"></a></td>
<td><pre>                throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1019" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1020" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1021" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1022" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1023" href="#"></a></td>
<td><pre>    // View class support</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1024" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1025" href="#"></a></td>
<td><pre>    class Values extends AbstractCollection&lt;V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1026" href="#"></a></td>
<td><pre>        public Iterator&lt;V&gt; iterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1027" href="#"></a></td>
<td><pre>            return new ValueIterator(getFirstEntry());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1028" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1029" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1030" href="#"></a></td>
<td><pre>        public int size() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1031" href="#"></a></td>
<td><pre>            return TreeMap.this.size();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1032" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1033" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1034" href="#"></a></td>
<td><pre>        public boolean contains(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1035" href="#"></a></td>
<td><pre>            return TreeMap.this.containsValue(o);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1036" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1037" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1038" href="#"></a></td>
<td><pre>        public boolean remove(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1039" href="#"></a></td>
<td><pre>            for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1040" href="#"></a></td>
<td><pre>                if (valEquals(e.getValue(), o)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1041" href="#"></a></td>
<td><pre>                    deleteEntry(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1042" href="#"></a></td>
<td><pre>                    return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1043" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1044" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1045" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1046" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1047" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1048" href="#"></a></td>
<td><pre>        public void clear() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1049" href="#"></a></td>
<td><pre>            TreeMap.this.clear();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1050" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1051" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1052" href="#"></a></td>
<td><pre>        public Spliterator&lt;V&gt; spliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1053" href="#"></a></td>
<td><pre>            return new ValueSpliterator&lt;K,V&gt;(TreeMap.this, null, null, 0, -1, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1054" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1055" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1056" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1057" href="#"></a></td>
<td><pre>    class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1058" href="#"></a></td>
<td><pre>        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1059" href="#"></a></td>
<td><pre>            return new EntryIterator(getFirstEntry());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1060" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1061" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1062" href="#"></a></td>
<td><pre>        public boolean contains(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1063" href="#"></a></td>
<td><pre>            if (!(o instanceof Map.Entry))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1064" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1065" href="#"></a></td>
<td><pre>            Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;) o;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1066" href="#"></a></td>
<td><pre>            Object value = entry.getValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1067" href="#"></a></td>
<td><pre>            Entry&lt;K,V&gt; p = getEntry(entry.getKey());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1068" href="#"></a></td>
<td><pre>            return p != null &amp;&amp; valEquals(p.getValue(), value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1069" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1070" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1071" href="#"></a></td>
<td><pre>        public boolean remove(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1072" href="#"></a></td>
<td><pre>            if (!(o instanceof Map.Entry))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1073" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1074" href="#"></a></td>
<td><pre>            Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;) o;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1075" href="#"></a></td>
<td><pre>            Object value = entry.getValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1076" href="#"></a></td>
<td><pre>            Entry&lt;K,V&gt; p = getEntry(entry.getKey());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1077" href="#"></a></td>
<td><pre>            if (p != null &amp;&amp; valEquals(p.getValue(), value)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1078" href="#"></a></td>
<td><pre>                deleteEntry(p);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1079" href="#"></a></td>
<td><pre>                return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1080" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1081" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1082" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1083" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1084" href="#"></a></td>
<td><pre>        public int size() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1085" href="#"></a></td>
<td><pre>            return TreeMap.this.size();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1086" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1087" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1088" href="#"></a></td>
<td><pre>        public void clear() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1089" href="#"></a></td>
<td><pre>            TreeMap.this.clear();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1090" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1091" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1092" href="#"></a></td>
<td><pre>        public Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1093" href="#"></a></td>
<td><pre>            return new EntrySpliterator&lt;K,V&gt;(TreeMap.this, null, null, 0, -1, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1094" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1095" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1096" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1097" href="#"></a></td>
<td><pre>    /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1098" href="#"></a></td>
<td><pre>     * Unlike Values and EntrySet, the KeySet class is static,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1099" href="#"></a></td>
<td><pre>     * delegating to a NavigableMap to allow use by SubMaps, which</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1100" href="#"></a></td>
<td><pre>     * outweighs the ugliness of needing type-tests for the following</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1101" href="#"></a></td>
<td><pre>     * Iterator methods that are defined appropriately in main versus</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1102" href="#"></a></td>
<td><pre>     * submap classes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1103" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1104" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1105" href="#"></a></td>
<td><pre>    Iterator&lt;K&gt; keyIterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1106" href="#"></a></td>
<td><pre>        return new KeyIterator(getFirstEntry());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1107" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1108" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1109" href="#"></a></td>
<td><pre>    Iterator&lt;K&gt; descendingKeyIterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1110" href="#"></a></td>
<td><pre>        return new DescendingKeyIterator(getLastEntry());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1111" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1112" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1113" href="#"></a></td>
<td><pre>    static final class KeySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1114" href="#"></a></td>
<td><pre>        private final NavigableMap&lt;E, ?&gt; m;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1115" href="#"></a></td>
<td><pre>        KeySet(NavigableMap&lt;E,?&gt; map) { m = map; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1116" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1117" href="#"></a></td>
<td><pre>        public Iterator&lt;E&gt; iterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1118" href="#"></a></td>
<td><pre>            if (m instanceof TreeMap)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1119" href="#"></a></td>
<td><pre>                return ((TreeMap&lt;E,?&gt;)m).keyIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1120" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1121" href="#"></a></td>
<td><pre>                return ((TreeMap.NavigableSubMap&lt;E,?&gt;)m).keyIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1122" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1123" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1124" href="#"></a></td>
<td><pre>        public Iterator&lt;E&gt; descendingIterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1125" href="#"></a></td>
<td><pre>            if (m instanceof TreeMap)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1126" href="#"></a></td>
<td><pre>                return ((TreeMap&lt;E,?&gt;)m).descendingKeyIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1127" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1128" href="#"></a></td>
<td><pre>                return ((TreeMap.NavigableSubMap&lt;E,?&gt;)m).descendingKeyIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1129" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1130" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1131" href="#"></a></td>
<td><pre>        public int size() { return m.size(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1132" href="#"></a></td>
<td><pre>        public boolean isEmpty() { return m.isEmpty(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1133" href="#"></a></td>
<td><pre>        public boolean contains(Object o) { return m.containsKey(o); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1134" href="#"></a></td>
<td><pre>        public void clear() { m.clear(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1135" href="#"></a></td>
<td><pre>        public E lower(E e) { return m.lowerKey(e); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1136" href="#"></a></td>
<td><pre>        public E floor(E e) { return m.floorKey(e); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1137" href="#"></a></td>
<td><pre>        public E ceiling(E e) { return m.ceilingKey(e); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1138" href="#"></a></td>
<td><pre>        public E higher(E e) { return m.higherKey(e); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1139" href="#"></a></td>
<td><pre>        public E first() { return m.firstKey(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1140" href="#"></a></td>
<td><pre>        public E last() { return m.lastKey(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1141" href="#"></a></td>
<td><pre>        public Comparator&lt;? super E&gt; comparator() { return m.comparator(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1142" href="#"></a></td>
<td><pre>        public E pollFirst() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1143" href="#"></a></td>
<td><pre>            Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1144" href="#"></a></td>
<td><pre>            return (e == null) ? null : e.getKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1145" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1146" href="#"></a></td>
<td><pre>        public E pollLast() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1147" href="#"></a></td>
<td><pre>            Map.Entry&lt;E,?&gt; e = m.pollLastEntry();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1148" href="#"></a></td>
<td><pre>            return (e == null) ? null : e.getKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1149" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1150" href="#"></a></td>
<td><pre>        public boolean remove(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1151" href="#"></a></td>
<td><pre>            int oldSize = size();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1152" href="#"></a></td>
<td><pre>            m.remove(o);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1153" href="#"></a></td>
<td><pre>            return size() != oldSize;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1154" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1155" href="#"></a></td>
<td><pre>        public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1156" href="#"></a></td>
<td><pre>                                      E toElement,   boolean toInclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1157" href="#"></a></td>
<td><pre>            return new KeySet&lt;&gt;(m.subMap(fromElement, fromInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1158" href="#"></a></td>
<td><pre>                                          toElement,   toInclusive));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1159" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1160" href="#"></a></td>
<td><pre>        public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1161" href="#"></a></td>
<td><pre>            return new KeySet&lt;&gt;(m.headMap(toElement, inclusive));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1162" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1163" href="#"></a></td>
<td><pre>        public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1164" href="#"></a></td>
<td><pre>            return new KeySet&lt;&gt;(m.tailMap(fromElement, inclusive));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1165" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1166" href="#"></a></td>
<td><pre>        public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1167" href="#"></a></td>
<td><pre>            return subSet(fromElement, true, toElement, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1168" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1169" href="#"></a></td>
<td><pre>        public SortedSet&lt;E&gt; headSet(E toElement) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1170" href="#"></a></td>
<td><pre>            return headSet(toElement, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1171" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1172" href="#"></a></td>
<td><pre>        public SortedSet&lt;E&gt; tailSet(E fromElement) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1173" href="#"></a></td>
<td><pre>            return tailSet(fromElement, true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1174" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1175" href="#"></a></td>
<td><pre>        public NavigableSet&lt;E&gt; descendingSet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1176" href="#"></a></td>
<td><pre>            return new KeySet&lt;&gt;(m.descendingMap());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1177" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1178" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1179" href="#"></a></td>
<td><pre>        public Spliterator&lt;E&gt; spliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1180" href="#"></a></td>
<td><pre>            return keySpliteratorFor(m);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1181" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1182" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1183" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1184" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1185" href="#"></a></td>
<td><pre>     * Base class for TreeMap Iterators</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1186" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1187" href="#"></a></td>
<td><pre>    abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1188" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1189" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; lastReturned;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1190" href="#"></a></td>
<td><pre>        int expectedModCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1191" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1192" href="#"></a></td>
<td><pre>        PrivateEntryIterator(Entry&lt;K,V&gt; first) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1193" href="#"></a></td>
<td><pre>            expectedModCount = modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1194" href="#"></a></td>
<td><pre>            lastReturned = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1195" href="#"></a></td>
<td><pre>            next = first;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1196" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1197" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1198" href="#"></a></td>
<td><pre>        public final boolean hasNext() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1199" href="#"></a></td>
<td><pre>            return next != null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1200" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1201" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1202" href="#"></a></td>
<td><pre>        final Entry&lt;K,V&gt; nextEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1203" href="#"></a></td>
<td><pre>            Entry&lt;K,V&gt; e = next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1204" href="#"></a></td>
<td><pre>            if (e == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1205" href="#"></a></td>
<td><pre>                throw new NoSuchElementException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1206" href="#"></a></td>
<td><pre>            if (modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1207" href="#"></a></td>
<td><pre>                throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1208" href="#"></a></td>
<td><pre>            next = successor(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1209" href="#"></a></td>
<td><pre>            lastReturned = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1210" href="#"></a></td>
<td><pre>            return e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1211" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1212" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1213" href="#"></a></td>
<td><pre>        final Entry&lt;K,V&gt; prevEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1214" href="#"></a></td>
<td><pre>            Entry&lt;K,V&gt; e = next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1215" href="#"></a></td>
<td><pre>            if (e == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1216" href="#"></a></td>
<td><pre>                throw new NoSuchElementException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1217" href="#"></a></td>
<td><pre>            if (modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1218" href="#"></a></td>
<td><pre>                throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1219" href="#"></a></td>
<td><pre>            next = predecessor(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1220" href="#"></a></td>
<td><pre>            lastReturned = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1221" href="#"></a></td>
<td><pre>            return e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1222" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1223" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1224" href="#"></a></td>
<td><pre>        public void remove() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1225" href="#"></a></td>
<td><pre>            if (lastReturned == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1226" href="#"></a></td>
<td><pre>                throw new IllegalStateException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1227" href="#"></a></td>
<td><pre>            if (modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1228" href="#"></a></td>
<td><pre>                throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1229" href="#"></a></td>
<td><pre>            // deleted entries are replaced by their successors</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1230" href="#"></a></td>
<td><pre>            if (lastReturned.left != null &amp;&amp; lastReturned.right != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1231" href="#"></a></td>
<td><pre>                next = lastReturned;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1232" href="#"></a></td>
<td><pre>            deleteEntry(lastReturned);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1233" href="#"></a></td>
<td><pre>            expectedModCount = modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1234" href="#"></a></td>
<td><pre>            lastReturned = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1235" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1236" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1237" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1238" href="#"></a></td>
<td><pre>    final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1239" href="#"></a></td>
<td><pre>        EntryIterator(Entry&lt;K,V&gt; first) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1240" href="#"></a></td>
<td><pre>            super(first);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1241" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1242" href="#"></a></td>
<td><pre>        public Map.Entry&lt;K,V&gt; next() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1243" href="#"></a></td>
<td><pre>            return nextEntry();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1244" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1245" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1246" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1247" href="#"></a></td>
<td><pre>    final class ValueIterator extends PrivateEntryIterator&lt;V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1248" href="#"></a></td>
<td><pre>        ValueIterator(Entry&lt;K,V&gt; first) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1249" href="#"></a></td>
<td><pre>            super(first);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1250" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1251" href="#"></a></td>
<td><pre>        public V next() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1252" href="#"></a></td>
<td><pre>            return nextEntry().value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1253" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1254" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1255" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1256" href="#"></a></td>
<td><pre>    final class KeyIterator extends PrivateEntryIterator&lt;K&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1257" href="#"></a></td>
<td><pre>        KeyIterator(Entry&lt;K,V&gt; first) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1258" href="#"></a></td>
<td><pre>            super(first);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1259" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1260" href="#"></a></td>
<td><pre>        public K next() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1261" href="#"></a></td>
<td><pre>            return nextEntry().key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1262" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1263" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1264" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1265" href="#"></a></td>
<td><pre>    final class DescendingKeyIterator extends PrivateEntryIterator&lt;K&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1266" href="#"></a></td>
<td><pre>        DescendingKeyIterator(Entry&lt;K,V&gt; first) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1267" href="#"></a></td>
<td><pre>            super(first);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1268" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1269" href="#"></a></td>
<td><pre>        public K next() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1270" href="#"></a></td>
<td><pre>            return prevEntry().key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1271" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1272" href="#"></a></td>
<td><pre>        public void remove() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1273" href="#"></a></td>
<td><pre>            if (lastReturned == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1274" href="#"></a></td>
<td><pre>                throw new IllegalStateException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1275" href="#"></a></td>
<td><pre>            if (modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1276" href="#"></a></td>
<td><pre>                throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1277" href="#"></a></td>
<td><pre>            deleteEntry(lastReturned);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1278" href="#"></a></td>
<td><pre>            lastReturned = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1279" href="#"></a></td>
<td><pre>            expectedModCount = modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1280" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1281" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1282" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1283" href="#"></a></td>
<td><pre>    // Little utilities</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1284" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1285" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1286" href="#"></a></td>
<td><pre>     * Compares two keys using the correct comparison method for this TreeMap.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1287" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1288" href="#"></a></td>
<td><pre>    @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1289" href="#"></a></td>
<td><pre>    final int compare(Object k1, Object k2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1290" href="#"></a></td>
<td><pre>        return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1291" href="#"></a></td>
<td><pre>            : comparator.compare((K)k1, (K)k2);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1292" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1293" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1294" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1295" href="#"></a></td>
<td><pre>     * Test two values for equality.  Differs from o1.equals(o2) only in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1296" href="#"></a></td>
<td><pre>     * that it copes with {@code null} o1 properly.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1297" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1298" href="#"></a></td>
<td><pre>    static final boolean valEquals(Object o1, Object o2) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1299" href="#"></a></td>
<td><pre>        return (o1==null ? o2==null : o1.equals(o2));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1300" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1301" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1302" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1303" href="#"></a></td>
<td><pre>     * Return SimpleImmutableEntry for entry, or null if null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1304" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1305" href="#"></a></td>
<td><pre>    static &lt;K,V&gt; Map.Entry&lt;K,V&gt; exportEntry(TreeMap.Entry&lt;K,V&gt; e) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1306" href="#"></a></td>
<td><pre>        return (e == null) ? null :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1307" href="#"></a></td>
<td><pre>            new AbstractMap.SimpleImmutableEntry&lt;&gt;(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1308" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1309" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1310" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1311" href="#"></a></td>
<td><pre>     * Return key for entry, or null if null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1312" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1313" href="#"></a></td>
<td><pre>    static &lt;K,V&gt; K keyOrNull(TreeMap.Entry&lt;K,V&gt; e) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1314" href="#"></a></td>
<td><pre>        return (e == null) ? null : e.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1315" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1316" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1317" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1318" href="#"></a></td>
<td><pre>     * Returns the key corresponding to the specified Entry.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1319" href="#"></a></td>
<td><pre>     * @throws NoSuchElementException if the Entry is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1320" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1321" href="#"></a></td>
<td><pre>    static &lt;K&gt; K key(Entry&lt;K,?&gt; e) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1322" href="#"></a></td>
<td><pre>        if (e==null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1323" href="#"></a></td>
<td><pre>            throw new NoSuchElementException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1324" href="#"></a></td>
<td><pre>        return e.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1325" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1326" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1327" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1328" href="#"></a></td>
<td><pre>    // SubMaps</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1329" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1330" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1331" href="#"></a></td>
<td><pre>     * Dummy value serving as unmatchable fence key for unbounded</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1332" href="#"></a></td>
<td><pre>     * SubMapIterators</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1333" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1334" href="#"></a></td>
<td><pre>    private static final Object UNBOUNDED = new Object();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1335" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1336" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1337" href="#"></a></td>
<td><pre>     * @serial include</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1338" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1339" href="#"></a></td>
<td><pre>    abstract static class NavigableSubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1340" href="#"></a></td>
<td><pre>        implements NavigableMap&lt;K,V&gt;, java.io.Serializable {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1341" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1342" href="#"></a></td>
<td><pre>         * The backing map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1343" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1344" href="#"></a></td>
<td><pre>        final TreeMap&lt;K,V&gt; m;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1345" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1346" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1347" href="#"></a></td>
<td><pre>         * Endpoints are represented as triples (fromStart, lo,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1348" href="#"></a></td>
<td><pre>         * loInclusive) and (toEnd, hi, hiInclusive). If fromStart is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1349" href="#"></a></td>
<td><pre>         * true, then the low (absolute) bound is the start of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1350" href="#"></a></td>
<td><pre>         * backing map, and the other values are ignored. Otherwise,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1351" href="#"></a></td>
<td><pre>         * if loInclusive is true, lo is the inclusive bound, else lo</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1352" href="#"></a></td>
<td><pre>         * is the exclusive bound. Similarly for the upper bound.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1353" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1354" href="#"></a></td>
<td><pre>        final K lo, hi;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1355" href="#"></a></td>
<td><pre>        final boolean fromStart, toEnd;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1356" href="#"></a></td>
<td><pre>        final boolean loInclusive, hiInclusive;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1357" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1358" href="#"></a></td>
<td><pre>        NavigableSubMap(TreeMap&lt;K,V&gt; m,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1359" href="#"></a></td>
<td><pre>                        boolean fromStart, K lo, boolean loInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1360" href="#"></a></td>
<td><pre>                        boolean toEnd,     K hi, boolean hiInclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1361" href="#"></a></td>
<td><pre>            if (!fromStart &amp;&amp; !toEnd) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1362" href="#"></a></td>
<td><pre>                if (m.compare(lo, hi) &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1363" href="#"></a></td>
<td><pre>                    throw new IllegalArgumentException(&quot;fromKey &gt; toKey&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1364" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1365" href="#"></a></td>
<td><pre>                if (!fromStart) // type check</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1366" href="#"></a></td>
<td><pre>                    m.compare(lo, lo);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1367" href="#"></a></td>
<td><pre>                if (!toEnd)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1368" href="#"></a></td>
<td><pre>                    m.compare(hi, hi);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1369" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1370" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1371" href="#"></a></td>
<td><pre>            this.m = m;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1372" href="#"></a></td>
<td><pre>            this.fromStart = fromStart;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1373" href="#"></a></td>
<td><pre>            this.lo = lo;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1374" href="#"></a></td>
<td><pre>            this.loInclusive = loInclusive;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1375" href="#"></a></td>
<td><pre>            this.toEnd = toEnd;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1376" href="#"></a></td>
<td><pre>            this.hi = hi;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1377" href="#"></a></td>
<td><pre>            this.hiInclusive = hiInclusive;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1378" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1379" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1380" href="#"></a></td>
<td><pre>        // internal utilities</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1381" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1382" href="#"></a></td>
<td><pre>        final boolean tooLow(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1383" href="#"></a></td>
<td><pre>            if (!fromStart) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1384" href="#"></a></td>
<td><pre>                int c = m.compare(key, lo);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1385" href="#"></a></td>
<td><pre>                if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1386" href="#"></a></td>
<td><pre>                    return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1387" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1388" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1389" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1390" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1391" href="#"></a></td>
<td><pre>        final boolean tooHigh(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1392" href="#"></a></td>
<td><pre>            if (!toEnd) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1393" href="#"></a></td>
<td><pre>                int c = m.compare(key, hi);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1394" href="#"></a></td>
<td><pre>                if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1395" href="#"></a></td>
<td><pre>                    return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1396" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1397" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1398" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1399" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1400" href="#"></a></td>
<td><pre>        final boolean inRange(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1401" href="#"></a></td>
<td><pre>            return !tooLow(key) &amp;&amp; !tooHigh(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1402" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1403" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1404" href="#"></a></td>
<td><pre>        final boolean inClosedRange(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1405" href="#"></a></td>
<td><pre>            return (fromStart || m.compare(key, lo) &gt;= 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1406" href="#"></a></td>
<td><pre>                &amp;&amp; (toEnd || m.compare(hi, key) &gt;= 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1407" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1408" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1409" href="#"></a></td>
<td><pre>        final boolean inRange(Object key, boolean inclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1410" href="#"></a></td>
<td><pre>            return inclusive ? inRange(key) : inClosedRange(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1411" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1412" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1413" href="#"></a></td>
<td><pre>        /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1414" href="#"></a></td>
<td><pre>         * Absolute versions of relation operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1415" href="#"></a></td>
<td><pre>         * Subclasses map to these using like-named &quot;sub&quot;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1416" href="#"></a></td>
<td><pre>         * versions that invert senses for descending maps</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1417" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1418" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1419" href="#"></a></td>
<td><pre>        final TreeMap.Entry&lt;K,V&gt; absLowest() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1420" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e =</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1421" href="#"></a></td>
<td><pre>                (fromStart ?  m.getFirstEntry() :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1422" href="#"></a></td>
<td><pre>                 (loInclusive ? m.getCeilingEntry(lo) :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1423" href="#"></a></td>
<td><pre>                                m.getHigherEntry(lo)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1424" href="#"></a></td>
<td><pre>            return (e == null || tooHigh(e.key)) ? null : e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1425" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1426" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1427" href="#"></a></td>
<td><pre>        final TreeMap.Entry&lt;K,V&gt; absHighest() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1428" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e =</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1429" href="#"></a></td>
<td><pre>                (toEnd ?  m.getLastEntry() :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1430" href="#"></a></td>
<td><pre>                 (hiInclusive ?  m.getFloorEntry(hi) :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1431" href="#"></a></td>
<td><pre>                                 m.getLowerEntry(hi)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1432" href="#"></a></td>
<td><pre>            return (e == null || tooLow(e.key)) ? null : e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1433" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1434" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1435" href="#"></a></td>
<td><pre>        final TreeMap.Entry&lt;K,V&gt; absCeiling(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1436" href="#"></a></td>
<td><pre>            if (tooLow(key))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1437" href="#"></a></td>
<td><pre>                return absLowest();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1438" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1439" href="#"></a></td>
<td><pre>            return (e == null || tooHigh(e.key)) ? null : e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1440" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1441" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1442" href="#"></a></td>
<td><pre>        final TreeMap.Entry&lt;K,V&gt; absHigher(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1443" href="#"></a></td>
<td><pre>            if (tooLow(key))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1444" href="#"></a></td>
<td><pre>                return absLowest();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1445" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1446" href="#"></a></td>
<td><pre>            return (e == null || tooHigh(e.key)) ? null : e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1447" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1448" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1449" href="#"></a></td>
<td><pre>        final TreeMap.Entry&lt;K,V&gt; absFloor(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1450" href="#"></a></td>
<td><pre>            if (tooHigh(key))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1451" href="#"></a></td>
<td><pre>                return absHighest();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1452" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1453" href="#"></a></td>
<td><pre>            return (e == null || tooLow(e.key)) ? null : e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1454" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1455" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1456" href="#"></a></td>
<td><pre>        final TreeMap.Entry&lt;K,V&gt; absLower(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1457" href="#"></a></td>
<td><pre>            if (tooHigh(key))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1458" href="#"></a></td>
<td><pre>                return absHighest();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1459" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1460" href="#"></a></td>
<td><pre>            return (e == null || tooLow(e.key)) ? null : e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1461" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1462" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1463" href="#"></a></td>
<td><pre>        /** Returns the absolute high fence for ascending traversal */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1464" href="#"></a></td>
<td><pre>        final TreeMap.Entry&lt;K,V&gt; absHighFence() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1465" href="#"></a></td>
<td><pre>            return (toEnd ? null : (hiInclusive ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1466" href="#"></a></td>
<td><pre>                                    m.getHigherEntry(hi) :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1467" href="#"></a></td>
<td><pre>                                    m.getCeilingEntry(hi)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1468" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1469" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1470" href="#"></a></td>
<td><pre>        /** Return the absolute low fence for descending traversal  */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1471" href="#"></a></td>
<td><pre>        final TreeMap.Entry&lt;K,V&gt; absLowFence() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1472" href="#"></a></td>
<td><pre>            return (fromStart ? null : (loInclusive ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1473" href="#"></a></td>
<td><pre>                                        m.getLowerEntry(lo) :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1474" href="#"></a></td>
<td><pre>                                        m.getFloorEntry(lo)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1475" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1476" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1477" href="#"></a></td>
<td><pre>        // Abstract methods defined in ascending vs descending classes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1478" href="#"></a></td>
<td><pre>        // These relay to the appropriate absolute versions</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1479" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1480" href="#"></a></td>
<td><pre>        abstract TreeMap.Entry&lt;K,V&gt; subLowest();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1481" href="#"></a></td>
<td><pre>        abstract TreeMap.Entry&lt;K,V&gt; subHighest();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1482" href="#"></a></td>
<td><pre>        abstract TreeMap.Entry&lt;K,V&gt; subCeiling(K key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1483" href="#"></a></td>
<td><pre>        abstract TreeMap.Entry&lt;K,V&gt; subHigher(K key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1484" href="#"></a></td>
<td><pre>        abstract TreeMap.Entry&lt;K,V&gt; subFloor(K key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1485" href="#"></a></td>
<td><pre>        abstract TreeMap.Entry&lt;K,V&gt; subLower(K key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1486" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1487" href="#"></a></td>
<td><pre>        /** Returns ascending iterator from the perspective of this submap */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1488" href="#"></a></td>
<td><pre>        abstract Iterator&lt;K&gt; keyIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1489" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1490" href="#"></a></td>
<td><pre>        abstract Spliterator&lt;K&gt; keySpliterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1491" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1492" href="#"></a></td>
<td><pre>        /** Returns descending iterator from the perspective of this submap */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1493" href="#"></a></td>
<td><pre>        abstract Iterator&lt;K&gt; descendingKeyIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1494" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1495" href="#"></a></td>
<td><pre>        // public methods</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1496" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1497" href="#"></a></td>
<td><pre>        public boolean isEmpty() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1498" href="#"></a></td>
<td><pre>            return (fromStart &amp;&amp; toEnd) ? m.isEmpty() : entrySet().isEmpty();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1499" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1500" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1501" href="#"></a></td>
<td><pre>        public int size() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1502" href="#"></a></td>
<td><pre>            return (fromStart &amp;&amp; toEnd) ? m.size() : entrySet().size();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1503" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1504" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1505" href="#"></a></td>
<td><pre>        public final boolean containsKey(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1506" href="#"></a></td>
<td><pre>            return inRange(key) &amp;&amp; m.containsKey(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1507" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1508" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1509" href="#"></a></td>
<td><pre>        public final V put(K key, V value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1510" href="#"></a></td>
<td><pre>            if (!inRange(key))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1511" href="#"></a></td>
<td><pre>                throw new IllegalArgumentException(&quot;key out of range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1512" href="#"></a></td>
<td><pre>            return m.put(key, value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1513" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1514" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1515" href="#"></a></td>
<td><pre>        public final V get(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1516" href="#"></a></td>
<td><pre>            return !inRange(key) ? null :  m.get(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1517" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1518" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1519" href="#"></a></td>
<td><pre>        public final V remove(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1520" href="#"></a></td>
<td><pre>            return !inRange(key) ? null : m.remove(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1521" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1522" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1523" href="#"></a></td>
<td><pre>        public final Map.Entry&lt;K,V&gt; ceilingEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1524" href="#"></a></td>
<td><pre>            return exportEntry(subCeiling(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1525" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1526" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1527" href="#"></a></td>
<td><pre>        public final K ceilingKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1528" href="#"></a></td>
<td><pre>            return keyOrNull(subCeiling(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1529" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1530" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1531" href="#"></a></td>
<td><pre>        public final Map.Entry&lt;K,V&gt; higherEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1532" href="#"></a></td>
<td><pre>            return exportEntry(subHigher(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1533" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1534" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1535" href="#"></a></td>
<td><pre>        public final K higherKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1536" href="#"></a></td>
<td><pre>            return keyOrNull(subHigher(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1537" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1538" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1539" href="#"></a></td>
<td><pre>        public final Map.Entry&lt;K,V&gt; floorEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1540" href="#"></a></td>
<td><pre>            return exportEntry(subFloor(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1541" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1542" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1543" href="#"></a></td>
<td><pre>        public final K floorKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1544" href="#"></a></td>
<td><pre>            return keyOrNull(subFloor(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1545" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1546" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1547" href="#"></a></td>
<td><pre>        public final Map.Entry&lt;K,V&gt; lowerEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1548" href="#"></a></td>
<td><pre>            return exportEntry(subLower(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1549" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1550" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1551" href="#"></a></td>
<td><pre>        public final K lowerKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1552" href="#"></a></td>
<td><pre>            return keyOrNull(subLower(key));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1553" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1554" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1555" href="#"></a></td>
<td><pre>        public final K firstKey() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1556" href="#"></a></td>
<td><pre>            return key(subLowest());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1557" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1558" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1559" href="#"></a></td>
<td><pre>        public final K lastKey() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1560" href="#"></a></td>
<td><pre>            return key(subHighest());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1561" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1562" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1563" href="#"></a></td>
<td><pre>        public final Map.Entry&lt;K,V&gt; firstEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1564" href="#"></a></td>
<td><pre>            return exportEntry(subLowest());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1565" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1566" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1567" href="#"></a></td>
<td><pre>        public final Map.Entry&lt;K,V&gt; lastEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1568" href="#"></a></td>
<td><pre>            return exportEntry(subHighest());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1569" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1570" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1571" href="#"></a></td>
<td><pre>        public final Map.Entry&lt;K,V&gt; pollFirstEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1572" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e = subLowest();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1573" href="#"></a></td>
<td><pre>            Map.Entry&lt;K,V&gt; result = exportEntry(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1574" href="#"></a></td>
<td><pre>            if (e != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1575" href="#"></a></td>
<td><pre>                m.deleteEntry(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1576" href="#"></a></td>
<td><pre>            return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1577" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1578" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1579" href="#"></a></td>
<td><pre>        public final Map.Entry&lt;K,V&gt; pollLastEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1580" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e = subHighest();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1581" href="#"></a></td>
<td><pre>            Map.Entry&lt;K,V&gt; result = exportEntry(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1582" href="#"></a></td>
<td><pre>            if (e != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1583" href="#"></a></td>
<td><pre>                m.deleteEntry(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1584" href="#"></a></td>
<td><pre>            return result;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1585" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1586" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1587" href="#"></a></td>
<td><pre>        // Views</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1588" href="#"></a></td>
<td><pre>        transient NavigableMap&lt;K,V&gt; descendingMapView = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1589" href="#"></a></td>
<td><pre>        transient EntrySetView entrySetView = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1590" href="#"></a></td>
<td><pre>        transient KeySet&lt;K&gt; navigableKeySetView = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1591" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1592" href="#"></a></td>
<td><pre>        public final NavigableSet&lt;K&gt; navigableKeySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1593" href="#"></a></td>
<td><pre>            KeySet&lt;K&gt; nksv = navigableKeySetView;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1594" href="#"></a></td>
<td><pre>            return (nksv != null) ? nksv :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1595" href="#"></a></td>
<td><pre>                (navigableKeySetView = new TreeMap.KeySet&lt;&gt;(this));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1596" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1597" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1598" href="#"></a></td>
<td><pre>        public final Set&lt;K&gt; keySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1599" href="#"></a></td>
<td><pre>            return navigableKeySet();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1600" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1601" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1602" href="#"></a></td>
<td><pre>        public NavigableSet&lt;K&gt; descendingKeySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1603" href="#"></a></td>
<td><pre>            return descendingMap().navigableKeySet();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1604" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1605" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1606" href="#"></a></td>
<td><pre>        public final SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1607" href="#"></a></td>
<td><pre>            return subMap(fromKey, true, toKey, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1608" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1609" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1610" href="#"></a></td>
<td><pre>        public final SortedMap&lt;K,V&gt; headMap(K toKey) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1611" href="#"></a></td>
<td><pre>            return headMap(toKey, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1612" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1613" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1614" href="#"></a></td>
<td><pre>        public final SortedMap&lt;K,V&gt; tailMap(K fromKey) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1615" href="#"></a></td>
<td><pre>            return tailMap(fromKey, true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1616" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1617" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1618" href="#"></a></td>
<td><pre>        // View classes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1619" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1620" href="#"></a></td>
<td><pre>        abstract class EntrySetView extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1621" href="#"></a></td>
<td><pre>            private transient int size = -1, sizeModCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1622" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1623" href="#"></a></td>
<td><pre>            public int size() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1624" href="#"></a></td>
<td><pre>                if (fromStart &amp;&amp; toEnd)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1625" href="#"></a></td>
<td><pre>                    return m.size();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1626" href="#"></a></td>
<td><pre>                if (size == -1 || sizeModCount != m.modCount) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1627" href="#"></a></td>
<td><pre>                    sizeModCount = m.modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1628" href="#"></a></td>
<td><pre>                    size = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1629" href="#"></a></td>
<td><pre>                    Iterator&lt;?&gt; i = iterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1630" href="#"></a></td>
<td><pre>                    while (i.hasNext()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1631" href="#"></a></td>
<td><pre>                        size++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1632" href="#"></a></td>
<td><pre>                        i.next();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1633" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1634" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1635" href="#"></a></td>
<td><pre>                return size;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1636" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1637" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1638" href="#"></a></td>
<td><pre>            public boolean isEmpty() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1639" href="#"></a></td>
<td><pre>                TreeMap.Entry&lt;K,V&gt; n = absLowest();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1640" href="#"></a></td>
<td><pre>                return n == null || tooHigh(n.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1641" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1642" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1643" href="#"></a></td>
<td><pre>            public boolean contains(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1644" href="#"></a></td>
<td><pre>                if (!(o instanceof Map.Entry))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1645" href="#"></a></td>
<td><pre>                    return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1646" href="#"></a></td>
<td><pre>                Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;) o;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1647" href="#"></a></td>
<td><pre>                Object key = entry.getKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1648" href="#"></a></td>
<td><pre>                if (!inRange(key))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1649" href="#"></a></td>
<td><pre>                    return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1650" href="#"></a></td>
<td><pre>                TreeMap.Entry&lt;?,?&gt; node = m.getEntry(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1651" href="#"></a></td>
<td><pre>                return node != null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1652" href="#"></a></td>
<td><pre>                    valEquals(node.getValue(), entry.getValue());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1653" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1654" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1655" href="#"></a></td>
<td><pre>            public boolean remove(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1656" href="#"></a></td>
<td><pre>                if (!(o instanceof Map.Entry))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1657" href="#"></a></td>
<td><pre>                    return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1658" href="#"></a></td>
<td><pre>                Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;) o;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1659" href="#"></a></td>
<td><pre>                Object key = entry.getKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1660" href="#"></a></td>
<td><pre>                if (!inRange(key))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1661" href="#"></a></td>
<td><pre>                    return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1662" href="#"></a></td>
<td><pre>                TreeMap.Entry&lt;K,V&gt; node = m.getEntry(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1663" href="#"></a></td>
<td><pre>                if (node!=null &amp;&amp; valEquals(node.getValue(),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1664" href="#"></a></td>
<td><pre>                                            entry.getValue())) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1665" href="#"></a></td>
<td><pre>                    m.deleteEntry(node);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1666" href="#"></a></td>
<td><pre>                    return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1667" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1668" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1669" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1670" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1671" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1672" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1673" href="#"></a></td>
<td><pre>         * Iterators for SubMaps</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1674" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1675" href="#"></a></td>
<td><pre>        abstract class SubMapIterator&lt;T&gt; implements Iterator&lt;T&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1676" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; lastReturned;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1677" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1678" href="#"></a></td>
<td><pre>            final Object fenceKey;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1679" href="#"></a></td>
<td><pre>            int expectedModCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1680" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1681" href="#"></a></td>
<td><pre>            SubMapIterator(TreeMap.Entry&lt;K,V&gt; first,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1682" href="#"></a></td>
<td><pre>                           TreeMap.Entry&lt;K,V&gt; fence) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1683" href="#"></a></td>
<td><pre>                expectedModCount = m.modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1684" href="#"></a></td>
<td><pre>                lastReturned = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1685" href="#"></a></td>
<td><pre>                next = first;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1686" href="#"></a></td>
<td><pre>                fenceKey = fence == null ? UNBOUNDED : fence.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1687" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1688" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1689" href="#"></a></td>
<td><pre>            public final boolean hasNext() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1690" href="#"></a></td>
<td><pre>                return next != null &amp;&amp; next.key != fenceKey;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1691" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1692" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1693" href="#"></a></td>
<td><pre>            final TreeMap.Entry&lt;K,V&gt; nextEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1694" href="#"></a></td>
<td><pre>                TreeMap.Entry&lt;K,V&gt; e = next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1695" href="#"></a></td>
<td><pre>                if (e == null || e.key == fenceKey)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1696" href="#"></a></td>
<td><pre>                    throw new NoSuchElementException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1697" href="#"></a></td>
<td><pre>                if (m.modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1698" href="#"></a></td>
<td><pre>                    throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1699" href="#"></a></td>
<td><pre>                next = successor(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1700" href="#"></a></td>
<td><pre>                lastReturned = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1701" href="#"></a></td>
<td><pre>                return e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1702" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1703" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1704" href="#"></a></td>
<td><pre>            final TreeMap.Entry&lt;K,V&gt; prevEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1705" href="#"></a></td>
<td><pre>                TreeMap.Entry&lt;K,V&gt; e = next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1706" href="#"></a></td>
<td><pre>                if (e == null || e.key == fenceKey)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1707" href="#"></a></td>
<td><pre>                    throw new NoSuchElementException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1708" href="#"></a></td>
<td><pre>                if (m.modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1709" href="#"></a></td>
<td><pre>                    throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1710" href="#"></a></td>
<td><pre>                next = predecessor(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1711" href="#"></a></td>
<td><pre>                lastReturned = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1712" href="#"></a></td>
<td><pre>                return e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1713" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1714" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1715" href="#"></a></td>
<td><pre>            final void removeAscending() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1716" href="#"></a></td>
<td><pre>                if (lastReturned == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1717" href="#"></a></td>
<td><pre>                    throw new IllegalStateException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1718" href="#"></a></td>
<td><pre>                if (m.modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1719" href="#"></a></td>
<td><pre>                    throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1720" href="#"></a></td>
<td><pre>                // deleted entries are replaced by their successors</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1721" href="#"></a></td>
<td><pre>                if (lastReturned.left != null &amp;&amp; lastReturned.right != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1722" href="#"></a></td>
<td><pre>                    next = lastReturned;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1723" href="#"></a></td>
<td><pre>                m.deleteEntry(lastReturned);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1724" href="#"></a></td>
<td><pre>                lastReturned = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1725" href="#"></a></td>
<td><pre>                expectedModCount = m.modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1726" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1727" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1728" href="#"></a></td>
<td><pre>            final void removeDescending() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1729" href="#"></a></td>
<td><pre>                if (lastReturned == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1730" href="#"></a></td>
<td><pre>                    throw new IllegalStateException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1731" href="#"></a></td>
<td><pre>                if (m.modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1732" href="#"></a></td>
<td><pre>                    throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1733" href="#"></a></td>
<td><pre>                m.deleteEntry(lastReturned);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1734" href="#"></a></td>
<td><pre>                lastReturned = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1735" href="#"></a></td>
<td><pre>                expectedModCount = m.modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1736" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1737" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1738" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1739" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1740" href="#"></a></td>
<td><pre>        final class SubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1741" href="#"></a></td>
<td><pre>            SubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; first,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1742" href="#"></a></td>
<td><pre>                                TreeMap.Entry&lt;K,V&gt; fence) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1743" href="#"></a></td>
<td><pre>                super(first, fence);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1744" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1745" href="#"></a></td>
<td><pre>            public Map.Entry&lt;K,V&gt; next() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1746" href="#"></a></td>
<td><pre>                return nextEntry();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1747" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1748" href="#"></a></td>
<td><pre>            public void remove() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1749" href="#"></a></td>
<td><pre>                removeAscending();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1750" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1751" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1752" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1753" href="#"></a></td>
<td><pre>        final class DescendingSubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1754" href="#"></a></td>
<td><pre>            DescendingSubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; last,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1755" href="#"></a></td>
<td><pre>                                          TreeMap.Entry&lt;K,V&gt; fence) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1756" href="#"></a></td>
<td><pre>                super(last, fence);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1757" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1758" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1759" href="#"></a></td>
<td><pre>            public Map.Entry&lt;K,V&gt; next() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1760" href="#"></a></td>
<td><pre>                return prevEntry();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1761" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1762" href="#"></a></td>
<td><pre>            public void remove() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1763" href="#"></a></td>
<td><pre>                removeDescending();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1764" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1765" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1766" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1767" href="#"></a></td>
<td><pre>        // Implement minimal Spliterator as KeySpliterator backup</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1768" href="#"></a></td>
<td><pre>        final class SubMapKeyIterator extends SubMapIterator&lt;K&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1769" href="#"></a></td>
<td><pre>            implements Spliterator&lt;K&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1770" href="#"></a></td>
<td><pre>            SubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; first,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1771" href="#"></a></td>
<td><pre>                              TreeMap.Entry&lt;K,V&gt; fence) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1772" href="#"></a></td>
<td><pre>                super(first, fence);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1773" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1774" href="#"></a></td>
<td><pre>            public K next() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1775" href="#"></a></td>
<td><pre>                return nextEntry().key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1776" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1777" href="#"></a></td>
<td><pre>            public void remove() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1778" href="#"></a></td>
<td><pre>                removeAscending();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1779" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1780" href="#"></a></td>
<td><pre>            public Spliterator&lt;K&gt; trySplit() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1781" href="#"></a></td>
<td><pre>                return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1782" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1783" href="#"></a></td>
<td><pre>            public void forEachRemaining(Consumer&lt;? super K&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1784" href="#"></a></td>
<td><pre>                while (hasNext())</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1785" href="#"></a></td>
<td><pre>                    action.accept(next());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1786" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1787" href="#"></a></td>
<td><pre>            public boolean tryAdvance(Consumer&lt;? super K&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1788" href="#"></a></td>
<td><pre>                if (hasNext()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1789" href="#"></a></td>
<td><pre>                    action.accept(next());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1790" href="#"></a></td>
<td><pre>                    return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1791" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1792" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1793" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1794" href="#"></a></td>
<td><pre>            public long estimateSize() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1795" href="#"></a></td>
<td><pre>                return Long.MAX_VALUE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1796" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1797" href="#"></a></td>
<td><pre>            public int characteristics() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1798" href="#"></a></td>
<td><pre>                return Spliterator.DISTINCT | Spliterator.ORDERED |</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1799" href="#"></a></td>
<td><pre>                    Spliterator.SORTED;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1800" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1801" href="#"></a></td>
<td><pre>            public final Comparator&lt;? super K&gt;  getComparator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1802" href="#"></a></td>
<td><pre>                return NavigableSubMap.this.comparator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1803" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1804" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1805" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1806" href="#"></a></td>
<td><pre>        final class DescendingSubMapKeyIterator extends SubMapIterator&lt;K&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1807" href="#"></a></td>
<td><pre>            implements Spliterator&lt;K&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1808" href="#"></a></td>
<td><pre>            DescendingSubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; last,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1809" href="#"></a></td>
<td><pre>                                        TreeMap.Entry&lt;K,V&gt; fence) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1810" href="#"></a></td>
<td><pre>                super(last, fence);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1811" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1812" href="#"></a></td>
<td><pre>            public K next() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1813" href="#"></a></td>
<td><pre>                return prevEntry().key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1814" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1815" href="#"></a></td>
<td><pre>            public void remove() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1816" href="#"></a></td>
<td><pre>                removeDescending();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1817" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1818" href="#"></a></td>
<td><pre>            public Spliterator&lt;K&gt; trySplit() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1819" href="#"></a></td>
<td><pre>                return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1820" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1821" href="#"></a></td>
<td><pre>            public void forEachRemaining(Consumer&lt;? super K&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1822" href="#"></a></td>
<td><pre>                while (hasNext())</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1823" href="#"></a></td>
<td><pre>                    action.accept(next());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1824" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1825" href="#"></a></td>
<td><pre>            public boolean tryAdvance(Consumer&lt;? super K&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1826" href="#"></a></td>
<td><pre>                if (hasNext()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1827" href="#"></a></td>
<td><pre>                    action.accept(next());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1828" href="#"></a></td>
<td><pre>                    return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1829" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1830" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1831" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1832" href="#"></a></td>
<td><pre>            public long estimateSize() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1833" href="#"></a></td>
<td><pre>                return Long.MAX_VALUE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1834" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1835" href="#"></a></td>
<td><pre>            public int characteristics() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1836" href="#"></a></td>
<td><pre>                return Spliterator.DISTINCT | Spliterator.ORDERED;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1837" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1838" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1839" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1840" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1841" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1842" href="#"></a></td>
<td><pre>     * @serial include</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1843" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1844" href="#"></a></td>
<td><pre>    static final class AscendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1845" href="#"></a></td>
<td><pre>        private static final long serialVersionUID = 912986545866124060L;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1846" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1847" href="#"></a></td>
<td><pre>        AscendingSubMap(TreeMap&lt;K,V&gt; m,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1848" href="#"></a></td>
<td><pre>                        boolean fromStart, K lo, boolean loInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1849" href="#"></a></td>
<td><pre>                        boolean toEnd,     K hi, boolean hiInclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1850" href="#"></a></td>
<td><pre>            super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1851" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1852" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1853" href="#"></a></td>
<td><pre>        public Comparator&lt;? super K&gt; comparator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1854" href="#"></a></td>
<td><pre>            return m.comparator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1855" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1856" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1857" href="#"></a></td>
<td><pre>        public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1858" href="#"></a></td>
<td><pre>                                        K toKey,   boolean toInclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1859" href="#"></a></td>
<td><pre>            if (!inRange(fromKey, fromInclusive))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1860" href="#"></a></td>
<td><pre>                throw new IllegalArgumentException(&quot;fromKey out of range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1861" href="#"></a></td>
<td><pre>            if (!inRange(toKey, toInclusive))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1862" href="#"></a></td>
<td><pre>                throw new IllegalArgumentException(&quot;toKey out of range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1863" href="#"></a></td>
<td><pre>            return new AscendingSubMap&lt;&gt;(m,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1864" href="#"></a></td>
<td><pre>                                         false, fromKey, fromInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1865" href="#"></a></td>
<td><pre>                                         false, toKey,   toInclusive);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1866" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1867" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1868" href="#"></a></td>
<td><pre>        public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1869" href="#"></a></td>
<td><pre>            if (!inRange(toKey, inclusive))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1870" href="#"></a></td>
<td><pre>                throw new IllegalArgumentException(&quot;toKey out of range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1871" href="#"></a></td>
<td><pre>            return new AscendingSubMap&lt;&gt;(m,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1872" href="#"></a></td>
<td><pre>                                         fromStart, lo,    loInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1873" href="#"></a></td>
<td><pre>                                         false,     toKey, inclusive);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1874" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1875" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1876" href="#"></a></td>
<td><pre>        public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1877" href="#"></a></td>
<td><pre>            if (!inRange(fromKey, inclusive))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1878" href="#"></a></td>
<td><pre>                throw new IllegalArgumentException(&quot;fromKey out of range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1879" href="#"></a></td>
<td><pre>            return new AscendingSubMap&lt;&gt;(m,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1880" href="#"></a></td>
<td><pre>                                         false, fromKey, inclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1881" href="#"></a></td>
<td><pre>                                         toEnd, hi,      hiInclusive);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1882" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1883" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1884" href="#"></a></td>
<td><pre>        public NavigableMap&lt;K,V&gt; descendingMap() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1885" href="#"></a></td>
<td><pre>            NavigableMap&lt;K,V&gt; mv = descendingMapView;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1886" href="#"></a></td>
<td><pre>            return (mv != null) ? mv :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1887" href="#"></a></td>
<td><pre>                (descendingMapView =</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1888" href="#"></a></td>
<td><pre>                 new DescendingSubMap&lt;&gt;(m,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1889" href="#"></a></td>
<td><pre>                                        fromStart, lo, loInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1890" href="#"></a></td>
<td><pre>                                        toEnd,     hi, hiInclusive));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1891" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1892" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1893" href="#"></a></td>
<td><pre>        Iterator&lt;K&gt; keyIterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1894" href="#"></a></td>
<td><pre>            return new SubMapKeyIterator(absLowest(), absHighFence());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1895" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1896" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1897" href="#"></a></td>
<td><pre>        Spliterator&lt;K&gt; keySpliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1898" href="#"></a></td>
<td><pre>            return new SubMapKeyIterator(absLowest(), absHighFence());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1899" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1900" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1901" href="#"></a></td>
<td><pre>        Iterator&lt;K&gt; descendingKeyIterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1902" href="#"></a></td>
<td><pre>            return new DescendingSubMapKeyIterator(absHighest(), absLowFence());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1903" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1904" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1905" href="#"></a></td>
<td><pre>        final class AscendingEntrySetView extends EntrySetView {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1906" href="#"></a></td>
<td><pre>            public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1907" href="#"></a></td>
<td><pre>                return new SubMapEntryIterator(absLowest(), absHighFence());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1908" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1909" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1910" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1911" href="#"></a></td>
<td><pre>        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1912" href="#"></a></td>
<td><pre>            EntrySetView es = entrySetView;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1913" href="#"></a></td>
<td><pre>            return (es != null) ? es : (entrySetView = new AscendingEntrySetView());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1914" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1915" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1916" href="#"></a></td>
<td><pre>        TreeMap.Entry&lt;K,V&gt; subLowest()       { return absLowest(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1917" href="#"></a></td>
<td><pre>        TreeMap.Entry&lt;K,V&gt; subHighest()      { return absHighest(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1918" href="#"></a></td>
<td><pre>        TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absCeiling(key); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1919" href="#"></a></td>
<td><pre>        TreeMap.Entry&lt;K,V&gt; subHigher(K key)  { return absHigher(key); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1920" href="#"></a></td>
<td><pre>        TreeMap.Entry&lt;K,V&gt; subFloor(K key)   { return absFloor(key); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1921" href="#"></a></td>
<td><pre>        TreeMap.Entry&lt;K,V&gt; subLower(K key)   { return absLower(key); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1922" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1923" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1924" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1925" href="#"></a></td>
<td><pre>     * @serial include</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1926" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1927" href="#"></a></td>
<td><pre>    static final class DescendingSubMap&lt;K,V&gt;  extends NavigableSubMap&lt;K,V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1928" href="#"></a></td>
<td><pre>        private static final long serialVersionUID = 912986545866120460L;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1929" href="#"></a></td>
<td><pre>        DescendingSubMap(TreeMap&lt;K,V&gt; m,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1930" href="#"></a></td>
<td><pre>                        boolean fromStart, K lo, boolean loInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1931" href="#"></a></td>
<td><pre>                        boolean toEnd,     K hi, boolean hiInclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1932" href="#"></a></td>
<td><pre>            super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1933" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1934" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1935" href="#"></a></td>
<td><pre>        private final Comparator&lt;? super K&gt; reverseComparator =</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1936" href="#"></a></td>
<td><pre>            Collections.reverseOrder(m.comparator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1937" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1938" href="#"></a></td>
<td><pre>        public Comparator&lt;? super K&gt; comparator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1939" href="#"></a></td>
<td><pre>            return reverseComparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1940" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1941" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1942" href="#"></a></td>
<td><pre>        public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1943" href="#"></a></td>
<td><pre>                                        K toKey,   boolean toInclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1944" href="#"></a></td>
<td><pre>            if (!inRange(fromKey, fromInclusive))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1945" href="#"></a></td>
<td><pre>                throw new IllegalArgumentException(&quot;fromKey out of range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1946" href="#"></a></td>
<td><pre>            if (!inRange(toKey, toInclusive))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1947" href="#"></a></td>
<td><pre>                throw new IllegalArgumentException(&quot;toKey out of range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1948" href="#"></a></td>
<td><pre>            return new DescendingSubMap&lt;&gt;(m,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1949" href="#"></a></td>
<td><pre>                                          false, toKey,   toInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1950" href="#"></a></td>
<td><pre>                                          false, fromKey, fromInclusive);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1951" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1952" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1953" href="#"></a></td>
<td><pre>        public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1954" href="#"></a></td>
<td><pre>            if (!inRange(toKey, inclusive))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1955" href="#"></a></td>
<td><pre>                throw new IllegalArgumentException(&quot;toKey out of range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1956" href="#"></a></td>
<td><pre>            return new DescendingSubMap&lt;&gt;(m,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1957" href="#"></a></td>
<td><pre>                                          false, toKey, inclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1958" href="#"></a></td>
<td><pre>                                          toEnd, hi,    hiInclusive);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1959" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1960" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1961" href="#"></a></td>
<td><pre>        public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1962" href="#"></a></td>
<td><pre>            if (!inRange(fromKey, inclusive))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1963" href="#"></a></td>
<td><pre>                throw new IllegalArgumentException(&quot;fromKey out of range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1964" href="#"></a></td>
<td><pre>            return new DescendingSubMap&lt;&gt;(m,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1965" href="#"></a></td>
<td><pre>                                          fromStart, lo, loInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1966" href="#"></a></td>
<td><pre>                                          false, fromKey, inclusive);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1967" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1968" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1969" href="#"></a></td>
<td><pre>        public NavigableMap&lt;K,V&gt; descendingMap() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1970" href="#"></a></td>
<td><pre>            NavigableMap&lt;K,V&gt; mv = descendingMapView;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1971" href="#"></a></td>
<td><pre>            return (mv != null) ? mv :</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1972" href="#"></a></td>
<td><pre>                (descendingMapView =</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1973" href="#"></a></td>
<td><pre>                 new AscendingSubMap&lt;&gt;(m,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1974" href="#"></a></td>
<td><pre>                                       fromStart, lo, loInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1975" href="#"></a></td>
<td><pre>                                       toEnd,     hi, hiInclusive));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1976" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1977" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1978" href="#"></a></td>
<td><pre>        Iterator&lt;K&gt; keyIterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1979" href="#"></a></td>
<td><pre>            return new DescendingSubMapKeyIterator(absHighest(), absLowFence());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1980" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1981" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1982" href="#"></a></td>
<td><pre>        Spliterator&lt;K&gt; keySpliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1983" href="#"></a></td>
<td><pre>            return new DescendingSubMapKeyIterator(absHighest(), absLowFence());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1984" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1985" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1986" href="#"></a></td>
<td><pre>        Iterator&lt;K&gt; descendingKeyIterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1987" href="#"></a></td>
<td><pre>            return new SubMapKeyIterator(absLowest(), absHighFence());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1988" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1989" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1990" href="#"></a></td>
<td><pre>        final class DescendingEntrySetView extends EntrySetView {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1991" href="#"></a></td>
<td><pre>            public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1992" href="#"></a></td>
<td><pre>                return new DescendingSubMapEntryIterator(absHighest(), absLowFence());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1993" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1994" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1995" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1996" href="#"></a></td>
<td><pre>        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1997" href="#"></a></td>
<td><pre>            EntrySetView es = entrySetView;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1998" href="#"></a></td>
<td><pre>            return (es != null) ? es : (entrySetView = new DescendingEntrySetView());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1999" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2000" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2001" href="#"></a></td>
<td><pre>        TreeMap.Entry&lt;K,V&gt; subLowest()       { return absHighest(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2002" href="#"></a></td>
<td><pre>        TreeMap.Entry&lt;K,V&gt; subHighest()      { return absLowest(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2003" href="#"></a></td>
<td><pre>        TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absFloor(key); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2004" href="#"></a></td>
<td><pre>        TreeMap.Entry&lt;K,V&gt; subHigher(K key)  { return absLower(key); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2005" href="#"></a></td>
<td><pre>        TreeMap.Entry&lt;K,V&gt; subFloor(K key)   { return absCeiling(key); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2006" href="#"></a></td>
<td><pre>        TreeMap.Entry&lt;K,V&gt; subLower(K key)   { return absHigher(key); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2007" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2008" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2009" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2010" href="#"></a></td>
<td><pre>     * This class exists solely for the sake of serialization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2011" href="#"></a></td>
<td><pre>     * compatibility with previous releases of TreeMap that did not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2012" href="#"></a></td>
<td><pre>     * support NavigableMap.  It translates an old-version SubMap into</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2013" href="#"></a></td>
<td><pre>     * a new-version AscendingSubMap. This class is never otherwise</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2014" href="#"></a></td>
<td><pre>     * used.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2015" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2016" href="#"></a></td>
<td><pre>     * @serial include</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2017" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2018" href="#"></a></td>
<td><pre>    private class SubMap extends AbstractMap&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2019" href="#"></a></td>
<td><pre>        implements SortedMap&lt;K,V&gt;, java.io.Serializable {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2020" href="#"></a></td>
<td><pre>        private static final long serialVersionUID = -6520786458950516097L;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2021" href="#"></a></td>
<td><pre>        private boolean fromStart = false, toEnd = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2022" href="#"></a></td>
<td><pre>        private K fromKey, toKey;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2023" href="#"></a></td>
<td><pre>        private Object readResolve() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2024" href="#"></a></td>
<td><pre>            return new AscendingSubMap&lt;&gt;(TreeMap.this,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2025" href="#"></a></td>
<td><pre>                                         fromStart, fromKey, true,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2026" href="#"></a></td>
<td><pre>                                         toEnd, toKey, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2027" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2028" href="#"></a></td>
<td><pre>        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { throw new InternalError(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2029" href="#"></a></td>
<td><pre>        public K lastKey() { throw new InternalError(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2030" href="#"></a></td>
<td><pre>        public K firstKey() { throw new InternalError(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2031" href="#"></a></td>
<td><pre>        public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) { throw new InternalError(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2032" href="#"></a></td>
<td><pre>        public SortedMap&lt;K,V&gt; headMap(K toKey) { throw new InternalError(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2033" href="#"></a></td>
<td><pre>        public SortedMap&lt;K,V&gt; tailMap(K fromKey) { throw new InternalError(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2034" href="#"></a></td>
<td><pre>        public Comparator&lt;? super K&gt; comparator() { throw new InternalError(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2035" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2036" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2037" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2038" href="#"></a></td>
<td><pre>    // Red-black mechanics</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2039" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2040" href="#"></a></td>
<td><pre>    private static final boolean RED   = false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2041" href="#"></a></td>
<td><pre>    private static final boolean BLACK = true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2042" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2043" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2044" href="#"></a></td>
<td><pre>     * Node in the Tree.  Doubles as a means to pass key-value pairs back to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2045" href="#"></a></td>
<td><pre>     * user (see Map.Entry).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2046" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2047" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2048" href="#"></a></td>
<td><pre>    static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2049" href="#"></a></td>
<td><pre>        K key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2050" href="#"></a></td>
<td><pre>        V value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2051" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; left = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2052" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; right = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2053" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2054" href="#"></a></td>
<td><pre>        boolean color = BLACK;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2055" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2056" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2057" href="#"></a></td>
<td><pre>         * Make a new cell with given key, value, and parent, and with</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2058" href="#"></a></td>
<td><pre>         * {@code null} child links, and BLACK color.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2059" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2060" href="#"></a></td>
<td><pre>        Entry(K key, V value, Entry&lt;K,V&gt; parent) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2061" href="#"></a></td>
<td><pre>            this.key = key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2062" href="#"></a></td>
<td><pre>            this.value = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2063" href="#"></a></td>
<td><pre>            this.parent = parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2064" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2065" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2066" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2067" href="#"></a></td>
<td><pre>         * Returns the key.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2068" href="#"></a></td>
<td><pre>         *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2069" href="#"></a></td>
<td><pre>         * @return the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2070" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2071" href="#"></a></td>
<td><pre>        public K getKey() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2072" href="#"></a></td>
<td><pre>            return key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2073" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2074" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2075" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2076" href="#"></a></td>
<td><pre>         * Returns the value associated with the key.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2077" href="#"></a></td>
<td><pre>         *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2078" href="#"></a></td>
<td><pre>         * @return the value associated with the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2079" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2080" href="#"></a></td>
<td><pre>        public V getValue() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2081" href="#"></a></td>
<td><pre>            return value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2082" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2083" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2084" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2085" href="#"></a></td>
<td><pre>         * Replaces the value currently associated with the key with the given</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2086" href="#"></a></td>
<td><pre>         * value.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2087" href="#"></a></td>
<td><pre>         *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2088" href="#"></a></td>
<td><pre>         * @return the value associated with the key before this method was</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2089" href="#"></a></td>
<td><pre>         *         called</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2090" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2091" href="#"></a></td>
<td><pre>        public V setValue(V value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2092" href="#"></a></td>
<td><pre>            V oldValue = this.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2093" href="#"></a></td>
<td><pre>            this.value = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2094" href="#"></a></td>
<td><pre>            return oldValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2095" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2096" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2097" href="#"></a></td>
<td><pre>        public boolean equals(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2098" href="#"></a></td>
<td><pre>            if (!(o instanceof Map.Entry))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2099" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2100" href="#"></a></td>
<td><pre>            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2101" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2102" href="#"></a></td>
<td><pre>            return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2103" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2104" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2105" href="#"></a></td>
<td><pre>        public int hashCode() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2106" href="#"></a></td>
<td><pre>            int keyHash = (key==null ? 0 : key.hashCode());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2107" href="#"></a></td>
<td><pre>            int valueHash = (value==null ? 0 : value.hashCode());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2108" href="#"></a></td>
<td><pre>            return keyHash ^ valueHash;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2109" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2110" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2111" href="#"></a></td>
<td><pre>        public String toString() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2112" href="#"></a></td>
<td><pre>            return key + &quot;=&quot; + value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2113" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2114" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2115" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2116" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2117" href="#"></a></td>
<td><pre>     * Returns the first Entry in the TreeMap (according to the TreeMap's</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2118" href="#"></a></td>
<td><pre>     * key-sort function).  Returns null if the TreeMap is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2119" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2120" href="#"></a></td>
<td><pre>    final Entry&lt;K,V&gt; getFirstEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2121" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; p = root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2122" href="#"></a></td>
<td><pre>        if (p != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2123" href="#"></a></td>
<td><pre>            while (p.left != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2124" href="#"></a></td>
<td><pre>                p = p.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2125" href="#"></a></td>
<td><pre>        return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2126" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2127" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2128" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2129" href="#"></a></td>
<td><pre>     * Returns the last Entry in the TreeMap (according to the TreeMap's</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2130" href="#"></a></td>
<td><pre>     * key-sort function).  Returns null if the TreeMap is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2131" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2132" href="#"></a></td>
<td><pre>    final Entry&lt;K,V&gt; getLastEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2133" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; p = root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2134" href="#"></a></td>
<td><pre>        if (p != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2135" href="#"></a></td>
<td><pre>            while (p.right != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2136" href="#"></a></td>
<td><pre>                p = p.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2137" href="#"></a></td>
<td><pre>        return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2138" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2139" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2140" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2141" href="#"></a></td>
<td><pre>     * Returns the successor of the specified Entry, or null if no such.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2142" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2143" href="#"></a></td>
<td><pre>    static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2144" href="#"></a></td>
<td><pre>        if (t == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2145" href="#"></a></td>
<td><pre>            return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2146" href="#"></a></td>
<td><pre>        else if (t.right != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2147" href="#"></a></td>
<td><pre>            Entry&lt;K,V&gt; p = t.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2148" href="#"></a></td>
<td><pre>            while (p.left != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2149" href="#"></a></td>
<td><pre>                p = p.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2150" href="#"></a></td>
<td><pre>            return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2151" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2152" href="#"></a></td>
<td><pre>            Entry&lt;K,V&gt; p = t.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2153" href="#"></a></td>
<td><pre>            Entry&lt;K,V&gt; ch = t;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2154" href="#"></a></td>
<td><pre>            while (p != null &amp;&amp; ch == p.right) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2155" href="#"></a></td>
<td><pre>                ch = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2156" href="#"></a></td>
<td><pre>                p = p.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2157" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2158" href="#"></a></td>
<td><pre>            return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2159" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2160" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2161" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2162" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2163" href="#"></a></td>
<td><pre>     * Returns the predecessor of the specified Entry, or null if no such.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2164" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2165" href="#"></a></td>
<td><pre>    static &lt;K,V&gt; Entry&lt;K,V&gt; predecessor(Entry&lt;K,V&gt; t) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2166" href="#"></a></td>
<td><pre>        if (t == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2167" href="#"></a></td>
<td><pre>            return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2168" href="#"></a></td>
<td><pre>        else if (t.left != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2169" href="#"></a></td>
<td><pre>            Entry&lt;K,V&gt; p = t.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2170" href="#"></a></td>
<td><pre>            while (p.right != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2171" href="#"></a></td>
<td><pre>                p = p.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2172" href="#"></a></td>
<td><pre>            return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2173" href="#"></a></td>
<td><pre>        } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2174" href="#"></a></td>
<td><pre>            Entry&lt;K,V&gt; p = t.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2175" href="#"></a></td>
<td><pre>            Entry&lt;K,V&gt; ch = t;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2176" href="#"></a></td>
<td><pre>            while (p != null &amp;&amp; ch == p.left) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2177" href="#"></a></td>
<td><pre>                ch = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2178" href="#"></a></td>
<td><pre>                p = p.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2179" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2180" href="#"></a></td>
<td><pre>            return p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2181" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2182" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2183" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2184" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2185" href="#"></a></td>
<td><pre>     * Balancing operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2186" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2187" href="#"></a></td>
<td><pre>     * Implementations of rebalancings during insertion and deletion are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2188" href="#"></a></td>
<td><pre>     * slightly different than the CLR version.  Rather than using dummy</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2189" href="#"></a></td>
<td><pre>     * nilnodes, we use a set of accessors that deal properly with null.  They</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2190" href="#"></a></td>
<td><pre>     * are used to avoid messiness surrounding nullness checks in the main</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2191" href="#"></a></td>
<td><pre>     * algorithms.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2192" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2193" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2194" href="#"></a></td>
<td><pre>    private static &lt;K,V&gt; boolean colorOf(Entry&lt;K,V&gt; p) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2195" href="#"></a></td>
<td><pre>        return (p == null ? BLACK : p.color);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2196" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2197" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2198" href="#"></a></td>
<td><pre>    private static &lt;K,V&gt; Entry&lt;K,V&gt; parentOf(Entry&lt;K,V&gt; p) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2199" href="#"></a></td>
<td><pre>        return (p == null ? null: p.parent);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2200" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2201" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2202" href="#"></a></td>
<td><pre>    private static &lt;K,V&gt; void setColor(Entry&lt;K,V&gt; p, boolean c) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2203" href="#"></a></td>
<td><pre>        if (p != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2204" href="#"></a></td>
<td><pre>            p.color = c;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2205" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2206" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2207" href="#"></a></td>
<td><pre>    private static &lt;K,V&gt; Entry&lt;K,V&gt; leftOf(Entry&lt;K,V&gt; p) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2208" href="#"></a></td>
<td><pre>        return (p == null) ? null: p.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2209" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2210" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2211" href="#"></a></td>
<td><pre>    private static &lt;K,V&gt; Entry&lt;K,V&gt; rightOf(Entry&lt;K,V&gt; p) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2212" href="#"></a></td>
<td><pre>        return (p == null) ? null: p.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2213" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2214" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2215" href="#"></a></td>
<td><pre>    /** From CLR */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2216" href="#"></a></td>
<td><pre>    private void rotateLeft(Entry&lt;K,V&gt; p) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2217" href="#"></a></td>
<td><pre>        if (p != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2218" href="#"></a></td>
<td><pre>            Entry&lt;K,V&gt; r = p.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2219" href="#"></a></td>
<td><pre>            p.right = r.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2220" href="#"></a></td>
<td><pre>            if (r.left != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2221" href="#"></a></td>
<td><pre>                r.left.parent = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2222" href="#"></a></td>
<td><pre>            r.parent = p.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2223" href="#"></a></td>
<td><pre>            if (p.parent == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2224" href="#"></a></td>
<td><pre>                root = r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2225" href="#"></a></td>
<td><pre>            else if (p.parent.left == p)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2226" href="#"></a></td>
<td><pre>                p.parent.left = r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2227" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2228" href="#"></a></td>
<td><pre>                p.parent.right = r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2229" href="#"></a></td>
<td><pre>            r.left = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2230" href="#"></a></td>
<td><pre>            p.parent = r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2231" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2232" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2233" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2234" href="#"></a></td>
<td><pre>    /** From CLR */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2235" href="#"></a></td>
<td><pre>    private void rotateRight(Entry&lt;K,V&gt; p) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2236" href="#"></a></td>
<td><pre>        if (p != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2237" href="#"></a></td>
<td><pre>            Entry&lt;K,V&gt; l = p.left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2238" href="#"></a></td>
<td><pre>            p.left = l.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2239" href="#"></a></td>
<td><pre>            if (l.right != null) l.right.parent = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2240" href="#"></a></td>
<td><pre>            l.parent = p.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2241" href="#"></a></td>
<td><pre>            if (p.parent == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2242" href="#"></a></td>
<td><pre>                root = l;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2243" href="#"></a></td>
<td><pre>            else if (p.parent.right == p)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2244" href="#"></a></td>
<td><pre>                p.parent.right = l;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2245" href="#"></a></td>
<td><pre>            else p.parent.left = l;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2246" href="#"></a></td>
<td><pre>            l.right = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2247" href="#"></a></td>
<td><pre>            p.parent = l;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2248" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2249" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2250" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2251" href="#"></a></td>
<td><pre>    /** From CLR */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2252" href="#"></a></td>
<td><pre>    private void fixAfterInsertion(Entry&lt;K,V&gt; x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2253" href="#"></a></td>
<td><pre>        x.color = RED;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2254" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2255" href="#"></a></td>
<td><pre>        while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2256" href="#"></a></td>
<td><pre>            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2257" href="#"></a></td>
<td><pre>                Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2258" href="#"></a></td>
<td><pre>                if (colorOf(y) == RED) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2259" href="#"></a></td>
<td><pre>                    setColor(parentOf(x), BLACK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2260" href="#"></a></td>
<td><pre>                    setColor(y, BLACK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2261" href="#"></a></td>
<td><pre>                    setColor(parentOf(parentOf(x)), RED);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2262" href="#"></a></td>
<td><pre>                    x = parentOf(parentOf(x));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2263" href="#"></a></td>
<td><pre>                } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2264" href="#"></a></td>
<td><pre>                    if (x == rightOf(parentOf(x))) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2265" href="#"></a></td>
<td><pre>                        x = parentOf(x);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2266" href="#"></a></td>
<td><pre>                        rotateLeft(x);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2267" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2268" href="#"></a></td>
<td><pre>                    setColor(parentOf(x), BLACK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2269" href="#"></a></td>
<td><pre>                    setColor(parentOf(parentOf(x)), RED);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2270" href="#"></a></td>
<td><pre>                    rotateRight(parentOf(parentOf(x)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2271" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2272" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2273" href="#"></a></td>
<td><pre>                Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2274" href="#"></a></td>
<td><pre>                if (colorOf(y) == RED) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2275" href="#"></a></td>
<td><pre>                    setColor(parentOf(x), BLACK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2276" href="#"></a></td>
<td><pre>                    setColor(y, BLACK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2277" href="#"></a></td>
<td><pre>                    setColor(parentOf(parentOf(x)), RED);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2278" href="#"></a></td>
<td><pre>                    x = parentOf(parentOf(x));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2279" href="#"></a></td>
<td><pre>                } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2280" href="#"></a></td>
<td><pre>                    if (x == leftOf(parentOf(x))) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2281" href="#"></a></td>
<td><pre>                        x = parentOf(x);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2282" href="#"></a></td>
<td><pre>                        rotateRight(x);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2283" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2284" href="#"></a></td>
<td><pre>                    setColor(parentOf(x), BLACK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2285" href="#"></a></td>
<td><pre>                    setColor(parentOf(parentOf(x)), RED);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2286" href="#"></a></td>
<td><pre>                    rotateLeft(parentOf(parentOf(x)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2287" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2288" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2289" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2290" href="#"></a></td>
<td><pre>        root.color = BLACK;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2291" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2292" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2293" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2294" href="#"></a></td>
<td><pre>     * Delete node p, and then rebalance the tree.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2295" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2296" href="#"></a></td>
<td><pre>    private void deleteEntry(Entry&lt;K,V&gt; p) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2297" href="#"></a></td>
<td><pre>        modCount++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2298" href="#"></a></td>
<td><pre>        size--;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2299" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2300" href="#"></a></td>
<td><pre>        // If strictly internal, copy successor's element to p and then make p</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2301" href="#"></a></td>
<td><pre>        // point to successor.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2302" href="#"></a></td>
<td><pre>        if (p.left != null &amp;&amp; p.right != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2303" href="#"></a></td>
<td><pre>            Entry&lt;K,V&gt; s = successor(p);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2304" href="#"></a></td>
<td><pre>            p.key = s.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2305" href="#"></a></td>
<td><pre>            p.value = s.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2306" href="#"></a></td>
<td><pre>            p = s;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2307" href="#"></a></td>
<td><pre>        } // p has 2 children</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2308" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2309" href="#"></a></td>
<td><pre>        // Start fixup at replacement node, if it exists.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2310" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2311" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2312" href="#"></a></td>
<td><pre>        if (replacement != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2313" href="#"></a></td>
<td><pre>            // Link replacement to parent</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2314" href="#"></a></td>
<td><pre>            replacement.parent = p.parent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2315" href="#"></a></td>
<td><pre>            if (p.parent == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2316" href="#"></a></td>
<td><pre>                root = replacement;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2317" href="#"></a></td>
<td><pre>            else if (p == p.parent.left)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2318" href="#"></a></td>
<td><pre>                p.parent.left  = replacement;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2319" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2320" href="#"></a></td>
<td><pre>                p.parent.right = replacement;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2321" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2322" href="#"></a></td>
<td><pre>            // Null out links so they are OK to use by fixAfterDeletion.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2323" href="#"></a></td>
<td><pre>            p.left = p.right = p.parent = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2324" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2325" href="#"></a></td>
<td><pre>            // Fix replacement</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2326" href="#"></a></td>
<td><pre>            if (p.color == BLACK)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2327" href="#"></a></td>
<td><pre>                fixAfterDeletion(replacement);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2328" href="#"></a></td>
<td><pre>        } else if (p.parent == null) { // return if we are the only node.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2329" href="#"></a></td>
<td><pre>            root = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2330" href="#"></a></td>
<td><pre>        } else { //  No children. Use self as phantom replacement and unlink.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2331" href="#"></a></td>
<td><pre>            if (p.color == BLACK)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2332" href="#"></a></td>
<td><pre>                fixAfterDeletion(p);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2333" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2334" href="#"></a></td>
<td><pre>            if (p.parent != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2335" href="#"></a></td>
<td><pre>                if (p == p.parent.left)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2336" href="#"></a></td>
<td><pre>                    p.parent.left = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2337" href="#"></a></td>
<td><pre>                else if (p == p.parent.right)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2338" href="#"></a></td>
<td><pre>                    p.parent.right = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2339" href="#"></a></td>
<td><pre>                p.parent = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2340" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2341" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2342" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2343" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2344" href="#"></a></td>
<td><pre>    /** From CLR */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2345" href="#"></a></td>
<td><pre>    private void fixAfterDeletion(Entry&lt;K,V&gt; x) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2346" href="#"></a></td>
<td><pre>        while (x != root &amp;&amp; colorOf(x) == BLACK) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2347" href="#"></a></td>
<td><pre>            if (x == leftOf(parentOf(x))) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2348" href="#"></a></td>
<td><pre>                Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2349" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2350" href="#"></a></td>
<td><pre>                if (colorOf(sib) == RED) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2351" href="#"></a></td>
<td><pre>                    setColor(sib, BLACK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2352" href="#"></a></td>
<td><pre>                    setColor(parentOf(x), RED);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2353" href="#"></a></td>
<td><pre>                    rotateLeft(parentOf(x));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2354" href="#"></a></td>
<td><pre>                    sib = rightOf(parentOf(x));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2355" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2356" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2357" href="#"></a></td>
<td><pre>                if (colorOf(leftOf(sib))  == BLACK &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2358" href="#"></a></td>
<td><pre>                    colorOf(rightOf(sib)) == BLACK) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2359" href="#"></a></td>
<td><pre>                    setColor(sib, RED);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2360" href="#"></a></td>
<td><pre>                    x = parentOf(x);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2361" href="#"></a></td>
<td><pre>                } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2362" href="#"></a></td>
<td><pre>                    if (colorOf(rightOf(sib)) == BLACK) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2363" href="#"></a></td>
<td><pre>                        setColor(leftOf(sib), BLACK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2364" href="#"></a></td>
<td><pre>                        setColor(sib, RED);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2365" href="#"></a></td>
<td><pre>                        rotateRight(sib);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2366" href="#"></a></td>
<td><pre>                        sib = rightOf(parentOf(x));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2367" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2368" href="#"></a></td>
<td><pre>                    setColor(sib, colorOf(parentOf(x)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2369" href="#"></a></td>
<td><pre>                    setColor(parentOf(x), BLACK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2370" href="#"></a></td>
<td><pre>                    setColor(rightOf(sib), BLACK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2371" href="#"></a></td>
<td><pre>                    rotateLeft(parentOf(x));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2372" href="#"></a></td>
<td><pre>                    x = root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2373" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2374" href="#"></a></td>
<td><pre>            } else { // symmetric</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2375" href="#"></a></td>
<td><pre>                Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2376" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2377" href="#"></a></td>
<td><pre>                if (colorOf(sib) == RED) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2378" href="#"></a></td>
<td><pre>                    setColor(sib, BLACK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2379" href="#"></a></td>
<td><pre>                    setColor(parentOf(x), RED);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2380" href="#"></a></td>
<td><pre>                    rotateRight(parentOf(x));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2381" href="#"></a></td>
<td><pre>                    sib = leftOf(parentOf(x));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2382" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2383" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2384" href="#"></a></td>
<td><pre>                if (colorOf(rightOf(sib)) == BLACK &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2385" href="#"></a></td>
<td><pre>                    colorOf(leftOf(sib)) == BLACK) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2386" href="#"></a></td>
<td><pre>                    setColor(sib, RED);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2387" href="#"></a></td>
<td><pre>                    x = parentOf(x);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2388" href="#"></a></td>
<td><pre>                } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2389" href="#"></a></td>
<td><pre>                    if (colorOf(leftOf(sib)) == BLACK) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2390" href="#"></a></td>
<td><pre>                        setColor(rightOf(sib), BLACK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2391" href="#"></a></td>
<td><pre>                        setColor(sib, RED);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2392" href="#"></a></td>
<td><pre>                        rotateLeft(sib);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2393" href="#"></a></td>
<td><pre>                        sib = leftOf(parentOf(x));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2394" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2395" href="#"></a></td>
<td><pre>                    setColor(sib, colorOf(parentOf(x)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2396" href="#"></a></td>
<td><pre>                    setColor(parentOf(x), BLACK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2397" href="#"></a></td>
<td><pre>                    setColor(leftOf(sib), BLACK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2398" href="#"></a></td>
<td><pre>                    rotateRight(parentOf(x));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2399" href="#"></a></td>
<td><pre>                    x = root;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2400" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2401" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2402" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2403" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2404" href="#"></a></td>
<td><pre>        setColor(x, BLACK);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2405" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2406" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2407" href="#"></a></td>
<td><pre>    private static final long serialVersionUID = 919286545866124006L;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2408" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2409" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2410" href="#"></a></td>
<td><pre>     * Save the state of the {@code TreeMap} instance to a stream (i.e.,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2411" href="#"></a></td>
<td><pre>     * serialize it).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2412" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2413" href="#"></a></td>
<td><pre>     * @serialData The &lt;em&gt;size&lt;/em&gt; of the TreeMap (the number of key-value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2414" href="#"></a></td>
<td><pre>     *             mappings) is emitted (int), followed by the key (Object)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2415" href="#"></a></td>
<td><pre>     *             and value (Object) for each key-value mapping represented</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2416" href="#"></a></td>
<td><pre>     *             by the TreeMap. The key-value mappings are emitted in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2417" href="#"></a></td>
<td><pre>     *             key-order (as determined by the TreeMap's Comparator,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2418" href="#"></a></td>
<td><pre>     *             or by the keys' natural ordering if the TreeMap has no</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2419" href="#"></a></td>
<td><pre>     *             Comparator).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2420" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2421" href="#"></a></td>
<td><pre>    private void writeObject(java.io.ObjectOutputStream s)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2422" href="#"></a></td>
<td><pre>        throws java.io.IOException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2423" href="#"></a></td>
<td><pre>        // Write out the Comparator and any hidden stuff</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2424" href="#"></a></td>
<td><pre>        s.defaultWriteObject();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2425" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2426" href="#"></a></td>
<td><pre>        // Write out size (number of Mappings)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2427" href="#"></a></td>
<td><pre>        s.writeInt(size);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2428" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2429" href="#"></a></td>
<td><pre>        // Write out keys and values (alternating)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2430" href="#"></a></td>
<td><pre>        for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); i.hasNext(); ) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2431" href="#"></a></td>
<td><pre>            Map.Entry&lt;K,V&gt; e = i.next();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2432" href="#"></a></td>
<td><pre>            s.writeObject(e.getKey());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2433" href="#"></a></td>
<td><pre>            s.writeObject(e.getValue());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2434" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2435" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2436" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2437" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2438" href="#"></a></td>
<td><pre>     * Reconstitute the {@code TreeMap} instance from a stream (i.e.,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2439" href="#"></a></td>
<td><pre>     * deserialize it).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2440" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2441" href="#"></a></td>
<td><pre>    private void readObject(final java.io.ObjectInputStream s)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2442" href="#"></a></td>
<td><pre>        throws java.io.IOException, ClassNotFoundException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2443" href="#"></a></td>
<td><pre>        // Read in the Comparator and any hidden stuff</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2444" href="#"></a></td>
<td><pre>        s.defaultReadObject();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2445" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2446" href="#"></a></td>
<td><pre>        // Read in size</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2447" href="#"></a></td>
<td><pre>        int size = s.readInt();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2448" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2449" href="#"></a></td>
<td><pre>        buildFromSorted(size, null, s, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2450" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2451" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2452" href="#"></a></td>
<td><pre>    /** Intended to be called only from TreeSet.readObject */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2453" href="#"></a></td>
<td><pre>    void readTreeSet(int size, java.io.ObjectInputStream s, V defaultVal)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2454" href="#"></a></td>
<td><pre>        throws java.io.IOException, ClassNotFoundException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2455" href="#"></a></td>
<td><pre>        buildFromSorted(size, null, s, defaultVal);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2456" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2457" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2458" href="#"></a></td>
<td><pre>    /** Intended to be called only from TreeSet.addAll */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2459" href="#"></a></td>
<td><pre>    void addAllForTreeSet(SortedSet&lt;? extends K&gt; set, V defaultVal) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2460" href="#"></a></td>
<td><pre>        try {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2461" href="#"></a></td>
<td><pre>            buildFromSorted(set.size(), set.iterator(), null, defaultVal);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2462" href="#"></a></td>
<td><pre>        } catch (java.io.IOException cannotHappen) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2463" href="#"></a></td>
<td><pre>        } catch (ClassNotFoundException cannotHappen) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2464" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2465" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2466" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2467" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2468" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2469" href="#"></a></td>
<td><pre>     * Linear time tree building algorithm from sorted data.  Can accept keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2470" href="#"></a></td>
<td><pre>     * and/or values from iterator or stream. This leads to too many</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2471" href="#"></a></td>
<td><pre>     * parameters, but seems better than alternatives.  The four formats</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2472" href="#"></a></td>
<td><pre>     * that this method accepts are:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2473" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2474" href="#"></a></td>
<td><pre>     *    1) An iterator of Map.Entries.  (it != null, defaultVal == null).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2475" href="#"></a></td>
<td><pre>     *    2) An iterator of keys.         (it != null, defaultVal != null).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2476" href="#"></a></td>
<td><pre>     *    3) A stream of alternating serialized keys and values.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2477" href="#"></a></td>
<td><pre>     *                                   (it == null, defaultVal == null).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2478" href="#"></a></td>
<td><pre>     *    4) A stream of serialized keys. (it == null, defaultVal != null).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2479" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2480" href="#"></a></td>
<td><pre>     * It is assumed that the comparator of the TreeMap is already set prior</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2481" href="#"></a></td>
<td><pre>     * to calling this method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2482" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2483" href="#"></a></td>
<td><pre>     * @param size the number of keys (or key-value pairs) to be read from</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2484" href="#"></a></td>
<td><pre>     *        the iterator or stream</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2485" href="#"></a></td>
<td><pre>     * @param it If non-null, new entries are created from entries</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2486" href="#"></a></td>
<td><pre>     *        or keys read from this iterator.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2487" href="#"></a></td>
<td><pre>     * @param str If non-null, new entries are created from keys and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2488" href="#"></a></td>
<td><pre>     *        possibly values read from this stream in serialized form.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2489" href="#"></a></td>
<td><pre>     *        Exactly one of it and str should be non-null.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2490" href="#"></a></td>
<td><pre>     * @param defaultVal if non-null, this default value is used for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2491" href="#"></a></td>
<td><pre>     *        each value in the map.  If null, each value is read from</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2492" href="#"></a></td>
<td><pre>     *        iterator or stream, as described above.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2493" href="#"></a></td>
<td><pre>     * @throws java.io.IOException propagated from stream reads. This cannot</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2494" href="#"></a></td>
<td><pre>     *         occur if str is null.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2495" href="#"></a></td>
<td><pre>     * @throws ClassNotFoundException propagated from readObject.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2496" href="#"></a></td>
<td><pre>     *         This cannot occur if str is null.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2497" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2498" href="#"></a></td>
<td><pre>    private void buildFromSorted(int size, Iterator&lt;?&gt; it,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2499" href="#"></a></td>
<td><pre>                                 java.io.ObjectInputStream str,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2500" href="#"></a></td>
<td><pre>                                 V defaultVal)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2501" href="#"></a></td>
<td><pre>        throws  java.io.IOException, ClassNotFoundException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2502" href="#"></a></td>
<td><pre>        this.size = size;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2503" href="#"></a></td>
<td><pre>        root = buildFromSorted(0, 0, size-1, computeRedLevel(size),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2504" href="#"></a></td>
<td><pre>                               it, str, defaultVal);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2505" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2506" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2507" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2508" href="#"></a></td>
<td><pre>     * Recursive &quot;helper method&quot; that does the real work of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2509" href="#"></a></td>
<td><pre>     * previous method.  Identically named parameters have</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2510" href="#"></a></td>
<td><pre>     * identical definitions.  Additional parameters are documented below.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2511" href="#"></a></td>
<td><pre>     * It is assumed that the comparator and size fields of the TreeMap are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2512" href="#"></a></td>
<td><pre>     * already set prior to calling this method.  (It ignores both fields.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2513" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2514" href="#"></a></td>
<td><pre>     * @param level the current level of tree. Initial call should be 0.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2515" href="#"></a></td>
<td><pre>     * @param lo the first element index of this subtree. Initial should be 0.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2516" href="#"></a></td>
<td><pre>     * @param hi the last element index of this subtree.  Initial should be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2517" href="#"></a></td>
<td><pre>     *        size-1.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2518" href="#"></a></td>
<td><pre>     * @param redLevel the level at which nodes should be red.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2519" href="#"></a></td>
<td><pre>     *        Must be equal to computeRedLevel for tree of this size.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2520" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2521" href="#"></a></td>
<td><pre>    @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2522" href="#"></a></td>
<td><pre>    private final Entry&lt;K,V&gt; buildFromSorted(int level, int lo, int hi,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2523" href="#"></a></td>
<td><pre>                                             int redLevel,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2524" href="#"></a></td>
<td><pre>                                             Iterator&lt;?&gt; it,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2525" href="#"></a></td>
<td><pre>                                             java.io.ObjectInputStream str,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2526" href="#"></a></td>
<td><pre>                                             V defaultVal)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2527" href="#"></a></td>
<td><pre>        throws  java.io.IOException, ClassNotFoundException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2528" href="#"></a></td>
<td><pre>        /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2529" href="#"></a></td>
<td><pre>         * Strategy: The root is the middlemost element. To get to it, we</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2530" href="#"></a></td>
<td><pre>         * have to first recursively construct the entire left subtree,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2531" href="#"></a></td>
<td><pre>         * so as to grab all of its elements. We can then proceed with right</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2532" href="#"></a></td>
<td><pre>         * subtree.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2533" href="#"></a></td>
<td><pre>         *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2534" href="#"></a></td>
<td><pre>         * The lo and hi arguments are the minimum and maximum</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2535" href="#"></a></td>
<td><pre>         * indices to pull out of the iterator or stream for current subtree.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2536" href="#"></a></td>
<td><pre>         * They are not actually indexed, we just proceed sequentially,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2537" href="#"></a></td>
<td><pre>         * ensuring that items are extracted in corresponding order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2538" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2539" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2540" href="#"></a></td>
<td><pre>        if (hi &lt; lo) return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2541" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2542" href="#"></a></td>
<td><pre>        int mid = (lo + hi) &gt;&gt;&gt; 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2543" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2544" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; left  = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2545" href="#"></a></td>
<td><pre>        if (lo &lt; mid)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2546" href="#"></a></td>
<td><pre>            left = buildFromSorted(level+1, lo, mid - 1, redLevel,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2547" href="#"></a></td>
<td><pre>                                   it, str, defaultVal);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2548" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2549" href="#"></a></td>
<td><pre>        // extract key and/or value from iterator or stream</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2550" href="#"></a></td>
<td><pre>        K key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2551" href="#"></a></td>
<td><pre>        V value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2552" href="#"></a></td>
<td><pre>        if (it != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2553" href="#"></a></td>
<td><pre>            if (defaultVal==null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2554" href="#"></a></td>
<td><pre>                Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)it.next();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2555" href="#"></a></td>
<td><pre>                key = (K)entry.getKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2556" href="#"></a></td>
<td><pre>                value = (V)entry.getValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2557" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2558" href="#"></a></td>
<td><pre>                key = (K)it.next();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2559" href="#"></a></td>
<td><pre>                value = defaultVal;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2560" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2561" href="#"></a></td>
<td><pre>        } else { // use stream</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2562" href="#"></a></td>
<td><pre>            key = (K) str.readObject();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2563" href="#"></a></td>
<td><pre>            value = (defaultVal != null ? defaultVal : (V) str.readObject());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2564" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2565" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2566" href="#"></a></td>
<td><pre>        Entry&lt;K,V&gt; middle =  new Entry&lt;&gt;(key, value, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2567" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2568" href="#"></a></td>
<td><pre>        // color nodes in non-full bottommost level red</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2569" href="#"></a></td>
<td><pre>        if (level == redLevel)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2570" href="#"></a></td>
<td><pre>            middle.color = RED;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2571" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2572" href="#"></a></td>
<td><pre>        if (left != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2573" href="#"></a></td>
<td><pre>            middle.left = left;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2574" href="#"></a></td>
<td><pre>            left.parent = middle;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2575" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2576" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2577" href="#"></a></td>
<td><pre>        if (mid &lt; hi) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2578" href="#"></a></td>
<td><pre>            Entry&lt;K,V&gt; right = buildFromSorted(level+1, mid+1, hi, redLevel,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2579" href="#"></a></td>
<td><pre>                                               it, str, defaultVal);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2580" href="#"></a></td>
<td><pre>            middle.right = right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2581" href="#"></a></td>
<td><pre>            right.parent = middle;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2582" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2583" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2584" href="#"></a></td>
<td><pre>        return middle;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2585" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2586" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2587" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2588" href="#"></a></td>
<td><pre>     * Find the level down to which to assign all nodes BLACK.  This is the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2589" href="#"></a></td>
<td><pre>     * last `full' level of the complete binary tree produced by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2590" href="#"></a></td>
<td><pre>     * buildTree. The remaining nodes are colored RED. (This makes a `nice'</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2591" href="#"></a></td>
<td><pre>     * set of color assignments wrt future insertions.) This level number is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2592" href="#"></a></td>
<td><pre>     * computed by finding the number of splits needed to reach the zeroeth</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2593" href="#"></a></td>
<td><pre>     * node.  (The answer is ~lg(N), but in any case must be computed by same</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2594" href="#"></a></td>
<td><pre>     * quick O(lg(N)) loop.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2595" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2596" href="#"></a></td>
<td><pre>    private static int computeRedLevel(int sz) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2597" href="#"></a></td>
<td><pre>        int level = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2598" href="#"></a></td>
<td><pre>        for (int m = sz - 1; m &gt;= 0; m = m / 2 - 1)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2599" href="#"></a></td>
<td><pre>            level++;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2600" href="#"></a></td>
<td><pre>        return level;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2601" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2602" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2603" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2604" href="#"></a></td>
<td><pre>     * Currently, we support Spliterator-based versions only for the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2605" href="#"></a></td>
<td><pre>     * full map, in either plain of descending form, otherwise relying</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2606" href="#"></a></td>
<td><pre>     * on defaults because size estimation for submaps would dominate</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2607" href="#"></a></td>
<td><pre>     * costs. The type tests needed to check these for key views are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2608" href="#"></a></td>
<td><pre>     * not very nice but avoid disrupting existing class</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2609" href="#"></a></td>
<td><pre>     * structures. Callers must use plain default spliterators if this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2610" href="#"></a></td>
<td><pre>     * returns null.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2611" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2612" href="#"></a></td>
<td><pre>    static &lt;K&gt; Spliterator&lt;K&gt; keySpliteratorFor(NavigableMap&lt;K,?&gt; m) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2613" href="#"></a></td>
<td><pre>        if (m instanceof TreeMap) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2614" href="#"></a></td>
<td><pre>            @SuppressWarnings(&quot;unchecked&quot;) TreeMap&lt;K,Object&gt; t =</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2615" href="#"></a></td>
<td><pre>                (TreeMap&lt;K,Object&gt;) m;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2616" href="#"></a></td>
<td><pre>            return t.keySpliterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2617" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2618" href="#"></a></td>
<td><pre>        if (m instanceof DescendingSubMap) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2619" href="#"></a></td>
<td><pre>            @SuppressWarnings(&quot;unchecked&quot;) DescendingSubMap&lt;K,?&gt; dm =</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2620" href="#"></a></td>
<td><pre>                (DescendingSubMap&lt;K,?&gt;) m;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2621" href="#"></a></td>
<td><pre>            TreeMap&lt;K,?&gt; tm = dm.m;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2622" href="#"></a></td>
<td><pre>            if (dm == tm.descendingMap) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2623" href="#"></a></td>
<td><pre>                @SuppressWarnings(&quot;unchecked&quot;) TreeMap&lt;K,Object&gt; t =</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2624" href="#"></a></td>
<td><pre>                    (TreeMap&lt;K,Object&gt;) tm;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2625" href="#"></a></td>
<td><pre>                return t.descendingKeySpliterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2626" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2627" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2628" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;unchecked&quot;) NavigableSubMap&lt;K,?&gt; sm =</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2629" href="#"></a></td>
<td><pre>            (NavigableSubMap&lt;K,?&gt;) m;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2630" href="#"></a></td>
<td><pre>        return sm.keySpliterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2631" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2632" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2633" href="#"></a></td>
<td><pre>    final Spliterator&lt;K&gt; keySpliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2634" href="#"></a></td>
<td><pre>        return new KeySpliterator&lt;K,V&gt;(this, null, null, 0, -1, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2635" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2636" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2637" href="#"></a></td>
<td><pre>    final Spliterator&lt;K&gt; descendingKeySpliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2638" href="#"></a></td>
<td><pre>        return new DescendingKeySpliterator&lt;K,V&gt;(this, null, null, 0, -2, 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2639" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2640" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2641" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2642" href="#"></a></td>
<td><pre>     * Base class for spliterators.  Iteration starts at a given</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2643" href="#"></a></td>
<td><pre>     * origin and continues up to but not including a given fence (or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2644" href="#"></a></td>
<td><pre>     * null for end).  At top-level, for ascending cases, the first</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2645" href="#"></a></td>
<td><pre>     * split uses the root as left-fence/right-origin. From there,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2646" href="#"></a></td>
<td><pre>     * right-hand splits replace the current fence with its left</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2647" href="#"></a></td>
<td><pre>     * child, also serving as origin for the split-off spliterator.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2648" href="#"></a></td>
<td><pre>     * Left-hands are symmetric. Descending versions place the origin</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2649" href="#"></a></td>
<td><pre>     * at the end and invert ascending split rules.  This base class</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2650" href="#"></a></td>
<td><pre>     * is non-commital about directionality, or whether the top-level</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2651" href="#"></a></td>
<td><pre>     * spliterator covers the whole tree. This means that the actual</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2652" href="#"></a></td>
<td><pre>     * split mechanics are located in subclasses. Some of the subclass</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2653" href="#"></a></td>
<td><pre>     * trySplit methods are identical (except for return types), but</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2654" href="#"></a></td>
<td><pre>     * not nicely factorable.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2655" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2656" href="#"></a></td>
<td><pre>     * Currently, subclass versions exist only for the full map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2657" href="#"></a></td>
<td><pre>     * (including descending keys via its descendingMap).  Others are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2658" href="#"></a></td>
<td><pre>     * possible but currently not worthwhile because submaps require</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2659" href="#"></a></td>
<td><pre>     * O(n) computations to determine size, which substantially limits</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2660" href="#"></a></td>
<td><pre>     * potential speed-ups of using custom Spliterators versus default</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2661" href="#"></a></td>
<td><pre>     * mechanics.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2662" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2663" href="#"></a></td>
<td><pre>     * To boostrap initialization, external constructors use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2664" href="#"></a></td>
<td><pre>     * negative size estimates: -1 for ascend, -2 for descend.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2665" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2666" href="#"></a></td>
<td><pre>    static class TreeMapSpliterator&lt;K,V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2667" href="#"></a></td>
<td><pre>        final TreeMap&lt;K,V&gt; tree;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2668" href="#"></a></td>
<td><pre>        TreeMap.Entry&lt;K,V&gt; current; // traverser; initially first node in range</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2669" href="#"></a></td>
<td><pre>        TreeMap.Entry&lt;K,V&gt; fence;   // one past last, or null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2670" href="#"></a></td>
<td><pre>        int side;                   // 0: top, -1: is a left split, +1: right</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2671" href="#"></a></td>
<td><pre>        int est;                    // size estimate (exact only for top-level)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2672" href="#"></a></td>
<td><pre>        int expectedModCount;       // for CME checks</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2673" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2674" href="#"></a></td>
<td><pre>        TreeMapSpliterator(TreeMap&lt;K,V&gt; tree,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2675" href="#"></a></td>
<td><pre>                           TreeMap.Entry&lt;K,V&gt; origin, TreeMap.Entry&lt;K,V&gt; fence,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2676" href="#"></a></td>
<td><pre>                           int side, int est, int expectedModCount) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2677" href="#"></a></td>
<td><pre>            this.tree = tree;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2678" href="#"></a></td>
<td><pre>            this.current = origin;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2679" href="#"></a></td>
<td><pre>            this.fence = fence;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2680" href="#"></a></td>
<td><pre>            this.side = side;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2681" href="#"></a></td>
<td><pre>            this.est = est;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2682" href="#"></a></td>
<td><pre>            this.expectedModCount = expectedModCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2683" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2684" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2685" href="#"></a></td>
<td><pre>        final int getEstimate() { // force initialization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2686" href="#"></a></td>
<td><pre>            int s; TreeMap&lt;K,V&gt; t;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2687" href="#"></a></td>
<td><pre>            if ((s = est) &lt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2688" href="#"></a></td>
<td><pre>                if ((t = tree) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2689" href="#"></a></td>
<td><pre>                    current = (s == -1) ? t.getFirstEntry() : t.getLastEntry();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2690" href="#"></a></td>
<td><pre>                    s = est = t.size;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2691" href="#"></a></td>
<td><pre>                    expectedModCount = t.modCount;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2692" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2693" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2694" href="#"></a></td>
<td><pre>                    s = est = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2695" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2696" href="#"></a></td>
<td><pre>            return s;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2697" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2698" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2699" href="#"></a></td>
<td><pre>        public final long estimateSize() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2700" href="#"></a></td>
<td><pre>            return (long)getEstimate();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2701" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2702" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2703" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2704" href="#"></a></td>
<td><pre>    static final class KeySpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2705" href="#"></a></td>
<td><pre>        extends TreeMapSpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2706" href="#"></a></td>
<td><pre>        implements Spliterator&lt;K&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2707" href="#"></a></td>
<td><pre>        KeySpliterator(TreeMap&lt;K,V&gt; tree,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2708" href="#"></a></td>
<td><pre>                       TreeMap.Entry&lt;K,V&gt; origin, TreeMap.Entry&lt;K,V&gt; fence,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2709" href="#"></a></td>
<td><pre>                       int side, int est, int expectedModCount) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2710" href="#"></a></td>
<td><pre>            super(tree, origin, fence, side, est, expectedModCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2711" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2712" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2713" href="#"></a></td>
<td><pre>        public KeySpliterator&lt;K,V&gt; trySplit() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2714" href="#"></a></td>
<td><pre>            if (est &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2715" href="#"></a></td>
<td><pre>                getEstimate(); // force initialization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2716" href="#"></a></td>
<td><pre>            int d = side;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2717" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e = current, f = fence,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2718" href="#"></a></td>
<td><pre>                s = ((e == null || e == f) ? null :      // empty</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2719" href="#"></a></td>
<td><pre>                     (d == 0)              ? tree.root : // was top</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2720" href="#"></a></td>
<td><pre>                     (d &gt;  0)              ? e.right :   // was right</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2721" href="#"></a></td>
<td><pre>                     (d &lt;  0 &amp;&amp; f != null) ? f.left :    // was left</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2722" href="#"></a></td>
<td><pre>                     null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2723" href="#"></a></td>
<td><pre>            if (s != null &amp;&amp; s != e &amp;&amp; s != f &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2724" href="#"></a></td>
<td><pre>                tree.compare(e.key, s.key) &lt; 0) {        // e not already past s</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2725" href="#"></a></td>
<td><pre>                side = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2726" href="#"></a></td>
<td><pre>                return new KeySpliterator&lt;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2727" href="#"></a></td>
<td><pre>                    (tree, e, current = s, -1, est &gt;&gt;&gt;= 1, expectedModCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2728" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2729" href="#"></a></td>
<td><pre>            return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2730" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2731" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2732" href="#"></a></td>
<td><pre>        public void forEachRemaining(Consumer&lt;? super K&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2733" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2734" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2735" href="#"></a></td>
<td><pre>            if (est &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2736" href="#"></a></td>
<td><pre>                getEstimate(); // force initialization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2737" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; f = fence, e, p, pl;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2738" href="#"></a></td>
<td><pre>            if ((e = current) != null &amp;&amp; e != f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2739" href="#"></a></td>
<td><pre>                current = f; // exhaust</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2740" href="#"></a></td>
<td><pre>                do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2741" href="#"></a></td>
<td><pre>                    action.accept(e.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2742" href="#"></a></td>
<td><pre>                    if ((p = e.right) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2743" href="#"></a></td>
<td><pre>                        while ((pl = p.left) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2744" href="#"></a></td>
<td><pre>                            p = pl;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2745" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2746" href="#"></a></td>
<td><pre>                    else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2747" href="#"></a></td>
<td><pre>                        while ((p = e.parent) != null &amp;&amp; e == p.right)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2748" href="#"></a></td>
<td><pre>                            e = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2749" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2750" href="#"></a></td>
<td><pre>                } while ((e = p) != null &amp;&amp; e != f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2751" href="#"></a></td>
<td><pre>                if (tree.modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2752" href="#"></a></td>
<td><pre>                    throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2753" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2754" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2755" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2756" href="#"></a></td>
<td><pre>        public boolean tryAdvance(Consumer&lt;? super K&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2757" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2758" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2759" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2760" href="#"></a></td>
<td><pre>            if (est &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2761" href="#"></a></td>
<td><pre>                getEstimate(); // force initialization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2762" href="#"></a></td>
<td><pre>            if ((e = current) == null || e == fence)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2763" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2764" href="#"></a></td>
<td><pre>            current = successor(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2765" href="#"></a></td>
<td><pre>            action.accept(e.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2766" href="#"></a></td>
<td><pre>            if (tree.modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2767" href="#"></a></td>
<td><pre>                throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2768" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2769" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2770" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2771" href="#"></a></td>
<td><pre>        public int characteristics() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2772" href="#"></a></td>
<td><pre>            return (side == 0 ? Spliterator.SIZED : 0) |</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2773" href="#"></a></td>
<td><pre>                Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2774" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2775" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2776" href="#"></a></td>
<td><pre>        public final Comparator&lt;? super K&gt;  getComparator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2777" href="#"></a></td>
<td><pre>            return tree.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2778" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2779" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2780" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2781" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2782" href="#"></a></td>
<td><pre>    static final class DescendingKeySpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2783" href="#"></a></td>
<td><pre>        extends TreeMapSpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2784" href="#"></a></td>
<td><pre>        implements Spliterator&lt;K&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2785" href="#"></a></td>
<td><pre>        DescendingKeySpliterator(TreeMap&lt;K,V&gt; tree,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2786" href="#"></a></td>
<td><pre>                                 TreeMap.Entry&lt;K,V&gt; origin, TreeMap.Entry&lt;K,V&gt; fence,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2787" href="#"></a></td>
<td><pre>                                 int side, int est, int expectedModCount) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2788" href="#"></a></td>
<td><pre>            super(tree, origin, fence, side, est, expectedModCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2789" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2790" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2791" href="#"></a></td>
<td><pre>        public DescendingKeySpliterator&lt;K,V&gt; trySplit() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2792" href="#"></a></td>
<td><pre>            if (est &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2793" href="#"></a></td>
<td><pre>                getEstimate(); // force initialization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2794" href="#"></a></td>
<td><pre>            int d = side;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2795" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e = current, f = fence,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2796" href="#"></a></td>
<td><pre>                    s = ((e == null || e == f) ? null :      // empty</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2797" href="#"></a></td>
<td><pre>                         (d == 0)              ? tree.root : // was top</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2798" href="#"></a></td>
<td><pre>                         (d &lt;  0)              ? e.left :    // was left</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2799" href="#"></a></td>
<td><pre>                         (d &gt;  0 &amp;&amp; f != null) ? f.right :   // was right</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2800" href="#"></a></td>
<td><pre>                         null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2801" href="#"></a></td>
<td><pre>            if (s != null &amp;&amp; s != e &amp;&amp; s != f &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2802" href="#"></a></td>
<td><pre>                tree.compare(e.key, s.key) &gt; 0) {       // e not already past s</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2803" href="#"></a></td>
<td><pre>                side = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2804" href="#"></a></td>
<td><pre>                return new DescendingKeySpliterator&lt;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2805" href="#"></a></td>
<td><pre>                        (tree, e, current = s, -1, est &gt;&gt;&gt;= 1, expectedModCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2806" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2807" href="#"></a></td>
<td><pre>            return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2808" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2809" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2810" href="#"></a></td>
<td><pre>        public void forEachRemaining(Consumer&lt;? super K&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2811" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2812" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2813" href="#"></a></td>
<td><pre>            if (est &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2814" href="#"></a></td>
<td><pre>                getEstimate(); // force initialization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2815" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; f = fence, e, p, pr;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2816" href="#"></a></td>
<td><pre>            if ((e = current) != null &amp;&amp; e != f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2817" href="#"></a></td>
<td><pre>                current = f; // exhaust</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2818" href="#"></a></td>
<td><pre>                do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2819" href="#"></a></td>
<td><pre>                    action.accept(e.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2820" href="#"></a></td>
<td><pre>                    if ((p = e.left) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2821" href="#"></a></td>
<td><pre>                        while ((pr = p.right) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2822" href="#"></a></td>
<td><pre>                            p = pr;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2823" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2824" href="#"></a></td>
<td><pre>                    else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2825" href="#"></a></td>
<td><pre>                        while ((p = e.parent) != null &amp;&amp; e == p.left)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2826" href="#"></a></td>
<td><pre>                            e = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2827" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2828" href="#"></a></td>
<td><pre>                } while ((e = p) != null &amp;&amp; e != f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2829" href="#"></a></td>
<td><pre>                if (tree.modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2830" href="#"></a></td>
<td><pre>                    throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2831" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2832" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2833" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2834" href="#"></a></td>
<td><pre>        public boolean tryAdvance(Consumer&lt;? super K&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2835" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2836" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2837" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2838" href="#"></a></td>
<td><pre>            if (est &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2839" href="#"></a></td>
<td><pre>                getEstimate(); // force initialization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2840" href="#"></a></td>
<td><pre>            if ((e = current) == null || e == fence)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2841" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2842" href="#"></a></td>
<td><pre>            current = predecessor(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2843" href="#"></a></td>
<td><pre>            action.accept(e.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2844" href="#"></a></td>
<td><pre>            if (tree.modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2845" href="#"></a></td>
<td><pre>                throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2846" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2847" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2848" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2849" href="#"></a></td>
<td><pre>        public int characteristics() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2850" href="#"></a></td>
<td><pre>            return (side == 0 ? Spliterator.SIZED : 0) |</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2851" href="#"></a></td>
<td><pre>                Spliterator.DISTINCT | Spliterator.ORDERED;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2852" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2853" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2854" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2855" href="#"></a></td>
<td><pre>    static final class ValueSpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2856" href="#"></a></td>
<td><pre>            extends TreeMapSpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2857" href="#"></a></td>
<td><pre>            implements Spliterator&lt;V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2858" href="#"></a></td>
<td><pre>        ValueSpliterator(TreeMap&lt;K,V&gt; tree,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2859" href="#"></a></td>
<td><pre>                         TreeMap.Entry&lt;K,V&gt; origin, TreeMap.Entry&lt;K,V&gt; fence,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2860" href="#"></a></td>
<td><pre>                         int side, int est, int expectedModCount) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2861" href="#"></a></td>
<td><pre>            super(tree, origin, fence, side, est, expectedModCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2862" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2863" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2864" href="#"></a></td>
<td><pre>        public ValueSpliterator&lt;K,V&gt; trySplit() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2865" href="#"></a></td>
<td><pre>            if (est &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2866" href="#"></a></td>
<td><pre>                getEstimate(); // force initialization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2867" href="#"></a></td>
<td><pre>            int d = side;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2868" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e = current, f = fence,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2869" href="#"></a></td>
<td><pre>                    s = ((e == null || e == f) ? null :      // empty</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2870" href="#"></a></td>
<td><pre>                         (d == 0)              ? tree.root : // was top</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2871" href="#"></a></td>
<td><pre>                         (d &gt;  0)              ? e.right :   // was right</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2872" href="#"></a></td>
<td><pre>                         (d &lt;  0 &amp;&amp; f != null) ? f.left :    // was left</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2873" href="#"></a></td>
<td><pre>                         null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2874" href="#"></a></td>
<td><pre>            if (s != null &amp;&amp; s != e &amp;&amp; s != f &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2875" href="#"></a></td>
<td><pre>                tree.compare(e.key, s.key) &lt; 0) {        // e not already past s</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2876" href="#"></a></td>
<td><pre>                side = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2877" href="#"></a></td>
<td><pre>                return new ValueSpliterator&lt;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2878" href="#"></a></td>
<td><pre>                        (tree, e, current = s, -1, est &gt;&gt;&gt;= 1, expectedModCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2879" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2880" href="#"></a></td>
<td><pre>            return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2881" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2882" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2883" href="#"></a></td>
<td><pre>        public void forEachRemaining(Consumer&lt;? super V&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2884" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2885" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2886" href="#"></a></td>
<td><pre>            if (est &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2887" href="#"></a></td>
<td><pre>                getEstimate(); // force initialization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2888" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; f = fence, e, p, pl;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2889" href="#"></a></td>
<td><pre>            if ((e = current) != null &amp;&amp; e != f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2890" href="#"></a></td>
<td><pre>                current = f; // exhaust</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2891" href="#"></a></td>
<td><pre>                do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2892" href="#"></a></td>
<td><pre>                    action.accept(e.value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2893" href="#"></a></td>
<td><pre>                    if ((p = e.right) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2894" href="#"></a></td>
<td><pre>                        while ((pl = p.left) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2895" href="#"></a></td>
<td><pre>                            p = pl;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2896" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2897" href="#"></a></td>
<td><pre>                    else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2898" href="#"></a></td>
<td><pre>                        while ((p = e.parent) != null &amp;&amp; e == p.right)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2899" href="#"></a></td>
<td><pre>                            e = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2900" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2901" href="#"></a></td>
<td><pre>                } while ((e = p) != null &amp;&amp; e != f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2902" href="#"></a></td>
<td><pre>                if (tree.modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2903" href="#"></a></td>
<td><pre>                    throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2904" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2905" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2906" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2907" href="#"></a></td>
<td><pre>        public boolean tryAdvance(Consumer&lt;? super V&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2908" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2909" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2910" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2911" href="#"></a></td>
<td><pre>            if (est &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2912" href="#"></a></td>
<td><pre>                getEstimate(); // force initialization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2913" href="#"></a></td>
<td><pre>            if ((e = current) == null || e == fence)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2914" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2915" href="#"></a></td>
<td><pre>            current = successor(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2916" href="#"></a></td>
<td><pre>            action.accept(e.value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2917" href="#"></a></td>
<td><pre>            if (tree.modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2918" href="#"></a></td>
<td><pre>                throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2919" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2920" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2921" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2922" href="#"></a></td>
<td><pre>        public int characteristics() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2923" href="#"></a></td>
<td><pre>            return (side == 0 ? Spliterator.SIZED : 0) | Spliterator.ORDERED;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2924" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2925" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2926" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2927" href="#"></a></td>
<td><pre>    static final class EntrySpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2928" href="#"></a></td>
<td><pre>        extends TreeMapSpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2929" href="#"></a></td>
<td><pre>        implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2930" href="#"></a></td>
<td><pre>        EntrySpliterator(TreeMap&lt;K,V&gt; tree,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2931" href="#"></a></td>
<td><pre>                         TreeMap.Entry&lt;K,V&gt; origin, TreeMap.Entry&lt;K,V&gt; fence,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2932" href="#"></a></td>
<td><pre>                         int side, int est, int expectedModCount) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2933" href="#"></a></td>
<td><pre>            super(tree, origin, fence, side, est, expectedModCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2934" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2935" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2936" href="#"></a></td>
<td><pre>        public EntrySpliterator&lt;K,V&gt; trySplit() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2937" href="#"></a></td>
<td><pre>            if (est &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2938" href="#"></a></td>
<td><pre>                getEstimate(); // force initialization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2939" href="#"></a></td>
<td><pre>            int d = side;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2940" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e = current, f = fence,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2941" href="#"></a></td>
<td><pre>                    s = ((e == null || e == f) ? null :      // empty</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2942" href="#"></a></td>
<td><pre>                         (d == 0)              ? tree.root : // was top</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2943" href="#"></a></td>
<td><pre>                         (d &gt;  0)              ? e.right :   // was right</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2944" href="#"></a></td>
<td><pre>                         (d &lt;  0 &amp;&amp; f != null) ? f.left :    // was left</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2945" href="#"></a></td>
<td><pre>                         null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2946" href="#"></a></td>
<td><pre>            if (s != null &amp;&amp; s != e &amp;&amp; s != f &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2947" href="#"></a></td>
<td><pre>                tree.compare(e.key, s.key) &lt; 0) {        // e not already past s</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2948" href="#"></a></td>
<td><pre>                side = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2949" href="#"></a></td>
<td><pre>                return new EntrySpliterator&lt;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2950" href="#"></a></td>
<td><pre>                        (tree, e, current = s, -1, est &gt;&gt;&gt;= 1, expectedModCount);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2951" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2952" href="#"></a></td>
<td><pre>            return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2953" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2954" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2955" href="#"></a></td>
<td><pre>        public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K, V&gt;&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2956" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2957" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2958" href="#"></a></td>
<td><pre>            if (est &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2959" href="#"></a></td>
<td><pre>                getEstimate(); // force initialization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2960" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; f = fence, e, p, pl;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2961" href="#"></a></td>
<td><pre>            if ((e = current) != null &amp;&amp; e != f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2962" href="#"></a></td>
<td><pre>                current = f; // exhaust</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2963" href="#"></a></td>
<td><pre>                do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2964" href="#"></a></td>
<td><pre>                    action.accept(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2965" href="#"></a></td>
<td><pre>                    if ((p = e.right) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2966" href="#"></a></td>
<td><pre>                        while ((pl = p.left) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2967" href="#"></a></td>
<td><pre>                            p = pl;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2968" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2969" href="#"></a></td>
<td><pre>                    else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2970" href="#"></a></td>
<td><pre>                        while ((p = e.parent) != null &amp;&amp; e == p.right)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2971" href="#"></a></td>
<td><pre>                            e = p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2972" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2973" href="#"></a></td>
<td><pre>                } while ((e = p) != null &amp;&amp; e != f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2974" href="#"></a></td>
<td><pre>                if (tree.modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2975" href="#"></a></td>
<td><pre>                    throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2976" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2977" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2978" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2979" href="#"></a></td>
<td><pre>        public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2980" href="#"></a></td>
<td><pre>            TreeMap.Entry&lt;K,V&gt; e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2981" href="#"></a></td>
<td><pre>            if (action == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2982" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2983" href="#"></a></td>
<td><pre>            if (est &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2984" href="#"></a></td>
<td><pre>                getEstimate(); // force initialization</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2985" href="#"></a></td>
<td><pre>            if ((e = current) == null || e == fence)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2986" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2987" href="#"></a></td>
<td><pre>            current = successor(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2988" href="#"></a></td>
<td><pre>            action.accept(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2989" href="#"></a></td>
<td><pre>            if (tree.modCount != expectedModCount)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2990" href="#"></a></td>
<td><pre>                throw new ConcurrentModificationException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2991" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2992" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2993" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2994" href="#"></a></td>
<td><pre>        public int characteristics() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2995" href="#"></a></td>
<td><pre>            return (side == 0 ? Spliterator.SIZED : 0) |</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2996" href="#"></a></td>
<td><pre>                    Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2997" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2998" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2999" href="#"></a></td>
<td><pre>        @Override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3000" href="#"></a></td>
<td><pre>        public Comparator&lt;Map.Entry&lt;K, V&gt;&gt; getComparator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3001" href="#"></a></td>
<td><pre>            // Adapt or create a key-based comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3002" href="#"></a></td>
<td><pre>            if (tree.comparator != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3003" href="#"></a></td>
<td><pre>                return Map.Entry.comparingByKey(tree.comparator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3004" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3005" href="#"></a></td>
<td><pre>            else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3006" href="#"></a></td>
<td><pre>                return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (e1, e2) -&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3007" href="#"></a></td>
<td><pre>                    @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3008" href="#"></a></td>
<td><pre>                    Comparable&lt;? super K&gt; k1 = (Comparable&lt;? super K&gt;) e1.getKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3009" href="#"></a></td>
<td><pre>                    return k1.compareTo(e2.getKey());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3010" href="#"></a></td>
<td><pre>                };</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3011" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3012" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3013" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3014" href="#"></a></td>
<td><pre>}</pre></td>
</tr>
</table>
</body>
</html>
