<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<table>
<tr>
<td><a class="linenum-cell" data-linenum="1" href="#"></a></td>
<td><pre>/*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2" href="#"></a></td>
<td><pre> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="4" href="#"></a></td>
<td><pre> * This code is free software; you can redistribute it and/or modify it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="5" href="#"></a></td>
<td><pre> * under the terms of the GNU General Public License version 2 only, as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="6" href="#"></a></td>
<td><pre> * published by the Free Software Foundation.  Oracle designates this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="7" href="#"></a></td>
<td><pre> * particular file as subject to the &quot;Classpath&quot; exception as provided</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="8" href="#"></a></td>
<td><pre> * by Oracle in the LICENSE file that accompanied this code.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="9" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="10" href="#"></a></td>
<td><pre> * This code is distributed in the hope that it will be useful, but WITHOUT</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="11" href="#"></a></td>
<td><pre> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="12" href="#"></a></td>
<td><pre> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="13" href="#"></a></td>
<td><pre> * version 2 for more details (a copy is included in the LICENSE file that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="14" href="#"></a></td>
<td><pre> * accompanied this code).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="15" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="16" href="#"></a></td>
<td><pre> * You should have received a copy of the GNU General Public License version</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="17" href="#"></a></td>
<td><pre> * 2 along with this work; if not, write to the Free Software Foundation,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="18" href="#"></a></td>
<td><pre> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="19" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="20" href="#"></a></td>
<td><pre> * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="21" href="#"></a></td>
<td><pre> * or visit www.oracle.com if you need additional information or have any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="22" href="#"></a></td>
<td><pre> * questions.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="23" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="24" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="25" href="#"></a></td>
<td><pre>/*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="26" href="#"></a></td>
<td><pre> * This file is available under and governed by the GNU General Public</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="27" href="#"></a></td>
<td><pre> * License version 2 only, as published by the Free Software Foundation.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="28" href="#"></a></td>
<td><pre> * However, the following notice accompanied the original version of this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="29" href="#"></a></td>
<td><pre> * file:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="30" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="31" href="#"></a></td>
<td><pre> * Written by Doug Lea with assistance from members of JCP JSR-166</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="32" href="#"></a></td>
<td><pre> * Expert Group and released to the public domain, as explained at</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="33" href="#"></a></td>
<td><pre> * http://creativecommons.org/publicdomain/zero/1.0/</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="34" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="35" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="36" href="#"></a></td>
<td><pre>package java.util.concurrent;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="37" href="#"></a></td>
<td><pre>import java.io.Serializable;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="38" href="#"></a></td>
<td><pre>import java.util.AbstractCollection;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="39" href="#"></a></td>
<td><pre>import java.util.AbstractMap;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="40" href="#"></a></td>
<td><pre>import java.util.AbstractSet;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="41" href="#"></a></td>
<td><pre>import java.util.ArrayList;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="42" href="#"></a></td>
<td><pre>import java.util.Collection;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="43" href="#"></a></td>
<td><pre>import java.util.Collections;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="44" href="#"></a></td>
<td><pre>import java.util.Comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="45" href="#"></a></td>
<td><pre>import java.util.Iterator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="46" href="#"></a></td>
<td><pre>import java.util.List;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="47" href="#"></a></td>
<td><pre>import java.util.Map;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="48" href="#"></a></td>
<td><pre>import java.util.NavigableMap;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="49" href="#"></a></td>
<td><pre>import java.util.NavigableSet;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="50" href="#"></a></td>
<td><pre>import java.util.NoSuchElementException;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="51" href="#"></a></td>
<td><pre>import java.util.Set;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="52" href="#"></a></td>
<td><pre>import java.util.SortedMap;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="53" href="#"></a></td>
<td><pre>import java.util.SortedSet;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="54" href="#"></a></td>
<td><pre>import java.util.Spliterator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="55" href="#"></a></td>
<td><pre>import java.util.concurrent.ConcurrentMap;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="56" href="#"></a></td>
<td><pre>import java.util.concurrent.ConcurrentNavigableMap;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="57" href="#"></a></td>
<td><pre>import java.util.function.BiFunction;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="58" href="#"></a></td>
<td><pre>import java.util.function.Consumer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="59" href="#"></a></td>
<td><pre>import java.util.function.BiConsumer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="60" href="#"></a></td>
<td><pre>import java.util.function.Function;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="61" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="62" href="#"></a></td>
<td><pre>/**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="63" href="#"></a></td>
<td><pre> * A scalable concurrent {@link ConcurrentNavigableMap} implementation.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="64" href="#"></a></td>
<td><pre> * The map is sorted according to the {@linkplain Comparable natural</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="65" href="#"></a></td>
<td><pre> * ordering} of its keys, or by a {@link Comparator} provided at map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="66" href="#"></a></td>
<td><pre> * creation time, depending on which constructor is used.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="67" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="68" href="#"></a></td>
<td><pre> * &lt;p&gt;This class implements a concurrent variant of &lt;a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="69" href="#"></a></td>
<td><pre> * href=&quot;http://en.wikipedia.org/wiki/Skip_list&quot; target=&quot;_top&quot;&gt;SkipLists&lt;/a&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="70" href="#"></a></td>
<td><pre> * providing expected average &lt;i&gt;log(n)&lt;/i&gt; time cost for the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="71" href="#"></a></td>
<td><pre> * {@code containsKey}, {@code get}, {@code put} and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="72" href="#"></a></td>
<td><pre> * {@code remove} operations and their variants.  Insertion, removal,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="73" href="#"></a></td>
<td><pre> * update, and access operations safely execute concurrently by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="74" href="#"></a></td>
<td><pre> * multiple threads.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="75" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="76" href="#"></a></td>
<td><pre> * &lt;p&gt;Iterators and spliterators are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="77" href="#"></a></td>
<td><pre> * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="78" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="79" href="#"></a></td>
<td><pre> * &lt;p&gt;Ascending key ordered views and their iterators are faster than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="80" href="#"></a></td>
<td><pre> * descending ones.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="81" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="82" href="#"></a></td>
<td><pre> * &lt;p&gt;All {@code Map.Entry} pairs returned by methods in this class</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="83" href="#"></a></td>
<td><pre> * and its views represent snapshots of mappings at the time they were</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="84" href="#"></a></td>
<td><pre> * produced. They do &lt;em&gt;not&lt;/em&gt; support the {@code Entry.setValue}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="85" href="#"></a></td>
<td><pre> * method. (Note however that it is possible to change mappings in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="86" href="#"></a></td>
<td><pre> * associated map using {@code put}, {@code putIfAbsent}, or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="87" href="#"></a></td>
<td><pre> * {@code replace}, depending on exactly which effect you need.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="88" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="89" href="#"></a></td>
<td><pre> * &lt;p&gt;Beware that, unlike in most collections, the {@code size}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="90" href="#"></a></td>
<td><pre> * method is &lt;em&gt;not&lt;/em&gt; a constant-time operation. Because of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="91" href="#"></a></td>
<td><pre> * asynchronous nature of these maps, determining the current number</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="92" href="#"></a></td>
<td><pre> * of elements requires a traversal of the elements, and so may report</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="93" href="#"></a></td>
<td><pre> * inaccurate results if this collection is modified during traversal.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="94" href="#"></a></td>
<td><pre> * Additionally, the bulk operations {@code putAll}, {@code equals},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="95" href="#"></a></td>
<td><pre> * {@code toArray}, {@code containsValue}, and {@code clear} are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="96" href="#"></a></td>
<td><pre> * &lt;em&gt;not&lt;/em&gt; guaranteed to be performed atomically. For example, an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="97" href="#"></a></td>
<td><pre> * iterator operating concurrently with a {@code putAll} operation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="98" href="#"></a></td>
<td><pre> * might view only some of the added elements.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="99" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="100" href="#"></a></td>
<td><pre> * &lt;p&gt;This class and its views and iterators implement all of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="101" href="#"></a></td>
<td><pre> * &lt;em&gt;optional&lt;/em&gt; methods of the {@link Map} and {@link Iterator}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="102" href="#"></a></td>
<td><pre> * interfaces. Like most other concurrent collections, this class does</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="103" href="#"></a></td>
<td><pre> * &lt;em&gt;not&lt;/em&gt; permit the use of {@code null} keys or values because some</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="104" href="#"></a></td>
<td><pre> * null return values cannot be reliably distinguished from the absence of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="105" href="#"></a></td>
<td><pre> * elements.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="106" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="107" href="#"></a></td>
<td><pre> * &lt;p&gt;This class is a member of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="108" href="#"></a></td>
<td><pre> * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="109" href="#"></a></td>
<td><pre> * Java Collections Framework&lt;/a&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="110" href="#"></a></td>
<td><pre> *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="111" href="#"></a></td>
<td><pre> * @author Doug Lea</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="112" href="#"></a></td>
<td><pre> * @param &lt;K&gt; the type of keys maintained by this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="113" href="#"></a></td>
<td><pre> * @param &lt;V&gt; the type of mapped values</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="114" href="#"></a></td>
<td><pre> * @since 1.6</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="115" href="#"></a></td>
<td><pre> */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="116" href="#"></a></td>
<td><pre>public class ConcurrentSkipListMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="117" href="#"></a></td>
<td><pre>    implements ConcurrentNavigableMap&lt;K,V&gt;, Cloneable, Serializable {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="118" href="#"></a></td>
<td><pre>    /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="119" href="#"></a></td>
<td><pre>     * This class implements a tree-like two-dimensionally linked skip</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="120" href="#"></a></td>
<td><pre>     * list in which the index levels are represented in separate</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="121" href="#"></a></td>
<td><pre>     * nodes from the base nodes holding data.  There are two reasons</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="122" href="#"></a></td>
<td><pre>     * for taking this approach instead of the usual array-based</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="123" href="#"></a></td>
<td><pre>     * structure: 1) Array based implementations seem to encounter</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="124" href="#"></a></td>
<td><pre>     * more complexity and overhead 2) We can use cheaper algorithms</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="125" href="#"></a></td>
<td><pre>     * for the heavily-traversed index lists than can be used for the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="126" href="#"></a></td>
<td><pre>     * base lists.  Here's a picture of some of the basics for a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="127" href="#"></a></td>
<td><pre>     * possible list with 2 levels of index:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="128" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="129" href="#"></a></td>
<td><pre>     * Head nodes          Index nodes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="130" href="#"></a></td>
<td><pre>     * +-+    right        +-+                      +-+</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="131" href="#"></a></td>
<td><pre>     * |2|----------------&gt;| |---------------------&gt;| |-&gt;null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="132" href="#"></a></td>
<td><pre>     * +-+                 +-+                      +-+</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="133" href="#"></a></td>
<td><pre>     *  | down              |                        |</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="134" href="#"></a></td>
<td><pre>     *  v                   v                        v</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="135" href="#"></a></td>
<td><pre>     * +-+            +-+  +-+       +-+            +-+       +-+</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="136" href="#"></a></td>
<td><pre>     * |1|-----------&gt;| |-&gt;| |------&gt;| |-----------&gt;| |------&gt;| |-&gt;null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="137" href="#"></a></td>
<td><pre>     * +-+            +-+  +-+       +-+            +-+       +-+</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="138" href="#"></a></td>
<td><pre>     *  v              |    |         |              |         |</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="139" href="#"></a></td>
<td><pre>     * Nodes  next     v    v         v              v         v</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="140" href="#"></a></td>
<td><pre>     * +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="141" href="#"></a></td>
<td><pre>     * | |-&gt;|A|-&gt;|B|-&gt;|C|-&gt;|D|-&gt;|E|-&gt;|F|-&gt;|G|-&gt;|H|-&gt;|I|-&gt;|J|-&gt;|K|-&gt;null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="142" href="#"></a></td>
<td><pre>     * +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="143" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="144" href="#"></a></td>
<td><pre>     * The base lists use a variant of the HM linked ordered set</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="145" href="#"></a></td>
<td><pre>     * algorithm. See Tim Harris, &quot;A pragmatic implementation of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="146" href="#"></a></td>
<td><pre>     * non-blocking linked lists&quot;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="147" href="#"></a></td>
<td><pre>     * http://www.cl.cam.ac.uk/~tlh20/publications.html and Maged</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="148" href="#"></a></td>
<td><pre>     * Michael &quot;High Performance Dynamic Lock-Free Hash Tables and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="149" href="#"></a></td>
<td><pre>     * List-Based Sets&quot;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="150" href="#"></a></td>
<td><pre>     * http://www.research.ibm.com/people/m/michael/pubs.htm.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="151" href="#"></a></td>
<td><pre>     * basic idea in these lists is to mark the &quot;next&quot; pointers of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="152" href="#"></a></td>
<td><pre>     * deleted nodes when deleting to avoid conflicts with concurrent</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="153" href="#"></a></td>
<td><pre>     * insertions, and when traversing to keep track of triples</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="154" href="#"></a></td>
<td><pre>     * (predecessor, node, successor) in order to detect when and how</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="155" href="#"></a></td>
<td><pre>     * to unlink these deleted nodes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="156" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="157" href="#"></a></td>
<td><pre>     * Rather than using mark-bits to mark list deletions (which can</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="158" href="#"></a></td>
<td><pre>     * be slow and space-intensive using AtomicMarkedReference), nodes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="159" href="#"></a></td>
<td><pre>     * use direct CAS'able next pointers.  On deletion, instead of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="160" href="#"></a></td>
<td><pre>     * marking a pointer, they splice in another node that can be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="161" href="#"></a></td>
<td><pre>     * thought of as standing for a marked pointer (indicating this by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="162" href="#"></a></td>
<td><pre>     * using otherwise impossible field values).  Using plain nodes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="163" href="#"></a></td>
<td><pre>     * acts roughly like &quot;boxed&quot; implementations of marked pointers,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="164" href="#"></a></td>
<td><pre>     * but uses new nodes only when nodes are deleted, not for every</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="165" href="#"></a></td>
<td><pre>     * link.  This requires less space and supports faster</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="166" href="#"></a></td>
<td><pre>     * traversal. Even if marked references were better supported by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="167" href="#"></a></td>
<td><pre>     * JVMs, traversal using this technique might still be faster</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="168" href="#"></a></td>
<td><pre>     * because any search need only read ahead one more node than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="169" href="#"></a></td>
<td><pre>     * otherwise required (to check for trailing marker) rather than</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="170" href="#"></a></td>
<td><pre>     * unmasking mark bits or whatever on each read.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="171" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="172" href="#"></a></td>
<td><pre>     * This approach maintains the essential property needed in the HM</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="173" href="#"></a></td>
<td><pre>     * algorithm of changing the next-pointer of a deleted node so</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="174" href="#"></a></td>
<td><pre>     * that any other CAS of it will fail, but implements the idea by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="175" href="#"></a></td>
<td><pre>     * changing the pointer to point to a different node, not by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="176" href="#"></a></td>
<td><pre>     * marking it.  While it would be possible to further squeeze</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="177" href="#"></a></td>
<td><pre>     * space by defining marker nodes not to have key/value fields, it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="178" href="#"></a></td>
<td><pre>     * isn't worth the extra type-testing overhead.  The deletion</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="179" href="#"></a></td>
<td><pre>     * markers are rarely encountered during traversal and are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="180" href="#"></a></td>
<td><pre>     * normally quickly garbage collected. (Note that this technique</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="181" href="#"></a></td>
<td><pre>     * would not work well in systems without garbage collection.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="182" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="183" href="#"></a></td>
<td><pre>     * In addition to using deletion markers, the lists also use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="184" href="#"></a></td>
<td><pre>     * nullness of value fields to indicate deletion, in a style</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="185" href="#"></a></td>
<td><pre>     * similar to typical lazy-deletion schemes.  If a node's value is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="186" href="#"></a></td>
<td><pre>     * null, then it is considered logically deleted and ignored even</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="187" href="#"></a></td>
<td><pre>     * though it is still reachable. This maintains proper control of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="188" href="#"></a></td>
<td><pre>     * concurrent replace vs delete operations -- an attempted replace</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="189" href="#"></a></td>
<td><pre>     * must fail if a delete beat it by nulling field, and a delete</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="190" href="#"></a></td>
<td><pre>     * must return the last non-null value held in the field. (Note:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="191" href="#"></a></td>
<td><pre>     * Null, rather than some special marker, is used for value fields</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="192" href="#"></a></td>
<td><pre>     * here because it just so happens to mesh with the Map API</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="193" href="#"></a></td>
<td><pre>     * requirement that method get returns null if there is no</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="194" href="#"></a></td>
<td><pre>     * mapping, which allows nodes to remain concurrently readable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="195" href="#"></a></td>
<td><pre>     * even when deleted. Using any other marker value here would be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="196" href="#"></a></td>
<td><pre>     * messy at best.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="197" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="198" href="#"></a></td>
<td><pre>     * Here's the sequence of events for a deletion of node n with</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="199" href="#"></a></td>
<td><pre>     * predecessor b and successor f, initially:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="200" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="201" href="#"></a></td>
<td><pre>     *        +------+       +------+      +------+</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="202" href="#"></a></td>
<td><pre>     *   ...  |   b  |------&gt;|   n  |-----&gt;|   f  | ...</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="203" href="#"></a></td>
<td><pre>     *        +------+       +------+      +------+</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="204" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="205" href="#"></a></td>
<td><pre>     * 1. CAS n's value field from non-null to null.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="206" href="#"></a></td>
<td><pre>     *    From this point on, no public operations encountering</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="207" href="#"></a></td>
<td><pre>     *    the node consider this mapping to exist. However, other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="208" href="#"></a></td>
<td><pre>     *    ongoing insertions and deletions might still modify</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="209" href="#"></a></td>
<td><pre>     *    n's next pointer.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="210" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="211" href="#"></a></td>
<td><pre>     * 2. CAS n's next pointer to point to a new marker node.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="212" href="#"></a></td>
<td><pre>     *    From this point on, no other nodes can be appended to n.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="213" href="#"></a></td>
<td><pre>     *    which avoids deletion errors in CAS-based linked lists.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="214" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="215" href="#"></a></td>
<td><pre>     *        +------+       +------+      +------+       +------+</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="216" href="#"></a></td>
<td><pre>     *   ...  |   b  |------&gt;|   n  |-----&gt;|marker|------&gt;|   f  | ...</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="217" href="#"></a></td>
<td><pre>     *        +------+       +------+      +------+       +------+</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="218" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="219" href="#"></a></td>
<td><pre>     * 3. CAS b's next pointer over both n and its marker.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="220" href="#"></a></td>
<td><pre>     *    From this point on, no new traversals will encounter n,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="221" href="#"></a></td>
<td><pre>     *    and it can eventually be GCed.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="222" href="#"></a></td>
<td><pre>     *        +------+                                    +------+</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="223" href="#"></a></td>
<td><pre>     *   ...  |   b  |-----------------------------------&gt;|   f  | ...</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="224" href="#"></a></td>
<td><pre>     *        +------+                                    +------+</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="225" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="226" href="#"></a></td>
<td><pre>     * A failure at step 1 leads to simple retry due to a lost race</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="227" href="#"></a></td>
<td><pre>     * with another operation. Steps 2-3 can fail because some other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="228" href="#"></a></td>
<td><pre>     * thread noticed during a traversal a node with null value and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="229" href="#"></a></td>
<td><pre>     * helped out by marking and/or unlinking.  This helping-out</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="230" href="#"></a></td>
<td><pre>     * ensures that no thread can become stuck waiting for progress of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="231" href="#"></a></td>
<td><pre>     * the deleting thread.  The use of marker nodes slightly</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="232" href="#"></a></td>
<td><pre>     * complicates helping-out code because traversals must track</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="233" href="#"></a></td>
<td><pre>     * consistent reads of up to four nodes (b, n, marker, f), not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="234" href="#"></a></td>
<td><pre>     * just (b, n, f), although the next field of a marker is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="235" href="#"></a></td>
<td><pre>     * immutable, and once a next field is CAS'ed to point to a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="236" href="#"></a></td>
<td><pre>     * marker, it never again changes, so this requires less care.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="237" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="238" href="#"></a></td>
<td><pre>     * Skip lists add indexing to this scheme, so that the base-level</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="239" href="#"></a></td>
<td><pre>     * traversals start close to the locations being found, inserted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="240" href="#"></a></td>
<td><pre>     * or deleted -- usually base level traversals only traverse a few</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="241" href="#"></a></td>
<td><pre>     * nodes. This doesn't change the basic algorithm except for the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="242" href="#"></a></td>
<td><pre>     * need to make sure base traversals start at predecessors (here,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="243" href="#"></a></td>
<td><pre>     * b) that are not (structurally) deleted, otherwise retrying</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="244" href="#"></a></td>
<td><pre>     * after processing the deletion.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="245" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="246" href="#"></a></td>
<td><pre>     * Index levels are maintained as lists with volatile next fields,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="247" href="#"></a></td>
<td><pre>     * using CAS to link and unlink.  Races are allowed in index-list</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="248" href="#"></a></td>
<td><pre>     * operations that can (rarely) fail to link in a new index node</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="249" href="#"></a></td>
<td><pre>     * or delete one. (We can't do this of course for data nodes.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="250" href="#"></a></td>
<td><pre>     * However, even when this happens, the index lists remain sorted,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="251" href="#"></a></td>
<td><pre>     * so correctly serve as indices.  This can impact performance,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="252" href="#"></a></td>
<td><pre>     * but since skip lists are probabilistic anyway, the net result</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="253" href="#"></a></td>
<td><pre>     * is that under contention, the effective &quot;p&quot; value may be lower</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="254" href="#"></a></td>
<td><pre>     * than its nominal value. And race windows are kept small enough</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="255" href="#"></a></td>
<td><pre>     * that in practice these failures are rare, even under a lot of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="256" href="#"></a></td>
<td><pre>     * contention.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="257" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="258" href="#"></a></td>
<td><pre>     * The fact that retries (for both base and index lists) are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="259" href="#"></a></td>
<td><pre>     * relatively cheap due to indexing allows some minor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="260" href="#"></a></td>
<td><pre>     * simplifications of retry logic. Traversal restarts are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="261" href="#"></a></td>
<td><pre>     * performed after most &quot;helping-out&quot; CASes. This isn't always</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="262" href="#"></a></td>
<td><pre>     * strictly necessary, but the implicit backoffs tend to help</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="263" href="#"></a></td>
<td><pre>     * reduce other downstream failed CAS's enough to outweigh restart</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="264" href="#"></a></td>
<td><pre>     * cost.  This worsens the worst case, but seems to improve even</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="265" href="#"></a></td>
<td><pre>     * highly contended cases.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="266" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="267" href="#"></a></td>
<td><pre>     * Unlike most skip-list implementations, index insertion and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="268" href="#"></a></td>
<td><pre>     * deletion here require a separate traversal pass occurring after</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="269" href="#"></a></td>
<td><pre>     * the base-level action, to add or remove index nodes.  This adds</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="270" href="#"></a></td>
<td><pre>     * to single-threaded overhead, but improves contended</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="271" href="#"></a></td>
<td><pre>     * multithreaded performance by narrowing interference windows,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="272" href="#"></a></td>
<td><pre>     * and allows deletion to ensure that all index nodes will be made</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="273" href="#"></a></td>
<td><pre>     * unreachable upon return from a public remove operation, thus</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="274" href="#"></a></td>
<td><pre>     * avoiding unwanted garbage retention. This is more important</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="275" href="#"></a></td>
<td><pre>     * here than in some other data structures because we cannot null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="276" href="#"></a></td>
<td><pre>     * out node fields referencing user keys since they might still be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="277" href="#"></a></td>
<td><pre>     * read by other ongoing traversals.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="278" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="279" href="#"></a></td>
<td><pre>     * Indexing uses skip list parameters that maintain good search</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="280" href="#"></a></td>
<td><pre>     * performance while using sparser-than-usual indices: The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="281" href="#"></a></td>
<td><pre>     * hardwired parameters k=1, p=0.5 (see method doPut) mean</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="282" href="#"></a></td>
<td><pre>     * that about one-quarter of the nodes have indices. Of those that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="283" href="#"></a></td>
<td><pre>     * do, half have one level, a quarter have two, and so on (see</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="284" href="#"></a></td>
<td><pre>     * Pugh's Skip List Cookbook, sec 3.4).  The expected total space</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="285" href="#"></a></td>
<td><pre>     * requirement for a map is slightly less than for the current</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="286" href="#"></a></td>
<td><pre>     * implementation of java.util.TreeMap.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="287" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="288" href="#"></a></td>
<td><pre>     * Changing the level of the index (i.e, the height of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="289" href="#"></a></td>
<td><pre>     * tree-like structure) also uses CAS. The head index has initial</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="290" href="#"></a></td>
<td><pre>     * level/height of one. Creation of an index with height greater</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="291" href="#"></a></td>
<td><pre>     * than the current level adds a level to the head index by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="292" href="#"></a></td>
<td><pre>     * CAS'ing on a new top-most head. To maintain good performance</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="293" href="#"></a></td>
<td><pre>     * after a lot of removals, deletion methods heuristically try to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="294" href="#"></a></td>
<td><pre>     * reduce the height if the topmost levels appear to be empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="295" href="#"></a></td>
<td><pre>     * This may encounter races in which it possible (but rare) to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="296" href="#"></a></td>
<td><pre>     * reduce and &quot;lose&quot; a level just as it is about to contain an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="297" href="#"></a></td>
<td><pre>     * index (that will then never be encountered). This does no</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="298" href="#"></a></td>
<td><pre>     * structural harm, and in practice appears to be a better option</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="299" href="#"></a></td>
<td><pre>     * than allowing unrestrained growth of levels.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="300" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="301" href="#"></a></td>
<td><pre>     * The code for all this is more verbose than you'd like. Most</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="302" href="#"></a></td>
<td><pre>     * operations entail locating an element (or position to insert an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="303" href="#"></a></td>
<td><pre>     * element). The code to do this can't be nicely factored out</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="304" href="#"></a></td>
<td><pre>     * because subsequent uses require a snapshot of predecessor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="305" href="#"></a></td>
<td><pre>     * and/or successor and/or value fields which can't be returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="306" href="#"></a></td>
<td><pre>     * all at once, at least not without creating yet another object</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="307" href="#"></a></td>
<td><pre>     * to hold them -- creating such little objects is an especially</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="308" href="#"></a></td>
<td><pre>     * bad idea for basic internal search operations because it adds</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="309" href="#"></a></td>
<td><pre>     * to GC overhead.  (This is one of the few times I've wished Java</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="310" href="#"></a></td>
<td><pre>     * had macros.) Instead, some traversal code is interleaved within</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="311" href="#"></a></td>
<td><pre>     * insertion and removal operations.  The control logic to handle</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="312" href="#"></a></td>
<td><pre>     * all the retry conditions is sometimes twisty. Most search is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="313" href="#"></a></td>
<td><pre>     * broken into 2 parts. findPredecessor() searches index nodes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="314" href="#"></a></td>
<td><pre>     * only, returning a base-level predecessor of the key. findNode()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="315" href="#"></a></td>
<td><pre>     * finishes out the base-level search. Even with this factoring,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="316" href="#"></a></td>
<td><pre>     * there is a fair amount of near-duplication of code to handle</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="317" href="#"></a></td>
<td><pre>     * variants.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="318" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="319" href="#"></a></td>
<td><pre>     * To produce random values without interference across threads,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="320" href="#"></a></td>
<td><pre>     * we use within-JDK thread local random support (via the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="321" href="#"></a></td>
<td><pre>     * &quot;secondary seed&quot;, to avoid interference with user-level</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="322" href="#"></a></td>
<td><pre>     * ThreadLocalRandom.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="323" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="324" href="#"></a></td>
<td><pre>     * A previous version of this class wrapped non-comparable keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="325" href="#"></a></td>
<td><pre>     * with their comparators to emulate Comparables when using</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="326" href="#"></a></td>
<td><pre>     * comparators vs Comparables.  However, JVMs now appear to better</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="327" href="#"></a></td>
<td><pre>     * handle infusing comparator-vs-comparable choice into search</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="328" href="#"></a></td>
<td><pre>     * loops. Static method cpr(comparator, x, y) is used for all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="329" href="#"></a></td>
<td><pre>     * comparisons, which works well as long as the comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="330" href="#"></a></td>
<td><pre>     * argument is set up outside of loops (thus sometimes passed as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="331" href="#"></a></td>
<td><pre>     * an argument to internal methods) to avoid field re-reads.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="332" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="333" href="#"></a></td>
<td><pre>     * For explanation of algorithms sharing at least a couple of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="334" href="#"></a></td>
<td><pre>     * features with this one, see Mikhail Fomitchev's thesis</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="335" href="#"></a></td>
<td><pre>     * (http://www.cs.yorku.ca/~mikhail/), Keir Fraser's thesis</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="336" href="#"></a></td>
<td><pre>     * (http://www.cl.cam.ac.uk/users/kaf24/), and Hakan Sundell's</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="337" href="#"></a></td>
<td><pre>     * thesis (http://www.cs.chalmers.se/~phs/).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="338" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="339" href="#"></a></td>
<td><pre>     * Given the use of tree-like index nodes, you might wonder why</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="340" href="#"></a></td>
<td><pre>     * this doesn't use some kind of search tree instead, which would</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="341" href="#"></a></td>
<td><pre>     * support somewhat faster search operations. The reason is that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="342" href="#"></a></td>
<td><pre>     * there are no known efficient lock-free insertion and deletion</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="343" href="#"></a></td>
<td><pre>     * algorithms for search trees. The immutability of the &quot;down&quot;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="344" href="#"></a></td>
<td><pre>     * links of index nodes (as opposed to mutable &quot;left&quot; fields in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="345" href="#"></a></td>
<td><pre>     * true trees) makes this tractable using only CAS operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="346" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="347" href="#"></a></td>
<td><pre>     * Notation guide for local variables</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="348" href="#"></a></td>
<td><pre>     * Node:         b, n, f    for  predecessor, node, successor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="349" href="#"></a></td>
<td><pre>     * Index:        q, r, d    for index node, right, down.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="350" href="#"></a></td>
<td><pre>     *               t          for another index node</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="351" href="#"></a></td>
<td><pre>     * Head:         h</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="352" href="#"></a></td>
<td><pre>     * Levels:       j</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="353" href="#"></a></td>
<td><pre>     * Keys:         k, key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="354" href="#"></a></td>
<td><pre>     * Values:       v, value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="355" href="#"></a></td>
<td><pre>     * Comparisons:  c</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="356" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="357" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="358" href="#"></a></td>
<td><pre>    private static final long serialVersionUID = -8627078645895051609L;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="359" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="360" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="361" href="#"></a></td>
<td><pre>     * Special value used to identify base-level header</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="362" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="363" href="#"></a></td>
<td><pre>    private static final Object BASE_HEADER = new Object();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="364" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="365" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="366" href="#"></a></td>
<td><pre>     * The topmost head index of the skiplist.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="367" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="368" href="#"></a></td>
<td><pre>    private transient volatile HeadIndex&lt;K,V&gt; head;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="369" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="370" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="371" href="#"></a></td>
<td><pre>     * The comparator used to maintain order in this map, or null if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="372" href="#"></a></td>
<td><pre>     * using natural ordering.  (Non-private to simplify access in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="373" href="#"></a></td>
<td><pre>     * nested classes.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="374" href="#"></a></td>
<td><pre>     * @serial</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="375" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="376" href="#"></a></td>
<td><pre>    final Comparator&lt;? super K&gt; comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="377" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="378" href="#"></a></td>
<td><pre>    /** Lazily initialized key set */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="379" href="#"></a></td>
<td><pre>    private transient KeySet&lt;K&gt; keySet;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="380" href="#"></a></td>
<td><pre>    /** Lazily initialized entry set */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="381" href="#"></a></td>
<td><pre>    private transient EntrySet&lt;K,V&gt; entrySet;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="382" href="#"></a></td>
<td><pre>    /** Lazily initialized values collection */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="383" href="#"></a></td>
<td><pre>    private transient Values&lt;V&gt; values;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="384" href="#"></a></td>
<td><pre>    /** Lazily initialized descending key set */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="385" href="#"></a></td>
<td><pre>    private transient ConcurrentNavigableMap&lt;K,V&gt; descendingMap;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="386" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="387" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="388" href="#"></a></td>
<td><pre>     * Initializes or resets state. Needed by constructors, clone,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="389" href="#"></a></td>
<td><pre>     * clear, readObject. and ConcurrentSkipListSet.clone.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="390" href="#"></a></td>
<td><pre>     * (Note that comparator must be separately initialized.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="391" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="392" href="#"></a></td>
<td><pre>    private void initialize() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="393" href="#"></a></td>
<td><pre>        keySet = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="394" href="#"></a></td>
<td><pre>        entrySet = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="395" href="#"></a></td>
<td><pre>        values = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="396" href="#"></a></td>
<td><pre>        descendingMap = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="397" href="#"></a></td>
<td><pre>        head = new HeadIndex&lt;K,V&gt;(new Node&lt;K,V&gt;(null, BASE_HEADER, null),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="398" href="#"></a></td>
<td><pre>                                  null, null, 1);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="399" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="400" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="401" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="402" href="#"></a></td>
<td><pre>     * compareAndSet head node</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="403" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="404" href="#"></a></td>
<td><pre>    private boolean casHead(HeadIndex&lt;K,V&gt; cmp, HeadIndex&lt;K,V&gt; val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="405" href="#"></a></td>
<td><pre>        return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="406" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="407" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="408" href="#"></a></td>
<td><pre>    /* ---------------- Nodes -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="409" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="410" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="411" href="#"></a></td>
<td><pre>     * Nodes hold keys and values, and are singly linked in sorted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="412" href="#"></a></td>
<td><pre>     * order, possibly with some intervening marker nodes. The list is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="413" href="#"></a></td>
<td><pre>     * headed by a dummy node accessible as head.node. The value field</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="414" href="#"></a></td>
<td><pre>     * is declared only as Object because it takes special non-V</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="415" href="#"></a></td>
<td><pre>     * values for marker and header nodes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="416" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="417" href="#"></a></td>
<td><pre>    static final class Node&lt;K,V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="418" href="#"></a></td>
<td><pre>        final K key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="419" href="#"></a></td>
<td><pre>        volatile Object value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="420" href="#"></a></td>
<td><pre>        volatile Node&lt;K,V&gt; next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="421" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="422" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="423" href="#"></a></td>
<td><pre>         * Creates a new regular node.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="424" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="425" href="#"></a></td>
<td><pre>        Node(K key, Object value, Node&lt;K,V&gt; next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="426" href="#"></a></td>
<td><pre>            this.key = key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="427" href="#"></a></td>
<td><pre>            this.value = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="428" href="#"></a></td>
<td><pre>            this.next = next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="429" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="430" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="431" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="432" href="#"></a></td>
<td><pre>         * Creates a new marker node. A marker is distinguished by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="433" href="#"></a></td>
<td><pre>         * having its value field point to itself.  Marker nodes also</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="434" href="#"></a></td>
<td><pre>         * have null keys, a fact that is exploited in a few places,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="435" href="#"></a></td>
<td><pre>         * but this doesn't distinguish markers from the base-level</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="436" href="#"></a></td>
<td><pre>         * header node (head.node), which also has a null key.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="437" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="438" href="#"></a></td>
<td><pre>        Node(Node&lt;K,V&gt; next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="439" href="#"></a></td>
<td><pre>            this.key = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="440" href="#"></a></td>
<td><pre>            this.value = this;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="441" href="#"></a></td>
<td><pre>            this.next = next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="442" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="443" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="444" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="445" href="#"></a></td>
<td><pre>         * compareAndSet value field</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="446" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="447" href="#"></a></td>
<td><pre>        boolean casValue(Object cmp, Object val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="448" href="#"></a></td>
<td><pre>            return UNSAFE.compareAndSwapObject(this, valueOffset, cmp, val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="449" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="450" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="451" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="452" href="#"></a></td>
<td><pre>         * compareAndSet next field</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="453" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="454" href="#"></a></td>
<td><pre>        boolean casNext(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="455" href="#"></a></td>
<td><pre>            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="456" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="457" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="458" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="459" href="#"></a></td>
<td><pre>         * Returns true if this node is a marker. This method isn't</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="460" href="#"></a></td>
<td><pre>         * actually called in any current code checking for markers</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="461" href="#"></a></td>
<td><pre>         * because callers will have already read value field and need</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="462" href="#"></a></td>
<td><pre>         * to use that read (not another done here) and so directly</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="463" href="#"></a></td>
<td><pre>         * test if value points to node.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="464" href="#"></a></td>
<td><pre>         *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="465" href="#"></a></td>
<td><pre>         * @return true if this node is a marker node</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="466" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="467" href="#"></a></td>
<td><pre>        boolean isMarker() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="468" href="#"></a></td>
<td><pre>            return value == this;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="469" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="470" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="471" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="472" href="#"></a></td>
<td><pre>         * Returns true if this node is the header of base-level list.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="473" href="#"></a></td>
<td><pre>         * @return true if this node is header node</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="474" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="475" href="#"></a></td>
<td><pre>        boolean isBaseHeader() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="476" href="#"></a></td>
<td><pre>            return value == BASE_HEADER;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="477" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="478" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="479" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="480" href="#"></a></td>
<td><pre>         * Tries to append a deletion marker to this node.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="481" href="#"></a></td>
<td><pre>         * @param f the assumed current successor of this node</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="482" href="#"></a></td>
<td><pre>         * @return true if successful</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="483" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="484" href="#"></a></td>
<td><pre>        boolean appendMarker(Node&lt;K,V&gt; f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="485" href="#"></a></td>
<td><pre>            return casNext(f, new Node&lt;K,V&gt;(f));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="486" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="487" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="488" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="489" href="#"></a></td>
<td><pre>         * Helps out a deletion by appending marker or unlinking from</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="490" href="#"></a></td>
<td><pre>         * predecessor. This is called during traversals when value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="491" href="#"></a></td>
<td><pre>         * field seen to be null.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="492" href="#"></a></td>
<td><pre>         * @param b predecessor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="493" href="#"></a></td>
<td><pre>         * @param f successor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="494" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="495" href="#"></a></td>
<td><pre>        void helpDelete(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="496" href="#"></a></td>
<td><pre>            /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="497" href="#"></a></td>
<td><pre>             * Rechecking links and then doing only one of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="498" href="#"></a></td>
<td><pre>             * help-out stages per call tends to minimize CAS</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="499" href="#"></a></td>
<td><pre>             * interference among helping threads.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="500" href="#"></a></td>
<td><pre>             */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="501" href="#"></a></td>
<td><pre>            if (f == next &amp;&amp; this == b.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="502" href="#"></a></td>
<td><pre>                if (f == null || f.value != f) // not already marked</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="503" href="#"></a></td>
<td><pre>                    casNext(f, new Node&lt;K,V&gt;(f));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="504" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="505" href="#"></a></td>
<td><pre>                    b.casNext(this, f.next);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="506" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="507" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="508" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="509" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="510" href="#"></a></td>
<td><pre>         * Returns value if this node contains a valid key-value pair,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="511" href="#"></a></td>
<td><pre>         * else null.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="512" href="#"></a></td>
<td><pre>         * @return this node's value if it isn't a marker or header or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="513" href="#"></a></td>
<td><pre>         * is deleted, else null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="514" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="515" href="#"></a></td>
<td><pre>        V getValidValue() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="516" href="#"></a></td>
<td><pre>            Object v = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="517" href="#"></a></td>
<td><pre>            if (v == this || v == BASE_HEADER)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="518" href="#"></a></td>
<td><pre>                return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="519" href="#"></a></td>
<td><pre>            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="520" href="#"></a></td>
<td><pre>            return vv;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="521" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="522" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="523" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="524" href="#"></a></td>
<td><pre>         * Creates and returns a new SimpleImmutableEntry holding current</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="525" href="#"></a></td>
<td><pre>         * mapping if this node holds a valid value, else null.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="526" href="#"></a></td>
<td><pre>         * @return new entry or null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="527" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="528" href="#"></a></td>
<td><pre>        AbstractMap.SimpleImmutableEntry&lt;K,V&gt; createSnapshot() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="529" href="#"></a></td>
<td><pre>            Object v = value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="530" href="#"></a></td>
<td><pre>            if (v == null || v == this || v == BASE_HEADER)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="531" href="#"></a></td>
<td><pre>                return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="532" href="#"></a></td>
<td><pre>            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="533" href="#"></a></td>
<td><pre>            return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(key, vv);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="534" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="535" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="536" href="#"></a></td>
<td><pre>        // UNSAFE mechanics</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="537" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="538" href="#"></a></td>
<td><pre>        private static final sun.misc.Unsafe UNSAFE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="539" href="#"></a></td>
<td><pre>        private static final long valueOffset;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="540" href="#"></a></td>
<td><pre>        private static final long nextOffset;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="541" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="542" href="#"></a></td>
<td><pre>        static {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="543" href="#"></a></td>
<td><pre>            try {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="544" href="#"></a></td>
<td><pre>                UNSAFE = sun.misc.Unsafe.getUnsafe();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="545" href="#"></a></td>
<td><pre>                Class&lt;?&gt; k = Node.class;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="546" href="#"></a></td>
<td><pre>                valueOffset = UNSAFE.objectFieldOffset</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="547" href="#"></a></td>
<td><pre>                    (k.getDeclaredField(&quot;value&quot;));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="548" href="#"></a></td>
<td><pre>                nextOffset = UNSAFE.objectFieldOffset</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="549" href="#"></a></td>
<td><pre>                    (k.getDeclaredField(&quot;next&quot;));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="550" href="#"></a></td>
<td><pre>            } catch (Exception e) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="551" href="#"></a></td>
<td><pre>                throw new Error(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="552" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="553" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="554" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="555" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="556" href="#"></a></td>
<td><pre>    /* ---------------- Indexing -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="557" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="558" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="559" href="#"></a></td>
<td><pre>     * Index nodes represent the levels of the skip list.  Note that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="560" href="#"></a></td>
<td><pre>     * even though both Nodes and Indexes have forward-pointing</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="561" href="#"></a></td>
<td><pre>     * fields, they have different types and are handled in different</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="562" href="#"></a></td>
<td><pre>     * ways, that can't nicely be captured by placing field in a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="563" href="#"></a></td>
<td><pre>     * shared abstract class.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="564" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="565" href="#"></a></td>
<td><pre>    static class Index&lt;K,V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="566" href="#"></a></td>
<td><pre>        final Node&lt;K,V&gt; node;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="567" href="#"></a></td>
<td><pre>        final Index&lt;K,V&gt; down;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="568" href="#"></a></td>
<td><pre>        volatile Index&lt;K,V&gt; right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="569" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="570" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="571" href="#"></a></td>
<td><pre>         * Creates index node with given values.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="572" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="573" href="#"></a></td>
<td><pre>        Index(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="574" href="#"></a></td>
<td><pre>            this.node = node;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="575" href="#"></a></td>
<td><pre>            this.down = down;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="576" href="#"></a></td>
<td><pre>            this.right = right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="577" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="578" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="579" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="580" href="#"></a></td>
<td><pre>         * compareAndSet right field</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="581" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="582" href="#"></a></td>
<td><pre>        final boolean casRight(Index&lt;K,V&gt; cmp, Index&lt;K,V&gt; val) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="583" href="#"></a></td>
<td><pre>            return UNSAFE.compareAndSwapObject(this, rightOffset, cmp, val);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="584" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="585" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="586" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="587" href="#"></a></td>
<td><pre>         * Returns true if the node this indexes has been deleted.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="588" href="#"></a></td>
<td><pre>         * @return true if indexed node is known to be deleted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="589" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="590" href="#"></a></td>
<td><pre>        final boolean indexesDeletedNode() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="591" href="#"></a></td>
<td><pre>            return node.value == null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="592" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="593" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="594" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="595" href="#"></a></td>
<td><pre>         * Tries to CAS newSucc as successor.  To minimize races with</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="596" href="#"></a></td>
<td><pre>         * unlink that may lose this index node, if the node being</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="597" href="#"></a></td>
<td><pre>         * indexed is known to be deleted, it doesn't try to link in.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="598" href="#"></a></td>
<td><pre>         * @param succ the expected current successor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="599" href="#"></a></td>
<td><pre>         * @param newSucc the new successor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="600" href="#"></a></td>
<td><pre>         * @return true if successful</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="601" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="602" href="#"></a></td>
<td><pre>        final boolean link(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="603" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; n = node;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="604" href="#"></a></td>
<td><pre>            newSucc.right = succ;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="605" href="#"></a></td>
<td><pre>            return n.value != null &amp;&amp; casRight(succ, newSucc);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="606" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="607" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="608" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="609" href="#"></a></td>
<td><pre>         * Tries to CAS right field to skip over apparent successor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="610" href="#"></a></td>
<td><pre>         * succ.  Fails (forcing a retraversal by caller) if this node</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="611" href="#"></a></td>
<td><pre>         * is known to be deleted.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="612" href="#"></a></td>
<td><pre>         * @param succ the expected current successor</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="613" href="#"></a></td>
<td><pre>         * @return true if successful</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="614" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="615" href="#"></a></td>
<td><pre>        final boolean unlink(Index&lt;K,V&gt; succ) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="616" href="#"></a></td>
<td><pre>            return node.value != null &amp;&amp; casRight(succ, succ.right);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="617" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="618" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="619" href="#"></a></td>
<td><pre>        // Unsafe mechanics</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="620" href="#"></a></td>
<td><pre>        private static final sun.misc.Unsafe UNSAFE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="621" href="#"></a></td>
<td><pre>        private static final long rightOffset;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="622" href="#"></a></td>
<td><pre>        static {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="623" href="#"></a></td>
<td><pre>            try {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="624" href="#"></a></td>
<td><pre>                UNSAFE = sun.misc.Unsafe.getUnsafe();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="625" href="#"></a></td>
<td><pre>                Class&lt;?&gt; k = Index.class;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="626" href="#"></a></td>
<td><pre>                rightOffset = UNSAFE.objectFieldOffset</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="627" href="#"></a></td>
<td><pre>                    (k.getDeclaredField(&quot;right&quot;));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="628" href="#"></a></td>
<td><pre>            } catch (Exception e) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="629" href="#"></a></td>
<td><pre>                throw new Error(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="630" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="631" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="632" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="633" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="634" href="#"></a></td>
<td><pre>    /* ---------------- Head nodes -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="635" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="636" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="637" href="#"></a></td>
<td><pre>     * Nodes heading each level keep track of their level.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="638" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="639" href="#"></a></td>
<td><pre>    static final class HeadIndex&lt;K,V&gt; extends Index&lt;K,V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="640" href="#"></a></td>
<td><pre>        final int level;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="641" href="#"></a></td>
<td><pre>        HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, int level) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="642" href="#"></a></td>
<td><pre>            super(node, down, right);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="643" href="#"></a></td>
<td><pre>            this.level = level;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="644" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="645" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="646" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="647" href="#"></a></td>
<td><pre>    /* ---------------- Comparison utilities -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="648" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="649" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="650" href="#"></a></td>
<td><pre>     * Compares using comparator or natural ordering if null.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="651" href="#"></a></td>
<td><pre>     * Called only by methods that have performed required type checks.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="652" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="653" href="#"></a></td>
<td><pre>    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="654" href="#"></a></td>
<td><pre>    static final int cpr(Comparator c, Object x, Object y) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="655" href="#"></a></td>
<td><pre>        return (c != null) ? c.compare(x, y) : ((Comparable)x).compareTo(y);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="656" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="657" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="658" href="#"></a></td>
<td><pre>    /* ---------------- Traversal -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="659" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="660" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="661" href="#"></a></td>
<td><pre>     * Returns a base-level node with key strictly less than given key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="662" href="#"></a></td>
<td><pre>     * or the base-level header if there is no such node.  Also</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="663" href="#"></a></td>
<td><pre>     * unlinks indexes to deleted nodes found along the way.  Callers</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="664" href="#"></a></td>
<td><pre>     * rely on this side-effect of clearing indices to deleted nodes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="665" href="#"></a></td>
<td><pre>     * @param key the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="666" href="#"></a></td>
<td><pre>     * @return a predecessor of key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="667" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="668" href="#"></a></td>
<td><pre>    private Node&lt;K,V&gt; findPredecessor(Object key, Comparator&lt;? super K&gt; cmp) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="669" href="#"></a></td>
<td><pre>        if (key == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="670" href="#"></a></td>
<td><pre>            throw new NullPointerException(); // don't postpone errors</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="671" href="#"></a></td>
<td><pre>        for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="672" href="#"></a></td>
<td><pre>            for (Index&lt;K,V&gt; q = head, r = q.right, d;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="673" href="#"></a></td>
<td><pre>                if (r != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="674" href="#"></a></td>
<td><pre>                    Node&lt;K,V&gt; n = r.node;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="675" href="#"></a></td>
<td><pre>                    K k = n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="676" href="#"></a></td>
<td><pre>                    if (n.value == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="677" href="#"></a></td>
<td><pre>                        if (!q.unlink(r))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="678" href="#"></a></td>
<td><pre>                            break;           // restart</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="679" href="#"></a></td>
<td><pre>                        r = q.right;         // reread r</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="680" href="#"></a></td>
<td><pre>                        continue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="681" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="682" href="#"></a></td>
<td><pre>                    if (cpr(cmp, key, k) &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="683" href="#"></a></td>
<td><pre>                        q = r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="684" href="#"></a></td>
<td><pre>                        r = r.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="685" href="#"></a></td>
<td><pre>                        continue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="686" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="687" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="688" href="#"></a></td>
<td><pre>                if ((d = q.down) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="689" href="#"></a></td>
<td><pre>                    return q.node;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="690" href="#"></a></td>
<td><pre>                q = d;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="691" href="#"></a></td>
<td><pre>                r = d.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="692" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="693" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="694" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="695" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="696" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="697" href="#"></a></td>
<td><pre>     * Returns node holding key or null if no such, clearing out any</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="698" href="#"></a></td>
<td><pre>     * deleted nodes seen along the way.  Repeatedly traverses at</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="699" href="#"></a></td>
<td><pre>     * base-level looking for key starting at predecessor returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="700" href="#"></a></td>
<td><pre>     * from findPredecessor, processing base-level deletions as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="701" href="#"></a></td>
<td><pre>     * encountered. Some callers rely on this side-effect of clearing</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="702" href="#"></a></td>
<td><pre>     * deleted nodes.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="703" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="704" href="#"></a></td>
<td><pre>     * Restarts occur, at traversal step centered on node n, if:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="705" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="706" href="#"></a></td>
<td><pre>     *   (1) After reading n's next field, n is no longer assumed</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="707" href="#"></a></td>
<td><pre>     *       predecessor b's current successor, which means that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="708" href="#"></a></td>
<td><pre>     *       we don't have a consistent 3-node snapshot and so cannot</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="709" href="#"></a></td>
<td><pre>     *       unlink any subsequent deleted nodes encountered.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="710" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="711" href="#"></a></td>
<td><pre>     *   (2) n's value field is null, indicating n is deleted, in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="712" href="#"></a></td>
<td><pre>     *       which case we help out an ongoing structural deletion</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="713" href="#"></a></td>
<td><pre>     *       before retrying.  Even though there are cases where such</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="714" href="#"></a></td>
<td><pre>     *       unlinking doesn't require restart, they aren't sorted out</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="715" href="#"></a></td>
<td><pre>     *       here because doing so would not usually outweigh cost of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="716" href="#"></a></td>
<td><pre>     *       restarting.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="717" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="718" href="#"></a></td>
<td><pre>     *   (3) n is a marker or n's predecessor's value field is null,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="719" href="#"></a></td>
<td><pre>     *       indicating (among other possibilities) that</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="720" href="#"></a></td>
<td><pre>     *       findPredecessor returned a deleted node. We can't unlink</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="721" href="#"></a></td>
<td><pre>     *       the node because we don't know its predecessor, so rely</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="722" href="#"></a></td>
<td><pre>     *       on another call to findPredecessor to notice and return</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="723" href="#"></a></td>
<td><pre>     *       some earlier predecessor, which it will do. This check is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="724" href="#"></a></td>
<td><pre>     *       only strictly needed at beginning of loop, (and the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="725" href="#"></a></td>
<td><pre>     *       b.value check isn't strictly needed at all) but is done</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="726" href="#"></a></td>
<td><pre>     *       each iteration to help avoid contention with other</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="727" href="#"></a></td>
<td><pre>     *       threads by callers that will fail to be able to change</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="728" href="#"></a></td>
<td><pre>     *       links, and so will retry anyway.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="729" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="730" href="#"></a></td>
<td><pre>     * The traversal loops in doPut, doRemove, and findNear all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="731" href="#"></a></td>
<td><pre>     * include the same three kinds of checks. And specialized</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="732" href="#"></a></td>
<td><pre>     * versions appear in findFirst, and findLast and their</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="733" href="#"></a></td>
<td><pre>     * variants. They can't easily share code because each uses the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="734" href="#"></a></td>
<td><pre>     * reads of fields held in locals occurring in the orders they</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="735" href="#"></a></td>
<td><pre>     * were performed.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="736" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="737" href="#"></a></td>
<td><pre>     * @param key the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="738" href="#"></a></td>
<td><pre>     * @return node holding key, or null if no such</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="739" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="740" href="#"></a></td>
<td><pre>    private Node&lt;K,V&gt; findNode(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="741" href="#"></a></td>
<td><pre>        if (key == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="742" href="#"></a></td>
<td><pre>            throw new NullPointerException(); // don't postpone errors</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="743" href="#"></a></td>
<td><pre>        Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="744" href="#"></a></td>
<td><pre>        outer: for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="745" href="#"></a></td>
<td><pre>            for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="746" href="#"></a></td>
<td><pre>                Object v; int c;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="747" href="#"></a></td>
<td><pre>                if (n == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="748" href="#"></a></td>
<td><pre>                    break outer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="749" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; f = n.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="750" href="#"></a></td>
<td><pre>                if (n != b.next)                // inconsistent read</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="751" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="752" href="#"></a></td>
<td><pre>                if ((v = n.value) == null) {    // n is deleted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="753" href="#"></a></td>
<td><pre>                    n.helpDelete(b, f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="754" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="755" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="756" href="#"></a></td>
<td><pre>                if (b.value == null || v == n)  // b is deleted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="757" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="758" href="#"></a></td>
<td><pre>                if ((c = cpr(cmp, key, n.key)) == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="759" href="#"></a></td>
<td><pre>                    return n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="760" href="#"></a></td>
<td><pre>                if (c &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="761" href="#"></a></td>
<td><pre>                    break outer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="762" href="#"></a></td>
<td><pre>                b = n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="763" href="#"></a></td>
<td><pre>                n = f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="764" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="765" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="766" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="767" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="768" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="769" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="770" href="#"></a></td>
<td><pre>     * Gets value for key. Almost the same as findNode, but returns</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="771" href="#"></a></td>
<td><pre>     * the found value (to avoid retries during re-reads)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="772" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="773" href="#"></a></td>
<td><pre>     * @param key the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="774" href="#"></a></td>
<td><pre>     * @return the value, or null if absent</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="775" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="776" href="#"></a></td>
<td><pre>    private V doGet(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="777" href="#"></a></td>
<td><pre>        if (key == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="778" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="779" href="#"></a></td>
<td><pre>        Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="780" href="#"></a></td>
<td><pre>        outer: for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="781" href="#"></a></td>
<td><pre>            for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="782" href="#"></a></td>
<td><pre>                Object v; int c;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="783" href="#"></a></td>
<td><pre>                if (n == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="784" href="#"></a></td>
<td><pre>                    break outer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="785" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; f = n.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="786" href="#"></a></td>
<td><pre>                if (n != b.next)                // inconsistent read</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="787" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="788" href="#"></a></td>
<td><pre>                if ((v = n.value) == null) {    // n is deleted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="789" href="#"></a></td>
<td><pre>                    n.helpDelete(b, f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="790" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="791" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="792" href="#"></a></td>
<td><pre>                if (b.value == null || v == n)  // b is deleted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="793" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="794" href="#"></a></td>
<td><pre>                if ((c = cpr(cmp, key, n.key)) == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="795" href="#"></a></td>
<td><pre>                    @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="796" href="#"></a></td>
<td><pre>                    return vv;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="797" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="798" href="#"></a></td>
<td><pre>                if (c &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="799" href="#"></a></td>
<td><pre>                    break outer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="800" href="#"></a></td>
<td><pre>                b = n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="801" href="#"></a></td>
<td><pre>                n = f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="802" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="803" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="804" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="805" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="806" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="807" href="#"></a></td>
<td><pre>    /* ---------------- Insertion -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="808" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="809" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="810" href="#"></a></td>
<td><pre>     * Main insertion method.  Adds element if not present, or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="811" href="#"></a></td>
<td><pre>     * replaces value if present and onlyIfAbsent is false.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="812" href="#"></a></td>
<td><pre>     * @param key the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="813" href="#"></a></td>
<td><pre>     * @param value the value that must be associated with key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="814" href="#"></a></td>
<td><pre>     * @param onlyIfAbsent if should not insert if already present</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="815" href="#"></a></td>
<td><pre>     * @return the old value, or null if newly inserted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="816" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="817" href="#"></a></td>
<td><pre>    private V doPut(K key, V value, boolean onlyIfAbsent) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="818" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; z;             // added node</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="819" href="#"></a></td>
<td><pre>        if (key == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="820" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="821" href="#"></a></td>
<td><pre>        Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="822" href="#"></a></td>
<td><pre>        outer: for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="823" href="#"></a></td>
<td><pre>            for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="824" href="#"></a></td>
<td><pre>                if (n != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="825" href="#"></a></td>
<td><pre>                    Object v; int c;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="826" href="#"></a></td>
<td><pre>                    Node&lt;K,V&gt; f = n.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="827" href="#"></a></td>
<td><pre>                    if (n != b.next)               // inconsistent read</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="828" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="829" href="#"></a></td>
<td><pre>                    if ((v = n.value) == null) {   // n is deleted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="830" href="#"></a></td>
<td><pre>                        n.helpDelete(b, f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="831" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="832" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="833" href="#"></a></td>
<td><pre>                    if (b.value == null || v == n) // b is deleted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="834" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="835" href="#"></a></td>
<td><pre>                    if ((c = cpr(cmp, key, n.key)) &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="836" href="#"></a></td>
<td><pre>                        b = n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="837" href="#"></a></td>
<td><pre>                        n = f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="838" href="#"></a></td>
<td><pre>                        continue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="839" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="840" href="#"></a></td>
<td><pre>                    if (c == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="841" href="#"></a></td>
<td><pre>                        if (onlyIfAbsent || n.casValue(v, value)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="842" href="#"></a></td>
<td><pre>                            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="843" href="#"></a></td>
<td><pre>                            return vv;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="844" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="845" href="#"></a></td>
<td><pre>                        break; // restart if lost race to replace value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="846" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="847" href="#"></a></td>
<td><pre>                    // else c &lt; 0; fall through</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="848" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="849" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="850" href="#"></a></td>
<td><pre>                z = new Node&lt;K,V&gt;(key, value, n);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="851" href="#"></a></td>
<td><pre>                if (!b.casNext(n, z))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="852" href="#"></a></td>
<td><pre>                    break;         // restart if lost race to append to b</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="853" href="#"></a></td>
<td><pre>                break outer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="854" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="855" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="856" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="857" href="#"></a></td>
<td><pre>        int rnd = ThreadLocalRandom.nextSecondarySeed();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="858" href="#"></a></td>
<td><pre>        if ((rnd &amp; 0x80000001) == 0) { // test highest and lowest bits</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="859" href="#"></a></td>
<td><pre>            int level = 1, max;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="860" href="#"></a></td>
<td><pre>            while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="861" href="#"></a></td>
<td><pre>                ++level;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="862" href="#"></a></td>
<td><pre>            Index&lt;K,V&gt; idx = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="863" href="#"></a></td>
<td><pre>            HeadIndex&lt;K,V&gt; h = head;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="864" href="#"></a></td>
<td><pre>            if (level &lt;= (max = h.level)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="865" href="#"></a></td>
<td><pre>                for (int i = 1; i &lt;= level; ++i)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="866" href="#"></a></td>
<td><pre>                    idx = new Index&lt;K,V&gt;(z, idx, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="867" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="868" href="#"></a></td>
<td><pre>            else { // try to grow by one level</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="869" href="#"></a></td>
<td><pre>                level = max + 1; // hold in array and later pick the one to use</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="870" href="#"></a></td>
<td><pre>                @SuppressWarnings(&quot;unchecked&quot;)Index&lt;K,V&gt;[] idxs =</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="871" href="#"></a></td>
<td><pre>                    (Index&lt;K,V&gt;[])new Index&lt;?,?&gt;[level+1];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="872" href="#"></a></td>
<td><pre>                for (int i = 1; i &lt;= level; ++i)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="873" href="#"></a></td>
<td><pre>                    idxs[i] = idx = new Index&lt;K,V&gt;(z, idx, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="874" href="#"></a></td>
<td><pre>                for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="875" href="#"></a></td>
<td><pre>                    h = head;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="876" href="#"></a></td>
<td><pre>                    int oldLevel = h.level;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="877" href="#"></a></td>
<td><pre>                    if (level &lt;= oldLevel) // lost race to add level</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="878" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="879" href="#"></a></td>
<td><pre>                    HeadIndex&lt;K,V&gt; newh = h;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="880" href="#"></a></td>
<td><pre>                    Node&lt;K,V&gt; oldbase = h.node;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="881" href="#"></a></td>
<td><pre>                    for (int j = oldLevel+1; j &lt;= level; ++j)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="882" href="#"></a></td>
<td><pre>                        newh = new HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="883" href="#"></a></td>
<td><pre>                    if (casHead(h, newh)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="884" href="#"></a></td>
<td><pre>                        h = newh;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="885" href="#"></a></td>
<td><pre>                        idx = idxs[level = oldLevel];</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="886" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="887" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="888" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="889" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="890" href="#"></a></td>
<td><pre>            // find insertion points and splice in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="891" href="#"></a></td>
<td><pre>            splice: for (int insertionLevel = level;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="892" href="#"></a></td>
<td><pre>                int j = h.level;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="893" href="#"></a></td>
<td><pre>                for (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="894" href="#"></a></td>
<td><pre>                    if (q == null || t == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="895" href="#"></a></td>
<td><pre>                        break splice;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="896" href="#"></a></td>
<td><pre>                    if (r != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="897" href="#"></a></td>
<td><pre>                        Node&lt;K,V&gt; n = r.node;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="898" href="#"></a></td>
<td><pre>                        // compare before deletion check avoids needing recheck</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="899" href="#"></a></td>
<td><pre>                        int c = cpr(cmp, key, n.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="900" href="#"></a></td>
<td><pre>                        if (n.value == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="901" href="#"></a></td>
<td><pre>                            if (!q.unlink(r))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="902" href="#"></a></td>
<td><pre>                                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="903" href="#"></a></td>
<td><pre>                            r = q.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="904" href="#"></a></td>
<td><pre>                            continue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="905" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="906" href="#"></a></td>
<td><pre>                        if (c &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="907" href="#"></a></td>
<td><pre>                            q = r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="908" href="#"></a></td>
<td><pre>                            r = r.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="909" href="#"></a></td>
<td><pre>                            continue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="910" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="911" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="912" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="913" href="#"></a></td>
<td><pre>                    if (j == insertionLevel) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="914" href="#"></a></td>
<td><pre>                        if (!q.link(r, t))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="915" href="#"></a></td>
<td><pre>                            break; // restart</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="916" href="#"></a></td>
<td><pre>                        if (t.node.value == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="917" href="#"></a></td>
<td><pre>                            findNode(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="918" href="#"></a></td>
<td><pre>                            break splice;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="919" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="920" href="#"></a></td>
<td><pre>                        if (--insertionLevel == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="921" href="#"></a></td>
<td><pre>                            break splice;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="922" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="923" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="924" href="#"></a></td>
<td><pre>                    if (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="925" href="#"></a></td>
<td><pre>                        t = t.down;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="926" href="#"></a></td>
<td><pre>                    q = q.down;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="927" href="#"></a></td>
<td><pre>                    r = q.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="928" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="929" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="930" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="931" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="932" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="933" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="934" href="#"></a></td>
<td><pre>    /* ---------------- Deletion -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="935" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="936" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="937" href="#"></a></td>
<td><pre>     * Main deletion method. Locates node, nulls value, appends a</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="938" href="#"></a></td>
<td><pre>     * deletion marker, unlinks predecessor, removes associated index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="939" href="#"></a></td>
<td><pre>     * nodes, and possibly reduces head index level.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="940" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="941" href="#"></a></td>
<td><pre>     * Index nodes are cleared out simply by calling findPredecessor.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="942" href="#"></a></td>
<td><pre>     * which unlinks indexes to deleted nodes found along path to key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="943" href="#"></a></td>
<td><pre>     * which will include the indexes to this node.  This is done</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="944" href="#"></a></td>
<td><pre>     * unconditionally. We can't check beforehand whether there are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="945" href="#"></a></td>
<td><pre>     * index nodes because it might be the case that some or all</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="946" href="#"></a></td>
<td><pre>     * indexes hadn't been inserted yet for this node during initial</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="947" href="#"></a></td>
<td><pre>     * search for it, and we'd like to ensure lack of garbage</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="948" href="#"></a></td>
<td><pre>     * retention, so must call to be sure.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="949" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="950" href="#"></a></td>
<td><pre>     * @param key the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="951" href="#"></a></td>
<td><pre>     * @param value if non-null, the value that must be</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="952" href="#"></a></td>
<td><pre>     * associated with key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="953" href="#"></a></td>
<td><pre>     * @return the node, or null if not found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="954" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="955" href="#"></a></td>
<td><pre>    final V doRemove(Object key, Object value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="956" href="#"></a></td>
<td><pre>        if (key == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="957" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="958" href="#"></a></td>
<td><pre>        Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="959" href="#"></a></td>
<td><pre>        outer: for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="960" href="#"></a></td>
<td><pre>            for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="961" href="#"></a></td>
<td><pre>                Object v; int c;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="962" href="#"></a></td>
<td><pre>                if (n == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="963" href="#"></a></td>
<td><pre>                    break outer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="964" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; f = n.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="965" href="#"></a></td>
<td><pre>                if (n != b.next)                    // inconsistent read</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="966" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="967" href="#"></a></td>
<td><pre>                if ((v = n.value) == null) {        // n is deleted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="968" href="#"></a></td>
<td><pre>                    n.helpDelete(b, f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="969" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="970" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="971" href="#"></a></td>
<td><pre>                if (b.value == null || v == n)      // b is deleted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="972" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="973" href="#"></a></td>
<td><pre>                if ((c = cpr(cmp, key, n.key)) &lt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="974" href="#"></a></td>
<td><pre>                    break outer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="975" href="#"></a></td>
<td><pre>                if (c &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="976" href="#"></a></td>
<td><pre>                    b = n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="977" href="#"></a></td>
<td><pre>                    n = f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="978" href="#"></a></td>
<td><pre>                    continue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="979" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="980" href="#"></a></td>
<td><pre>                if (value != null &amp;&amp; !value.equals(v))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="981" href="#"></a></td>
<td><pre>                    break outer;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="982" href="#"></a></td>
<td><pre>                if (!n.casValue(v, null))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="983" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="984" href="#"></a></td>
<td><pre>                if (!n.appendMarker(f) || !b.casNext(n, f))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="985" href="#"></a></td>
<td><pre>                    findNode(key);                  // retry via findNode</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="986" href="#"></a></td>
<td><pre>                else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="987" href="#"></a></td>
<td><pre>                    findPredecessor(key, cmp);      // clean index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="988" href="#"></a></td>
<td><pre>                    if (head.right == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="989" href="#"></a></td>
<td><pre>                        tryReduceLevel();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="990" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="991" href="#"></a></td>
<td><pre>                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="992" href="#"></a></td>
<td><pre>                return vv;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="993" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="994" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="995" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="996" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="997" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="998" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="999" href="#"></a></td>
<td><pre>     * Possibly reduce head level if it has no nodes.  This method can</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1000" href="#"></a></td>
<td><pre>     * (rarely) make mistakes, in which case levels can disappear even</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1001" href="#"></a></td>
<td><pre>     * though they are about to contain index nodes. This impacts</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1002" href="#"></a></td>
<td><pre>     * performance, not correctness.  To minimize mistakes as well as</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1003" href="#"></a></td>
<td><pre>     * to reduce hysteresis, the level is reduced by one only if the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1004" href="#"></a></td>
<td><pre>     * topmost three levels look empty. Also, if the removed level</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1005" href="#"></a></td>
<td><pre>     * looks non-empty after CAS, we try to change it back quick</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1006" href="#"></a></td>
<td><pre>     * before anyone notices our mistake! (This trick works pretty</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1007" href="#"></a></td>
<td><pre>     * well because this method will practically never make mistakes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1008" href="#"></a></td>
<td><pre>     * unless current thread stalls immediately before first CAS, in</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1009" href="#"></a></td>
<td><pre>     * which case it is very unlikely to stall again immediately</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1010" href="#"></a></td>
<td><pre>     * afterwards, so will recover.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1011" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1012" href="#"></a></td>
<td><pre>     * We put up with all this rather than just let levels grow</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1013" href="#"></a></td>
<td><pre>     * because otherwise, even a small map that has undergone a large</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1014" href="#"></a></td>
<td><pre>     * number of insertions and removals will have a lot of levels,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1015" href="#"></a></td>
<td><pre>     * slowing down access more than would an occasional unwanted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1016" href="#"></a></td>
<td><pre>     * reduction.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1017" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1018" href="#"></a></td>
<td><pre>    private void tryReduceLevel() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1019" href="#"></a></td>
<td><pre>        HeadIndex&lt;K,V&gt; h = head;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1020" href="#"></a></td>
<td><pre>        HeadIndex&lt;K,V&gt; d;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1021" href="#"></a></td>
<td><pre>        HeadIndex&lt;K,V&gt; e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1022" href="#"></a></td>
<td><pre>        if (h.level &gt; 3 &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1023" href="#"></a></td>
<td><pre>            (d = (HeadIndex&lt;K,V&gt;)h.down) != null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1024" href="#"></a></td>
<td><pre>            (e = (HeadIndex&lt;K,V&gt;)d.down) != null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1025" href="#"></a></td>
<td><pre>            e.right == null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1026" href="#"></a></td>
<td><pre>            d.right == null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1027" href="#"></a></td>
<td><pre>            h.right == null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1028" href="#"></a></td>
<td><pre>            casHead(h, d) &amp;&amp; // try to set</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1029" href="#"></a></td>
<td><pre>            h.right != null) // recheck</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1030" href="#"></a></td>
<td><pre>            casHead(d, h);   // try to backout</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1031" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1032" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1033" href="#"></a></td>
<td><pre>    /* ---------------- Finding and removing first element -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1034" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1035" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1036" href="#"></a></td>
<td><pre>     * Specialized variant of findNode to get first valid node.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1037" href="#"></a></td>
<td><pre>     * @return first node or null if empty</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1038" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1039" href="#"></a></td>
<td><pre>    final Node&lt;K,V&gt; findFirst() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1040" href="#"></a></td>
<td><pre>        for (Node&lt;K,V&gt; b, n;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1041" href="#"></a></td>
<td><pre>            if ((n = (b = head.node).next) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1042" href="#"></a></td>
<td><pre>                return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1043" href="#"></a></td>
<td><pre>            if (n.value != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1044" href="#"></a></td>
<td><pre>                return n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1045" href="#"></a></td>
<td><pre>            n.helpDelete(b, n.next);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1046" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1047" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1048" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1049" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1050" href="#"></a></td>
<td><pre>     * Removes first entry; returns its snapshot.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1051" href="#"></a></td>
<td><pre>     * @return null if empty, else snapshot of first entry</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1052" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1053" href="#"></a></td>
<td><pre>    private Map.Entry&lt;K,V&gt; doRemoveFirstEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1054" href="#"></a></td>
<td><pre>        for (Node&lt;K,V&gt; b, n;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1055" href="#"></a></td>
<td><pre>            if ((n = (b = head.node).next) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1056" href="#"></a></td>
<td><pre>                return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1057" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; f = n.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1058" href="#"></a></td>
<td><pre>            if (n != b.next)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1059" href="#"></a></td>
<td><pre>                continue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1060" href="#"></a></td>
<td><pre>            Object v = n.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1061" href="#"></a></td>
<td><pre>            if (v == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1062" href="#"></a></td>
<td><pre>                n.helpDelete(b, f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1063" href="#"></a></td>
<td><pre>                continue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1064" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1065" href="#"></a></td>
<td><pre>            if (!n.casValue(v, null))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1066" href="#"></a></td>
<td><pre>                continue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1067" href="#"></a></td>
<td><pre>            if (!n.appendMarker(f) || !b.casNext(n, f))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1068" href="#"></a></td>
<td><pre>                findFirst(); // retry</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1069" href="#"></a></td>
<td><pre>            clearIndexToFirst();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1070" href="#"></a></td>
<td><pre>            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1071" href="#"></a></td>
<td><pre>            return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, vv);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1072" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1073" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1074" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1075" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1076" href="#"></a></td>
<td><pre>     * Clears out index nodes associated with deleted first entry.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1077" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1078" href="#"></a></td>
<td><pre>    private void clearIndexToFirst() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1079" href="#"></a></td>
<td><pre>        for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1080" href="#"></a></td>
<td><pre>            for (Index&lt;K,V&gt; q = head;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1081" href="#"></a></td>
<td><pre>                Index&lt;K,V&gt; r = q.right;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1082" href="#"></a></td>
<td><pre>                if (r != null &amp;&amp; r.indexesDeletedNode() &amp;&amp; !q.unlink(r))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1083" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1084" href="#"></a></td>
<td><pre>                if ((q = q.down) == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1085" href="#"></a></td>
<td><pre>                    if (head.right == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1086" href="#"></a></td>
<td><pre>                        tryReduceLevel();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1087" href="#"></a></td>
<td><pre>                    return;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1088" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1089" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1090" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1091" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1092" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1093" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1094" href="#"></a></td>
<td><pre>     * Removes last entry; returns its snapshot.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1095" href="#"></a></td>
<td><pre>     * Specialized variant of doRemove.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1096" href="#"></a></td>
<td><pre>     * @return null if empty, else snapshot of last entry</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1097" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1098" href="#"></a></td>
<td><pre>    private Map.Entry&lt;K,V&gt; doRemoveLastEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1099" href="#"></a></td>
<td><pre>        for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1100" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; b = findPredecessorOfLast();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1101" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; n = b.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1102" href="#"></a></td>
<td><pre>            if (n == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1103" href="#"></a></td>
<td><pre>                if (b.isBaseHeader())               // empty</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1104" href="#"></a></td>
<td><pre>                    return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1105" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1106" href="#"></a></td>
<td><pre>                    continue; // all b's successors are deleted; retry</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1107" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1108" href="#"></a></td>
<td><pre>            for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1109" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; f = n.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1110" href="#"></a></td>
<td><pre>                if (n != b.next)                    // inconsistent read</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1111" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1112" href="#"></a></td>
<td><pre>                Object v = n.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1113" href="#"></a></td>
<td><pre>                if (v == null) {                    // n is deleted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1114" href="#"></a></td>
<td><pre>                    n.helpDelete(b, f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1115" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1116" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1117" href="#"></a></td>
<td><pre>                if (b.value == null || v == n)      // b is deleted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1118" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1119" href="#"></a></td>
<td><pre>                if (f != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1120" href="#"></a></td>
<td><pre>                    b = n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1121" href="#"></a></td>
<td><pre>                    n = f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1122" href="#"></a></td>
<td><pre>                    continue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1123" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1124" href="#"></a></td>
<td><pre>                if (!n.casValue(v, null))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1125" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1126" href="#"></a></td>
<td><pre>                K key = n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1127" href="#"></a></td>
<td><pre>                if (!n.appendMarker(f) || !b.casNext(n, f))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1128" href="#"></a></td>
<td><pre>                    findNode(key);                  // retry via findNode</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1129" href="#"></a></td>
<td><pre>                else {                              // clean index</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1130" href="#"></a></td>
<td><pre>                    findPredecessor(key, comparator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1131" href="#"></a></td>
<td><pre>                    if (head.right == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1132" href="#"></a></td>
<td><pre>                        tryReduceLevel();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1133" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1134" href="#"></a></td>
<td><pre>                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1135" href="#"></a></td>
<td><pre>                return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(key, vv);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1136" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1137" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1138" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1139" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1140" href="#"></a></td>
<td><pre>    /* ---------------- Finding and removing last element -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1141" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1142" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1143" href="#"></a></td>
<td><pre>     * Specialized version of find to get last valid node.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1144" href="#"></a></td>
<td><pre>     * @return last node or null if empty</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1145" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1146" href="#"></a></td>
<td><pre>    final Node&lt;K,V&gt; findLast() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1147" href="#"></a></td>
<td><pre>        /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1148" href="#"></a></td>
<td><pre>         * findPredecessor can't be used to traverse index level</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1149" href="#"></a></td>
<td><pre>         * because this doesn't use comparisons.  So traversals of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1150" href="#"></a></td>
<td><pre>         * both levels are folded together.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1151" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1152" href="#"></a></td>
<td><pre>        Index&lt;K,V&gt; q = head;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1153" href="#"></a></td>
<td><pre>        for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1154" href="#"></a></td>
<td><pre>            Index&lt;K,V&gt; d, r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1155" href="#"></a></td>
<td><pre>            if ((r = q.right) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1156" href="#"></a></td>
<td><pre>                if (r.indexesDeletedNode()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1157" href="#"></a></td>
<td><pre>                    q.unlink(r);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1158" href="#"></a></td>
<td><pre>                    q = head; // restart</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1159" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1160" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1161" href="#"></a></td>
<td><pre>                    q = r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1162" href="#"></a></td>
<td><pre>            } else if ((d = q.down) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1163" href="#"></a></td>
<td><pre>                q = d;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1164" href="#"></a></td>
<td><pre>            } else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1165" href="#"></a></td>
<td><pre>                for (Node&lt;K,V&gt; b = q.node, n = b.next;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1166" href="#"></a></td>
<td><pre>                    if (n == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1167" href="#"></a></td>
<td><pre>                        return b.isBaseHeader() ? null : b;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1168" href="#"></a></td>
<td><pre>                    Node&lt;K,V&gt; f = n.next;            // inconsistent read</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1169" href="#"></a></td>
<td><pre>                    if (n != b.next)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1170" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1171" href="#"></a></td>
<td><pre>                    Object v = n.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1172" href="#"></a></td>
<td><pre>                    if (v == null) {                 // n is deleted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1173" href="#"></a></td>
<td><pre>                        n.helpDelete(b, f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1174" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1175" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1176" href="#"></a></td>
<td><pre>                    if (b.value == null || v == n)      // b is deleted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1177" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1178" href="#"></a></td>
<td><pre>                    b = n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1179" href="#"></a></td>
<td><pre>                    n = f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1180" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1181" href="#"></a></td>
<td><pre>                q = head; // restart</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1182" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1183" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1184" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1185" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1186" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1187" href="#"></a></td>
<td><pre>     * Specialized variant of findPredecessor to get predecessor of last</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1188" href="#"></a></td>
<td><pre>     * valid node.  Needed when removing the last entry.  It is possible</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1189" href="#"></a></td>
<td><pre>     * that all successors of returned node will have been deleted upon</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1190" href="#"></a></td>
<td><pre>     * return, in which case this method can be retried.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1191" href="#"></a></td>
<td><pre>     * @return likely predecessor of last node</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1192" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1193" href="#"></a></td>
<td><pre>    private Node&lt;K,V&gt; findPredecessorOfLast() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1194" href="#"></a></td>
<td><pre>        for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1195" href="#"></a></td>
<td><pre>            for (Index&lt;K,V&gt; q = head;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1196" href="#"></a></td>
<td><pre>                Index&lt;K,V&gt; d, r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1197" href="#"></a></td>
<td><pre>                if ((r = q.right) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1198" href="#"></a></td>
<td><pre>                    if (r.indexesDeletedNode()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1199" href="#"></a></td>
<td><pre>                        q.unlink(r);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1200" href="#"></a></td>
<td><pre>                        break;    // must restart</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1201" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1202" href="#"></a></td>
<td><pre>                    // proceed as far across as possible without overshooting</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1203" href="#"></a></td>
<td><pre>                    if (r.node.next != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1204" href="#"></a></td>
<td><pre>                        q = r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1205" href="#"></a></td>
<td><pre>                        continue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1206" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1207" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1208" href="#"></a></td>
<td><pre>                if ((d = q.down) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1209" href="#"></a></td>
<td><pre>                    q = d;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1210" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1211" href="#"></a></td>
<td><pre>                    return q.node;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1212" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1213" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1214" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1215" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1216" href="#"></a></td>
<td><pre>    /* ---------------- Relational operations -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1217" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1218" href="#"></a></td>
<td><pre>    // Control values OR'ed as arguments to findNear</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1219" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1220" href="#"></a></td>
<td><pre>    private static final int EQ = 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1221" href="#"></a></td>
<td><pre>    private static final int LT = 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1222" href="#"></a></td>
<td><pre>    private static final int GT = 0; // Actually checked as !LT</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1223" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1224" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1225" href="#"></a></td>
<td><pre>     * Utility for ceiling, floor, lower, higher methods.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1226" href="#"></a></td>
<td><pre>     * @param key the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1227" href="#"></a></td>
<td><pre>     * @param rel the relation -- OR'ed combination of EQ, LT, GT</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1228" href="#"></a></td>
<td><pre>     * @return nearest node fitting relation, or null if no such</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1229" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1230" href="#"></a></td>
<td><pre>    final Node&lt;K,V&gt; findNear(K key, int rel, Comparator&lt;? super K&gt; cmp) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1231" href="#"></a></td>
<td><pre>        if (key == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1232" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1233" href="#"></a></td>
<td><pre>        for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1234" href="#"></a></td>
<td><pre>            for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1235" href="#"></a></td>
<td><pre>                Object v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1236" href="#"></a></td>
<td><pre>                if (n == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1237" href="#"></a></td>
<td><pre>                    return ((rel &amp; LT) == 0 || b.isBaseHeader()) ? null : b;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1238" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; f = n.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1239" href="#"></a></td>
<td><pre>                if (n != b.next)                  // inconsistent read</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1240" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1241" href="#"></a></td>
<td><pre>                if ((v = n.value) == null) {      // n is deleted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1242" href="#"></a></td>
<td><pre>                    n.helpDelete(b, f);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1243" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1244" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1245" href="#"></a></td>
<td><pre>                if (b.value == null || v == n)      // b is deleted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1246" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1247" href="#"></a></td>
<td><pre>                int c = cpr(cmp, key, n.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1248" href="#"></a></td>
<td><pre>                if ((c == 0 &amp;&amp; (rel &amp; EQ) != 0) ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1249" href="#"></a></td>
<td><pre>                    (c &lt;  0 &amp;&amp; (rel &amp; LT) == 0))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1250" href="#"></a></td>
<td><pre>                    return n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1251" href="#"></a></td>
<td><pre>                if ( c &lt;= 0 &amp;&amp; (rel &amp; LT) != 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1252" href="#"></a></td>
<td><pre>                    return b.isBaseHeader() ? null : b;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1253" href="#"></a></td>
<td><pre>                b = n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1254" href="#"></a></td>
<td><pre>                n = f;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1255" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1256" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1257" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1258" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1259" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1260" href="#"></a></td>
<td><pre>     * Returns SimpleImmutableEntry for results of findNear.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1261" href="#"></a></td>
<td><pre>     * @param key the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1262" href="#"></a></td>
<td><pre>     * @param rel the relation -- OR'ed combination of EQ, LT, GT</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1263" href="#"></a></td>
<td><pre>     * @return Entry fitting relation, or null if no such</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1264" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1265" href="#"></a></td>
<td><pre>    final AbstractMap.SimpleImmutableEntry&lt;K,V&gt; getNear(K key, int rel) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1266" href="#"></a></td>
<td><pre>        Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1267" href="#"></a></td>
<td><pre>        for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1268" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; n = findNear(key, rel, cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1269" href="#"></a></td>
<td><pre>            if (n == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1270" href="#"></a></td>
<td><pre>                return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1271" href="#"></a></td>
<td><pre>            AbstractMap.SimpleImmutableEntry&lt;K,V&gt; e = n.createSnapshot();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1272" href="#"></a></td>
<td><pre>            if (e != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1273" href="#"></a></td>
<td><pre>                return e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1274" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1275" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1276" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1277" href="#"></a></td>
<td><pre>    /* ---------------- Constructors -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1278" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1279" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1280" href="#"></a></td>
<td><pre>     * Constructs a new, empty map, sorted according to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1281" href="#"></a></td>
<td><pre>     * {@linkplain Comparable natural ordering} of the keys.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1282" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1283" href="#"></a></td>
<td><pre>    public ConcurrentSkipListMap() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1284" href="#"></a></td>
<td><pre>        this.comparator = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1285" href="#"></a></td>
<td><pre>        initialize();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1286" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1287" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1288" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1289" href="#"></a></td>
<td><pre>     * Constructs a new, empty map, sorted according to the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1290" href="#"></a></td>
<td><pre>     * comparator.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1291" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1292" href="#"></a></td>
<td><pre>     * @param comparator the comparator that will be used to order this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1293" href="#"></a></td>
<td><pre>     *        If {@code null}, the {@linkplain Comparable natural</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1294" href="#"></a></td>
<td><pre>     *        ordering} of the keys will be used.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1295" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1296" href="#"></a></td>
<td><pre>    public ConcurrentSkipListMap(Comparator&lt;? super K&gt; comparator) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1297" href="#"></a></td>
<td><pre>        this.comparator = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1298" href="#"></a></td>
<td><pre>        initialize();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1299" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1300" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1301" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1302" href="#"></a></td>
<td><pre>     * Constructs a new map containing the same mappings as the given map,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1303" href="#"></a></td>
<td><pre>     * sorted according to the {@linkplain Comparable natural ordering} of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1304" href="#"></a></td>
<td><pre>     * the keys.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1305" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1306" href="#"></a></td>
<td><pre>     * @param  m the map whose mappings are to be placed in this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1307" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the keys in {@code m} are not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1308" href="#"></a></td>
<td><pre>     *         {@link Comparable}, or are not mutually comparable</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1309" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified map or any of its keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1310" href="#"></a></td>
<td><pre>     *         or values are null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1311" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1312" href="#"></a></td>
<td><pre>    public ConcurrentSkipListMap(Map&lt;? extends K, ? extends V&gt; m) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1313" href="#"></a></td>
<td><pre>        this.comparator = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1314" href="#"></a></td>
<td><pre>        initialize();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1315" href="#"></a></td>
<td><pre>        putAll(m);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1316" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1317" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1318" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1319" href="#"></a></td>
<td><pre>     * Constructs a new map containing the same mappings and using the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1320" href="#"></a></td>
<td><pre>     * same ordering as the specified sorted map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1321" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1322" href="#"></a></td>
<td><pre>     * @param m the sorted map whose mappings are to be placed in this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1323" href="#"></a></td>
<td><pre>     *        map, and whose comparator is to be used to sort this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1324" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified sorted map or any of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1325" href="#"></a></td>
<td><pre>     *         its keys or values are null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1326" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1327" href="#"></a></td>
<td><pre>    public ConcurrentSkipListMap(SortedMap&lt;K, ? extends V&gt; m) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1328" href="#"></a></td>
<td><pre>        this.comparator = m.comparator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1329" href="#"></a></td>
<td><pre>        initialize();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1330" href="#"></a></td>
<td><pre>        buildFromSorted(m);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1331" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1332" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1333" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1334" href="#"></a></td>
<td><pre>     * Returns a shallow copy of this {@code ConcurrentSkipListMap}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1335" href="#"></a></td>
<td><pre>     * instance. (The keys and values themselves are not cloned.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1336" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1337" href="#"></a></td>
<td><pre>     * @return a shallow copy of this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1338" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1339" href="#"></a></td>
<td><pre>    public ConcurrentSkipListMap&lt;K,V&gt; clone() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1340" href="#"></a></td>
<td><pre>        try {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1341" href="#"></a></td>
<td><pre>            @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1342" href="#"></a></td>
<td><pre>            ConcurrentSkipListMap&lt;K,V&gt; clone =</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1343" href="#"></a></td>
<td><pre>                (ConcurrentSkipListMap&lt;K,V&gt;) super.clone();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1344" href="#"></a></td>
<td><pre>            clone.initialize();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1345" href="#"></a></td>
<td><pre>            clone.buildFromSorted(this);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1346" href="#"></a></td>
<td><pre>            return clone;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1347" href="#"></a></td>
<td><pre>        } catch (CloneNotSupportedException e) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1348" href="#"></a></td>
<td><pre>            throw new InternalError();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1349" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1350" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1351" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1352" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1353" href="#"></a></td>
<td><pre>     * Streamlined bulk insertion to initialize from elements of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1354" href="#"></a></td>
<td><pre>     * given sorted map.  Call only from constructor or clone</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1355" href="#"></a></td>
<td><pre>     * method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1356" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1357" href="#"></a></td>
<td><pre>    private void buildFromSorted(SortedMap&lt;K, ? extends V&gt; map) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1358" href="#"></a></td>
<td><pre>        if (map == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1359" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1360" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1361" href="#"></a></td>
<td><pre>        HeadIndex&lt;K,V&gt; h = head;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1362" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; basepred = h.node;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1363" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1364" href="#"></a></td>
<td><pre>        // Track the current rightmost node at each level. Uses an</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1365" href="#"></a></td>
<td><pre>        // ArrayList to avoid committing to initial or maximum level.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1366" href="#"></a></td>
<td><pre>        ArrayList&lt;Index&lt;K,V&gt;&gt; preds = new ArrayList&lt;Index&lt;K,V&gt;&gt;();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1367" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1368" href="#"></a></td>
<td><pre>        // initialize</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1369" href="#"></a></td>
<td><pre>        for (int i = 0; i &lt;= h.level; ++i)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1370" href="#"></a></td>
<td><pre>            preds.add(null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1371" href="#"></a></td>
<td><pre>        Index&lt;K,V&gt; q = h;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1372" href="#"></a></td>
<td><pre>        for (int i = h.level; i &gt; 0; --i) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1373" href="#"></a></td>
<td><pre>            preds.set(i, q);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1374" href="#"></a></td>
<td><pre>            q = q.down;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1375" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1376" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1377" href="#"></a></td>
<td><pre>        Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; it =</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1378" href="#"></a></td>
<td><pre>            map.entrySet().iterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1379" href="#"></a></td>
<td><pre>        while (it.hasNext()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1380" href="#"></a></td>
<td><pre>            Map.Entry&lt;? extends K, ? extends V&gt; e = it.next();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1381" href="#"></a></td>
<td><pre>            int rnd = ThreadLocalRandom.current().nextInt();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1382" href="#"></a></td>
<td><pre>            int j = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1383" href="#"></a></td>
<td><pre>            if ((rnd &amp; 0x80000001) == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1384" href="#"></a></td>
<td><pre>                do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1385" href="#"></a></td>
<td><pre>                    ++j;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1386" href="#"></a></td>
<td><pre>                } while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1387" href="#"></a></td>
<td><pre>                if (j &gt; h.level) j = h.level + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1388" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1389" href="#"></a></td>
<td><pre>            K k = e.getKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1390" href="#"></a></td>
<td><pre>            V v = e.getValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1391" href="#"></a></td>
<td><pre>            if (k == null || v == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1392" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1393" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(k, v, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1394" href="#"></a></td>
<td><pre>            basepred.next = z;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1395" href="#"></a></td>
<td><pre>            basepred = z;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1396" href="#"></a></td>
<td><pre>            if (j &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1397" href="#"></a></td>
<td><pre>                Index&lt;K,V&gt; idx = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1398" href="#"></a></td>
<td><pre>                for (int i = 1; i &lt;= j; ++i) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1399" href="#"></a></td>
<td><pre>                    idx = new Index&lt;K,V&gt;(z, idx, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1400" href="#"></a></td>
<td><pre>                    if (i &gt; h.level)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1401" href="#"></a></td>
<td><pre>                        h = new HeadIndex&lt;K,V&gt;(h.node, h, idx, i);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1402" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1403" href="#"></a></td>
<td><pre>                    if (i &lt; preds.size()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1404" href="#"></a></td>
<td><pre>                        preds.get(i).right = idx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1405" href="#"></a></td>
<td><pre>                        preds.set(i, idx);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1406" href="#"></a></td>
<td><pre>                    } else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1407" href="#"></a></td>
<td><pre>                        preds.add(idx);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1408" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1409" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1410" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1411" href="#"></a></td>
<td><pre>        head = h;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1412" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1413" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1414" href="#"></a></td>
<td><pre>    /* ---------------- Serialization -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1415" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1416" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1417" href="#"></a></td>
<td><pre>     * Saves this map to a stream (that is, serializes it).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1418" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1419" href="#"></a></td>
<td><pre>     * @param s the stream</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1420" href="#"></a></td>
<td><pre>     * @throws java.io.IOException if an I/O error occurs</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1421" href="#"></a></td>
<td><pre>     * @serialData The key (Object) and value (Object) for each</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1422" href="#"></a></td>
<td><pre>     * key-value mapping represented by the map, followed by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1423" href="#"></a></td>
<td><pre>     * {@code null}. The key-value mappings are emitted in key-order</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1424" href="#"></a></td>
<td><pre>     * (as determined by the Comparator, or by the keys' natural</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1425" href="#"></a></td>
<td><pre>     * ordering if no Comparator).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1426" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1427" href="#"></a></td>
<td><pre>    private void writeObject(java.io.ObjectOutputStream s)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1428" href="#"></a></td>
<td><pre>        throws java.io.IOException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1429" href="#"></a></td>
<td><pre>        // Write out the Comparator and any hidden stuff</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1430" href="#"></a></td>
<td><pre>        s.defaultWriteObject();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1431" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1432" href="#"></a></td>
<td><pre>        // Write out keys and values (alternating)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1433" href="#"></a></td>
<td><pre>        for (Node&lt;K,V&gt; n = findFirst(); n != null; n = n.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1434" href="#"></a></td>
<td><pre>            V v = n.getValidValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1435" href="#"></a></td>
<td><pre>            if (v != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1436" href="#"></a></td>
<td><pre>                s.writeObject(n.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1437" href="#"></a></td>
<td><pre>                s.writeObject(v);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1438" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1439" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1440" href="#"></a></td>
<td><pre>        s.writeObject(null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1441" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1442" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1443" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1444" href="#"></a></td>
<td><pre>     * Reconstitutes this map from a stream (that is, deserializes it).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1445" href="#"></a></td>
<td><pre>     * @param s the stream</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1446" href="#"></a></td>
<td><pre>     * @throws ClassNotFoundException if the class of a serialized object</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1447" href="#"></a></td>
<td><pre>     *         could not be found</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1448" href="#"></a></td>
<td><pre>     * @throws java.io.IOException if an I/O error occurs</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1449" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1450" href="#"></a></td>
<td><pre>    @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1451" href="#"></a></td>
<td><pre>    private void readObject(final java.io.ObjectInputStream s)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1452" href="#"></a></td>
<td><pre>        throws java.io.IOException, ClassNotFoundException {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1453" href="#"></a></td>
<td><pre>        // Read in the Comparator and any hidden stuff</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1454" href="#"></a></td>
<td><pre>        s.defaultReadObject();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1455" href="#"></a></td>
<td><pre>        // Reset transients</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1456" href="#"></a></td>
<td><pre>        initialize();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1457" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1458" href="#"></a></td>
<td><pre>        /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1459" href="#"></a></td>
<td><pre>         * This is nearly identical to buildFromSorted, but is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1460" href="#"></a></td>
<td><pre>         * distinct because readObject calls can't be nicely adapted</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1461" href="#"></a></td>
<td><pre>         * as the kind of iterator needed by buildFromSorted. (They</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1462" href="#"></a></td>
<td><pre>         * can be, but doing so requires type cheats and/or creation</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1463" href="#"></a></td>
<td><pre>         * of adaptor classes.) It is simpler to just adapt the code.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1464" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1465" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1466" href="#"></a></td>
<td><pre>        HeadIndex&lt;K,V&gt; h = head;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1467" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; basepred = h.node;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1468" href="#"></a></td>
<td><pre>        ArrayList&lt;Index&lt;K,V&gt;&gt; preds = new ArrayList&lt;Index&lt;K,V&gt;&gt;();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1469" href="#"></a></td>
<td><pre>        for (int i = 0; i &lt;= h.level; ++i)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1470" href="#"></a></td>
<td><pre>            preds.add(null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1471" href="#"></a></td>
<td><pre>        Index&lt;K,V&gt; q = h;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1472" href="#"></a></td>
<td><pre>        for (int i = h.level; i &gt; 0; --i) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1473" href="#"></a></td>
<td><pre>            preds.set(i, q);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1474" href="#"></a></td>
<td><pre>            q = q.down;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1475" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1476" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1477" href="#"></a></td>
<td><pre>        for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1478" href="#"></a></td>
<td><pre>            Object k = s.readObject();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1479" href="#"></a></td>
<td><pre>            if (k == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1480" href="#"></a></td>
<td><pre>                break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1481" href="#"></a></td>
<td><pre>            Object v = s.readObject();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1482" href="#"></a></td>
<td><pre>            if (v == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1483" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1484" href="#"></a></td>
<td><pre>            K key = (K) k;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1485" href="#"></a></td>
<td><pre>            V val = (V) v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1486" href="#"></a></td>
<td><pre>            int rnd = ThreadLocalRandom.current().nextInt();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1487" href="#"></a></td>
<td><pre>            int j = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1488" href="#"></a></td>
<td><pre>            if ((rnd &amp; 0x80000001) == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1489" href="#"></a></td>
<td><pre>                do {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1490" href="#"></a></td>
<td><pre>                    ++j;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1491" href="#"></a></td>
<td><pre>                } while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1492" href="#"></a></td>
<td><pre>                if (j &gt; h.level) j = h.level + 1;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1493" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1494" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(key, val, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1495" href="#"></a></td>
<td><pre>            basepred.next = z;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1496" href="#"></a></td>
<td><pre>            basepred = z;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1497" href="#"></a></td>
<td><pre>            if (j &gt; 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1498" href="#"></a></td>
<td><pre>                Index&lt;K,V&gt; idx = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1499" href="#"></a></td>
<td><pre>                for (int i = 1; i &lt;= j; ++i) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1500" href="#"></a></td>
<td><pre>                    idx = new Index&lt;K,V&gt;(z, idx, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1501" href="#"></a></td>
<td><pre>                    if (i &gt; h.level)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1502" href="#"></a></td>
<td><pre>                        h = new HeadIndex&lt;K,V&gt;(h.node, h, idx, i);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1503" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1504" href="#"></a></td>
<td><pre>                    if (i &lt; preds.size()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1505" href="#"></a></td>
<td><pre>                        preds.get(i).right = idx;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1506" href="#"></a></td>
<td><pre>                        preds.set(i, idx);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1507" href="#"></a></td>
<td><pre>                    } else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1508" href="#"></a></td>
<td><pre>                        preds.add(idx);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1509" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1510" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1511" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1512" href="#"></a></td>
<td><pre>        head = h;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1513" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1514" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1515" href="#"></a></td>
<td><pre>    /* ------ Map API methods ------ */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1516" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1517" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1518" href="#"></a></td>
<td><pre>     * Returns {@code true} if this map contains a mapping for the specified</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1519" href="#"></a></td>
<td><pre>     * key.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1520" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1521" href="#"></a></td>
<td><pre>     * @param key key whose presence in this map is to be tested</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1522" href="#"></a></td>
<td><pre>     * @return {@code true} if this map contains a mapping for the specified key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1523" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the specified key cannot be compared</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1524" href="#"></a></td>
<td><pre>     *         with the keys currently in the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1525" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1526" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1527" href="#"></a></td>
<td><pre>    public boolean containsKey(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1528" href="#"></a></td>
<td><pre>        return doGet(key) != null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1529" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1530" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1531" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1532" href="#"></a></td>
<td><pre>     * Returns the value to which the specified key is mapped,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1533" href="#"></a></td>
<td><pre>     * or {@code null} if this map contains no mapping for the key.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1534" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1535" href="#"></a></td>
<td><pre>     * &lt;p&gt;More formally, if this map contains a mapping from a key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1536" href="#"></a></td>
<td><pre>     * {@code k} to a value {@code v} such that {@code key} compares</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1537" href="#"></a></td>
<td><pre>     * equal to {@code k} according to the map's ordering, then this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1538" href="#"></a></td>
<td><pre>     * method returns {@code v}; otherwise it returns {@code null}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1539" href="#"></a></td>
<td><pre>     * (There can be at most one such mapping.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1540" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1541" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the specified key cannot be compared</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1542" href="#"></a></td>
<td><pre>     *         with the keys currently in the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1543" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1544" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1545" href="#"></a></td>
<td><pre>    public V get(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1546" href="#"></a></td>
<td><pre>        return doGet(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1547" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1548" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1549" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1550" href="#"></a></td>
<td><pre>     * Returns the value to which the specified key is mapped,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1551" href="#"></a></td>
<td><pre>     * or the given defaultValue if this map contains no mapping for the key.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1552" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1553" href="#"></a></td>
<td><pre>     * @param key the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1554" href="#"></a></td>
<td><pre>     * @param defaultValue the value to return if this map contains</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1555" href="#"></a></td>
<td><pre>     * no mapping for the given key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1556" href="#"></a></td>
<td><pre>     * @return the mapping for the key, if present; else the defaultValue</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1557" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1558" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1559" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1560" href="#"></a></td>
<td><pre>    public V getOrDefault(Object key, V defaultValue) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1561" href="#"></a></td>
<td><pre>        V v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1562" href="#"></a></td>
<td><pre>        return (v = doGet(key)) == null ? defaultValue : v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1563" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1564" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1565" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1566" href="#"></a></td>
<td><pre>     * Associates the specified value with the specified key in this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1567" href="#"></a></td>
<td><pre>     * If the map previously contained a mapping for the key, the old</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1568" href="#"></a></td>
<td><pre>     * value is replaced.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1569" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1570" href="#"></a></td>
<td><pre>     * @param key key with which the specified value is to be associated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1571" href="#"></a></td>
<td><pre>     * @param value value to be associated with the specified key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1572" href="#"></a></td>
<td><pre>     * @return the previous value associated with the specified key, or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1573" href="#"></a></td>
<td><pre>     *         {@code null} if there was no mapping for the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1574" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the specified key cannot be compared</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1575" href="#"></a></td>
<td><pre>     *         with the keys currently in the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1576" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key or value is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1577" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1578" href="#"></a></td>
<td><pre>    public V put(K key, V value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1579" href="#"></a></td>
<td><pre>        if (value == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1580" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1581" href="#"></a></td>
<td><pre>        return doPut(key, value, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1582" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1583" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1584" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1585" href="#"></a></td>
<td><pre>     * Removes the mapping for the specified key from this map if present.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1586" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1587" href="#"></a></td>
<td><pre>     * @param  key key for which mapping should be removed</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1588" href="#"></a></td>
<td><pre>     * @return the previous value associated with the specified key, or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1589" href="#"></a></td>
<td><pre>     *         {@code null} if there was no mapping for the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1590" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the specified key cannot be compared</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1591" href="#"></a></td>
<td><pre>     *         with the keys currently in the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1592" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1593" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1594" href="#"></a></td>
<td><pre>    public V remove(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1595" href="#"></a></td>
<td><pre>        return doRemove(key, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1596" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1597" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1598" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1599" href="#"></a></td>
<td><pre>     * Returns {@code true} if this map maps one or more keys to the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1600" href="#"></a></td>
<td><pre>     * specified value.  This operation requires time linear in the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1601" href="#"></a></td>
<td><pre>     * map size. Additionally, it is possible for the map to change</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1602" href="#"></a></td>
<td><pre>     * during execution of this method, in which case the returned</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1603" href="#"></a></td>
<td><pre>     * result may be inaccurate.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1604" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1605" href="#"></a></td>
<td><pre>     * @param value value whose presence in this map is to be tested</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1606" href="#"></a></td>
<td><pre>     * @return {@code true} if a mapping to {@code value} exists;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1607" href="#"></a></td>
<td><pre>     *         {@code false} otherwise</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1608" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified value is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1609" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1610" href="#"></a></td>
<td><pre>    public boolean containsValue(Object value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1611" href="#"></a></td>
<td><pre>        if (value == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1612" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1613" href="#"></a></td>
<td><pre>        for (Node&lt;K,V&gt; n = findFirst(); n != null; n = n.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1614" href="#"></a></td>
<td><pre>            V v = n.getValidValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1615" href="#"></a></td>
<td><pre>            if (v != null &amp;&amp; value.equals(v))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1616" href="#"></a></td>
<td><pre>                return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1617" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1618" href="#"></a></td>
<td><pre>        return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1619" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1620" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1621" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1622" href="#"></a></td>
<td><pre>     * Returns the number of key-value mappings in this map.  If this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1623" href="#"></a></td>
<td><pre>     * contains more than {@code Integer.MAX_VALUE} elements, it</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1624" href="#"></a></td>
<td><pre>     * returns {@code Integer.MAX_VALUE}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1625" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1626" href="#"></a></td>
<td><pre>     * &lt;p&gt;Beware that, unlike in most collections, this method is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1627" href="#"></a></td>
<td><pre>     * &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1628" href="#"></a></td>
<td><pre>     * asynchronous nature of these maps, determining the current</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1629" href="#"></a></td>
<td><pre>     * number of elements requires traversing them all to count them.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1630" href="#"></a></td>
<td><pre>     * Additionally, it is possible for the size to change during</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1631" href="#"></a></td>
<td><pre>     * execution of this method, in which case the returned result</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1632" href="#"></a></td>
<td><pre>     * will be inaccurate. Thus, this method is typically not very</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1633" href="#"></a></td>
<td><pre>     * useful in concurrent applications.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1634" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1635" href="#"></a></td>
<td><pre>     * @return the number of elements in this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1636" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1637" href="#"></a></td>
<td><pre>    public int size() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1638" href="#"></a></td>
<td><pre>        long count = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1639" href="#"></a></td>
<td><pre>        for (Node&lt;K,V&gt; n = findFirst(); n != null; n = n.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1640" href="#"></a></td>
<td><pre>            if (n.getValidValue() != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1641" href="#"></a></td>
<td><pre>                ++count;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1642" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1643" href="#"></a></td>
<td><pre>        return (count &gt;= Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) count;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1644" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1645" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1646" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1647" href="#"></a></td>
<td><pre>     * Returns {@code true} if this map contains no key-value mappings.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1648" href="#"></a></td>
<td><pre>     * @return {@code true} if this map contains no key-value mappings</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1649" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1650" href="#"></a></td>
<td><pre>    public boolean isEmpty() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1651" href="#"></a></td>
<td><pre>        return findFirst() == null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1652" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1653" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1654" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1655" href="#"></a></td>
<td><pre>     * Removes all of the mappings from this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1656" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1657" href="#"></a></td>
<td><pre>    public void clear() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1658" href="#"></a></td>
<td><pre>        initialize();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1659" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1660" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1661" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1662" href="#"></a></td>
<td><pre>     * If the specified key is not already associated with a value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1663" href="#"></a></td>
<td><pre>     * attempts to compute its value using the given mapping function</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1664" href="#"></a></td>
<td><pre>     * and enters it into this map unless {@code null}.  The function</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1665" href="#"></a></td>
<td><pre>     * is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically only</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1666" href="#"></a></td>
<td><pre>     * if the value is not present.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1667" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1668" href="#"></a></td>
<td><pre>     * @param key key with which the specified value is to be associated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1669" href="#"></a></td>
<td><pre>     * @param mappingFunction the function to compute a value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1670" href="#"></a></td>
<td><pre>     * @return the current (existing or computed) value associated with</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1671" href="#"></a></td>
<td><pre>     *         the specified key, or null if the computed value is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1672" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1673" href="#"></a></td>
<td><pre>     *         or the mappingFunction is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1674" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1675" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1676" href="#"></a></td>
<td><pre>    public V computeIfAbsent(K key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1677" href="#"></a></td>
<td><pre>                             Function&lt;? super K, ? extends V&gt; mappingFunction) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1678" href="#"></a></td>
<td><pre>        if (key == null || mappingFunction == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1679" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1680" href="#"></a></td>
<td><pre>        V v, p, r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1681" href="#"></a></td>
<td><pre>        if ((v = doGet(key)) == null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1682" href="#"></a></td>
<td><pre>            (r = mappingFunction.apply(key)) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1683" href="#"></a></td>
<td><pre>            v = (p = doPut(key, r, true)) == null ? r : p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1684" href="#"></a></td>
<td><pre>        return v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1685" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1686" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1687" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1688" href="#"></a></td>
<td><pre>     * If the value for the specified key is present, attempts to</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1689" href="#"></a></td>
<td><pre>     * compute a new mapping given the key and its current mapped</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1690" href="#"></a></td>
<td><pre>     * value. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1691" href="#"></a></td>
<td><pre>     * once atomically.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1692" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1693" href="#"></a></td>
<td><pre>     * @param key key with which a value may be associated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1694" href="#"></a></td>
<td><pre>     * @param remappingFunction the function to compute a value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1695" href="#"></a></td>
<td><pre>     * @return the new value associated with the specified key, or null if none</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1696" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1697" href="#"></a></td>
<td><pre>     *         or the remappingFunction is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1698" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1699" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1700" href="#"></a></td>
<td><pre>    public V computeIfPresent(K key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1701" href="#"></a></td>
<td><pre>                              BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1702" href="#"></a></td>
<td><pre>        if (key == null || remappingFunction == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1703" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1704" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; n; Object v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1705" href="#"></a></td>
<td><pre>        while ((n = findNode(key)) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1706" href="#"></a></td>
<td><pre>            if ((v = n.value) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1707" href="#"></a></td>
<td><pre>                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V) v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1708" href="#"></a></td>
<td><pre>                V r = remappingFunction.apply(key, vv);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1709" href="#"></a></td>
<td><pre>                if (r != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1710" href="#"></a></td>
<td><pre>                    if (n.casValue(vv, r))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1711" href="#"></a></td>
<td><pre>                        return r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1712" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1713" href="#"></a></td>
<td><pre>                else if (doRemove(key, vv) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1714" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1715" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1716" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1717" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1718" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1719" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1720" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1721" href="#"></a></td>
<td><pre>     * Attempts to compute a mapping for the specified key and its</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1722" href="#"></a></td>
<td><pre>     * current mapped value (or {@code null} if there is no current</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1723" href="#"></a></td>
<td><pre>     * mapping). The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1724" href="#"></a></td>
<td><pre>     * once atomically.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1725" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1726" href="#"></a></td>
<td><pre>     * @param key key with which the specified value is to be associated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1727" href="#"></a></td>
<td><pre>     * @param remappingFunction the function to compute a value</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1728" href="#"></a></td>
<td><pre>     * @return the new value associated with the specified key, or null if none</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1729" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1730" href="#"></a></td>
<td><pre>     *         or the remappingFunction is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1731" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1732" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1733" href="#"></a></td>
<td><pre>    public V compute(K key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1734" href="#"></a></td>
<td><pre>                     BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1735" href="#"></a></td>
<td><pre>        if (key == null || remappingFunction == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1736" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1737" href="#"></a></td>
<td><pre>        for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1738" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; n; Object v; V r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1739" href="#"></a></td>
<td><pre>            if ((n = findNode(key)) == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1740" href="#"></a></td>
<td><pre>                if ((r = remappingFunction.apply(key, null)) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1741" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1742" href="#"></a></td>
<td><pre>                if (doPut(key, r, true) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1743" href="#"></a></td>
<td><pre>                    return r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1744" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1745" href="#"></a></td>
<td><pre>            else if ((v = n.value) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1746" href="#"></a></td>
<td><pre>                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V) v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1747" href="#"></a></td>
<td><pre>                if ((r = remappingFunction.apply(key, vv)) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1748" href="#"></a></td>
<td><pre>                    if (n.casValue(vv, r))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1749" href="#"></a></td>
<td><pre>                        return r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1750" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1751" href="#"></a></td>
<td><pre>                else if (doRemove(key, vv) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1752" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1753" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1754" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1755" href="#"></a></td>
<td><pre>        return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1756" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1757" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1758" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1759" href="#"></a></td>
<td><pre>     * If the specified key is not already associated with a value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1760" href="#"></a></td>
<td><pre>     * associates it with the given value.  Otherwise, replaces the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1761" href="#"></a></td>
<td><pre>     * value with the results of the given remapping function, or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1762" href="#"></a></td>
<td><pre>     * removes if {@code null}. The function is &lt;em&gt;NOT&lt;/em&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1763" href="#"></a></td>
<td><pre>     * guaranteed to be applied once atomically.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1764" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1765" href="#"></a></td>
<td><pre>     * @param key key with which the specified value is to be associated</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1766" href="#"></a></td>
<td><pre>     * @param value the value to use if absent</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1767" href="#"></a></td>
<td><pre>     * @param remappingFunction the function to recompute a value if present</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1768" href="#"></a></td>
<td><pre>     * @return the new value associated with the specified key, or null if none</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1769" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key or value is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1770" href="#"></a></td>
<td><pre>     *         or the remappingFunction is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1771" href="#"></a></td>
<td><pre>     * @since 1.8</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1772" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1773" href="#"></a></td>
<td><pre>    public V merge(K key, V value,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1774" href="#"></a></td>
<td><pre>                   BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1775" href="#"></a></td>
<td><pre>        if (key == null || value == null || remappingFunction == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1776" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1777" href="#"></a></td>
<td><pre>        for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1778" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; n; Object v; V r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1779" href="#"></a></td>
<td><pre>            if ((n = findNode(key)) == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1780" href="#"></a></td>
<td><pre>                if (doPut(key, value, true) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1781" href="#"></a></td>
<td><pre>                    return value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1782" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1783" href="#"></a></td>
<td><pre>            else if ((v = n.value) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1784" href="#"></a></td>
<td><pre>                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V) v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1785" href="#"></a></td>
<td><pre>                if ((r = remappingFunction.apply(vv, value)) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1786" href="#"></a></td>
<td><pre>                    if (n.casValue(vv, r))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1787" href="#"></a></td>
<td><pre>                        return r;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1788" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1789" href="#"></a></td>
<td><pre>                else if (doRemove(key, vv) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1790" href="#"></a></td>
<td><pre>                    return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1791" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1792" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1793" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1794" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1795" href="#"></a></td>
<td><pre>    /* ---------------- View methods -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1796" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1797" href="#"></a></td>
<td><pre>    /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1798" href="#"></a></td>
<td><pre>     * Note: Lazy initialization works for views because view classes</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1799" href="#"></a></td>
<td><pre>     * are stateless/immutable so it doesn't matter wrt correctness if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1800" href="#"></a></td>
<td><pre>     * more than one is created (which will only rarely happen).  Even</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1801" href="#"></a></td>
<td><pre>     * so, the following idiom conservatively ensures that the method</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1802" href="#"></a></td>
<td><pre>     * returns the one it created if it does so, not one created by</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1803" href="#"></a></td>
<td><pre>     * another racing thread.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1804" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1805" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1806" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1807" href="#"></a></td>
<td><pre>     * Returns a {@link NavigableSet} view of the keys contained in this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1808" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1809" href="#"></a></td>
<td><pre>     * &lt;p&gt;The set's iterator returns the keys in ascending order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1810" href="#"></a></td>
<td><pre>     * The set's spliterator additionally reports {@link Spliterator#CONCURRENT},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1811" href="#"></a></td>
<td><pre>     * {@link Spliterator#NONNULL}, {@link Spliterator#SORTED} and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1812" href="#"></a></td>
<td><pre>     * {@link Spliterator#ORDERED}, with an encounter order that is ascending</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1813" href="#"></a></td>
<td><pre>     * key order.  The spliterator's comparator (see</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1814" href="#"></a></td>
<td><pre>     * {@link java.util.Spliterator#getComparator()}) is {@code null} if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1815" href="#"></a></td>
<td><pre>     * the map's comparator (see {@link #comparator()}) is {@code null}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1816" href="#"></a></td>
<td><pre>     * Otherwise, the spliterator's comparator is the same as or imposes the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1817" href="#"></a></td>
<td><pre>     * same total ordering as the map's comparator.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1818" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1819" href="#"></a></td>
<td><pre>     * &lt;p&gt;The set is backed by the map, so changes to the map are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1820" href="#"></a></td>
<td><pre>     * reflected in the set, and vice-versa.  The set supports element</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1821" href="#"></a></td>
<td><pre>     * removal, which removes the corresponding mapping from the map,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1822" href="#"></a></td>
<td><pre>     * via the {@code Iterator.remove}, {@code Set.remove},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1823" href="#"></a></td>
<td><pre>     * {@code removeAll}, {@code retainAll}, and {@code clear}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1824" href="#"></a></td>
<td><pre>     * operations.  It does not support the {@code add} or {@code addAll}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1825" href="#"></a></td>
<td><pre>     * operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1826" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1827" href="#"></a></td>
<td><pre>     * &lt;p&gt;The view's iterators and spliterators are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1828" href="#"></a></td>
<td><pre>     * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1829" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1830" href="#"></a></td>
<td><pre>     * &lt;p&gt;This method is equivalent to method {@code navigableKeySet}.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1831" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1832" href="#"></a></td>
<td><pre>     * @return a navigable set view of the keys in this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1833" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1834" href="#"></a></td>
<td><pre>    public NavigableSet&lt;K&gt; keySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1835" href="#"></a></td>
<td><pre>        KeySet&lt;K&gt; ks = keySet;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1836" href="#"></a></td>
<td><pre>        return (ks != null) ? ks : (keySet = new KeySet&lt;K&gt;(this));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1837" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1838" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1839" href="#"></a></td>
<td><pre>    public NavigableSet&lt;K&gt; navigableKeySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1840" href="#"></a></td>
<td><pre>        KeySet&lt;K&gt; ks = keySet;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1841" href="#"></a></td>
<td><pre>        return (ks != null) ? ks : (keySet = new KeySet&lt;K&gt;(this));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1842" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1843" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1844" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1845" href="#"></a></td>
<td><pre>     * Returns a {@link Collection} view of the values contained in this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1846" href="#"></a></td>
<td><pre>     * &lt;p&gt;The collection's iterator returns the values in ascending order</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1847" href="#"></a></td>
<td><pre>     * of the corresponding keys. The collections's spliterator additionally</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1848" href="#"></a></td>
<td><pre>     * reports {@link Spliterator#CONCURRENT}, {@link Spliterator#NONNULL} and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1849" href="#"></a></td>
<td><pre>     * {@link Spliterator#ORDERED}, with an encounter order that is ascending</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1850" href="#"></a></td>
<td><pre>     * order of the corresponding keys.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1851" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1852" href="#"></a></td>
<td><pre>     * &lt;p&gt;The collection is backed by the map, so changes to the map are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1853" href="#"></a></td>
<td><pre>     * reflected in the collection, and vice-versa.  The collection</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1854" href="#"></a></td>
<td><pre>     * supports element removal, which removes the corresponding</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1855" href="#"></a></td>
<td><pre>     * mapping from the map, via the {@code Iterator.remove},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1856" href="#"></a></td>
<td><pre>     * {@code Collection.remove}, {@code removeAll},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1857" href="#"></a></td>
<td><pre>     * {@code retainAll} and {@code clear} operations.  It does not</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1858" href="#"></a></td>
<td><pre>     * support the {@code add} or {@code addAll} operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1859" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1860" href="#"></a></td>
<td><pre>     * &lt;p&gt;The view's iterators and spliterators are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1861" href="#"></a></td>
<td><pre>     * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1862" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1863" href="#"></a></td>
<td><pre>    public Collection&lt;V&gt; values() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1864" href="#"></a></td>
<td><pre>        Values&lt;V&gt; vs = values;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1865" href="#"></a></td>
<td><pre>        return (vs != null) ? vs : (values = new Values&lt;V&gt;(this));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1866" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1867" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1868" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1869" href="#"></a></td>
<td><pre>     * Returns a {@link Set} view of the mappings contained in this map.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1870" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1871" href="#"></a></td>
<td><pre>     * &lt;p&gt;The set's iterator returns the entries in ascending key order.  The</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1872" href="#"></a></td>
<td><pre>     * set's spliterator additionally reports {@link Spliterator#CONCURRENT},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1873" href="#"></a></td>
<td><pre>     * {@link Spliterator#NONNULL}, {@link Spliterator#SORTED} and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1874" href="#"></a></td>
<td><pre>     * {@link Spliterator#ORDERED}, with an encounter order that is ascending</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1875" href="#"></a></td>
<td><pre>     * key order.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1876" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1877" href="#"></a></td>
<td><pre>     * &lt;p&gt;The set is backed by the map, so changes to the map are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1878" href="#"></a></td>
<td><pre>     * reflected in the set, and vice-versa.  The set supports element</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1879" href="#"></a></td>
<td><pre>     * removal, which removes the corresponding mapping from the map,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1880" href="#"></a></td>
<td><pre>     * via the {@code Iterator.remove}, {@code Set.remove},</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1881" href="#"></a></td>
<td><pre>     * {@code removeAll}, {@code retainAll} and {@code clear}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1882" href="#"></a></td>
<td><pre>     * operations.  It does not support the {@code add} or</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1883" href="#"></a></td>
<td><pre>     * {@code addAll} operations.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1884" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1885" href="#"></a></td>
<td><pre>     * &lt;p&gt;The view's iterators and spliterators are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1886" href="#"></a></td>
<td><pre>     * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1887" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1888" href="#"></a></td>
<td><pre>     * &lt;p&gt;The {@code Map.Entry} elements traversed by the {@code iterator}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1889" href="#"></a></td>
<td><pre>     * or {@code spliterator} do &lt;em&gt;not&lt;/em&gt; support the {@code setValue}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1890" href="#"></a></td>
<td><pre>     * operation.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1891" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1892" href="#"></a></td>
<td><pre>     * @return a set view of the mappings contained in this map,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1893" href="#"></a></td>
<td><pre>     *         sorted in ascending key order</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1894" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1895" href="#"></a></td>
<td><pre>    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1896" href="#"></a></td>
<td><pre>        EntrySet&lt;K,V&gt; es = entrySet;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1897" href="#"></a></td>
<td><pre>        return (es != null) ? es : (entrySet = new EntrySet&lt;K,V&gt;(this));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1898" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1899" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1900" href="#"></a></td>
<td><pre>    public ConcurrentNavigableMap&lt;K,V&gt; descendingMap() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1901" href="#"></a></td>
<td><pre>        ConcurrentNavigableMap&lt;K,V&gt; dm = descendingMap;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1902" href="#"></a></td>
<td><pre>        return (dm != null) ? dm : (descendingMap = new SubMap&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1903" href="#"></a></td>
<td><pre>                                    (this, null, false, null, false, true));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1904" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1905" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1906" href="#"></a></td>
<td><pre>    public NavigableSet&lt;K&gt; descendingKeySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1907" href="#"></a></td>
<td><pre>        return descendingMap().navigableKeySet();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1908" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1909" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1910" href="#"></a></td>
<td><pre>    /* ---------------- AbstractMap Overrides -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1911" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1912" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1913" href="#"></a></td>
<td><pre>     * Compares the specified object with this map for equality.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1914" href="#"></a></td>
<td><pre>     * Returns {@code true} if the given object is also a map and the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1915" href="#"></a></td>
<td><pre>     * two maps represent the same mappings.  More formally, two maps</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1916" href="#"></a></td>
<td><pre>     * {@code m1} and {@code m2} represent the same mappings if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1917" href="#"></a></td>
<td><pre>     * {@code m1.entrySet().equals(m2.entrySet())}.  This</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1918" href="#"></a></td>
<td><pre>     * operation may return misleading results if either map is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1919" href="#"></a></td>
<td><pre>     * concurrently modified during execution of this method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1920" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1921" href="#"></a></td>
<td><pre>     * @param o object to be compared for equality with this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1922" href="#"></a></td>
<td><pre>     * @return {@code true} if the specified object is equal to this map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1923" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1924" href="#"></a></td>
<td><pre>    public boolean equals(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1925" href="#"></a></td>
<td><pre>        if (o == this)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1926" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1927" href="#"></a></td>
<td><pre>        if (!(o instanceof Map))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1928" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1929" href="#"></a></td>
<td><pre>        Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1930" href="#"></a></td>
<td><pre>        try {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1931" href="#"></a></td>
<td><pre>            for (Map.Entry&lt;K,V&gt; e : this.entrySet())</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1932" href="#"></a></td>
<td><pre>                if (! e.getValue().equals(m.get(e.getKey())))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1933" href="#"></a></td>
<td><pre>                    return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1934" href="#"></a></td>
<td><pre>            for (Map.Entry&lt;?,?&gt; e : m.entrySet()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1935" href="#"></a></td>
<td><pre>                Object k = e.getKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1936" href="#"></a></td>
<td><pre>                Object v = e.getValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1937" href="#"></a></td>
<td><pre>                if (k == null || v == null || !v.equals(get(k)))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1938" href="#"></a></td>
<td><pre>                    return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1939" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1940" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1941" href="#"></a></td>
<td><pre>        } catch (ClassCastException unused) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1942" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1943" href="#"></a></td>
<td><pre>        } catch (NullPointerException unused) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1944" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1945" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1946" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1947" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1948" href="#"></a></td>
<td><pre>    /* ------ ConcurrentMap API methods ------ */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1949" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1950" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1951" href="#"></a></td>
<td><pre>     * {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1952" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1953" href="#"></a></td>
<td><pre>     * @return the previous value associated with the specified key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1954" href="#"></a></td>
<td><pre>     *         or {@code null} if there was no mapping for the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1955" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the specified key cannot be compared</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1956" href="#"></a></td>
<td><pre>     *         with the keys currently in the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1957" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key or value is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1958" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1959" href="#"></a></td>
<td><pre>    public V putIfAbsent(K key, V value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1960" href="#"></a></td>
<td><pre>        if (value == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1961" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1962" href="#"></a></td>
<td><pre>        return doPut(key, value, true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1963" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1964" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1965" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1966" href="#"></a></td>
<td><pre>     * {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1967" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1968" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the specified key cannot be compared</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1969" href="#"></a></td>
<td><pre>     *         with the keys currently in the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1970" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1971" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1972" href="#"></a></td>
<td><pre>    public boolean remove(Object key, Object value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1973" href="#"></a></td>
<td><pre>        if (key == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1974" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1975" href="#"></a></td>
<td><pre>        return value != null &amp;&amp; doRemove(key, value) != null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1976" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1977" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1978" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1979" href="#"></a></td>
<td><pre>     * {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1980" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1981" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the specified key cannot be compared</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1982" href="#"></a></td>
<td><pre>     *         with the keys currently in the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1983" href="#"></a></td>
<td><pre>     * @throws NullPointerException if any of the arguments are null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1984" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1985" href="#"></a></td>
<td><pre>    public boolean replace(K key, V oldValue, V newValue) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1986" href="#"></a></td>
<td><pre>        if (key == null || oldValue == null || newValue == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1987" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1988" href="#"></a></td>
<td><pre>        for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1989" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; n; Object v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1990" href="#"></a></td>
<td><pre>            if ((n = findNode(key)) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1991" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1992" href="#"></a></td>
<td><pre>            if ((v = n.value) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1993" href="#"></a></td>
<td><pre>                if (!oldValue.equals(v))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1994" href="#"></a></td>
<td><pre>                    return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1995" href="#"></a></td>
<td><pre>                if (n.casValue(v, newValue))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1996" href="#"></a></td>
<td><pre>                    return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1997" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1998" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="1999" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2000" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2001" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2002" href="#"></a></td>
<td><pre>     * {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2003" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2004" href="#"></a></td>
<td><pre>     * @return the previous value associated with the specified key,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2005" href="#"></a></td>
<td><pre>     *         or {@code null} if there was no mapping for the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2006" href="#"></a></td>
<td><pre>     * @throws ClassCastException if the specified key cannot be compared</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2007" href="#"></a></td>
<td><pre>     *         with the keys currently in the map</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2008" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key or value is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2009" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2010" href="#"></a></td>
<td><pre>    public V replace(K key, V value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2011" href="#"></a></td>
<td><pre>        if (key == null || value == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2012" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2013" href="#"></a></td>
<td><pre>        for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2014" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; n; Object v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2015" href="#"></a></td>
<td><pre>            if ((n = findNode(key)) == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2016" href="#"></a></td>
<td><pre>                return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2017" href="#"></a></td>
<td><pre>            if ((v = n.value) != null &amp;&amp; n.casValue(v, value)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2018" href="#"></a></td>
<td><pre>                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2019" href="#"></a></td>
<td><pre>                return vv;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2020" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2021" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2022" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2023" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2024" href="#"></a></td>
<td><pre>    /* ------ SortedMap API methods ------ */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2025" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2026" href="#"></a></td>
<td><pre>    public Comparator&lt;? super K&gt; comparator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2027" href="#"></a></td>
<td><pre>        return comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2028" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2029" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2030" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2031" href="#"></a></td>
<td><pre>     * @throws NoSuchElementException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2032" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2033" href="#"></a></td>
<td><pre>    public K firstKey() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2034" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; n = findFirst();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2035" href="#"></a></td>
<td><pre>        if (n == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2036" href="#"></a></td>
<td><pre>            throw new NoSuchElementException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2037" href="#"></a></td>
<td><pre>        return n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2038" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2039" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2040" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2041" href="#"></a></td>
<td><pre>     * @throws NoSuchElementException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2042" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2043" href="#"></a></td>
<td><pre>    public K lastKey() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2044" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; n = findLast();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2045" href="#"></a></td>
<td><pre>        if (n == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2046" href="#"></a></td>
<td><pre>            throw new NoSuchElementException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2047" href="#"></a></td>
<td><pre>        return n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2048" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2049" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2050" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2051" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2052" href="#"></a></td>
<td><pre>     * @throws NullPointerException if {@code fromKey} or {@code toKey} is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2053" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2054" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2055" href="#"></a></td>
<td><pre>    public ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2056" href="#"></a></td>
<td><pre>                                              boolean fromInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2057" href="#"></a></td>
<td><pre>                                              K toKey,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2058" href="#"></a></td>
<td><pre>                                              boolean toInclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2059" href="#"></a></td>
<td><pre>        if (fromKey == null || toKey == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2060" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2061" href="#"></a></td>
<td><pre>        return new SubMap&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2062" href="#"></a></td>
<td><pre>            (this, fromKey, fromInclusive, toKey, toInclusive, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2063" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2064" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2065" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2066" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2067" href="#"></a></td>
<td><pre>     * @throws NullPointerException if {@code toKey} is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2068" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2069" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2070" href="#"></a></td>
<td><pre>    public ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2071" href="#"></a></td>
<td><pre>                                               boolean inclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2072" href="#"></a></td>
<td><pre>        if (toKey == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2073" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2074" href="#"></a></td>
<td><pre>        return new SubMap&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2075" href="#"></a></td>
<td><pre>            (this, null, false, toKey, inclusive, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2076" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2077" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2078" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2079" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2080" href="#"></a></td>
<td><pre>     * @throws NullPointerException if {@code fromKey} is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2081" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2082" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2083" href="#"></a></td>
<td><pre>    public ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2084" href="#"></a></td>
<td><pre>                                               boolean inclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2085" href="#"></a></td>
<td><pre>        if (fromKey == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2086" href="#"></a></td>
<td><pre>            throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2087" href="#"></a></td>
<td><pre>        return new SubMap&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2088" href="#"></a></td>
<td><pre>            (this, fromKey, inclusive, null, false, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2089" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2090" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2091" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2092" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2093" href="#"></a></td>
<td><pre>     * @throws NullPointerException if {@code fromKey} or {@code toKey} is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2094" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2095" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2096" href="#"></a></td>
<td><pre>    public ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey, K toKey) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2097" href="#"></a></td>
<td><pre>        return subMap(fromKey, true, toKey, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2098" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2099" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2100" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2101" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2102" href="#"></a></td>
<td><pre>     * @throws NullPointerException if {@code toKey} is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2103" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2104" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2105" href="#"></a></td>
<td><pre>    public ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2106" href="#"></a></td>
<td><pre>        return headMap(toKey, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2107" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2108" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2109" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2110" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2111" href="#"></a></td>
<td><pre>     * @throws NullPointerException if {@code fromKey} is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2112" href="#"></a></td>
<td><pre>     * @throws IllegalArgumentException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2113" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2114" href="#"></a></td>
<td><pre>    public ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2115" href="#"></a></td>
<td><pre>        return tailMap(fromKey, true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2116" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2117" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2118" href="#"></a></td>
<td><pre>    /* ---------------- Relational operations -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2119" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2120" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2121" href="#"></a></td>
<td><pre>     * Returns a key-value mapping associated with the greatest key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2122" href="#"></a></td>
<td><pre>     * strictly less than the given key, or {@code null} if there is</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2123" href="#"></a></td>
<td><pre>     * no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support the</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2124" href="#"></a></td>
<td><pre>     * {@code Entry.setValue} method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2125" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2126" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2127" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2128" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2129" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; lowerEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2130" href="#"></a></td>
<td><pre>        return getNear(key, LT);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2131" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2132" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2133" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2134" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2135" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2136" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2137" href="#"></a></td>
<td><pre>    public K lowerKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2138" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; n = findNear(key, LT, comparator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2139" href="#"></a></td>
<td><pre>        return (n == null) ? null : n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2140" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2141" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2142" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2143" href="#"></a></td>
<td><pre>     * Returns a key-value mapping associated with the greatest key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2144" href="#"></a></td>
<td><pre>     * less than or equal to the given key, or {@code null} if there</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2145" href="#"></a></td>
<td><pre>     * is no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2146" href="#"></a></td>
<td><pre>     * the {@code Entry.setValue} method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2147" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2148" href="#"></a></td>
<td><pre>     * @param key the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2149" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2150" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2151" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2152" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; floorEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2153" href="#"></a></td>
<td><pre>        return getNear(key, LT|EQ);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2154" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2155" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2156" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2157" href="#"></a></td>
<td><pre>     * @param key the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2158" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2159" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2160" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2161" href="#"></a></td>
<td><pre>    public K floorKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2162" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; n = findNear(key, LT|EQ, comparator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2163" href="#"></a></td>
<td><pre>        return (n == null) ? null : n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2164" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2165" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2166" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2167" href="#"></a></td>
<td><pre>     * Returns a key-value mapping associated with the least key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2168" href="#"></a></td>
<td><pre>     * greater than or equal to the given key, or {@code null} if</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2169" href="#"></a></td>
<td><pre>     * there is no such entry. The returned entry does &lt;em&gt;not&lt;/em&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2170" href="#"></a></td>
<td><pre>     * support the {@code Entry.setValue} method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2171" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2172" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2173" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2174" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2175" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; ceilingEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2176" href="#"></a></td>
<td><pre>        return getNear(key, GT|EQ);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2177" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2178" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2179" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2180" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2181" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2182" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2183" href="#"></a></td>
<td><pre>    public K ceilingKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2184" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; n = findNear(key, GT|EQ, comparator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2185" href="#"></a></td>
<td><pre>        return (n == null) ? null : n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2186" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2187" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2188" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2189" href="#"></a></td>
<td><pre>     * Returns a key-value mapping associated with the least key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2190" href="#"></a></td>
<td><pre>     * strictly greater than the given key, or {@code null} if there</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2191" href="#"></a></td>
<td><pre>     * is no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2192" href="#"></a></td>
<td><pre>     * the {@code Entry.setValue} method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2193" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2194" href="#"></a></td>
<td><pre>     * @param key the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2195" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2196" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2197" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2198" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; higherEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2199" href="#"></a></td>
<td><pre>        return getNear(key, GT);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2200" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2201" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2202" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2203" href="#"></a></td>
<td><pre>     * @param key the key</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2204" href="#"></a></td>
<td><pre>     * @throws ClassCastException {@inheritDoc}</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2205" href="#"></a></td>
<td><pre>     * @throws NullPointerException if the specified key is null</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2206" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2207" href="#"></a></td>
<td><pre>    public K higherKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2208" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; n = findNear(key, GT, comparator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2209" href="#"></a></td>
<td><pre>        return (n == null) ? null : n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2210" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2211" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2212" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2213" href="#"></a></td>
<td><pre>     * Returns a key-value mapping associated with the least</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2214" href="#"></a></td>
<td><pre>     * key in this map, or {@code null} if the map is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2215" href="#"></a></td>
<td><pre>     * The returned entry does &lt;em&gt;not&lt;/em&gt; support</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2216" href="#"></a></td>
<td><pre>     * the {@code Entry.setValue} method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2217" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2218" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; firstEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2219" href="#"></a></td>
<td><pre>        for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2220" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; n = findFirst();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2221" href="#"></a></td>
<td><pre>            if (n == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2222" href="#"></a></td>
<td><pre>                return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2223" href="#"></a></td>
<td><pre>            AbstractMap.SimpleImmutableEntry&lt;K,V&gt; e = n.createSnapshot();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2224" href="#"></a></td>
<td><pre>            if (e != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2225" href="#"></a></td>
<td><pre>                return e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2226" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2227" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2228" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2229" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2230" href="#"></a></td>
<td><pre>     * Returns a key-value mapping associated with the greatest</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2231" href="#"></a></td>
<td><pre>     * key in this map, or {@code null} if the map is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2232" href="#"></a></td>
<td><pre>     * The returned entry does &lt;em&gt;not&lt;/em&gt; support</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2233" href="#"></a></td>
<td><pre>     * the {@code Entry.setValue} method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2234" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2235" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; lastEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2236" href="#"></a></td>
<td><pre>        for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2237" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; n = findLast();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2238" href="#"></a></td>
<td><pre>            if (n == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2239" href="#"></a></td>
<td><pre>                return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2240" href="#"></a></td>
<td><pre>            AbstractMap.SimpleImmutableEntry&lt;K,V&gt; e = n.createSnapshot();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2241" href="#"></a></td>
<td><pre>            if (e != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2242" href="#"></a></td>
<td><pre>                return e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2243" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2244" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2245" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2246" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2247" href="#"></a></td>
<td><pre>     * Removes and returns a key-value mapping associated with</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2248" href="#"></a></td>
<td><pre>     * the least key in this map, or {@code null} if the map is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2249" href="#"></a></td>
<td><pre>     * The returned entry does &lt;em&gt;not&lt;/em&gt; support</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2250" href="#"></a></td>
<td><pre>     * the {@code Entry.setValue} method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2251" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2252" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; pollFirstEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2253" href="#"></a></td>
<td><pre>        return doRemoveFirstEntry();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2254" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2255" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2256" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2257" href="#"></a></td>
<td><pre>     * Removes and returns a key-value mapping associated with</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2258" href="#"></a></td>
<td><pre>     * the greatest key in this map, or {@code null} if the map is empty.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2259" href="#"></a></td>
<td><pre>     * The returned entry does &lt;em&gt;not&lt;/em&gt; support</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2260" href="#"></a></td>
<td><pre>     * the {@code Entry.setValue} method.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2261" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2262" href="#"></a></td>
<td><pre>    public Map.Entry&lt;K,V&gt; pollLastEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2263" href="#"></a></td>
<td><pre>        return doRemoveLastEntry();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2264" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2265" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2266" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2267" href="#"></a></td>
<td><pre>    /* ---------------- Iterators -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2268" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2269" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2270" href="#"></a></td>
<td><pre>     * Base of iterator classes:</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2271" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2272" href="#"></a></td>
<td><pre>    abstract class Iter&lt;T&gt; implements Iterator&lt;T&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2273" href="#"></a></td>
<td><pre>        /** the last node returned by next() */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2274" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; lastReturned;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2275" href="#"></a></td>
<td><pre>        /** the next node to return from next(); */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2276" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2277" href="#"></a></td>
<td><pre>        /** Cache of next value field to maintain weak consistency */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2278" href="#"></a></td>
<td><pre>        V nextValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2279" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2280" href="#"></a></td>
<td><pre>        /** Initializes ascending iterator for entire range. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2281" href="#"></a></td>
<td><pre>        Iter() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2282" href="#"></a></td>
<td><pre>            while ((next = findFirst()) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2283" href="#"></a></td>
<td><pre>                Object x = next.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2284" href="#"></a></td>
<td><pre>                if (x != null &amp;&amp; x != next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2285" href="#"></a></td>
<td><pre>                    @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2286" href="#"></a></td>
<td><pre>                    nextValue = vv;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2287" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2288" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2289" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2290" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2291" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2292" href="#"></a></td>
<td><pre>        public final boolean hasNext() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2293" href="#"></a></td>
<td><pre>            return next != null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2294" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2295" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2296" href="#"></a></td>
<td><pre>        /** Advances next to higher entry. */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2297" href="#"></a></td>
<td><pre>        final void advance() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2298" href="#"></a></td>
<td><pre>            if (next == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2299" href="#"></a></td>
<td><pre>                throw new NoSuchElementException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2300" href="#"></a></td>
<td><pre>            lastReturned = next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2301" href="#"></a></td>
<td><pre>            while ((next = next.next) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2302" href="#"></a></td>
<td><pre>                Object x = next.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2303" href="#"></a></td>
<td><pre>                if (x != null &amp;&amp; x != next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2304" href="#"></a></td>
<td><pre>                    @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2305" href="#"></a></td>
<td><pre>                    nextValue = vv;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2306" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2307" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2308" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2309" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2310" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2311" href="#"></a></td>
<td><pre>        public void remove() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2312" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; l = lastReturned;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2313" href="#"></a></td>
<td><pre>            if (l == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2314" href="#"></a></td>
<td><pre>                throw new IllegalStateException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2315" href="#"></a></td>
<td><pre>            // It would not be worth all of the overhead to directly</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2316" href="#"></a></td>
<td><pre>            // unlink from here. Using remove is fast enough.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2317" href="#"></a></td>
<td><pre>            ConcurrentSkipListMap.this.remove(l.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2318" href="#"></a></td>
<td><pre>            lastReturned = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2319" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2320" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2321" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2322" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2323" href="#"></a></td>
<td><pre>    final class ValueIterator extends Iter&lt;V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2324" href="#"></a></td>
<td><pre>        public V next() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2325" href="#"></a></td>
<td><pre>            V v = nextValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2326" href="#"></a></td>
<td><pre>            advance();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2327" href="#"></a></td>
<td><pre>            return v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2328" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2329" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2330" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2331" href="#"></a></td>
<td><pre>    final class KeyIterator extends Iter&lt;K&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2332" href="#"></a></td>
<td><pre>        public K next() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2333" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; n = next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2334" href="#"></a></td>
<td><pre>            advance();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2335" href="#"></a></td>
<td><pre>            return n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2336" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2337" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2338" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2339" href="#"></a></td>
<td><pre>    final class EntryIterator extends Iter&lt;Map.Entry&lt;K,V&gt;&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2340" href="#"></a></td>
<td><pre>        public Map.Entry&lt;K,V&gt; next() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2341" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; n = next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2342" href="#"></a></td>
<td><pre>            V v = nextValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2343" href="#"></a></td>
<td><pre>            advance();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2344" href="#"></a></td>
<td><pre>            return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2345" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2346" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2347" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2348" href="#"></a></td>
<td><pre>    // Factory methods for iterators needed by ConcurrentSkipListSet etc</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2349" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2350" href="#"></a></td>
<td><pre>    Iterator&lt;K&gt; keyIterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2351" href="#"></a></td>
<td><pre>        return new KeyIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2352" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2353" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2354" href="#"></a></td>
<td><pre>    Iterator&lt;V&gt; valueIterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2355" href="#"></a></td>
<td><pre>        return new ValueIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2356" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2357" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2358" href="#"></a></td>
<td><pre>    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; entryIterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2359" href="#"></a></td>
<td><pre>        return new EntryIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2360" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2361" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2362" href="#"></a></td>
<td><pre>    /* ---------------- View Classes -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2363" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2364" href="#"></a></td>
<td><pre>    /*</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2365" href="#"></a></td>
<td><pre>     * View classes are static, delegating to a ConcurrentNavigableMap</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2366" href="#"></a></td>
<td><pre>     * to allow use by SubMaps, which outweighs the ugliness of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2367" href="#"></a></td>
<td><pre>     * needing type-tests for Iterator methods.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2368" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2369" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2370" href="#"></a></td>
<td><pre>    static final &lt;E&gt; List&lt;E&gt; toList(Collection&lt;E&gt; c) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2371" href="#"></a></td>
<td><pre>        // Using size() here would be a pessimization.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2372" href="#"></a></td>
<td><pre>        ArrayList&lt;E&gt; list = new ArrayList&lt;E&gt;();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2373" href="#"></a></td>
<td><pre>        for (E e : c)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2374" href="#"></a></td>
<td><pre>            list.add(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2375" href="#"></a></td>
<td><pre>        return list;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2376" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2377" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2378" href="#"></a></td>
<td><pre>    static final class KeySet&lt;E&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2379" href="#"></a></td>
<td><pre>            extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2380" href="#"></a></td>
<td><pre>        final ConcurrentNavigableMap&lt;E,?&gt; m;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2381" href="#"></a></td>
<td><pre>        KeySet(ConcurrentNavigableMap&lt;E,?&gt; map) { m = map; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2382" href="#"></a></td>
<td><pre>        public int size() { return m.size(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2383" href="#"></a></td>
<td><pre>        public boolean isEmpty() { return m.isEmpty(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2384" href="#"></a></td>
<td><pre>        public boolean contains(Object o) { return m.containsKey(o); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2385" href="#"></a></td>
<td><pre>        public boolean remove(Object o) { return m.remove(o) != null; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2386" href="#"></a></td>
<td><pre>        public void clear() { m.clear(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2387" href="#"></a></td>
<td><pre>        public E lower(E e) { return m.lowerKey(e); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2388" href="#"></a></td>
<td><pre>        public E floor(E e) { return m.floorKey(e); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2389" href="#"></a></td>
<td><pre>        public E ceiling(E e) { return m.ceilingKey(e); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2390" href="#"></a></td>
<td><pre>        public E higher(E e) { return m.higherKey(e); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2391" href="#"></a></td>
<td><pre>        public Comparator&lt;? super E&gt; comparator() { return m.comparator(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2392" href="#"></a></td>
<td><pre>        public E first() { return m.firstKey(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2393" href="#"></a></td>
<td><pre>        public E last() { return m.lastKey(); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2394" href="#"></a></td>
<td><pre>        public E pollFirst() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2395" href="#"></a></td>
<td><pre>            Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2396" href="#"></a></td>
<td><pre>            return (e == null) ? null : e.getKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2397" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2398" href="#"></a></td>
<td><pre>        public E pollLast() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2399" href="#"></a></td>
<td><pre>            Map.Entry&lt;E,?&gt; e = m.pollLastEntry();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2400" href="#"></a></td>
<td><pre>            return (e == null) ? null : e.getKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2401" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2402" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2403" href="#"></a></td>
<td><pre>        public Iterator&lt;E&gt; iterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2404" href="#"></a></td>
<td><pre>            if (m instanceof ConcurrentSkipListMap)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2405" href="#"></a></td>
<td><pre>                return ((ConcurrentSkipListMap&lt;E,Object&gt;)m).keyIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2406" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2407" href="#"></a></td>
<td><pre>                return ((ConcurrentSkipListMap.SubMap&lt;E,Object&gt;)m).keyIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2408" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2409" href="#"></a></td>
<td><pre>        public boolean equals(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2410" href="#"></a></td>
<td><pre>            if (o == this)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2411" href="#"></a></td>
<td><pre>                return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2412" href="#"></a></td>
<td><pre>            if (!(o instanceof Set))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2413" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2414" href="#"></a></td>
<td><pre>            Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2415" href="#"></a></td>
<td><pre>            try {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2416" href="#"></a></td>
<td><pre>                return containsAll(c) &amp;&amp; c.containsAll(this);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2417" href="#"></a></td>
<td><pre>            } catch (ClassCastException unused) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2418" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2419" href="#"></a></td>
<td><pre>            } catch (NullPointerException unused) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2420" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2421" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2422" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2423" href="#"></a></td>
<td><pre>        public Object[] toArray()     { return toList(this).toArray();  }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2424" href="#"></a></td>
<td><pre>        public &lt;T&gt; T[] toArray(T[] a) { return toList(this).toArray(a); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2425" href="#"></a></td>
<td><pre>        public Iterator&lt;E&gt; descendingIterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2426" href="#"></a></td>
<td><pre>            return descendingSet().iterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2427" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2428" href="#"></a></td>
<td><pre>        public NavigableSet&lt;E&gt; subSet(E fromElement,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2429" href="#"></a></td>
<td><pre>                                      boolean fromInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2430" href="#"></a></td>
<td><pre>                                      E toElement,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2431" href="#"></a></td>
<td><pre>                                      boolean toInclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2432" href="#"></a></td>
<td><pre>            return new KeySet&lt;E&gt;(m.subMap(fromElement, fromInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2433" href="#"></a></td>
<td><pre>                                          toElement,   toInclusive));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2434" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2435" href="#"></a></td>
<td><pre>        public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2436" href="#"></a></td>
<td><pre>            return new KeySet&lt;E&gt;(m.headMap(toElement, inclusive));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2437" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2438" href="#"></a></td>
<td><pre>        public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2439" href="#"></a></td>
<td><pre>            return new KeySet&lt;E&gt;(m.tailMap(fromElement, inclusive));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2440" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2441" href="#"></a></td>
<td><pre>        public NavigableSet&lt;E&gt; subSet(E fromElement, E toElement) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2442" href="#"></a></td>
<td><pre>            return subSet(fromElement, true, toElement, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2443" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2444" href="#"></a></td>
<td><pre>        public NavigableSet&lt;E&gt; headSet(E toElement) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2445" href="#"></a></td>
<td><pre>            return headSet(toElement, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2446" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2447" href="#"></a></td>
<td><pre>        public NavigableSet&lt;E&gt; tailSet(E fromElement) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2448" href="#"></a></td>
<td><pre>            return tailSet(fromElement, true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2449" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2450" href="#"></a></td>
<td><pre>        public NavigableSet&lt;E&gt; descendingSet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2451" href="#"></a></td>
<td><pre>            return new KeySet&lt;E&gt;(m.descendingMap());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2452" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2453" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2454" href="#"></a></td>
<td><pre>        public Spliterator&lt;E&gt; spliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2455" href="#"></a></td>
<td><pre>            if (m instanceof ConcurrentSkipListMap)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2456" href="#"></a></td>
<td><pre>                return ((ConcurrentSkipListMap&lt;E,?&gt;)m).keySpliterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2457" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2458" href="#"></a></td>
<td><pre>                return (Spliterator&lt;E&gt;)((SubMap&lt;E,?&gt;)m).keyIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2459" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2460" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2461" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2462" href="#"></a></td>
<td><pre>    static final class Values&lt;E&gt; extends AbstractCollection&lt;E&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2463" href="#"></a></td>
<td><pre>        final ConcurrentNavigableMap&lt;?, E&gt; m;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2464" href="#"></a></td>
<td><pre>        Values(ConcurrentNavigableMap&lt;?, E&gt; map) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2465" href="#"></a></td>
<td><pre>            m = map;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2466" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2467" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2468" href="#"></a></td>
<td><pre>        public Iterator&lt;E&gt; iterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2469" href="#"></a></td>
<td><pre>            if (m instanceof ConcurrentSkipListMap)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2470" href="#"></a></td>
<td><pre>                return ((ConcurrentSkipListMap&lt;?,E&gt;)m).valueIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2471" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2472" href="#"></a></td>
<td><pre>                return ((SubMap&lt;?,E&gt;)m).valueIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2473" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2474" href="#"></a></td>
<td><pre>        public boolean isEmpty() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2475" href="#"></a></td>
<td><pre>            return m.isEmpty();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2476" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2477" href="#"></a></td>
<td><pre>        public int size() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2478" href="#"></a></td>
<td><pre>            return m.size();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2479" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2480" href="#"></a></td>
<td><pre>        public boolean contains(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2481" href="#"></a></td>
<td><pre>            return m.containsValue(o);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2482" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2483" href="#"></a></td>
<td><pre>        public void clear() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2484" href="#"></a></td>
<td><pre>            m.clear();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2485" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2486" href="#"></a></td>
<td><pre>        public Object[] toArray()     { return toList(this).toArray();  }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2487" href="#"></a></td>
<td><pre>        public &lt;T&gt; T[] toArray(T[] a) { return toList(this).toArray(a); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2488" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2489" href="#"></a></td>
<td><pre>        public Spliterator&lt;E&gt; spliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2490" href="#"></a></td>
<td><pre>            if (m instanceof ConcurrentSkipListMap)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2491" href="#"></a></td>
<td><pre>                return ((ConcurrentSkipListMap&lt;?,E&gt;)m).valueSpliterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2492" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2493" href="#"></a></td>
<td><pre>                return (Spliterator&lt;E&gt;)((SubMap&lt;?,E&gt;)m).valueIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2494" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2495" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2496" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2497" href="#"></a></td>
<td><pre>    static final class EntrySet&lt;K1,V1&gt; extends AbstractSet&lt;Map.Entry&lt;K1,V1&gt;&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2498" href="#"></a></td>
<td><pre>        final ConcurrentNavigableMap&lt;K1, V1&gt; m;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2499" href="#"></a></td>
<td><pre>        EntrySet(ConcurrentNavigableMap&lt;K1, V1&gt; map) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2500" href="#"></a></td>
<td><pre>            m = map;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2501" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2502" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2503" href="#"></a></td>
<td><pre>        public Iterator&lt;Map.Entry&lt;K1,V1&gt;&gt; iterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2504" href="#"></a></td>
<td><pre>            if (m instanceof ConcurrentSkipListMap)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2505" href="#"></a></td>
<td><pre>                return ((ConcurrentSkipListMap&lt;K1,V1&gt;)m).entryIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2506" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2507" href="#"></a></td>
<td><pre>                return ((SubMap&lt;K1,V1&gt;)m).entryIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2508" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2509" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2510" href="#"></a></td>
<td><pre>        public boolean contains(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2511" href="#"></a></td>
<td><pre>            if (!(o instanceof Map.Entry))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2512" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2513" href="#"></a></td>
<td><pre>            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2514" href="#"></a></td>
<td><pre>            V1 v = m.get(e.getKey());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2515" href="#"></a></td>
<td><pre>            return v != null &amp;&amp; v.equals(e.getValue());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2516" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2517" href="#"></a></td>
<td><pre>        public boolean remove(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2518" href="#"></a></td>
<td><pre>            if (!(o instanceof Map.Entry))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2519" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2520" href="#"></a></td>
<td><pre>            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2521" href="#"></a></td>
<td><pre>            return m.remove(e.getKey(),</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2522" href="#"></a></td>
<td><pre>                            e.getValue());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2523" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2524" href="#"></a></td>
<td><pre>        public boolean isEmpty() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2525" href="#"></a></td>
<td><pre>            return m.isEmpty();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2526" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2527" href="#"></a></td>
<td><pre>        public int size() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2528" href="#"></a></td>
<td><pre>            return m.size();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2529" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2530" href="#"></a></td>
<td><pre>        public void clear() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2531" href="#"></a></td>
<td><pre>            m.clear();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2532" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2533" href="#"></a></td>
<td><pre>        public boolean equals(Object o) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2534" href="#"></a></td>
<td><pre>            if (o == this)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2535" href="#"></a></td>
<td><pre>                return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2536" href="#"></a></td>
<td><pre>            if (!(o instanceof Set))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2537" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2538" href="#"></a></td>
<td><pre>            Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2539" href="#"></a></td>
<td><pre>            try {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2540" href="#"></a></td>
<td><pre>                return containsAll(c) &amp;&amp; c.containsAll(this);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2541" href="#"></a></td>
<td><pre>            } catch (ClassCastException unused) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2542" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2543" href="#"></a></td>
<td><pre>            } catch (NullPointerException unused) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2544" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2545" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2546" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2547" href="#"></a></td>
<td><pre>        public Object[] toArray()     { return toList(this).toArray();  }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2548" href="#"></a></td>
<td><pre>        public &lt;T&gt; T[] toArray(T[] a) { return toList(this).toArray(a); }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2549" href="#"></a></td>
<td><pre>        @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2550" href="#"></a></td>
<td><pre>        public Spliterator&lt;Map.Entry&lt;K1,V1&gt;&gt; spliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2551" href="#"></a></td>
<td><pre>            if (m instanceof ConcurrentSkipListMap)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2552" href="#"></a></td>
<td><pre>                return ((ConcurrentSkipListMap&lt;K1,V1&gt;)m).entrySpliterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2553" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2554" href="#"></a></td>
<td><pre>                return (Spliterator&lt;Map.Entry&lt;K1,V1&gt;&gt;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2555" href="#"></a></td>
<td><pre>                    ((SubMap&lt;K1,V1&gt;)m).entryIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2556" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2557" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2558" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2559" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2560" href="#"></a></td>
<td><pre>     * Submaps returned by {@link ConcurrentSkipListMap} submap operations</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2561" href="#"></a></td>
<td><pre>     * represent a subrange of mappings of their underlying</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2562" href="#"></a></td>
<td><pre>     * maps. Instances of this class support all methods of their</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2563" href="#"></a></td>
<td><pre>     * underlying maps, differing in that mappings outside their range are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2564" href="#"></a></td>
<td><pre>     * ignored, and attempts to add mappings outside their ranges result</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2565" href="#"></a></td>
<td><pre>     * in {@link IllegalArgumentException}.  Instances of this class are</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2566" href="#"></a></td>
<td><pre>     * constructed only using the {@code subMap}, {@code headMap}, and</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2567" href="#"></a></td>
<td><pre>     * {@code tailMap} methods of their underlying maps.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2568" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2569" href="#"></a></td>
<td><pre>     * @serial include</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2570" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2571" href="#"></a></td>
<td><pre>    static final class SubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2572" href="#"></a></td>
<td><pre>        implements ConcurrentNavigableMap&lt;K,V&gt;, Cloneable, Serializable {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2573" href="#"></a></td>
<td><pre>        private static final long serialVersionUID = -7647078645895051609L;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2574" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2575" href="#"></a></td>
<td><pre>        /** Underlying map */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2576" href="#"></a></td>
<td><pre>        private final ConcurrentSkipListMap&lt;K,V&gt; m;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2577" href="#"></a></td>
<td><pre>        /** lower bound key, or null if from start */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2578" href="#"></a></td>
<td><pre>        private final K lo;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2579" href="#"></a></td>
<td><pre>        /** upper bound key, or null if to end */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2580" href="#"></a></td>
<td><pre>        private final K hi;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2581" href="#"></a></td>
<td><pre>        /** inclusion flag for lo */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2582" href="#"></a></td>
<td><pre>        private final boolean loInclusive;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2583" href="#"></a></td>
<td><pre>        /** inclusion flag for hi */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2584" href="#"></a></td>
<td><pre>        private final boolean hiInclusive;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2585" href="#"></a></td>
<td><pre>        /** direction */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2586" href="#"></a></td>
<td><pre>        private final boolean isDescending;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2587" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2588" href="#"></a></td>
<td><pre>        // Lazily initialized view holders</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2589" href="#"></a></td>
<td><pre>        private transient KeySet&lt;K&gt; keySetView;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2590" href="#"></a></td>
<td><pre>        private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySetView;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2591" href="#"></a></td>
<td><pre>        private transient Collection&lt;V&gt; valuesView;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2592" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2593" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2594" href="#"></a></td>
<td><pre>         * Creates a new submap, initializing all fields.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2595" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2596" href="#"></a></td>
<td><pre>        SubMap(ConcurrentSkipListMap&lt;K,V&gt; map,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2597" href="#"></a></td>
<td><pre>               K fromKey, boolean fromInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2598" href="#"></a></td>
<td><pre>               K toKey, boolean toInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2599" href="#"></a></td>
<td><pre>               boolean isDescending) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2600" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = map.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2601" href="#"></a></td>
<td><pre>            if (fromKey != null &amp;&amp; toKey != null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2602" href="#"></a></td>
<td><pre>                cpr(cmp, fromKey, toKey) &gt; 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2603" href="#"></a></td>
<td><pre>                throw new IllegalArgumentException(&quot;inconsistent range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2604" href="#"></a></td>
<td><pre>            this.m = map;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2605" href="#"></a></td>
<td><pre>            this.lo = fromKey;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2606" href="#"></a></td>
<td><pre>            this.hi = toKey;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2607" href="#"></a></td>
<td><pre>            this.loInclusive = fromInclusive;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2608" href="#"></a></td>
<td><pre>            this.hiInclusive = toInclusive;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2609" href="#"></a></td>
<td><pre>            this.isDescending = isDescending;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2610" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2611" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2612" href="#"></a></td>
<td><pre>        /* ----------------  Utilities -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2613" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2614" href="#"></a></td>
<td><pre>        boolean tooLow(Object key, Comparator&lt;? super K&gt; cmp) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2615" href="#"></a></td>
<td><pre>            int c;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2616" href="#"></a></td>
<td><pre>            return (lo != null &amp;&amp; ((c = cpr(cmp, key, lo)) &lt; 0 ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2617" href="#"></a></td>
<td><pre>                                   (c == 0 &amp;&amp; !loInclusive)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2618" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2619" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2620" href="#"></a></td>
<td><pre>        boolean tooHigh(Object key, Comparator&lt;? super K&gt; cmp) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2621" href="#"></a></td>
<td><pre>            int c;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2622" href="#"></a></td>
<td><pre>            return (hi != null &amp;&amp; ((c = cpr(cmp, key, hi)) &gt; 0 ||</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2623" href="#"></a></td>
<td><pre>                                   (c == 0 &amp;&amp; !hiInclusive)));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2624" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2625" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2626" href="#"></a></td>
<td><pre>        boolean inBounds(Object key, Comparator&lt;? super K&gt; cmp) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2627" href="#"></a></td>
<td><pre>            return !tooLow(key, cmp) &amp;&amp; !tooHigh(key, cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2628" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2629" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2630" href="#"></a></td>
<td><pre>        void checkKeyBounds(K key, Comparator&lt;? super K&gt; cmp) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2631" href="#"></a></td>
<td><pre>            if (key == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2632" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2633" href="#"></a></td>
<td><pre>            if (!inBounds(key, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2634" href="#"></a></td>
<td><pre>                throw new IllegalArgumentException(&quot;key out of range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2635" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2636" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2637" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2638" href="#"></a></td>
<td><pre>         * Returns true if node key is less than upper bound of range.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2639" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2640" href="#"></a></td>
<td><pre>        boolean isBeforeEnd(ConcurrentSkipListMap.Node&lt;K,V&gt; n,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2641" href="#"></a></td>
<td><pre>                            Comparator&lt;? super K&gt; cmp) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2642" href="#"></a></td>
<td><pre>            if (n == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2643" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2644" href="#"></a></td>
<td><pre>            if (hi == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2645" href="#"></a></td>
<td><pre>                return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2646" href="#"></a></td>
<td><pre>            K k = n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2647" href="#"></a></td>
<td><pre>            if (k == null) // pass by markers and headers</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2648" href="#"></a></td>
<td><pre>                return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2649" href="#"></a></td>
<td><pre>            int c = cpr(cmp, k, hi);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2650" href="#"></a></td>
<td><pre>            if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2651" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2652" href="#"></a></td>
<td><pre>            return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2653" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2654" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2655" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2656" href="#"></a></td>
<td><pre>         * Returns lowest node. This node might not be in range, so</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2657" href="#"></a></td>
<td><pre>         * most usages need to check bounds.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2658" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2659" href="#"></a></td>
<td><pre>        ConcurrentSkipListMap.Node&lt;K,V&gt; loNode(Comparator&lt;? super K&gt; cmp) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2660" href="#"></a></td>
<td><pre>            if (lo == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2661" href="#"></a></td>
<td><pre>                return m.findFirst();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2662" href="#"></a></td>
<td><pre>            else if (loInclusive)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2663" href="#"></a></td>
<td><pre>                return m.findNear(lo, GT|EQ, cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2664" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2665" href="#"></a></td>
<td><pre>                return m.findNear(lo, GT, cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2666" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2667" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2668" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2669" href="#"></a></td>
<td><pre>         * Returns highest node. This node might not be in range, so</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2670" href="#"></a></td>
<td><pre>         * most usages need to check bounds.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2671" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2672" href="#"></a></td>
<td><pre>        ConcurrentSkipListMap.Node&lt;K,V&gt; hiNode(Comparator&lt;? super K&gt; cmp) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2673" href="#"></a></td>
<td><pre>            if (hi == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2674" href="#"></a></td>
<td><pre>                return m.findLast();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2675" href="#"></a></td>
<td><pre>            else if (hiInclusive)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2676" href="#"></a></td>
<td><pre>                return m.findNear(hi, LT|EQ, cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2677" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2678" href="#"></a></td>
<td><pre>                return m.findNear(hi, LT, cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2679" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2680" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2681" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2682" href="#"></a></td>
<td><pre>         * Returns lowest absolute key (ignoring directonality).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2683" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2684" href="#"></a></td>
<td><pre>        K lowestKey() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2685" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2686" href="#"></a></td>
<td><pre>            ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2687" href="#"></a></td>
<td><pre>            if (isBeforeEnd(n, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2688" href="#"></a></td>
<td><pre>                return n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2689" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2690" href="#"></a></td>
<td><pre>                throw new NoSuchElementException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2691" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2692" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2693" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2694" href="#"></a></td>
<td><pre>         * Returns highest absolute key (ignoring directonality).</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2695" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2696" href="#"></a></td>
<td><pre>        K highestKey() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2697" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2698" href="#"></a></td>
<td><pre>            ConcurrentSkipListMap.Node&lt;K,V&gt; n = hiNode(cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2699" href="#"></a></td>
<td><pre>            if (n != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2700" href="#"></a></td>
<td><pre>                K last = n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2701" href="#"></a></td>
<td><pre>                if (inBounds(last, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2702" href="#"></a></td>
<td><pre>                    return last;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2703" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2704" href="#"></a></td>
<td><pre>            throw new NoSuchElementException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2705" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2706" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2707" href="#"></a></td>
<td><pre>        Map.Entry&lt;K,V&gt; lowestEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2708" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2709" href="#"></a></td>
<td><pre>            for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2710" href="#"></a></td>
<td><pre>                ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2711" href="#"></a></td>
<td><pre>                if (!isBeforeEnd(n, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2712" href="#"></a></td>
<td><pre>                    return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2713" href="#"></a></td>
<td><pre>                Map.Entry&lt;K,V&gt; e = n.createSnapshot();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2714" href="#"></a></td>
<td><pre>                if (e != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2715" href="#"></a></td>
<td><pre>                    return e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2716" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2717" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2718" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2719" href="#"></a></td>
<td><pre>        Map.Entry&lt;K,V&gt; highestEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2720" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2721" href="#"></a></td>
<td><pre>            for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2722" href="#"></a></td>
<td><pre>                ConcurrentSkipListMap.Node&lt;K,V&gt; n = hiNode(cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2723" href="#"></a></td>
<td><pre>                if (n == null || !inBounds(n.key, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2724" href="#"></a></td>
<td><pre>                    return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2725" href="#"></a></td>
<td><pre>                Map.Entry&lt;K,V&gt; e = n.createSnapshot();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2726" href="#"></a></td>
<td><pre>                if (e != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2727" href="#"></a></td>
<td><pre>                    return e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2728" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2729" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2730" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2731" href="#"></a></td>
<td><pre>        Map.Entry&lt;K,V&gt; removeLowest() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2732" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2733" href="#"></a></td>
<td><pre>            for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2734" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; n = loNode(cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2735" href="#"></a></td>
<td><pre>                if (n == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2736" href="#"></a></td>
<td><pre>                    return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2737" href="#"></a></td>
<td><pre>                K k = n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2738" href="#"></a></td>
<td><pre>                if (!inBounds(k, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2739" href="#"></a></td>
<td><pre>                    return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2740" href="#"></a></td>
<td><pre>                V v = m.doRemove(k, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2741" href="#"></a></td>
<td><pre>                if (v != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2742" href="#"></a></td>
<td><pre>                    return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2743" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2744" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2745" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2746" href="#"></a></td>
<td><pre>        Map.Entry&lt;K,V&gt; removeHighest() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2747" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2748" href="#"></a></td>
<td><pre>            for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2749" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; n = hiNode(cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2750" href="#"></a></td>
<td><pre>                if (n == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2751" href="#"></a></td>
<td><pre>                    return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2752" href="#"></a></td>
<td><pre>                K k = n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2753" href="#"></a></td>
<td><pre>                if (!inBounds(k, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2754" href="#"></a></td>
<td><pre>                    return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2755" href="#"></a></td>
<td><pre>                V v = m.doRemove(k, null);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2756" href="#"></a></td>
<td><pre>                if (v != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2757" href="#"></a></td>
<td><pre>                    return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2758" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2759" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2760" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2761" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2762" href="#"></a></td>
<td><pre>         * Submap version of ConcurrentSkipListMap.getNearEntry</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2763" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2764" href="#"></a></td>
<td><pre>        Map.Entry&lt;K,V&gt; getNearEntry(K key, int rel) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2765" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2766" href="#"></a></td>
<td><pre>            if (isDescending) { // adjust relation for direction</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2767" href="#"></a></td>
<td><pre>                if ((rel &amp; LT) == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2768" href="#"></a></td>
<td><pre>                    rel |= LT;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2769" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2770" href="#"></a></td>
<td><pre>                    rel &amp;= ~LT;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2771" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2772" href="#"></a></td>
<td><pre>            if (tooLow(key, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2773" href="#"></a></td>
<td><pre>                return ((rel &amp; LT) != 0) ? null : lowestEntry();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2774" href="#"></a></td>
<td><pre>            if (tooHigh(key, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2775" href="#"></a></td>
<td><pre>                return ((rel &amp; LT) != 0) ? highestEntry() : null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2776" href="#"></a></td>
<td><pre>            for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2777" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; n = m.findNear(key, rel, cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2778" href="#"></a></td>
<td><pre>                if (n == null || !inBounds(n.key, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2779" href="#"></a></td>
<td><pre>                    return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2780" href="#"></a></td>
<td><pre>                K k = n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2781" href="#"></a></td>
<td><pre>                V v = n.getValidValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2782" href="#"></a></td>
<td><pre>                if (v != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2783" href="#"></a></td>
<td><pre>                    return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2784" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2785" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2786" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2787" href="#"></a></td>
<td><pre>        // Almost the same as getNearEntry, except for keys</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2788" href="#"></a></td>
<td><pre>        K getNearKey(K key, int rel) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2789" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2790" href="#"></a></td>
<td><pre>            if (isDescending) { // adjust relation for direction</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2791" href="#"></a></td>
<td><pre>                if ((rel &amp; LT) == 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2792" href="#"></a></td>
<td><pre>                    rel |= LT;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2793" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2794" href="#"></a></td>
<td><pre>                    rel &amp;= ~LT;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2795" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2796" href="#"></a></td>
<td><pre>            if (tooLow(key, cmp)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2797" href="#"></a></td>
<td><pre>                if ((rel &amp; LT) == 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2798" href="#"></a></td>
<td><pre>                    ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2799" href="#"></a></td>
<td><pre>                    if (isBeforeEnd(n, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2800" href="#"></a></td>
<td><pre>                        return n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2801" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2802" href="#"></a></td>
<td><pre>                return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2803" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2804" href="#"></a></td>
<td><pre>            if (tooHigh(key, cmp)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2805" href="#"></a></td>
<td><pre>                if ((rel &amp; LT) != 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2806" href="#"></a></td>
<td><pre>                    ConcurrentSkipListMap.Node&lt;K,V&gt; n = hiNode(cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2807" href="#"></a></td>
<td><pre>                    if (n != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2808" href="#"></a></td>
<td><pre>                        K last = n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2809" href="#"></a></td>
<td><pre>                        if (inBounds(last, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2810" href="#"></a></td>
<td><pre>                            return last;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2811" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2812" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2813" href="#"></a></td>
<td><pre>                return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2814" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2815" href="#"></a></td>
<td><pre>            for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2816" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; n = m.findNear(key, rel, cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2817" href="#"></a></td>
<td><pre>                if (n == null || !inBounds(n.key, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2818" href="#"></a></td>
<td><pre>                    return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2819" href="#"></a></td>
<td><pre>                K k = n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2820" href="#"></a></td>
<td><pre>                V v = n.getValidValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2821" href="#"></a></td>
<td><pre>                if (v != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2822" href="#"></a></td>
<td><pre>                    return k;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2823" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2824" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2825" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2826" href="#"></a></td>
<td><pre>        /* ----------------  Map API methods -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2827" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2828" href="#"></a></td>
<td><pre>        public boolean containsKey(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2829" href="#"></a></td>
<td><pre>            if (key == null) throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2830" href="#"></a></td>
<td><pre>            return inBounds(key, m.comparator) &amp;&amp; m.containsKey(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2831" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2832" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2833" href="#"></a></td>
<td><pre>        public V get(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2834" href="#"></a></td>
<td><pre>            if (key == null) throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2835" href="#"></a></td>
<td><pre>            return (!inBounds(key, m.comparator)) ? null : m.get(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2836" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2837" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2838" href="#"></a></td>
<td><pre>        public V put(K key, V value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2839" href="#"></a></td>
<td><pre>            checkKeyBounds(key, m.comparator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2840" href="#"></a></td>
<td><pre>            return m.put(key, value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2841" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2842" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2843" href="#"></a></td>
<td><pre>        public V remove(Object key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2844" href="#"></a></td>
<td><pre>            return (!inBounds(key, m.comparator)) ? null : m.remove(key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2845" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2846" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2847" href="#"></a></td>
<td><pre>        public int size() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2848" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2849" href="#"></a></td>
<td><pre>            long count = 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2850" href="#"></a></td>
<td><pre>            for (ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2851" href="#"></a></td>
<td><pre>                 isBeforeEnd(n, cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2852" href="#"></a></td>
<td><pre>                 n = n.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2853" href="#"></a></td>
<td><pre>                if (n.getValidValue() != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2854" href="#"></a></td>
<td><pre>                    ++count;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2855" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2856" href="#"></a></td>
<td><pre>            return count &gt;= Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)count;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2857" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2858" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2859" href="#"></a></td>
<td><pre>        public boolean isEmpty() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2860" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2861" href="#"></a></td>
<td><pre>            return !isBeforeEnd(loNode(cmp), cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2862" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2863" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2864" href="#"></a></td>
<td><pre>        public boolean containsValue(Object value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2865" href="#"></a></td>
<td><pre>            if (value == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2866" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2867" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2868" href="#"></a></td>
<td><pre>            for (ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2869" href="#"></a></td>
<td><pre>                 isBeforeEnd(n, cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2870" href="#"></a></td>
<td><pre>                 n = n.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2871" href="#"></a></td>
<td><pre>                V v = n.getValidValue();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2872" href="#"></a></td>
<td><pre>                if (v != null &amp;&amp; value.equals(v))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2873" href="#"></a></td>
<td><pre>                    return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2874" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2875" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2876" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2877" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2878" href="#"></a></td>
<td><pre>        public void clear() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2879" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2880" href="#"></a></td>
<td><pre>            for (ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2881" href="#"></a></td>
<td><pre>                 isBeforeEnd(n, cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2882" href="#"></a></td>
<td><pre>                 n = n.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2883" href="#"></a></td>
<td><pre>                if (n.getValidValue() != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2884" href="#"></a></td>
<td><pre>                    m.remove(n.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2885" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2886" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2887" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2888" href="#"></a></td>
<td><pre>        /* ----------------  ConcurrentMap API methods -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2889" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2890" href="#"></a></td>
<td><pre>        public V putIfAbsent(K key, V value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2891" href="#"></a></td>
<td><pre>            checkKeyBounds(key, m.comparator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2892" href="#"></a></td>
<td><pre>            return m.putIfAbsent(key, value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2893" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2894" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2895" href="#"></a></td>
<td><pre>        public boolean remove(Object key, Object value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2896" href="#"></a></td>
<td><pre>            return inBounds(key, m.comparator) &amp;&amp; m.remove(key, value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2897" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2898" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2899" href="#"></a></td>
<td><pre>        public boolean replace(K key, V oldValue, V newValue) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2900" href="#"></a></td>
<td><pre>            checkKeyBounds(key, m.comparator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2901" href="#"></a></td>
<td><pre>            return m.replace(key, oldValue, newValue);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2902" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2903" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2904" href="#"></a></td>
<td><pre>        public V replace(K key, V value) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2905" href="#"></a></td>
<td><pre>            checkKeyBounds(key, m.comparator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2906" href="#"></a></td>
<td><pre>            return m.replace(key, value);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2907" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2908" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2909" href="#"></a></td>
<td><pre>        /* ----------------  SortedMap API methods -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2910" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2911" href="#"></a></td>
<td><pre>        public Comparator&lt;? super K&gt; comparator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2912" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = m.comparator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2913" href="#"></a></td>
<td><pre>            if (isDescending)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2914" href="#"></a></td>
<td><pre>                return Collections.reverseOrder(cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2915" href="#"></a></td>
<td><pre>            else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2916" href="#"></a></td>
<td><pre>                return cmp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2917" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2918" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2919" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2920" href="#"></a></td>
<td><pre>         * Utility to create submaps, where given bounds override</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2921" href="#"></a></td>
<td><pre>         * unbounded(null) ones and/or are checked against bounded ones.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2922" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2923" href="#"></a></td>
<td><pre>        SubMap&lt;K,V&gt; newSubMap(K fromKey, boolean fromInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2924" href="#"></a></td>
<td><pre>                              K toKey, boolean toInclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2925" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2926" href="#"></a></td>
<td><pre>            if (isDescending) { // flip senses</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2927" href="#"></a></td>
<td><pre>                K tk = fromKey;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2928" href="#"></a></td>
<td><pre>                fromKey = toKey;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2929" href="#"></a></td>
<td><pre>                toKey = tk;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2930" href="#"></a></td>
<td><pre>                boolean ti = fromInclusive;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2931" href="#"></a></td>
<td><pre>                fromInclusive = toInclusive;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2932" href="#"></a></td>
<td><pre>                toInclusive = ti;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2933" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2934" href="#"></a></td>
<td><pre>            if (lo != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2935" href="#"></a></td>
<td><pre>                if (fromKey == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2936" href="#"></a></td>
<td><pre>                    fromKey = lo;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2937" href="#"></a></td>
<td><pre>                    fromInclusive = loInclusive;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2938" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2939" href="#"></a></td>
<td><pre>                else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2940" href="#"></a></td>
<td><pre>                    int c = cpr(cmp, fromKey, lo);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2941" href="#"></a></td>
<td><pre>                    if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive &amp;&amp; fromInclusive))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2942" href="#"></a></td>
<td><pre>                        throw new IllegalArgumentException(&quot;key out of range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2943" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2944" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2945" href="#"></a></td>
<td><pre>            if (hi != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2946" href="#"></a></td>
<td><pre>                if (toKey == null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2947" href="#"></a></td>
<td><pre>                    toKey = hi;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2948" href="#"></a></td>
<td><pre>                    toInclusive = hiInclusive;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2949" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2950" href="#"></a></td>
<td><pre>                else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2951" href="#"></a></td>
<td><pre>                    int c = cpr(cmp, toKey, hi);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2952" href="#"></a></td>
<td><pre>                    if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive &amp;&amp; toInclusive))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2953" href="#"></a></td>
<td><pre>                        throw new IllegalArgumentException(&quot;key out of range&quot;);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2954" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2955" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2956" href="#"></a></td>
<td><pre>            return new SubMap&lt;K,V&gt;(m, fromKey, fromInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2957" href="#"></a></td>
<td><pre>                                   toKey, toInclusive, isDescending);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2958" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2959" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2960" href="#"></a></td>
<td><pre>        public SubMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2961" href="#"></a></td>
<td><pre>                                  K toKey, boolean toInclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2962" href="#"></a></td>
<td><pre>            if (fromKey == null || toKey == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2963" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2964" href="#"></a></td>
<td><pre>            return newSubMap(fromKey, fromInclusive, toKey, toInclusive);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2965" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2966" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2967" href="#"></a></td>
<td><pre>        public SubMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2968" href="#"></a></td>
<td><pre>            if (toKey == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2969" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2970" href="#"></a></td>
<td><pre>            return newSubMap(null, false, toKey, inclusive);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2971" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2972" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2973" href="#"></a></td>
<td><pre>        public SubMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2974" href="#"></a></td>
<td><pre>            if (fromKey == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2975" href="#"></a></td>
<td><pre>                throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2976" href="#"></a></td>
<td><pre>            return newSubMap(fromKey, inclusive, null, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2977" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2978" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2979" href="#"></a></td>
<td><pre>        public SubMap&lt;K,V&gt; subMap(K fromKey, K toKey) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2980" href="#"></a></td>
<td><pre>            return subMap(fromKey, true, toKey, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2981" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2982" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2983" href="#"></a></td>
<td><pre>        public SubMap&lt;K,V&gt; headMap(K toKey) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2984" href="#"></a></td>
<td><pre>            return headMap(toKey, false);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2985" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2986" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2987" href="#"></a></td>
<td><pre>        public SubMap&lt;K,V&gt; tailMap(K fromKey) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2988" href="#"></a></td>
<td><pre>            return tailMap(fromKey, true);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2989" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2990" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2991" href="#"></a></td>
<td><pre>        public SubMap&lt;K,V&gt; descendingMap() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2992" href="#"></a></td>
<td><pre>            return new SubMap&lt;K,V&gt;(m, lo, loInclusive,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2993" href="#"></a></td>
<td><pre>                                   hi, hiInclusive, !isDescending);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2994" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2995" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2996" href="#"></a></td>
<td><pre>        /* ----------------  Relational methods -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2997" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2998" href="#"></a></td>
<td><pre>        public Map.Entry&lt;K,V&gt; ceilingEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="2999" href="#"></a></td>
<td><pre>            return getNearEntry(key, GT|EQ);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3000" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3001" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3002" href="#"></a></td>
<td><pre>        public K ceilingKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3003" href="#"></a></td>
<td><pre>            return getNearKey(key, GT|EQ);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3004" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3005" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3006" href="#"></a></td>
<td><pre>        public Map.Entry&lt;K,V&gt; lowerEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3007" href="#"></a></td>
<td><pre>            return getNearEntry(key, LT);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3008" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3009" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3010" href="#"></a></td>
<td><pre>        public K lowerKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3011" href="#"></a></td>
<td><pre>            return getNearKey(key, LT);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3012" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3013" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3014" href="#"></a></td>
<td><pre>        public Map.Entry&lt;K,V&gt; floorEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3015" href="#"></a></td>
<td><pre>            return getNearEntry(key, LT|EQ);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3016" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3017" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3018" href="#"></a></td>
<td><pre>        public K floorKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3019" href="#"></a></td>
<td><pre>            return getNearKey(key, LT|EQ);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3020" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3021" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3022" href="#"></a></td>
<td><pre>        public Map.Entry&lt;K,V&gt; higherEntry(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3023" href="#"></a></td>
<td><pre>            return getNearEntry(key, GT);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3024" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3025" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3026" href="#"></a></td>
<td><pre>        public K higherKey(K key) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3027" href="#"></a></td>
<td><pre>            return getNearKey(key, GT);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3028" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3029" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3030" href="#"></a></td>
<td><pre>        public K firstKey() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3031" href="#"></a></td>
<td><pre>            return isDescending ? highestKey() : lowestKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3032" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3033" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3034" href="#"></a></td>
<td><pre>        public K lastKey() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3035" href="#"></a></td>
<td><pre>            return isDescending ? lowestKey() : highestKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3036" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3037" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3038" href="#"></a></td>
<td><pre>        public Map.Entry&lt;K,V&gt; firstEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3039" href="#"></a></td>
<td><pre>            return isDescending ? highestEntry() : lowestEntry();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3040" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3041" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3042" href="#"></a></td>
<td><pre>        public Map.Entry&lt;K,V&gt; lastEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3043" href="#"></a></td>
<td><pre>            return isDescending ? lowestEntry() : highestEntry();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3044" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3045" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3046" href="#"></a></td>
<td><pre>        public Map.Entry&lt;K,V&gt; pollFirstEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3047" href="#"></a></td>
<td><pre>            return isDescending ? removeHighest() : removeLowest();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3048" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3049" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3050" href="#"></a></td>
<td><pre>        public Map.Entry&lt;K,V&gt; pollLastEntry() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3051" href="#"></a></td>
<td><pre>            return isDescending ? removeLowest() : removeHighest();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3052" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3053" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3054" href="#"></a></td>
<td><pre>        /* ---------------- Submap Views -------------- */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3055" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3056" href="#"></a></td>
<td><pre>        public NavigableSet&lt;K&gt; keySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3057" href="#"></a></td>
<td><pre>            KeySet&lt;K&gt; ks = keySetView;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3058" href="#"></a></td>
<td><pre>            return (ks != null) ? ks : (keySetView = new KeySet&lt;K&gt;(this));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3059" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3060" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3061" href="#"></a></td>
<td><pre>        public NavigableSet&lt;K&gt; navigableKeySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3062" href="#"></a></td>
<td><pre>            KeySet&lt;K&gt; ks = keySetView;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3063" href="#"></a></td>
<td><pre>            return (ks != null) ? ks : (keySetView = new KeySet&lt;K&gt;(this));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3064" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3065" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3066" href="#"></a></td>
<td><pre>        public Collection&lt;V&gt; values() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3067" href="#"></a></td>
<td><pre>            Collection&lt;V&gt; vs = valuesView;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3068" href="#"></a></td>
<td><pre>            return (vs != null) ? vs : (valuesView = new Values&lt;V&gt;(this));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3069" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3070" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3071" href="#"></a></td>
<td><pre>        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3072" href="#"></a></td>
<td><pre>            Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySetView;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3073" href="#"></a></td>
<td><pre>            return (es != null) ? es : (entrySetView = new EntrySet&lt;K,V&gt;(this));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3074" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3075" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3076" href="#"></a></td>
<td><pre>        public NavigableSet&lt;K&gt; descendingKeySet() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3077" href="#"></a></td>
<td><pre>            return descendingMap().navigableKeySet();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3078" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3079" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3080" href="#"></a></td>
<td><pre>        Iterator&lt;K&gt; keyIterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3081" href="#"></a></td>
<td><pre>            return new SubMapKeyIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3082" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3083" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3084" href="#"></a></td>
<td><pre>        Iterator&lt;V&gt; valueIterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3085" href="#"></a></td>
<td><pre>            return new SubMapValueIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3086" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3087" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3088" href="#"></a></td>
<td><pre>        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; entryIterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3089" href="#"></a></td>
<td><pre>            return new SubMapEntryIterator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3090" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3091" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3092" href="#"></a></td>
<td><pre>        /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3093" href="#"></a></td>
<td><pre>         * Variant of main Iter class to traverse through submaps.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3094" href="#"></a></td>
<td><pre>         * Also serves as back-up Spliterator for views</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3095" href="#"></a></td>
<td><pre>         */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3096" href="#"></a></td>
<td><pre>        abstract class SubMapIter&lt;T&gt; implements Iterator&lt;T&gt;, Spliterator&lt;T&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3097" href="#"></a></td>
<td><pre>            /** the last node returned by next() */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3098" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; lastReturned;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3099" href="#"></a></td>
<td><pre>            /** the next node to return from next(); */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3100" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3101" href="#"></a></td>
<td><pre>            /** Cache of next value field to maintain weak consistency */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3102" href="#"></a></td>
<td><pre>            V nextValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3103" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3104" href="#"></a></td>
<td><pre>            SubMapIter() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3105" href="#"></a></td>
<td><pre>                Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3106" href="#"></a></td>
<td><pre>                for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3107" href="#"></a></td>
<td><pre>                    next = isDescending ? hiNode(cmp) : loNode(cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3108" href="#"></a></td>
<td><pre>                    if (next == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3109" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3110" href="#"></a></td>
<td><pre>                    Object x = next.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3111" href="#"></a></td>
<td><pre>                    if (x != null &amp;&amp; x != next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3112" href="#"></a></td>
<td><pre>                        if (! inBounds(next.key, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3113" href="#"></a></td>
<td><pre>                            next = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3114" href="#"></a></td>
<td><pre>                        else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3115" href="#"></a></td>
<td><pre>                            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3116" href="#"></a></td>
<td><pre>                            nextValue = vv;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3117" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3118" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3119" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3120" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3121" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3122" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3123" href="#"></a></td>
<td><pre>            public final boolean hasNext() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3124" href="#"></a></td>
<td><pre>                return next != null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3125" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3126" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3127" href="#"></a></td>
<td><pre>            final void advance() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3128" href="#"></a></td>
<td><pre>                if (next == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3129" href="#"></a></td>
<td><pre>                    throw new NoSuchElementException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3130" href="#"></a></td>
<td><pre>                lastReturned = next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3131" href="#"></a></td>
<td><pre>                if (isDescending)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3132" href="#"></a></td>
<td><pre>                    descend();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3133" href="#"></a></td>
<td><pre>                else</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3134" href="#"></a></td>
<td><pre>                    ascend();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3135" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3136" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3137" href="#"></a></td>
<td><pre>            private void ascend() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3138" href="#"></a></td>
<td><pre>                Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3139" href="#"></a></td>
<td><pre>                for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3140" href="#"></a></td>
<td><pre>                    next = next.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3141" href="#"></a></td>
<td><pre>                    if (next == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3142" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3143" href="#"></a></td>
<td><pre>                    Object x = next.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3144" href="#"></a></td>
<td><pre>                    if (x != null &amp;&amp; x != next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3145" href="#"></a></td>
<td><pre>                        if (tooHigh(next.key, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3146" href="#"></a></td>
<td><pre>                            next = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3147" href="#"></a></td>
<td><pre>                        else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3148" href="#"></a></td>
<td><pre>                            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3149" href="#"></a></td>
<td><pre>                            nextValue = vv;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3150" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3151" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3152" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3153" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3154" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3155" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3156" href="#"></a></td>
<td><pre>            private void descend() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3157" href="#"></a></td>
<td><pre>                Comparator&lt;? super K&gt; cmp = m.comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3158" href="#"></a></td>
<td><pre>                for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3159" href="#"></a></td>
<td><pre>                    next = m.findNear(lastReturned.key, LT, cmp);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3160" href="#"></a></td>
<td><pre>                    if (next == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3161" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3162" href="#"></a></td>
<td><pre>                    Object x = next.value;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3163" href="#"></a></td>
<td><pre>                    if (x != null &amp;&amp; x != next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3164" href="#"></a></td>
<td><pre>                        if (tooLow(next.key, cmp))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3165" href="#"></a></td>
<td><pre>                            next = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3166" href="#"></a></td>
<td><pre>                        else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3167" href="#"></a></td>
<td><pre>                            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)x;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3168" href="#"></a></td>
<td><pre>                            nextValue = vv;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3169" href="#"></a></td>
<td><pre>                        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3170" href="#"></a></td>
<td><pre>                        break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3171" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3172" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3173" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3174" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3175" href="#"></a></td>
<td><pre>            public void remove() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3176" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; l = lastReturned;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3177" href="#"></a></td>
<td><pre>                if (l == null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3178" href="#"></a></td>
<td><pre>                    throw new IllegalStateException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3179" href="#"></a></td>
<td><pre>                m.remove(l.key);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3180" href="#"></a></td>
<td><pre>                lastReturned = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3181" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3182" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3183" href="#"></a></td>
<td><pre>            public Spliterator&lt;T&gt; trySplit() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3184" href="#"></a></td>
<td><pre>                return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3185" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3186" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3187" href="#"></a></td>
<td><pre>            public boolean tryAdvance(Consumer&lt;? super T&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3188" href="#"></a></td>
<td><pre>                if (hasNext()) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3189" href="#"></a></td>
<td><pre>                    action.accept(next());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3190" href="#"></a></td>
<td><pre>                    return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3191" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3192" href="#"></a></td>
<td><pre>                return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3193" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3194" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3195" href="#"></a></td>
<td><pre>            public void forEachRemaining(Consumer&lt;? super T&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3196" href="#"></a></td>
<td><pre>                while (hasNext())</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3197" href="#"></a></td>
<td><pre>                    action.accept(next());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3198" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3199" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3200" href="#"></a></td>
<td><pre>            public long estimateSize() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3201" href="#"></a></td>
<td><pre>                return Long.MAX_VALUE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3202" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3203" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3204" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3205" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3206" href="#"></a></td>
<td><pre>        final class SubMapValueIterator extends SubMapIter&lt;V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3207" href="#"></a></td>
<td><pre>            public V next() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3208" href="#"></a></td>
<td><pre>                V v = nextValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3209" href="#"></a></td>
<td><pre>                advance();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3210" href="#"></a></td>
<td><pre>                return v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3211" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3212" href="#"></a></td>
<td><pre>            public int characteristics() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3213" href="#"></a></td>
<td><pre>                return 0;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3214" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3215" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3216" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3217" href="#"></a></td>
<td><pre>        final class SubMapKeyIterator extends SubMapIter&lt;K&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3218" href="#"></a></td>
<td><pre>            public K next() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3219" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; n = next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3220" href="#"></a></td>
<td><pre>                advance();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3221" href="#"></a></td>
<td><pre>                return n.key;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3222" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3223" href="#"></a></td>
<td><pre>            public int characteristics() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3224" href="#"></a></td>
<td><pre>                return Spliterator.DISTINCT | Spliterator.ORDERED |</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3225" href="#"></a></td>
<td><pre>                    Spliterator.SORTED;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3226" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3227" href="#"></a></td>
<td><pre>            public final Comparator&lt;? super K&gt; getComparator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3228" href="#"></a></td>
<td><pre>                return SubMap.this.comparator();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3229" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3230" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3231" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3232" href="#"></a></td>
<td><pre>        final class SubMapEntryIterator extends SubMapIter&lt;Map.Entry&lt;K,V&gt;&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3233" href="#"></a></td>
<td><pre>            public Map.Entry&lt;K,V&gt; next() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3234" href="#"></a></td>
<td><pre>                Node&lt;K,V&gt; n = next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3235" href="#"></a></td>
<td><pre>                V v = nextValue;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3236" href="#"></a></td>
<td><pre>                advance();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3237" href="#"></a></td>
<td><pre>                return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3238" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3239" href="#"></a></td>
<td><pre>            public int characteristics() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3240" href="#"></a></td>
<td><pre>                return Spliterator.DISTINCT;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3241" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3242" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3243" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3244" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3245" href="#"></a></td>
<td><pre>    // default Map method overrides</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3246" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3247" href="#"></a></td>
<td><pre>    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3248" href="#"></a></td>
<td><pre>        if (action == null) throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3249" href="#"></a></td>
<td><pre>        V v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3250" href="#"></a></td>
<td><pre>        for (Node&lt;K,V&gt; n = findFirst(); n != null; n = n.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3251" href="#"></a></td>
<td><pre>            if ((v = n.getValidValue()) != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3252" href="#"></a></td>
<td><pre>                action.accept(n.key, v);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3253" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3254" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3255" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3256" href="#"></a></td>
<td><pre>    public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3257" href="#"></a></td>
<td><pre>        if (function == null) throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3258" href="#"></a></td>
<td><pre>        V v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3259" href="#"></a></td>
<td><pre>        for (Node&lt;K,V&gt; n = findFirst(); n != null; n = n.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3260" href="#"></a></td>
<td><pre>            while ((v = n.getValidValue()) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3261" href="#"></a></td>
<td><pre>                V r = function.apply(n.key, v);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3262" href="#"></a></td>
<td><pre>                if (r == null) throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3263" href="#"></a></td>
<td><pre>                if (n.casValue(v, r))</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3264" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3265" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3266" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3267" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3268" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3269" href="#"></a></td>
<td><pre>    /**</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3270" href="#"></a></td>
<td><pre>     * Base class providing common structure for Spliterators.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3271" href="#"></a></td>
<td><pre>     * (Although not all that much common functionality; as usual for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3272" href="#"></a></td>
<td><pre>     * view classes, details annoyingly vary in key, value, and entry</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3273" href="#"></a></td>
<td><pre>     * subclasses in ways that are not worth abstracting out for</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3274" href="#"></a></td>
<td><pre>     * internal classes.)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3275" href="#"></a></td>
<td><pre>     *</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3276" href="#"></a></td>
<td><pre>     * The basic split strategy is to recursively descend from top</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3277" href="#"></a></td>
<td><pre>     * level, row by row, descending to next row when either split</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3278" href="#"></a></td>
<td><pre>     * off, or the end of row is encountered. Control of the number of</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3279" href="#"></a></td>
<td><pre>     * splits relies on some statistical estimation: The expected</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3280" href="#"></a></td>
<td><pre>     * remaining number of elements of a skip list when advancing</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3281" href="#"></a></td>
<td><pre>     * either across or down decreases by about 25%. To make this</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3282" href="#"></a></td>
<td><pre>     * observation useful, we need to know initial size, which we</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3283" href="#"></a></td>
<td><pre>     * don't. But we can just use Integer.MAX_VALUE so that we</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3284" href="#"></a></td>
<td><pre>     * don't prematurely zero out while splitting.</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3285" href="#"></a></td>
<td><pre>     */</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3286" href="#"></a></td>
<td><pre>    abstract static class CSLMSpliterator&lt;K,V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3287" href="#"></a></td>
<td><pre>        final Comparator&lt;? super K&gt; comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3288" href="#"></a></td>
<td><pre>        final K fence;     // exclusive upper bound for keys, or null if to end</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3289" href="#"></a></td>
<td><pre>        Index&lt;K,V&gt; row;    // the level to split out</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3290" href="#"></a></td>
<td><pre>        Node&lt;K,V&gt; current; // current traversal node; initialize at origin</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3291" href="#"></a></td>
<td><pre>        int est;           // pseudo-size estimate</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3292" href="#"></a></td>
<td><pre>        CSLMSpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3293" href="#"></a></td>
<td><pre>                        Node&lt;K,V&gt; origin, K fence, int est) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3294" href="#"></a></td>
<td><pre>            this.comparator = comparator; this.row = row;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3295" href="#"></a></td>
<td><pre>            this.current = origin; this.fence = fence; this.est = est;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3296" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3297" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3298" href="#"></a></td>
<td><pre>        public final long estimateSize() { return (long)est; }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3299" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3300" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3301" href="#"></a></td>
<td><pre>    static final class KeySpliterator&lt;K,V&gt; extends CSLMSpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3302" href="#"></a></td>
<td><pre>        implements Spliterator&lt;K&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3303" href="#"></a></td>
<td><pre>        KeySpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3304" href="#"></a></td>
<td><pre>                       Node&lt;K,V&gt; origin, K fence, int est) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3305" href="#"></a></td>
<td><pre>            super(comparator, row, origin, fence, est);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3306" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3307" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3308" href="#"></a></td>
<td><pre>        public Spliterator&lt;K&gt; trySplit() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3309" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; e; K ek;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3310" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3311" href="#"></a></td>
<td><pre>            K f = fence;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3312" href="#"></a></td>
<td><pre>            if ((e = current) != null &amp;&amp; (ek = e.key) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3313" href="#"></a></td>
<td><pre>                for (Index&lt;K,V&gt; q = row; q != null; q = row = q.down) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3314" href="#"></a></td>
<td><pre>                    Index&lt;K,V&gt; s; Node&lt;K,V&gt; b, n; K sk;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3315" href="#"></a></td>
<td><pre>                    if ((s = q.right) != null &amp;&amp; (b = s.node) != null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3316" href="#"></a></td>
<td><pre>                        (n = b.next) != null &amp;&amp; n.value != null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3317" href="#"></a></td>
<td><pre>                        (sk = n.key) != null &amp;&amp; cpr(cmp, sk, ek) &gt; 0 &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3318" href="#"></a></td>
<td><pre>                        (f == null || cpr(cmp, sk, f) &lt; 0)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3319" href="#"></a></td>
<td><pre>                        current = n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3320" href="#"></a></td>
<td><pre>                        Index&lt;K,V&gt; r = q.down;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3321" href="#"></a></td>
<td><pre>                        row = (s.right != null) ? s : s.down;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3322" href="#"></a></td>
<td><pre>                        est -= est &gt;&gt;&gt; 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3323" href="#"></a></td>
<td><pre>                        return new KeySpliterator&lt;K,V&gt;(cmp, r, e, sk, est);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3324" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3325" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3326" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3327" href="#"></a></td>
<td><pre>            return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3328" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3329" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3330" href="#"></a></td>
<td><pre>        public void forEachRemaining(Consumer&lt;? super K&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3331" href="#"></a></td>
<td><pre>            if (action == null) throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3332" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3333" href="#"></a></td>
<td><pre>            K f = fence;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3334" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; e = current;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3335" href="#"></a></td>
<td><pre>            current = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3336" href="#"></a></td>
<td><pre>            for (; e != null; e = e.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3337" href="#"></a></td>
<td><pre>                K k; Object v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3338" href="#"></a></td>
<td><pre>                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3339" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3340" href="#"></a></td>
<td><pre>                if ((v = e.value) != null &amp;&amp; v != e)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3341" href="#"></a></td>
<td><pre>                    action.accept(k);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3342" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3343" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3344" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3345" href="#"></a></td>
<td><pre>        public boolean tryAdvance(Consumer&lt;? super K&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3346" href="#"></a></td>
<td><pre>            if (action == null) throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3347" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3348" href="#"></a></td>
<td><pre>            K f = fence;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3349" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; e = current;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3350" href="#"></a></td>
<td><pre>            for (; e != null; e = e.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3351" href="#"></a></td>
<td><pre>                K k; Object v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3352" href="#"></a></td>
<td><pre>                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3353" href="#"></a></td>
<td><pre>                    e = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3354" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3355" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3356" href="#"></a></td>
<td><pre>                if ((v = e.value) != null &amp;&amp; v != e) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3357" href="#"></a></td>
<td><pre>                    current = e.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3358" href="#"></a></td>
<td><pre>                    action.accept(k);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3359" href="#"></a></td>
<td><pre>                    return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3360" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3361" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3362" href="#"></a></td>
<td><pre>            current = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3363" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3364" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3365" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3366" href="#"></a></td>
<td><pre>        public int characteristics() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3367" href="#"></a></td>
<td><pre>            return Spliterator.DISTINCT | Spliterator.SORTED |</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3368" href="#"></a></td>
<td><pre>                Spliterator.ORDERED | Spliterator.CONCURRENT |</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3369" href="#"></a></td>
<td><pre>                Spliterator.NONNULL;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3370" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3371" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3372" href="#"></a></td>
<td><pre>        public final Comparator&lt;? super K&gt; getComparator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3373" href="#"></a></td>
<td><pre>            return comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3374" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3375" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3376" href="#"></a></td>
<td><pre>    // factory method for KeySpliterator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3377" href="#"></a></td>
<td><pre>    final KeySpliterator&lt;K,V&gt; keySpliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3378" href="#"></a></td>
<td><pre>        Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3379" href="#"></a></td>
<td><pre>        for (;;) { // ensure h corresponds to origin p</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3380" href="#"></a></td>
<td><pre>            HeadIndex&lt;K,V&gt; h; Node&lt;K,V&gt; p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3381" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; b = (h = head).node;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3382" href="#"></a></td>
<td><pre>            if ((p = b.next) == null || p.value != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3383" href="#"></a></td>
<td><pre>                return new KeySpliterator&lt;K,V&gt;(cmp, h, p, null, (p == null) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3384" href="#"></a></td>
<td><pre>                                               0 : Integer.MAX_VALUE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3385" href="#"></a></td>
<td><pre>            p.helpDelete(b, p.next);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3386" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3387" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3388" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3389" href="#"></a></td>
<td><pre>    static final class ValueSpliterator&lt;K,V&gt; extends CSLMSpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3390" href="#"></a></td>
<td><pre>        implements Spliterator&lt;V&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3391" href="#"></a></td>
<td><pre>        ValueSpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3392" href="#"></a></td>
<td><pre>                       Node&lt;K,V&gt; origin, K fence, int est) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3393" href="#"></a></td>
<td><pre>            super(comparator, row, origin, fence, est);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3394" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3395" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3396" href="#"></a></td>
<td><pre>        public Spliterator&lt;V&gt; trySplit() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3397" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; e; K ek;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3398" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3399" href="#"></a></td>
<td><pre>            K f = fence;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3400" href="#"></a></td>
<td><pre>            if ((e = current) != null &amp;&amp; (ek = e.key) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3401" href="#"></a></td>
<td><pre>                for (Index&lt;K,V&gt; q = row; q != null; q = row = q.down) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3402" href="#"></a></td>
<td><pre>                    Index&lt;K,V&gt; s; Node&lt;K,V&gt; b, n; K sk;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3403" href="#"></a></td>
<td><pre>                    if ((s = q.right) != null &amp;&amp; (b = s.node) != null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3404" href="#"></a></td>
<td><pre>                        (n = b.next) != null &amp;&amp; n.value != null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3405" href="#"></a></td>
<td><pre>                        (sk = n.key) != null &amp;&amp; cpr(cmp, sk, ek) &gt; 0 &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3406" href="#"></a></td>
<td><pre>                        (f == null || cpr(cmp, sk, f) &lt; 0)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3407" href="#"></a></td>
<td><pre>                        current = n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3408" href="#"></a></td>
<td><pre>                        Index&lt;K,V&gt; r = q.down;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3409" href="#"></a></td>
<td><pre>                        row = (s.right != null) ? s : s.down;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3410" href="#"></a></td>
<td><pre>                        est -= est &gt;&gt;&gt; 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3411" href="#"></a></td>
<td><pre>                        return new ValueSpliterator&lt;K,V&gt;(cmp, r, e, sk, est);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3412" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3413" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3414" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3415" href="#"></a></td>
<td><pre>            return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3416" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3417" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3418" href="#"></a></td>
<td><pre>        public void forEachRemaining(Consumer&lt;? super V&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3419" href="#"></a></td>
<td><pre>            if (action == null) throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3420" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3421" href="#"></a></td>
<td><pre>            K f = fence;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3422" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; e = current;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3423" href="#"></a></td>
<td><pre>            current = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3424" href="#"></a></td>
<td><pre>            for (; e != null; e = e.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3425" href="#"></a></td>
<td><pre>                K k; Object v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3426" href="#"></a></td>
<td><pre>                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3427" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3428" href="#"></a></td>
<td><pre>                if ((v = e.value) != null &amp;&amp; v != e) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3429" href="#"></a></td>
<td><pre>                    @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3430" href="#"></a></td>
<td><pre>                    action.accept(vv);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3431" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3432" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3433" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3434" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3435" href="#"></a></td>
<td><pre>        public boolean tryAdvance(Consumer&lt;? super V&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3436" href="#"></a></td>
<td><pre>            if (action == null) throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3437" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3438" href="#"></a></td>
<td><pre>            K f = fence;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3439" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; e = current;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3440" href="#"></a></td>
<td><pre>            for (; e != null; e = e.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3441" href="#"></a></td>
<td><pre>                K k; Object v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3442" href="#"></a></td>
<td><pre>                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3443" href="#"></a></td>
<td><pre>                    e = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3444" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3445" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3446" href="#"></a></td>
<td><pre>                if ((v = e.value) != null &amp;&amp; v != e) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3447" href="#"></a></td>
<td><pre>                    current = e.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3448" href="#"></a></td>
<td><pre>                    @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3449" href="#"></a></td>
<td><pre>                    action.accept(vv);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3450" href="#"></a></td>
<td><pre>                    return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3451" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3452" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3453" href="#"></a></td>
<td><pre>            current = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3454" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3455" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3456" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3457" href="#"></a></td>
<td><pre>        public int characteristics() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3458" href="#"></a></td>
<td><pre>            return Spliterator.CONCURRENT | Spliterator.ORDERED |</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3459" href="#"></a></td>
<td><pre>                Spliterator.NONNULL;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3460" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3461" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3462" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3463" href="#"></a></td>
<td><pre>    // Almost the same as keySpliterator()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3464" href="#"></a></td>
<td><pre>    final ValueSpliterator&lt;K,V&gt; valueSpliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3465" href="#"></a></td>
<td><pre>        Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3466" href="#"></a></td>
<td><pre>        for (;;) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3467" href="#"></a></td>
<td><pre>            HeadIndex&lt;K,V&gt; h; Node&lt;K,V&gt; p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3468" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; b = (h = head).node;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3469" href="#"></a></td>
<td><pre>            if ((p = b.next) == null || p.value != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3470" href="#"></a></td>
<td><pre>                return new ValueSpliterator&lt;K,V&gt;(cmp, h, p, null, (p == null) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3471" href="#"></a></td>
<td><pre>                                                 0 : Integer.MAX_VALUE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3472" href="#"></a></td>
<td><pre>            p.helpDelete(b, p.next);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3473" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3474" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3475" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3476" href="#"></a></td>
<td><pre>    static final class EntrySpliterator&lt;K,V&gt; extends CSLMSpliterator&lt;K,V&gt;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3477" href="#"></a></td>
<td><pre>        implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3478" href="#"></a></td>
<td><pre>        EntrySpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3479" href="#"></a></td>
<td><pre>                         Node&lt;K,V&gt; origin, K fence, int est) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3480" href="#"></a></td>
<td><pre>            super(comparator, row, origin, fence, est);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3481" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3482" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3483" href="#"></a></td>
<td><pre>        public Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; trySplit() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3484" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; e; K ek;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3485" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3486" href="#"></a></td>
<td><pre>            K f = fence;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3487" href="#"></a></td>
<td><pre>            if ((e = current) != null &amp;&amp; (ek = e.key) != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3488" href="#"></a></td>
<td><pre>                for (Index&lt;K,V&gt; q = row; q != null; q = row = q.down) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3489" href="#"></a></td>
<td><pre>                    Index&lt;K,V&gt; s; Node&lt;K,V&gt; b, n; K sk;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3490" href="#"></a></td>
<td><pre>                    if ((s = q.right) != null &amp;&amp; (b = s.node) != null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3491" href="#"></a></td>
<td><pre>                        (n = b.next) != null &amp;&amp; n.value != null &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3492" href="#"></a></td>
<td><pre>                        (sk = n.key) != null &amp;&amp; cpr(cmp, sk, ek) &gt; 0 &amp;&amp;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3493" href="#"></a></td>
<td><pre>                        (f == null || cpr(cmp, sk, f) &lt; 0)) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3494" href="#"></a></td>
<td><pre>                        current = n;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3495" href="#"></a></td>
<td><pre>                        Index&lt;K,V&gt; r = q.down;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3496" href="#"></a></td>
<td><pre>                        row = (s.right != null) ? s : s.down;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3497" href="#"></a></td>
<td><pre>                        est -= est &gt;&gt;&gt; 2;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3498" href="#"></a></td>
<td><pre>                        return new EntrySpliterator&lt;K,V&gt;(cmp, r, e, sk, est);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3499" href="#"></a></td>
<td><pre>                    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3500" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3501" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3502" href="#"></a></td>
<td><pre>            return null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3503" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3504" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3505" href="#"></a></td>
<td><pre>        public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3506" href="#"></a></td>
<td><pre>            if (action == null) throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3507" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3508" href="#"></a></td>
<td><pre>            K f = fence;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3509" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; e = current;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3510" href="#"></a></td>
<td><pre>            current = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3511" href="#"></a></td>
<td><pre>            for (; e != null; e = e.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3512" href="#"></a></td>
<td><pre>                K k; Object v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3513" href="#"></a></td>
<td><pre>                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3514" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3515" href="#"></a></td>
<td><pre>                if ((v = e.value) != null &amp;&amp; v != e) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3516" href="#"></a></td>
<td><pre>                    @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3517" href="#"></a></td>
<td><pre>                    action.accept</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3518" href="#"></a></td>
<td><pre>                        (new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, vv));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3519" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3520" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3521" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3522" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3523" href="#"></a></td>
<td><pre>        public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3524" href="#"></a></td>
<td><pre>            if (action == null) throw new NullPointerException();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3525" href="#"></a></td>
<td><pre>            Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3526" href="#"></a></td>
<td><pre>            K f = fence;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3527" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; e = current;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3528" href="#"></a></td>
<td><pre>            for (; e != null; e = e.next) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3529" href="#"></a></td>
<td><pre>                K k; Object v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3530" href="#"></a></td>
<td><pre>                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3531" href="#"></a></td>
<td><pre>                    e = null;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3532" href="#"></a></td>
<td><pre>                    break;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3533" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3534" href="#"></a></td>
<td><pre>                if ((v = e.value) != null &amp;&amp; v != e) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3535" href="#"></a></td>
<td><pre>                    current = e.next;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3536" href="#"></a></td>
<td><pre>                    @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3537" href="#"></a></td>
<td><pre>                    action.accept</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3538" href="#"></a></td>
<td><pre>                        (new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, vv));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3539" href="#"></a></td>
<td><pre>                    return true;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3540" href="#"></a></td>
<td><pre>                }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3541" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3542" href="#"></a></td>
<td><pre>            current = e;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3543" href="#"></a></td>
<td><pre>            return false;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3544" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3545" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3546" href="#"></a></td>
<td><pre>        public int characteristics() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3547" href="#"></a></td>
<td><pre>            return Spliterator.DISTINCT | Spliterator.SORTED |</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3548" href="#"></a></td>
<td><pre>                Spliterator.ORDERED | Spliterator.CONCURRENT |</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3549" href="#"></a></td>
<td><pre>                Spliterator.NONNULL;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3550" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3551" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3552" href="#"></a></td>
<td><pre>        public final Comparator&lt;Map.Entry&lt;K,V&gt;&gt; getComparator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3553" href="#"></a></td>
<td><pre>            // Adapt or create a key-based comparator</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3554" href="#"></a></td>
<td><pre>            if (comparator != null) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3555" href="#"></a></td>
<td><pre>                return Map.Entry.comparingByKey(comparator);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3556" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3557" href="#"></a></td>
<td><pre>            else {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3558" href="#"></a></td>
<td><pre>                return (Comparator&lt;Map.Entry&lt;K,V&gt;&gt; &amp; Serializable) (e1, e2) -&gt; {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3559" href="#"></a></td>
<td><pre>                    @SuppressWarnings(&quot;unchecked&quot;)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3560" href="#"></a></td>
<td><pre>                    Comparable&lt;? super K&gt; k1 = (Comparable&lt;? super K&gt;) e1.getKey();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3561" href="#"></a></td>
<td><pre>                    return k1.compareTo(e2.getKey());</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3562" href="#"></a></td>
<td><pre>                };</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3563" href="#"></a></td>
<td><pre>            }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3564" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3565" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3566" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3567" href="#"></a></td>
<td><pre>    // Almost the same as keySpliterator()</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3568" href="#"></a></td>
<td><pre>    final EntrySpliterator&lt;K,V&gt; entrySpliterator() {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3569" href="#"></a></td>
<td><pre>        Comparator&lt;? super K&gt; cmp = comparator;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3570" href="#"></a></td>
<td><pre>        for (;;) { // almost same as key version</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3571" href="#"></a></td>
<td><pre>            HeadIndex&lt;K,V&gt; h; Node&lt;K,V&gt; p;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3572" href="#"></a></td>
<td><pre>            Node&lt;K,V&gt; b = (h = head).node;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3573" href="#"></a></td>
<td><pre>            if ((p = b.next) == null || p.value != null)</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3574" href="#"></a></td>
<td><pre>                return new EntrySpliterator&lt;K,V&gt;(cmp, h, p, null, (p == null) ?</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3575" href="#"></a></td>
<td><pre>                                                 0 : Integer.MAX_VALUE);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3576" href="#"></a></td>
<td><pre>            p.helpDelete(b, p.next);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3577" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3578" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3579" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3580" href="#"></a></td>
<td><pre>    // Unsafe mechanics</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3581" href="#"></a></td>
<td><pre>    private static final sun.misc.Unsafe UNSAFE;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3582" href="#"></a></td>
<td><pre>    private static final long headOffset;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3583" href="#"></a></td>
<td><pre>    private static final long SECONDARY;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3584" href="#"></a></td>
<td><pre>    static {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3585" href="#"></a></td>
<td><pre>        try {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3586" href="#"></a></td>
<td><pre>            UNSAFE = sun.misc.Unsafe.getUnsafe();</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3587" href="#"></a></td>
<td><pre>            Class&lt;?&gt; k = ConcurrentSkipListMap.class;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3588" href="#"></a></td>
<td><pre>            headOffset = UNSAFE.objectFieldOffset</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3589" href="#"></a></td>
<td><pre>                (k.getDeclaredField(&quot;head&quot;));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3590" href="#"></a></td>
<td><pre>            Class&lt;?&gt; tk = Thread.class;</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3591" href="#"></a></td>
<td><pre>            SECONDARY = UNSAFE.objectFieldOffset</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3592" href="#"></a></td>
<td><pre>                (tk.getDeclaredField(&quot;threadLocalRandomSecondarySeed&quot;));</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3593" href="#"></a></td>
<td><pre></pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3594" href="#"></a></td>
<td><pre>        } catch (Exception e) {</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3595" href="#"></a></td>
<td><pre>            throw new Error(e);</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3596" href="#"></a></td>
<td><pre>        }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3597" href="#"></a></td>
<td><pre>    }</pre></td>
</tr>
<tr>
<td><a class="linenum-cell" data-linenum="3598" href="#"></a></td>
<td><pre>}</pre></td>
</tr>
</table>
</body>
</html>
