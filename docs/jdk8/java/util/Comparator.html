<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/css/styles.css"/>
    </head>
<body>
<pre class="code">
/*
 * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

import java.io.Serializable;
import java.util.function.Function;
import java.util.function.ToIntFunction;
import java.util.function.ToLongFunction;
import java.util.function.ToDoubleFunction;
import java.util.Comparators;

/**
 * A comparison function, which imposes a &lt;i&gt;total ordering&lt;/i&gt; on some
 * collection of objects.  Comparators can be passed to a sort method (such
 * as {@link Collections#sort(List,Comparator) Collections.sort} or {@link
 * Arrays#sort(Object[],Comparator) Arrays.sort}) to allow precise control
 * over the sort order.  Comparators can also be used to control the order of
 * certain data structures (such as {@link SortedSet sorted sets} or {@link
 * SortedMap sorted maps}), or to provide an ordering for collections of
 * objects that don't have a {@link Comparable natural ordering}.&lt;p&gt;
 *
 * The ordering imposed by a comparator &lt;tt&gt;c&lt;/tt&gt; on a set of elements
 * &lt;tt&gt;S&lt;/tt&gt; is said to be &lt;i&gt;consistent with equals&lt;/i&gt; if and only if
 * &lt;tt&gt;c.compare(e1, e2)==0&lt;/tt&gt; has the same boolean value as
 * &lt;tt&gt;e1.equals(e2)&lt;/tt&gt; for every &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; in
 * &lt;tt&gt;S&lt;/tt&gt;.&lt;p&gt;
 *
 * Caution should be exercised when using a comparator capable of imposing an
 * ordering inconsistent with equals to order a sorted set (or sorted map).
 * Suppose a sorted set (or sorted map) with an explicit comparator &lt;tt&gt;c&lt;/tt&gt;
 * is used with elements (or keys) drawn from a set &lt;tt&gt;S&lt;/tt&gt;.  If the
 * ordering imposed by &lt;tt&gt;c&lt;/tt&gt; on &lt;tt&gt;S&lt;/tt&gt; is inconsistent with equals,
 * the sorted set (or sorted map) will behave &quot;strangely.&quot;  In particular the
 * sorted set (or sorted map) will violate the general contract for set (or
 * map), which is defined in terms of &lt;tt&gt;equals&lt;/tt&gt;.&lt;p&gt;
 *
 * For example, suppose one adds two elements {@code a} and {@code b} such that
 * {@code (a.equals(b) &amp;&amp; c.compare(a, b) != 0)}
 * to an empty {@code TreeSet} with comparator {@code c}.
 * The second {@code add} operation will return
 * true (and the size of the tree set will increase) because {@code a} and
 * {@code b} are not equivalent from the tree set's perspective, even though
 * this is contrary to the specification of the
 * {@link Set#add Set.add} method.&lt;p&gt;
 *
 * Note: It is generally a good idea for comparators to also implement
 * &lt;tt&gt;java.io.Serializable&lt;/tt&gt;, as they may be used as ordering methods in
 * serializable data structures (like {@link TreeSet}, {@link TreeMap}).  In
 * order for the data structure to serialize successfully, the comparator (if
 * provided) must implement &lt;tt&gt;Serializable&lt;/tt&gt;.&lt;p&gt;
 *
 * For the mathematically inclined, the &lt;i&gt;relation&lt;/i&gt; that defines the
 * &lt;i&gt;imposed ordering&lt;/i&gt; that a given comparator &lt;tt&gt;c&lt;/tt&gt; imposes on a
 * given set of objects &lt;tt&gt;S&lt;/tt&gt; is:&lt;pre&gt;
 *       {(x, y) such that c.compare(x, y) &amp;lt;= 0}.
 * &lt;/pre&gt; The &lt;i&gt;quotient&lt;/i&gt; for this total order is:&lt;pre&gt;
 *       {(x, y) such that c.compare(x, y) == 0}.
 * &lt;/pre&gt;
 *
 * It follows immediately from the contract for &lt;tt&gt;compare&lt;/tt&gt; that the
 * quotient is an &lt;i&gt;equivalence relation&lt;/i&gt; on &lt;tt&gt;S&lt;/tt&gt;, and that the
 * imposed ordering is a &lt;i&gt;total order&lt;/i&gt; on &lt;tt&gt;S&lt;/tt&gt;.  When we say that
 * the ordering imposed by &lt;tt&gt;c&lt;/tt&gt; on &lt;tt&gt;S&lt;/tt&gt; is &lt;i&gt;consistent with
 * equals&lt;/i&gt;, we mean that the quotient for the ordering is the equivalence
 * relation defined by the objects' {@link Object#equals(Object)
 * equals(Object)} method(s):&lt;pre&gt;
 *     {(x, y) such that x.equals(y)}. &lt;/pre&gt;
 *
 * &lt;p&gt;Unlike {@code Comparable}, a comparator may optionally permit
 * comparison of null arguments, while maintaining the requirements for
 * an equivalence relation.
 *
 * &lt;p&gt;This interface is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @param &lt;T&gt; the type of objects that may be compared by this comparator
 *
 * @author  Josh Bloch
 * @author  Neal Gafter
 * @see Comparable
 * @see java.io.Serializable
 * @since 1.2
 */
@FunctionalInterface
public interface Comparator&lt;T&gt; {
    /**
     * Compares its two arguments for order.  Returns a negative integer,
     * zero, or a positive integer as the first argument is less than, equal
     * to, or greater than the second.&lt;p&gt;
     *
     * In the foregoing description, the notation
     * &lt;tt&gt;sgn(&lt;/tt&gt;&lt;i&gt;expression&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt; designates the mathematical
     * &lt;i&gt;signum&lt;/i&gt; function, which is defined to return one of &lt;tt&gt;-1&lt;/tt&gt;,
     * &lt;tt&gt;0&lt;/tt&gt;, or &lt;tt&gt;1&lt;/tt&gt; according to whether the value of
     * &lt;i&gt;expression&lt;/i&gt; is negative, zero or positive.&lt;p&gt;
     *
     * The implementor must ensure that &lt;tt&gt;sgn(compare(x, y)) ==
     * -sgn(compare(y, x))&lt;/tt&gt; for all &lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;y&lt;/tt&gt;.  (This
     * implies that &lt;tt&gt;compare(x, y)&lt;/tt&gt; must throw an exception if and only
     * if &lt;tt&gt;compare(y, x)&lt;/tt&gt; throws an exception.)&lt;p&gt;
     *
     * The implementor must also ensure that the relation is transitive:
     * &lt;tt&gt;((compare(x, y)&amp;gt;0) &amp;amp;&amp;amp; (compare(y, z)&amp;gt;0))&lt;/tt&gt; implies
     * &lt;tt&gt;compare(x, z)&amp;gt;0&lt;/tt&gt;.&lt;p&gt;
     *
     * Finally, the implementor must ensure that &lt;tt&gt;compare(x, y)==0&lt;/tt&gt;
     * implies that &lt;tt&gt;sgn(compare(x, z))==sgn(compare(y, z))&lt;/tt&gt; for all
     * &lt;tt&gt;z&lt;/tt&gt;.&lt;p&gt;
     *
     * It is generally the case, but &lt;i&gt;not&lt;/i&gt; strictly required that
     * &lt;tt&gt;(compare(x, y)==0) == (x.equals(y))&lt;/tt&gt;.  Generally speaking,
     * any comparator that violates this condition should clearly indicate
     * this fact.  The recommended language is &quot;Note: this comparator
     * imposes orderings that are inconsistent with equals.&quot;
     *
     * @param o1 the first object to be compared.
     * @param o2 the second object to be compared.
     * @return a negative integer, zero, or a positive integer as the
     *         first argument is less than, equal to, or greater than the
     *         second.
     * @throws NullPointerException if an argument is null and this
     *         comparator does not permit null arguments
     * @throws ClassCastException if the arguments' types prevent them from
     *         being compared by this comparator.
     */
    int compare(T o1, T o2);

    /**
     * Indicates whether some other object is &amp;quot;equal to&amp;quot; this
     * comparator.  This method must obey the general contract of
     * {@link Object#equals(Object)}.  Additionally, this method can return
     * &lt;tt&gt;true&lt;/tt&gt; &lt;i&gt;only&lt;/i&gt; if the specified object is also a comparator
     * and it imposes the same ordering as this comparator.  Thus,
     * &lt;code&gt;comp1.equals(comp2)&lt;/code&gt; implies that &lt;tt&gt;sgn(comp1.compare(o1,
     * o2))==sgn(comp2.compare(o1, o2))&lt;/tt&gt; for every object reference
     * &lt;tt&gt;o1&lt;/tt&gt; and &lt;tt&gt;o2&lt;/tt&gt;.&lt;p&gt;
     *
     * Note that it is &lt;i&gt;always&lt;/i&gt; safe &lt;i&gt;not&lt;/i&gt; to override
     * &lt;tt&gt;Object.equals(Object)&lt;/tt&gt;.  However, overriding this method may,
     * in some cases, improve performance by allowing programs to determine
     * that two distinct comparators impose the same order.
     *
     * @param   obj   the reference object with which to compare.
     * @return  &lt;code&gt;true&lt;/code&gt; only if the specified object is also
     *          a comparator and it imposes the same ordering as this
     *          comparator.
     * @see Object#equals(Object)
     * @see Object#hashCode()
     */
    boolean equals(Object obj);

    /**
     * Returns a comparator that imposes the reverse ordering of this
     * comparator.
     *
     * @return a comparator that imposes the reverse ordering of this
     *         comparator.
     * @since 1.8
     */
    default Comparator&lt;T&gt; reversed() {
        return Collections.reverseOrder(this);
    }

    /**
     * Returns a lexicographic-order comparator with another comparator.
     * If this {@code Comparator} considers two elements equal, i.e.
     * {@code compare(a, b) == 0}, {@code other} is used to determine the order.
     *
     * &lt;p&gt;The returned comparator is serializable if the specified comparator
     * is also serializable.
     *
     * @apiNote
     * For example, to sort a collection of {@code String} based on the length
     * and then case-insensitive natural ordering, the comparator can be
     * composed using following code,
     *
     * &lt;pre&gt;{@code
     *     Comparator&lt;String&gt; cmp = Comparator.comparingInt(String::length)
     *             .thenComparing(String.CASE_INSENSITIVE_ORDER);
     * }&lt;/pre&gt;
     *
     * @param  other the other comparator to be used when this comparator
     *         compares two objects that are equal.
     * @return a lexicographic-order comparator composed of this and then the
     *         other comparator
     * @throws NullPointerException if the argument is null.
     * @since 1.8
     */
    default Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other) {
        Objects.requireNonNull(other);
        return (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; {
            int res = compare(c1, c2);
            return (res != 0) ? res : other.compare(c1, c2);
        };
    }

    /**
     * Returns a lexicographic-order comparator with a function that
     * extracts a key to be compared with the given {@code Comparator}.
     *
     * @implSpec This default implementation behaves as if {@code
     *           thenComparing(comparing(keyExtractor, cmp))}.
     *
     * @param  &lt;U&gt;  the type of the sort key
     * @param  keyExtractor the function used to extract the sort key
     * @param  keyComparator the {@code Comparator} used to compare the sort key
     * @return a lexicographic-order comparator composed of this comparator
     *         and then comparing on the key extracted by the keyExtractor function
     * @throws NullPointerException if either argument is null.
     * @see #comparing(Function, Comparator)
     * @see #thenComparing(Comparator)
     * @since 1.8
     */
    default &lt;U&gt; Comparator&lt;T&gt; thenComparing(
            Function&lt;? super T, ? extends U&gt; keyExtractor,
            Comparator&lt;? super U&gt; keyComparator)
    {
        return thenComparing(comparing(keyExtractor, keyComparator));
    }

    /**
     * Returns a lexicographic-order comparator with a function that
     * extracts a {@code Comparable} sort key.
     *
     * @implSpec This default implementation behaves as if {@code
     *           thenComparing(comparing(keyExtractor))}.
     *
     * @param  &lt;U&gt;  the type of the {@link Comparable} sort key
     * @param  keyExtractor the function used to extract the {@link
     *         Comparable} sort key
     * @return a lexicographic-order comparator composed of this and then the
     *         {@link Comparable} sort key.
     * @throws NullPointerException if the argument is null.
     * @see #comparing(Function)
     * @see #thenComparing(Comparator)
     * @since 1.8
     */
    default &lt;U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; thenComparing(
            Function&lt;? super T, ? extends U&gt; keyExtractor)
    {
        return thenComparing(comparing(keyExtractor));
    }

    /**
     * Returns a lexicographic-order comparator with a function that
     * extracts a {@code int} sort key.
     *
     * @implSpec This default implementation behaves as if {@code
     *           thenComparing(comparingInt(keyExtractor))}.
     *
     * @param  keyExtractor the function used to extract the integer sort key
     * @return a lexicographic-order comparator composed of this and then the
     *         {@code int} sort key
     * @throws NullPointerException if the argument is null.
     * @see #comparingInt(ToIntFunction)
     * @see #thenComparing(Comparator)
     * @since 1.8
     */
    default Comparator&lt;T&gt; thenComparingInt(ToIntFunction&lt;? super T&gt; keyExtractor) {
        return thenComparing(comparingInt(keyExtractor));
    }

    /**
     * Returns a lexicographic-order comparator with a function that
     * extracts a {@code long} sort key.
     *
     * @implSpec This default implementation behaves as if {@code
     *           thenComparing(comparingLong(keyExtractor))}.
     *
     * @param  keyExtractor the function used to extract the long sort key
     * @return a lexicographic-order comparator composed of this and then the
     *         {@code long} sort key
     * @throws NullPointerException if the argument is null.
     * @see #comparingLong(ToLongFunction)
     * @see #thenComparing(Comparator)
     * @since 1.8
     */
    default Comparator&lt;T&gt; thenComparingLong(ToLongFunction&lt;? super T&gt; keyExtractor) {
        return thenComparing(comparingLong(keyExtractor));
    }

    /**
     * Returns a lexicographic-order comparator with a function that
     * extracts a {@code double} sort key.
     *
     * @implSpec This default implementation behaves as if {@code
     *           thenComparing(comparingDouble(keyExtractor))}.
     *
     * @param  keyExtractor the function used to extract the double sort key
     * @return a lexicographic-order comparator composed of this and then the
     *         {@code double} sort key
     * @throws NullPointerException if the argument is null.
     * @see #comparingDouble(ToDoubleFunction)
     * @see #thenComparing(Comparator)
     * @since 1.8
     */
    default Comparator&lt;T&gt; thenComparingDouble(ToDoubleFunction&lt;? super T&gt; keyExtractor) {
        return thenComparing(comparingDouble(keyExtractor));
    }

    /**
     * Returns a comparator that imposes the reverse of the &lt;em&gt;natural
     * ordering&lt;/em&gt;.
     *
     * &lt;p&gt;The returned comparator is serializable and throws {@link
     * NullPointerException} when comparing {@code null}.
     *
     * @param  &lt;T&gt; the {@link Comparable} type of element to be compared
     * @return a comparator that imposes the reverse of the &lt;i&gt;natural
     *         ordering&lt;/i&gt; on {@code Comparable} objects.
     * @see Comparable
     * @since 1.8
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; reverseOrder() {
        return Collections.reverseOrder();
    }

    /**
     * Returns a comparator that compares {@link Comparable} objects in natural
     * order.
     *
     * &lt;p&gt;The returned comparator is serializable and throws {@link
     * NullPointerException} when comparing {@code null}.
     *
     * @param  &lt;T&gt; the {@link Comparable} type of element to be compared
     * @return a comparator that imposes the &lt;i&gt;natural ordering&lt;/i&gt; on {@code
     *         Comparable} objects.
     * @see Comparable
     * @since 1.8
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; naturalOrder() {
        return (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE;
    }

    /**
     * Returns a null-friendly comparator that considers {@code null} to be
     * less than non-null. When both are {@code null}, they are considered
     * equal. If both are non-null, the specified {@code Comparator} is used
     * to determine the order. If the specified comparator is {@code null},
     * then the returned comparator considers all non-null values to be equal.
     *
     * &lt;p&gt;The returned comparator is serializable if the specified comparator
     * is serializable.
     *
     * @param  &lt;T&gt; the type of the elements to be compared
     * @param  comparator a {@code Comparator} for comparing non-null values
     * @return a comparator that considers {@code null} to be less than
     *         non-null, and compares non-null objects with the supplied
     *         {@code Comparator}.
     * @since 1.8
     */
    public static &lt;T&gt; Comparator&lt;T&gt; nullsFirst(Comparator&lt;? super T&gt; comparator) {
        return new Comparators.NullComparator&lt;&gt;(true, comparator);
    }

    /**
     * Returns a null-friendly comparator that considers {@code null} to be
     * greater than non-null. When both are {@code null}, they are considered
     * equal. If both are non-null, the specified {@code Comparator} is used
     * to determine the order. If the specified comparator is {@code null},
     * then the returned comparator considers all non-null values to be equal.
     *
     * &lt;p&gt;The returned comparator is serializable if the specified comparator
     * is serializable.
     *
     * @param  &lt;T&gt; the type of the elements to be compared
     * @param  comparator a {@code Comparator} for comparing non-null values
     * @return a comparator that considers {@code null} to be greater than
     *         non-null, and compares non-null objects with the supplied
     *         {@code Comparator}.
     * @since 1.8
     */
    public static &lt;T&gt; Comparator&lt;T&gt; nullsLast(Comparator&lt;? super T&gt; comparator) {
        return new Comparators.NullComparator&lt;&gt;(false, comparator);
    }

    /**
     * Accepts a function that extracts a sort key from a type {@code T}, and
     * returns a {@code Comparator&lt;T&gt;} that compares by that sort key using
     * the specified {@link Comparator}.
      *
     * &lt;p&gt;The returned comparator is serializable if the specified function
     * and comparator are both serializable.
     *
     * @apiNote
     * For example, to obtain a {@code Comparator} that compares {@code
     * Person} objects by their last name ignoring case differences,
     *
     * &lt;pre&gt;{@code
     *     Comparator&lt;Person&gt; cmp = Comparator.comparing(
     *             Person::getLastName,
     *             String.CASE_INSENSITIVE_ORDER);
     * }&lt;/pre&gt;
     *
     * @param  &lt;T&gt; the type of element to be compared
     * @param  &lt;U&gt; the type of the sort key
     * @param  keyExtractor the function used to extract the sort key
     * @param  keyComparator the {@code Comparator} used to compare the sort key
     * @return a comparator that compares by an extracted key using the
     *         specified {@code Comparator}
     * @throws NullPointerException if either argument is null
     * @since 1.8
     */
    public static &lt;T, U&gt; Comparator&lt;T&gt; comparing(
            Function&lt;? super T, ? extends U&gt; keyExtractor,
            Comparator&lt;? super U&gt; keyComparator)
    {
        Objects.requireNonNull(keyExtractor);
        Objects.requireNonNull(keyComparator);
        return (Comparator&lt;T&gt; &amp; Serializable)
            (c1, c2) -&gt; keyComparator.compare(keyExtractor.apply(c1),
                                              keyExtractor.apply(c2));
    }

    /**
     * Accepts a function that extracts a {@link java.lang.Comparable
     * Comparable} sort key from a type {@code T}, and returns a {@code
     * Comparator&lt;T&gt;} that compares by that sort key.
     *
     * &lt;p&gt;The returned comparator is serializable if the specified function
     * is also serializable.
     *
     * @apiNote
     * For example, to obtain a {@code Comparator} that compares {@code
     * Person} objects by their last name,
     *
     * &lt;pre&gt;{@code
     *     Comparator&lt;Person&gt; byLastName = Comparator.comparing(Person::getLastName);
     * }&lt;/pre&gt;
     *
     * @param  &lt;T&gt; the type of element to be compared
     * @param  &lt;U&gt; the type of the {@code Comparable} sort key
     * @param  keyExtractor the function used to extract the {@link
     *         Comparable} sort key
     * @return a comparator that compares by an extracted key
     * @throws NullPointerException if the argument is null
     * @since 1.8
     */
    public static &lt;T, U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; comparing(
            Function&lt;? super T, ? extends U&gt; keyExtractor)
    {
        Objects.requireNonNull(keyExtractor);
        return (Comparator&lt;T&gt; &amp; Serializable)
            (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));
    }

    /**
     * Accepts a function that extracts an {@code int} sort key from a type
     * {@code T}, and returns a {@code Comparator&lt;T&gt;} that compares by that
     * sort key.
     *
     * &lt;p&gt;The returned comparator is serializable if the specified function
     * is also serializable.
     *
     * @param  &lt;T&gt; the type of element to be compared
     * @param  keyExtractor the function used to extract the integer sort key
     * @return a comparator that compares by an extracted key
     * @see #comparing(Function)
     * @throws NullPointerException if the argument is null
     * @since 1.8
     */
    public static &lt;T&gt; Comparator&lt;T&gt; comparingInt(ToIntFunction&lt;? super T&gt; keyExtractor) {
        Objects.requireNonNull(keyExtractor);
        return (Comparator&lt;T&gt; &amp; Serializable)
            (c1, c2) -&gt; Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2));
    }

    /**
     * Accepts a function that extracts a {@code long} sort key from a type
     * {@code T}, and returns a {@code Comparator&lt;T&gt;} that compares by that
     * sort key.
     *
     * &lt;p&gt;The returned comparator is serializable if the specified function is
     * also serializable.
     *
     * @param  &lt;T&gt; the type of element to be compared
     * @param  keyExtractor the function used to extract the long sort key
     * @return a comparator that compares by an extracted key
     * @see #comparing(Function)
     * @throws NullPointerException if the argument is null
     * @since 1.8
     */
    public static &lt;T&gt; Comparator&lt;T&gt; comparingLong(ToLongFunction&lt;? super T&gt; keyExtractor) {
        Objects.requireNonNull(keyExtractor);
        return (Comparator&lt;T&gt; &amp; Serializable)
            (c1, c2) -&gt; Long.compare(keyExtractor.applyAsLong(c1), keyExtractor.applyAsLong(c2));
    }

    /**
     * Accepts a function that extracts a {@code double} sort key from a type
     * {@code T}, and returns a {@code Comparator&lt;T&gt;} that compares by that
     * sort key.
     *
     * &lt;p&gt;The returned comparator is serializable if the specified function
     * is also serializable.
     *
     * @param  &lt;T&gt; the type of element to be compared
     * @param  keyExtractor the function used to extract the double sort key
     * @return a comparator that compares by an extracted key
     * @see #comparing(Function)
     * @throws NullPointerException if the argument is null
     * @since 1.8
     */
    public static&lt;T&gt; Comparator&lt;T&gt; comparingDouble(ToDoubleFunction&lt;? super T&gt; keyExtractor) {
        Objects.requireNonNull(keyExtractor);
        return (Comparator&lt;T&gt; &amp; Serializable)
            (c1, c2) -&gt; Double.compare(keyExtractor.applyAsDouble(c1), keyExtractor.applyAsDouble(c2));
    }
}
</pre>
</body>
</html>
